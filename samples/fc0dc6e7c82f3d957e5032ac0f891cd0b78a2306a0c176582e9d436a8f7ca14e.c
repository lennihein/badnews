//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <netdb.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <windows.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;
typedef int64_t int224_t;
typedef int64_t int864_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float80_t;

// ------------------------ Structures ------------------------

struct hostent {
    char * e0;
    char ** e1;
    int16_t e2;
    int16_t e3;
    char ** e4;
};

// ------------------- Function Prototypes --------------------

int32_t Activate(int32_t a1);
int32_t DllCanUnloadNow(void);
int32_t DllGetClassObject(void);
int32_t entry_point(int32_t a1);
int32_t function_1000100b(void);
int32_t function_10001021(void);
int32_t function_10001043(void);
int32_t function_10001098(int32_t a1, int32_t a2);
int32_t function_1000111b(int32_t a1);
int32_t function_10001322(int32_t a1);
int32_t function_1000132a(void);
int32_t function_10001373(void);
int32_t function_10001383(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t * a9);
int32_t function_1000139c(void);
int32_t function_100013a8(void);
int32_t function_100013af(void);
int32_t function_100013b1(int32_t a1, int32_t a2);
int32_t function_10001467(void);
int32_t function_100014e8(int32_t a1);
int32_t function_10001549(void);
int32_t function_1000156b(void);
int32_t function_10001577(void);
int32_t function_100015ab(void);
int32_t function_100015da(void);
int32_t function_100015fb(void);
int32_t function_10001639(void);
int32_t function_10001672(void);
int32_t function_1000167a(int32_t a1);
int32_t function_100016ec(void);
int32_t function_10001730(int16_t a1);
int32_t function_100017b2(void);
int32_t function_100017b5(void);
int32_t function_100017d0(void);
int32_t function_100017f5(int32_t a1, int32_t a2);
int32_t function_10001829(void);
int32_t function_10001854(int32_t a1);
int32_t function_1000187c(void);
int32_t function_10001885(void);
int32_t function_10001aaf(int32_t a1);
int32_t function_10001abd(int32_t a1);
int32_t function_10001b24(void);
int32_t function_10001b52(void);
int32_t function_10001b57(void);
int32_t function_10001b77(int32_t a1);
int32_t function_10001b93(void);
int32_t function_10001bb7(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5, int32_t a6, uint32_t a7);
int32_t function_10001c19(void);
int32_t function_10001c2b(void);
int32_t function_10001c42(int32_t a1);
int32_t function_10001ca9(void);
int32_t function_10001cbc(int32_t a1, int32_t a2);
int32_t function_10001d9a(int32_t a1, int32_t a2, uint32_t a3, uint32_t a4, int32_t a5, int32_t a6);
int32_t function_10001e08(int32_t a1);
int32_t function_10001e4a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10001f46(int16_t a1);
int32_t function_10001faa(void);
int32_t function_1000200a(int32_t a1, int32_t a2);
int32_t function_10002013(void);
int32_t function_10002038(void);
int32_t function_10002080(void);
int32_t function_100020a9(void);
int32_t function_100020ad(void);
int32_t function_100020af(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_100020b4(int32_t a1, int32_t a2);
int32_t function_100023b2(int16_t a1);
int32_t function_1000242f(void);
int32_t function_10002448(int32_t a1, int32_t a2);
int32_t function_100024a9(void);
int32_t function_100024b8(void);
int32_t function_100024d6(void);
int32_t function_10002544(void);
int32_t function_10002588(int32_t a1);
int32_t function_100025b7(void);
int32_t function_100025de(void);
int32_t function_100025f1(int32_t a1);
int32_t function_10002617(int32_t a1);
int32_t function_100026ae(void);
int32_t function_100026b6(void);
int32_t function_100026dd(void);
int32_t function_100026e6(void);
int32_t function_1000288d(void);
int32_t function_100028ad(int32_t a1);
int32_t function_100028ce(int32_t a1);
int32_t function_100028d2(void);
int32_t function_10002916(void);
int32_t function_10002921(void);
int32_t function_1000294c(void);
int32_t function_10002951(void);
int32_t function_10002995(char a1, int32_t a2);
int32_t function_100029cd(int16_t a1, int32_t a2, int32_t a3);
int32_t function_10002a0a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_10002b24(void);
int32_t function_10002b33(void);
int32_t function_10002b34(void);
int32_t function_10002b3f(void);
int32_t function_10002b46(int16_t a1, int32_t a2);
int32_t function_10002ba7(int32_t a1);
int32_t function_10002bbc(void);
int32_t function_10002bf7(int32_t a1);
int32_t function_10002c4c(void);
int32_t function_10002c5e(int32_t a1);
int32_t function_10002c7d(void);
int32_t function_10002cbf(void);
int32_t function_10002cc6(int32_t * a1);
int32_t function_10002d0e(int32_t a1, int32_t a2);
int32_t function_10002d15(void);
int32_t function_10002d1b(void);
int32_t function_10002d72(int16_t a1);
int32_t function_10002e10(int32_t a1);
int32_t function_10002e50(void);
int32_t function_10002e8a(void);
int32_t function_10002ebd(int32_t a1);
int32_t function_10002ee6(int32_t a1);
int32_t function_10002efc(void);
float80_t function_10002f22(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10002ffa(void);
int32_t function_1000301a(void);
int32_t function_10003050(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_100030c1(void);
int32_t function_100030f5(int32_t a1);
int32_t function_10003105(void);
int32_t function_1000314b(void);
int32_t function_10003155(void);
int32_t function_100031aa(void);
int32_t function_100031ba(void);
int32_t function_100031bc(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_1000322b(void);
int32_t function_10003248(int32_t a1);
int32_t function_100032b9(void);
int32_t function_10003303(void);
int32_t function_10003343(int32_t a1);
int32_t function_1000336f(int32_t a1);
int32_t function_100033a8(void);
int32_t function_100033cd(void);
int32_t function_10003432(void);
int32_t function_1000343b(void);
int32_t function_100034eb(void);
int32_t function_1000354b(void);
int32_t function_1000361a(void);
int32_t function_10003620(void);
int32_t function_10003638(void);
int32_t function_1000365f(void);
int32_t function_10003686(int16_t a1);
int32_t function_10003732(int16_t a1);
int32_t function_1000373d(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_1000377d(void);
int32_t function_10003787(void);
int32_t function_1000379c(void);
int32_t function_100037b7(void);
int32_t function_1000385e(int32_t a1);
int32_t function_10003871(void);
int32_t function_1000399d(void);
int32_t function_100039ae(void);
int32_t function_100039d2(void);
int32_t function_100039ee(int32_t a1);
int32_t function_10003a3a(void);
int32_t function_10003ad3(void);
int32_t function_10003b0b(void);
int32_t function_10003b34(void);
int32_t function_10003b54(int32_t a1);
int32_t function_10003b68(void);
int32_t function_10003b6d(void);
int32_t function_10003b76(int32_t a1);
int32_t function_10003b7f(void);
int32_t function_10003b86(int32_t a1);
int32_t function_10003c22(void);
int32_t function_10003c33(void);
int32_t function_10003c46(void);
int32_t function_10003c4f(void);
int32_t function_10003c60(int16_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_10003d74(void);
int32_t function_10003da8(void);
int32_t function_10003e15(void);
int32_t function_10003e1d(void);
int32_t function_10003e2f(int32_t a1);
int32_t function_10003e38(void);
int32_t function_10003e64(int32_t a1);
int32_t function_100041b1(void);
int32_t function_100041ba(void);
int32_t function_100041bf(void);
int32_t function_100041d2(int16_t a1);
int32_t function_1000424d(int32_t a1);
int32_t function_100043f9(void);
int32_t function_10004414(int32_t a1);
int32_t function_10004432(int16_t a1);
int32_t function_100044f9(void);
int32_t function_10004508(int32_t a1);
int32_t function_10004517(void);
int32_t function_10004528(int32_t a1);
int32_t function_10004574(void);
int32_t function_1000457a(int32_t a1);
int32_t function_10004592(int32_t a1, int32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_1000462b(void);
int32_t function_1000463c(int32_t a1);
int32_t function_10004723(void);
int32_t function_10004755(void);
float80_t function_10004757(void);
int32_t function_1000479d(void);
int32_t function_10004851(int32_t a1);
int32_t function_100048d8(void);
int32_t function_1000491c(int32_t a1);
int32_t function_10004932(void);
int32_t function_1000496e(int32_t a1);
int32_t function_10004a1c(int16_t a1);
int32_t function_10004a51(void);
int32_t function_10004abb(int32_t a1);
int32_t function_10004ac7(void);
int32_t function_10004ace(void);
int32_t function_10004ae1(void);
int32_t function_10004af5(void);
int32_t function_10004b14(int32_t a1);
int32_t function_10004b2e(void);
int32_t function_10004b4a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10004b71(int32_t a1);
int32_t function_10004bb4(void);
int32_t function_10004c02(int32_t a1);
int32_t function_10004c0f(void);
int32_t function_10004c17(int32_t a1);
int32_t function_10004c2e(int16_t a1, int32_t a2);
int32_t function_10004d92(int16_t a1, int32_t a2);
int32_t function_10004e56(void);
int32_t function_10004e58(void);
int32_t function_10004e7d(int32_t a1);
int32_t function_10004eda(void);
int32_t function_10004edf(void);
int32_t function_10004f05(int32_t a1);
int32_t function_10004fb4(void);
int32_t function_10004fc6(int32_t a1);
int32_t function_10004fc9(int32_t a1, int32_t a2);
int32_t function_10005022(void);
int32_t function_10005030(void);
int32_t function_10005052(void);
int32_t function_10005057(void);
int32_t function_1000508a(int32_t a1, int32_t a2);
int32_t function_100050b6(int32_t a1, int32_t a2);
int32_t function_100050d7(int32_t a1);
int32_t function_100051a5(int32_t a1);
int32_t function_100051cc(void);
int32_t function_1000531e(int32_t a1);
int32_t function_10005325(int32_t a1);
int32_t function_1000532c(int32_t a1);
int32_t function_1000532f(void);
float80_t function_10005353(int32_t a1);
int32_t function_1000535a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_100053f2(void);
int32_t function_10005455(void);
int32_t function_1000545a(void);
int32_t function_1000546f(int32_t a1);
int32_t function_1000551a(int32_t a1);
int32_t function_100055db(void);
int32_t function_10005606(void);
int32_t function_10005608(void);
int32_t function_10005609(int32_t a1, int32_t a2);
int32_t function_100056d5(void);
int32_t function_100056de(int32_t a1);
int32_t function_100056f3(void);
int32_t function_100056f5(void);
int32_t function_100056f8(void);
int32_t function_1000570f(int32_t a1);
int32_t function_10005734(int32_t a1);
int32_t function_10005772(void);
int32_t function_10005773(int32_t a1);
int32_t function_1000578f(int32_t a1);
int32_t function_100057b0(void);
int32_t function_100057c8(void);
int32_t function_100057df(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_10005811(void);
int32_t function_10005837(void);
int32_t function_10005897(void);
int32_t function_100058a0(void);
int32_t function_100058ad(void);
int32_t function_100058e4(void);
int32_t function_100058e6(void);
int32_t function_100058e8(int32_t a1);
int32_t function_100058fe(int32_t a1);
int32_t function_100059dc(void);
int32_t function_10005a71(int32_t a1, int32_t a2);
int32_t function_10005ac0(void);
int32_t function_10005ac3(int32_t a1);
struct hostent * function_10005aea(char * addr, int32_t len, int32_t type);
int32_t function_10005b05(void);
int32_t function_1000f000(int32_t a1);
int32_t function_1000f06f(int32_t a1);
int32_t function_1000f0d5(void);
int32_t function_1000f0dd(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1000f401(void);
int32_t function_1000f405(void);
int32_t function_1000f419(void);
int32_t function_1000f44a(void);
int32_t function_1000f456(int32_t a1, int32_t a2);
int32_t function_1000f479(void);
int32_t function_1000f481(void);
int32_t function_1000f482(void);
int32_t function_1000f4b1(void);
int32_t function_1000f4c6(void);
int32_t function_1000f4eb(int32_t a1);
int32_t function_1000f50e(void);
int32_t function_1000f55e(int32_t a1);
int32_t function_1000f5ce(int32_t a1);
int32_t function_1000f5f2(void);
int32_t function_1000f632(void);
int32_t function_1000f64c(void);
int32_t function_1000f6f8(int32_t a1);
int32_t function_1000f72a(int32_t result, int32_t a2);
int32_t function_1000f7c5(int16_t a1, int32_t a2);
int32_t function_1000f7cd(int32_t a1);
int32_t function_1000f80b(void);
int32_t function_1000f817(int32_t a1);
int32_t function_1000f81d(int32_t a1);
int32_t function_1000f906(void);
int32_t function_1000f925(void);
int32_t function_1000f944(void);
int32_t function_1000f96a(void);
int32_t function_1000f9b3(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_1000fad0(void);
int32_t function_1000fae0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_1000fb19(void);
int32_t function_1000fb46(void);
int32_t function_1000fb4e(int32_t a1, int32_t a2);
int32_t function_1000fc9d(int32_t a1);
int32_t function_1000fdf3(void);
int32_t function_1000fe08(void);
int32_t function_1000fe17(int32_t a1);
int32_t function_1000fe1d(void);
int32_t function_1000fe70(int32_t result, int32_t a2);
int32_t function_13cf632b(void);
int32_t function_156e638a(void);
int32_t function_194b8e18(void);
int32_t function_1a054105(void);
int32_t function_1b7c7a9c(void);
int32_t function_20004389(void);
int32_t function_20011b4a(void);
int32_t function_250a2048(void);
int32_t function_2823af96(void);
int32_t function_2bc0b70f(void);
int32_t function_2e6e678a(void);
int32_t function_31b0023a(void);
int32_t function_34b9a97b(void);
int32_t function_34d67382(void);
int32_t function_38ef82c2(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_4c53012a(char a1);
int32_t function_4c5306d4(void);
int32_t function_4f4705ff(void);
int32_t function_5812ebe8(void);
int32_t function_59a094e2(void);
int32_t function_59ec125e(void);
int32_t function_5cb9a97b(void);
int32_t function_638f0c83(void);
int32_t function_662b4dd6(void);
int32_t function_6eea93c6(void);
int32_t function_724b2866(void);
int32_t function_76c44af5(void);
int32_t function_76ce0d83(int32_t a1);
int32_t function_792c82ca(void);
int32_t function_7ae8ac7b(void);
int32_t function_804ec438(void);
int32_t function_826e4b8a(void);
int32_t function_82c00b4a(void);
int32_t function_82c07b4a(void);
int32_t function_82c0e74a(void);
int32_t function_82c2774a(void);
int32_t function_82c35f4a(void);
int32_t function_850a14c6(void);
int32_t function_860e752d(void);
int32_t function_887ff032(void);
int32_t function_89c8b28b(void);
int32_t function_8e140c55(void);
int32_t function_8fa93699(void);
int32_t function_938aaf2d(void);
int32_t function_98115606(void);
int32_t function_99ec2826(int16_t a1);
int32_t function_9b59eb7c(void);
int32_t function_9dd14627(void);
int32_t function_a6ac3c7b(void);
int32_t function_a700e3d4(void);
int32_t function_a9a42bcf(void);
int32_t function_ab3626a2(int32_t a1);
int32_t function_ac770516(void);
int32_t function_b1fc5741(void);
int32_t function_b39003fa(void);
int32_t function_b4360ac2(void);
int32_t function_b5f8a065(void);
int32_t function_b6fce7ee(void);
int32_t function_c3024dda(void);
int32_t function_c782bb45(int16_t a1);
int32_t function_c90d0b57(void);
int32_t function_ce235ce3(void);
int32_t function_d4ac3cfd(void);
int32_t function_d4bc725f(int16_t a1);
int32_t function_d4ce28ce(void);
int32_t function_d4eaf4e8(int32_t a1);
int32_t function_d4eafac3(int32_t a1);
int32_t function_d6c0a0d0(int32_t a1);
int32_t function_d81bbc05(void);
int32_t function_d81c0bff(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_d8458d0c(void);
int32_t function_d933c1ec(void);
int32_t function_dcef8262(void);
int32_t function_df0d09de(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_e05061f4(void);
int32_t function_e0b4d242(void);
int32_t function_e99a084a(void);
int32_t function_f06e538a(void);
int32_t function_f06e7f8a(void);
int32_t function_f06eaf8a(void);
int32_t function_f50ace15(void);
int32_t function_f56e738a(void);
int32_t function_f5804983(void);
int32_t function_f88b5e19(int32_t a1);
int32_t function_f98150ec(void);
int32_t function_faf63c48(int32_t a1, int32_t a2, int16_t a3);
int32_t function_faf648fe(void);
int32_t function_fb12c512(void);
int32_t function_fc75ff0d(void);
int32_t function_fffffaff(void);
int32_t HookProc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t Logoff(void);
int32_t Logon(void);
int32_t Start(int32_t a1);
int32_t unknown_10626329(int32_t a1, int32_t a2);
int32_t unknown_15024c98(void);
int32_t unknown_15103567(int32_t a1);
int32_t unknown_17b84747(int16_t a1);
int32_t unknown_1a053d18(void);
int32_t unknown_1bac4bd0(void);
int32_t unknown_2708b749(void);
int32_t unknown_2afbb8f9(int16_t a1);
int32_t unknown_38c358ca(void);
int32_t unknown_4310357f(void);
int32_t unknown_49e6d3(void);
int32_t unknown_4aab5bcf(void);
int32_t unknown_50c5be5a(void);
int32_t unknown_54102a25(int16_t a1);
int32_t unknown_5fb1354(void);
int32_t unknown_631c1e(void);
int32_t unknown_64092a0e(void);
int32_t unknown_6f101d71(void);
int32_t unknown_8df2dc5b(void);
int32_t unknown_8fbf4f64(void);
int32_t unknown_900046d1(int32_t a1);
int32_t unknown_9000b4d3(void);
int32_t unknown_988e2202(void);
int32_t unknown_9ac3cd4(void);
int32_t unknown_9c0a0d0(void);
int32_t unknown_9fba9d4(void);
int32_t unknown_a0203e(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_a0383e(void);
int32_t unknown_a05c3e(void);
int32_t unknown_a0b83e(void);
int32_t unknown_a0c43e(int16_t a1);
int32_t unknown_a18c3e(void);
int32_t unknown_a1c43e(int32_t a1);
int32_t unknown_a30c4b(void);
int32_t unknown_a56659ce(void);
int32_t unknown_afe0ff2(void);
int32_t unknown_afe14f8(void);
int32_t unknown_afe1c5e(int16_t a1);
int32_t unknown_afe270e(int16_t * a1);
int32_t unknown_b9dc48(void);
int32_t unknown_c4957b04(void);
int32_t unknown_ca103461(void);
int32_t unknown_cb9c0c4d(int32_t a1);
int32_t unknown_d36eca05(int16_t a1);
int32_t unknown_d6cd6030(int16_t a1);
int32_t unknown_d77d222(void);
int32_t unknown_d8b46382(void);
int32_t unknown_dff3907(void);
int32_t unknown_e313ca5b(void);
int32_t unknown_f0059aa(int32_t a1);
int32_t unknown_f103573(void);
int32_t unknown_f55505(void);
int32_t unknown_f60ca9c(void);
int32_t unknown_f7ce0d60(int16_t a1);
int32_t unknown_fb3fb48f(int16_t a1);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x10006004
char * g2; // 0x10006020
int32_t g3 = 0; // 0x10006128
char * g4; // 0x100062e4
int32_t g5 = 0; // 0x100062e8
int32_t g6 = 0; // 0x10006300
int32_t g7 = 0; // 0x10006310
char * g8; // 0x10006314
float80_t * g9 = NULL; // 0x10006328
char g10 = 0; // 0x10009470
int32_t g11 = -0x4a7a6252; // 0x1000a2e4
int32_t g12 = 0x4e6c6c44; // 0x1000a48c
int16_t g13 = 2988; // 0x1000ad98
int32_t g14 = 0x54464f53; // 0x1000b72c
char * g15 = "\x85\x33\xbfv=%x_%y] r3Lk\x89*\x95\x12\xf1\xbc\x03S\xa6\xc0\x1bM\xc8\x9d\xb7\xf5\x90r\xe9_%02i_$27c0XV\x89*\x9c\x43\xbf\xa6ZZ\xea\xec\x18\v\xc7\xd1\x90\x8f\x85\x38\xdf%x&g=%r$q70\x1b\x62\xc5\x06\x96V\xfe\xf0lB\xff\xadW\"\xdf\xc4\xda\xb9\xff\x65\xb0\x32i&d=%h'v,t\x16s\xc5Y\xb3\x66\xea\xea\x0eV\xcf\x9f>}\xdc\x99\xd5\xe1\xa0@\x80"; // 0x1000b768
int32_t g16 = -0x597e7956; // 0x1000b924
int32_t g17 = 0x66b359ad; // 0x1000ba58
char g18 = 1; // 0x1000d000
char * g19; // 0x1000d0b0
int32_t g20 = 0; // 0x1000d0b8
int32_t g21 = -256; // 0x1000d0c7
int32_t g22;

// ------------------------ Functions -------------------------

// Address range: 0x1000100b - 0x1000100e
int32_t function_1000100b(void) {
    // 0x1000100b
    int32_t result; // 0x1000100b
    return result;
}

// Address range: 0x10001021 - 0x1000102b
int32_t function_10001021(void) {
    // 0x10001021
    return function_a9a42bcf();
}

// Address range: 0x10001043 - 0x10001098
int32_t function_10001043(void) {
    // 0x10001043
    int32_t v1; // 0x10001043
    unsigned char v2 = (char)v1;
    char v3 = v2 / 128; // 0x10001043
    *(char *)v1 = v3 | 2 * v2;
    int32_t v4; // 0x10001043
    char * v5 = (char *)(v4 - 0x38ba9924); // 0x10001045
    uint32_t v6; // 0x10001043
    char v7 = v6; // 0x10001045
    *v5 = (char)(v3 != 0) + v7 + *v5;
    int32_t v8; // 0x10001043
    unsigned char v9 = *(char *)&v8; // 0x1000104b
    char v10 = v9 / 128; // 0x1000104b
    *(char *)v8 = v10 | 2 * v9;
    int32_t v11; // 0x10001043
    unsigned char v12 = *(char *)&v11; // 0x1000104d
    unsigned char v13 = v12 + (char)v8; // 0x1000104d
    unsigned char v14 = v13 + (char)(v10 != 0); // 0x1000104d
    *(char *)v11 = v14;
    int32_t v15 = unknown_15024c98(); // 0x1000104f
    int32_t v16; // 0x10001043
    *(int32_t *)v16 = v15;
    int32_t v17 = v15 - (v10 != 0 ? v14 <= v12 : v13 < v12 ? 97 : 96); // 0x10001055
    int32_t v18 = v17 & 255 | v15 & -256; // 0x10001055
    char * v19 = (char *)v18; // 0x10001057
    unsigned char v20 = *v19; // 0x10001057
    int32_t v21; // 0x10001043
    char v22 = v21; // 0x10001057
    unsigned char v23 = v20 + v22; // 0x10001057
    *v19 = v23;
    __asm_bound(*(int64_t *)(v18 + 19));
    unsigned char v24 = (char)v17; // 0x1000105d
    bool v25 = v23 < v20 ? v24 + 118 + (char)(v23 < v20) <= v24 : v24 > 137; // 0x1000105d
    __asm_hlt();
    int32_t v26 = __asm_in_2(152); // 0x10001068
    char * v27 = (char *)(v6 + 106); // 0x1000106a
    *v27 = 2 * *v27 | (char)v25;
    int32_t * v28 = (int32_t *)(v6 - 1); // 0x1000106d
    uint32_t v29 = *v28; // 0x1000106d
    uint32_t v30 = v29 + v21; // 0x1000106d
    *v28 = v30;
    int32_t v31 = v26 + 0x1000a064 + (int32_t)(v30 < v29); // 0x10001070
    char * v32 = (char *)v31; // 0x10001076
    *v32 = v22 + v7;
    __asm_fldenv(*(int224_t *)(v31 - 96));
    unsigned char v33 = *v32; // 0x1000107f
    char v34 = v31 >> 31; // 0x1000107f
    unsigned char v35 = v33 + v34; // 0x1000107f
    *v32 = v35;
    int32_t v36 = v31 - (v35 < v33 ? 97 : 96) & 255 | v31 & -256; // 0x10001081
    v8 = v36;
    char * v37 = (char *)v36; // 0x10001084
    unsigned char v38 = *v37; // 0x10001084
    unsigned char v39 = v38 + v34; // 0x10001084
    *v37 = v39;
    *(int32_t *)v6 = v6 / 16 | 0x20000000 * v6 | 0x10000000 * (int32_t)(v39 < v38);
    return unknown_f55505();
}

// Address range: 0x10001098 - 0x100010d2
int32_t function_10001098(int32_t a1, int32_t a2) {
    int32_t v1 = a1;
    int32_t v2; // 0x10001098
    char v3 = v2;
    int32_t v4; // 0x10001098
    *(char *)v2 = v3 + (char)v4;
    int32_t v5; // 0x10001098
    char * v6 = (char *)(v5 + 0x6ff15097); // 0x1000109a
    *v6 = *v6 & -49;
    unsigned char v7 = v3 + 114; // 0x100010a1
    int32_t v8 = v2 & -256; // 0x100010a1
    int32_t v9 = v1; // 0x100010a3
    uint16_t v10 = (int16_t)(v8 | (int32_t)v7); // 0x100010a4
    uint16_t v11 = (int16_t)*(char *)(v9 + 33); // 0x100010a4
    v1 = -0x7f7fff5d;
    if (v7 == 0) {
        // 0x100010cf
        return (v8 | (int32_t)(v10 / v11)) & -0xff01 | (int32_t)(256 * (v10 % v11));
    }
    // 0x100010ae
    int32_t v12; // 0x10001098
    uint32_t v13 = *(int32_t *)(v12 + 26); // 0x100010b2
    int32_t v14; // 0x10001098
    int32_t * v15 = (int32_t *)(v14 - 0x33372313); // 0x100010b9
    *v15 = *v15 - ((int32_t)(v13 < 0x27595f15) | (int32_t)&v1);
    __asm_outsb((int16_t)v4, *(char *)&v5);
    unsigned char v16 = (char)v14 - 31; // 0x100010c3
    int32_t result = v14 & -256 | (int32_t)v16; // 0x100010c6
    if (v16 != 0 && v9 != 1) {
        result = function_1000111b((int32_t)&g22);
    }
    int32_t * v17 = (int32_t *)(result + 56); // 0x100010c8
    *v17 = *v17 - 0x7fffbffb;
    // 0x100010cf
    return result;
}

// Address range: 0x100010e6 - 0x100010f4
int32_t DllCanUnloadNow(void) {
    // 0x100010e6
    int32_t v1; // 0x100010e6
    float80_t v2; // 0x100010e6
    *(int32_t *)v1 = (int32_t)v2;
    int32_t v3 = v1 & -256; // 0x100010ea
    char * v4 = (char *)(v1 + 96 & 255 | v3); // 0x100010ec
    char v5 = *v4; // 0x100010ec
    char v6 = v1 >> 31; // 0x100010ec
    char v7 = v5 + v6; // 0x100010ec
    *v4 = v7;
    return v3 | (int32_t)(v7 < 0 == ((v7 ^ v5) & (v7 ^ v6)) < 0 == (v7 != 0));
}

// Address range: 0x1000111b - 0x10001321
int32_t function_1000111b(int32_t a1) {
    // 0x1000111b
    int32_t v1; // 0x1000111b
    int16_t v2 = v1; // 0x1000111b
    int32_t v3 = __asm_in_3(v2); // 0x1000111b
    int32_t v4; // 0x1000111b
    uint32_t v5; // 0x1000111b
    *(char *)(v4 - 0x6cf01bc9) = (char)(v5 / 256);
    int32_t v6; // 0x1000111b
    __asm_outsb(v2, *(char *)&v6);
    unsigned char v7 = *(char *)-0x7b7df000; // 0x10001126
    int32_t v8 = v7; // 0x10001126
    int32_t v9 = v3 & -256; // 0x10001126
    char * v10 = (char *)(v6 - 117); // 0x1000112b
    char v11 = *v10; // 0x1000112b
    char v12 = v1; // 0x1000112b
    char v13 = v11 + v12; // 0x1000112b
    *v10 = v13;
    int32_t v14; // 0x1000111b
    int32_t v15; // 0x1000111b
    if (v13 != 0) {
        char * v16 = (char *)(v6 - 113); // 0x10001130
        char v17 = *v16 | v12; // 0x10001130
        char v18 = llvm_ctpop_i8(v17); // 0x10001130
        *v16 = v17;
        if ((v18 & 1) == 0) {
            // 0x10001135
            *(char *)v14 = __asm_insb(v2 + 1);
            return v3 & -0x10000 | (int32_t)(v7 % 67) | 256 * (int32_t)(v7 / 67);
        }
        int32_t result2 = v9 | v8; // 0x10001126
        char * v19 = (char *)(v15 + 89); // 0x1000113b
        unsigned char v20 = *v19; // 0x1000113b
        unsigned char v21 = v20 + (char)v15; // 0x1000113b
        *v19 = v21;
        int32_t v22; // 0x1000111b
        if (v22 == 1 || v21 < v20) {
            int32_t v23 = result2 + 8 + v6; // 0x1000118b
            *(int32_t *)v15 = v23;
            int32_t result = v23 ^ v1 & 255; // 0x10001191
            __asm_out_4(v2, (char)result);
            return result;
        }
        // 0x10001141
        return result2;
    }
    int32_t v24 = v5 + 0x9800 & 0xff00 | v5 & -0xff01; // 0x10001123
    unsigned char v25 = *(char *)(v24 + v8); // 0x10001155
    unsigned char v26 = (char)v15 & 31; // 0x10001159
    if (v26 != 0) {
        char * v27 = (char *)(v14 + 48); // 0x10001159
        unsigned char v28 = *v27; // 0x10001159
        *v27 = v28 >> v26 | 1 << 8 - v26 | (char)((int16_t)v28 << (int16_t)(9 - v26));
    }
    bool v29 = v11 != 0 | v25 > 153;
    char v30 = v29 ? v25 - 96 : v25;
    unsigned char v31 = (v11 & 15) + (v12 & 15) > 15 | (v25 & 14) > 9 ? (v29 ? -102 : -6) + v25 : v30;
    int32_t result3 = v9 | (int32_t)v31;
    *(char *)v14 = *(char *)&v6;
    bool v32; // 0x1000111b
    int32_t v33 = v32 ? -1 : 1; // 0x1000115c
    v6 += v33;
    int32_t v34 = 0x601000ba; // bp-12, 0x1000115d
    if ((v5 & -v24) >= 0) {
        int32_t v35 = v24 - 1; // 0x10001162
        *(int32_t *)-0x6eb8917d = *(int32_t *)-0x6eb8917d & v35;
        __asm_arpl(*(int16_t *)(result3 + 0x3bb59b9e), (int16_t)v35);
        return v3 & -0x10000 | (int32_t)(v31 % 43) | 256 * (int32_t)(v31 / 43);
    }
    int32_t v36 = &v34; // 0x1000115d
    char * v37 = (char *)(result3 + 0x595940c5); // 0x10001167
    unsigned char v38 = *v37; // 0x10001167
    char v39 = 2 * v38; // 0x10001167
    *v37 = v39;
    if (v39 != 0) {
        // 0x1000116f
        *(int32_t *)(v24 + 1 - v36) = result3;
        return result3;
    }
    if ((v38 / 64 & 1) != v38 / 128) {
        // 0x10001197
        __asm_iretd();
        int32_t result4 = __asm_in_2(241); // 0x100011bc
        char * v40 = (char *)(v36 + 0x4d304000); // 0x100011c4
        *v40 = -*v40;
        return result4;
    }
    int32_t v41 = v33 + v14; // 0x1000115c
    int32_t v42 = 256 * v15 & 0xff00 ^ v1; // 0x100011e0
    __asm_arpl(*(int16_t *)(v4 - 0x144f3650), (int16_t)v42);
    *(char *)v41 = *(char *)v6;
    v6 += v33;
    *(int32_t *)v15 = v15 & 2;
    int32_t v43 = -52; // bp-16, 0x100011fb
    char * v44 = (char *)(v41 + v33);
    int32_t v45 = __asm_int1(); // 0x100011fd
    int32_t v46 = -0x29d4aaf8;
    int32_t v47 = &v43;
    int32_t v48 = v42;
    int32_t v49 = v45 + 96; // 0x100011fe
    int32_t v50 = v45 & -256; // 0x100011fe
    char * v51 = (char *)(v49 & 255 | v50); // 0x10001200
    char v52 = *v51; // 0x10001200
    char v53 = v48; // 0x10001200
    char v54 = v52 + v53; // 0x10001200
    *v51 = v54;
    int32_t v55; // 0x10001219
    while (v54 < 0 == ((v54 ^ v52) & (v54 ^ v53)) < 0) {
        // 0x10001205
        *(char *)0x555f1000 = (char)v49;
        *v44 = __asm_insb((int16_t)v48);
        int32_t v56 = (int32_t)*(char *)0x33c31000; // 0x1000120b
        uint32_t v57 = v50 | v56; // 0x1000120b
        int32_t v58 = v57 + 0x520f5181; // 0x10001213
        unsigned char v59 = (char)v58; // 0x10001218
        bool v60 = v57 > 0xadf0ae7e | v59 > 153;
        int32_t v61; // 0x1000111b
        if ((v56 & 15) == 15 || (v59 & 14) > 9) {
            v61 = (v60 ? 154 : 250) + v58 & 255 | v58 & -256;
        } else {
            v61 = (v60 ? v56 + 33 : v58) & 255 | v58 & -256;
        }
        int32_t v62; // 0x1000111b
        int32_t v63 = *(int32_t *)(2 * v46 - 0x3efff60 + v61) ^ v62; // 0x1000121c
        int32_t v64 = v47 - 4; // 0x1000122a
        *(int32_t *)v64 = -0xefff46;
        if (v63 == 0) {
            // 0x10001231
            return function_250a2048();
        }
        // 0x1000123d
        v55 = v61 >> 31;
        v45 = *(int32_t *)0x28f63c63 & -256 | (int32_t)__asm_in((int16_t)v55);
        int32_t v65 = *(int32_t *)v46; // 0x10001240
        int32_t * v66 = (int32_t *)v65;
        *(int32_t *)-0x3f528002 = *(int32_t *)-0x3f528002 / 512;
        v62 = v63;
        if (((v46 - v64 ^ v46) & (v46 ^ v64)) >= 0) {
            // 0x1000124b
            *v66 = (int32_t)&g17;
            goto lab_0x1000126f;
        }
        v46 = *v66;
        v47 = v65 + 4;
        v48 = v55;
        v49 = v45 + 96;
        v50 = v45 & -256;
        v51 = (char *)(v49 & 255 | v50);
        v52 = *v51;
        v53 = v48;
        v54 = v52 + v53;
        *v51 = v54;
    }
    int32_t * v67 = (int32_t *)v47; // 0x10001259
    int32_t v68 = *v67; // 0x10001259
    *v67 = 18;
    char v69 = (char)v49 | -64; // 0x10001260
    char v70 = v69 + 20; // 0x10001260
    if ((llvm_ctpop_i8(v70) & 1) != 0) {
        // 0x100012d1
        *(int32_t *)(v47 - 6) = -0x2defff5e;
        uint32_t v71 = __asm_sti(); // 0x100012da
        __asm_outsb((int16_t)v48, *(char *)v6);
        int32_t * v72 = (int32_t *)(v71 + 199 & 255 | v71 & -256); // 0x100012ee
        *v72 = *v72 + v68;
        char * v73 = (char *)(v48 + 0x5d811000); // 0x100012f0
        *v73 = *v73 & (char)(v71 / 256);
        __asm_in_2(93);
        __asm_in_2(235);
        __asm_wait();
        *(int32_t *)(v46 + 1) = v6;
        unknown_afe0ff2();
        *(int32_t *)(v46 - 3) = v68;
        int128_t v74; // 0x1000111b
        __asm_divps(v74, *(int128_t *)-0xdbb916a);
        *v44 = *v44 ^ (char)(v48 / 256) / 4;
        return __asm_iretd();
    }
    // 0x10001264
    if (v70 >= 0) {
        // 0x10001141
        return v50 | (int32_t)v70;
    }
    int32_t v75 = unknown_9000b4d3(); // 0x10001266
    char * v76 = (char *)(v6 + 93); // 0x1000126b
    *v76 = *v76 - ((v69 ^ -4) < 20 ? -61 : -62);
    v45 = v75;
    v55 = v48;
    goto lab_0x1000126f;
  lab_0x1000126f:;
    char * v77 = (char *)(v6 + 33); // 0x10001271
    unsigned char v78 = *v77; // 0x10001271
    *v77 = v78 - 14;
    int32_t v79 = *(int32_t *)(v45 - 90 + v55 + (int32_t)(v78 < 14)); // 0x10001277
    __asm_in_2(160);
    char * v80 = (char *)(v79 - 0xb7b88fb); // 0x10001282
    unsigned char v81 = *v80; // 0x10001282
    *v80 = v81 / 16 | 16 * v81;
    return function_e0b4d242();
}

// Address range: 0x10001322 - 0x1000132a
int32_t function_10001322(int32_t a1) {
    // 0x10001322
    int32_t v1; // 0x10001322
    int32_t v2; // 0x10001322
    *(char *)v1 = (char)v2;
    int32_t v3; // 0x10001322
    int32_t v4; // 0x10001322
    return v4 & -256 | (int32_t)__asm_in((int16_t)v3);
}

// Address range: 0x1000132a - 0x10001352
int32_t function_1000132a(void) {
    int32_t v1 = &g1; // bp-4, 0x1000132f
    __asm_int(19);
    int32_t v2 = &v1; // bp-8, 0x10001336
    int32_t v3; // 0x1000132a
    *(char *)0x734c1000 = (char)v3;
    int32_t v4 = v3 & -256 | (int32_t)*(char *)0x10b88734; // 0x10001348
    int32_t * v5 = (int32_t *)(5 * v4); // 0x1000134d
    *v5 = v4 + *v5;
    int32_t v6; // 0x1000132a
    int32_t v7; // 0x1000132a
    int32_t v8; // 0x1000132a
    int32_t v9; // 0x1000132a
    int32_t v10; // 0x1000132a
    int32_t result = function_10001383(v6, v7, v8, &v2, v9, v10, 0x441000a0, v3, (int32_t *)v2); // 0x10001350
    return result;
}

// Address range: 0x10001373 - 0x1000137c
int32_t function_10001373(void) {
    // 0x10001373
    int16_t v1; // 0x10001373
    return function_d4bc725f(v1);
}

// Address range: 0x10001383 - 0x10001398
int32_t function_10001383(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t * a9) {
    // 0x10001383
    int32_t v1; // 0x10001383
    int32_t v2; // 0x10001383
    *(int32_t *)v1 = __asm_insd((int16_t)v2);
    int32_t v3; // 0x10001383
    *(char *)0x64dc5bbf = (char)v3;
    bool v4; // 0x10001383
    return v3 + 0x1000a06c + (int32_t)v4;
}

// Address range: 0x1000139c - 0x1000139f
int32_t function_1000139c(void) {
    // 0x1000139c
    int32_t result; // 0x1000139c
    return result;
}

// Address range: 0x100013a8 - 0x100013af
int32_t function_100013a8(void) {
    // 0x100013a8
    return function_100013b1((int32_t)&g22, (int32_t)&g22);
}

// Address range: 0x100013af - 0x100013b1
int32_t function_100013af(void) {
    // 0x100013af
    int32_t result; // 0x100013af
    return result;
}

// Address range: 0x100013b1 - 0x100013b3
int32_t function_100013b1(int32_t a1, int32_t a2) {
    // 0x100013b1
    int32_t result; // 0x100013b1
    return result;
}

// Address range: 0x100013b6 - 0x10001465
int32_t DllGetClassObject(void) {
    // 0x100013b6
    int32_t v1; // 0x100013b6
    char * v2 = (char *)(v1 - 0x4766f000); // 0x100013b7
    unsigned char v3 = *v2; // 0x100013b7
    uint32_t v4; // 0x100013b6
    char v5 = v4 / 256; // 0x100013b7
    bool v6; // 0x100013b6
    char v7 = v6; // 0x100013b7
    unsigned char v8 = v3 + v5; // 0x100013b7
    char v9 = v8 + v7; // 0x100013b7
    char v10 = v9 + v7; // 0x100013b7
    *v2 = v9;
    if (v9 < 0 != ((v10 ^ v3) & (v10 ^ v5)) < 0) {
        // 0x100013c5
        return function_fb12c512();
    }
    // 0x10001444
    int32_t v11; // 0x100013b6
    bool v12; // 0x100013b6
    int32_t v13 = (v12 ? -4 : 4) + v11; // 0x10001444
    int32_t v14; // 0x100013b6
    *(char *)v13 = *(char *)v14;
    int32_t v15; // 0x100013b6
    int32_t v16 = *(int32_t *)v15 & 0xa4d8b8; // 0x1000144f
    int32_t * v17 = (int32_t *)v1; // 0x10001451
    int32_t v18 = *v17; // 0x10001451
    int32_t v19 = v18 + v16; // 0x10001451
    *v17 = v19;
    if ((v19 & (v18 ^ -0x80000000)) >= 0) {
        char * v20 = (char *)v16; // 0x10001457
        *v20 = *v20 + (char)v1;
        return unknown_64092a0e();
    }
    // 0x100013f7
    int32_t v21; // 0x100013b6
    uint32_t v22 = v21 + 1; // 0x100013b6
    int32_t v23 = v12 ? -1 : 1; // 0x10001445
    bool v24 = v6 ? v9 <= v3 : v8 < v3; // 0x100013b7
    unsigned char v25 = (char)v15 & 31; // 0x100013f9
    uint16_t v26 = (int16_t)(9 - v25);
    int32_t v27 = 256 * (v22 / 256 + 184 + (int32_t)v24) & 0xff00 | v22 & -0xff01; // 0x1000141c
    int32_t v28; // 0x100013b6
    int32_t v29 = v28 + 2; // 0x10001404
    int32_t v30 = v23 + v14; // 0x100013b6
    int32_t v31 = v13 + v23; // 0x100013b6
    while (true) {
        int32_t v32 = v31;
        *(int32_t *)(v29 - 4) = v30;
        if (v25 != 0) {
            char * v33 = (char *)(v32 + 55); // 0x100013f9
            unsigned char v34 = *v33; // 0x100013f9
            *v33 = v34 >> v25 | 1 << 8 - v25 | (char)((int16_t)v34 << v26);
        }
        __asm_iretd();
        v29 -= 6;
        *(int32_t *)v32 = *(int32_t *)v30;
        int32_t v35; // 0x100013b6
        *(char *)-0x5b273780 = *(char *)-0x5b273780 + (char)v35;
        *(int32_t *)-0x69b270c8 = 0x5020023;
        int32_t v36 = -0x5b273780; // 0x10001414
        int32_t v37 = v27 & -256 | 48;
        char * v38 = (char *)(v36 - 96); // 0x10001415
        *v38 = *v38 + (char)(v35 / 256);
        char * v39 = (char *)v36; // 0x10001418
        char v40 = v35; // 0x10001418
        *v39 = *v39 + v40;
        int32_t v41 = v35 & -256 | (int32_t)(*(char *)v37 ^ v40); // 0x1000141a
        v27 = v37 & -256;
        v36 = v36 & -256 | (int32_t)__asm_in((int16_t)v41);
        int32_t v42 = v41; // 0x100013ef
        while ((v37 & 0xff00) == 0) {
            // 0x10001415
            v37 = v27;
            v38 = (char *)(v36 - 96);
            *v38 = *v38 + (char)(v42 / 256);
            v39 = (char *)v36;
            v40 = v42;
            *v39 = *v39 + v40;
            v41 = v42 & -256 | (int32_t)(*(char *)v37 ^ v40);
            v27 = v37 & -256;
            v36 = v36 & -256 | (int32_t)__asm_in((int16_t)v41);
            v42 = v41;
        }
        // 0x100013f7
        v35 = v41;
        v30 += 4;
        v31 = v32 + 4;
    }
}

// Address range: 0x10001467 - 0x10001475
int32_t function_10001467(void) {
    // 0x10001467
    int32_t v1; // 0x10001467
    char * v2 = (char *)(v1 + 53); // 0x10001467
    unsigned char v3 = *v2; // 0x10001467
    int32_t v4; // 0x10001467
    unsigned char v5 = v3 + (char)v4; // 0x10001467
    bool v6; // 0x10001467
    unsigned char v7 = v5 + (char)v6; // 0x10001467
    *v2 = v7;
    int32_t v8; // 0x10001467
    return v8 + 0x1000a1c4 + (int32_t)(v6 ? v7 <= v3 : v5 < v3);
}

// Address range: 0x100014e8 - 0x100014eb
int32_t function_100014e8(int32_t a1) {
    // 0x100014e8
    int32_t result; // 0x100014e8
    return result;
}

// Address range: 0x10001549 - 0x10001558
int32_t function_10001549(void) {
    // 0x10001549
    int32_t v1; // 0x10001549
    int32_t v2; // 0x10001549
    *(char *)v2 = (char)v2 + (char)v1;
    return function_f98150ec();
}

// Address range: 0x1000156b - 0x1000156c
int32_t function_1000156b(void) {
    // 0x1000156b
    int32_t result; // 0x1000156b
    return result;
}

// Address range: 0x10001577 - 0x10001578
int32_t function_10001577(void) {
    // 0x10001577
    int32_t result; // 0x10001577
    return result;
}

// Address range: 0x100015ab - 0x100015d8
int32_t function_100015ab(void) {
    // 0x100015ab
    int32_t v1; // 0x100015ab
    CloseHandle((int32_t *)*(int32_t *)(v1 - 4));
    uint32_t v2; // 0x100015ab
    bool v3; // 0x100015ab
    uint32_t v4 = v2 + 0x6a6f9f75 + (int32_t)v3; // 0x100015b4
    int32_t v5; // 0x100015ab
    int32_t v6; // 0x100015ab
    if (!((v3 ? v4 <= v2 : v2 > 0x9590608a))) {
        // 0x100015c3
        function_1000156b();
        int32_t v7 = __asm_bound(*(int64_t *)&v5); // 0x100015be
        __asm_in_5(-100);
        uint32_t v8; // 0x100015ab
        *(int32_t *)v8 = v8 / 0x1000;
        v6 = v7 + v4;
    } else {
        // 0x100015bc
        v6 = __asm_bound(*(int64_t *)&v5);
    }
    // 0x100015ca
    int32_t v9; // 0x100015ab
    *(char *)v9 = *(char *)v6;
    *(char *)(v9 + 1) = __asm_insb((int16_t)v5);
    unknown_5fb1354();
    return function_100015fb();
}

// Address range: 0x100015da - 0x100015fb
int32_t function_100015da(void) {
    // 0x100015da
    int32_t v1; // 0x100015da
    bool v2; // 0x100015da
    if (!v2) {
        // 0x100015dc
        v1 = function_1000156b();
    } else {
        v1 = function_10001577();
    }
    // 0x100015de
    int32_t v3; // 0x100015da
    int32_t v4; // 0x100015da
    int32_t v5 = *(int32_t *)(v3 - 104) ^ v4; // 0x100015de
    *(int32_t *)(v5 - 4) = v1;
    *(int32_t *)(v5 - 20) = v5;
    int32_t v6; // 0x100015da
    int32_t v7 = v6 - 1; // 0x100015e2
    __asm_out_4((int16_t)v7, (char)v1);
    int32_t result = *(int32_t *)0x40a4fa80 & -256 | 160; // 0x100015ed
    char * v8 = (char *)result; // 0x100015ef
    *v8 = *v8 + (char)v7;
    int32_t * v9 = (int32_t *)v7; // 0x100015f3
    *v9 = -*v9;
    return result;
}

// Address range: 0x100015fb - 0x1000160a
int32_t function_100015fb(void) {
    // 0x100015fb
    int32_t v1; // 0x100015fb
    int32_t result = v1 ^ 0x4347669a; // 0x100015fb
    int32_t v2; // 0x100015fb
    __asm_out_6((int16_t)v2, result);
    return result;
}

// Address range: 0x10001639 - 0x10001671
int32_t function_10001639(void) {
    // 0x10001639
    int32_t v1; // 0x10001639
    int32_t v2; // 0x10001639
    *(char *)v1 = (char)v2;
    int32_t v3; // 0x10001639
    int32_t v4; // 0x10001639
    *(char *)v3 = *(char *)&v3 + (char)v4;
    int32_t result = v3 & -256 | (int32_t)*(char *)0x457b1000; // 0x10001646
    v3 = result;
    int32_t v5; // 0x10001639
    if ((v5 & 0xff00) == 0x9c00) {
        // 0x10001673
        return result;
    }
    // 0x1000164d
    bool v6; // 0x10001639
    int32_t v7 = v6 ? -1 : 1; // 0x10001639
    int32_t v8 = v7 + v1; // 0x10001639
    int32_t v9 = v7 + v2; // 0x10001639
    char * v10 = (char *)(result + 0x381000a0); // 0x10001655
    *v10 = *v10 + (char)v5;
    uint64_t v11 = (int64_t)*(int32_t *)(v8 + 112 + 2 * v9) * (int64_t)v9; // 0x1000165c
    *(int32_t *)v8 = *(int32_t *)v3;
    char * v12 = (char *)(int32_t)v11; // 0x10001667
    *v12 = *v12 + (char)(v11 / 0x100000000);
    char v13; // bp-256, 0x10001639
    return &v13;
}

// Address range: 0x10001672 - 0x10001673
int32_t function_10001672(void) {
    // 0x10001672
    int32_t result; // 0x10001672
    return result;
}

// Address range: 0x1000167a - 0x10001680
int32_t function_1000167a(int32_t a1) {
    // 0x1000167a
    int32_t result; // 0x1000167a
    return result;
}

// Address range: 0x100016ec - 0x100016fc
int32_t function_100016ec(void) {
    // 0x100016ec
    int32_t v1; // 0x100016ec
    char * v2 = (char *)(v1 - 0x73dc8b40); // 0x100016ec
    int32_t v3; // 0x100016ec
    bool v4; // 0x100016ec
    *v2 = *v2 + (char)v3 + (char)v4;
    __asm_hlt();
    return function_4c5306d4();
}

// Address range: 0x10001730 - 0x10001798
int32_t function_10001730(int16_t a1) {
    // 0x10001730
    bool v1; // 0x10001730
    uint32_t v2; // 0x10001730
    uint32_t v3; // 0x10001730
    char v4 = __asm_insb((int16_t)(256 * (v3 / 256 + v2 / 256 + (int32_t)v1) | v3 & 255)); // 0x10001738
    int32_t v5; // 0x10001730
    *(char *)v5 = v4;
    uint32_t v6; // 0x10001730
    int32_t v7 = v6 + 0x53b8cf3b; // 0x10001739
    char v8 = llvm_ctpop_i8((char)v7); // 0x10001739
    bool v9; // 0x10001730
    bool v10; // 0x10001730
    bool v11; // 0x10001730
    bool v12; // 0x10001730
    *(int32_t *)-0x2cefff64 = 0x4000 * (int32_t)v10 | (int32_t)(v6 < 0xac4730c5) | 64 * (int32_t)(v7 == 0) | 128 * (int32_t)(v7 < 0) | 1024 * (int32_t)v11 | 16 * (int32_t)((v6 & 15) > 20) | 512 * (int32_t)v12 | 256 * (int32_t)v9 | 2048 * (int32_t)(((v7 ^ v6) & (v6 ^ -0x80000000)) < 0) | 4 * (int32_t)((v8 & 1) == 0) | 2;
    unsigned char v13 = *(char *)0x2c561000; // 0x1000173f
    int32_t v14 = v7 & -256 | (int32_t)v13; // 0x1000173f
    int32_t v15 = v11 ? -4 : 4; // 0x10001744
    int32_t v16; // 0x10001730
    int32_t v17 = v15 + v16; // 0x10001744
    char * v18 = (char *)v14; // 0x10001745
    unsigned char v19 = *v18; // 0x10001745
    char v20 = v3; // 0x10001745
    unsigned char v21 = v19 + v20; // 0x10001745
    *v18 = v21;
    char * v22 = (char *)(v5 - 106 + v15); // 0x10001747
    *v22 = *v22 - (v21 < v19 ? 6 : 5);
    *(int32_t *)-0x2cefff64 = v17;
    int32_t v23 = v14 & -0xff01 | 0xa400; // 0x10001757
    char * v24 = (char *)v23; // 0x10001759
    char v25 = v20 + 1; // 0x10001759
    *v24 = *v24 + v25;
    int32_t v26 = v23 & -0x5c00 | (int32_t)(v13 | -52); // 0x1000175b
    uint32_t v27 = *(int32_t *)(v26 + 0xa0b8da) ^ v2 + 1; // 0x1000175d
    char * v28 = (char *)(v26 + 0x23100060); // 0x10001764
    char v29 = *v28; // 0x10001764
    unsigned char v30 = (char)v27; // 0x10001764
    *v28 = v29 + v30;
    char * v31 = (char *)v26; // 0x1000176b
    unsigned char v32 = *v31; // 0x1000176b
    unsigned char v33 = v32 - 92 + (char)(-1 - v29 < v30); // 0x1000176b
    bool v34 = -1 - v29 < v30 ? v33 <= v32 : v32 > 91; // 0x1000176b
    *v31 = v33;
    uint32_t v35 = v27 / 256; // 0x1000176e
    unsigned char v36 = (char)v35; // 0x1000176e
    unsigned char v37 = 2 * (char)v35; // 0x1000176e
    bool v38 = v34 ? (v37 | (char)v34) <= v36 : v37 < v36; // 0x1000176e
    *(int16_t *)-0x2cefff62 = a1;
    uint32_t v39 = v26 + 0x1000a1c8 + (int32_t)v38 & -0xba00; // 0x10001777
    int32_t v40 = v39 | (int32_t)*(char *)-0x24efff60; // 0x10001777
    int32_t v41; // 0x10001730
    char * v42 = (char *)(v41 + 0xc741000); // 0x1000177c
    *v42 = *v42 - (char)(v39 / 256);
    int32_t v43 = v17 + v15; // 0x10001782
    char * v44 = (char *)v40; // 0x10001783
    *v44 = *v44 + v25;
    char * v45 = (char *)(v40 - 1); // 0x1000178a
    char v46 = *v45; // 0x1000178a
    *v45 = v46 - 1;
    *(int32_t *)-0x2cefff64 = v43;
    *(int32_t *)-0x2cefff68 = v43;
    return v40 + (v46 == 0 ? 0x1000a0b3 : 0x1000a0b4);
}

// Address range: 0x100017b2 - 0x100017b5
int32_t function_100017b2(void) {
    // 0x100017b2
    int32_t result; // 0x100017b2
    return result;
}

// Address range: 0x100017b5 - 0x100017c1
int32_t function_100017b5(void) {
    // 0x100017b5
    int32_t v1; // 0x100017b5
    int32_t * v2 = (int32_t *)(v1 - 52); // 0x100017ba
    *v2 = *v2 & 102;
    int32_t v3; // 0x100017b5
    bool v4; // 0x100017b5
    return v3 + 0x59c45241 + (int32_t)v4;
}

// Address range: 0x100017d0 - 0x100017dc
int32_t function_100017d0(void) {
    // 0x100017d0
    uint32_t v1; // 0x100017d0
    unsigned char v2 = (char)(v1 / 256); // 0x100017d0
    uint32_t v3; // 0x100017d0
    unsigned char v4 = v2 + (char)(v3 / 256); // 0x100017d0
    if (v4 < v2 || v4 == 0) {
        function_100017f5((int32_t)&g22, (int32_t)&g22);
    }
    // 0x100017d4
    int16_t v5; // 0x100017d0
    return unknown_a0c43e(v5);
}

// Address range: 0x100017dc - 0x100017e8
int32_t Logon(void) {
    // 0x100017dc
    int32_t v1; // 0x100017dc
    return (uint32_t)(int32_t)&v1 / 0x10000;
}

// Address range: 0x100017e8 - 0x100017f1
int32_t Logoff(void) {
    // 0x100017e8
    int32_t v1; // 0x100017e8
    __asm_arpl(*(int16_t *)-0x137c13f5, (int16_t)v1);
    int32_t v2; // 0x100017e8
    char * v3 = (char *)(v2 + 51); // 0x100017ee
    *v3 = *v3 - (char)v1;
    int32_t result; // 0x100017e8
    return result;
}

// Address range: 0x100017f5 - 0x10001827
int32_t function_100017f5(int32_t a1, int32_t a2) {
    // 0x100017f5
    bool v1; // 0x100017f5
    int32_t v2 = v1; // 0x100017f5
    uint32_t v3; // 0x100017f5
    int32_t v4 = v3 + 0x2c6cd22b + v2; // 0x100017f5
    bool v5 = v1 ? v4 <= v3 : v3 > 0xd3932dd4; // 0x100017f5
    if (v4 != 0 && !v5) {
        function_100017d0();
    }
    char v6 = llvm_ctpop_i8((char)v4); // 0x100017f5
    __asm_int(251);
    int32_t v7; // 0x100017f5
    float80_t v8; // 0x100017f5
    *(int16_t *)(v7 - 27) = (int16_t)v8;
    int32_t v9 = v5 ? 767 : 512; // 0x10001809
    *(int32_t *)((0x1000000 * (16 * (int32_t)((v3 & 15) + 11 + v2 > 15) | (int32_t)v5 | 64 * (int32_t)(v4 == 0) | 128 * (int32_t)(v4 < 0) | 4 * (int32_t)((v6 & 1) == 0)) / 0x10000 | v9) - 46) = a2;
    if (v7 < -1) {
        function_10001854((int32_t)&g22);
    }
    // 0x10001818
    int32_t v10; // 0x100017f5
    return (v10 & -256 | (int32_t)*(char *)0x6f441000) + 0x17e18e8e;
}

// Address range: 0x10001829 - 0x1000183c
int32_t function_10001829(void) {
    unsigned char v1 = *(char *)-0x48c2f000; // 0x10001829
    int32_t v2; // 0x10001829
    char * v3 = (char *)(v2 & -256 | (int32_t)v1); // 0x1000182e
    *v3 = *v3 + v1;
    int32_t v4; // 0x10001829
    char * v5 = (char *)(v4 + 13); // 0x10001830
    int32_t v6; // 0x10001829
    *v5 = *v5 + (char)v6;
    return unknown_a05c3e();
}

// Address range: 0x10001841 - 0x10001844
int32_t Activate(int32_t a1) {
    // 0x10001841
    int32_t result; // 0x10001841
    return result;
}

// Address range: 0x10001854 - 0x1000186b
int32_t function_10001854(int32_t a1) {
    // 0x10001854
    int32_t v1; // 0x10001854
    return v1 & -256 | (int32_t)*(char *)0x233e1000;
}

// Address range: 0x1000187c - 0x1000187d
int32_t function_1000187c(void) {
    // 0x1000187c
    int32_t result; // 0x1000187c
    return result;
}

// Address range: 0x10001885 - 0x10001887
int32_t function_10001885(void) {
    // 0x10001885
    return function_1000187c();
}

// Address range: 0x10001902 - 0x10001a5c
int32_t entry_point(int32_t a1) {
    int32_t v1 = a1;
    int32_t v2; // 0x10001902
    int32_t v3; // 0x10001902
    int32_t v4; // 0x10001902
    uint32_t v5; // 0x10001902
    int32_t v6; // 0x10001902
    int32_t v7; // 0x10001902
    int32_t result; // 0x10001902
    __asm_rdtsc(v2, v3, v4, &v1, v5, v6, v7, result);
    __asm_rdtsc_1();
    if ((int16_t)result == 736) {
        // 0x10001919
        return result;
    }
    // 0x1000191a
    v1 += 0xd6d0;
    int32_t v8; // bp-4, 0x10001902
    uint32_t v9 = (int32_t)&v8; // 0x10001956
    int32_t v10 = __readfsdword(0); // 0x10001967
    v8 = v10;
    __writefsdword(0, v9);
    for (int32_t i = 0x10000; i > 0; i--) {
        // continue -> 0x100019b8
    }
    int32_t * v11 = (int32_t *)i; // 0x100019da
    *v11 = *v11 ^ v4;
    char * v12 = (char *)v10; // 0x100019dc
    char v13 = v6; // 0x100019dc
    *v12 = *v12 + v13;
    bool v14; // 0x10001902
    int32_t v15 = v14 ? -4 : 4; // 0x100019e0
    int32_t v16 = v15 + v2; // 0x100019e0
    int32_t v17 = v15 + v3; // 0x100019e0
    char * v18 = (char *)(v6 + 0x17a21000); // 0x100019e1
    *v18 = *v18 & 7;
    uint32_t v19 = v10 & 0x3841f580; // 0x100019e8
    int32_t v20 = v19 - (int32_t)&g21; // 0x100019ed
    if (v19 < (int32_t)&g21 || v20 == 0) {
        int32_t v21 = *(int32_t *)(v20 - 61); // 0x100019f4
        char * v22 = (char *)(v20 + 0x22be1000); // 0x100019fa
        *v22 = 2 * *v22;
        int32_t v23; // bp-10, 0x10001902
        bool v24 = ((int32_t)&v23 & 12) > 16 | (v20 & 12) > 9; // 0x10001a00
        unsigned char v25 = (char)(__asm_iretd() / 256); // 0x10001a04
        unsigned char v26 = *(char *)(v16 + 0xa0ccc5 + v21) + v25; // 0x10001a04
        bool v27 = v24 ? v26 + (char)v24 <= v25 : v26 < v25; // 0x10001a04
        char * v28 = (char *)(v21 + 8); // 0x10001a0b
        *v28 = *v28 + (char)(i / 256) + (char)v27;
        int32_t v29 = v4 - 8; // 0x10001a0e
        char * v30 = (char *)v29; // 0x10001a14
        unsigned char v31 = *v30; // 0x10001a14
        char v32 = v31 / 128; // 0x10001a14
        *v30 = v32 | 2 * v31;
        char * v33 = (char *)(v17 + 0x66b36fb8); // 0x10001a16
        unsigned char v34 = *v33; // 0x10001a16
        unsigned char v35 = v34 + (char)(v5 / 256); // 0x10001a16
        unsigned char v36 = v35 + (char)(v32 != 0); // 0x10001a16
        *v33 = v36;
        unsigned char v37 = (char)v29; // 0x10001a20
        bool v38 = v37 > 153 | (v32 != 0 ? v36 <= v34 : v35 < v34);
        int32_t v39; // 0x10001902
        if ((v37 & 14) > 9 || (i & 15) == 15) {
            v39 = (v38 ? 102 : 6) + v29 & 255 | v29 & -256;
        } else {
            v39 = (v38 ? v4 + 88 : v29) & 255 | v29 & -256;
        }
        return v39 - 1;
    }
    int32_t v40 = __asm_bound(*(int64_t *)v20); // 0x10001a30
    char * v41 = (char *)v5; // 0x10001a33
    *v41 = *v41 + (char)i;
    char * v42 = (char *)(v40 - 108); // 0x10001a36
    unsigned char v43 = *v42; // 0x10001a36
    *v42 = v43 / 16 | 16 * v43;
    int32_t v44 = v40 + 158 & 255 | v40 & -256; // 0x10001a3a
    char * v45 = (char *)v44; // 0x10001a3c
    unsigned char v46 = *v45; // 0x10001a3c
    unsigned char v47 = v46 + v13; // 0x10001a3c
    *v45 = v47;
    int32_t v48 = v44; // 0x10001a3f
    if ((v16 + 1 & (v16 ^ -0x80000000)) >= 0) {
        v48 = function_10001aaf((int32_t)&g22);
    }
    int32_t v49 = v48;
    char * v50 = (char *)(v49 - (v47 < v46 ? 97 : 96) & 255 | v49 & -256); // 0x10001a43
    *v50 = *v50 + v13;
    int32_t v51 = __asm_iretd(); // 0x10001a45
    char v52 = *(int32_t *)(v4 + 0x5c157f10 + 4 * v4) > v9 ? 97 : 96; // 0x10001a52
    int32_t result2 = v51 & -256 | (int32_t)(*(char *)0x1c891000 - v52); // 0x10001a52
    char * v53 = (char *)result2; // 0x10001a54
    unsigned char v54 = *v53; // 0x10001a54
    unsigned char v55 = v54 + v13; // 0x10001a54
    *v53 = v55;
    char * v56 = (char *)(v17 - 0x5b85fd14); // 0x10001a56
    *v56 = *v56 - v13 + (char)(v55 < v54);
    return result2;
}

// Address range: 0x10001a5e - 0x10001a82
int32_t HookProc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x10001a5e
    uint32_t v1; // 0x10001a5e
    int32_t v2; // 0x10001a5e
    int64_t v3 = *(int64_t *)(v2 & -256 | (int32_t)__asm_in((int16_t)v1)); // 0x10001a69
    int32_t v4; // 0x10001a5e
    char * v5 = (char *)(v4 + 56 + 2 * __asm_bound(v3)); // 0x10001a6c
    *v5 = *v5 + (char)(v1 / 256);
    __asm_outsb((int16_t)a4, *(char *)a1);
    int32_t result = __asm_bound(*(int64_t *)a6); // 0x10001a7a
    int32_t * v6 = (int32_t *)(v4 - 126); // 0x10001a7f
    *v6 = *v6 ^ result;
    return result;
}

// Address range: 0x10001aaf - 0x10001abc
int32_t function_10001aaf(int32_t a1) {
    // 0x10001aaf
    int32_t v1; // 0x10001aaf
    return v1 & -256 | (int32_t)*(char *)-0xaa4f000;
}

// Address range: 0x10001abd - 0x10001ac0
int32_t function_10001abd(int32_t a1) {
    // 0x10001abd
    int32_t result; // 0x10001abd
    return result;
}

// Address range: 0x10001ac9 - 0x10001b23
int32_t Start(int32_t a1) {
    // 0x10001ac9
    int32_t v1; // 0x10001ac9
    bool v2; // 0x10001ac9
    int32_t v3 = 0x10000 * (v1 + 0xec0b + (int32_t)v2) / 0x10000; // 0x10001ace
    int32_t v4 = v3 + 0x53510100; // 0x10001acf
    int32_t v5 = *(int32_t *)(v3 + 0x535100eb); // 0x10001ad4
    int32_t v6; // 0x10001ac9
    int32_t * v7 = (int32_t *)(v6 - 0x6e111c7e); // 0x10001ad7
    uint32_t v8 = *v7; // 0x10001ad7
    int32_t v9; // 0x10001ac9
    uint32_t v10 = v8 + v9; // 0x10001ad7
    *v7 = v10;
    __asm_out(45, v4);
    int32_t v11 = __asm_bound(*(int64_t *)v4); // 0x10001ae6
    int32_t v12; // 0x10001ac9
    char v13 = *(char *)&v12; // 0x10001ae8
    *(char *)v12 = (char)(v10 < v8) + (char)v9 + v13;
    *(int32_t *)(4 * v5 + 0x68000000 + v12) = a1;
    char * v14 = (char *)(v11 - 0x67f5fb15); // 0x10001b0e
    *v14 = *v14 + (char)v5;
    *(int32_t *)0x3aae980a = *(int32_t *)0x3aae980a ^ v11 - 0x67f5fafd;
    uint32_t result = __asm_wait(); // 0x10001b1f
    char * v15 = (char *)(result + 110); // 0x10001b20
    *v15 = *v15 ^ (char)(result / 256);
    return result;
}

// Address range: 0x10001b24 - 0x10001b3f
int32_t function_10001b24(void) {
    // 0x10001b24
    int32_t v1; // 0x10001b24
    unsigned char v2 = (char)v1; // 0x10001b27
    bool v3; // 0x10001b24
    bool v4 = v2 > 153 | v3;
    int32_t v5 = v4 ? v1 + 160 : v1;
    int32_t v6; // 0x10001b24
    char * v7 = (char *)(v6 - 0xaff000); // 0x10001b29
    bool v8; // 0x10001b24
    *v7 = *v7 - (char)(v8 | (v2 & 14) > 9 ? (v4 ? 154 : 250) + v1 : v5);
    int32_t v9; // 0x10001b24
    int32_t v10; // 0x10001b24
    __asm_out_6((int16_t)v10, v9);
    return function_c3024dda();
}

// Address range: 0x10001b52 - 0x10001b53
int32_t function_10001b52(void) {
    // 0x10001b52
    int32_t result; // 0x10001b52
    return result;
}

// Address range: 0x10001b57 - 0x10001b58
int32_t function_10001b57(void) {
    // 0x10001b57
    int32_t result; // 0x10001b57
    return result;
}

// Address range: 0x10001b77 - 0x10001b7f
int32_t function_10001b77(int32_t a1) {
    // 0x10001b77
    int32_t v1; // 0x10001b77
    *(char *)v1 = 2 * (char)v1;
    int32_t result; // 0x10001b77
    return result;
}

// Address range: 0x10001b93 - 0x10001bb1
int32_t function_10001b93(void) {
    // 0x10001b93
    int32_t v1; // 0x10001b93
    int32_t v2 = v1 & -256 | (int32_t)(unsigned char)__readfsbyte(-0x41faf000); // 0x10001ba4
    bool v3; // 0x10001b93
    if (!v3) {
        v2 = function_10001b57();
    }
    uint32_t v4 = v2;
    int32_t v5; // 0x10001b93
    int32_t v6; // 0x10001b93
    char * v7 = (char *)(v6 + 0xa28028 + 8 * v5); // 0x10001ba6
    unsigned char v8 = *v7; // 0x10001ba6
    unsigned char v9 = v8 + (char)(v4 / 256); // 0x10001ba6
    unsigned char v10 = v9 + (char)v3; // 0x10001ba6
    bool v11 = v3 ? v10 <= v8 : v9 < v8; // 0x10001ba6
    *v7 = v10;
    uint32_t v12; // 0x10001b93
    return v4 + v12 / 256 + (int32_t)v11 & 255 | v4 & -256;
}

// Address range: 0x10001bb7 - 0x10001bfc
int32_t function_10001bb7(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5, int32_t a6, uint32_t a7) {
    // 0x10001bb7
    int32_t v1; // 0x10001bb7
    int32_t v2; // 0x10001bb7
    *(char *)v2 = (char)v2 + (char)v1;
    *(char *)a1 = *(char *)a2;
    bool v3; // 0x10001bb7
    int32_t v4 = v3 ? -1 : 1; // 0x10001bbc
    char * v5 = (char *)a7; // 0x10001bbd
    *v5 = *v5 & (char)(a7 / 256);
    char * v6 = (char *)(a1 - 16 + a6 + v4); // 0x10001bc0
    char v7 = *v6; // 0x10001bc0
    unsigned char v8 = (char)(a5 / 256); // 0x10001bc0
    char v9 = v7 + v8; // 0x10001bc0
    *v6 = v9;
    if (-1 - v7 >= v8 && v9 != 0) {
        function_10001b52();
    }
    int32_t * v10 = (int32_t *)(v4 + a2); // 0x10001bd3
    __asm_outsd((int16_t)a5, *v10);
    __asm_hlt();
    int16_t v11; // 0x10001bb7
    *(int32_t *)(int32_t)v11 = *v10;
    char v12; // 0x10001bb7
    char v13; // 0x10001bb7
    return function_4c53012a(v13 + v12);
}

// Address range: 0x10001c19 - 0x10001c26
int32_t function_10001c19(void) {
    // 0x10001c19
    int32_t v1; // 0x10001c19
    char * v2 = (char *)(v1 + 0x69ec333b); // 0x10001c19
    int32_t v3; // 0x10001c19
    bool v4; // 0x10001c19
    *v2 = *v2 + (char)v3 + (char)v4;
    return function_82c0e74a();
}

// Address range: 0x10001c2b - 0x10001c2e
int32_t function_10001c2b(void) {
    // 0x10001c2b
    int32_t result; // 0x10001c2b
    return result;
}

// Address range: 0x10001c42 - 0x10001c96
int32_t function_10001c42(int32_t a1) {
    // 0x10001c42
    int32_t result; // 0x10001c42
    bool v1; // 0x10001c42
    if (!v1) {
        // 0x10001c8b
        return result;
    }
    // 0x10001c4b
    int32_t v2; // 0x10001c42
    int32_t v3; // 0x10001c42
    __asm_rep_stosd_memset((char *)(v2 - 128), result, v3);
    int32_t v4; // 0x10001c42
    return 8 * v2 + 85 + v4 - 0x15f5fafd;
}

// Address range: 0x10001ca9 - 0x10001cbc
int32_t function_10001ca9(void) {
    // 0x10001ca9
    __asm_int(5);
    int32_t v1; // 0x10001ca9
    int32_t v2; // 0x10001ca9
    *(char *)v1 = *(char *)&v1 + (char)v2;
    return unknown_a1c43e(0x68fffffa);
}

// Address range: 0x10001cbc - 0x10001d99
int32_t function_10001cbc(int32_t a1, int32_t a2) {
    // 0x10001cbc
    int32_t v1; // 0x10001cbc
    char * v2 = (char *)(v1 + 0x65a7e2be); // 0x10001cbc
    *v2 = *v2 | (char)v1;
    int32_t v3; // 0x10001cbc
    char * v4 = (char *)(v3 + 21); // 0x10001cc9
    uint32_t v5; // 0x10001cbc
    *v4 = *v4 + (char)(v5 / 256);
    unknown_6f101d71();
    int32_t v6 = __asm_int3(); // 0x10001cd3
    char v7 = __asm_in_5(-96); // 0x10001cd8
    int32_t result = v6 & -0x10000 | (int32_t)v7 | 256 * (int32_t)((char)v6 / 67); // 0x10001cd8
    char * v8 = (char *)result; // 0x10001cda
    int32_t v9; // 0x10001cbc
    *v8 = *v8 + (char)v9;
    char v10 = *(char *)&v9; // 0x10001cdc
    char v11 = v9; // 0x10001cdc
    char v12 = v10 + v11; // 0x10001cdc
    *(char *)v9 = v12;
    if (v12 < 0 == ((v12 ^ v10) & (v12 ^ v11)) < 0 != v12 != 0) {
        // 0x10001ce0
        return result;
    }
    // 0x10001d23
    __asm_out_4((int16_t)v9, v7);
    int32_t v13; // 0x10001cbc
    int32_t v14 = *(int32_t *)(v13 + 4); // 0x10001d27
    v9 = v14 - 1;
    if (v14 > 1) {
        // 0x10001d3c
        return result & -256 | 122;
    }
    if (v14 == 1) {
        int32_t v15 = result - 8; // 0x10001d23
        *(int32_t *)(a1 + 1) = *(int32_t *)v15;
        // 0x10001d3c
        return -0x12f9939b * v15;
    }
    char * v16 = (char *)a2; // 0x10001d43
    *v16 = *v16 + 8;
    int32_t result2 = result | 255; // 0x10001d4b
    __asm_out_6(-1283, result2);
    v9 = *(int32_t *)(v13 + 8);
    int32_t * v17 = (int32_t *)(result2 - 0x47a5735a); // 0x10001d59
    *v17 = *v17 + 0x446414dd;
    char * v18 = (char *)(a2 - 0x7ff28a81); // 0x10001d68
    *v18 = *v18 & (char)(*(int32_t *)(v13 + 12) / 256);
    return result2;
}

// Address range: 0x10001d9a - 0x10001e08
int32_t function_10001d9a(int32_t a1, int32_t a2, uint32_t a3, uint32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = a6;
    int32_t v2 = a3;
    int64_t v3; // 0x10001d9a
    __asm_pmullw(v3, v3);
    v1 = a5;
    unsigned char v4 = (char)a5 & 31; // 0x10001dbc
    if (v4 != 0) {
        char * v5 = (char *)(a6 + 71); // 0x10001dbc
        *v5 = *v5 << v4;
    }
    int16_t v6 = a4; // 0x10001dc2
    __asm_outsb(v6, *(char *)a6);
    unsigned char v7 = (char)(a3 / 256); // 0x10001dc3
    unsigned char v8 = v7 - 84; // 0x10001dc3
    int32_t v9 = a3 & -0x10000 | 256 * (int32_t)v8 | 19; // 0x10001dc3
    unsigned char v10 = *(char *)0x40c51000; // 0x10001dc6
    int32_t v11 = a2 + 0x610c8c02 & -256; // 0x10001dc6
    int32_t v12 = v11 | (int32_t)v10; // 0x10001dcb
    int32_t * v13 = &v1; // 0x10001dcb
    if (v8 != 0) {
        // 0x10001dcd
        v2 = *(int32_t *)(a1 + 38);
        int32_t * v14 = (int32_t *)(a5 - 22); // 0x10001dd3
        *v14 = (int32_t)(v7 < 84) - v9 + *v14;
        v12 = v11 | (int32_t)(v10 - 95);
        char * v15 = (char *)v12; // 0x10001dd9
        *v15 = *v15 + (char)a4;
        v13 = &v2;
    }
    // 0x10001ddb
    int32_t v16; // 0x10001d9a
    *(int32_t *)v16 = __asm_insd(v6);
    char * v17 = (char *)(a5 + 24); // 0x10001de2
    char v18 = *v17; // 0x10001de2
    int32_t v19 = a4 / 256; // 0x10001de2
    char v20 = v19; // 0x10001de2
    *v17 = v18 - v20;
    int32_t v21 = v12; // 0x10001deb
    if (v19 < (int32_t)v18) {
        char * v22 = (char *)(a6 - 117 + v9); // 0x10001ded
        *v22 = *v22 + v20;
        v21 = v12 - 1;
    }
    // 0x10001df9
    *(int32_t *)((int32_t)v13 - 4) = 0x3b12b86;
    unsigned char v23 = *(char *)a6; // 0x10001dfa
    unsigned char v24 = *(char *)v21; // 0x10001dfa
    char v25 = v23 - v24; // 0x10001dfa
    char v26 = llvm_ctpop_i8(v25); // 0x10001dfa
    bool v27; // 0x10001d9a
    __asm_outsb(v6, *(char *)((v27 ? -1 : 1) + a6));
    return 256 * (64 * (int32_t)(v25 == 0) | (int32_t)(v23 < v24) | 128 * (int32_t)(v25 < 0) | 16 * (int32_t)((v23 & 15) - (v24 & 15) > 15) | 4 * (int32_t)((v26 & 1) == 0)) | 0x330202b7;
}

// Address range: 0x10001e08 - 0x10001e4a
int32_t function_10001e08(int32_t a1) {
    int32_t v1 = a1;
    int32_t v2 = &v1; // bp-4, 0x10001e08
    int32_t v3 = &v2; // 0x10001e08
    int32_t v4; // 0x10001e08
    bool v5; // 0x10001e08
    if (!v5) {
        // 0x10001e10
        int32_t v6; // 0x10001e08
        __asm_arpl((int16_t)v6, (int16_t)v3);
        return v4 + 85 + 8 * v6;
    }
    int32_t v7 = (int32_t)*(char *)-0x3f7af000; // 0x10001e09
    int32_t v8 = (v7 & 14) > 9 ? v7 + 6 : v7; // 0x10001e25
    int32_t v9 = v8 & 15; // 0x10001e25
    int32_t v10; // 0x10001e08
    int32_t v11 = 256 * (int32_t)((v7 & 14) > 9) + (v10 & 0xff00 | v7) & 0xff00 | v10 & -0x10000;
    uint32_t v12 = v11 | v9; // 0x10001e25
    float80_t v13; // 0x10001e08
    *(int32_t *)v12 = (int32_t)v13;
    int32_t v14 = v10 >> 31; // 0x10001e28
    int32_t v15; // 0x10001e08
    int32_t * v16 = (int32_t *)(2 * (v15 & v4) + 0x4413916 + v3); // 0x10001e29
    int32_t v17; // 0x10001e08
    int32_t v18 = *v16 + v17; // 0x10001e29
    *v16 = v18;
    int32_t v19 = v14; // 0x10001e30
    int32_t v20 = v12; // 0x10001e30
    if (v18 != 0) {
        uint32_t v21 = *(int32_t *)(v14 + 97 + v12); // 0x10001e32
        int32_t v22 = v12 < v21 ? 102 : 6;
        int32_t v23 = v12 < v21 ? v9 | 96 : v9;
        v20 = ((v8 & 14) > 9 | v9 - (v21 & 15) > 15 ? v22 + v9 : v23) | v11;
        __asm_out_6((int16_t)v14, v20);
        int32_t v24; // 0x10001e08
        v19 = v24 + 0x748fa700;
    }
    // 0x10001e42
    return v20 & -256 | (int32_t)__asm_in((int16_t)v19);
}

// Address range: 0x10001e4a - 0x10001f46
int32_t function_10001e4a(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10001e4a
    int32_t v1; // 0x10001e4a
    int32_t v2; // 0x10001e4a
    *(char *)v1 = __asm_insb((int16_t)v2);
    int32_t v3; // 0x10001e4a
    int32_t v4 = *(int32_t *)(v3 + 9); // 0x10001e4f
    int32_t v5; // 0x10001e5a
    int64_t v6; // 0x10001e66
    if (*(int32_t *)(v3 + 16) != 0) {
        // 0x10001e5a
        v5 = 0x10000 * v4 / 0x10000;
        v6 = (int64_t)*(int32_t *)v5;
        return v5 - (-92 * v6 == -0x5c00000000 * v6 / 0x100000000 ? -0xf74a9bd : -0xf74a9bc);
    }
    int32_t * v7 = (int32_t *)(v4 + 59); // 0x10001e54
    int32_t v8 = *v7 - 35; // 0x10001e54
    *v7 = v8;
    int32_t v9; // 0x10001e4a
    if (v9 != 1 != (v8 == 0)) {
        // 0x10001e5a
        v5 = 0x10000 * v4 / 0x10000;
        v6 = (int64_t)*(int32_t *)v5;
        return v5 - (-92 * v6 == -0x5c00000000 * v6 / 0x100000000 ? -0xf74a9bd : -0xf74a9bc);
    }
    int16_t v10 = v2 + 0xdf00 & 0xff00 | v2 & 255; // 0x10001eb6
    char v11 = __asm_in(v10); // 0x10001eb6
    uint32_t v12 = v4 & -256 | (int32_t)v11; // 0x10001eb6
    int32_t v13; // 0x10001e4a
    *(char *)v13 = *(char *)&v13 + (char)(v12 / 256);
    __asm_fldenv(*(int224_t *)(v13 - 100));
    unsigned char v14 = ((v11 & 14) > 9 ? v11 + 10 : v11) & 15; // 0x10001ec0
    __asm_int(255);
    int32_t v15 = (v12 & -0x10000 | (int32_t)v14 | 256 * (int32_t)((v11 & 14) > 9) + v12 & 0xff00) - v1; // 0x10001ece
    char * v16 = (char *)a1; // 0x10001f23
    *v16 = *v16 + 1;
    __asm_out_4(v10, v14);
    char * v17 = (char *)v15; // 0x10001f2d
    *v17 = *v17 + (char)v15;
    return function_34d67382();
}

// Address range: 0x10001f46 - 0x10001fa9
int32_t function_10001f46(int16_t a1) {
    // 0x10001f46
    return -0x23323220;
}

// Address range: 0x10001faa - 0x10001ff7
int32_t function_10001faa(void) {
    // 0x10001faa
    int32_t v1; // 0x10001faa
    int32_t v2; // 0x10001faa
    if ((unsigned char)(char)v1 < (unsigned char)(char)v2) {
        // 0x10001fe6
        int16_t v3; // 0x10001faa
        return unknown_afe1c5e(v3);
    }
    // 0x10001fc3
    *(int32_t *)-0x1e99cf5 = *(int32_t *)-0x1e99cf5 + 27;
    int32_t v4; // 0x10001faa
    bool v5; // 0x10001faa
    return 0x10000 * ((v5 ? 0xffff : 1) + v4) / 0x10000;
}

// Address range: 0x1000200a - 0x10002013
int32_t function_1000200a(int32_t a1, int32_t a2) {
    // 0x1000200a
    return 0;
}

// Address range: 0x10002013 - 0x10002038
int32_t function_10002013(void) {
    // 0x10002013
    int32_t v1; // 0x10002013
    int32_t * v2 = (int32_t *)(v1 + 15); // 0x10002014
    *v2 = *v2 & -0x3950d6a2;
    int32_t v3; // 0x10002013
    int32_t v4 = unknown_cb9c0c4d(v3); // 0x1000201d
    char * v5 = (char *)(v1 - 0x4052451b); // 0x10002024
    *v5 = *v5 - (char)v4;
    int32_t v6; // 0x10002013
    char * v7 = (char *)(v6 | 161); // 0x1000202d
    int32_t v8; // 0x10002013
    *v7 = *v7 + (char)v8;
    return 0;
}

// Address range: 0x10002038 - 0x10002078
int32_t function_10002038(void) {
    // 0x10002038
    bool v1; // 0x10002038
    int32_t v2 = v1 ? -4 : 4; // 0x1000203b
    int32_t v3; // 0x10002038
    char v4 = *(char *)&v3; // 0x1000203c
    int32_t v5; // 0x10002038
    char v6 = v5; // 0x1000203c
    *(char *)v3 = v4 + v6;
    int32_t v7 = v3;
    int32_t v8 = unknown_1bac4bd0(); // 0x10002046
    int32_t v9; // 0x10002038
    int32_t v10 = v2 + v9; // bp-4, 0x10002051
    int32_t v11; // 0x10002038
    int32_t v12; // 0x10002038
    uint32_t v13; // 0x10002038
    *(int32_t *)((v8 + 83 + (int32_t)((char)((256 * (int32_t)((v4 & 15) + (v6 & 15) > 15 | (v7 & 14) > 9) + v7) / 256) < (char)((256 * v13 ^ v12) / 256)) & 255 | v8 & -256) + 26) = v2 + v11;
    int32_t v14; // 0x10002038
    int32_t * v15 = (int32_t *)(v14 - 79); // 0x10002058
    *v15 = *v15 & (int32_t)&v10;
    int32_t v16 = __asm_in_3((int16_t)v5); // 0x1000205b
    v3 = v16;
    if ((*(char *)(v5 - 0x7f44d01f) || (char)(v13 / 256)) != 0) {
        // 0x10002064
        return __asm_hlt();
    }
    // 0x1000206d
    *(int32_t *)v16 = 0;
    return function_194b8e18();
}

// Address range: 0x10002080 - 0x10002081
int32_t function_10002080(void) {
    // 0x10002080
    int32_t result; // 0x10002080
    return result;
}

// Address range: 0x100020a9 - 0x100020ad
int32_t function_100020a9(void) {
    int32_t result = function_100020af((int32_t)&g22, (int32_t)&g22, (int32_t)&g22, (int32_t)&g22); // 0x100020ab
    return result;
}

// Address range: 0x100020ad - 0x100020af
int32_t function_100020ad(void) {
    // 0x100020ad
    int32_t v1; // 0x100020ad
    int32_t v2; // 0x100020ad
    *(char *)v1 = (char)v2;
    int32_t result; // 0x100020ad
    return result;
}

// Address range: 0x100020af - 0x100020b3
int32_t function_100020af(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x100020af
    int32_t result; // 0x100020af
    return result;
}

// Address range: 0x100020b4 - 0x100023b1
int32_t function_100020b4(int32_t a1, int32_t a2) {
    // 0x100020b4
    bool v1; // 0x100020b4
    int32_t v2; // 0x100020b4
    char v3 = (char)v1 + (char)v2 - *(char *)0x558812a0; // 0x100020b4
    int32_t v4; // 0x100020b4
    int32_t v5; // 0x100020b4
    int32_t v6; // 0x100020b4
    __asm_rep_movsb_memcpy((char *)v4, (char *)v5, v6);
    *(char *)-0x2cbb5948 = -1;
    int32_t v7; // 0x100020b4
    unsigned char v8 = (char)v7;
    if (v3 < 0) {
        unsigned char v9 = v8 < 232 ? v8 : v8 + 24; // 0x100020c5
        uint32_t v10 = v7 & -0x10000 | (int32_t)v9 | 256 * (int32_t)(v8 > 231); // 0x100020c5
        int32_t * v11 = v9 != 0 ? (int32_t *)46 : (int32_t *)(v10 + 67);
        *v11 = v2 & -256 | (int32_t)v3;
        if (v10 >= 0x112584ae) {
            // 0x10002127
            return v10 - 0x112584ae & -0x8100;
        }
        int32_t result = __asm_iretd(); // 0x100020e1
        __asm_arpl(*(int16_t *)(result + 0xa1c3ac), (int16_t)v2 & -256 ^ -0x30ed);
        return result;
    }
    // 0x1000213e
    uint32_t v12; // 0x100020b4
    unsigned char v13 = *(char *)(v12 - 56) ^ v8; // 0x1000213e
    int32_t v14 = v7 & -256 | (int32_t)v13; // 0x1000213e
    *(int32_t *)0x74ed083b = v14;
    int32_t result2 = (v7 & -0x10000 | (int32_t)(v13 % 79) | 256 * (int32_t)(v13 / 79)) + 1; // 0x1000214c
    if (result2 == 0) {
        // 0x1000214f
        return result2;
    }
    // 0x10002154
    bool v15; // 0x100020b4
    int32_t v16 = v15 ? -1 : 1; // 0x100020ba
    int32_t v17 = v16 * v6 + v4; // 0x100020ba
    *(int32_t *)v17 = result2;
    int32_t v18 = v15 ? -4 : 4; // 0x10002156
    int32_t v19 = v17 + v18; // 0x10002156
    int32_t v20; // 0x100020b4
    if ((*(int32_t *)(v19 + 0x4f62cdd4) & v20) < 0) {
        // 0x1000219b
        *(char *)v19 = *(char *)v17;
        return -0x3cde4764;
    }
    unsigned char v21 = (*(char *)v14 | v3) + (char)(v12 / 256); // 0x1000214a
    int32_t v22 = v12 & 0xff00; // 0x10002154
    *(char *)-0x747fbf72 = *(char *)-0x747fbf72 + v21;
    int32_t v23; // bp-5, 0x100020b4
    int32_t v24 = (v2 & -0x10000 | (int32_t)v21) - (int32_t)&v23; // 0x10002175
    int32_t v25 = v19 + v16; // 0x10002177
    int32_t result3 = __asm_wait(); // 0x1000217f
    if ((v12 & -v12) < 0) {
        // 0x10002185
        *(char *)v25 = __asm_insb((int16_t)v24);
        *(int32_t *)(v22 | 45) = result3;
        int32_t * v26 = (int32_t *)(v25 + 0x185aaa5e); // 0x10002194
        *v26 = *v26 | v12 - 1;
        return result3;
    }
    int32_t * v27 = (int32_t *)(v25 + 0x475090f6); // 0x10002207
    *v27 = *v27 / 2;
    __asm_hlt();
    int32_t v28 = unknown_8fbf4f64(); // 0x10002226
    int32_t v29 = (256 * result3 + v22 & 0xff00 | 45) + 1; // 0x1000222d
    int32_t v30 = v28 + 1; // 0x1000222e
    char * v31 = (char *)v29; // 0x10002230
    unsigned char v32 = (char)v30; // 0x10002230
    *v31 = *v31 + v32;
    int32_t v33 = v32 < 169 ? v30 : v28 + 88; // 0x10002236
    char * v34 = (char *)((v28 + (v29 & 0xff00) & 0xff00 | 46) + 0x69df22b8); // 0x1000223c
    char v35 = *v34 & 46; // 0x1000223c
    *v34 = v35;
    if (v35 != 0) {
        // 0x1000214f
        return v33 & 255 | v28 & -0x10000 | 256 * (int32_t)(v32 > 168);
    }
    int32_t v36 = v25 + 2; // 0x1000222b
    int16_t v37; // 0x100020b4
    int32_t v38 = unknown_fb3fb48f(v37); // 0x100022c0
    *(char *)v36 = *(char *)v17;
    int32_t v39 = v38 & -200; // 0x100022cd
    if ((char)v39 == 16) {
        // 0x100022d3
        int32_t v40; // 0x100020b4
        int16_t v41; // 0x100020b4
        return v40 + 0x131ba549 & -256 | (int32_t)__asm_in(v41);
    }
    uint32_t v42 = v36 + v16; // 0x100022c7
    int32_t v43; // 0x100020b4
    uint32_t v44 = *(int32_t *)v43; // 0x10002336
    int32_t v45 = v42 - v44; // 0x10002336
    unsigned char v46 = (char)v45; // 0x10002338
    bool v47 = v42 < v44 | v46 > 153;
    int32_t v48; // 0x100020b4
    if ((v42 & 15) - (v44 & 15) > 15 || (v46 & 14) > 9) {
        v48 = (v47 ? 102 : 6) + v45 & 255 | v45 & -256;
    } else {
        v48 = (v47 ? v45 + 96 : v45) & 255 | v45 & -256;
    }
    int32_t v49 = 8 * v24; // 0x1000220d
    uint32_t v50 = v49 + (int32_t)&g13; // 0x1000220d
    unsigned char v51 = (char)v48 | -55; // 0x1000233c
    char v52 = llvm_ctpop_i8(v51); // 0x1000233c
    __asm_arpl(*(int16_t *)v39, -0x5a84);
    char v53 = *(char *)(v43 - 127); // 0x10002341
    int32_t v54 = v50 & -0xff02; // 0x10002341
    int32_t v55 = 256 * (int32_t)(v53 + (char)(v50 / 256)) | v54; // 0x10002341
    *(int32_t *)v39 = v48 & -0x10000 | (int32_t)v51 | 1024 * (int32_t)((v52 & 1) == 0) | 0x8200;
    *(char *)(v39 + v18) = *(char *)0x1a74a57c;
    int32_t v56 = *(int32_t *)0xe22d & 0xa4d8b8; // 0x1000234f
    int32_t * v57 = (int32_t *)v55; // 0x10002351
    int32_t v58 = *v57; // 0x10002351
    int32_t v59 = v58 + v56; // 0x10002351
    *v57 = v59;
    if ((v59 & (v58 ^ -0x80000000)) < 0) {
        int32_t result4 = __asm_int3() ^ 0x38f99fcf; // 0x100022ff
        __asm_out_6((int16_t)v55, result4);
        char * v60 = (char *)result4; // 0x10002306
        *v60 = *v60 & (char)result4;
        char * v61 = (char *)(result4 - 671); // 0x10002308
        *v61 = *v61 - 30;
        return result4;
    }
    int32_t v62 = v15 ? 0x1a74a57b : 0x1a74a57d; // 0x10002345
    char * v63 = (char *)v56; // 0x10002357
    char v64 = v50;
    *v63 = *v63 + v64;
    unknown_2afbb8f9(v37);
    uint32_t v65 = __asm_iretd(); // 0x10002364
    *(int32_t *)-0x5b2e35c3 = *(int32_t *)-0x5b2e35c3 ^ v65;
    char * v66 = (char *)v65; // 0x1000236d
    unsigned char v67 = *v66; // 0x1000236d
    unsigned char v68 = v67 + v64; // 0x1000236d
    *v66 = v68;
    int16_t v69 = (int16_t)*(int32_t *)-0x1be0fa81; // bp+32108, 0x1000236f
    int32_t v70 = &v69; // 0x1000236f
    int32_t v71 = v70; // 0x1000237a
    while ((char)(v65 / 256) + (char)v65 + (char)(v68 < v67) <= 0) {
        // 0x1000237f
        v71 -= 2;
    }
    // 0x10002385
    __asm_hlt();
    *(int32_t *)(v70 - 6) = -0x2cec841d;
    *(int32_t *)(v70 - 10) = -0x2cec841d;
    *(int32_t *)(v70 - 14) = -0x1be0fa9e;
    *(int32_t *)(v70 - 18) = v54;
    *(int32_t *)(v70 - 22) = *(int32_t *)(v62 + 115);
    *(int32_t *)-0x4733f051 = __asm_insd((int16_t)v54);
    *(char *)-0x1be0fa9e = *(char *)-0x1be0fa9e + v64;
    *(int32_t *)-0x4733f051 = *(int32_t *)v62;
    int32_t result5 = 98 - (int32_t)&g13 - v49 & 254 | -0x1be0fb00; // 0x100023a9
    *(char *)-0x4733f055 = *(char *)(v62 - 4);
    char * v72 = (char *)result5; // 0x100023ac
    *v72 = *v72 + v64;
    *(int32_t *)(v70 - 27) = *(int32_t *)-0x1be0fa82;
    return result5;
}

// Address range: 0x100023b2 - 0x100023dd
int32_t function_100023b2(int16_t a1) {
    // 0x100023b2
    int32_t v1; // 0x100023b2
    int32_t v2; // 0x100023b2
    int32_t v3 = *(int32_t *)(3 * v1) ^ v2; // 0x100023bc
    char v4 = llvm_ctpop_i8((char)v3); // 0x100023bc
    int32_t v5 = __asm_hlt(); // 0x100023c5
    char * v6 = (char *)(v5 + 1); // 0x100023cb
    char v7 = *v6; // 0x100023cb
    uint32_t v8; // 0x100023b2
    uint32_t v9; // 0x100023b2
    int32_t v10; // 0x100023b2
    *v6 = v7 + (char)(v9 / 256) + (char)((int64_t)(v10 & -0xff01 | 0x4000 * (int32_t)(v3 == 0) | 0x8000 * (int32_t)(v3 < 0) | 1024 * (int32_t)((v4 & 1) == 0) | 512) * (int64_t)v8 > 0xffffffff);
    char * v11 = (char *)v5; // 0x100023ce
    *v11 = *v11 + (char)v5;
    char * v12 = (char *)(v5 + 0xf5fd5f); // 0x100023d0
    *v12 = *v12 | 60;
    return v5 & -256 | (int32_t)*(char *)-0x59c9f000;
}

// Address range: 0x1000242f - 0x10002436
int32_t function_1000242f(void) {
    // 0x1000242f
    return function_860e752d();
}

// Address range: 0x10002448 - 0x1000244a
int32_t function_10002448(int32_t a1, int32_t a2) {
    // 0x10002448
    int32_t result; // 0x10002448
    return result;
}

// Address range: 0x100024a9 - 0x100024ab
int32_t function_100024a9(void) {
    // 0x100024a9
    return function_100024d6();
}

// Address range: 0x100024b8 - 0x100024bd
int32_t function_100024b8(void) {
    // 0x100024b8
    return function_e99a084a();
}

// Address range: 0x100024d6 - 0x10002544
int32_t function_100024d6(void) {
    // 0x100024d6
    int32_t v1; // 0x100024d6
    int32_t v2; // 0x100024d6
    __asm_outsb((int16_t)v2, (char)v1);
    int32_t v3; // 0x100024d6
    *(char *)0x4de1b1fc = (char)v3;
    int32_t v4 = __asm_int3(); // 0x100024dc
    uint32_t v5; // 0x100024d6
    char * v6 = (char *)(v5 - 31); // 0x100024e3
    unsigned char v7 = *v6; // 0x100024e3
    unsigned char v8 = v7 + (char)((v4 >> 31) / 256); // 0x100024e3
    bool v9; // 0x100024d6
    unsigned char v10 = v8 + (char)v9; // 0x100024e3
    *v6 = v10;
    int32_t v11 = __asm_bound(*(int64_t *)0x62f86a); // 0x100024e7
    int32_t v12; // 0x100024d6
    char v13 = *(char *)&v12; // 0x100024e9
    char v14 = v5; // 0x100024e9
    *(char *)v12 = v13 + v14 + (char)(v9 ? v10 <= v7 : v8 < v7);
    int32_t * v15 = (int32_t *)(v12 - 0x3df4f33c); // 0x100024eb
    uint32_t v16 = *v15; // 0x100024eb
    *v15 = v16 / 0x1000 | 0x100000 * v16;
    int32_t v17 = __asm_bound(*(int64_t *)(v11 - 0x771eb072 + (int32_t)((v16 & 0x1000) != 0))); // 0x100024f8
    uint32_t v18 = v5 / 256; // 0x100024fa
    unsigned char v19 = (char)v18; // 0x100024fa
    int32_t v20 = 512 * v18 & 0xfe00 | v5 & -0xff01; // 0x100024fa
    int32_t v21; // 0x100024d6
    *(int32_t *)(v20 - 112) = (int32_t)&v21;
    __asm_bound(*(int64_t *)v17);
    int32_t v22; // 0x100024d6
    char * v23 = (char *)(v22 + 58); // 0x10002502
    *v23 = (char)(-1 - v19 < v19) + v14 + *v23;
    int32_t v24; // 0x100024d6
    int32_t v25 = *(int32_t *)(v24 - 12) | v1; // 0x1000250a
    unsigned char v26 = *(char *)(v22 - 3); // 0x10002511
    __asm_arpl(*(int16_t *)v25, (int16_t)v12);
    __asm_iretd();
    *(char *)(v20 & -512 | (int32_t)v26) = 2 * (char)v18;
    __asm_bound(*(int64_t *)__asm_in_2(248));
    char v27; // 0x100024d6
    char * v28 = (char *)((int32_t)v27 + 0x62fc0d); // 0x1000252b
    unsigned char v29 = *v28; // 0x1000252b
    unsigned char v30 = v29 + v27; // 0x1000252b
    unsigned char v31 = v30 + (char)((v25 & 0x4000) != 0); // 0x1000252b
    *v28 = v31;
    uint32_t v32; // 0x100024d6
    char * v33 = (char *)(v32 + 0x2a51e304); // 0x10002531
    char v34 = *v33; // 0x10002531
    char v35 = v32 / 256; // 0x10002531
    char v36 = (v25 & 0x4000) != 0 ? v31 <= v29 : v30 < v29; // 0x10002531
    *v33 = v34 + v35 + v36;
    int32_t v37 = __asm_int3(); // 0x1000253d
    bool v38 = (v37 & 14) > 9 | (v34 & 15) + (v35 & 15) + v36 > 15; // 0x1000253f
    int32_t v39 = v38 ? v37 + 6 : v37; // 0x1000253f
    return v39 & 15 | v37 & -0x10000 | 256 * (int32_t)v38 + v37 & 0xff00;
}

// Address range: 0x10002544 - 0x1000255c
int32_t function_10002544(void) {
    // 0x10002544
    return unknown_a0b83e();
}

// Address range: 0x10002588 - 0x100025a6
int32_t function_10002588(int32_t a1) {
    // 0x10002588
    int32_t v1; // 0x10002588
    char * v2 = (char *)(v1 - 0x77ad32bb); // 0x1000258e
    int32_t v3; // 0x10002588
    bool v4; // 0x10002588
    *v2 = *v2 + (char)v3 + (char)v4;
    return function_f06e538a();
}

// Address range: 0x100025b7 - 0x100025b8
int32_t function_100025b7(void) {
    // 0x100025b7
    int32_t result; // 0x100025b7
    return result;
}

// Address range: 0x100025de - 0x100025e0
int32_t function_100025de(void) {
    // 0x100025de
    return function_10002617((int32_t)&g22);
}

// Address range: 0x100025f1 - 0x10002617
int32_t function_100025f1(int32_t a1) {
    unsigned char v1 = *(char *)-0x2a70f000; // 0x100025f1
    int32_t v2; // 0x100025f1
    int32_t v3 = __asm_in_3((int16_t)v2); // 0x100025fb
    int32_t v4 = v3; // 0x100025fd
    if (v1 + 39 + (v1 > 216 ? 68 : 69) >= 0) {
        v4 = function_100025b7();
    }
    int32_t v5 = v3 >> 31; // 0x100025fc
    int32_t result; // 0x100025f1
    unsigned char v6 = (char)result;
    int32_t v7; // 0x100025f1
    int32_t v8 = ((char)v5 < (char)v7 ? 76 : 75) + v4; // 0x10002601
    int32_t v9; // 0x100025f1
    int16_t v10 = *(int16_t *)(v9 - 0x3f6a3684); // 0x10002606
    __asm_arpl(v10, (int16_t)(v5 - v7 & 255 | v5 & 0xff00));
    char v11 = v6 / 128; // 0x1000260c
    *(char *)result = v11 | 2 * v6;
    int32_t v12; // 0x100025f1
    char * v13 = (char *)(v12 - 0x2ac60eab); // 0x1000260e
    unsigned char v14 = *v13; // 0x1000260e
    unsigned char v15 = v14 + (char)v8; // 0x1000260e
    unsigned char v16 = v15 + (char)(v11 != 0); // 0x1000260e
    *v13 = v16;
    int32_t v17 = v11 != 0 ? v16 <= v14 : v15 < v14 ? -79 : -80; // 0x10002614
    *(int32_t *)result = (v8 & 255 | v4 & -256) - v17;
    return result;
}

// Address range: 0x10002617 - 0x10002660
int32_t function_10002617(int32_t a1) {
    // 0x10002617
    int32_t v1; // 0x10002617
    unsigned char v2 = (char)v1;
    char v3 = v2 / 128; // 0x10002617
    *(char *)v1 = v3 | 2 * v2;
    int32_t v4; // 0x10002617
    char v5 = v4; // 0x10002619
    int32_t result; // 0x10002617
    *(char *)result = (char)(v3 != 0) + v5 + *(char *)&result;
    int32_t v6 = result & -0xff01 | 0xd000; // 0x1000261b
    result = v6;
    char * v7 = (char *)v6; // 0x1000261d
    unsigned char v8 = *v7; // 0x1000261d
    unsigned char v9 = v8 + v5; // 0x1000261d
    *v7 = v9;
    int32_t v10; // 0x10002617
    int32_t v11; // 0x10002617
    int32_t v12 = v11 - v10 + (int32_t)(v9 < v8); // 0x1000261f
    int32_t v13; // 0x10002617
    if (v13 != 1 && v12 != 0) {
        // 0x1000265d
        return result;
    }
    // 0x10002623
    int32_t v14; // 0x10002617
    int32_t v15 = v14 + 1; // 0x10002623
    int32_t v16 = *(int32_t *)(v4 + 0x5b51fbe2) | result; // bp-4, 0x1000262a
    result = v15;
    uint32_t v17 = v15 & 31; // 0x10002636
    if (v17 != 0) {
        *(int32_t *)v4 = v4 << v17;
    }
    char * v18 = (char *)(v10 - 52); // 0x10002638
    *v18 = 2 * *v18;
    __asm_outsb((int16_t)v4, v5);
    int32_t * v19 = (int32_t *)(v12 + 94); // 0x10002647
    uint32_t v20 = *v19; // 0x10002647
    *v19 = v20 / 2 | 0x80000000 * v20;
    int32_t v21; // 0x10002617
    int32_t v22 = *(int32_t *)(v21 - 21); // 0x1000264a
    *(int32_t *)(v21 - 41) = v22 | *(int32_t *)(v10 + 0x59480afb) ^ result;
    int32_t * v23 = (int32_t *)(*(int32_t *)(v4 + 82 + 8 * v4) - 9); // 0x10002654
    *v23 = *v23 - 37;
    return function_df0d09de(v10, v4, v21 - 1, &v16, v12, v4, v15, result);
}

// Address range: 0x100026ae - 0x100026af
int32_t function_100026ae(void) {
    // 0x100026ae
    int32_t result; // 0x100026ae
    return result;
}

// Address range: 0x100026b6 - 0x100026b7
int32_t function_100026b6(void) {
    // 0x100026b6
    int32_t result; // 0x100026b6
    return result;
}

// Address range: 0x100026dd - 0x100026e6
int32_t function_100026dd(void) {
    // 0x100026dd
    int32_t v1; // 0x100026dd
    int32_t v2; // 0x100026dd
    *(char *)v2 = (char)v2 + (char)v1;
    return function_f06e7f8a();
}

// Address range: 0x100026e6 - 0x10002836
int32_t function_100026e6(void) {
    char v1 = *(char *)-0x5f334ad1; // 0x100026eb
    int32_t v2; // 0x100026e6
    char v3 = v2; // 0x100026eb
    char v4 = v1 + v3; // 0x100026eb
    char v5 = llvm_ctpop_i8(v4); // 0x100026eb
    *(char *)-0x5f334ad1 = v4;
    int32_t v6; // 0x100026e6
    int32_t v7 = v6;
    int32_t v8; // 0x100026e6
    int32_t v9 = v8;
    int32_t v10; // bp-8, 0x100026e6
    int32_t v11 = &v10;
    int32_t v12; // 0x100026e6
    *(char *)(v7 - 31) = (char)v12;
    int32_t v13; // 0x100026e6
    int32_t v14 = v13 - 31; // 0x100026f6
    if ((v5 & 1) != 0) {
        v14 = function_100026b6();
    }
    int32_t v15 = 0x10000 * v14 / 0x10000; // 0x100026f9
    if (((v4 ^ v1) & (v4 ^ v3)) < 0) {
        v15 = function_100026ae();
    }
    uint32_t v16 = v15;
    int32_t v17 = v7 + 1 & 0xffff | v7 & -0x10000; // 0x100026fb
    float80_t v18; // 0x100026e6
    float80_t v19 = 2 * v18; // 0x100026fd
    unsigned char v20 = (char)v16; // 0x100026ff
    int32_t v21; // 0x100026e6
    __asm_out_4((int16_t)v21, v20);
    int32_t v22 = 256 * (int32_t)*(char *)(v17 - 75) | v21 & -0xff01; // 0x10002700
    int32_t v23; // 0x100026e6
    int32_t v24; // 0x100026e6
    while (*(char *)v22 <= v20) {
        int32_t v25 = v16 - 0x2f3f5e94; // 0x10002709
        char * v26 = (char *)v25; // 0x1000270e
        *v26 = *v26 + (char)v21;
        *(int32_t *)(8 * v24 - 120 + v22) = v25;
        int32_t v27 = v17 - 1; // 0x10002714
        if ((llvm_ctpop_i8((char)v27) & 1) == 0) {
            // 0x10002718
            return function_b4360ac2();
        }
        bool v28 = (v7 & -v17) < 0; // 0x100026e6
        v21 = v22;
        int32_t v29 = v9 + 4; // 0x100026e6
        v7 = v27;
        v9 = *(int32_t *)v9;
        v11 = v29;
        *(char *)(v7 - 31) = (char)v23;
        v14 = v25;
        v14 = function_100026b6();
        // 0x100026f8
        v15 = 0x10000 * v14 / 0x10000;
        if (v28) {
            v15 = function_100026ae();
        }
        // 0x100026fb
        v16 = v15;
        v17 = v7 + 1 & 0xffff | v7 & -0x10000;
        v19 = 2 * ((float80_t)*(float64_t *)&v23 - v19);
        v20 = (char)v16;
        __asm_out_4((int16_t)v21, v20);
        v22 = 256 * (int32_t)*(char *)(v17 - 75) | v21 & -0xff01;
    }
    char * v30 = (char *)(v17 - 0x3990a12b); // 0x10002733
    *v30 = *v30 + (char)v23;
    int32_t v31 = v11 - 4; // 0x10002739
    *(int32_t *)v31 = v9;
    int32_t v32 = *(int32_t *)(9 * v23) & v31; // 0x1000273a
    char v33 = llvm_ctpop_i8((char)v32); // 0x1000273a
    int32_t * v34 = (int32_t *)v32; // 0x1000273e
    int32_t v35 = *v34; // 0x1000273e
    v23 = v35;
    bool v36; // 0x100026e6
    bool v37; // 0x100026e6
    bool v38; // 0x100026e6
    bool v39; // 0x100026e6
    *v34 = 0x4000 * (int32_t)v36 | 1024 * (int32_t)v37 | 512 * (int32_t)v38 | 256 * (int32_t)v39 | 64 * (int32_t)(v32 == 0) | 128 * (int32_t)(v32 < 0) | 4 * (int32_t)((v33 & 1) == 0) | 2;
    uint64_t v40 = (int64_t)v32 * (int64_t)v16; // 0x10002741
    uint64_t v41 = v40 / 0x100000000; // 0x10002741
    int32_t v42 = v41; // 0x10002741
    *(char *)-0x5ae8f000 = (char)v40;
    int32_t v43 = v32 + 4; // 0x10002748
    int32_t v44; // 0x100026e6
    char * v45 = (char *)(v44 + 0x70fdf545); // 0x1000274e
    *v45 = *v45 + (char)v35 + (char)(v42 != 0);
    unsigned char v46 = *(char *)(v24 + (int32_t)&g19); // 0x10002754
    int32_t v47 = ((int32_t)v40 & -0x10000 | (int32_t)((int16_t)v40 / (int16_t)v46 & 255)) ^ 0xd03a; // 0x1000275e
    char * v48 = (char *)v47; // 0x10002760
    char v49 = v41; // 0x10002760
    *v48 = *v48 + 2 * (char)v41;
    int32_t * v50 = (int32_t *)v43; // 0x10002768
    int32_t v51 = (v47 & -0x3000 | (int32_t)*(char *)-0x2a8f000) ^ 0x4815ff00; // 0x1000276e
    char * v52 = (char *)v23; // 0x10002773
    *v52 = *v52 + v49;
    char * v53 = (char *)v51; // 0x10002776
    *v53 = *v53 + v49;
    int32_t v54 = v37 ? -2 : 2; // 0x10002779
    int32_t v55 = *v50 + v54; // 0x1000277a
    int32_t v56 = v54 + v24; // 0x1000277a
    *(int32_t *)(v32 + 8) = v56;
    char * v57 = (char *)(v23 + 24); // 0x10002783
    *v57 = *v57 - (char)(v40 / 0x10000000000);
    v23 = 0xd17f681;
    *v50 = v51 & -256 | (int32_t)*(char *)-0x6bc6f000;
    int32_t v58 = v9 - 3; // 0x1000278e
    *v34 = 0xd17f681;
    int32_t v59 = v55 ^ v42; // 0x10002792
    int32_t v60 = v58; // 0x10002795
    int32_t v61 = v43; // 0x10002795
    if (v59 < 0) {
        // 0x10002797
        *v34 = v56;
        *(int32_t *)-0x64ce1ba7 = v58;
        __asm_int1();
        v60 = __asm_hlt();
        v61 = v32 - 4;
        *(int32_t *)v61 = -0x5fcf4ad1;
    }
    char * v62 = (char *)v60; // 0x100027ab
    char v63 = v59; // 0x100027ab
    *v62 = *v62 + v63;
    int32_t v64 = *(int32_t *)0x1000a02c; // 0x100027ad
    *(int32_t *)v55 = __asm_insd((int16_t)v59);
    unsigned char v65 = __asm_in_5(-94); // 0x100027b4
    int32_t v66 = v60 & -256 | (int32_t)v65; // 0x100027b4
    char * v67 = (char *)v66; // 0x100027b6
    *v67 = *v67 + v63;
    int32_t v68 = v61 - 4; // 0x100027b8
    *(int32_t *)v68 = v44;
    uint32_t v69 = v66 >> 31; // 0x100027bb
    unsigned char v70 = (char)v23; // 0x100027bc
    unsigned char v71 = (char)(v69 / 256); // 0x100027bc
    char v72 = v65 < 79; // 0x100027bc
    unsigned char v73 = v71 + v72; // 0x100027bc
    unsigned char v74 = v70 - v73; // 0x100027bc
    bool v75 = v65 < 79 ? v73 != -1 | v74 - v72 > v70 : v73 > v70; // 0x100027bc
    int32_t v76 = v23 & -256 | (int32_t)v74; // 0x100027bc
    v23 = v76;
    int32_t v77 = __asm_int3(); // 0x100027be
    unsigned char v78 = *(char *)&v44 + v71; // 0x100027bf
    unsigned char v79 = v78 + (char)v75; // 0x100027bf
    int32_t v80 = 256 * (int32_t)v79 | v69 & -0xff01; // 0x100027bf
    *(int32_t *)(v61 - 8) = v77;
    *(int32_t *)(v61 - 12) = v76;
    *(int32_t *)(v61 - 16) = v80;
    *(int32_t *)(v61 - 20) = v44;
    *(int32_t *)(v61 - 24) = v68;
    *(int32_t *)(v61 - 28) = 0xd17f681;
    *(int32_t *)(v61 - 32) = v64;
    *(int32_t *)(v61 - 36) = v55;
    unknown_2708b749();
    int32_t v81 = v44; // 0x100027c7
    bool v82 = v75 ? v79 <= v71 : v78 < v71; // 0x100027c7
    uint32_t v83 = v81 / 256; // 0x100027cb
    unsigned char v84 = (char)v83; // 0x100027cb
    unsigned char v85 = 2 * (char)v83; // 0x100027cb
    unsigned char v86 = v85 | (char)v82; // 0x100027cb
    v82 = v82 ? v86 <= v84 : v85 < v84;
    v81 = 256 * (int32_t)v86 | v81 & -0xff01;
    while (v86 != 0) {
        // 0x100027cb
        v83 = v81 / 256;
        v84 = (char)v83;
        v85 = 2 * (char)v83;
        v86 = v85 | (char)v82;
        v82 = v82 ? v86 <= v84 : v85 < v84;
        v81 = 256 * (int32_t)v86 | v81 & -0xff01;
    }
    // 0x100027cf
    v44 = v81;
    int32_t v87 = RegCloseKey(&g22); // 0x100027cf
    __asm_outsd((int16_t)v80 - 1, *(int32_t *)v64);
    char * v88 = (char *)v87; // 0x100027e5
    unsigned char v89 = *v88; // 0x100027e5
    *v88 = v89 - 65;
    unsigned char v90 = (char)v87; // 0x100027e7
    bool v91 = v90 > 153 | v89 > 64;
    char v92 = v91 ? v90 - 96 : v90;
    int32_t v93 = v23; // 0x100027e8
    v23 = v93 & -0xff01 | 0xbc00;
    int32_t v94 = v87 & -256 | (int32_t)*(char *)-0x3f7af000; // 0x100027ea
    if (((v90 & 14) > 9 || (v89 & 15) != 0 ? (v91 ? -102 : -6) + v90 : v92) != 0) {
        char * v95 = (char *)v94; // 0x100027fb
        *v95 = *v95 - 65;
        return __asm_bound(*(int64_t *)v94);
    }
    // 0x10002802
    __asm_bound(*(int64_t *)(v94 | -0x130e3c43));
    char * v96 = (char *)(v55 + 0x55c3c095); // 0x10002809
    *v96 = *v96 + (char)v93;
    *(char *)-0x2b05fad5 = *(char *)-0x2b05fad5 | -65;
    uint32_t v97 = __asm_wait(); // 0x1000281c
    *(float80_t *)-0x93e9fcc = v19 * (float80_t)*(int32_t *)(v64 + 0x100062ec);
    __asm_arpl_7((int16_t)v55);
    char * v98 = (char *)(v23 + 0x4c71000); // 0x10002828
    *v98 = (char)(v97 / 256) + 1 + *v98;
    *(char *)-0x493bff4c = *(char *)-0x493bff4c - 65;
    return v97 & -20;
}

// Address range: 0x1000288d - 0x1000289e
int32_t function_1000288d(void) {
    // 0x1000288d
    int32_t v1; // 0x1000288d
    char * v2 = (char *)(v1 + 0x6a2a74c0); // 0x1000288d
    int32_t v3; // 0x1000288d
    bool v4; // 0x1000288d
    *v2 = *v2 + (char)v3 + (char)v4;
    return function_d933c1ec();
}

// Address range: 0x100028ad - 0x100028ce
int32_t function_100028ad(int32_t a1) {
    // 0x100028ad
    int32_t v1; // 0x100028ad
    char * v2 = (char *)(v1 - 2); // 0x100028af
    int32_t v3; // 0x100028ad
    bool v4; // 0x100028ad
    *v2 = *v2 + (char)v3 + (char)v4;
    int32_t v5 = __asm_in_3((int16_t)v3 & 255); // 0x100028b5
    char v6 = __asm_in_5(-103); // 0x100028ba
    int32_t v7; // 0x100028ad
    char * v8 = (char *)(v7 - 0x7d96f000); // 0x100028be
    *v8 = 2 * *v8;
    return (v5 | (int32_t)v6) & -256 | (int32_t)(v6 + 89);
}

// Address range: 0x100028ce - 0x100028cf
int32_t function_100028ce(int32_t a1) {
    // 0x100028ce
    int32_t result; // 0x100028ce
    return result;
}

// Address range: 0x100028d2 - 0x100028dd
int32_t function_100028d2(void) {
    // 0x100028d2
    int32_t v1; // 0x100028d2
    int32_t v2; // 0x100028d2
    __asm_out_4((int16_t)v1, (char)v2);
    return function_638f0c83();
}

// Address range: 0x10002916 - 0x1000291d
int32_t function_10002916(void) {
    // 0x10002916
    int32_t v1; // 0x10002916
    int32_t v2; // 0x10002916
    *(char *)v2 = (char)v2 + (char)v1;
    __asm_sti();
    return function_100028ce(115);
}

// Address range: 0x10002921 - 0x10002922
int32_t function_10002921(void) {
    // 0x10002921
    int32_t result; // 0x10002921
    return result;
}

// Address range: 0x1000294c - 0x10002951
int32_t function_1000294c(void) {
    // 0x1000294c
    uint32_t v1; // 0x1000294c
    uint32_t v2; // 0x1000294c
    uint32_t v3; // 0x1000294c
    return (0x100000000 * (int64_t)v2 | (int64_t)v3) / (int64_t)v1;
}

// Address range: 0x10002951 - 0x10002995
int32_t function_10002951(void) {
    // 0x10002951
    uint32_t v1; // 0x10002951
    unsigned char v2 = (char)v1;
    char v3 = v2 / 128; // 0x10002951
    *(char *)v1 = v3 | 2 * v2;
    int32_t v4; // 0x10002951
    char * v5 = (char *)(v4 - 16); // 0x10002953
    unsigned char v6 = *v5; // 0x10002953
    unsigned char v7 = v6 + (char)(v1 / 256); // 0x10002953
    unsigned char v8 = v7 + (char)(v3 != 0); // 0x10002953
    bool v9 = v3 != 0 ? v8 <= v6 : v7 < v6; // 0x10002953
    *v5 = v8;
    int32_t v10; // 0x10002951
    unsigned char v11 = *(char *)&v10; // 0x10002958
    unsigned char v12 = v11 + (char)v10; // 0x10002958
    unsigned char v13 = v12 + (char)v9; // 0x10002958
    *(char *)v10 = v13;
    if (!((v9 ? v13 <= v11 : v12 < v11))) {
        function_10002921();
    }
    // 0x1000295d
    __asm_hlt();
    unknown_e313ca5b();
    int32_t v14; // 0x10002951
    char * v15 = (char *)(v14 - 2104 & -256 | (int32_t)__asm_in_5(-95)); // 0x10002977
    *v15 = *v15 + (char)*(int32_t *)0x5b4c1000;
    int16_t v16; // 0x10002951
    int32_t v17 = unknown_54102a25(v16); // 0x1000297e
    int32_t v18; // 0x10002951
    char * v19 = (char *)(v18 + 38); // 0x10002989
    *v19 = *v19 - 56;
    return v17 & -0x10000 | (v17 | 29) + 110 & 111 | 256;
}

// Address range: 0x10002995 - 0x100029a5
int32_t function_10002995(char a1, int32_t a2) {
    // 0x10002995
    int32_t v1; // 0x10002995
    int32_t result = __asm_in_3((int16_t)v1); // 0x10002995
    char * v2 = (char *)(v1 + 0x3401f39c); // 0x1000299a
    *v2 = -1 - *v2;
    return result;
}

// Address range: 0x100029cd - 0x10002a0a
int32_t function_100029cd(int16_t a1, int32_t a2, int32_t a3) {
    // 0x100029cd
    uint32_t v1; // 0x100029cd
    int32_t v2 = v1 & -256 | (int32_t)(*(char *)-0x762af000 - 96); // 0x100029d9
    char * v3 = (char *)v2; // 0x100029db
    int32_t v4; // 0x100029cd
    *v3 = *v3 + (char)v4;
    uint32_t v5 = v1 / 0x80000000; // 0x100029dd
    unsigned char v6 = *(char *)(v2 - 63) ^ (char)(v1 / 256); // 0x100029e0
    int32_t v7 = v1 & -0x10000 | (int32_t)*(char *)0x57d61000; // 0x100029e0
    float80_t v8; // 0x100029cd
    *(float32_t *)((v7 | 256 * (int32_t)v6) - 0x5858d715) = (float32_t)v8;
    int32_t v9; // 0x100029cd
    bool v10; // 0x100029cd
    int32_t v11 = *(int32_t *)((v10 ? -1 : 1) + v9); // 0x10002a01
    __asm_outsd((int16_t)(256 * (int32_t)(v6 ^ (char)(v5 / 256)) | v5 & 255), v11);
    int32_t v12; // 0x100029cd
    *(char *)(v12 - 0xaec4c56) = -12;
    return v7 | 0xf400;
}

// Address range: 0x10002a0a - 0x10002af8
int32_t function_10002a0a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x10002a0a
    int32_t v1; // 0x10002a0a
    int32_t v2; // 0x10002a0a
    *(char *)v1 = __asm_insb((int16_t)v2);
    int32_t v3; // 0x10002a0a
    int32_t v4 = *(int32_t *)(v3 + 8); // 0x10002a0e
    int32_t v5 = v3 - 0x150a059e; // 0x10002a70
    bool v6 = false; // 0x10002a76
    if (v5 >= 0) {
        int32_t result; // 0x10002a0a
        if (v5 != 0) {
            // 0x10002a87
            return result;
        }
        // 0x10002a9e
        __asm_fldenv(*(int224_t *)(result - 90));
        int16_t v7; // 0x10002a0a
        return unknown_f7ce0d60(v7);
    }
    int32_t v8; // 0x10002a0a
    uint32_t v9 = v8 / 256; // 0x10002aeb
    unsigned char v10 = (char)v9; // 0x10002aeb
    unsigned char v11 = 2 * (char)v9; // 0x10002aeb
    unsigned char v12 = v11 | (char)v6; // 0x10002aeb
    v6 = v6 ? v12 <= v10 : v11 < v10;
    while (v12 != 0) {
        // 0x10002ae7
        v9 = 256 * (int32_t)v12 / 256;
        v10 = (char)v9;
        v11 = 2 * (char)v9;
        v12 = v11 | (char)v6;
        v6 = v6 ? v12 <= v10 : v11 < v10;
    }
    bool handleClosed = CloseHandle(&g22); // 0x10002aef
    float80_t v13; // 0x10002a0a
    *(float32_t *)(*(int32_t *)(v4 | 23) - 127) = (float32_t)v13;
    return handleClosed;
}

// Address range: 0x10002b24 - 0x10002b2b
int32_t function_10002b24(void) {
    // 0x10002b24
    return unknown_a30c4b();
}

// Address range: 0x10002b33 - 0x10002b34
int32_t function_10002b33(void) {
    // 0x10002b33
    int32_t result; // 0x10002b33
    return result;
}

// Address range: 0x10002b34 - 0x10002b3c
int32_t function_10002b34(void) {
    // 0x10002b34
    int32_t v1; // 0x10002b34
    int32_t v2; // 0x10002b34
    __asm_outsb((int16_t)v2, (char)v1);
    return unknown_9fba9d4();
}

// Address range: 0x10002b3f - 0x10002b46
int32_t function_10002b3f(void) {
    // 0x10002b3f
    return function_f06e7f8a();
}

// Address range: 0x10002b46 - 0x10002b5d
int32_t function_10002b46(int16_t a1, int32_t a2) {
    // 0x10002b46
    int32_t v1; // 0x10002b46
    unsigned char v2 = (char)v1; // 0x10002b47
    bool v3; // 0x10002b46
    bool v4 = v2 > 153 | v3;
    int32_t v5; // 0x10002b46
    bool v6; // 0x10002b46
    if (v6 || (v2 & 14) > 9) {
        v5 = (v4 ? 154 : 250) + v1 & 255 | v1 & -256;
    } else {
        v5 = (v4 ? v1 + 160 : v1) & 255 | v1 & -256;
    }
    int32_t v7 = v5;
    char * v8 = (char *)(v7 + 34); // 0x10002b49
    unsigned char v9 = *v8; // 0x10002b49
    uint32_t v10; // 0x10002b46
    char v11 = v10 / 256; // 0x10002b49
    char v12 = v4; // 0x10002b49
    unsigned char v13 = v9 + v11; // 0x10002b49
    unsigned char v14 = v13 + v12; // 0x10002b49
    *v8 = v14;
    unsigned char v15 = (char)v7; // 0x10002b4c
    bool v16 = v15 > 153 | (v4 ? v14 <= v9 : v13 < v9);
    int32_t v17; // 0x10002b46
    if ((v15 & 14) > 9 || (v11 & 15) + v12 + (v9 & 15) > 15) {
        v17 = (v16 ? 154 : 250) + v7 & 255 | v7 & -256;
    } else {
        int32_t v18 = v16 ? v7 + 160 : v7; // 0x10002b4c
        v17 = v18 & 255 | v7 & -256;
    }
    char * v19 = (char *)v17; // 0x10002b4d
    char v20 = *v19 + (char)v17; // 0x10002b4d
    char v21 = llvm_ctpop_i8(v20); // 0x10002b4d
    *v19 = v20;
    *(char *)(a2 - 87) = (char)v10;
    if ((v21 & 1) != 0) {
        function_10002b33();
    }
    // 0x10002b58
    return function_ac770516();
}

// Address range: 0x10002ba7 - 0x10002baa
int32_t function_10002ba7(int32_t a1) {
    // 0x10002ba7
    int32_t result; // 0x10002ba7
    return result;
}

// Address range: 0x10002bbc - 0x10002bd2
int32_t function_10002bbc(void) {
    // 0x10002bbc
    int32_t v1; // 0x10002bbc
    uint32_t v2; // 0x10002bbc
    *(char *)v2 = (char)v2 + (char)v1;
    int32_t v3 = 196 * v2 / 256 + (v2 ^ 46); // 0x10002bc7
    int32_t v4 = v3 & 255 | v2 & -0x10000; // 0x10002bc7
    char * v5 = (char *)v4; // 0x10002bc9
    unsigned char v6 = *v5; // 0x10002bc9
    char v7 = v6 / 128; // 0x10002bc9
    *v5 = (v7 | 2 * v6) + (char)v3 + (char)(v7 != 0);
    return v4 + 1;
}

// Address range: 0x10002bf7 - 0x10002bfd
int32_t function_10002bf7(int32_t a1) {
    // 0x10002bf7
    int32_t v1; // 0x10002bf7
    int32_t result; // 0x10002bf7
    *(char *)result = (char)result + (char)v1;
    __asm_bound(*(int64_t *)(result + 19));
    return result;
}

// Address range: 0x10002c4c - 0x10002c4d
int32_t function_10002c4c(void) {
    // 0x10002c4c
    int32_t result; // 0x10002c4c
    return result;
}

// Address range: 0x10002c5e - 0x10002c7d
int32_t function_10002c5e(int32_t a1) {
    int32_t v1 = a1;
    int32_t v2; // 0x10002c5e
    char * v3 = (char *)(v2 - 16); // 0x10002c61
    uint32_t v4; // 0x10002c5e
    bool v5; // 0x10002c5e
    *v3 = (char)v5 + (char)(v4 / 256) + *v3;
    int32_t v6; // 0x10002c5e
    int32_t v7; // 0x10002c5e
    *(char *)v7 = *(char *)&v6 + 89;
    int32_t v8; // 0x10002c5e
    *(int32_t *)(v8 - 0x562b142a) = v1;
    return function_10002cc6(&v1);
}

// Address range: 0x10002c7d - 0x10002c9d
int32_t function_10002c7d(void) {
    // 0x10002c7d
    int32_t v1; // 0x10002c7d
    int32_t v2; // 0x10002c7d
    bool v3; // 0x10002c7d
    bool v4; // 0x10002c7d
    if (v4 == v3) {
        int32_t v5 = function_10002c4c(); // 0x10002c7d
        v2 = v5;
        v1 = v5;
    }
    int32_t v6 = 0x10000 * v1 / 0x10000; // 0x10002c7f
    int32_t * v7 = (int32_t *)(v6 - 112); // 0x10002c82
    *v7 = *v7 / 2;
    int32_t v8; // 0x10002c7d
    *(char *)v6 = *(char *)&v2 + (char)v8;
    int32_t v9; // 0x10002c7d
    return function_10002d0e(v9, -0x4963acb6);
}

// Address range: 0x10002cbf - 0x10002cc6
int32_t function_10002cbf(void) {
    // 0x10002cbf
    return function_82c07b4a();
}

// Address range: 0x10002cc6 - 0x10002d0b
int32_t function_10002cc6(int32_t * a1) {
    int32_t * v1 = a1;
    int32_t v2; // 0x10002cc6
    char v3 = v2;
    int32_t v4; // 0x10002cc6
    *(char *)v4 = (char)v4 + v3;
    int32_t v5; // 0x10002cc6
    char * v6 = (char *)(v5 + 0x4c0e1000); // 0x10002cd5
    unsigned char v7 = *v6; // 0x10002cd5
    unsigned char v8 = (char)((v5 + 0xfee4) / 256); // 0x10002cd5
    *v6 = v7 - v8;
    char v9 = v3; // 0x10002cdb
    if (v7 < v8) {
        char v10 = __asm_in((int16_t)v2); // 0x10002ce2
        int64_t v11 = *(int64_t *)(*(int32_t *)-0x7d09f000 & -256 | (int32_t)v10); // 0x10002ce3
        v9 = __asm_bound(v11);
        char v12 = v9 - 1; // 0x10002cea
        *(char *)v2 = v12;
        if (v12 == 0) {
            // 0x10002cef
            return unknown_afe270e((int16_t *)&v1);
        }
        // 0x10002cf7
        __asm_int3();
    }
    int32_t result = __asm_int3(); // 0x10002d01
    int32_t * v13 = (int32_t *)(result - 20); // 0x10002d02
    *v13 = *v13 / 4;
    char * v14 = (char *)result; // 0x10002d06
    *v14 = *v14 + v9;
    return result;
}

// Address range: 0x10002d0e - 0x10002d11
int32_t function_10002d0e(int32_t a1, int32_t a2) {
    // 0x10002d0e
    int32_t v1; // 0x10002d0e
    int32_t v2; // 0x10002d0e
    return v1 & 0xff00 ^ v2;
}

// Address range: 0x10002d15 - 0x10002d16
int32_t function_10002d15(void) {
    // 0x10002d15
    int32_t result; // 0x10002d15
    return result;
}

// Address range: 0x10002d1b - 0x10002d71
int32_t function_10002d1b(void) {
    // 0x10002d1b
    int32_t v1; // 0x10002d1b
    char * v2 = (char *)(v1 + 94); // 0x10002d66
    int32_t v3; // 0x10002d1b
    bool v4; // 0x10002d1b
    *v2 = (char)v4 - (char)v3 + *v2;
    int32_t result; // 0x10002d1b
    return result;
}

// Address range: 0x10002d72 - 0x10002e0f
int32_t function_10002d72(int16_t a1) {
    // 0x10002d72
    int32_t v1; // 0x10002d72
    bool v2; // 0x10002d72
    if (v2) {
        v1 = function_10002d15();
    }
    int32_t v3 = v1;
    int32_t v4; // 0x10002d72
    *(char *)v3 = (char)v3 + (char)v4;
    int32_t v5 = v3 + 0x36471c21; // 0x10002d77
    bool v6; // 0x10002d72
    int32_t v7 = v6 ? -1 : 1; // 0x10002d7c
    int32_t v8; // 0x10002d72
    uint32_t v9 = v7 + v8; // 0x10002d7c
    int32_t * v10 = (int32_t *)v5; // 0x10002d7e
    int32_t v11 = *v10; // 0x10002d7e
    int32_t v12; // 0x10002d72
    char v13 = *(char *)&v12; // 0x10002d7f
    int32_t v14; // 0x10002d72
    *(char *)v12 = v13 ^ (char)((int32_t)&v14 / 256);
    char * v15 = (char *)v11; // 0x10002d82
    uint32_t v16; // 0x10002d72
    *v15 = *v15 + (char)(v16 / 256);
    uint32_t v17 = v12;
    CloseHandle(&g22);
    __asm_int1();
    *v10 = v11;
    int32_t * v18 = (int32_t *)(2 * v9 + 44 + v11); // 0x10002d99
    *v18 = *v18 | v16;
    int32_t v19 = *(int32_t *)-0x3d08f000; // 0x10002d9d
    int32_t v20 = v19 ^ v17 + (int32_t)(&v14 > (int32_t *)-0xa120e2) + v17 / 256;
    char v21 = v20; // 0x10002da2
    v12 = 256 * v20 & 0xff00 | v17 & -0xff01;
    if (v21 >= 0 != v21 != 0) {
        // 0x10002da6
        *(int16_t *)(v3 + 0x36471c1f) = a1;
        unsigned char v22 = (char)v19; // 0x10002da7
        int32_t v23; // 0x10002d72
        if ((v22 & 14) > 9) {
            v23 = (v22 > 153 ? 154 : 250) + v19 & 255 | v19 & -256;
        } else {
            v23 = (v22 > 153 ? v19 + 160 : v19) & 255 | v19 & -256;
        }
        int32_t v24 = v23 ^ 128; // 0x10002daa
        char * v25 = (char *)v24; // 0x10002dac
        *v25 = *v25 + (char)v24;
        char * v26 = (char *)(v24 - 1); // 0x10002dae
        unsigned char v27 = *v26; // 0x10002dae
        unsigned char v28 = v27 + (char)v12; // 0x10002dae
        *v26 = v28;
        return v24 + 188 + (int32_t)(v28 < v27) & 255 | v23 & -256;
    }
    // 0x10002db6
    int32_t v29; // 0x10002d72
    int32_t v30 = v7 + v29; // 0x10002d7c
    int32_t v31 = v19 & -256; // 0x10002db6
    int32_t v32 = v16 - 1; // 0x10002dbb
    if (v32 != 0) {
        unsigned char v33 = *(char *)-0x435d6852; // 0x10002db6
        *(int32_t *)(v3 + 0x36471c1d) = v31 | (int32_t)v33;
        *(int32_t *)(v3 + 0x36471c19) = v32;
        *(int32_t *)(v3 + 0x36471c15) = v12;
        *(int32_t *)(v3 + 0x36471c11) = v11;
        *(int32_t *)(v3 + 0x36471c0d) = v5;
        *(int32_t *)(v3 + 0x36471c05) = v9;
        *(int32_t *)(v3 + 0x36471c01) = v30;
        return __asm_sti();
    }
    int32_t v34 = v19 >> 31; // 0x10002dbd
    v12 = v34;
    int32_t v35 = *(int32_t *)(v30 + 66); // 0x10002dbe
    char v36 = *(char *)(v9 - 0x47f4fa7d); // 0x10002dc1
    char v37 = -v36; // 0x10002dc1
    char v38 = llvm_ctpop_i8(v37); // 0x10002dc1
    *(int32_t *)(v30 + 85) = v11;
    bool v39; // 0x10002d72
    bool v40; // 0x10002d72
    bool v41; // 0x10002d72
    *(int32_t *)((v35 ^ v5) - 4) = 0x4000 * (int32_t)v39 | 1024 * (int32_t)v6 | 512 * (int32_t)v40 | 256 * (int32_t)v41 | (int32_t)(v36 != 0) | 64 * (int32_t)(v36 == 0) | 128 * (int32_t)(v37 < 0) | 16 * (int32_t)(-((v36 & 15)) > 15) | 2048 * (int32_t)((v36 & v37) < 0) | 4 * (int32_t)((v38 & 1) == 0) | 2;
    unsigned char v42 = *(char *)-0xf74f000; // 0x10002dcb
    int32_t result = v31 | (int32_t)v42; // 0x10002dcb
    if (v9 > v34) {
        // 0x10002dd4
        return result;
    }
    char * v43 = (char *)result; // 0x10002ddb
    *v43 = *v43 + (char)v12;
    *(char *)-0x857ec40 = v42;
    unsigned char v44 = *v43; // 0x10002dee
    char v45 = v44 / 128; // 0x10002dee
    *v43 = v45 | 2 * v44;
    char * v46 = (char *)(v12 + 106); // 0x10002df0
    *v46 = (char)v12 + (char)(v45 != 0) + *v46;
    return result - 0x56d4faf6;
}

// Address range: 0x10002e10 - 0x10002e2f
int32_t function_10002e10(int32_t a1) {
    // 0x10002e10
    int32_t v1; // 0x10002e10
    char * v2 = (char *)(v1 & -95); // 0x10002e1c
    int32_t v3; // 0x10002e10
    char v4 = v3; // 0x10002e1c
    *v2 = *v2 + v4;
    *(char *)-0x5fa34ad1 = *(char *)-0x5fa34ad1 + v4;
    return -0x5fa34ad1;
}

// Address range: 0x10002e50 - 0x10002e55
int32_t function_10002e50(void) {
    // 0x10002e50
    int32_t v1; // 0x10002e50
    uint32_t v2; // 0x10002e50
    bool v3; // 0x10002e50
    *(char *)v1 = (char)(v2 / 256) + (char)v1 + (char)v3;
    int32_t result; // 0x10002e50
    return result;
}

// Address range: 0x10002e8a - 0x10002ebd
int32_t function_10002e8a(void) {
    uint32_t v1 = __asm_int1(); // 0x10002e92
    int32_t v2; // 0x10002e8a
    int32_t v3; // 0x10002e8a
    bool v4; // 0x10002e8a
    *(char *)(v2 - 0x100010b + (v4 ? -1 : 1)) = __asm_insb((int16_t)v3);
    int32_t v5; // 0x10002e8a
    unsigned char v6 = *(char *)&v5; // 0x10002e9a
    unsigned char v7 = v6 + (char)v3; // 0x10002e9a
    *(char *)v1 = v7;
    char * v8 = (char *)((v1 - (v7 < v6 ? 200 : 199) & 255 | v1 & -256) + 110); // 0x10002ea0
    *v8 = *v8 ^ (char)(v1 / 256);
    return function_59ec125e();
}

// Address range: 0x10002ebd - 0x10002edc
int32_t function_10002ebd(int32_t a1) {
    // 0x10002ebd
    int32_t v1; // 0x10002ebd
    int32_t v2; // 0x10002ebd
    *(int32_t *)v1 = __asm_insd((int16_t)v2);
    __asm_int(152);
    int32_t v3; // 0x10002ebd
    int32_t v4; // 0x10002ebd
    int32_t v5; // 0x10002ebd
    char * v6 = (char *)((v5 ^ -0x7a280078) - 116 + (256 * v4 & 0xff00 ^ v3)); // 0x10002ece
    *v6 = *v6 << 7;
    __asm_int1();
    __asm_hlt();
    return unknown_9ac3cd4();
}

// Address range: 0x10002ee6 - 0x10002efc
int32_t function_10002ee6(int32_t a1) {
    // 0x10002ee6
    int32_t v1; // 0x10002ee6
    char * v2 = (char *)(v1 - 0x2000b7b); // 0x10002eed
    int32_t v3; // 0x10002ee6
    int32_t v4; // 0x10002ee6
    bool v5; // 0x10002ee6
    *v2 = *v2 + (char)v4 + (char)((char)v3 > 153 | v5);
    return function_d4ac3cfd();
}

// Address range: 0x10002efc - 0x10002f1c
int32_t function_10002efc(void) {
    // 0x10002efc
    bool v1; // 0x10002efc
    bool v2; // 0x10002efc
    bool v3; // 0x10002efc
    bool v4; // 0x10002efc
    bool v5; // 0x10002efc
    bool v6; // 0x10002efc
    bool v7; // 0x10002efc
    bool v8; // 0x10002efc
    bool v9; // 0x10002efc
    bool v10; // 0x10002efc
    int32_t v11 = 0x4000 * (int32_t)v5 | 2048 * (int32_t)v6 | 1024 * (int32_t)v7 | 512 * (int32_t)v8 | 256 * (int32_t)v9 | 128 * (int32_t)v10 | 64 * (int32_t)v1 | 16 * (int32_t)v2 | (int32_t)v4 | 4 * (int32_t)v3 | 2; // bp-4, 0x10002efc
    int32_t v12; // 0x10002efc
    int32_t * v13 = (int32_t *)(v12 - 63); // 0x10002f00
    *v13 = *v13 ^ (int32_t)&v11;
    int32_t v14; // 0x10002efc
    char * v15 = (char *)(v14 - 0xa04097c); // 0x10002f0f
    int32_t v16; // 0x10002efc
    *v15 = *v15 - (char)v16 + (char)((v11 ^ -64) < 0x745e5fc0);
    return function_b1fc5741();
}

// Address range: 0x10002f22 - 0x10002f9d
float80_t function_10002f22(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10002f22
    int32_t v1; // 0x10002f22
    uint32_t v2 = v1 - 1; // 0x10002f22
    int32_t v3; // 0x10002f22
    int32_t v4; // 0x10002f22
    if (v2 < 0) {
        // 0x10002f25
        uint32_t v5; // 0x10002f22
        *(int32_t *)v5 = 2 * v5;
        int32_t v6 = __asm_int3(); // 0x10002f34
        char * v7 = (char *)(256 * (v6 + (int32_t)(v5 < 0x1374007f)) + v6 & 0xff00 | v6 & -0xff01); // 0x10002f37
        unsigned char v8 = *v7; // 0x10002f37
        char v9 = v8 / 128; // 0x10002f37
        *v7 = v9 | 2 * v8;
        char * v10 = (char *)(v1 - 0x5f9f2668); // 0x10002f39
        *v10 = *v10 + (char)(v2 / 256) + (char)(v9 != 0);
        *v7 = *v7 + (char)v2;
        float80_t result; // 0x10002f22
        if (v3 == 1) {
            // 0x10002f47
            return result;
        }
        char * v11 = (char *)(v4 & -256 | 23); // 0x10002f4a
        *v11 = *v11 ^ (char)v6;
        return result;
    }
    char * v12 = (char *)((v3 & -0xff01) - 127); // 0x10002f63
    unsigned char v13 = *v12; // 0x10002f63
    unsigned char v14 = v13 + (char)(v2 / 256); // 0x10002f63
    bool v15; // 0x10002f22
    unsigned char v16 = v14 + (char)v15; // 0x10002f63
    bool v17 = v15 ? v16 <= v13 : v14 < v13; // 0x10002f63
    *v12 = v16;
    char * v18 = (char *)(v1 - 7); // 0x10002f71
    unsigned char v19 = *v18; // 0x10002f71
    unsigned char v20 = v19 + (char)v2; // 0x10002f71
    unsigned char v21 = v20 + (char)v17; // 0x10002f71
    bool v22 = v17 ? v21 <= v19 : v20 < v19; // 0x10002f71
    *v18 = v21;
    int64_t v23; // 0x10002f22
    __asm_paddsw(v23, *(int64_t *)v2);
    int32_t v24; // 0x10002f22
    int32_t v25; // 0x10002f22
    *(char *)v25 = *(char *)&v24;
    __asm_hlt();
    char v26 = *(char *)(a3 - 0x1daa8abc); // 0x10002f8f
    int64_t result2 = *(int64_t *)((v4 & -0x10000 | (int32_t)(v26 + (char)v4 + (char)v22) | 0xbc00) + 0x3f73dd53); // 0x10002f95
    return result2;
}

// Address range: 0x10002ffa - 0x10002ffd
int32_t function_10002ffa(void) {
    // 0x10002ffa
    int32_t v1; // 0x10002ffa
    uint16_t v2 = (int16_t)v1; // 0x10002ffa
    int32_t v3; // 0x10002ffa
    uint16_t v4 = (int16_t)v3 & 255; // 0x10002ffa
    return v1 & -0x10000 | (int32_t)(v2 / v4 & 255) | (int32_t)(256 * (v2 % v4));
}

// Address range: 0x1000301a - 0x10003021
int32_t function_1000301a(void) {
    // 0x1000301a
    return function_8e140c55();
}

// Address range: 0x10003050 - 0x100030c0
int32_t function_10003050(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x10003050
    int32_t result; // 0x10003050
    return result;
}

// Address range: 0x100030c1 - 0x100030f5
int32_t function_100030c1(void) {
    // 0x100030c1
    int32_t v1; // 0x100030c1
    *(int32_t *)v1 = 0x400000 * v1;
    int32_t v2; // 0x100030c1
    int16_t v3 = 125 * (int16_t)*(int32_t *)(v2 - 0x48708332); // 0x100030cd
    int32_t v4; // 0x100030c1
    __asm_outsb(v3, *(char *)&v4);
    int32_t v5; // 0x100030c1
    int32_t v6; // 0x100030c1
    __asm_arpl(*(int16_t *)(v6 - 0x6acfecb0), (int16_t)v5);
    int32_t v7; // 0x100030c1
    *(int32_t *)v7 = v4;
    int32_t v8 = __asm_in_3(v3); // 0x100030e7
    int32_t v9; // 0x100030c1
    bool v10; // 0x100030c1
    return v8 & -0x10000 | (int32_t)*(int16_t *)(v9 + 110 + (v10 ? -4 : 4) + v4);
}

// Address range: 0x100030f5 - 0x100030fb
int32_t function_100030f5(int32_t a1) {
    // 0x100030f5
    int32_t v1; // 0x100030f5
    int32_t result; // 0x100030f5
    *(int32_t *)result = result - v1;
    return result;
}

// Address range: 0x10003105 - 0x10003111
int32_t function_10003105(void) {
    // 0x10003105
    return function_2bc0b70f();
}

// Address range: 0x1000314b - 0x10003155
int32_t function_1000314b(void) {
    // 0x1000314b
    int32_t v1; // 0x1000314b
    int32_t v2; // 0x1000314b
    *(char *)v1 = __asm_insb((int16_t)v2);
    int32_t v3; // 0x1000314b
    return v3 & 0xffff;
}

// Address range: 0x10003155 - 0x100031aa
int32_t function_10003155(void) {
    // 0x10003155
    int32_t v1; // 0x10003155
    bool v2; // 0x10003155
    int32_t v3 = v1 + 0x5aac51c2 + (int32_t)v2; // 0x10003155
    int32_t v4; // 0x10003155
    uint32_t v5 = v4 - 1; // 0x1000315a
    uint32_t v6 = v5 / 256; // 0x1000315b
    uint32_t v7; // 0x10003155
    *(char *)v7 = (char)(v6 ^ v7);
    int32_t v8; // 0x10003155
    *(char *)v8 = *(char *)&v8 + (char)v3;
    int32_t v9 = v3 + v5; // 0x10003164
    char * v10 = (char *)(v9 & 255 | v3 & -256); // 0x10003166
    char v11 = v5; // 0x10003166
    *v10 = *v10 + v11;
    unsigned char v12 = (char)v9; // 0x10003168
    uint32_t v13 = (v3 & -0x10000 | (int32_t)(v12 % 78) | 256 * (int32_t)(v12 / 78)) + (int32_t)"_VMProtectionMutex"; // 0x1000316b
    int32_t v14; // 0x10003155
    *(int32_t *)v14 = (int32_t)"_VMMainMutex";
    char v15 = *(char *)-0x765e2cfc; // 0x10003177
    int32_t v16 = v13 & -0x10000; // 0x10003177
    int32_t v17 = 96 * (int32_t)(v15 | (char)(v13 / 256)) + v13; // 0x1000317d
    char * v18 = (char *)(v17 & 255 | v16); // 0x1000317f
    unsigned char v19 = *v18; // 0x1000317f
    *v18 = v19 / 128 | 2 * v19;
    char * v20 = (char *)(v8 - 0x5f2f7f58); // 0x10003183
    *v20 = *v20 | (char)v6;
    char * v21 = (char *)(v17 - ((char)(v7 / 256) < 21 ? 162 : 161) & 255 | v16); // 0x1000318f
    *v21 = *v21 + v11;
    return -0x456bf776;
}

// Address range: 0x100031aa - 0x100031b1
int32_t function_100031aa(void) {
    // 0x100031aa
    int32_t v1; // 0x100031aa
    int32_t v2; // 0x100031aa
    int32_t v3; // 0x100031aa
    int32_t v4; // 0x100031aa
    int32_t v5; // 0x100031aa
    int32_t v6; // 0x100031aa
    int32_t v7; // 0x100031aa
    int32_t v8; // 0x100031aa
    return function_100031bc(v2, v3, v4, &v1, v5, v6, v7, v8);
}

// Address range: 0x100031ba - 0x100031bc
int32_t function_100031ba(void) {
    // 0x100031ba
    int32_t v1; // 0x100031ba
    int32_t result; // 0x100031ba
    *(char *)result = (char)result + (char)v1;
    return result;
}

// Address range: 0x100031bc - 0x100031da
int32_t function_100031bc(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x100031bc
    int32_t v1; // 0x100031bc
    int32_t v2 = v1 & -256 | (int32_t)__asm_in_5(83); // 0x100031bd
    char * v3 = (char *)v2; // 0x100031c5
    int32_t v4; // 0x100031bc
    char v5 = v4; // 0x100031c5
    *v3 = *v3 + v5;
    *(int32_t *)-0x481ba973 = v2 & -0x826c;
    lstrcpyA((char *)&g22, (char *)&g22);
    int32_t result = __asm_in_2(98); // 0x100031d6
    char * v6 = (char *)result; // 0x100031d8
    *v6 = *v6 + v5;
    return result;
}

// Address range: 0x1000322b - 0x1000323c
int32_t function_1000322b(void) {
    // 0x1000322b
    __asm_sti();
    return function_a700e3d4();
}

// Address range: 0x10003248 - 0x100032b9
int32_t function_10003248(int32_t a1) {
    // 0x10003248
    int32_t v1; // 0x10003248
    unsigned char v2 = (char)v1;
    char v3 = v2 / 128; // 0x10003248
    *(char *)v1 = v3 | 2 * v2;
    char * v4 = (char *)(v1 - 104); // 0x1000324a
    unsigned char v5 = *v4; // 0x1000324a
    uint32_t v6; // 0x10003248
    unsigned char v7 = v5 + (char)(v6 / 256); // 0x1000324a
    unsigned char v8 = v7 + (char)(v3 != 0); // 0x1000324a
    bool v9 = v3 != 0 ? v8 <= v5 : v7 < v5; // 0x1000324a
    *v4 = v8;
    int32_t v10; // 0x10003248
    int32_t v11 = v10 & -0xff01; // 0x1000324d
    char * v12 = (char *)(v1 - 2); // 0x1000324f
    unsigned char v13 = *v12; // 0x1000324f
    int32_t v14; // 0x10003248
    char v15 = v14; // 0x1000324f
    char v16 = v9; // 0x1000324f
    unsigned char v17 = v13 + v15; // 0x1000324f
    unsigned char v18 = v17 + v16; // 0x1000324f
    *v12 = v18;
    unsigned char v19 = v2 < 134 ? v2 : v2 + 122; // 0x10003252
    int32_t v20; // 0x10003248
    __asm_into(v20);
    if (v19 >= 0) {
        bool v21 = v9 ? v18 <= v13 : v17 < v13; // 0x1000324f
        return v11 | 256 * (4 * (int32_t)((llvm_ctpop_i8(v19) & 1) == 0) | 64 * (int32_t)(v19 == 0) | (int32_t)v21 | 16 * (int32_t)((v13 & 15) + (v15 & 15) + v16 > 15)) | 512;
    }
    // 0x10003296
    __asm_into(v20);
    int32_t v22 = *(int32_t *)((v1 & -0x10000 | (int32_t)v19 | 256 * (int32_t)(v2 > 133)) - 55); // 0x10003299
    int32_t v23 = __asm_hlt(); // 0x1000329e
    int32_t v24 = v22 & v11;
    char v25 = *(char *)(v24 + 11) & (char)v24; // 0x1000329f
    int32_t v26 = v24 & -256 | (int32_t)v25; // 0x100032a2
    while (v25 >= 0) {
        // 0x1000329f
        v24 = v26;
        v25 = *(char *)(v24 + 11) & (char)v24;
        v26 = v24 & -256 | (int32_t)v25;
    }
    unsigned char v27 = (char)v23; // 0x100032a7
    int32_t v28 = v27 < 160 ? v23 : v23 + 96; // 0x100032a7
    char * v29 = (char *)(v28 & 255 | v23 & -0x10000 | 256 * (int32_t)(v27 > 159)); // 0x100032a9
    *v29 = *v29 + v15;
    return function_d4eafac3(v6);
}

// Address range: 0x100032b9 - 0x100032c8
int32_t function_100032b9(void) {
    // 0x100032b9
    int32_t v1; // 0x100032b9
    return function_10003343(v1);
}

// Address range: 0x10003303 - 0x1000331d
int32_t function_10003303(void) {
    // 0x10003303
    int32_t v1; // 0x10003303
    char * v2 = (char *)(v1 - 0x5fa302f5); // 0x10003303
    uint32_t v3; // 0x10003303
    bool v4; // 0x10003303
    *v2 = (char)v4 + (char)(v3 / 256) + *v2;
    int32_t v5; // 0x10003303
    int32_t v6; // 0x10003303
    *(char *)v5 = *(char *)&v5 + (char)v6;
    return v1 - 556 | 0x7b5f4fb2;
}

// Address range: 0x10003343 - 0x1000336d
int32_t function_10003343(int32_t a1) {
    // 0x10003343
    int32_t v1; // 0x10003343
    unsigned char v2 = (char)v1;
    char v3 = v2 / 128; // 0x10003343
    *(char *)v1 = v3 | 2 * v2;
    char * v4 = (char *)(v1 + (int32_t)&g15); // 0x10003345
    *v4 = (char)(v3 != 0) + v2 + *v4;
    int32_t v5 = 5; // bp+40, 0x10003352
    char v6 = *(char *)-0x2b00fad5; // 0x10003354
    int32_t v7; // 0x10003343
    int32_t v8 = *(int32_t *)(v7 - 52); // 0x1000335c
    int32_t v9 = (v8 & 15) - ((int32_t)&v5 & 12) > 15 ? 6 : 0; // 0x1000335f
    int32_t v10 = 256 * (int32_t)((v8 & 15) - ((int32_t)&v5 & 12) > 15) + v1 & 0xff00 | v1 & -0x10000;
    uint32_t v11; // 0x10003343
    uint32_t v12 = v11 / 256; // 0x10003360
    uint32_t v13; // 0x10003343
    int32_t v14 = v12 ^ v13;
    __asm_out_6((int16_t)(256 * (int32_t)(v6 | (char)(v13 / 256)) | v14 & 255), v10 | v9);
    int32_t result = v10 | (int32_t)__asm_in_5(-95); // 0x10003365
    char * v15 = (char *)result; // 0x10003367
    unsigned char v16 = *v15; // 0x10003367
    unsigned char v17 = v16 + (char)v14; // 0x10003367
    *v15 = v17;
    char * v18 = (char *)(result - 26); // 0x10003369
    *v18 = *v18 + (char)v12 + (char)(v17 < v16);
    return result;
}

// Address range: 0x1000336f - 0x100033a8
int32_t function_1000336f(int32_t a1) {
    // 0x1000336f
    int32_t v1; // 0x1000336f
    int32_t v2; // 0x1000336f
    if (v2 == 1) {
        // 0x10003376
        int32_t v3; // 0x1000336f
        *(int32_t *)(v3 + 92) = a1;
        v1 = 9;
    }
    // 0x10003392
    *(int32_t *)(a1 + 82) = v1;
    return function_dcef8262();
}

// Address range: 0x100033a8 - 0x100033cd
int32_t function_100033a8(void) {
    // 0x100033a8
    int32_t v1; // 0x100033a8
    unsigned char v2 = (char)v1; // 0x100033a8
    uint32_t v3; // 0x100033a8
    unsigned char v4 = v2 + (char)(v3 / 256); // 0x100033a8
    int32_t v5; // 0x100033a8
    int32_t * v6 = (int32_t *)(v5 + 94); // 0x100033aa
    bool v7; // 0x100033a8
    int32_t v8 = v7 ? v4 + (char)v7 <= v2 : v4 < v2 ? 0x78c5835c : 0x78c5835b; // 0x100033aa
    *v6 = *v6 - v8;
    int32_t v9; // 0x100033a8
    int32_t * v10 = (int32_t *)(v9 - 40); // 0x100033bd
    *v10 = *v10 & (int32_t)&g14;
    int32_t v11; // 0x100033a8
    return function_d6c0a0d0(v11);
}

// Address range: 0x100033cd - 0x10003432
int32_t function_100033cd(void) {
    // 0x100033cd
    int32_t v1; // 0x100033cd
    int32_t v2 = v1 & -96; // 0x100033cd
    char * v3 = (char *)v2; // 0x100033cf
    int32_t v4; // 0x100033cd
    *v3 = *v3 + (char)v4;
    unsigned char v5 = *(char *)-0x1bd2f000; // 0x100033d6
    int32_t v6; // 0x100033cd
    uint32_t v7 = (int32_t)&v6 & -256 | (int32_t)v5; // 0x100033d6
    char * v8 = (char *)(v7 + 0x44fc1000); // 0x100033dc
    uint32_t v9; // 0x100033cd
    *v8 = *v8 + (char)(v9 / 256);
    int32_t v10; // 0x100033cd
    *(int32_t *)v10 = __asm_insd((int16_t)v4);
    uint32_t v11; // 0x100033cd
    int32_t v12 = v11 / 256 + v4 + (int32_t)(v7 > 0xff5eaf1e); // 0x100033e9
    int32_t * v13 = (int32_t *)(v9 + 83); // 0x100033eb
    *v13 = (v12 & 255 | v4 & -256) + *v13;
    *(int32_t *)(v2 - 6) = 0x201ea60;
    int32_t v14; // 0x100033cd
    *(char *)(v14 + 49) = v5 - 31;
    int32_t v15 = unknown_ca103461(); // 0x100033fa
    char * v16 = (char *)((v9 & -256 | 183) - 1); // 0x1000340b
    *v16 = *v16 + (char)v12;
    float80_t v17; // 0x100033cd
    *(int16_t *)((v15 ^ (int32_t)&g5) + 0x9b4726f) = (int16_t)v17;
    __asm_in_5(48);
    return function_1000343b();
}

// Address range: 0x10003432 - 0x1000343b
int32_t function_10003432(void) {
    // 0x10003432
    int32_t v1; // 0x10003432
    *(int32_t *)v1 = v1 | -96;
    int32_t result; // 0x10003432
    unsigned char v2 = *(char *)&result; // 0x10003437
    *(char *)result = v2 / 128 | 2 * v2;
    return result;
}

// Address range: 0x1000343b - 0x1000343f
int32_t function_1000343b(void) {
    // 0x1000343b
    int32_t v1; // 0x1000343b
    int32_t v2; // 0x1000343b
    int32_t result = v1 & 255 ^ v2; // 0x1000343b
    char * v3 = (char *)result; // 0x1000343d
    *v3 = *v3 + (char)v1;
    return result;
}

// Address range: 0x100034eb - 0x1000354b
int32_t function_100034eb(void) {
    // 0x100034eb
    unknown_1a053d18();
    __asm_int3();
    int32_t v1; // 0x100034eb
    uint32_t v2 = unknown_15103567(0x10000 * v1 / 0x10000); // 0x10003500
    int32_t v3; // 0x100034eb
    int32_t * v4 = (int32_t *)(v3 + 16); // 0x10003505
    *v4 = *v4 & v3;
    char v5 = 123 * (char)(v2 / 256) + (char)v2; // 0x10003508
    if (v5 >= 0 == (v5 != 0)) {
        char * v6 = (char *)(v2 & -0x10000 | 161); // 0x10003543
        *v6 = *v6 + (char)v1;
        return function_d4ce28ce();
    }
    int32_t v7 = unknown_f103573(); // 0x1000350c
    int32_t v8 = unknown_4310357f(); // 0x10003518
    int32_t v9; // 0x100034eb
    int32_t v10 = v9 - 1; // 0x1000351d
    *(int64_t *)v10 = (int64_t)*(float80_t *)(v3 - 56);
    unsigned char v11 = (char)v3; // 0x10003527
    bool v12 = v11 > 153 | (char)v7 > 187;
    int32_t v13; // 0x100034eb
    if ((v9 & 15) > 16 || (v11 & 14) > 9) {
        v13 = (v12 ? 154 : 250) + v3 & 255 | v3 & -256;
    } else {
        v13 = (v12 ? v3 + 160 : v3) & 255 | v3 & -256;
    }
    int32_t v14 = v8 & -0xff01 | 256 * (128 * (int32_t)(v10 < 0) | 64 * (int32_t)(v10 == 0) | 16 * (int32_t)((v9 & 15) > 16) | 4 * (int32_t)((llvm_ctpop_i8((char)v10) & 1) == 0) | (int32_t)((char)v7 > 187)) | 512; // 0x10003521
    int32_t v15 = v13 - 1; // 0x10003528
    int32_t v16; // 0x100034eb
    *(char *)v16 = (char)v15;
    *(int32_t *)v15 = v15;
    char * v17 = (char *)(v14 + 0x3e1000bf); // 0x10003535
    uint32_t v18; // 0x100034eb
    *v17 = *v17 + (char)(v18 / 256);
    return v14 + 30;
}

// Address range: 0x1000354b - 0x100035f1
int32_t function_1000354b(void) {
    // 0x1000354b
    uint32_t v1; // 0x1000354b
    int32_t v2 = v1 & -216; // 0x1000354b
    int32_t v3; // 0x1000354b
    int32_t v4; // 0x1000354b
    int32_t v5; // 0x1000354b
    uint32_t v6; // 0x1000354b
    if ((char)(v2 & v6) != 0) {
        char * v7 = (char *)(8 * v3 - 0x137c9335); // 0x100035a6
        *v7 = *v7 + (char)v5;
        int32_t v8 = v1 & -256 | (int32_t)__asm_in_5(98); // 0x100035b3
        char * v9 = (char *)v8; // 0x100035b5
        char v10 = v6; // 0x100035b5
        *v9 = *v9 + v10;
        int64_t v11; // 0x1000354b
        __asm_pand(v11, *(int64_t *)v8);
        *v9 = *v9 + v10;
        int32_t v12 = 0x10000 * v8 / 0x10000; // 0x100035bf
        char * v13 = (char *)(v4 + (int32_t)&g4); // 0x100035c9
        *v13 = (char)v12 - 16;
        int32_t v14 = (v12 & -256 | (int32_t)*v13) + v4; // 0x100035cf
        char v15 = __readfsbyte(0x413f1000); // 0x100035d7
        bool v16 = (v15 & 14) > 9 | (v14 & 0x1000) != 0; // 0x100035df
        char v17 = v16 ? v15 + 6 : v15; // 0x100035df
        bool v18 = v16 | (v17 & 14) > 9; // 0x100035e2
        char v19 = v18 ? v17 + 10 : v17; // 0x100035e2
        return v14 & -0x10000 | (int32_t)(v19 & 15) | 256 * ((int32_t)v18 + (int32_t)v16) + v14 & 0xff00;
    }
    char * v20 = (char *)(v3 - 26); // 0x1000355c
    char v21 = *v20; // 0x1000355c
    unsigned char v22 = (char)(v1 / 256); // 0x1000355c
    *v20 = v21 + v22;
    int32_t v23; // 0x1000354b
    int32_t v24 = v23 - 1; // 0x1000355f
    int32_t v25 = v2; // 0x1000355f
    bool v26 = -1 - v21 < v22; // 0x1000355f
    int32_t v27; // 0x1000354b
    if (v24 == 0) {
        // 0x10003561
        v25 = unknown_10626329(v2, v5);
        int32_t v28; // 0x1000354b
        char * v29 = (char *)(v28 + 83 + v25); // 0x1000356c
        unsigned char v30 = *v29; // 0x1000356c
        unsigned char v31 = v30 + (char)(v6 / 256); // 0x1000356c
        unsigned char v32 = v31 + (char)(-1 - v21 < v22); // 0x1000356c
        v26 = -1 - v21 < v22 ? v32 <= v30 : v31 < v30;
        *v29 = v32;
        v27 = 0x170b0550;
    }
    // 0x10003570
    __asm_bound(*(int64_t *)(v25 & -256 | (int32_t)*(char *)-0x1f75f000));
    char * v33 = (char *)(v4 + 15); // 0x1000357a
    *v33 = (char)v26 + (char)v27 + *v33;
    uint32_t v34 = __asm_in_3((int16_t)v6); // 0x1000357d
    char * v35 = (char *)(v34 - 73); // 0x10003580
    char v36 = *v35 ^ (char)v24; // 0x10003580
    *v35 = v36;
    int32_t v37 = v23 - 2; // 0x10003584
    if (v37 == 0 || v36 == 0) {
        char * v38 = (char *)v34; // 0x10003586
        *v38 = *v38 + (char)v6;
        uint32_t v39 = v34 + v3; // 0x10003588
        int32_t result = __asm_bound(*(int64_t *)v39); // 0x1000358a
        char * v40 = (char *)v27; // 0x1000358c
        *v40 = (char)(v39 < v34) + (char)(v27 / 256) + *v40;
        return result;
    }
    int32_t result2 = __asm_bound(*(int64_t *)v34); // 0x100035e8
    char * v41 = (char *)(v4 - 0x17af2bbb); // 0x100035ea
    *v41 = *v41 + (char)v37;
    return result2;
}

// Address range: 0x1000361a - 0x10003620
int32_t function_1000361a(void) {
    // 0x1000361a
    int32_t result; // 0x1000361a
    int32_t v1; // 0x1000361a
    *(char *)v1 = (char)v1 + (char)result;
    return result;
}

// Address range: 0x10003620 - 0x10003621
int32_t function_10003620(void) {
    // 0x10003620
    int32_t result; // 0x10003620
    return result;
}

// Address range: 0x10003638 - 0x10003641
int32_t function_10003638(void) {
    // 0x10003638
    int32_t v1; // bp-4, 0x10003638
    int32_t v2; // 0x10003638
    return (v2 | (int32_t)&v1) ^ 0x12cc9da6;
}

// Address range: 0x1000365f - 0x10003666
int32_t function_1000365f(void) {
    // 0x1000365f
    return function_f56e738a();
}

// Address range: 0x10003686 - 0x10003731
int32_t function_10003686(int16_t a1) {
    // 0x10003686
    int32_t v1; // 0x10003686
    int32_t v2 = &v1; // 0x10003686
    int32_t v3; // 0x10003686
    bool v4; // 0x10003686
    int32_t v5 = (v4 ? -4 : 4) + v3; // 0x10003687
    uint32_t v6; // 0x10003686
    int32_t v7 = v6 & -256 | (int32_t)*(char *)v5; // 0x10003688
    char * v8 = (char *)(v7 - 0x3a78f000); // 0x1000368e
    unsigned char v9 = *v8 & (char)(v6 / 256); // 0x1000368e
    *v8 = v9;
    int32_t result = v7; // 0x10003694
    int32_t v10 = v2; // 0x10003694
    int32_t v11; // 0x10003686
    if (v9 >= 1) {
        char * v12 = (char *)(v5 + (v4 ? 0x134c5546 : 0x134c5548)); // 0x10003696
        *v12 = *v12 - (char)v11;
        int32_t v13 = v2; // bp-2, 0x1000369e
        result = *(int32_t *)0x3a4e1000 & -0xff01 | 0xb300;
        v10 = &v13;
    }
    uint32_t v14 = v10;
    int32_t v15; // 0x10003686
    int32_t * v16 = (int32_t *)(v15 + 21); // 0x100036a7
    *v16 = *v16 - v14;
    if (v14 <= 0x1000118) {
        if (v14 < 0x1000119) {
            // 0x100036ba
            return 0x10000 * (result + 0xfee3 + v14 + (int32_t)(v14 < 0x1000118)) / 0x10000;
        }
        // 0x100036c4
        return result;
    }
    char * v17 = (char *)result; // 0x1000372e
    *v17 = *v17 + (char)v11;
    *(int32_t *)(v14 - 0x1000120) = result;
    return result;
}

// Address range: 0x10003732 - 0x1000373d
int32_t function_10003732(int16_t a1) {
    // 0x10003732
    return function_10003787();
}

// Address range: 0x1000373d - 0x1000377c
int32_t function_1000373d(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x1000373d
    int32_t v1; // 0x1000373d
    int32_t v2 = v1 + 1; // 0x1000373d
    char * v3 = (char *)(v2 & -256 | (int32_t)*(char *)v2); // 0x10003746
    int32_t v4; // 0x1000373d
    *v3 = *v3 + (char)v4;
    uint32_t v5; // 0x1000373d
    uint32_t v6; // 0x1000373d
    if (v6 != 1 == v5 == v6) {
        // 0x10003771
        return -0x15a3f000;
    }
    int32_t v7 = __asm_int3(); // 0x1000375e
    unsigned char v8 = *(char *)-0x4e88f000; // 0x10003761
    unsigned char v9 = v8 ^ -128; // 0x10003766
    unsigned char v10 = v9 + (char)(v5 < v6); // 0x10003766
    bool v11 = v5 < v6 ? v10 <= v8 : v9 < v8; // 0x10003766
    char * v12 = (char *)(a3 + 83); // 0x1000376c
    *v12 = *v12 + (char)a4 + (char)v11;
    return v7 & -256 | (int32_t)v10;
}

// Address range: 0x1000377d - 0x10003785
int32_t function_1000377d(void) {
    // 0x1000377d
    int32_t result; // 0x1000377d
    return result;
}

// Address range: 0x10003787 - 0x1000379c
int32_t function_10003787(void) {
    // 0x10003787
    return unknown_a18c3e();
}

// Address range: 0x1000379c - 0x100037b7
int32_t function_1000379c(void) {
    // 0x1000379c
    int32_t v1; // 0x1000379c
    int32_t v2 = v1 | 236; // 0x1000379c
    char * v3 = (char *)v2; // 0x1000379e
    uint32_t v4; // 0x1000379c
    *v3 = *v3 ^ (char)(v4 / 256);
    *(int32_t *)-0x3baf4be = v2;
    return function_6eea93c6();
}

// Address range: 0x100037b7 - 0x100037fc
int32_t function_100037b7(void) {
    // 0x100037b7
    int32_t v1; // 0x100037b7
    char * v2 = (char *)(v1 + 96 & 255 | v1 & -256); // 0x100037bc
    int32_t v3; // 0x100037b7
    *v2 = *v2 + (char)v3;
    uint32_t v4 = __asm_int3(); // 0x100037be
    int32_t v5; // 0x100037b7
    bool v6; // 0x100037b7
    char * v7 = (char *)((v6 ? -1 : 1) + v5); // 0x100037bf
    uint32_t v8 = *(int32_t *)v4; // 0x100037c2
    uint32_t v9 = v4 - v8; // 0x100037c2
    char v10 = *v7; // 0x100037c6
    uint32_t v11; // 0x100037b7
    char v12 = v11 / 256; // 0x100037c6
    char v13 = v4 < v8; // 0x100037c6
    char v14 = v10 + v12 + v13; // 0x100037c6
    char v15 = v14 + v13; // 0x100037c6
    *v7 = v14;
    char v16 = -72 * (char)(v9 / 256) + (char)v9; // 0x100037c8
    int32_t v17 = v9 & -0x10000 | (int32_t)v16; // 0x100037ca
    if (v16 < 0 == ((v15 ^ v10) & (v15 ^ v12)) < 0 != v16 != 0) {
        // 0x100037cc
        v17 = 0x10000 * __asm_int3() / 0x10000;
    }
    // 0x100037e1
    *(int32_t *)-0x3984e4f5 = *(int32_t *)-0x3984e4f5 - 21;
    int32_t * v18 = (int32_t *)v17; // 0x100037ed
    *v18 = *v18 + v17;
    int32_t v19; // 0x100037b7
    char * v20 = (char *)(v19 - 0xa04157c); // 0x100037ef
    *v20 = *v20 + (char)v11;
    return function_5cb9a97b();
}

// Address range: 0x1000385e - 0x10003871
int32_t function_1000385e(int32_t a1) {
    // 0x1000385e
    int32_t v1; // 0x1000385e
    float80_t v2; // 0x1000385e
    *(int16_t *)(v1 + 0xa074da) = (int16_t)v2;
    int32_t v3; // 0x1000385e
    int32_t v4; // 0x1000385e
    bool v5; // 0x1000385e
    *(char *)v3 = (char)v5 + (char)v4 + *(char *)&v3;
    uint32_t v6 = v3;
    *(char *)v6 = *(char *)&v3 + (char)(v6 / 256);
    return v1 & -10;
}

// Address range: 0x10003871 - 0x1000399c
int32_t function_10003871(void) {
    // 0x10003871
    int32_t v1; // 0x10003871
    char * v2 = (char *)(v1 - 0x24d4eaf6); // 0x10003872
    uint32_t v3; // 0x10003871
    *v2 = (char)v3;
    int32_t v4 = v3 & -256 | (int32_t)*v2; // 0x10003872
    uint32_t v5; // 0x10003871
    uint32_t v6 = *(int32_t *)v4 + v5; // 0x10003878
    bool v7; // 0x10003871
    uint32_t v8 = v6 + (int32_t)v7; // 0x10003878
    bool v9 = v7 ? v8 <= v5 : v6 < v5; // 0x10003878
    __asm_arpl(*(int16_t *)v4, (int16_t)v4);
    uint32_t v10; // 0x10003871
    char * v11 = (char *)(v10 + 0x1607ecf4); // 0x1000387c
    *v11 = *v11 + (char)(v3 / 256) + (char)v9;
    int32_t v12; // 0x10003871
    __asm_arpl(*(int16_t *)(v12 - 0x3e9d1a72), (int16_t)v12);
    char * v13 = (char *)(v10 - 0x7ff58b76); // 0x10003888
    uint32_t v14; // 0x10003871
    *v13 = *v13 & (char)(v14 / 256);
    int32_t v15 = v4 | 0x3e430474; // 0x1000388f
    int32_t result = *(int32_t *)(v15 - 60); // 0x10003894
    if (v15 < 0) {
        char v16 = v10 / 256; // 0x10003899
        if (((char)v8 & 14) > 9) {
            // branch -> 0x100038a7
        }
        // 0x100038a7
        __asm_out_6((int16_t)(256 * (int32_t)(v16 / 2) | v10 & 255), result);
        return result;
    }
    uint32_t v17 = *(int32_t *)(2 * v14 + 0x611000a0 + result) ^ v12; // 0x100038fc
    int32_t v18; // 0x10003871
    if ((*(int32_t *)(v17 + 0x2b852b3d) & result) != -v18) {
        // 0x1000390e
        return v15 & -256 | (int32_t)*(char *)v8;
    }
    char * v19 = (char *)(v14 + 50); // 0x1000390f
    unsigned char v20 = *v19; // 0x1000390f
    unsigned char v21 = v20 + (char)v10; // 0x1000390f
    *v19 = v21;
    bool v22; // 0x10003871
    char * v23 = (char *)(4 * (v8 + (v22 ? 0x3fffffff : 1))); // 0x10003918
    *v23 = *v23 + (char)(v17 / 256) + (char)(v21 < v20);
    __asm_int(112);
    __asm_iret();
    abort();
    // UNREACHABLE
}

// Address range: 0x1000399d - 0x100039a1
int32_t function_1000399d(void) {
    // 0x1000399d
    return function_100039d2();
}

// Address range: 0x100039ae - 0x100039c6
int32_t function_100039ae(void) {
    // 0x100039ae
    unknown_dff3907();
    int32_t v1; // 0x100039ae
    int32_t * v2 = (int32_t *)(v1 + 0x2cdda396); // 0x100039b5
    int32_t v3; // 0x100039ae
    *v2 = *v2 + v3;
    __asm_int3();
    return function_2e6e678a();
}

// Address range: 0x100039d2 - 0x100039e5
int32_t function_100039d2(void) {
    // 0x100039d2
    uint32_t v1; // 0x100039d2
    uint32_t v2; // 0x100039d2
    bool v3; // 0x100039d2
    *(char *)v2 = (char)v2 + (char)(v1 / 256) + (char)v3;
    int32_t v4; // 0x100039d2
    *(char *)((v4 + 0xfffc & 0xffff | v4 & -0x10000) + 23) = (char)(v2 / 256);
    return v2 & -256 | (int32_t)*(char *)-0x6568f000;
}

// Address range: 0x100039ee - 0x10003a00
int32_t function_100039ee(int32_t a1) {
    // 0x100039ee
    int32_t v1; // 0x100039ee
    *(char *)-0x12b87e5 = (char)v1;
    int32_t result; // 0x100039ee
    return result;
}

// Address range: 0x10003a3a - 0x10003ad2
int32_t function_10003a3a(void) {
    // 0x10003a3a
    int32_t v1; // 0x10003a3a
    char * v2 = (char *)(v1 + 0xa014d9); // 0x10003a3a
    unsigned char v3 = *v2; // 0x10003a3a
    int32_t v4; // 0x10003a3a
    unsigned char v5 = v3 + (char)v4; // 0x10003a3a
    bool v6; // 0x10003a3a
    unsigned char v7 = v5 + (char)v6; // 0x10003a3a
    bool v8 = v6 ? v7 <= v3 : v5 < v3; // 0x10003a3a
    *v2 = v7;
    int32_t v9; // 0x10003a3a
    int32_t v10; // 0x10003a3a
    *(char *)v10 = *(char *)&v10 + (char)v9 + (char)v8;
    int32_t v11; // 0x10003a3a
    *(char *)v11 = *(char *)&v11 - 1;
    int32_t v12 = v10;
    v10 = v12 + 256 & 0xff00 | v12 & -0xff01;
    char v13 = *(char *)&v9; // 0x10003a46
    int32_t v14 = v9 / 256; // 0x10003a46
    *(char *)v9 = v13 - (char)v14;
    int32_t v15 = __asm_in_2(19); // 0x10003a48
    int32_t v16; // 0x10003a3a
    if (v14 >= (int32_t)v13) {
        // 0x10003a4c
        __asm_hlt();
        int32_t v17 = v9;
        return unknown_a0203e(v16, 4, v17, v17);
    }
    // 0x10003ac1
    *(char *)v16 = __asm_insb((int16_t)v10);
    __asm_int(172);
    *(int32_t *)(v15 - 52) = v11;
    *(int32_t *)(v15 - 19) = v11;
    int32_t result; // 0x10003a3a
    return result;
}

// Address range: 0x10003ad3 - 0x10003afd
int32_t function_10003ad3(void) {
    // 0x10003ad3
    __asm_int3();
    __asm_in_2(115);
    return function_2823af96();
}

// Address range: 0x10003b0b - 0x10003b0c
int32_t function_10003b0b(void) {
    // 0x10003b0b
    int32_t result; // 0x10003b0b
    return result;
}

// Address range: 0x10003b34 - 0x10003b37
int32_t function_10003b34(void) {
    // 0x10003b34
    return function_10003b0b();
}

// Address range: 0x10003b54 - 0x10003b5d
int32_t function_10003b54(int32_t a1) {
    // 0x10003b54
    int32_t v1; // 0x10003b54
    char * v2 = (char *)(v1 + 0x2d526dd3); // 0x10003b54
    int32_t v3; // 0x10003b54
    bool v4; // 0x10003b54
    *v2 = *v2 + (char)v3 + (char)v4;
    int32_t v5; // 0x10003b54
    return v3 & -256 | (int32_t)__asm_in((int16_t)v5);
}

// Address range: 0x10003b68 - 0x10003b69
int32_t function_10003b68(void) {
    // 0x10003b68
    int32_t result; // 0x10003b68
    return result;
}

// Address range: 0x10003b6d - 0x10003b6e
int32_t function_10003b6d(void) {
    // 0x10003b6d
    int32_t result; // 0x10003b6d
    return result;
}

// Address range: 0x10003b76 - 0x10003b7f
int32_t function_10003b76(int32_t a1) {
    // 0x10003b76
    int32_t v1; // 0x10003b76
    uint32_t v2; // 0x10003b76
    *(char *)v1 = (char)(v2 / 256 ^ v1);
    return *(int32_t *)-0x4b2eaced & -256 | (int32_t)__asm_in((int16_t)v2);
}

// Address range: 0x10003b7f - 0x10003b86
int32_t function_10003b7f(void) {
    // 0x10003b7f
    return function_82c00b4a();
}

// Address range: 0x10003b86 - 0x10003c20
int32_t function_10003b86(int32_t a1) {
    // 0x10003b86
    int32_t v1; // 0x10003b86
    uint32_t v2 = -v1; // 0x10003b90
    unsigned char v3 = (char)(v2 / 256); // 0x10003b92
    char v4 = v1 != 0; // 0x10003b92
    int32_t v5; // 0x10003b86
    unsigned char v6 = (char)v5 + v4; // 0x10003b92
    unsigned char v7 = v3 - v6; // 0x10003b92
    bool v8 = v1 != 0 ? v6 != -1 | v7 - v4 > v3 : v6 > v3; // 0x10003b92
    int32_t v9 = __asm_hlt(); // 0x10003b94
    int32_t v10 = v8 ? 254 : 0; // 0x10003b95
    int32_t v11 = __asm_int3(); // 0x10003b9e
    int32_t result = v11; // 0x10003b9e
    if ((v9 & -0x10000 || v10 || 256 * (v5 + (int32_t)v8) + v9 & 0xff00) < 0x61b999ba) {
        int32_t v12 = v11 & -0xff01 | 0xa400; // 0x10003bf5
        result = v12;
        char * v13 = (char *)v12; // 0x10003bf7
        char v14 = v2; // 0x10003bf7
        *v13 = *v13 + v14;
        int32_t v15; // 0x10003b86
        char * v16 = (char *)(v15 + 0xa11c + (*(int32_t *)(v5 + 0x2399cc0e) ^ 0xa4ba) & 0xffff); // 0x10003bff
        uint32_t v17; // 0x10003b86
        *v16 = *v16 ^ (char)v17;
        unsigned char v18 = *v13; // 0x10003c04
        unsigned char v19 = v18 + v14; // 0x10003c04
        *v13 = v19;
        int32_t v20; // 0x10003b86
        *(int32_t *)v20 = __asm_insd((int16_t)(256 * (int32_t)v7 | v2 & 255));
        char v21 = v17 / 256; // 0x10003c07
        char v22 = v19 < v18; // 0x10003c07
        char v23 = v21 + v14 + v22; // 0x10003c07
        char v24 = v23 + v22; // 0x10003c07
        if (v23 < 0 == ((v24 ^ v21) & (v24 ^ v14)) < 0 == (v23 != 0)) {
            // 0x10003c21
            return result;
        }
        // 0x10003c0c
        int32_t result2; // 0x10003b86
        return result2;
    }
    int32_t v25 = __asm_bound(*(int64_t *)&result); // 0x10003ba6
    *(int32_t *)(v5 + 86) = __asm_sti();
    int32_t v26 = __asm_hlt(); // 0x10003bc5
    result = v26;
    *(char *)0x94023d0 = *(char *)0x94023d0 | -95;
    char * v27 = (char *)v26; // 0x10003bce
    unsigned char v28 = *v27; // 0x10003bce
    char v29 = (char)v25 + 1; // 0x10003bce
    char v30 = v28 + v29; // 0x10003bce
    *v27 = v30;
    int32_t v31 = a1; // 0x10003bd4
    unsigned char v32 = v28; // 0x10003bd4
    unsigned char v33 = v30; // 0x10003bd4
    bool v34 = v30 < v28; // 0x10003bd4
    if (v30 < 1) {
        int32_t v35 = -0x4c40750;
        *(char *)a1 = (char)result;
        bool v36; // 0x10003b86
        v31 = a1 + (v36 ? -1 : 1);
        *(int32_t *)-0x5e9f3ae9 = result;
        char * v37 = (char *)result; // 0x10003bea
        *v37 = *v37 + v29;
        *(char *)v35 = 92;
        char * v38 = (char *)(v35 - 0x77ea80ea); // 0x10003bc6
        *v38 = *v38 | -95;
        char * v39 = (char *)result; // 0x10003bce
        v32 = *v39;
        v33 = v32 + v29;
        *v39 = v33;
        int32_t v40 = v31; // 0x10003bd4
        while (v33 < 1) {
            // 0x10003be4
            v35 = -0x4c40750;
            *(char *)v40 = (char)result;
            v31 = v40 + (v36 ? -1 : 1);
            *(int32_t *)-0x5e9f3ae9 = result;
            v37 = (char *)result;
            *v37 = *v37 + v29;
            *(char *)v35 = 92;
            v38 = (char *)(v35 - 0x77ea80ea);
            *v38 = *v38 | -95;
            v39 = (char *)result;
            v32 = *v39;
            v33 = v32 + v29;
            *v39 = v33;
            v40 = v31;
        }
        // 0x10003bc6
        v34 = v33 < v32;
    }
    char v41 = v33;
    int32_t v42; // 0x10003b86
    if (((v41 ^ v32) & (v41 ^ v29)) >= 0) {
        // 0x10003bd6
        v42 = result;
    } else {
        int32_t v43 = function_10003b68(); // 0x10003bd6
        result = v43;
        v42 = v43;
    }
    // 0x10003bd8
    *(char *)v31 = (char)v42;
    if (v34) {
        // 0x10003bdd
        return *(int32_t *)0x5f4a1000;
    }
    function_10003b6d();
    // 0x10003bdd
    return *(int32_t *)0x5f4a1000;
}

// Address range: 0x10003c22 - 0x10003c2d
int32_t function_10003c22(void) {
    // 0x10003c22
    int32_t v1; // 0x10003c22
    int32_t result = v1 + 0x5fa31efb; // 0x10003c23
    char * v2 = (char *)result; // 0x10003c28
    int32_t v3; // 0x10003c22
    *v2 = *v2 + (char)v3;
    return result;
}

// Address range: 0x10003c33 - 0x10003c38
int32_t function_10003c33(void) {
    // 0x10003c33
    return function_662b4dd6();
}

// Address range: 0x10003c46 - 0x10003c47
int32_t function_10003c46(void) {
    // 0x10003c46
    int32_t result; // 0x10003c46
    return result;
}

// Address range: 0x10003c4f - 0x10003c60
int32_t function_10003c4f(void) {
    // 0x10003c4f
    return __asm_int3();
}

// Address range: 0x10003c60 - 0x10003d6f
int32_t function_10003c60(int16_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x10003c60
    unknown_c4957b04();
    char v1 = __asm_in_5(-17); // 0x10003c7a
    int32_t v2 = a2; // 0x10003ca2
    int32_t v3 = -0x179f58c6; // 0x10003ca2
    int32_t v4 = a4; // 0x10003ca2
    if ((v1 + (char)&g16 & -46 ^ 89) <= 226) {
        char * v5 = (char *)(a4 + 53); // 0x10003ca7
        unsigned char v6 = *v5; // 0x10003ca7
        *v5 = v6 + 27;
        int32_t v7; // 0x10003c60
        int32_t v8 = v7 + 108; // 0x10003cb4
        if (v6 <= 229) {
            v8 = function_10003c46();
        }
        int32_t v9 = v8;
        int16_t v10 = a1; // bp-4, 0x10003cdb
        int32_t v11; // 0x10003c60
        if ((v6 & 15) > 19 || (v9 & 14) > 9) {
            v11 = v9 + 102 & 255 | v9 & -256;
        } else {
            v11 = v9 + 96 & 255 | v9 & -256;
        }
        int32_t v12 = __asm_bound(*(int64_t *)(v11 + 0x63080316)); // 0x10003cdf
        char * v13 = (char *)v11; // 0x10003ce5
        char v14 = v12; // 0x10003ce5
        *v13 = *v13 + v14;
        int32_t v15 = __asm_in_2(40); // 0x10003ce8
        int32_t v16; // 0x10003c60
        if ((v16 & 0xfe00) != 0) {
            char * v17 = (char *)(v15 | 160); // 0x10003d55
            *v17 = *v17 + v14;
            uint16_t v18 = a1 & 31;
            if (v18 != 0) {
                int32_t * v19 = (int32_t *)(a5 + 54 + 2 * v12); // 0x10003d57
                *v19 = *v19 >> (int32_t)v18;
            }
            return v15 & -256 | (int32_t)*(char *)a5;
        }
        // 0x10003cee
        v10 = 0x6004;
        __asm_out_8(18, (char)((int32_t)a1 + 108 | (int32_t)&v10));
        *(int32_t *)(a4 - 1) = *(int32_t *)a5;
        int32_t v20 = __asm_wait(); // 0x10003d01
        *(char *)(a4 - 5) = *(char *)v20;
        char * v21 = (char *)(a5 - 4); // 0x10003d06
        *v21 = v14 + 99 + *v21;
        int32_t result = function_10005030(); // 0x10003d0b
        if ((char)result >= 119) {
            if (v10 == 0) {
                // 0x10003d65
                return result - 1 & -256 | (int32_t)__asm_in_5(-5);
            }
            // 0x10003d3d
            return result;
        }
        int32_t v22 = v10; // 0x10003cfd
        int32_t v23 = a4 - 6; // 0x10003d05
        char * v24 = (char *)(v20 + 87); // 0x10003d17
        unsigned char v25 = *v24; // 0x10003d17
        unsigned char v26 = (char)v10 & 31; // 0x10003d17
        v2 = v22;
        v3 = v12;
        v4 = v23;
        if (v26 != 0) {
            *v24 = v25 >> 8 - v26 | v25 << v26;
            v2 = v22;
            v3 = v12;
            v4 = v23;
        }
    }
    // 0x10003d1c
    unknown_a56659ce();
    char * v27 = (char *)(v3 - 0x5f2ecbe3); // 0x10003d23
    *v27 = *v27 - (char)v2;
    g6 |= v4;
    return function_1a054105();
}

// Address range: 0x10003d74 - 0x10003d77
int32_t function_10003d74(void) {
    // 0x10003d74
    int32_t result; // 0x10003d74
    return result;
}

// Address range: 0x10003da8 - 0x10003dbc
int32_t function_10003da8(void) {
    // 0x10003da8
    int32_t v1; // 0x10003da8
    int32_t v2 = v1 & -256 | (int32_t)*(char *)0x4688040; // 0x10003da8
    int32_t * v3 = (int32_t *)v2; // 0x10003dad
    *v3 = v2 + *v3;
    int32_t v4; // 0x10003da8
    char * v5 = (char *)(v4 - 0xa07117c); // 0x10003daf
    int32_t v6; // 0x10003da8
    *v5 = *v5 + (char)v6;
    return function_a6ac3c7b();
}

// Address range: 0x10003e15 - 0x10003e1a
int32_t function_10003e15(void) {
    // 0x10003e15
    return function_b6fce7ee();
}

// Address range: 0x10003e1d - 0x10003e26
int32_t function_10003e1d(void) {
    // 0x10003e1d
    int32_t v1; // 0x10003e1d
    int32_t v2; // 0x10003e1d
    *(char *)v2 = (char)v2 + (char)v1;
    return function_82c2774a();
}

// Address range: 0x10003e2f - 0x10003e37
int32_t function_10003e2f(int32_t a1) {
    // 0x10003e2f
    int32_t result; // 0x10003e2f
    return result;
}

// Address range: 0x10003e38 - 0x10003e39
int32_t function_10003e38(void) {
    // 0x10003e38
    int32_t result; // 0x10003e38
    return result;
}

// Address range: 0x10003e64 - 0x10004118
int32_t function_10003e64(int32_t a1) {
    // 0x10003e64
    int32_t v1; // 0x10003e64
    unsigned char v2 = (char)v1; // 0x10003e64
    int32_t v3; // 0x10003e64
    int32_t v4 = v3 - 1; // 0x10003e66
    int32_t v5; // 0x10003e64
    if (v4 != 0 && v2 != -16) {
        v5 = function_10003e38();
    }
    // 0x10003e68
    unsigned char v6; // 0x10003e64
    unsigned char v7 = v6 + (char)v4; // 0x10003e6c
    bool v8 = v2 < 240 ? v7 + (char)(v2 < 240) <= v6 : v7 < v6; // 0x10003e6c
    char * v9 = (char *)(v3 - 0x2656f001); // 0x10003e73
    *v9 = (char)(v5 / 256) + (char)v8 + *v9;
    int32_t v10 = v5 + 0x23be4ab4; // 0x10003e79
    int32_t v11; // 0x10003e64
    int32_t v12 = v11 + 1; // 0x10003e7e
    bool v13 = (v11 & 15) == 15 | (v10 & 14) > 9; // 0x10003e7f
    int32_t v14 = v13 ? v5 + 10 : v10; // 0x10003e7f
    unsigned char v15 = *(char *)-0x3f7af000; // 0x10003e88
    int32_t v16 = __asm_int3(); // 0x10003e9e
    char v17 = *(char *)(v11 + 0xc68c1ca); // 0x10003e9f
    uint32_t v18; // 0x10003e64
    int32_t v19 = 256 * (int32_t)(v17 + (char)(v18 / 256)) | v18 & -0xff01; // 0x10003e9f
    unsigned char v20 = *(char *)-0x7fdaf000; // 0x10003ea5
    *(int32_t *)(4 * v12 - 0x14000002 + v19) = 1;
    int32_t v21; // bp-4, 0x10003e64
    *(int32_t *)((v16 & -256 | (int32_t)v20) + 122) = (int32_t)&v21;
    int32_t v22; // 0x10003e64
    unsigned char v23 = *(char *)&v22; // 0x10003eba
    *(char *)v12 = (char)((256 * (int16_t)(v20 / 35) | (int16_t)(v20 % 35)) / (int16_t)v23);
    __asm_int3();
    char v24 = *(char *)-60; // 0x10003ebf
    *(char *)-60 = v24 ^ (char)((((v14 & 15 | v10 & -0x10000 | 256 * (int32_t)v13 + v10 & 0xff00) - 0x24fd0bac & -256 | (int32_t)v15) - 1 >> 31) / 256);
    bool v25; // 0x10003e64
    *(int32_t *)((v25 ? -1 : 1) + v12) = v22;
    v22 += (v25 ? -4 : 4);
    RegQueryValueExA(&g22, (char *)&g22, &g22, &g22, (char *)&g22, &g22);
    int32_t v26; // bp-3, 0x10003e64
    int32_t result = &v26; // 0x10003ed2
    int32_t * v27 = (int32_t *)(v19 + 8 * result); // 0x10003ed8
    *v27 = *v27 & v19;
    return result;
}

// Address range: 0x100041b1 - 0x100041b2
int32_t function_100041b1(void) {
    // 0x100041b1
    int32_t result; // 0x100041b1
    return result;
}

// Address range: 0x100041ba - 0x100041bb
int32_t function_100041ba(void) {
    // 0x100041ba
    int32_t result; // 0x100041ba
    return result;
}

// Address range: 0x100041bf - 0x100041c6
int32_t function_100041bf(void) {
    // 0x100041bf
    return function_826e4b8a();
}

// Address range: 0x100041d2 - 0x1000424d
int32_t function_100041d2(int16_t a1) {
    // 0x100041d2
    __asm_int3();
    int32_t v1; // 0x100041d2
    int32_t v2; // 0x100041d2
    char * v3 = (char *)(v2 + 0x779f8b76 + (int32_t)&v1); // 0x100041db
    bool v4; // 0x100041d2
    *v3 = *v3 - (v4 ? 117 : 116);
    __asm_hlt();
    int32_t v5; // 0x100041d2
    int32_t v6; // 0x100041d2
    __asm_arpl(*(int16_t *)(v5 - 0xf3a34b4), (int16_t)v6);
    int32_t v7; // 0x100041d2
    int32_t v8 = v7 - g20; // 0x100041ef
    function_100041b1();
    unsigned char v9 = (char)v8 & 31; // 0x10004208
    if (v9 != 0) {
        char * v10 = (char *)(v2 + 71); // 0x10004208
        unsigned char v11 = *v10; // 0x10004208
        *v10 = v11 << 8 - v9 | v11 >> v9;
    }
    int32_t v12; // 0x100041d2
    int32_t v13 = v12 + (int32_t)&g10 - 1; // 0x1000420b
    *(int32_t *)v8 = v8 + v13;
    char v14 = *(char *)-0x2f38f7ce; // 0x10004212
    int32_t v15 = v13 & -256; // 0x10004212
    char * v16 = (char *)(v15 | (int32_t)(v14 + (char)v13)); // 0x10004218
    char v17 = v2; // 0x10004218
    *v16 = *v16 + v17;
    char v18 = *(char *)(v6 + 48); // 0x1000421a
    int32_t v19 = v15 | (int32_t)*(char *)-0x6c45f000; // 0x1000421d
    *(int32_t *)-0x1aefff32 = v19;
    *(int32_t *)-0x1aefff36 = v8;
    *(int32_t *)-0x1aefff42 = -0x1aefff2e;
    *(int32_t *)-0x1aefff46 = v5 + 1;
    *(int32_t *)-0x1aefff4e = -0x23eb057c;
    int32_t v20 = v19; // 0x10004224
    if (((v18 - v17 ^ v18) & (v18 ^ v17)) < 0) {
        v20 = function_100041ba();
    }
    char * v21 = (char *)v20; // 0x10004226
    *v21 = *v21 + v17;
    int32_t v22 = *(int32_t *)v20; // 0x10004229
    char * v23 = (char *)v22; // 0x1000422c
    *v23 = *v23 + (char)v22;
    *(int32_t *)-0x1aefff52 = v8;
    *(int32_t *)(v5 - 17) = v8;
    char * v24 = (char *)(v6 & -256 | 163); // 0x10004243
    unsigned char v25 = *v24; // 0x10004243
    char v26 = v25 + v17; // 0x10004243
    char v27 = llvm_ctpop_i8(v26); // 0x10004243
    *v24 = v26;
    bool v28; // 0x100041d2
    bool v29; // 0x100041d2
    bool v30; // 0x100041d2
    bool v31; // 0x100041d2
    *(int32_t *)0x60ca9b62 = 0x4000 * (int32_t)v28 | 1024 * (int32_t)v29 | 512 * (int32_t)v30 | 256 * (int32_t)v31 | (int32_t)(v26 < v25) | 64 * (int32_t)(v26 == 0) | 128 * (int32_t)(v26 < 0) | 16 * (int32_t)((v25 & 15) + (v17 & 15) > 15) | 4 * (int32_t)((v27 & 1) == 0) | 2048 * (int32_t)(((v26 ^ v25) & (v26 ^ v17)) < 0) | 2;
    return unknown_9c0a0d0();
}

// Address range: 0x1000424d - 0x100043eb
int32_t function_1000424d(int32_t a1) {
    // 0x1000424d
    int32_t v1; // 0x1000424d
    int32_t v2; // 0x1000424d
    int32_t v3; // 0x1000424d
    int32_t v4; // 0x1000424d
    char * v5; // bp-2, 0x1000424d
    int32_t v6; // 0x1000424d
    int32_t v7; // 0x1000424d
    int32_t v8; // 0x1000424d
    if (v7 > v8) {
        int32_t v9 = v8 >> 31; // 0x1000425d
        int32_t v10 = v8 & -256 | 163; // 0x10004260
        char * v11 = (char *)v10; // 0x10004262
        *v11 = *v11 + (char)v9;
        int16_t v12 = (int16_t)(256 * v9) / 256; // 0x10004265
        char * v13 = (char *)(v9 & -0x10000 | (int32_t)(v12 * v12)); // 0x10004267
        *v13 = 2 * *v13;
        int32_t v14 = 8 * v6 + 85 + v10; // 0x10004270
        int32_t * v15 = (int32_t *)(v14 - 41); // 0x10004274
        *v15 = v10;
        uint16_t v16; // 0x1000424d
        v5 = (char *)(int32_t)v16;
        int32_t v17; // 0x1000424d
        v2 = v17 ^ v6;
        v3 = *v15;
        v4 = (int32_t)&v5;
        v1 = v14;
    }
    int32_t v18 = v7 - 1; // 0x10004278
    int32_t * v19 = (int32_t *)v7; // 0x10004278
    *v19 = v18;
    int32_t v20 = v2 - 1; // 0x1000427a
    char v21; // 0x1000424d
    int32_t v22; // 0x1000424d
    int32_t v23; // 0x1000424d
    int32_t v24; // 0x1000424d
    int32_t v25; // 0x1000424d
    int32_t v26; // 0x1000424d
    int32_t v27; // 0x1000424d
    if (v18 == 0 || v20 == 0) {
        char * v28 = (char *)(__asm_int1() & -256 | 163); // 0x10004280
        char v29 = v3;
        char v30 = *v28 + v29; // 0x10004280
        *v28 = v30;
        int32_t result = __asm_hlt(); // 0x10004285
        v26 = 0x40c5762f;
        v23 = v20;
        if (v30 != 0) {
            goto lab_0x100042f3;
        } else {
            // 0x1000428d
            v25 = 0x40c5762f;
            v21 = v29;
            v22 = result;
            if (*(int32_t *)(v27 - 8) != 1) {
                // 0x10004293
                return result;
            }
            goto lab_0x100042d8;
        }
    } else {
        int32_t v31 = (int32_t)*(char *)0x50871000; // 0x100042b1
        int32_t v32 = v1 & -256; // 0x100042b1
        *v19 = 0x36671c21;
        uint32_t v33 = *(int32_t *)(v4 + 0x541000a0 + 8 * v20) ^ v20; // 0x100042bc
        if (v33 != 0) {
            char * v34 = (char *)(v32 | v31); // 0x1000433c
            *v34 = *v34 + (char)v3;
            __asm_iretd();
            __asm_fbld(*(float80_t *)0x815e);
            int32_t result2 = v27 - 12; // 0x1000434d
            v5 = (char *)(result2 & 0xffff);
            int32_t * v35 = (int32_t *)(0x10000 * (int32_t)v5 / 0x10000); // 0x10004358
            *v35 = *v35 - 1;
            return result2;
        }
        int32_t v36 = v31 | 40; // 0x100042c7
        int32_t v37 = v36 | v32; // 0x100042c7
        __asm_arpl(*(int16_t *)v37, (int16_t)v37);
        int32_t v38 = v33 / 256 + v36; // 0x100042cc
        *(char *)v6 = (char)v38;
        v21 = v3;
        v22 = v32 | v38 + 86 & 255 | -0x3e7eff00;
        bool v39; // 0x1000424d
        v24 = (v39 ? -1 : 1) + v6;
        goto lab_0x100042d8;
    }
  lab_0x100042f3:;
    // 0x100042f3
    int32_t v40; // 0x1000424d
    *(char *)(v40 - 31) = (char)v23;
    return function_ab3626a2(v26);
  lab_0x100042d8:
    // 0x100042d8
    *(int32_t *)0x30134c59 = v22;
    int32_t v41 = v22 & -256 | (int32_t)*(char *)-0x707df000; // 0x100042e0
    char * v42 = (char *)v24; // 0x100042e5
    *v42 = *v42 | v21;
    char * v43 = (char *)v41; // 0x100042ea
    *v43 = *v43 + v21;
    v26 = v25;
    v23 = *(int32_t *)(v41 - 96);
    v40 = v24;
    goto lab_0x100042f3;
}

// Address range: 0x100043f9 - 0x100043fa
int32_t function_100043f9(void) {
    // 0x100043f9
    int32_t result; // 0x100043f9
    return result;
}

// Address range: 0x10004414 - 0x10004417
int32_t function_10004414(int32_t a1) {
    // 0x10004414
    int32_t result; // 0x10004414
    return result;
}

// Address range: 0x10004432 - 0x100044ab
int32_t function_10004432(int16_t a1) {
    // 0x10004432
    uint32_t v1; // 0x10004432
    unsigned char v2 = (char)(v1 / 256); // 0x10004432
    int32_t v3; // 0x10004432
    bool v4; // 0x10004432
    unsigned char v5 = *(char *)(v3 + 15) + (char)v4; // 0x10004432
    unsigned char v6 = v2 - v5 + (char)v4; // 0x10004432
    if (v5 <= v2) {
        bool v7 = v4 ? v5 != -1 | v6 > v2 : v5 > v2; // 0x10004432
        int32_t v8 = __asm_iretd(); // 0x1000449f
        __asm_int(197);
        return (v8 & -256 | (v7 ? 255 : 0)) - (v7 ? -0x76e8f4f1 : -0x76e8f4f2);
    }
    int32_t v9 = __asm_int1(); // 0x1000443e
    if (((v6 ^ v2) & (v5 ^ v2)) < 0) {
        v9 = function_100043f9();
    }
    uint32_t result = v9;
    char * v10 = (char *)result; // 0x10004440
    int32_t v11; // 0x10004432
    *v10 = *v10 + (char)v11;
    int32_t * v12 = (int32_t *)result; // 0x10004442
    uint32_t v13 = *v12; // 0x10004442
    *v12 = v13 / 4 | 0x40000000 * v13;
    if (*(char *)(result + 0x5d391000) == (char)(result / 256)) {
        // 0x10004459
        return result;
    }
    // 0x10004450
    return result - 1;
}

// Address range: 0x100044f9 - 0x10004508
int32_t function_100044f9(void) {
    // 0x100044f9
    uint32_t v1; // 0x100044f9
    *(char *)-0x6759f000 = *(char *)-0x6759f000 ^ (char)(v1 / 256);
    int32_t v2; // 0x100044f9
    int32_t v3; // 0x100044f9
    int32_t v4; // 0x100044f9
    int32_t v5; // 0x100044f9
    int32_t v6; // 0x100044f9
    int32_t v7; // 0x100044f9
    return function_38ef82c2(v3, v4, v5, &v2, v6, v1, v7, -0x6759f000);
}

// Address range: 0x10004508 - 0x10004517
int32_t function_10004508(int32_t a1) {
    // 0x10004508
    int32_t v1; // 0x10004508
    char * v2 = (char *)(v1 + 0x15fffcf5); // 0x10004508
    uint32_t v3; // 0x10004508
    bool v4; // 0x10004508
    *v2 = *v2 + (char)(v3 / 256) + (char)v4;
    int32_t v5; // 0x10004508
    return v5 - 1 & -256 | (int32_t)*(char *)-0x7f70f000;
}

// Address range: 0x10004517 - 0x10004526
int32_t function_10004517(void) {
    // 0x10004517
    return function_82c35f4a();
}

// Address range: 0x10004528 - 0x10004530
int32_t function_10004528(int32_t a1) {
    // 0x10004528
    return 0x3b1000a0;
}

// Address range: 0x10004574 - 0x1000457a
int32_t function_10004574(void) {
    // 0x10004574
    return function_76c44af5();
}

// Address range: 0x1000457a - 0x10004580
int32_t function_1000457a(int32_t a1) {
    // 0x1000457a
    return __asm_int3();
}

// Address range: 0x10004592 - 0x1000462b
int32_t function_10004592(int32_t a1, int32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x10004592
    int32_t v1; // 0x10004592
    char * v2 = (char *)(v1 + 112); // 0x10004594
    int32_t v3; // 0x10004592
    bool v4; // 0x10004592
    *v2 = (char)v4 + (char)v3 + *v2;
    int32_t v5 = __asm_sti(); // 0x10004598
    int32_t v6; // 0x10004592
    int32_t * v7 = (int32_t *)(v6 - 0x24e6339a); // 0x10004599
    *v7 = *v7 ^ v1;
    *(int32_t *)v3 = 0x2000000 * v3;
    bool v8; // 0x10004592
    int32_t v9 = (v8 ? -4 : 4) + v1; // 0x100045a6
    __asm_int(197);
    int32_t v10 = v9 + 1; // 0x100045b5
    int32_t v11; // 0x10004592
    int32_t v12; // 0x10004592
    int32_t v13; // 0x10004592
    if (v10 < 0 == (v10 & (v9 ^ -0x80000000)) < 0) {
        // 0x100045b8
        int32_t v14; // 0x10004592
        int32_t v15 = *(int32_t *)v5 + v14; // 0x1000459f
        int32_t v16 = *(int32_t *)(v15 + 9) ^ 0x20e003f; // 0x100045bc
        int32_t v17 = v10; // 0x100045bc
        int32_t v18 = v15; // 0x100045bc
        v18++;
        *(char *)v18 = *(char *)v17;
        int32_t v19; // 0x10004592
        *(char *)v19 = -1;
        v17++;
        while (v16 >= 0) {
            // 0x100045bf
            v18++;
            *(char *)v18 = *(char *)v17;
            *(char *)v19 = -1;
            v17++;
        }
        // 0x100045c5
        __asm_hlt();
        int32_t v20; // 0x10004592
        int32_t v21 = v20 - 1; // 0x100045c8
        *(char *)0x5350c845 = *(char *)0x5350c845 + (char)v16;
        unsigned char v22 = (char)v21; // 0x100045d6
        v11 = v21 & -0x10000 | (int32_t)(v22 % 35) | 256 * (int32_t)(v22 / 35);
        v13 = v19 + 1;
        v12 = &g11;
    } else {
        // 0x100045f6
        v11 = a6;
        v13 = a4;
        if (a5 == 1) {
            int32_t result = a6 & -0xff01 | 0xd000; // 0x10004608
            char * v23 = (char *)result;
            char v24 = *v23 + (char)a4; // 0x1000460a
            *v23 = v24;
            if (v24 != 0) {
                // 0x10004628
                return result;
            }
            uint32_t v25 = (int32_t)g19; // 0x1000460e
            char * v26 = v23; // 0x10004614
            bool v27 = v25 < a3; // 0x10004614
            int32_t result2 = result; // 0x10004614
            if (v25 <= a3) {
                // 0x10004616
                result2 = result & -0x3000 | (int32_t)*(char *)-0x4f059bed;
                v26 = (char *)result2;
                unsigned char v28 = *v26; // 0x1000461b
                char v29 = v28 / 128; // 0x1000461b
                *v26 = v29 | 2 * v28;
                v27 = v29 != 0;
            }
            char * v30 = (char *)(result2 - 0x4bc3fcde); // 0x1000461d
            *v30 = (char)v27 + (char)(a3 / 256) + *v30;
            unsigned char v31 = *v26; // 0x10004623
            char v32 = v31 / 128; // 0x10004623
            *v26 = v32 | 2 * v31;
            char * v33 = (char *)a3; // 0x10004625
            *v33 = *v33 + (char)result2 + (char)(v32 != 0);
            return result2;
        }
    }
    char * v34 = (char *)v11; // 0x100045e1
    unsigned char v35 = *v34; // 0x100045e1
    *v34 = v35 + (char)v13;
    int32_t v36 = __asm_insd((int16_t)(256 * (int32_t)v35 | v13 & 255)); // 0x100045e6
    *(int32_t *)v12 = v36;
    return function_d8458d0c();
}

// Address range: 0x1000462b - 0x1000463c
int32_t function_1000462b(void) {
    // 0x1000462b
    int32_t v1; // 0x1000462b
    int32_t v2 = *(int32_t *)(v1 + 86); // 0x1000462f
    int32_t v3; // 0x1000462b
    int32_t v4 = v2 + v3; // 0x1000462f
    if (((v4 ^ v3) & (v4 ^ v2)) < 0) {
        function_1000462b();
    }
    // 0x10004635
    return unknown_a0383e();
}

// Address range: 0x1000463c - 0x10004722
int32_t function_1000463c(int32_t a1) {
    int32_t v1 = *(int32_t *)0x23d41000; // 0x10004653
    bool v2; // 0x1000463c
    int32_t v3 = v2 ? -1 : 1;
    int32_t v4 = 2 * v3;
    int32_t v5; // 0x1000463c
    int32_t v6 = v4 + v5; // 0x1000465a
    int32_t v7; // 0x1000463c
    int32_t v8 = v4 + v7; // 0x1000465a
    int32_t v9; // 0x1000463c
    char v10 = v9; // 0x10004661
    char * v11 = (char *)(v1 & -256 | (int32_t)(*(char *)-0x2da0f000 + v10)); // 0x10004663
    *v11 = *v11 + v10;
    int32_t v12 = __asm_sti(); // 0x10004665
    char v13 = __asm_insb((int16_t)v9); // 0x10004666
    char * v14 = (char *)v6; // 0x10004666
    *v14 = v13;
    int32_t v15 = v9 & -0xff01 | 0xa200; // 0x10004667
    char * v16 = (char *)(v15 + 64); // 0x1000466a
    *v16 = *v16 - 51;
    unsigned char v17 = *(char *)0x44724865; // 0x10004671
    unsigned char v18 = (char)((v12 + 1) / 256); // 0x10004671
    *(char *)0x44724865 = v17 - v18;
    int32_t v19; // 0x1000463c
    char * v20 = (char *)(v19 - 0x59ae694a); // 0x10004674
    int32_t v21; // 0x1000463c
    *v20 = *v20 + (char)v21 + (char)(v17 < v18);
    int16_t v22; // 0x1000463c
    uint32_t v23 = unknown_d6cd6030(v22); // 0x1000467f
    uint32_t v24 = v15 + 1; // 0x10004686
    int32_t * v25 = (int32_t *)v8; // 0x10004687
    __asm_outsd((int16_t)v24, *v25);
    unsigned char v26 = *(char *)0x44724866; // 0x10004688
    unsigned char v27 = (char)(v23 / 256); // 0x10004688
    *(char *)0x44724866 = v26 - v27;
    char * v28 = (char *)(v19 + 45); // 0x1000468b
    unsigned char v29 = *v28; // 0x1000468b
    char v30 = v24 / 256; // 0x1000468b
    char v31 = v26 < v27; // 0x1000468b
    unsigned char v32 = v29 + v30; // 0x1000468b
    char v33 = v32 + v31; // 0x1000468b
    char v34 = v33 + v31; // 0x1000468b
    *v28 = v33;
    uint32_t v35 = v19 - 0x5020340; // 0x1000468e
    char v36; // 0x1000463c
    if (v33 < 0 != ((v34 ^ v29) & (v34 ^ v30)) < 0) {
        char * v37 = (char *)v35; // 0x10004698
        *v37 = *v37 + v36;
        *v25 = 64 * *v25;
        __asm_int3();
        int32_t * v38 = (int32_t *)v6; // 0x100046a1
        *v38 = -1 - *v38;
        char * v39 = (char *)v8; // 0x100046a4
        *v39 = *v39 + 2 * v36;
        return v19 - 0x2010240;
    }
    int32_t v40 = v36; // 0x10004694
    char v41 = *(char *)-0x7a58a79a; // 0x100046b7
    char v42 = v35 / 256; // 0x100046b7
    char v43 = v26 < v27 ? v33 <= v29 : v32 < v29; // 0x100046b7
    char v44 = v43 + v42 + v41; // 0x100046b7
    char v45 = llvm_ctpop_i8(v44); // 0x100046b7
    *(char *)-0x7a58a79a = v44;
    char v46 = (v35 & 14) > 9 | (v42 & 15) + v43 + (v41 & 15) > 15; // 0x100046c0
    char v47 = 128 * (char)(v44 < 0) | 64 * (char)(v44 == 0) | v46 | 4 * (char)((v45 & 1) == 0) | 16 * v46 | 2; // 0x100046c0
    int32_t v48 = unknown_900046d1((int32_t)v47); // 0x100046ca
    int32_t v49; // 0x1000463c
    int32_t v50; // 0x1000463c
    if (v36 >= 0 == (v36 != 0)) {
        // 0x10004716
        *(char *)-0x72af07bb = *(char *)-0x72af07bb + 102;
        v50 = v48 & -0xff01 | 0x7c00;
        v49 = 1;
    } else {
        // 0x100046d6
        v50 = v48;
        v49 = v3;
        if (v36 >= 0) {
            int32_t v51 = v48 & -65; // 0x100046dc
            int32_t * v52 = (int32_t *)(v51 - 0xf9839d0); // 0x100046de
            uint32_t v53 = *v52; // 0x100046de
            *v52 = 4 * v53 | v53 / 0x80000000;
            int32_t v54 = __asm_in_2(180); // 0x100046e8
            char * v55 = (char *)((v21 & -256 | 230) + 104); // 0x100046ea
            *v55 = 2 * *v55 | (char)(((char)v51 ^ -8) < 184);
            bool v56 = (v48 & 8) != 0 | (v54 & 14) > 9; // 0x100046ed
            int32_t v57 = 256 * (int32_t)v56 + v54 & 0xff00 | v54 & -0x10000;
            char * v58 = (char *)(v6 + v3); // 0x100046ee
            *v58 = *v58 + v47;
            char * v59 = (char *)(v40 + 81); // 0x100046f0
            char v60 = *v59; // 0x100046f0
            char v61 = v60 + v36; // 0x100046f0
            *v59 = v61;
            if (v61 < 0 == ((v61 ^ v60) & (v61 ^ v36)) < 0) {
                // 0x10004720
                return v57 | (v56 ? v54 + 10 : v54) & 15;
            }
            // 0x100046f7
            return v57 | (int32_t)*(char *)v8;
        }
    }
    // 0x10004716
    *v14 = *(char *)v8;
    char * v62 = (char *)v50; // 0x10004717
    char v63 = *v62; // 0x10004717
    char v64 = v63 + v36; // 0x10004717
    *v62 = v64;
    int32_t v65 = v64 < 0 == ((v64 ^ v63) & (v64 ^ v36)) < 0 ? v40 : *(int32_t *)(v21 ^ 23); // 0x10004719
    __asm_outsb((int16_t)v65, *(char *)(v49 + v8));
    // 0x10004720
    return __asm_wait();
}

// Address range: 0x10004723 - 0x10004751
int32_t function_10004723(void) {
    // 0x10004723
    __asm_hlt();
    int32_t v1 = unknown_50c5be5a(); // 0x10004726
    bool v2; // 0x10004723
    if (v2) {
        // 0x1000472d
        int32_t v3; // 0x10004723
        if (*(int32_t *)(v3 - 4) != 1) {
            // 0x1000474f
            return (float32_t)function_10004757();
        }
    }
    // 0x10004733
    int32_t v4; // 0x10004723
    int16_t v5 = v4; // 0x10004733
    int32_t v6; // 0x10004723
    __asm_outsd(v5, v6);
    __asm_outsb(v5, (char)v6);
    int32_t v7; // 0x10004723
    *(char *)v7 = (char)v1;
    int32_t v8; // 0x10004723
    bool v9; // 0x10004723
    *(char *)((v9 ? -1 : 1) + v7) = (char)v8;
    *(char *)v8 = *(char *)&v8;
    // 0x1000474f
    return (float32_t)function_10004757();
}

// Address range: 0x10004755 - 0x10004757
int32_t function_10004755(void) {
    // 0x10004755
    int32_t v1; // 0x10004755
    int32_t result; // 0x10004755
    *(char *)result = (char)result + (char)v1;
    return result;
}

// Address range: 0x10004757 - 0x1000479c
float80_t function_10004757(void) {
    unsigned char v1 = *(char *)0x946ca9; // 0x10004757
    int32_t v2; // 0x10004757
    int32_t v3 = v2 & -256; // 0x10004757
    char * v4 = (char *)((v3 | (int32_t)v1) - 0x64c8dd0c); // 0x1000475c
    char v5 = *v4; // 0x1000475c
    int32_t v6; // 0x10004757
    char v7 = v6; // 0x1000475c
    bool v8; // 0x10004757
    char v9 = v8; // 0x1000475c
    *v4 = v9 + v7 + v5;
    bool v10 = (v1 & 14) > 9 | (v7 & 15) + v9 + (v5 & 15) > 15; // 0x10004762
    unsigned char v11 = v10 ? v1 + 10 : v1; // 0x10004762
    int32_t v12 = (v3 | (int32_t)v11) & -0xfff1 | 256 * (int32_t)v10 + v2 & 0xff00; // 0x10004762
    char * v13 = (char *)v12; // 0x1000476b
    int32_t v14; // 0x10004757
    *v13 = *v13 + (char)v14;
    int32_t * v15 = (int32_t *)(v14 + 92); // 0x1000476d
    int32_t v16; // 0x10004757
    *v15 = *v15 + v16;
    int32_t v17 = -0x2befffa0 * *(int32_t *)v12; // 0x10004771
    int32_t v18 = (v6 ^ -0x6b9352ad) + 1; // 0x10004777
    *(int32_t *)(v17 - 4) = -0x4cefff6c;
    int32_t v19; // 0x10004757
    int32_t v20; // 0x10004757
    *(char *)v20 = *(char *)&v19;
    *(int32_t *)(v17 - 12) = v18;
    int32_t v21 = v17 - 16; // 0x1000478f
    *(int32_t *)v21 = (int32_t)&g12;
    *(int32_t *)(v17 - 20) = *(int32_t *)0x3a8c1000;
    *(int32_t *)(v17 - 32) = v18;
    *(int32_t *)(v17 - 36) = v21;
    *(int32_t *)(v17 - 44) = 0x5350ff7f;
    bool v22; // 0x10004757
    *(int32_t *)(v17 - 48) = (v22 ? -1 : 1) + v20;
    int32_t v23; // 0x10004757
    return (float80_t)*(int64_t *)(v23 + 0x1373dc7b);
}

// Address range: 0x1000479d - 0x10004837
int32_t function_1000479d(void) {
    int32_t v1 = -0xfefff6c; // bp-6, 0x1000479f
    char v2; // 0x1000479d
    int32_t v3; // 0x1000479d
    int32_t * v4; // 0x1000479d
    bool v5; // 0x1000479d
    bool v6; // 0x1000479d
    uint32_t v7; // 0x1000479d
    int32_t v8; // 0x1000479d
    uint32_t v9; // 0x1000479d
    bool v10; // 0x1000479d
    if (v5 == v10 == !v6) {
        // 0x100047d6
        int32_t v11; // 0x1000479d
        __asm_outsb((int16_t)v8, (char)v11);
        v2 = v7 / 256;
        v4 = &v1;
        int32_t v12; // 0x1000479d
        bool v13; // 0x1000479d
        v3 = (v13 ? -1 : 1) + v12;
    } else {
        // 0x100047a6
        int32_t v14; // 0x1000479d
        unsigned char v15 = (char)v14; // 0x100047a7
        bool v16; // 0x1000479d
        bool v17 = v15 > 153 | v16;
        int32_t v18; // 0x1000479d
        bool v19; // 0x1000479d
        if ((v15 & 14) > 9 || v19) {
            v18 = (v17 ? 154 : 250) + v14 & 255 | v14 & -256;
        } else {
            v18 = (v17 ? v14 + 160 : v14) & 255 | v14 & -256;
        }
        int16_t v20; // 0x1000479d
        int32_t v21 = v20; // 0x100047a8
        char * v22 = (char *)(v21 + 21); // 0x100047a9
        unsigned char v23 = *v22; // 0x100047a9
        char v24 = v7 / 256;
        unsigned char v25 = v23 + v24; // 0x100047a9
        unsigned char v26 = v25 + (char)v17; // 0x100047a9
        *v22 = v26;
        v2 = v24;
        int32_t v27; // bp-4, 0x1000479d
        v4 = &v27;
        v3 = v21;
        if (v26 != 0 && !((v17 ? v26 <= v23 : v25 < v23))) {
            char * v28 = (char *)(v18 - 108); // 0x100047b5
            *v28 = *v28 & (char)(v9 / 256);
            char * v29 = (char *)v18; // 0x100047b8
            char v30 = v8; // 0x100047b8
            *v29 = *v29 + v30;
            int32_t result = v18 & -256 | (int32_t)*(char *)-0x3070f000; // 0x100047bd
            int32_t * v31 = (int32_t *)(result + 104); // 0x100047c2
            uint32_t v32 = *v31; // 0x100047c2
            *v31 = v32 / 0x100000 | 0x1000 * v32;
            char * v33 = (char *)result; // 0x100047c6
            *v33 = *v33 + v30;
            return result;
        }
    }
    char * v34 = (char *)unknown_f60ca9c(); // 0x100047e2
    char v35 = v8; // 0x100047e2
    *v34 = *v34 + v35;
    int32_t v36 = *(int32_t *)91 ^ v9; // 0x100047f4
    char v37 = *(char *)(v8 - 0x761448cd); // 0x100047f7
    __asm_arpl(__readgsword(-0x6ba93335), (int16_t)v36);
    int32_t v38; // 0x1000479d
    *(char *)v3 = *(char *)&v38;
    v38++;
    *(char *)132 = *(char *)132 + v35;
    int32_t v39; // 0x1000479d
    int32_t * v40 = (int32_t *)(v39 - 4); // 0x1000480a
    *v40 = 256 * (int32_t)(v37 & v2) | v7 & -0xff01 | *v40;
    *(char *)(v3 + 0x53a9d5d2) = (char)v36;
    uint32_t v41 = (int32_t)v4 - 4 | v39 - 7; // 0x10004819
    uint32_t v42 = v41 ^ 0xa4a0a4; // 0x1000481b
    char * v43 = (char *)(v42 + 75); // 0x10004820
    *v43 = *v43 + (char)(v42 / 256);
    *(int32_t *)(v8 + 105) = v38;
    int32_t v44 = v42 + 210; // 0x10004826
    int32_t v45 = v44 & 255 | v42 & -256; // 0x10004826
    int32_t * v46 = (int32_t *)v45; // 0x1000482e
    *v46 = *v46 + v45;
    return (v41 / 2 & 128) + v44 & 255 | v42 & -0x10000;
}

// Address range: 0x10004851 - 0x10004882
int32_t function_10004851(int32_t a1) {
    // 0x10004851
    bool v1; // 0x10004851
    int32_t v2 = v1 ? -1 : 1; // 0x10004851
    int32_t v3; // 0x10004851
    int32_t v4; // 0x10004851
    int32_t v5 = v2 + v3 + (v4 & -256 | (int32_t)*(char *)0x7b551000); // 0x10004857
    int32_t v6; // 0x10004851
    if (v6 == 1 || v5 == 0) {
        // 0x1000485c
        return function_792c82ca();
    }
    uint32_t v7 = a1 - 316; // 0x1000486a
    int32_t v8; // 0x10004851
    *(char *)v8 = *(char *)v5;
    char * v9 = (char *)v7; // 0x10004875
    int32_t v10; // 0x10004851
    *v9 = *v9 + (char)v10;
    char * v11 = (char *)(v8 - 52 + v2); // 0x1000487c
    *v11 = *v11 | (char)(v7 / 256);
    return 0x10000 * v7 / 0x10000;
}

// Address range: 0x100048d8 - 0x100048d9
int32_t function_100048d8(void) {
    // 0x100048d8
    int32_t result; // 0x100048d8
    return result;
}

// Address range: 0x1000491c - 0x10004920
int32_t function_1000491c(int32_t a1) {
    // 0x1000491c
    int32_t result; // 0x1000491c
    return result;
}

// Address range: 0x10004932 - 0x10004935
int32_t function_10004932(void) {
    // 0x10004932
    int32_t result; // 0x10004932
    return result;
}

// Address range: 0x1000496e - 0x10004a1c
int32_t function_1000496e(int32_t a1) {
    // 0x1000496e
    int32_t v1; // 0x1000496e
    char v2 = v1;
    *(char *)0x77fe1000 = v2;
    uint32_t v3; // 0x1000496e
    *(char *)v1 = v2 + (char)(v3 / 256);
    int32_t v4; // 0x1000496e
    unsigned char v5 = *(char *)&v4; // 0x10004978
    int32_t v6; // 0x1000496e
    char v7 = v6; // 0x10004978
    unsigned char v8 = v5 + v7; // 0x10004978
    *(char *)v4 = v8;
    int32_t v9 = v4;
    int32_t v10 = v9 & -256 | (int32_t)*(char *)-0x707df000; // 0x10004980
    v4 = v10;
    int32_t result; // 0x1000496e
    *(char *)result = *(char *)&result | v7;
    char * v11 = (char *)v10; // 0x1000498a
    *v11 = *v11 + v7;
    int32_t v12; // 0x1000496e
    if (g18 <= (char)v12) {
        // 0x100049f7
        return result;
    }
    // 0x10004994
    int32_t v13; // 0x1000496e
    int32_t v14 = v9 + v13 + (int32_t)(v8 < v5); // 0x1000497b
    char * v15 = (char *)(v14 + 0x61284494); // 0x10004996
    *v15 = *v15 - v7;
    char * v16 = (char *)v4; // 0x1000499c
    *v16 = *v16 + v7;
    *(char *)0x1f869173 = *(char *)0x1f869173 & -65;
    *(int32_t *)result = v4;
    bool v17; // 0x1000496e
    int32_t v18 = result + (v17 ? -4 : 4); // 0x100049ac
    *(int16_t *)v18 = (int16_t)v4;
    *(char *)(v18 + (v17 ? -2 : 2)) = (char)v4;
    char * v19 = (char *)v14; // 0x100049b6
    *v19 = *v19 + 59;
    uint32_t v20 = __asm_wait(); // 0x100049bc
    char * v21 = (char *)v20; // 0x100049bf
    unsigned char v22 = *v21; // 0x100049bf
    unsigned char v23 = (char)(v20 / 256); // 0x100049bf
    *v21 = v22 - v23;
    char * v24 = (char *)(v6 + 0xa0e0ef); // 0x100049c2
    *v24 = *v24 + (char)v20 + (char)(v22 < v23);
    int16_t v25; // 0x1000496e
    return function_faf63c48((int32_t)&g3, v20 - 268, v25);
}

// Address range: 0x10004a1c - 0x10004a51
int32_t function_10004a1c(int16_t a1) {
    // 0x10004a1c
    int32_t v1; // 0x10004a1c
    float80_t v2; // 0x10004a1c
    *(float32_t *)(v1 - 0x1e5f000) = (float32_t)v2;
    int32_t v3; // 0x10004a1c
    uint32_t v4; // 0x10004a1c
    int32_t v5 = v4 | v3; // 0x10004a23
    uint32_t v6 = *(int32_t *)v5; // 0x10004a25
    bool v7; // 0x10004a1c
    int32_t v8 = v7 ? -4 : 4; // 0x10004a25
    int32_t v9 = v8 + v4; // 0x10004a25
    uint32_t v10 = __asm_in_2(16); // 0x10004a27
    __asm_arpl(*(int16_t *)v10, (int16_t)v10);
    uint32_t v11; // 0x10004a1c
    uint32_t v12 = v11 / 256; // 0x10004a2b
    unsigned char v13 = (char)v12; // 0x10004a2b
    unsigned char v14 = 2 * (char)v12; // 0x10004a2b
    unsigned char v15 = v14 | (char)(v4 < v6); // 0x10004a2b
    bool v16 = v4 < v6 ? v15 <= v13 : v14 < v13; // 0x10004a2b
    uint32_t v17 = v10 + 0x1000a16c + (int32_t)v16; // 0x10004a2d
    g7 = v17;
    int32_t v18; // 0x10004a1c
    int16_t v19 = v18; // 0x10004a37
    *(int32_t *)(v8 + v5) = __asm_insd(v19);
    __asm_outsd(v19, *(int32_t *)v9);
    int32_t v20; // 0x10004a1c
    char v21 = v20;
    unsigned char v22 = v21 & 31; // 0x10004a39
    int32_t v23; // 0x10004a1c
    char v24; // 0x10004a1c
    bool v25; // 0x10004a1c
    if (v22 == 0) {
        // 0x10004a1c
        v23 = v20;
        v24 = v21;
        v25 = v16 ? v17 <= v10 : v10 > 0xefff5e93;
    } else {
        char * v26 = (char *)(v9 + 0x1000a05c); // 0x10004a39
        unsigned char v27 = *v26; // 0x10004a39
        char v28 = v27 >> 8 - v22 | v27 << v22; // 0x10004a39
        *v26 = v28;
        v23 = v20;
        v24 = *(char *)&v20;
        v25 = (v28 & 1) != 0;
    }
    bool v29 = v25;
    unsigned char v30 = v24; // 0x10004a49
    uint32_t v31 = v17 + v9; // 0x10004a3f
    bool v32 = v29 ? v31 + (int32_t)v29 <= v17 : v31 < v17; // 0x10004a3f
    uint32_t result = __asm_iretd(); // 0x10004a41
    char v33 = result / 256; // 0x10004a49
    unsigned char v34 = v30 + v33; // 0x10004a49
    unsigned char v35 = v34 + (char)v32; // 0x10004a49
    bool v36 = v32 ? v35 <= v30 : v34 < v30; // 0x10004a49
    *(char *)v23 = v35;
    char * v37 = (char *)(256 * (int32_t)v15 | v11 & -0xff01); // 0x10004a4b
    unsigned char v38 = *v37; // 0x10004a4b
    char v39 = v36; // 0x10004a4b
    unsigned char v40 = v39 + v33; // 0x10004a4b
    char v41 = v38 - v40; // 0x10004a4b
    bool v42 = v36 ? v40 != -1 | v38 < v41 - v39 : v38 < v40; // 0x10004a4b
    *v37 = v41 + v15 + (char)v42;
    return result;
}

// Address range: 0x10004a51 - 0x10004a79
int32_t function_10004a51(void) {
    // 0x10004a51
    uint32_t result; // 0x10004a51
    bool v1; // 0x10004a51
    if (v1) {
        // 0x10004a53
        return result;
    }
    int16_t v2 = result;
    __asm_arpl(v2, v2);
    int32_t v3; // 0x10004a51
    int32_t v4; // 0x10004a51
    char * v5 = (char *)(v4 + 0x17a4f309 + 8 * v3); // 0x10004a60
    bool v6; // 0x10004a51
    *v5 = (char)v6 + (char)(result / 256) + *v5;
    int32_t * v7 = (int32_t *)(v4 + 12); // 0x10004a68
    uint32_t v8 = *v7; // 0x10004a68
    uint32_t v9; // 0x10004a51
    *v7 = v8 - v9;
    int32_t v10; // 0x10004a51
    __asm_arpl(*(int16_t *)&v10, (int16_t)v10);
    int32_t v11; // 0x10004a51
    char * v12 = (char *)(v11 + (int32_t)&g8); // 0x10004a6d
    *v12 = (char)(v10 / 256) + (char)(v8 < v9) + *v12;
    int32_t * v13 = (int32_t *)(v4 + 32); // 0x10004a75
    int32_t v14 = *v13; // 0x10004a75
    char v15 = *(char *)*(int32_t *)(v4 + 8); // 0x10004a76
    *v13 = *(int32_t *)(v4 + 20);
    return v14 & -256 | (int32_t)(v15 & (char)v14);
}

// Address range: 0x10004abb - 0x10004ac0
int32_t function_10004abb(int32_t a1) {
    // 0x10004abb
    int32_t v1; // 0x10004abb
    return v1 | 200;
}

// Address range: 0x10004ac7 - 0x10004ac8
int32_t function_10004ac7(void) {
    // 0x10004ac7
    int32_t result; // 0x10004ac7
    return result;
}

// Address range: 0x10004ace - 0x10004ad5
int32_t function_10004ace(void) {
    // 0x10004ace
    int32_t result; // 0x10004ace
    return result;
}

// Address range: 0x10004ae1 - 0x10004ae2
int32_t function_10004ae1(void) {
    // 0x10004ae1
    int32_t result; // 0x10004ae1
    return result;
}

// Address range: 0x10004af5 - 0x10004af6
int32_t function_10004af5(void) {
    // 0x10004af5
    int32_t result; // 0x10004af5
    return result;
}

// Address range: 0x10004b14 - 0x10004b1c
int32_t function_10004b14(int32_t a1) {
    // 0x10004b14
    return unknown_631c1e();
}

// Address range: 0x10004b2e - 0x10004b4a
int32_t function_10004b2e(void) {
    // 0x10004b2e
    int32_t v1; // 0x10004b2e
    int32_t v2; // 0x10004b2e
    if (v2 == v1) {
        // 0x10004b45
        return function_20011b4a();
    }
    int32_t v3 = -1; // 0x10004b34
    int32_t v4; // 0x10004b2e
    if (v4 != 1) {
        // 0x10004b36
        function_10004ac7();
        int32_t v5 = v4 - 2; // 0x10004b36
        v3 = v5;
        if (v5 == 0) {
            function_10004ae1();
            v3 = 0;
        }
    }
    // 0x10004b38
    *(int32_t *)v1 = v3 ^ v1;
    int32_t v6; // 0x10004b2e
    int32_t v7; // 0x10004b2e
    *(int32_t *)v6 = __asm_insd((int16_t)v7);
    __asm_int3();
    return __asm_int3();
}

// Address range: 0x10004b4a - 0x10004b6d
int32_t function_10004b4a(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10004b4a
    __asm_hlt();
    int32_t v1; // 0x10004b4a
    int32_t * v2 = (int32_t *)(v1 + 106); // 0x10004b4b
    int32_t v3; // 0x10004b4a
    *v2 = *v2 & v3;
    __asm_int3();
    int32_t v4; // 0x10004b4a
    *(int32_t *)v4 = a2;
    return function_10004bb4();
}

// Address range: 0x10004b71 - 0x10004b88
int32_t function_10004b71(int32_t a1) {
    int32_t v1 = *(int32_t *)-0x2a70f000; // 0x10004b71
    bool v2; // 0x10004b71
    int32_t v3 = *(int32_t *)((v1 + (v2 ? 251 : 250) & 255 | v1 & -256) + 106); // 0x10004b7c
    int32_t v4; // 0x10004b71
    int32_t v5 = v3 ^ (int32_t)&v4; // 0x10004b7c
    char v6 = (char)a1 ^ -91; // 0x10004b7f
    *(int32_t *)(v5 - 4) = v5;
    int32_t result = a1 & -256 | (int32_t)v6; // 0x10004b83
    if (v6 >= 0 == (v6 != 0)) {
        result = function_10004b2e();
    }
    // 0x10004b85
    return result;
}

// Address range: 0x10004bb4 - 0x10004bdb
int32_t function_10004bb4(void) {
    // 0x10004bb4
    uint32_t v1; // 0x10004bb4
    unsigned char v2 = (char)v1;
    int32_t v3; // 0x10004bb4
    unsigned char v4 = v2 + (char)v3; // 0x10004bb5
    *(char *)v1 = v4;
    uint32_t v5; // 0x10004bb4
    unsigned char v6 = (char)(v5 / 256); // 0x10004bb9
    unsigned char v7 = (char)(v1 / 256) + v6; // 0x10004bb9
    bool v8 = v4 < v2 ? v7 + (char)(v4 < v2) <= v6 : v7 < v6; // 0x10004bb9
    __asm_wait();
    int32_t v9; // 0x10004bb4
    int32_t v10; // 0x10004bb4
    char v11 = (char)v10 - *(char *)(v9 + 0x2fe8f4f9) + (char)v8; // 0x10004bc2
    char * v12 = (char *)(v9 | 99); // 0x10004bcb
    *v12 = v11 + *v12;
    int32_t result = WaitForSingleObject(&g22, (int32_t)&g22); // 0x10004bcd
    char * v13 = (char *)(v3 - 90); // 0x10004bd7
    int32_t v14; // 0x10004bb4
    *v13 = *v13 + (char)(*(char *)&v14 > (char)result) - (v11 | 26);
    return result;
}

// Address range: 0x10004c02 - 0x10004c03
int32_t function_10004c02(int32_t a1) {
    // 0x10004c02
    int32_t result; // 0x10004c02
    return result;
}

// Address range: 0x10004c0f - 0x10004c10
int32_t function_10004c0f(void) {
    // 0x10004c0f
    int32_t result; // 0x10004c0f
    return result;
}

// Address range: 0x10004c17 - 0x10004c1b
int32_t function_10004c17(int32_t a1) {
    // 0x10004c17
    int32_t result; // 0x10004c17
    return result;
}

// Address range: 0x10004c2e - 0x10004d91
int32_t function_10004c2e(int16_t a1, int32_t a2) {
    // 0x10004c2e
    int32_t v1; // 0x10004c2e
    char * v2 = (char *)(v1 - 2); // 0x10004c2f
    bool v3; // 0x10004c2e
    *v2 = 2 * *v2 | (char)v3;
    char * v4 = (char *)(v1 - 0x1624f000); // 0x10004c33
    *v4 = 2 * *v4;
    int32_t v5; // 0x10004c2e
    __asm_arpl(*(int16_t *)(v1 + 0xa0ccda), (int16_t)v5);
    int32_t v6; // 0x10004c2e
    char * v7 = (char *)(v6 - 0x4f1aa220); // 0x10004c44
    *v7 = *v7 + (char)v5;
    int32_t v8; // 0x10004c2e
    char * v9 = (char *)(v8 - 0x17af17ba); // 0x10004c4a
    unsigned char v10 = *v9; // 0x10004c4a
    *v9 = v10 / 2 | 128 * v10;
    int32_t v11; // 0x10004c2e
    float64_t v12 = *(float64_t *)&v11; // 0x10004c50
    unsigned char v13 = *(char *)-0x223caf7f + (char)v1; // 0x10004c52
    int32_t v14; // 0x10004c2e
    uint32_t v15 = v14 - 1; // 0x10004c58
    int32_t v16 = v1 & -256 | (int32_t)v13; // 0x10004c58
    if (v15 != 0 == v13 == 0) {
        v16 = function_10004c0f();
    }
    // 0x10004c5a
    float80_t v17; // 0x10004c2e
    float80_t v18 = v17 + (float80_t)v12; // 0x10004c50
    uint32_t v19 = v16;
    char * v20 = (char *)((int32_t)(int64_t)v12 + 0x2836b2c0); // 0x10004c5a
    char v21 = v19 / 256; // 0x10004c5a
    *v20 = *v20 ^ v21;
    __asm_arpl(*(int16_t *)v19, (int16_t)v19);
    char * v22 = (char *)(v6 - 9); // 0x10004c62
    *v22 = *v22 + v21;
    int32_t v23 = v19 + 157; // 0x10004c65
    int32_t v24 = v19 & -256; // 0x10004c65
    uint32_t v25 = v23 & 255 | v24; // 0x10004c65
    char * v26 = (char *)v25; // 0x10004c67
    unsigned char v27 = *v26; // 0x10004c67
    char v28 = v11; // 0x10004c67
    unsigned char v29 = v27 + v28; // 0x10004c67
    *v26 = v29;
    int32_t * v30 = (int32_t *)(v8 + 1); // 0x10004c69
    __asm_int(228);
    if (v29 >= 0) {
        bool v31 = v29 < v27; // 0x10004c6e
        if (((v29 ^ v27) & (v29 ^ v28)) >= 0 != v29 != 0) {
            // 0x10004c70
            int32_t v32; // 0x10004c2e
            __asm_arpl(*(int16_t *)&v11, (int16_t)v32);
            v31 = v25 < 0xb8d55c01;
        }
        // 0x10004c77
        *(float80_t *)(v14 + (int32_t)&g9 - 1) = __asm_fbstp(v18);
        char v33 = *(char *)&v6; // 0x10004c7d
        *(char *)v6 = (char)v31 + (char)(v15 / 256) + v33;
        char * v34 = (char *)(v19 + 58 & 255 | v24); // 0x10004c81
        *v34 = *v34 + (char)v11;
        return __asm_hlt();
    }
    char * v35 = (char *)(v5 + 104); // 0x10004c8c
    *v35 = *v35 + (char)(v29 < v27) + (char)v11;
    unsigned char v36 = *v26; // 0x10004c8f
    unsigned char v37 = v36 + (char)v23; // 0x10004c8f
    *v26 = v37;
    int32_t v38 = v11;
    *(int32_t *)v38 = v38 + v25 + (int32_t)(v37 < v36);
    char * v39 = (char *)(v14 + 0x70620fff); // 0x10004c95
    *v39 = *v39 | v21;
    __asm_out_6((int16_t)v11, v25);
    if (v15 != 0) {
        // 0x10004ca1
        return function_804ec438();
    }
    int32_t v40 = *(int32_t *)(v8 + 0x466b); // 0x10004d21
    uint32_t v41 = *(int32_t *)(v8 + 0x4673); // 0x10004d21
    int32_t v42 = *(int32_t *)(v8 + 0x4677); // 0x10004d21
    uint32_t v43 = *(int32_t *)(v8 + 0x467b); // 0x10004d21
    int32_t * v44 = (int32_t *)(v8 + 0x467f); // 0x10004d21
    int32_t v45 = *v44; // 0x10004d21
    v6 = *(int32_t *)(v8 + 0x4667);
    v11 = v42;
    int32_t * v46 = (int32_t *)(v42 + 0x2fe99ea9); // 0x10004d22
    uint32_t v47 = *v46; // 0x10004d22
    *v46 = v47 / 2048 | 0x200000 * v47;
    int32_t v48 = v45 & -256 | 160; // 0x10004d29
    char * v49 = (char *)v48; // 0x10004d2b
    *v49 = *v49 + (char)v42;
    int32_t v50 = v48 - v41; // 0x10004d2f
    bool v51 = v48 < v41; // 0x10004d31
    bool v52 = (llvm_ctpop_i8((char)v50) & 1) == 0; // 0x10004d31
    bool v53 = -((v41 & 15)) > 15; // 0x10004d31
    bool v54 = v50 < 0; // 0x10004d31
    bool v55 = ((v50 ^ v45) & (v45 ^ v41)) < 0; // 0x10004d31
    int32_t result = v48; // 0x10004d31
    int32_t v56 = v41; // 0x10004d31
    int32_t v57 = v8 + 0x4683; // 0x10004d31
    if (v50 != 0) {
        // 0x10004d33
        *(char *)(v48 + 0x53a9d5bd) = (char)v43;
        int32_t * v58 = (int32_t *)(v41 + 52 + v11); // 0x10004d39
        int32_t v59 = *v58 | v43; // 0x10004d39
        char v60 = llvm_ctpop_i8((char)v59); // 0x10004d39
        *v58 = v59;
        *v44 = -49;
        v51 = v18 != v18 || 0.0L != 0.0L;
        v52 = v18 != v18 || 0.0L != 0.0L;
        v53 = false;
        v54 = v59 < 0;
        v55 = false;
        result = v48 & -0xff60 | 0x4000 * (int32_t)(v59 == 0) | 0x8000 * (int32_t)(v59 < 0) | 1024 * (int32_t)((v60 & 1) == 0) | 512;
        v56 = 0x36e8fbd;
        v57 = v8 + 0x4681;
    }
    // 0x10004d4a
    if (v54 == v55) {
        if (v55) {
            // 0x10004cef
            return result;
        }
        char * v61 = (char *)result; // 0x10004d4e
        *v61 = *v61 + (char)v11;
        *(int32_t *)(v57 - 4) = v48;
        return result;
    }
    int32_t v62 = result & -0xff01 | 256 * (4 * (int32_t)v52 | (int32_t)v51 | 16 * (int32_t)v53 | 128 * (int32_t)v54) | 0x4200; // 0x10004d61
    int32_t * v63 = (int32_t *)(v62 + 12); // 0x10004d62
    uint32_t v64 = *v63; // 0x10004d62
    *v63 = v64 / 8 | 0x20000000 * v64;
    char * v65 = (char *)v62; // 0x10004d66
    unsigned char v66 = *v65; // 0x10004d66
    unsigned char v67 = v66 + (char)v11; // 0x10004d66
    *v65 = v67;
    *(int32_t *)v57 = v40;
    int32_t v68 = v57 & -256 | (int32_t)*(char *)-0x3f7af000; // 0x10004d70
    if (v67 == 0) {
        v68 = function_faf648fe();
    }
    uint32_t v69 = *(int32_t *)(v56 + 45) + v43; // 0x10004d76
    uint32_t v70 = v69 + (int32_t)(v67 < v66); // 0x10004d76
    bool v71 = v67 < v66 ? v70 <= v43 : v69 < v43; // 0x10004d76
    int32_t v72 = __asm_bound(*(int64_t *)v68); // 0x10004d79
    char * v73 = (char *)(v72 - 0x25679f62); // 0x10004d7b
    *v73 = *v73 + (char)(v56 / 256) + (char)v71;
    char v74 = __asm_in_5(-96); // 0x10004d81
    int32_t v75 = v72 & -256 | (int32_t)v74; // 0x10004d81
    char * v76 = (char *)v75; // 0x10004d83
    unsigned char v77 = *v76; // 0x10004d83
    unsigned char v78 = v77 + (char)v11; // 0x10004d83
    *v76 = v78;
    int32_t result2 = v75 & -256 | (int32_t)(v74 - 95 + (v78 < v77 ? 98 : 99)); // 0x10004d87
    *(int32_t *)(v62 - 4) = result2;
    *(int32_t *)(v62 - 8) = v70;
    *(int32_t *)(v62 - 12) = v11;
    *(int32_t *)(v62 - 16) = v56;
    *(int32_t *)(v62 - 20) = v62;
    *(int32_t *)(v62 - 24) = v40;
    *(int32_t *)(v62 - 28) = v6;
    *(int32_t *)(v62 - 32) = 0x1835ffd3;
    char * v79 = (char *)result2; // 0x10004d8f
    *v79 = *v79 + (char)v11;
    return result2;
}

// Address range: 0x10004d92 - 0x10004e51
int32_t function_10004d92(int16_t a1, int32_t a2) {
    // 0x10004d92
    int32_t v1; // 0x10004d92
    unsigned char v2 = (char)v1 & 31; // 0x10004d99
    int32_t v3; // 0x10004d92
    if (v2 != 0) {
        char * v4 = (char *)(v3 - 27); // 0x10004d99
        unsigned char v5 = *v4; // 0x10004d99
        bool v6; // 0x10004d92
        *v4 = v5 >> v2 | (char)v6 << 8 - v2 | (char)((int16_t)v5 << (int16_t)(9 - v2));
    }
    int32_t v7; // 0x10004d92
    char * v8 = (char *)(v7 + 0x14743160); // 0x10004d9c
    uint32_t v9; // 0x10004d92
    *v8 = *v8 & (char)(v9 / 256);
    *(char *)-0x24590000 = *(char *)-0x24590000 + 16;
    uint32_t v10; // 0x10004d92
    uint32_t v11 = v10 / 256; // 0x10004dad
    int32_t v12 = (512 * v11 & 0xfe00 | v10 & -0xff01) ^ v9; // 0x10004db4
    int32_t v13 = 2 * (char)v11 < (char)v11 ? -0x57485e4f : -0x57485e50; // 0x10004dbb
    uint16_t v14 = *(int16_t *)(v13 + 8 * v1) ^ (int16_t)v1; // 0x10004dbb
    int32_t v15 = v1 & -0x10000 | (int32_t)v14; // 0x10004dbb
    uint32_t v16 = __asm_sti(); // 0x10004dc5
    *(char *)v3 = __asm_insb((int16_t)v9);
    char * v17 = (char *)v12; // 0x10004dcd
    char v18 = *v17; // 0x10004dcd
    unsigned char v19 = (char)(v16 / 256); // 0x10004dcd
    *v17 = v18 + v19;
    int32_t v20; // 0x10004d92
    unsigned char v21 = *(char *)&v20; // 0x10004dd0
    unsigned char v22 = v21 + (char)v14; // 0x10004dd0
    unsigned char v23 = v22 + (char)(-1 - v18 < v19); // 0x10004dd0
    bool v24 = -1 - v18 < v19 ? v23 <= v21 : v22 < v21; // 0x10004dd0
    *(char *)v20 = v23;
    int32_t * v25 = (int32_t *)(v9 - 0x6690d4eb + v15); // 0x10004dd2
    *v25 = v16 & -256 | (int32_t)*(char *)0x35398040;
    unsigned char v26 = *v17; // 0x10004dd9
    uint32_t v27 = *v25 / 256; // 0x10004dd9
    char v28 = v24; // 0x10004dd9
    unsigned char v29 = (char)v27 + v28; // 0x10004dd9
    char v30 = v26 - v29; // 0x10004dd9
    bool v31 = v24 ? v29 != -1 | v26 < v30 - v28 : v26 < v29; // 0x10004dd9
    *v17 = v30;
    int32_t v32 = v9 - 1; // 0x10004dde
    char * v33 = (char *)(v3 + (int32_t)&g2); // 0x10004ddf
    *v33 = *v33 ^ (char)(v27 + (int32_t)(v14 / 256) + (int32_t)v31);
    int32_t v34 = v3 | a2; // 0x10004de5
    int32_t v35 = unknown_afe14f8(); // 0x10004def
    *(int32_t *)-0x72efff64 = v12;
    char v36 = *(char *)&v20;
    __asm_outsb((int16_t)v32, v36);
    __asm_fldenv(*(int224_t *)(v34 - 102));
    char v37 = __readfsbyte(-0x3e8f000); // 0x10004dfd
    *(char *)v34 = v36;
    int32_t v38 = v12 - 1; // 0x10004e06
    char * v39 = (char *)(0x10000 * v35 / 0x10000 & -256 | (int32_t)(v37 | 99)); // 0x10004e09
    char v40 = v32; // 0x10004e09
    *v39 = *v39 + v40;
    int32_t v41 = *(int32_t *)(function_10003620() + 8 * v38); // 0x10004e10
    int32_t * v42 = (int32_t *)(v41 + 2 * v15); // 0x10004e18
    *v42 = *v42 & v38;
    char * v43 = (char *)unknown_4aab5bcf(); // 0x10004e2a
    *v43 = *v43 + v40;
    int32_t v44 = a2 - 3 - *(int32_t *)(v12 + 0x6310733e + v15); // 0x10004e2c
    *(int32_t *)-0x72efff68 = v44;
    bool v45; // 0x10004d92
    *(int32_t *)-0x72efff6c = v20 + (v45 ? -1 : 1);
    *(int32_t *)-0x72efff70 = v41;
    *(int32_t *)-0x72efff74 = -20;
    uint32_t v46 = v12 - 2; // 0x10004e34
    char * v47 = (char *)v44; // 0x10004e35
    *v47 = *v47 + v40;
    int32_t v48 = v46 / 256 + v32; // 0x10004e37
    uint32_t v49 = v44 ^ 0x1890cf9a; // 0x10004e3a
    __asm_arpl(*(int16_t *)v49, (int16_t)v49);
    char * v50 = (char *)((v48 & 255 | v32 & -256) + 0xa0b8ef); // 0x10004e42
    char v51 = *v50; // 0x10004e42
    unsigned char v52 = (char)v49; // 0x10004e42
    *v50 = v51 + v52;
    unsigned char v53 = (char)v46; // 0x10004e48
    unsigned char v54 = (char)(v49 / 256) + v53; // 0x10004e48
    bool v55 = -1 - v51 < v52 ? v54 + (char)(-1 - v51 < v52) <= v53 : v54 < v53; // 0x10004e48
    char * v56 = (char *)(v49 + 99 + (int32_t)v55 & 255 | v49 & -256); // 0x10004e4c
    *v56 = *v56 + (char)v48;
    return function_10004e58();
}

// Address range: 0x10004e56 - 0x10004e58
int32_t function_10004e56(void) {
    // 0x10004e56
    int32_t v1; // 0x10004e56
    int32_t result; // 0x10004e56
    *(char *)result = (char)result + (char)v1;
    return result;
}

// Address range: 0x10004e58 - 0x10004e71
int32_t function_10004e58(void) {
    // 0x10004e58
    int32_t v1; // 0x10004e58
    return function_f88b5e19(v1);
}

// Address range: 0x10004e7d - 0x10004eb1
int32_t function_10004e7d(int32_t a1) {
    // 0x10004e7d
    int32_t v1; // 0x10004e7d
    int32_t v2; // 0x10004e7d
    *(char *)v1 = (char)v2;
    int32_t v3; // 0x10004e7d
    bool v4; // 0x10004e7d
    if (v3 != 1 != v4) {
        // 0x10004e80
        int32_t result; // 0x10004e7d
        return result;
    }
    // 0x10004e8d
    bool v5; // 0x10004e7d
    int32_t v6 = (v5 ? -1 : 1) + v1; // 0x10004e7d
    int32_t * v7 = (int32_t *)v6; // 0x10004e8d
    bool v8; // 0x10004e7d
    *v7 = 1 - v3 + (int32_t)v8 + *v7;
    int32_t v9 = v3 - 2; // 0x10004e95
    unsigned char v10 = (char)v9 & 31; // 0x10004e99
    if (v10 != 0) {
        int32_t v11; // 0x10004e7d
        char * v12 = (char *)(v11 - 19); // 0x10004e99
        *v12 = *v12 >> v10;
    }
    int32_t v13 = __asm_int1(); // 0x10004e9e
    *(int32_t *)0x1e03a4af = v9;
    unsigned char v14 = (char)v13; // 0x10004ea7
    char v15 = v14 > 153 ? v14 - 96 : v14;
    char v16 = (v6 & 15) == 15 | (v14 & 14) > 9 ? (v14 > 153 ? -102 : -6) + v14 : v15;
    int32_t result2 = __asm_in_2(72); // 0x10004eaf
    if (v16 < 0 != (v6 + 1 & (v6 ^ -0x80000000)) < 0) {
        result2 = function_10004e7d((int32_t)&g22);
    }
    // 0x10004e80
    return result2;
}

// Address range: 0x10004eda - 0x10004edb
int32_t function_10004eda(void) {
    // 0x10004eda
    int32_t result; // 0x10004eda
    return result;
}

// Address range: 0x10004edf - 0x10004ee6
int32_t function_10004edf(void) {
    // 0x10004edf
    return unknown_b9dc48();
}

// Address range: 0x10004f05 - 0x10004f17
int32_t function_10004f05(int32_t a1) {
    // 0x10004f05
    __asm_sti();
    int16_t v1; // 0x10004f05
    int32_t v2 = unknown_d36eca05(v1); // 0x10004f06
    int32_t v3 = v2; // 0x10004f11
    if (v2 == 0) {
        v3 = function_10004eda();
    }
    int32_t v4 = v3;
    int32_t v5 = (v4 & 14) > 9 ? v4 + 6 : v4; // 0x10004f13
    return v5 & 15 | v4 & -0x10000 | 256 * (int32_t)((v4 & 14) > 9) + v4 & 0xff00;
}

// Address range: 0x10004fb4 - 0x10004fb5
int32_t function_10004fb4(void) {
    // 0x10004fb4
    int32_t result; // 0x10004fb4
    return result;
}

// Address range: 0x10004fc6 - 0x10004fc9
int32_t function_10004fc6(int32_t a1) {
    // 0x10004fc6
    int32_t result; // 0x10004fc6
    return result;
}

// Address range: 0x10004fc9 - 0x10005015
int32_t function_10004fc9(int32_t a1, int32_t a2) {
    // 0x10004fc9
    int32_t v1; // 0x10004fc9
    int32_t v2 = v1 + 1; // 0x10004fc9
    int32_t v3; // 0x10004fc9
    int32_t v4; // 0x10004fc9
    if ((v2 || v3) != v4) {
        // 0x10004fd0
        int32_t v5; // 0x10004fc9
        return function_d4eaf4e8(v5);
    }
    int32_t * v6 = (int32_t *)v2; // 0x10005002
    int32_t v7 = *v6; // 0x10005002
    *v6 = v7 / 0x4000;
    if (v7 >= 0 == v7 >= 0x4000) {
        function_10004fb4();
    }
    // 0x10005007
    return unknown_d77d222();
}

// Address range: 0x10005022 - 0x10005030
int32_t function_10005022(void) {
    // 0x10005022
    int32_t v1; // 0x10005022
    char * v2 = (char *)(v1 - 0x2f1701bc); // 0x10005022
    int32_t v3; // 0x10005022
    bool v4; // 0x10005022
    *v2 = *v2 + (char)v3 + (char)v4;
    int32_t v5; // 0x10005022
    return v5 & -256 | (int32_t)((char)v5 - *(char *)0x5b5e5f7f);
}

// Address range: 0x10005030 - 0x10005056
int32_t function_10005030(void) {
    // 0x10005030
    int32_t v1; // 0x10005030
    int32_t * v2 = (int32_t *)(v1 + 59); // 0x10005034
    *v2 = *v2 & -0x5dd8a52d;
    int32_t v3; // 0x10005030
    __asm_in_3((int16_t)v3);
    int32_t v4; // 0x10005030
    int32_t * v5 = (int32_t *)((v4 & -0xff01 | v3 & 0xff00) - 0x4b3cdd48); // 0x1000503c
    *v5 = *v5 - 0x3110801;
    int32_t v6; // bp-40, 0x10005030
    return &v6;
}

// Address range: 0x10005052 - 0x10005053
int32_t function_10005052(void) {
    // 0x10005052
    int32_t result; // 0x10005052
    return result;
}

// Address range: 0x10005057 - 0x10005088
int32_t function_10005057(void) {
    // 0x10005057
    int32_t v1; // 0x10005057
    char v2 = v1; // 0x10005057
    unsigned char v3 = v2 & 31; // 0x10005057
    if (v3 != 0) {
        int32_t v4; // 0x10005057
        char * v5 = (char *)(v1 - 0x6a766f4d + 2 * v4); // 0x10005057
        *v5 = *v5 >> v3;
    }
    int32_t v6; // 0x10005057
    int32_t v7 = v1 & 0xff00 ^ v6; // 0x1000505e
    __asm_arpl(*(int16_t *)(v7 + 0x700b16b0), (int16_t)v1);
    int32_t v8 = v7 & -256 | v6 + 87 & 255; // 0x1000506c
    *(char *)(*(int32_t *)(v8 + 12) - 11) = v2;
    int32_t * v9 = (int32_t *)(v8 - 41); // 0x10005074
    *v9 = *v9 & 35;
    int32_t * v10 = (int32_t *)(v1 + 39); // 0x1000507d
    *v10 = *v10 - 48;
    return function_887ff032();
}

// Address range: 0x1000508a - 0x100050b5
int32_t function_1000508a(int32_t a1, int32_t a2) {
    int32_t v1 = -95; // bp-4, 0x1000508a
    int32_t v2; // 0x1000508a
    *(int32_t *)(v2 - 0x562b158a) = a1;
    unsigned char v3 = (char)v2; // 0x10005098
    bool v4 = v3 > 153 | &v1 > (int32_t *)-14;
    int32_t v5; // 0x1000508a
    if ((v3 & 14) > 9 || ((int32_t)&v1 & 12) != 0) {
        v5 = (v4 ? 102 : 6) + v2 & 255 | v2 & -256;
    } else {
        v5 = (v4 ? v2 + 96 : v2) & 255 | v2 & -256;
    }
    int32_t v6; // 0x1000508a
    unsigned char v7 = *(char *)(v6 - 0x4eefb4c5); // 0x1000509a
    int32_t v8; // 0x1000508a
    uint32_t v9; // 0x1000508a
    *(char *)v8 = __asm_insb((int16_t)v9);
    int32_t v10; // 0x1000508a
    int32_t v11; // 0x1000508a
    *(int32_t *)v11 = v11 + v10;
    return v5 - (v7 < (char)(v9 / 256) ? -0x14dd0e75 : -0x14dd0e76) | 0xa948d70;
}

// Address range: 0x100050b6 - 0x100050d7
int32_t function_100050b6(int32_t a1, int32_t a2) {
    // 0x100050b6
    int32_t v1; // 0x100050b6
    char * v2 = (char *)(0x10000 * (v1 + 35 & 255 | v1 & 0xff00) / 0x10000 - 0x534a9114); // 0x100050be
    uint32_t v3; // 0x100050b6
    *v2 = *v2 ^ (char)(v3 / 256);
    int32_t result; // 0x100050b6
    int32_t * v4 = (int32_t *)(result + 4); // 0x100050ca
    *v4 = *v4 - 117;
    return result;
}

// Address range: 0x100050d7 - 0x10005195
int32_t function_100050d7(int32_t a1) {
    // 0x100050d7
    int32_t v1; // 0x100050d7
    uint32_t v2; // 0x100050d7
    int32_t result; // 0x100050d7
    bool v3; // 0x100050d7
    if (v3) {
        // 0x100050df
        int32_t v4; // 0x100050d7
        *(char *)v4 = __asm_insb((int16_t)v2);
        int32_t v5; // 0x100050d7
        int32_t * v6 = (int32_t *)(v4 + 0x3e0308f6 + 8 * v5); // 0x100050e0
        *v6 = (int32_t)v3 - v1 + *v6;
        return result;
    }
    // 0x10005106
    bool v7; // 0x100050d7
    bool v8 = (uint32_t)(result & 14) > 9 | v7; // 0x10005106
    int32_t v9 = (v8 ? result + 6 : result) & 15; // 0x10005106
    int32_t v10 = 256 * (int32_t)v8 + result & 0xff00 | result & -0x10000;
    int32_t v11; // 0x100050d7
    if (v8 || (char)v9 > 9) {
        int32_t v12 = v9 + (v8 ? 102 : 6); // 0x10005107
        int32_t v13 = v10 | v12; // 0x10005107
        v11 = v13;
        if (v8) {
            int32_t * v14 = (int32_t *)(v13 + 35); // 0x10005114
            *v14 = *v14 & 0x3e55dadd;
            return v10 | v12 + 205 & 255;
        }
    } else {
        // .thread
        v11 = v10 | v9;
    }
    // 0x1000516d
    int32_t v15; // 0x100050d7
    unsigned char v16 = *(char *)&v15; // 0x10005174
    *(char *)v15 = 64 * v16 | 32 * (char)((v1 & 0x40000) != 0) | v16 / 8;
    *(char *)-0x60c777d9 = (char)v11;
    __asm_out_6((int16_t)v2, v11);
    int32_t v17 = (v16 & 4) == 0 ? 0x2d76e8bc : 0x2d76e8bd; // 0x10005180
    uint32_t v18 = (v11 & -256 | (int32_t)__asm_in_5(-57)) - v17; // 0x10005180
    uint32_t v19 = *(int32_t *)(v18 + 0x783d2bc8); // 0x10005185
    return (0x100000000 * (int64_t)v2 | (int64_t)v18) / (int64_t)v19;
}

// Address range: 0x100051a5 - 0x100051a7
int32_t function_100051a5(int32_t a1) {
    // 0x100051a5
    int32_t v1; // 0x100051a5
    unsigned char v2 = (char)v1; // 0x100051a5
    bool v3; // 0x100051a5
    bool v4 = v2 > 153 | v3;
    int32_t result; // 0x100051a5
    bool v5; // 0x100051a5
    if (v5 || (v2 & 14) > 9) {
        result = (v4 ? 102 : 6) + v1 & 255 | v1 & -256;
    } else {
        result = (v4 ? v1 + 96 : v1) & 255 | v1 & -256;
    }
    return result;
}

// Address range: 0x100051cc - 0x10005315
int32_t function_100051cc(void) {
    // 0x100051cc
    int32_t v1; // 0x100051cc
    uint32_t v2; // 0x100051cc
    int32_t v3 = v1 - v2; // 0x100051d4
    uint32_t v4; // 0x100051cc
    char * v5 = (char *)(v4 - 0x12bcd351); // 0x100051d6
    uint32_t v6; // 0x100051cc
    char v7 = *v5 & (char)(v6 / 256); // 0x100051d6
    *v5 = v7;
    int16_t v8 = v3; // 0x100051dd
    int32_t v9; // 0x100051cc
    *(int32_t *)v9 = __asm_insd(v8);
    bool v10; // 0x100051cc
    int32_t v11; // 0x100051cc
    int32_t v12; // 0x100051cc
    int32_t v13; // 0x100051cc
    int32_t v14; // 0x100051cc
    int32_t v15; // 0x100051cc
    int32_t * v16; // 0x100051cc
    if (v7 >= 0 == (v7 != 0)) {
        int32_t v17 = v3 & -256 | 118; // 0x10005202
        __asm_out_6((int16_t)v17, v9 | 193);
        int32_t v18 = v2 + v9; // 0x10005212
        v10 = v18 < v2;
        v14 = v17;
        v12 = v18;
        int32_t v19; // bp-4, 0x100051cc
        v16 = (int32_t *)((int32_t)&v19 - 4);
        v11 = *(int32_t *)(v2 - 0x1ebe46d5 + 2 * v2) + v4;
        v15 = -0x59b82e05;
    } else {
        int32_t * v20 = (int32_t *)(v2 + 71); // 0x100051e7
        uint32_t v21 = *v20; // 0x100051e7
        uint32_t v22 = v21 + v9; // 0x100051e7
        *v20 = v22;
        __asm_out_4(v8, (char)v9);
        *(int32_t *)v2 = (int32_t)(v22 < v21);
        *(char *)(v9 - 7) = (char)(v2 / 256);
        v10 = v2 < v4;
        v13 = v6 + 1;
        v14 = v3;
        v12 = v2 - v4;
        v16 = (int32_t *)0x3f3046c3;
        v15 = v9 - 0x59b82e05;
    }
    uint32_t v23 = v10 ? 0x148f87dd : 0x148f87dc; // 0x10005214
    int32_t v24 = v14 - v23; // 0x10005214
    bool v25 = v10 | v14 < v23; // 0x10005214
    uint32_t v26 = v9 - 1; // 0x1000521a
    int32_t v27 = __asm_in_3((int16_t)v24); // 0x1000521b
    uint32_t v28 = *(int32_t *)(v24 - 0x63fb9313) + v26; // 0x1000521c
    uint32_t v29 = v28 + (int32_t)v25; // 0x1000521c
    if (v29 == 0 || (v25 ? v29 <= v26 : v28 < v26)) {
        // 0x10005279
        return v27 + 1;
    }
    unsigned char v30 = (char)v13 & 31; // 0x1000528b
    if (v30 != 0) {
        char * v31 = (char *)v12; // 0x1000528b
        *v31 = *v31 << v30;
    }
    // 0x10005301
    *v16 = v11;
    *(char *)(v15 + 0x3427b82f) = (char)((v24 | v12) / 256);
    *(char *)v29 = *(char *)v15;
    return *(int32_t *)-0x430aa6e4 & -256 | (int32_t)*(char *)0x741d2bd4;
}

// Address range: 0x1000531e - 0x1000531f
int32_t function_1000531e(int32_t a1) {
    // 0x1000531e
    int32_t result; // 0x1000531e
    return result;
}

// Address range: 0x10005325 - 0x1000532a
int32_t function_10005325(int32_t a1) {
    // 0x10005325
    int32_t v1; // 0x10005325
    char * v2 = (char *)(v1 - 115); // 0x10005325
    uint32_t result; // 0x10005325
    *v2 = *v2 | (char)(result / 256);
    return result;
}

// Address range: 0x1000532c - 0x1000532d
int32_t function_1000532c(int32_t a1) {
    // 0x1000532c
    int32_t result; // 0x1000532c
    return result;
}

// Address range: 0x1000532f - 0x10005330
int32_t function_1000532f(void) {
    // 0x1000532f
    int32_t result; // 0x1000532f
    return result;
}

// Address range: 0x10005353 - 0x10005358
float80_t function_10005353(int32_t a1) {
    // 0x10005353
    int32_t v1; // 0x10005353
    float80_t v2; // 0x10005353
    return (float80_t)*(float64_t *)&v1 - v2;
}

// Address range: 0x1000535a - 0x100053f1
int32_t function_1000535a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x1000535a
    __asm_in_5(-22);
    bool v1; // 0x1000535a
    if (v1) {
        int32_t v2 = __asm_hlt(); // 0x100053e2
        int32_t v3; // 0x1000535a
        char v4 = *(char *)((v2 & 255) + (v3 & -0xff01 | 0xa500)); // 0x100053e5
        return v2 & -256 | (int32_t)(v4 & 43);
    }
    int32_t v5 = function_1000532f(); // 0x100053a4
    unsigned char v6 = (char)v5; // 0x100053a6
    bool v7; // 0x1000535a
    unsigned char v8 = v7 ? 94 : 93; // 0x100053a6
    unsigned char v9 = v6 - v8; // 0x100053a6
    bool v10 = v7 | v8 > v6; // 0x100053a6
    int32_t v11 = v5 & -256; // 0x100053a6
    unsigned char v12 = v9 + 126 + (char)v10; // 0x100053a8
    float80_t v13; // 0x1000535a
    *(float64_t *)(v11 | (int32_t)v12) = (float64_t)v13;
    return (v12 > 153 | (v10 ? v12 <= v9 : v9 > 129) ? 255 : 0) | v11;
}

// Address range: 0x100053f2 - 0x100053ff
int32_t function_100053f2(void) {
    // 0x100053f2
    return -0x750c74e4;
}

// Address range: 0x10005455 - 0x1000545a
int32_t function_10005455(void) {
    // 0x10005455
    return function_b39003fa();
}

// Address range: 0x1000545a - 0x10005466
int32_t function_1000545a(void) {
    // 0x1000545a
    return function_7ae8ac7b();
}

// Address range: 0x1000546f - 0x1000551a
int32_t function_1000546f(int32_t a1) {
    // 0x1000546f
    int32_t v1; // 0x1000546f
    char * v2 = (char *)(v1 - 0xff9018c); // 0x1000546f
    char v3 = *v2 - 1; // 0x1000546f
    *v2 = v3;
    int32_t v4; // 0x1000546f
    if (v3 != 0) {
        int32_t v5 = v1 - 75; // 0x100054df
        __writefsbyte(v5, __readfsbyte(v5) & -93);
        return v4 + 1 | 0x5c8dcb27;
    }
    // 0x10005479
    int32_t v6; // 0x1000546f
    int32_t v7 = v6 - 1; // 0x10005475
    unsigned char v8 = (char)v7 & 31; // 0x10005479
    int32_t v9; // 0x1000546f
    if (v8 != 0) {
        int32_t v10; // 0x1000546f
        char * v11 = (char *)(v9 - 111 + 2 * v10); // 0x10005479
        *v11 = *v11 >> v8;
    }
    int32_t v12; // 0x1000546f
    __readgsbyte(v12 + 0x76f032ef + 8 * v7);
    int32_t v13; // 0x1000546f
    __asm_outsd((int16_t)v4, v13);
    *(int864_t *)(v9 - 76) = (int864_t)__asm_fnsave();
    int32_t v14 = __asm_in_3((int16_t)(__asm_int3() >> 31)); // 0x100054ab
    return v14 + 90 + (int32_t)(*(char *)-0x6f77a464 < 45) & 255 | v14 & -256;
}

// Address range: 0x1000551a - 0x100055b3
int32_t function_1000551a(int32_t a1) {
    // 0x1000551a
    int32_t v1; // 0x1000551a
    bool v2; // 0x1000551a
    int32_t v3 = (v2 ? -4 : 4) + v1; // 0x1000551a
    uint32_t v4; // 0x1000551a
    unsigned char v5 = (char)v4;
    unsigned char v6 = (char)(v4 / 256) + v5; // 0x10005595
    *(char *)v4 = v6;
    __asm_int3();
    int32_t v7 = __asm_iretd(); // 0x1000559e
    int32_t v8; // 0x1000551a
    __asm_out_4((int16_t)v8, (char)v7);
    char * v9 = (char *)(v3 + 13); // 0x100055a0
    *v9 = *v9 + (v6 < v5 ? -84 : -85);
    int32_t result = v7 & 0x629a6c65; // 0x100055a5
    int32_t v10; // 0x1000551a
    if (v10 != 1 != (result == 0)) {
        // 0x100055ac
        *(int32_t *)v3 = __asm_insd((int16_t)v8);
        return result;
    }
    // 0x10005549
    int32_t v11; // 0x1000551a
    int32_t * v12 = (int32_t *)(v11 + 12); // 0x10005549
    *v12 = *v12 - 0xb14e3c1;
    int16_t v13 = *(int16_t *)&v8; // 0x10005550
    float80_t v14; // 0x1000551a
    *(int64_t *)(v11 + 0x65dc26f8) = (int64_t)(v14 + (float80_t)v13);
    int16_t v15; // 0x1000551a
    *(char *)a1 = (char)unknown_17b84747(v15);
    return function_850a14c6();
}

// Address range: 0x100055db - 0x100055dc
int32_t function_100055db(void) {
    // 0x100055db
    int32_t result; // 0x100055db
    return result;
}

// Address range: 0x10005606 - 0x10005608
int32_t function_10005606(void) {
    // 0x10005606
    return function_10005609((int32_t)&g22, (int32_t)&g22);
}

// Address range: 0x10005608 - 0x10005609
int32_t function_10005608(void) {
    // 0x10005608
    int32_t result; // 0x10005608
    return result;
}

// Address range: 0x10005609 - 0x100056d3
int32_t function_10005609(int32_t a1, int32_t a2) {
    // 0x10005609
    int32_t v1; // 0x10005609
    int32_t v2 = v1 & -0x73b62031; // 0x1000560f
    int32_t v3; // 0x10005609
    if (v2 >= 0 == (v2 != 0)) {
        v3 = function_100055db();
    }
    int32_t v4 = v3 & -256 | (int32_t)*(char *)-0x4745925b; // 0x10005616
    bool v5; // 0x10005609
    int32_t v6 = v5 ? -4 : 4; // 0x1000561b
    int32_t v7; // 0x10005609
    int32_t v8; // 0x10005609
    char v9 = *(char *)(v7 - 0x393dbb6c + v6 + v4) & (char)v8; // 0x1000561c
    bool v10 = false; // 0x10005623
    int32_t result = v4; // 0x10005623
    if (v9 < 1) {
        unsigned char v11 = (char)result; // 0x1000562d
        unsigned char v12 = v10 ? -118 : -119; // 0x1000562d
        unsigned char v13 = v11 - v12; // 0x1000562d
        result = result & -256 | (int32_t)v13;
        v10 |= v12 > v11;
        while (v13 != 0) {
            // 0x1000562d
            v11 = (char)result;
            v12 = v10 ? -118 : -119;
            v13 = v11 - v12;
            result = result & -256 | (int32_t)v13;
            v10 |= v12 > v11;
        }
        // 0x10005631
        return result;
    }
    unsigned char v14 = v9 & 31; // 0x10005644
    bool v15 = a2 == -1; // 0x10005644
    if (v14 != 0) {
        uint32_t v16; // 0x10005609
        v15 = (char)(v16 / 256) << v14 == 0;
    }
    // 0x10005646
    int32_t v17; // 0x10005609
    int32_t v18 = v6 + v17; // 0x1000561b
    int32_t v19 = v8 & -0x10000 | (int32_t)v9 | 1280;
    int32_t v20 = v19 - 1; // 0x10005646
    while (v20 != 0 == v15) {
        // 0x10005646
        v19 = v20;
        v20 = v19 - 1;
    }
    int32_t v21 = *(int32_t *)-0x7407a2f7; // 0x1000564e
    int32_t * v22 = (int32_t *)a2; // 0x10005654
    uint32_t v23 = *v22; // 0x10005654
    *v22 = v23 + 37;
    char v24 = *(char *)-0x637201ba; // 0x10005658
    *(char *)-0x637201ba = v24 - 125 + (char)(v23 < 0xffffffdb);
    int32_t v25 = *(int32_t *)(v21 - 4); // 0x1000566e
    int32_t v26 = __asm_int1(); // 0x10005674
    int32_t v27 = *(int32_t *)(v21 - 8) + v19; // 0x10005677
    *(int32_t *)0x3129fd0f = 39;
    char * v28 = (char *)(v18 + 71); // 0x1000567a
    *v28 = *v28 - (char)v27;
    int32_t v29 = v18 - 1; // 0x1000567d
    __asm_arpl(*(int16_t *)(v21 + 0x1110a971), -753);
    uint32_t v30 = 0x10000 * v26 / 0x10000 + v25 | v27; // 0x10005694
    if (v27 == 1) {
        // 0x10005699
        *(int32_t *)0x1026c794 = v25;
        __asm_out_6((int16_t)v25, v30);
        int32_t v31 = v30 ^ -0x415424f2; // 0x100056a5
        char * v32 = (char *)(*(int32_t *)(v31 + 12) | v29); // 0x100056b3
        *v32 = 2 * *v32;
        float80_t v33; // 0x10005609
        float80_t v34; // 0x10005609
        __asm_fstp(v33, v34);
        *(int32_t *)(v25 + 0x6faf) = v25;
        *(int32_t *)0x36296271 = *(int32_t *)0x36296271 / 2;
        return v31 & -256 | 129;
    }
    unsigned char v35 = *(char *)v29; // 0x10005696
    unsigned char v36 = *(char *)(v27 ^ 0x4b16 ^ *(int32_t *)v25); // 0x10005696
    unsigned char v37 = (char)v25; // 0x10005638
    bool v38 = v37 > 153 | v35 < v36;
    int32_t result2; // 0x10005609
    if ((v37 & 14) > 9 || (v35 & 15) - (v36 & 15) > 15) {
        result2 = (v38 ? 102 : 6) + v25 & 255 | v25 & -256;
    } else {
        result2 = (v38 ? v25 + 96 : v25) & 255 | v25 & -256;
    }
    *(char *)(v30 - 127) = (char)(v30 / 256);
    return result2;
}

// Address range: 0x100056d5 - 0x100056da
int32_t function_100056d5(void) {
    // 0x100056d5
    return function_e05061f4();
}

// Address range: 0x100056de - 0x100056f3
int32_t function_100056de(int32_t a1) {
    uint32_t v1 = __asm_iretd(); // 0x100056de
    bool v2; // 0x100056de
    uint32_t v3 = v1 + (v2 ? -0x700b1f63 : -0x700b1f64); // 0x100056e0
    int32_t v4 = v3 + 101 + (int32_t)(v2 ? v3 <= v1 : v1 > 0x700b1f63); // 0x100056e5
    int32_t v5; // 0x100056de
    *(int32_t *)v5 = v4 & 255 | v3 & -256;
    int32_t v6; // 0x100056de
    int32_t v7; // 0x100056de
    *(char *)(4 * v7 + v6) = (char)v4;
    return __asm_iretd();
}

// Address range: 0x100056f3 - 0x100056f5
int32_t function_100056f3(void) {
    // 0x100056f3
    return function_100056f8();
}

// Address range: 0x100056f5 - 0x100056f8
int32_t function_100056f5(void) {
    // 0x100056f5
    int32_t v1; // 0x100056f5
    unsigned char v2 = (char)v1; // 0x100056f5
    return (v2 < 202 ? v1 : v1 + 54) & 255 | v1 & -0x10000 | 256 * (int32_t)(v2 > 201);
}

// Address range: 0x100056f8 - 0x1000570c
int32_t function_100056f8(void) {
    // 0x100056f8
    __asm_wait();
    int32_t v1; // 0x100056f8
    int32_t v2; // 0x100056f8
    bool v3; // 0x100056f8
    __asm_outsb((int16_t)v2, *(char *)(v1 + 1 + (v3 ? -4 : 4)));
    return function_9b59eb7c();
}

// Address range: 0x1000570f - 0x10005733
int32_t function_1000570f(int32_t a1) {
    // 0x1000570f
    int32_t v1; // 0x1000570f
    unsigned char v2 = (char)v1 - 63; // 0x1000570f
    while (v2 == 0) {
        // continue -> 0x10005731
    }
    // 0x10005733
    return v1 & -256 | (int32_t)v2;
}

// Address range: 0x10005734 - 0x10005768
int32_t function_10005734(int32_t a1) {
    // 0x10005734
    int32_t v1; // 0x10005734
    int16_t v2 = v1; // 0x10005738
    int32_t v3 = __asm_insd(v2); // 0x10005738
    int32_t v4; // 0x10005734
    int32_t * v5 = (int32_t *)v4; // 0x10005738
    *v5 = v3;
    *v5 = __asm_insd(v2);
    char * v6 = (char *)(*(int32_t *)(a1 + 32) - 0x45f2a6bc); // 0x1000575e
    *v6 = *v6 ^ (char)*(int32_t *)(a1 + 24);
    return *(int32_t *)(a1 + 36);
}

// Address range: 0x10005772 - 0x10005773
int32_t function_10005772(void) {
    // 0x10005772
    int32_t result; // 0x10005772
    return result;
}

// Address range: 0x10005773 - 0x10005777
int32_t function_10005773(int32_t a1) {
    // 0x10005773
    int32_t v1; // 0x10005773
    int32_t v2; // 0x10005773
    return v2 & -256 | (int32_t)__asm_in((int16_t)v1);
}

// Address range: 0x1000578f - 0x10005792
int32_t function_1000578f(int32_t a1) {
    // 0x1000578f
    int32_t result; // 0x1000578f
    return result;
}

// Address range: 0x100057b0 - 0x100057c8
int32_t function_100057b0(void) {
    int32_t result = unknown_38c358ca(); // 0x100057b2
    int32_t v1; // 0x100057b0
    int32_t v2; // 0x100057b0
    *(int32_t *)v2 = (int32_t)&v1;
    int32_t v3; // 0x100057b0
    char * v4 = (char *)(v3 - 0xf0d1534); // 0x100057be
    int32_t v5; // 0x100057b0
    *v4 = *v4 + (char)v5;
    return result;
}

// Address range: 0x100057c8 - 0x100057df
int32_t function_100057c8(void) {
    // 0x100057c8
    int32_t v1; // 0x100057c8
    return 0x10000 * (v1 & 0xff00 | (int32_t)*(char *)-0x4771a451) / 0x10000;
}

// Address range: 0x100057df - 0x10005811
int32_t function_100057df(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x100057df
    int32_t v1; // 0x100057df
    unsigned char v2 = (char)v1; // 0x100057df
    bool v3; // 0x100057df
    char v4 = v3; // 0x100057df
    int32_t v5; // 0x100057df
    unsigned char v6 = v4 + (char)v5; // 0x100057df
    unsigned char v7 = v2 - v6; // 0x100057df
    bool v8 = v3 ? v6 != -1 | v7 - v4 > v2 : v6 > v2; // 0x100057df
    char v9 = *(char *)((v1 & -256 | (int32_t)v7) + 0x7b54c37a); // 0x100057e1
    int32_t v10; // 0x100057df
    int32_t * v11 = (int32_t *)(v10 - 17); // 0x100057e9
    int32_t v12; // 0x100057df
    *v11 = v12 & -256 | (int32_t)((char)v12 - 43 + v9 + (char)v8);
    int32_t v13 = *v11 | v10; // 0x100057ec
    int32_t v14; // 0x100057df
    int32_t v15; // 0x100057df
    if (v10 == 1 || v13 == 0) {
        // 0x100057f0
        int32_t v16; // 0x100057df
        int32_t v17 = v13 | v16; // 0x100057f0
        char * v18 = (char *)(v17 - 0x15301b31); // 0x100057fa
        uint32_t v19; // 0x100057df
        *v18 = *v18 - (v19 < 0xa1a781dc ? 116 : 115);
        v14 = v17 + v5;
        v15 = v19 + 0x5e587e24;
    }
    // 0x10005805
    __asm_arpl(*(int16_t *)v15, (int16_t)v14);
    return function_13cf632b();
}

// Address range: 0x10005811 - 0x10005818
int32_t function_10005811(void) {
    // 0x10005811
    int32_t result; // 0x10005811
    return result;
}

// Address range: 0x10005837 - 0x1000583d
int32_t function_10005837(void) {
    // 0x10005837
    return function_100058ad();
}

// Address range: 0x10005897 - 0x10005898
int32_t function_10005897(void) {
    // 0x10005897
    int32_t result; // 0x10005897
    return result;
}

// Address range: 0x100058a0 - 0x100058a8
int32_t function_100058a0(void) {
    // 0x100058a0
    int32_t result; // 0x100058a0
    return result;
}

// Address range: 0x100058ad - 0x100058c1
int32_t function_100058ad(void) {
    // 0x100058ad
    int32_t v1; // 0x100058ad
    int32_t v2; // 0x100058ad
    int32_t v3; // 0x100058ad
    int32_t v4; // 0x100058ad
    bool v5 = (v4 & 14) > 9 | (*(int32_t *)(v2 - 120) & 15) + ((v3 ^ v1) & 15) > 15; // 0x100058b6
    int32_t v6 = v5 ? v4 + 10 : v4; // 0x100058b6
    int32_t v7 = v5 ? -0x6ec70552 : -0x6ec70553; // 0x100058b7
    return (v6 & 15 | v4 & -0x10000 | 256 * (int32_t)v5 + v4 & 0xff00) + v7 | 0x21a63c7e;
}

// Address range: 0x100058e4 - 0x100058e5
int32_t function_100058e4(void) {
    // 0x100058e4
    int32_t result; // 0x100058e4
    return result;
}

// Address range: 0x100058e6 - 0x100058e8
int32_t function_100058e6(void) {
    // 0x100058e6
    return function_100058fe((int32_t)&g22);
}

// Address range: 0x100058e8 - 0x100058fe
int32_t function_100058e8(int32_t a1) {
    // 0x100058e8
    int32_t v1; // 0x100058e8
    char * v2 = (char *)(v1 + 0x7b800ebc); // 0x100058ee
    unsigned char v3 = *v2; // 0x100058ee
    *v2 = v3 / 2 | 128 * v3;
    int32_t result = 0x7d03feb3; // 0x100058f5
    if (a1 != 1) {
        result = function_10005897();
    }
    // 0x100058f7
    int32_t v4; // 0x100058e8
    bool v5; // 0x100058e8
    *(int32_t *)((v5 ? -4 : 4) + v4) = __asm_insd((int16_t)(result >> 31));
    return result;
}

// Address range: 0x100058fe - 0x100059db
int32_t function_100058fe(int32_t a1) {
    // 0x100058fe
    uint32_t v1; // 0x100058fe
    int32_t * v2 = (int32_t *)(v1 - 0x37827c48); // 0x10005907
    int32_t v3; // 0x100058fe
    *v2 = *v2 - v3;
    int16_t v4; // 0x100058fe
    int32_t v5; // 0x100058fe
    int32_t v6; // 0x100058fe
    if (((v6 + 0x67594b16 ^ v6) & (v6 ^ -0x80000000)) < 0) {
        int32_t v7 = function_100058e4(); // 0x1000591b
        v5 = v7;
        v4 = v7;
    } else {
        // 0x100058fe
        v4 = *(int16_t *)&v5;
    }
    // 0x1000591d
    int32_t v8; // 0x100058fe
    __asm_arpl(v4, (int16_t)v8);
    int32_t v9; // 0x100058fe
    int32_t v10 = v9 + 4; // 0x10005922
    v5 = __asm_int1();
    int32_t * v11 = (int32_t *)(v1 - 0x4b728beb); // 0x10005927
    *v11 = *v11 + v10;
    char v12 = *(char *)(v1 - 0x76d4282e); // 0x1000592d
    int32_t v13 = 256 * (int32_t)(v12 ^ (char)(v1 / 256)) | v1 & -0xff01; // 0x1000592d
    int32_t v14; // 0x100058fe
    uint32_t v15 = v14 & 31; // 0x10005933
    int32_t v16 = v13; // 0x10005933
    if (v15 != 0) {
        v16 = v13 >> v15 | v13 << 32 - v15;
    }
    int32_t v17 = v6 - 0x47c70ccb + v3; // 0x1000590d
    bool v18; // 0x100058fe
    int32_t v19 = v18 ? -4 : 4; // 0x10005923
    int32_t v20 = v6 + 0x67594b15 + v19; // 0x10005923
    int32_t v21 = v8 + 1; // 0x10005938
    int32_t v22 = v14 - 1; // 0x10005941
    *(int32_t *)v20 = *(int32_t *)v21;
    int32_t v23 = v20 + v19; // 0x10005947
    int32_t v24 = v19 + v21; // 0x10005947
    *(int32_t *)v9 = -0x24947149;
    *(int32_t *)(v9 - 4) = v22;
    *(int32_t *)(v9 - 8) = v17;
    *(int32_t *)(v9 - 12) = v16;
    *(int32_t *)(v9 - 16) = v10;
    *(int32_t *)(v9 - 24) = v24;
    *(int32_t *)(v9 - 28) = v23;
    __asm_int(52);
    v5 = v22;
    int32_t * v25 = (int32_t *)(v24 + 0xa448beb); // 0x1000594d
    uint32_t v26 = *v25; // 0x1000594d
    *v25 = v26 / 512 | 0x800000 * v26;
    char * v27 = (char *)(v23 - 0x788d68d9); // 0x10005956
    *v27 = *v27 + 73;
    float80_t v28; // 0x100058fe
    *(float32_t *)(v5 - 35) = (float32_t)v28;
    *(char *)v23 = __asm_insb((int16_t)v17);
    int32_t v29 = *(int32_t *)-0x2494710c; // 0x10005960
    int32_t v30 = v5 ^ -0x274f820a; // 0x10005963
    *(int32_t *)0xc48098a = v30;
    __asm_arpl(*(int16_t *)(v29 - 81), (int16_t)v30);
    int16_t v31 = v29; // 0x1000597a
    unsigned char v32 = __asm_in(v31); // 0x1000597a
    int32_t v33 = v24 & -256 | (int32_t)v32; // 0x1000597a
    v5 = v33;
    unsigned char v34 = *(char *)(v9 - 47); // 0x1000597b
    bool v35 = v32 > 153 | v34 < v32;
    int32_t v36; // 0x100058fe
    if ((v32 & 14) > 9 || (v34 & 15) - (v32 & 15) > 15) {
        v36 = v33 & -256 | (int32_t)((v35 ? 102 : 6) + v32);
    } else {
        v36 = v33 & -256 | (int32_t)(v35 ? v32 + 96 : v32);
    }
    v5 = v36;
    *(int32_t *)(v36 + 8) = 0x62472201;
    __asm_int(85);
    int32_t v37 = v5; // 0x10005996
    unsigned char v38 = (char)v37; // 0x10005996
    int32_t v39; // 0x100058fe
    char v40; // 0x100058fe
    if (((char)v36 & 15) > 21 || (v38 & 14) > 9) {
        char v41 = (v38 > 153 ? 102 : 6) + v38; // 0x10005996
        v39 = v37 & -256 | (int32_t)v41;
        v40 = v41;
    } else {
        char v42 = v38 > 153 ? v38 + 96 : v38; // 0x10005996
        v39 = v37 & -256 | (int32_t)v42;
        v40 = v42;
    }
    int32_t result = *(int32_t *)-0x44327674; // 0x1000599b
    v5 = result;
    if (v40 == 0) {
        // 0x100059a2
        return result;
    }
    int32_t v43 = v9 - 117 + (int32_t)(v38 > 153); // 0x100059a9
    __asm_in(v31);
    int32_t * v44 = (int32_t *)v39; // 0x100059ad
    *v44 = *(int32_t *)(v9 + 26) & -0xff01 | 0x3900;
    int32_t * v45 = (int32_t *)(v39 - 4); // 0x100059b1
    *v45 = v29;
    *(int32_t *)(*(int32_t *)(v43 + 12) + 26) = v16;
    int32_t v46 = v16 + 1; // 0x100059b5
    int32_t v47 = *v45; // 0x100059bb
    char * v48 = (char *)(v19 - 0x28ec8641 + v43); // 0x100059c0
    *v48 = *v48 & (char)v46;
    int32_t * v49 = (int32_t *)(v47 + 67); // 0x100059c7
    *v49 = *v49 + v47;
    int32_t v50 = v47 - 0x6571f025; // 0x100059ca
    char * v51 = (char *)v50; // 0x100059cf
    *v51 = *v51 + (char)v50;
    int32_t * v52 = (int32_t *)v46; // 0x100059d1
    *v52 = *v52 + v50;
    return *v44;
}

// Address range: 0x100059dc - 0x10005a71
int32_t function_100059dc(void) {
    // 0x100059dc
    int32_t v1; // 0x100059dc
    char v2 = llvm_ctpop_i8((char)v1 + 20); // 0x100059f1
    int16_t v3; // bp-16490, 0x100059dc
    int32_t v4 = &v3; // 0x100059f3
    int32_t v5; // bp-4, 0x100059dc
    int32_t * v6 = &v5; // 0x100059f3
    int32_t v7; // 0x100059dc
    int32_t v8; // 0x100059dc
    if ((v2 & 1) == 0) {
        // 0x100059f5
        __asm_in(0x55ec);
        int16_t v9 = v3; // 0x100059fa
        int16_t v10; // 0x100059dc
        __asm_arpl(v10, v9);
        int32_t v11; // bp-16486, 0x100059dc
        v4 = &v11;
        int32_t v12; // bp-16488, 0x100059dc
        v6 = &v12;
        v8 = v1 - 1;
        v7 = (int32_t)(v9 & -256 | 207) | (int32_t)(v9 & 48);
    }
    int32_t v13 = (int32_t)v6;
    int32_t * v14 = (int32_t *)v7; // 0x10005a02
    uint32_t v15 = *v14; // 0x10005a02
    *v14 = v15 / 0x400000 | 1024 * v15;
    __asm_out(184, v7);
    char * v16 = (char *)(v7 + 33); // 0x10005a09
    *v16 = *v16 + (char)(v8 / 256) + (char)((v15 & 0x200000) != 0);
    int32_t v17; // 0x100059dc
    int32_t * v18 = (int32_t *)(v17 + 0x98f1145); // 0x10005a0e
    *v18 = *v18 - 1;
    int32_t v19 = v4 - 4; // 0x10005a21
    int32_t * v20 = (int32_t *)v19; // 0x10005a21
    __asm_int(252);
    function_10005052();
    int32_t * v21 = (int32_t *)v4; // 0x10005a32
    *v21 = v13;
    *(char *)0x12ca8972 = (char)*v20;
    __asm_hlt();
    int32_t v22; // 0x100059dc
    *(int32_t *)v22 = *(int32_t *)*(int32_t *)(v4 - 2);
    *(int16_t *)(v4 + 4) = *(int16_t *)v19;
    *v21 = -2557;
    int32_t * v23 = (int32_t *)(v13 - 3); // 0x10005a4f
    *v23 = *v23 + 66;
    *v20 = *v21;
    return __asm_wait() | 95;
}

// Address range: 0x10005a71 - 0x10005abf
int32_t function_10005a71(int32_t a1, int32_t a2) {
    // 0x10005a71
    int32_t v1; // 0x10005a71
    int32_t v2 = &v1; // 0x10005a71
    float80_t v3; // 0x10005a71
    float32_t v4 = v3; // 0x10005a78
    int32_t v5; // 0x10005a71
    *(float32_t *)(v5 - 128) = v4;
    uint32_t v6 = v5 - 1; // 0x10005a7d
    __asm_int(20);
    uint32_t v7 = v6 / 256; // 0x10005a82
    char v8 = v7; // 0x10005a82
    unsigned char v9 = v8 - (char)v2; // 0x10005a82
    if (((v9 ^ v8) & (char)(v7 ^ v2)) >= 0) {
        // 0x10005ac2
        int32_t result; // 0x10005a71
        return result;
    }
    int32_t v10 = 256 * (int32_t)v9 | v6 & -0xff01; // 0x10005a82
    int32_t * v11 = (int32_t *)(v10 + 3); // 0x10005a89
    *v11 = *v11 & -0x7cbf152d;
    int32_t v12; // 0x10005a71
    int32_t * v13 = (int32_t *)(v12 + 0x57e20f51); // 0x10005a91
    *v13 = *v13 | v10;
    *(float32_t *)(v10 + 0x64db5895) = v4;
    __asm_in_5(87);
    return 0x10000 * unknown_f0059aa(-93 * *(int32_t *)v10) / 0x10000;
}

// Address range: 0x10005ac0 - 0x10005ac2
int32_t function_10005ac0(void) {
    // 0x10005ac0
    int32_t v1; // 0x10005ac0
    int32_t v2; // 0x10005ac0
    return v2 & -256 | v1 & 255;
}

// Address range: 0x10005ac3 - 0x10005adf
int32_t function_10005ac3(int32_t a1) {
    // 0x10005ac3
    int32_t v1; // 0x10005ac3
    int16_t v2 = v1;
    int32_t v3; // 0x10005ac3
    char * v4 = (char *)(v3 + 0x3e183c8); // 0x10005acb
    int32_t v5; // 0x10005ac3
    *v4 = *v4 | (char)v5;
    unsigned char v6 = *(char *)-0x582e5fe5; // 0x10005ad6
    int32_t v7; // 0x10005ac3
    __asm_outsb(v2, *(char *)&v7);
    int32_t v8; // 0x10005ac3
    return (v8 & -0x10000 | (int32_t)(256 * (int16_t)v8 / 256 * 256 * v2 / 256 & -256) | (int32_t)v6) ^ 0x142bd200;
}

// Address range: 0x10005aea - 0x10005af2
struct hostent * function_10005aea(char * addr, int32_t len, int32_t type) {
    // 0x10005aea
    int32_t v1; // 0x10005aea
    int32_t v2; // 0x10005aea
    *(char *)v2 = (char)v2 + (char)v1;
    return gethostbyaddr(addr, len, type);
}

// Address range: 0x10005b05 - 0x10005b13
int32_t function_10005b05(void) {
    // 0x10005b05
    int32_t v1; // 0x10005b05
    int32_t * v2 = (int32_t *)(v1 + 0x7f1000a0); // 0x10005b05
    uint32_t v3 = *v2; // 0x10005b05
    *v2 = v3 / 0x80000000 | 2 * v3;
    return v1 & 0x1000a084;
}

// Address range: 0x1000f000 - 0x1000f06f
int32_t function_1000f000(int32_t a1) {
    // 0x1000f000
    int32_t v1; // 0x1000f000
    *(int32_t *)(v1 + 184) = a1 + 89;
    return 0;
}

// Address range: 0x1000f06f - 0x1000f0d5
int32_t function_1000f06f(int32_t a1) {
    // 0x1000f06f
    __writefsdword(0, a1);
    int32_t v1; // 0x1000f06f
    int32_t v2; // 0x1000f06f
    int32_t v3; // 0x1000f06f
    int32_t v4; // 0x1000f06f
    return function_1000f0dd(v4, v3, v1, v2);
}

// Address range: 0x1000f0d5 - 0x1000f0dd
int32_t function_1000f0d5(void) {
    // 0x1000f0d5
    int32_t v1; // 0x1000f0d5
    return v1 & -256 | (int32_t)*(char *)0x600accf;
}

// Address range: 0x1000f0dd - 0x1000f3d9
int32_t function_1000f0dd(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1 - 27 + (int32_t)*(int16_t *)(a1 - 21); // 0x1000f140
    uint16_t v2 = *(int16_t *)(a1 - 19); // 0x1000f16d
    int32_t v3 = *(int32_t *)(a1 - 25); // 0x1000f1c8
    int32_t v4 = 0; // 0x1000f1c8
    int32_t * v5 = (int32_t *)(4 * v4 + v1); // 0x1000f1c9
    *v5 = *v5 ^ v3;
    uint32_t v6 = v3 / 2; // 0x1000f1d8
    v4++;
    v3 = v6 & 0x7fffff00 | 0x80000000 * v3 | v6 & 255;
    while (v4 < (int32_t)(v2 / 4)) {
        // 0x1000f1c9
        v5 = (int32_t *)(4 * v4 + v1);
        *v5 = *v5 ^ v3;
        v6 = v3 / 2;
        v4++;
        v3 = v6 & 0x7fffff00 | 0x80000000 * v3 | v6 & 255;
    }
    uint16_t v7 = v2 % 4;
    if (v7 != 0) {
        switch ((int32_t)v7) {
            case 1: {
                char * v8 = (char *)(4 * v4 + v1); // 0x1000f3a2
                *v8 = *v8 ^ (char)v6;
                // break -> 0x1000f2c5
                break;
            }
            case 2: {
                int16_t * v9 = (int16_t *)(4 * v4 + v1); // 0x1000f3c4
                *v9 = *v9 ^ (int16_t)v3;
                // break -> 0x1000f2c5
                break;
            }
            default: {
                int32_t v10 = 4 * v4 + v1;
                int16_t * v11 = (int16_t *)v10; // 0x1000f294
                *v11 = *v11 ^ (int16_t)v3;
                char * v12 = (char *)(v10 + 2); // 0x1000f2b4
                *v12 = *v12 ^ (char)(v3 / 2);
                // break -> 0x1000f2c5
                break;
            }
        }
    }
    // 0x1000f2c5
    int32_t v13; // 0x1000f0dd
    int32_t v14 = v13; // 0x1000f0dd
    while (true) {
        int32_t v15 = v14;
        if (*(int16_t *)v15 == 0x5a4d) {
            int32_t v16 = v15 + 60; // 0x1000f321
            int32_t v17 = v16 & -0x10000 | (int32_t)*(int16_t *)v16; // 0x1000f331
            v14 = v17;
            if (*(int16_t *)v17 == 0x4550) {
                // break -> 0x1000f358
                break;
            }
        } else {
            // 0x1000f2dd
            v14 = v15 - 0x1000 & -0x10000;
        }
    }
    // 0x1000f358
    return *(int32_t *)((int32_t)&v13 + 4);
}

// Address range: 0x1000f401 - 0x1000f402
int32_t function_1000f401(void) {
    // 0x1000f401
    int32_t result; // 0x1000f401
    return result;
}

// Address range: 0x1000f405 - 0x1000f406
int32_t function_1000f405(void) {
    // 0x1000f405
    int32_t result; // 0x1000f405
    return result;
}

// Address range: 0x1000f419 - 0x1000f449
int32_t function_1000f419(void) {
    // 0x1000f419
    uint32_t v1; // 0x1000f419
    unsigned char v2 = (char)v1;
    unsigned char v3 = (char)(v1 / 256); // 0x1000f41a
    *(char *)v1 = v2 - v3;
    char v4 = v2 < v3 ? -71 : -72; // 0x1000f423
    int32_t v5; // 0x1000f419
    int32_t v6; // 0x1000f419
    int32_t v7 = (v6 & -256 | (int32_t)(*(char *)(v5 - 0x5d4c6275) - v4)) + 1; // 0x1000f425
    int32_t v8 = v7; // 0x1000f427
    if (v7 < 0 == (v7 & (v6 ^ -0x80000000)) < 0 == (v7 != 0)) {
        v8 = function_1000f405();
    }
    int32_t result = v8;
    if (v1 == 1) {
        // 0x1000f436
        return result;
    }
    unsigned char v9 = (char)result; // 0x1000f447
    int32_t v10 = v9 < 206 ? result : result + 50; // 0x1000f447
    return v10 & 255 | result & -0x10000 | 256 * (int32_t)(v9 > 205);
}

// Address range: 0x1000f44a - 0x1000f456
int32_t function_1000f44a(void) {
    // 0x1000f44a
    int32_t v1; // 0x1000f44a
    int32_t v2; // 0x1000f44a
    __asm_out_4((int16_t)v1, (char)v2);
    int32_t result = __asm_wait(); // 0x1000f451
    int32_t v3; // 0x1000f44a
    __asm_into(v3);
    return result;
}

// Address range: 0x1000f456 - 0x1000f479
int32_t function_1000f456(int32_t a1, int32_t a2) {
    // 0x1000f456
    int32_t v1; // 0x1000f456
    int32_t v2; // 0x1000f456
    int32_t * v3 = (int32_t *)((v2 & -0xff01 | v1 & 0xff00) + 118); // 0x1000f460
    int32_t v4; // 0x1000f456
    int32_t v5; // 0x1000f456
    *v3 = v5 + (int32_t)&v4 + *v3;
    int32_t v6; // 0x1000f456
    float80_t v7; // 0x1000f456
    *(int16_t *)(v6 - 0x3e698647) = (int16_t)v7;
    int32_t v8 = __asm_sti(); // 0x1000f469
    uint32_t v9 = a1 + 2; // 0x1000f46a
    uint32_t v10 = *(int32_t *)(v6 + 111); // 0x1000f470
    int32_t v11 = v8; // 0x1000f473
    if (((v9 - v10 ^ v9) & (v10 ^ v9)) >= 0) {
        v11 = function_1000f401();
    }
    int32_t v12 = v11;
    return v12 + (v9 < v10 ? 29 : 28) & 255 | v12 & -256;
}

// Address range: 0x1000f479 - 0x1000f481
int32_t function_1000f479(void) {
    // 0x1000f479
    int32_t v1; // 0x1000f479
    int32_t v2; // 0x1000f479
    char * v3 = (char *)(v1 - 79 + 4 * v2); // 0x1000f479
    *v3 = *v3 | -17;
    return function_1000f482();
}

// Address range: 0x1000f481 - 0x1000f482
int32_t function_1000f481(void) {
    // 0x1000f481
    return __asm_hlt();
}

// Address range: 0x1000f482 - 0x1000f483
int32_t function_1000f482(void) {
    // 0x1000f482
    int32_t v1; // 0x1000f482
    int32_t v2; // 0x1000f482
    __asm_outsb((int16_t)v2, (char)v1);
    int32_t result; // 0x1000f482
    return result;
}

// Address range: 0x1000f4b1 - 0x1000f4b6
int32_t function_1000f4b1(void) {
    // 0x1000f4b1
    int32_t result; // 0x1000f4b1
    return result;
}

// Address range: 0x1000f4c6 - 0x1000f4eb
int32_t function_1000f4c6(void) {
    // 0x1000f4c6
    int32_t v1; // 0x1000f4c6
    char v2 = v1; // 0x1000f4c8
    bool v3; // 0x1000f4c6
    char v4 = v3; // 0x1000f4c8
    int32_t v5 = __asm_int3(); // 0x1000f4cb
    if (v4 == -v2) {
        // 0x1000f4e0
        return v5 & -0x10000 | v5 + 179 & 255 | 256 * (16 * (int32_t)((v2 & 15) + v4 > 15) | (int32_t)v3) | 0x4600;
    }
    // 0x1000f4ce
    int32_t v6; // 0x1000f4c6
    char v7 = v6;
    int32_t v8; // 0x1000f4c6
    int32_t v9; // 0x1000f4c6
    __asm_outsb((int16_t)v9, (char)v8);
    int32_t v10; // 0x1000f4c6
    char * v11 = (char *)((v10 & -256 | 53) + 49); // 0x1000f4dc
    *v11 = *v11 - v7;
    return v5 & -0x10550000 | (int32_t)(256 * (int16_t)v5 / 256 * (int16_t)v7) | 0x1054d233;
}

// Address range: 0x1000f4eb - 0x1000f4ff
int32_t function_1000f4eb(int32_t a1) {
    // 0x1000f4eb
    int32_t v1; // 0x1000f4eb
    int32_t v2; // 0x1000f4eb
    __asm_outsd((int16_t)v2, v1);
    int32_t v3; // 0x1000f4eb
    unsigned char v4 = (char)v3 & 31; // 0x1000f4f6
    if (v4 != 0) {
        int32_t v5; // 0x1000f4eb
        char * v6 = (char *)(4 * v2 + 70 + (v5 + 0x6b8b & 0xffff | v5 & -0x10000)); // 0x1000f4f6
        unsigned char v7 = *v6; // 0x1000f4f6
        *v6 = v7 >> 8 - v4 | v7 << v4;
    }
    return function_ce235ce3();
}

// Address range: 0x1000f50e - 0x1000f559
int32_t function_1000f50e(void) {
    // 0x1000f50e
    int32_t v1; // 0x1000f50e
    int32_t v2 = 256 * v1 & 0xff00;
    int32_t v3; // 0x1000f50e
    int32_t v4 = v2 ^ v3; // 0x1000f517
    int32_t v5 = *(int32_t *)(v4 - 0x5449fad7); // 0x1000f526
    int32_t v6 = __asm_iretd(); // 0x1000f52c
    uint32_t v7; // 0x1000f50e
    int32_t v8 = v1 & -0x10000 | v7 / 256 & 255 | 0x9200; // 0x1000f52d
    int32_t * v9 = (int32_t *)(v2 | v7 & -0xff01); // 0x1000f52f
    int32_t v10 = *v9 + v8 & v4; // 0x1000f531
    char v11 = llvm_ctpop_i8((char)v10); // 0x1000f531
    *v9 = v10;
    int32_t * v12 = (int32_t *)-0x25c03746; // 0x1000f533
    if ((v11 & 1) == 0) {
        // 0x1000f535
        v12 = (int32_t *)-0x25c03748;
    }
    int32_t * v13 = (int32_t *)(v4 - 96); // 0x1000f539
    *v13 = *v13 + 39;
    int128_t v14; // 0x1000f50e
    __asm_divps(v14, *(int128_t *)(v4 + 46));
    int32_t * v15 = (int32_t *)(8 * v5 + v8); // 0x1000f545
    *v15 = *v15 | 96;
    *v12 = v5;
    return v6 ^ 0x9200;
}

// Address range: 0x1000f55e - 0x1000f579
int32_t function_1000f55e(int32_t a1) {
    // 0x1000f55e
    int32_t v1; // 0x1000f55e
    char v2 = *(char *)(v1 - 117); // 0x1000f55e
    int32_t v3; // 0x1000f55e
    bool v4; // 0x1000f55e
    int32_t v5 = (v4 ? -4 : 4) + v3; // 0x1000f561
    int32_t * v6 = (int32_t *)(5 * v5); // 0x1000f562
    *v6 = *v6 & -91;
    uint32_t v7; // 0x1000f55e
    uint32_t v8; // 0x1000f55e
    bool v9; // 0x1000f55e
    *(char *)((256 * (int32_t)(v2 + (char)(v8 / 256) + (char)v9) | v8 & -0xff01) - 0x29c774db) = (char)(v7 / 256);
    int32_t v10; // 0x1000f55e
    char v11 = *(char *)(0x10000 * v10 / 0x10000 + 0x7981b176); // 0x1000f56f
    uint32_t v12; // 0x1000f55e
    char v13 = __asm_in((int16_t)(256 * (int32_t)(v11 | (char)(v12 / 256)) | v12 & 255)); // 0x1000f575
    return (v5 | (int32_t)v13) & -256 | (int32_t)(v13 - 34);
}

// Address range: 0x1000f5ce - 0x1000f5cf
int32_t function_1000f5ce(int32_t a1) {
    // 0x1000f5ce
    int32_t result; // 0x1000f5ce
    return result;
}

// Address range: 0x1000f5f2 - 0x1000f5f9
int32_t function_1000f5f2(void) {
    // 0x1000f5f2
    int32_t v1; // 0x1000f5f2
    uint16_t v2 = (int16_t)v1; // 0x1000f5f2
    int32_t v3; // 0x1000f5f2
    uint16_t v4 = (int16_t)*(char *)(v3 + 0x11298f); // 0x1000f5f2
    return v1 & -0x10000 | (int32_t)(v2 / v4 & 255) | (int32_t)(256 * (v2 % v4));
}

// Address range: 0x1000f632 - 0x1000f64c
int32_t function_1000f632(void) {
    // 0x1000f632
    __asm_int(142);
    uint32_t v1; // 0x1000f632
    int32_t v2 = 231 * v1 / 256 + v1; // 0x1000f639
    unsigned char v3 = (char)v2; // 0x1000f63c
    bool v4; // 0x1000f632
    bool v5 = v4 | v3 > 153;
    int32_t v6 = v5 ? v2 + 96 : v2;
    bool v7; // 0x1000f632
    int32_t result = (v7 | (v3 & 14) > 9 ? (v5 ? 102 : 6) + v2 : v6) & 255 | v1 & -0x10000;
    int32_t v8; // 0x1000f632
    int32_t v9 = v8 + 1; // 0x1000f63d
    *(int32_t *)-0x5ce3ae4d = result;
    *(int32_t *)-0x5ce3ae5d = -0x5ce3ae49;
    *(int32_t *)-0x5ce3ae61 = v9;
    *(int32_t *)-0x5ce3ae6d = -0x4f16b720;
    int32_t v10; // 0x1000f632
    unsigned char v11 = (char)v10 & 31; // 0x1000f644
    if (v11 != 0) {
        char * v12 = (char *)(v10 - 123 + 4 * result); // 0x1000f644
        *v12 = *v12 << v11;
    }
    *(int32_t *)-0x5ce3ae71 = v9;
    return result;
}

// Address range: 0x1000f64c - 0x1000f6f8
int32_t function_1000f64c(void) {
    // 0x1000f64c
    int32_t v1; // 0x1000f64c
    int32_t v2; // 0x1000f64c
    *(int32_t *)0x562f0d89 = v2 & -256 | (int32_t)__asm_in((int16_t)v1);
    int32_t v3 = __asm_int3(); // 0x1000f65a
    unsigned char v4 = (char)v3; // 0x1000f65b
    bool v5; // 0x1000f64c
    bool v6 = v5 | v4 > 153;
    int32_t v7; // 0x1000f64c
    int32_t v8; // 0x1000f64c
    if ((v8 & 15) > 16 || (v4 & 14) > 9) {
        v7 = (v6 ? 154 : 250) + v3 & 255 | v3 & -256;
    } else {
        v7 = (v6 ? v3 + 160 : v3) & 255 | v3 & -256;
    }
    int32_t v9 = v8 - 1; // 0x1000f652
    int32_t v10 = v9 & -0xff01 | 0xf100; // 0x1000f658
    *(int32_t *)-0x16372d98 = v7;
    int32_t v11; // 0x1000f64c
    int32_t v12 = *(int32_t *)v10 ^ v11; // 0x1000f662
    int32_t v13; // 0x1000f64c
    if (v12 < 1) {
        char * v14 = (char *)(v13 - 0x3017bb62); // 0x1000f674
        *v14 = *v14 - (v7 > 0xfcfa44f0 ? -83 : -84);
        char * v15 = (char *)(v7 - 0x776ee565); // 0x1000f67b
        *v15 = *v15 + (char)((v7 + 0xbb0f) / 256);
        __asm_wait();
        return function_8fa93699();
    }
    // 0x1000f6d5
    int32_t v16; // 0x1000f64c
    int32_t v17 = *(int32_t *)(v16 - 0x21b761d7) + 1; // 0x1000f6da
    *(char *)v13 = *(char *)v17;
    *(int32_t *)-0x21a80c2 = v10;
    bool v18; // 0x1000f64c
    char * v19 = (char *)(v17 + (v18 ? 0x445a020 : 0x445a022)); // 0x1000f6e0
    unsigned char v20 = *v19; // 0x1000f6e0
    unsigned char v21 = v20 + (char)v9; // 0x1000f6e0
    *v19 = v21;
    int32_t * v22 = (int32_t *)(3 * v12 + 0x437b89c1); // 0x1000f6ec
    *v22 = 0x80000000 * (int32_t)(v21 < v20) | *v22 / 2;
    return function_c90d0b57();
}

// Address range: 0x1000f6f8 - 0x1000f6f9
int32_t function_1000f6f8(int32_t a1) {
    // 0x1000f6f8
    int32_t result; // 0x1000f6f8
    return result;
}

// Address range: 0x1000f72a - 0x1000f7c5
int32_t function_1000f72a(int32_t result, int32_t a2) {
    // 0x1000f72a
    int32_t v1; // 0x1000f72a
    char * v2 = (char *)(v1 - 0x3ab27166); // 0x1000f72a
    int32_t v3; // 0x1000f72a
    *v2 = *v2 + (char)v3;
    int32_t v4; // 0x1000f72a
    __asm_in_3((int16_t)v4);
    int32_t v5; // 0x1000f72a
    int32_t * v6 = (int32_t *)(v1 - 77 + v5); // 0x1000f731
    *v6 = *v6 & 1;
    int32_t * v7 = (int32_t *)(v5 + 0x7ecc8879); // 0x1000f785
    *v7 = *v7 & v4;
    return result;
}

// Address range: 0x1000f7c5 - 0x1000f7cd
int32_t function_1000f7c5(int16_t a1, int32_t a2) {
    // 0x1000f7c5
    int32_t v1; // 0x1000f7c5
    bool v2; // 0x1000f7c5
    return (int32_t)v2 - v1 + __asm_in_2(209);
}

// Address range: 0x1000f7cd - 0x1000f80a
int32_t function_1000f7cd(int32_t a1) {
    // 0x1000f7cd
    int32_t v1; // 0x1000f7cd
    int32_t v2; // 0x1000f7cd
    __asm_out_4((int16_t)v2, (char)v1);
    __asm_in_3(-0x2235);
    int32_t v3; // 0x1000f7cd
    int32_t * v4 = (int32_t *)(v3 + 0xffd1 & 0xffff); // 0x1000f7da
    *v4 = *v4 & -0x75da2235;
    int32_t v5; // 0x1000f7cd
    float80_t v6; // 0x1000f7cd
    *(int16_t *)(v5 + 64) = (int16_t)v6;
    __asm_iretd();
    int16_t v7; // 0x1000f7cd
    *(int32_t *)((int32_t)&v7 + 0x607f02b0) = v3 ^ v5 - 1;
    char * v8 = (char *)(a1 - 0x6a74792f); // 0x1000f7fb
    *v8 = *v8 | -26;
    return __asm_wait() & -256 | (int32_t)__asm_in_5(-104);
}

// Address range: 0x1000f80b - 0x1000f80c
int32_t function_1000f80b(void) {
    // 0x1000f80b
    int32_t result; // 0x1000f80b
    return result;
}

// Address range: 0x1000f817 - 0x1000f818
int32_t function_1000f817(int32_t a1) {
    // 0x1000f817
    int32_t result; // 0x1000f817
    return result;
}

// Address range: 0x1000f81d - 0x1000f905
int32_t function_1000f81d(int32_t a1) {
    // 0x1000f81d
    int32_t v1; // 0x1000f81d
    float80_t v2; // 0x1000f81d
    *(int64_t *)(v1 + 32) = (int64_t)v2;
    uint32_t v3; // 0x1000f81d
    uint32_t v4 = v3 | v1; // 0x1000f822
    int32_t v5 = __asm_hlt(); // 0x1000f829
    *(int32_t *)-0x7d0367db = *(int32_t *)-0x7d0367db + 1;
    int32_t v6 = v5 >> 31; // 0x1000f830
    bool v7 = v4 < 0xc40eb3fe; // 0x1000f837
    int32_t v8 = v5; // 0x1000f837
    uint32_t v9 = v6; // 0x1000f837
    int32_t v10; // 0x1000f81d
    int32_t v11; // 0x1000f81d
    int32_t v12; // 0x1000f81d
    if (((v4 + 0x3bf14c02 ^ v4) & (v4 ^ -0x80000000)) < 0) {
        char * v13 = (char *)(v5 + 0x5bb8f944); // 0x1000f839
        unsigned char v14 = (char)(v5 / 256); // 0x1000f839
        *v13 = *v13 + v14;
        char v15 = *(char *)(v6 + 0x2bb36a03); // 0x1000f83f
        unsigned char v16 = (char)(v6 / 256) + v14; // 0x1000f845
        int32_t v17 = 256 * (int32_t)v16 | v5 & -0xff01; // 0x1000f845
        char * v18 = (char *)(v17 - 104); // 0x1000f847
        unsigned char v19 = *v18; // 0x1000f847
        char v20 = v6; // 0x1000f847
        char v21 = v16 < v14; // 0x1000f847
        unsigned char v22 = v19 + v20; // 0x1000f847
        unsigned char v23 = v22 + v21; // 0x1000f847
        char v24 = v23 + v21; // 0x1000f847
        *v18 = v23;
        int32_t v25 = v17; // 0x1000f84a
        if (((v24 ^ v19) & (v24 ^ v20)) >= 0) {
            v25 = function_1000f7cd((int32_t)&g22);
        }
        int32_t v26 = 256 * (int32_t)(v15 & (char)(v3 / 256)) | v3 & -0xff01; // 0x1000f83f
        bool v27 = v16 < v14 ? v23 <= v19 : v22 < v19; // 0x1000f847
        uint32_t v28 = v25;
        int32_t v29; // 0x1000f81d
        int16_t v30 = *(int16_t *)(v29 - 0x7f77cd3f); // 0x1000f84f
        int32_t v31; // 0x1000f81d
        char * v32 = (char *)(v31 - 0x2e2dfea7); // 0x1000f855
        unsigned char v33 = *v32; // 0x1000f855
        *v32 = v33 / 128 | 2 * (char)v27 | 4 * v33;
        int32_t v34 = *(int32_t *)(v26 + 0x7e901621); // 0x1000f864
        int32_t v35 = __asm_int3(); // 0x1000f86a
        char v36 = *(char *)v35; // 0x1000f86b
        int32_t v37; // 0x1000f81d
        char v38 = *(char *)&v37; // 0x1000f86d
        int32_t v39 = ((0x10000 * (int32_t)(v36 | (char)v35) * (int32_t)v38 | 0x5060000) + 0x10000) / 0x10000; // 0x1000f87b
        *(char *)v31 = (char)v39;
        v9 = *(int32_t *)(v28 + 0x7c45a23f) + v28;
        unsigned char v40 = (char)v37; // 0x1000f885
        char v41 = *(char *)(v39 - 20); // 0x1000f885
        char v42 = v9 < v28; // 0x1000f885
        unsigned char v43 = v41 + v40; // 0x1000f885
        unsigned char v44 = v43 + v42; // 0x1000f885
        char v45 = v44 + v42; // 0x1000f885
        v37 = v37 & -256 | (int32_t)v44;
        v8 = v39;
        if (v44 < 0 == ((v45 ^ v40) & (v45 ^ v41)) < 0) {
            v8 = function_1000f80b();
        }
        // 0x1000f88a
        int32_t v46; // 0x1000f81d
        int32_t v47 = (int32_t)&v46 - *(int32_t *)v28; // 0x1000f87c
        v7 = v9 < v28 ? v44 <= v40 : v43 < v40;
        int32_t v48 = *(int32_t *)(v31 - 0x66aa734b); // 0x1000f88b
        v10 = v26;
        v12 = v47;
        v11 = v34;
        if (v44 == 0) {
            // 0x1000f8da
            __asm_iretd();
            int64_t v49; // 0x1000f81d
            __asm_packuswb(v49, *(int64_t *)(v48 + 0x3ce0e897));
            int32_t * v50 = (int32_t *)v47; // 0x1000f8e3
            int32_t v51 = *v50; // 0x1000f8e3
            *v50 = v48;
            int32_t v52 = (char)v51 < 0 == ((v51 & 2048) != 0) ? v26 : v34 - 1; // 0x1000f8e8
            *(char *)(v31 - 1) = (char)(v37 / 256);
            __asm_out_6((int16_t)v9, v52);
            int64_t v53; // 0x1000f81d
            __asm_psubusw(v53, *(int64_t *)v9);
            *(int64_t *)(v47 + 33) = (int64_t)(v2 * (float80_t)v30);
            return v52 + v47;
        }
    }
    int32_t v54 = v8;
    *(int32_t *)(v12 - 4) = 0x4001593e;
    int32_t v55 = *(int32_t *)(v9 + 0x6b908b96); // 0x1000f89b
    int32_t v56 = 0x10000 * (v54 + 233 + (int32_t)v7 & 255 | v54 & 0xff00) / 0x10000 - v55; // 0x1000f89b
    char * v57 = (char *)(v10 - 28); // 0x1000f8a1
    *v57 = *v57 + (char)v56;
    char * v58 = (char *)(v9 + 0x3055d09e); // 0x1000f8b5
    unsigned char v59 = *v58; // 0x1000f8b5
    *v58 = v59 - 76;
    int32_t * v60 = (int32_t *)((v56 | -0x12aa73c3) - 0x74bbee30); // 0x1000f8bc
    *v60 = 2 * *v60 | (int32_t)(v59 < 76);
    return *(int32_t *)v11;
}

// Address range: 0x1000f906 - 0x1000f915
int32_t function_1000f906(void) {
    // 0x1000f906
    __asm_in_2(209);
    int16_t v1; // 0x1000f906
    return function_c782bb45(v1);
}

// Address range: 0x1000f925 - 0x1000f92a
int32_t function_1000f925(void) {
    // 0x1000f925
    return function_938aaf2d();
}

// Address range: 0x1000f944 - 0x1000f946
int32_t function_1000f944(void) {
    // 0x1000f944
    int32_t result; // 0x1000f944
    return result;
}

// Address range: 0x1000f96a - 0x1000f9b2
int32_t function_1000f96a(void) {
    int32_t v1 = unknown_49e6d3(); // 0x1000f96c
    uint32_t v2; // 0x1000f96a
    __asm_out_6((int16_t)v2, v1);
    uint32_t v3; // 0x1000f96a
    int32_t * v4 = (int32_t *)(v3 + 22); // 0x1000f973
    *v4 = *v4 | v1;
    int32_t v5; // 0x1000f96a
    *(int32_t *)v5 = v1 + 15 & 255 | v1 & -256;
    char * v6 = (char *)(v2 + 69); // 0x1000f979
    *v6 = (char)((char)v1 < 241) + (char)(v3 / 256) + *v6;
    char * v7 = (char *)(v2 - 0x66e80037); // 0x1000f980
    uint32_t v8 = v2 / 256; // 0x1000f980
    *v7 = *v7 & (char)v8;
    bool v9; // 0x1000f96a
    int32_t v10 = v9 ? -1 : 1;
    int32_t v11 = (v9 ? -4 : 4) + v5; // 0x1000f986
    int32_t v12 = unknown_d8b46382(); // 0x1000f98b
    int32_t v13; // 0x1000f96a
    __asm_into(v13);
    int32_t v14; // 0x1000f96a
    float80_t v15; // 0x1000f96a
    *(float64_t *)(v14 + 32) = (float64_t)v15;
    int32_t v16; // 0x1000f96a
    unsigned char v17 = *(char *)v16; // 0x1000f9a0
    unsigned char v18 = *(char *)v11; // 0x1000f9a0
    v11 += v10;
    int32_t * v19 = (int32_t *)v11; // 0x1000f9a1
    uint32_t v20 = *v19; // 0x1000f9a1
    *v19 = 0x40000000 * v20 | v20 / 8 | 0x20000000 * (int32_t)(v17 < v18);
    v16 += v10;
    while (v17 == v18 || (v20 & 4) != 0) {
        // 0x1000f98b
        v12 = unknown_d8b46382();
        __asm_into(v13);
        *(float64_t *)(v14 + 32) = (float64_t)v15;
        v17 = *(char *)v16;
        v18 = *(char *)v11;
        v11 += v10;
        v19 = (int32_t *)v11;
        v20 = *v19;
        *v19 = 0x40000000 * v20 | v20 / 8 | 0x20000000 * (int32_t)(v17 < v18);
        v16 += v10;
    }
    uint16_t v21 = ((int16_t)v12 & 255) * ((int16_t)v8 & 255); // 0x1000f990
    int32_t v22 = (int32_t)v21 + 225 + (int32_t)(v21 > 255) & 255; // 0x1000f998
    int32_t * v23 = (int32_t *)(5 * v2); // 0x1000f9a6
    *v23 = 2 * *v23;
    return v22 * (v8 & 255) | v12 & -0x10000;
}

// Address range: 0x1000f9b3 - 0x1000fabe
int32_t function_1000f9b3(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x1000f9b3
    int32_t v1; // 0x1000f9b3
    int32_t v2 = v1 & -0xff01 | 0xfe00; // 0x1000f9b3
    int32_t v3; // 0x1000f9b3
    int32_t v4; // 0x1000f9b3
    int32_t v5 = v4 & -256 | (int32_t)*(char *)(v3 + 41); // 0x1000f9b5
    int32_t v6; // 0x1000f9b3
    int32_t v7 = *(int32_t *)-0x133a8a58 & v6; // 0x1000f9ba
    int32_t v8; // 0x1000f9b3
    uint32_t v9 = *(int32_t *)(v8 - 0x46762985); // 0x1000f9c0
    int32_t * v10 = (int32_t *)(v7 + 0x7fcc7a7d); // 0x1000f9c7
    *v10 = *v10 - v2 + (int32_t)(v9 > -1 - v5);
    unsigned char v11 = (char)v1; // 0x1000f9cd
    unsigned char v12 = *(char *)(v7 - 0x4a3a3c90) + v11; // 0x1000f9cd
    int32_t v13; // 0x1000f9b3
    int32_t v14 = (v13 | 139) - 0x5e3c25ed | (int32_t)(v12 < v11); // 0x1000f9df
    int32_t v15 = v2 & -512 | (int32_t)v12; // 0x1000f9df
    int32_t v16 = v8 & -256 | 137;
    unsigned char v17 = (char)v14; // 0x1000f9e0
    unsigned char v18 = v17 + (char)((v5 + v9) / 256); // 0x1000f9e0
    v14 = v14 & -256 | (int32_t)v18;
    int32_t v19 = v14; // 0x1000f9e4
    int32_t v20 = v16; // 0x1000f9e4
    while (v18 == 0) {
        // 0x1000f9e6
        v15 = v15 & -0xff01 | 0xeb00;
        char v21 = *(char *)(v14 - 104); // 0x1000f9e6
        char v22 = (char)(v18 < v17) + (char)v16 + v21; // 0x1000f9e6
        int32_t v23 = v16 & -256 | (int32_t)v22; // 0x1000f9e6
        if (v22 < 0) {
            char * v24 = (char *)(v7 + 1); // 0x1000f9f0
            *v24 = *v24 + (char)(v16 / 256);
            uint32_t v25 = v23 + 1; // 0x1000f9f8
            __asm_int(37);
            int32_t v26; // bp-2, 0x1000f9b3
            int32_t v27; // 0x1000f9b3
            *(int32_t *)(v27 + 0x24559e69) = (int32_t)&v26;
            int32_t v28 = v26; // 0x1000fa0a
            __asm_in_5(61);
            char * v29 = (char *)(v27 - 76); // 0x1000fa0f
            *v29 = *v29 + (char)(v25 / 256);
            int32_t v30 = unknown_8df2dc5b(); // 0x1000fa23
            int32_t v31 = *(int32_t *)-0x9f011cd + 1; // 0x1000fa2a
            *(int32_t *)-0x9f011cd = v31;
            if (v31 == 0) {
                char * v32 = (char *)(v28 + 120); // 0x1000fa77
                *v32 = *v32 - 1;
                return function_1b7c7a9c();
            }
            int32_t * v33 = (int32_t *)(v15 - 86 + (4 * v30 | 504)); // 0x1000fa33
            uint32_t v34 = *v33; // 0x1000fa33
            *v33 = v34 / 0x40000000 | 4 * v34;
            char * v35 = (char *)(v27 - 0xaccf2b); // 0x1000fa38
            *v35 = 2 * *v35 | (char)((v34 & 0x20000000) != 0);
            v26 = v25 & -256 | (int32_t)(v22 - 20);
            __asm_int3();
            v19 = a6;
            v20 = a3;
            goto lab_0x1000fa52;
        }
        v16 = v23;
        v17 = (char)v14;
        v18 = v17 + (char)((v5 + v9) / 256);
        v14 = v14 & -256 | (int32_t)v18;
        v19 = v14;
        v20 = v16;
    }
  lab_0x1000fa52:;
    int32_t v36 = v19 ^ 0x6f058b72; // 0x1000fa52
    return v36 & -256 | (int32_t)*(char *)((v36 & 255) + v20);
}

// Address range: 0x1000fad0 - 0x1000fae0
int32_t function_1000fad0(void) {
    // 0x1000fad0
    int32_t v1; // 0x1000fad0
    return v1 - 0xd014a80 & -256 | v1 + 28 & 255;
}

// Address range: 0x1000fae0 - 0x1000fb09
int32_t function_1000fae0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x1000fae0
    bool v1; // 0x1000fae0
    if (v1) {
        uint32_t v2 = __asm_iretd(); // 0x1000faf9
        int32_t v3; // 0x1000fae0
        int32_t result = v2 & -256 | v3 & 255; // 0x1000fafa
        char * v4 = (char *)(result + 0x5bc003ec); // 0x1000fafb
        *v4 = *v4 + (char)(v2 / 256);
        return result;
    }
    // 0x1000fae2
    __asm_int3();
    return function_4f4705ff();
}

// Address range: 0x1000fb19 - 0x1000fb20
int32_t function_1000fb19(void) {
    // 0x1000fb19
    int32_t result; // 0x1000fb19
    return result;
}

// Address range: 0x1000fb46 - 0x1000fb4d
int32_t function_1000fb46(void) {
    // 0x1000fb46
    return function_fffffaff();
}

// Address range: 0x1000fb4e - 0x1000fc8d
int32_t function_1000fb4e(int32_t a1, int32_t a2) {
    // 0x1000fb4e
    uint32_t v1; // 0x1000fb4e
    int32_t v2; // 0x1000fb4e
    char v3 = v2 & v1 / 256; // 0x1000fb4f
    int32_t v4; // 0x1000fb4e
    if (v3 >= 0 != v3 != 0) {
        int32_t * v5 = (int32_t *)(v4 - 104); // 0x1000fb55
        *v5 = -*v5;
        return function_d81bbc05();
    }
    // 0x1000fb91
    *(int32_t *)-0x7d936fb9 = *(int32_t *)-0x7d936fb9 + 1;
    int32_t v6; // 0x1000fb4e
    int32_t v7 = *(int32_t *)(v6 - 1); // 0x1000fbbc
    int32_t v8 = v7 + 136 & 255 | v7 & -256; // 0x1000fbbd
    uint32_t v9; // 0x1000fb4e
    uint32_t v10 = v9 & 31; // 0x1000fbbf
    int32_t v11 = v8; // 0x1000fbbf
    if (v10 != 0) {
        v11 = v8 >> 32 - v10 | v8 << v10;
    }
    int32_t v12 = v11 & -0xff01 | 0xa000; // 0x1000fbc3
    int32_t * v13 = (int32_t *)(v12 - 0x6bfebbfe); // 0x1000fbd4
    *v13 = *v13 & -74;
    int32_t v14; // 0x1000fb4e
    int32_t v15 = (v14 & 1024) != 0 ? -1 : 1; // 0x1000fbe2
    *(int32_t *)0x68ffd498 = *(int32_t *)0x68ffd498 - 1;
    char v16 = *(char *)0x2bf61fe2; // 0x1000fbe9
    int32_t v17; // bp-1, 0x1000fb4e
    int32_t v18; // 0x1000fb4e
    uint32_t v19 = (v18 - 1 + (int32_t)&v17 + v15) / 2; // 0x1000fbf0
    int32_t v20 = v12 + 0x73ffea67 & -0x7500 | v9 / 256 & 255; // 0x1000fbf7
    int32_t * v21 = (int32_t *)((v9 & -256 | (int32_t)(v16 | (char)v9)) - 90); // 0x1000fbff
    *v21 = *v21 + 0x68ffd453;
    *(int32_t *)-0x5625f641 = v19 | -0x80000000;
    int32_t v22 = v6 - 5 + v15 + ((v14 & 1024) != 0 ? -2 : 2); // 0x1000fc05
    int32_t v23 = __asm_int3(); // 0x1000fc09
    char v24 = *(char *)(v4 + 0x4d80693b); // 0x1000fc0a
    int32_t v25 = v23 & -256 | (int32_t)(v24 | (char)v23); // 0x1000fc0a
    int32_t * v26 = (int32_t *)(v4 + 12 + 8 * v19); // 0x1000fc10
    *v26 = *v26 | 115;
    int32_t * v27 = (int32_t *)(v20 + 0x4d258b81); // 0x1000fc15
    uint32_t v28 = *v27; // 0x1000fc15
    *v27 = v28 / 256 | 0x1000000 * v28;
    __asm_out(182, v25);
    if ((*(int32_t *)(v22 - 119) || v22 - 0x5625f640) >= 0) {
        int32_t * v29 = (int32_t *)(v20 + 0x66174cbe); // 0x1000fc80
        *v29 = *v29 / 2;
        return function_f5804983();
    }
    // 0x1000fc2c
    __asm_int3();
    int32_t v30 = unknown_988e2202(); // 0x1000fc3a
    int32_t * v31 = (int32_t *)(*(int32_t *)(v25 + 0x271d53) + 0x68ffd453); // 0x1000fc45
    *v31 = *v31 - 1;
    __asm_int3();
    int32_t * v32 = (int32_t *)(v4 + 0x7ffa9926); // 0x1000fc4c
    *v32 = *v32 - 0x36f58e43 + (int32_t)(((int16_t)v30 ^ -512) < 0xfa00);
    return function_89c8b28b();
}

// Address range: 0x1000fc9d - 0x1000fdf2
int32_t function_1000fc9d(int32_t a1) {
    int32_t v1 = a1;
    uint32_t v2; // 0x1000fc9d
    uint32_t v3 = v2 & 31; // 0x1000fc9d
    bool v4; // 0x1000fc9d
    int32_t v5; // 0x1000fc9d
    if (v3 != 0) {
        int32_t v6 = v2 << 32 - v3 | v2 >> v3; // 0x1000fc9d
        v5 = v6;
        v4 = v6 < 0;
    }
    bool v7; // 0x1000fc9d
    int32_t v8 = v7 ? -4 : 4; // 0x1000fc9f
    int32_t v9; // 0x1000fc9d
    int32_t v10 = v8 + v9; // 0x1000fc9f
    int32_t v11; // 0x1000fc9d
    int32_t v12 = v8 + v11; // 0x1000fc9f
    bool v13; // 0x1000fc9d
    int32_t v14; // 0x1000fc9d
    int32_t v15; // 0x1000fc9d
    int32_t v16; // 0x1000fc9d
    if (v13 || v4) {
        // 0x1000fca2
        int32_t v17; // 0x1000fc9d
        return function_d81c0bff(v10, v12, v14, &v1, v15, v16 & -0xff01 | 0x7d00, v5, v17);
    }
    int32_t v18 = __asm_hlt(); // 0x1000fcc6
    int32_t v19 = (int32_t)(*(char *)(v18 - 0xaccfaa8) + (char)v18); // 0x1000fcc7
    int32_t v20 = v18 & -0x10000 | v19 | 256 * v19; // 0x1000fcd0
    int32_t * v21 = (int32_t *)(v14 - 121 + 8 * v10); // 0x1000fcd2
    uint32_t v22 = *v21; // 0x1000fcd2
    *v21 = v22 / 0x4000000 | 64 * v22;
    int32_t v23 = v10 + v12 + *(int32_t *)(v10 - 17) + (int32_t)((v22 & 0x2000000) != 0); // 0x1000fcd7
    int32_t v24 = v1; // 0x1000fcd9
    char * v25 = (char *)(2 * v20 + 0x45dd67d0); // 0x1000fcda
    *v25 = *v25 ^ (char)(v5 / 256);
    v1 = v20;
    int32_t v26 = v5 - 1; // 0x1000fce5
    if (v26 == 0 || v20 == 1) {
        // 0x1000fce7
        __asm_hlt();
        if (v26 == 0) {
            int32_t v27 = *(int32_t *)(v16 - 0x53729091) + v15; // 0x1000fd3d
            int32_t v28 = __asm_int3(); // 0x1000fd43
            int32_t v29 = (char)v28 == -1;
            int32_t v30 = v28 + v29; // 0x1000fd44
            int32_t * v31 = (int32_t *)(v27 + 0x497111fe); // 0x1000fd46
            *v31 = v27;
            int32_t v32 = v16 + 1; // 0x1000fd4c
            int32_t * v33 = (int32_t *)(v16 + 0x1640869a); // 0x1000fd4d
            *v33 = *v33 + 1;
            int32_t v34 = 77 * *(int32_t *)v24; // 0x1000fd5a
            int32_t v35 = v23 - (256 * v29 | v28 & -0x10000 | v30 & 255) + (int32_t)((char)v30 < 238); // 0x1000fd5f
            __asm_arpl(*(int16_t *)(v35 - 5), (int16_t)v34);
            *(int32_t *)(v26 + 0x1245d27c) = v34;
            int32_t v36 = __asm_int3(); // 0x1000fd6a
            char v37 = *(char *)v36; // 0x1000fd6b
            char * v38 = (char *)((v36 & -256 | (int32_t)(v37 | (char)v36)) - 63); // 0x1000fd6f
            *v38 = *v38 | 76;
            int32_t v39 = *(int32_t *)v32 | v32; // 0x1000fd74
            __asm_in((int16_t)v39);
            int32_t result = *(int32_t *)v39 ^ v24; // 0x1000fd7f
            int32_t v40 = result >> 31; // 0x1000fd85
            if ((char)result < 0) {
                char * v41 = (char *)(v40 - 0x676ada62); // 0x1000fd96
                *v41 = *v41 - 48;
                return __asm_int3() + 0x4f12e676;
            }
            // 0x1000fde3
            __asm_outsd((int16_t)v40, *(int32_t *)(v35 - 1));
            int32_t * v42 = (int32_t *)(*v31 - 1); // 0x1000fde4
            *v42 = *v42 - 1;
            int32_t * v43 = (int32_t *)(v40 - 0x76f0fa9a); // 0x1000fdec
            *v43 = *v43 + 1;
            return result;
        }
    }
    uint32_t v44 = __asm_iretd(); // 0x1000fcf9
    char * v45 = (char *)((v44 & -256 | (int32_t)*(char *)v23) + 0x5d8b598c); // 0x1000fcfb
    unsigned char v46 = *v45; // 0x1000fcfb
    uint32_t v47 = v44 / 256; // 0x1000fcfb
    unsigned char v48 = v46 + (char)v47; // 0x1000fcfb
    *v45 = v48;
    int64_t v49; // 0x1000fc9d
    __asm_paddq(v49, v49);
    int32_t * v50 = (int32_t *)(v14 + 65); // 0x1000fd07
    *v50 = *v50 + v24;
    *(int32_t *)-0x3aaa7167 = *(int32_t *)-0x3aaa7167 + 1;
    int32_t v51 = __asm_int1(); // 0x1000fd1c
    float80_t v52; // 0x1000fc9d
    *(int64_t *)(v14 - 0x2b6768) = (int64_t)v52;
    __asm_arpl(*(int16_t *)(v23 + (v7 ? 0x660bff50 : 0x660bff52)), -0x3d4b);
    int32_t * v53 = (int32_t *)(v26 - 10); // 0x1000fd29
    *v53 = *v53 ^ (v16 - v47 + (int32_t)(v48 < v46) & 255 | v16 & -256);
    unsigned char v54 = *(char *)(v26 + 76); // 0x1000fd34
    return (v51 + 204 + (int32_t)(v54 < (char)v26) & 255 | v51 & -256) - 1;
}

// Address range: 0x1000fdf3 - 0x1000fdf4
int32_t function_1000fdf3(void) {
    // 0x1000fdf3
    int32_t result; // 0x1000fdf3
    return result;
}

// Address range: 0x1000fe08 - 0x1000fe09
int32_t function_1000fe08(void) {
    // 0x1000fe08
    int32_t result; // 0x1000fe08
    return result;
}

// Address range: 0x1000fe17 - 0x1000fe18
int32_t function_1000fe17(int32_t a1) {
    // 0x1000fe17
    int32_t result; // 0x1000fe17
    return result;
}

// Address range: 0x1000fe1d - 0x1000fe5e
int32_t function_1000fe1d(void) {
    // 0x1000fe1d
    int32_t v1; // 0x1000fe1d
    float80_t v2; // 0x1000fe1d
    *(int64_t *)(v1 + 32) = (int64_t)v2;
    int32_t v3; // 0x1000fe1d
    int32_t * v4 = (int32_t *)((v3 | v1) - 0x5cc52); // 0x1000fe29
    *v4 = *v4 + 0x900a4fe;
    int32_t v5; // 0x1000fe1d
    __asm_out(254, v5);
    int32_t v6; // 0x1000fe1d
    char * v7 = (char *)(v6 - 117); // 0x1000fe3b
    *v7 = *v7 ^ 80;
    int32_t v8 = *(int32_t *)0x25ad7418; // 0x1000fe49
    int32_t v9; // 0x1000fe1d
    int32_t v10 = v8 + v9; // 0x1000fe49
    if (v10 < 0 == ((v10 ^ v9) & (v10 ^ v8)) < 0 == (v10 != 0)) {
        function_1000fe08();
    }
    // 0x1000fe53
    return 0x258aa660;
}

// Address range: 0x1000fe70 - 0x1001004b
int32_t function_1000fe70(int32_t result, int32_t a2) {
    // 0x1000fe70
    int32_t v1; // 0x1000fe70
    int32_t v2; // 0x1000fe70
    bool v3; // 0x1000fe70
    if (v3) {
        // 0x1000fe72
        bool v4; // 0x1000fe70
        *(char *)v1 = (char)v2 + (char)v1 + (char)v4;
        return result;
    }
    // 0x1000feae
    int32_t v5; // 0x1000fe70
    int32_t v6 = v5 >> 31; // 0x1000feb0
    unsigned char v7 = (char)v5 ^ -126; // 0x1000feb5
    unsigned char v8 = *(char *)v6 + v7; // 0x1000feb5
    int32_t result2 = __asm_wait(); // 0x1000feb7
    int32_t v9; // 0x1000fe70
    char * v10 = (char *)(v9 - 0xaccf6c); // 0x1000feb8
    unsigned char v11 = *v10; // 0x1000feb8
    unsigned char v12 = (char)v2 & 31; // 0x1000feb8
    bool v13 = v8 < v7; // 0x1000feb8
    if (v12 != 0) {
        char v14 = v11 >> v12 | v11 << 8 - v12; // 0x1000feb8
        *v10 = v14;
        v13 = v14 < 0;
    }
    if (v8 == 0 || v13) {
        // 0x1000fe9e
        return result2;
    }
    // 0x1000fec1
    int32_t v15; // 0x1000fe70
    int32_t v16 = *(int32_t *)(v1 + 79) | v15; // 0x1000feb2
    int32_t v17 = v9 - 1; // 0x1000fec1
    unsigned char v18 = (char)result2; // 0x1000fec2
    unsigned char v19 = v18 - 70; // 0x1000fec2
    bool v20 = v18 > 69 | v19 > 153;
    char v21 = v20 ? v18 + 90 : v19;
    unsigned char v22 = (v18 & 14) > 5 | (v19 & 14) > 9 ? (v20 ? -102 : -6) + v19 : v21;
    int32_t * v23 = (int32_t *)(v16 + 12); // 0x1000fec5
    *v23 = v16 + (int32_t)v20 + *v23;
    int32_t v24 = (result2 & -256 | (int32_t)v22) + 0x75c28933; // 0x1000feca
    __asm_out_6((int16_t)v6, v24);
    uint32_t v25 = v24 & -0xff01 | 0xc100; // 0x1000fed1
    *(int32_t *)v16 = v25;
    int32_t v26 = v17; // bp-1, 0x1000fed6
    int32_t v27; // 0x1000fe70
    int32_t v28 = 2 * v27;
    char * v29 = (char *)((int32_t)&v26 + 68 + v28); // 0x1000fed7
    unsigned char v30 = *v29; // 0x1000fed7
    int32_t v31 = v28; // 0x1000fed7
    v26 = v17;
    if (v12 != 0) {
        *v29 = v30 >> 8 - v12 | v30 << v12;
        v31 = 2 * v27;
    }
    int32_t v32 = v26; // 0x1000fedc
    uint32_t v33 = v2 - 1; // 0x1000fedb
    int32_t * v34 = (int32_t *)v25; // 0x1000fedd
    int32_t v35 = *v34; // 0x1000fedd
    char * v36 = (char *)(v31 + 91 + v32); // 0x1000fee1
    char v37 = v33 / 256; // 0x1000fee1
    char v38 = *v36 | v37; // 0x1000fee1
    *v36 = v38;
    if (v38 >= 0 != v38 != 0) {
        // 0x1000fee7
        return v25 - 1;
    }
    int32_t v39 = __asm_hlt(); // 0x1000ff65
    int32_t v40 = v39 + 0x1c3a9100 + (int32_t)(v25 < *v34); // 0x1000ff67
    if (v40 == 0) {
        // 0x1000ff6e
        *(char *)v35 = (char)v40;
        *(char *)(v35 - 1) = *(char *)&v27;
        return v40 + 1;
    }
    int32_t v41 = *(int32_t *)v32; // 0x1000ffe7
    int32_t v42 = v27 - 4; // 0x1000ffef
    v27 = v42;
    char * v43 = (char *)v42; // 0x1000fff0
    unsigned char v44 = *v43; // 0x1000fff0
    char v45 = v44 + v37; // 0x1000fff0
    *v43 = v45;
    *(int32_t *)(v32 - 2) = v32 + 2;
    if (v45 < 0 == ((v45 ^ v44) & (v45 ^ v37)) < 0 == (v45 != 0)) {
        int32_t result3 = (((v45 < v44 ? 0 : 255) | v40 & -256) ^ 26) - 1; // 0x10010042
        char * v46 = (char *)result3; // 0x10010043
        *v46 = *v46 + 4 * (char)result3;
        return result3;
    }
    int32_t v47 = v39 >> 31; // 0x1000ff66
    __asm_outsd((int16_t)v47, *(int32_t *)v27);
    if ((*(char *)0x47bdcfa ^ -128) < 0) {
        function_98115606();
    }
    int64_t v48 = result; // 0x10010001
    *(int32_t *)(v32 - 6) = v27;
    uint32_t v49 = __asm_int3(); // 0x10010009
    char v50 = *(char *)(v2 + 0x48605058 + 8 * v27); // 0x1001000a
    unsigned char v51 = v37 + (char)(0x1aaa71cc * v48 != 0x1aaa71cc00000000 * v48 / 0x100000000) - v50; // 0x1001000a
    uint32_t v52 = *(int32_t *)(256 * (int32_t)v51 | v33 & -0xff01); // 0x10010015
    *(int32_t *)(v32 - 10) = v49;
    int32_t v53 = v41 + 1; // 0x10010019
    if (v53 < 0 != (v53 & (v41 ^ -0x80000000)) < 0) {
        // 0x1000ffde
        return *(int32_t *)(v32 + 18) + 0x2b92704c;
    }
    int32_t v54 = v49 - v52; // 0x10010015
    char v55 = llvm_ctpop_i8((char)v54); // 0x10010015
    int64_t v56 = *(int64_t *)(v49 & -0xff01 | 256 * (64 * (int32_t)(v54 == 0) | (int32_t)(v49 < v52) | 128 * (int32_t)(v54 < 0) | 16 * (int32_t)((v49 & 15) - (v52 & 15) > 15) | 4 * (int32_t)((v55 & 1) == 0)) | 512); // 0x1001001c
    int64_t v57; // 0x1000fe70
    __asm_pslld(v57, v56);
    int32_t v58 = *(int32_t *)-0x49b8ac96; // 0x10010023
    unsigned char v59 = *(char *)0x2c856b53; // 0x10010029
    *(int32_t *)(v32 - 14) = 102;
    unsigned char v60 = (char)v47; // 0x10010031
    unsigned char v61 = (char)result + 1 + v60; // 0x10010031
    unsigned char v62 = v61 + (char)(v59 < v51); // 0x10010031
    *(int32_t *)(v35 - 4) = __asm_insd((int16_t)(v47 & 0xff00 | (int32_t)v62));
    char v63 = v58; // 0x10010035
    char v64 = v59 < v51 ? v62 <= v60 : v61 < v60; // 0x10010035
    char v65 = v63 - 104 + v64; // 0x10010035
    bool v66 = (v63 & 15) + 8 + v64 > 15 | (v65 & 14) > 9; // 0x10010037
    char v67 = v66 ? v65 + 10 : v65; // 0x10010037
    return v58 & -0x10000 | (int32_t)(v67 & 15) | 256 * (int32_t)v66 + v58 & 0xff00;
}

// Address range: 0x13cf632b - 0x13cf632c
int32_t function_13cf632b(void) {
    // 0x13cf632b
    int32_t result; // 0x13cf632b
    return result;
}

// Address range: 0x156e638a - 0x156e638b
int32_t function_156e638a(void) {
    // 0x156e638a
    int32_t result; // 0x156e638a
    return result;
}

// Address range: 0x194b8e18 - 0x194b8e19
int32_t function_194b8e18(void) {
    // 0x194b8e18
    int32_t result; // 0x194b8e18
    return result;
}

// Address range: 0x1a054105 - 0x1a054106
int32_t function_1a054105(void) {
    // 0x1a054105
    int32_t result; // 0x1a054105
    return result;
}

// Address range: 0x1b7c7a9c - 0x1b7c7a9d
int32_t function_1b7c7a9c(void) {
    // 0x1b7c7a9c
    int32_t result; // 0x1b7c7a9c
    return result;
}

// Address range: 0x20004389 - 0x2000438a
int32_t function_20004389(void) {
    // 0x20004389
    int32_t result; // 0x20004389
    return result;
}

// Address range: 0x20011b4a - 0x20011b4b
int32_t function_20011b4a(void) {
    // 0x20011b4a
    int32_t result; // 0x20011b4a
    return result;
}

// Address range: 0x250a2048 - 0x250a2049
int32_t function_250a2048(void) {
    // 0x250a2048
    int32_t result; // 0x250a2048
    return result;
}

// Address range: 0x2823af96 - 0x2823af97
int32_t function_2823af96(void) {
    // 0x2823af96
    int32_t result; // 0x2823af96
    return result;
}

// Address range: 0x2bc0b70f - 0x2bc0b710
int32_t function_2bc0b70f(void) {
    // 0x2bc0b70f
    int32_t result; // 0x2bc0b70f
    return result;
}

// Address range: 0x2e6e678a - 0x2e6e678b
int32_t function_2e6e678a(void) {
    // 0x2e6e678a
    int32_t result; // 0x2e6e678a
    return result;
}

// Address range: 0x31b0023a - 0x31b0023b
int32_t function_31b0023a(void) {
    // 0x31b0023a
    int32_t result; // 0x31b0023a
    return result;
}

// Address range: 0x34b9a97b - 0x34b9a97c
int32_t function_34b9a97b(void) {
    // 0x34b9a97b
    int32_t result; // 0x34b9a97b
    return result;
}

// Address range: 0x34d67382 - 0x34d67383
int32_t function_34d67382(void) {
    // 0x34d67382
    int32_t result; // 0x34d67382
    return result;
}

// Address range: 0x38ef82c2 - 0x38ef82c3
int32_t function_38ef82c2(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x38ef82c2
    int32_t result; // 0x38ef82c2
    return result;
}

// Address range: 0x4c53012a - 0x4c53012b
int32_t function_4c53012a(char a1) {
    // 0x4c53012a
    int32_t result; // 0x4c53012a
    return result;
}

// Address range: 0x4c5306d4 - 0x4c5306d5
int32_t function_4c5306d4(void) {
    // 0x4c5306d4
    int32_t result; // 0x4c5306d4
    return result;
}

// Address range: 0x4f4705ff - 0x4f470600
int32_t function_4f4705ff(void) {
    // 0x4f4705ff
    int32_t result; // 0x4f4705ff
    return result;
}

// Address range: 0x5812ebe8 - 0x5812ebe9
int32_t function_5812ebe8(void) {
    // 0x5812ebe8
    int32_t result; // 0x5812ebe8
    return result;
}

// Address range: 0x59a094e2 - 0x59a094e3
int32_t function_59a094e2(void) {
    // 0x59a094e2
    int32_t result; // 0x59a094e2
    return result;
}

// Address range: 0x59ec125e - 0x59ec125f
int32_t function_59ec125e(void) {
    // 0x59ec125e
    int32_t result; // 0x59ec125e
    return result;
}

// Address range: 0x5cb9a97b - 0x5cb9a97c
int32_t function_5cb9a97b(void) {
    // 0x5cb9a97b
    int32_t result; // 0x5cb9a97b
    return result;
}

// Address range: 0x638f0c83 - 0x638f0c84
int32_t function_638f0c83(void) {
    // 0x638f0c83
    int32_t result; // 0x638f0c83
    return result;
}

// Address range: 0x662b4dd6 - 0x662b4dd7
int32_t function_662b4dd6(void) {
    // 0x662b4dd6
    int32_t result; // 0x662b4dd6
    return result;
}

// Address range: 0x6eea93c6 - 0x6eea93c7
int32_t function_6eea93c6(void) {
    // 0x6eea93c6
    int32_t result; // 0x6eea93c6
    return result;
}

// Address range: 0x724b2866 - 0x724b2867
int32_t function_724b2866(void) {
    // 0x724b2866
    int32_t result; // 0x724b2866
    return result;
}

// Address range: 0x76c44af5 - 0x76c44af6
int32_t function_76c44af5(void) {
    // 0x76c44af5
    int32_t result; // 0x76c44af5
    return result;
}

// Address range: 0x76ce0d83 - 0x76ce0d84
int32_t function_76ce0d83(int32_t a1) {
    // 0x76ce0d83
    int32_t result; // 0x76ce0d83
    return result;
}

// Address range: 0x792c82ca - 0x792c82cb
int32_t function_792c82ca(void) {
    // 0x792c82ca
    int32_t result; // 0x792c82ca
    return result;
}

// Address range: 0x7ae8ac7b - 0x7ae8ac7c
int32_t function_7ae8ac7b(void) {
    // 0x7ae8ac7b
    int32_t result; // 0x7ae8ac7b
    return result;
}

// Address range: 0x804ec438 - 0x804ec439
int32_t function_804ec438(void) {
    // 0x804ec438
    int32_t result; // 0x804ec438
    return result;
}

// Address range: 0x826e4b8a - 0x826e4b8b
int32_t function_826e4b8a(void) {
    // 0x826e4b8a
    int32_t result; // 0x826e4b8a
    return result;
}

// Address range: 0x82c00b4a - 0x82c00b4b
int32_t function_82c00b4a(void) {
    // 0x82c00b4a
    int32_t result; // 0x82c00b4a
    return result;
}

// Address range: 0x82c07b4a - 0x82c07b4b
int32_t function_82c07b4a(void) {
    // 0x82c07b4a
    int32_t result; // 0x82c07b4a
    return result;
}

// Address range: 0x82c0e74a - 0x82c0e74b
int32_t function_82c0e74a(void) {
    // 0x82c0e74a
    int32_t result; // 0x82c0e74a
    return result;
}

// Address range: 0x82c2774a - 0x82c2774b
int32_t function_82c2774a(void) {
    // 0x82c2774a
    int32_t result; // 0x82c2774a
    return result;
}

// Address range: 0x82c35f4a - 0x82c35f4b
int32_t function_82c35f4a(void) {
    // 0x82c35f4a
    int32_t result; // 0x82c35f4a
    return result;
}

// Address range: 0x850a14c6 - 0x850a14c7
int32_t function_850a14c6(void) {
    // 0x850a14c6
    int32_t result; // 0x850a14c6
    return result;
}

// Address range: 0x860e752d - 0x860e752e
int32_t function_860e752d(void) {
    // 0x860e752d
    int32_t result; // 0x860e752d
    return result;
}

// Address range: 0x887ff032 - 0x887ff033
int32_t function_887ff032(void) {
    // 0x887ff032
    int32_t result; // 0x887ff032
    return result;
}

// Address range: 0x89c8b28b - 0x89c8b28c
int32_t function_89c8b28b(void) {
    // 0x89c8b28b
    int32_t result; // 0x89c8b28b
    return result;
}

// Address range: 0x8e140c55 - 0x8e140c56
int32_t function_8e140c55(void) {
    // 0x8e140c55
    int32_t result; // 0x8e140c55
    return result;
}

// Address range: 0x8fa93699 - 0x8fa9369a
int32_t function_8fa93699(void) {
    // 0x8fa93699
    int32_t result; // 0x8fa93699
    return result;
}

// Address range: 0x938aaf2d - 0x938aaf2e
int32_t function_938aaf2d(void) {
    // 0x938aaf2d
    int32_t result; // 0x938aaf2d
    return result;
}

// Address range: 0x98115606 - 0x98115607
int32_t function_98115606(void) {
    // 0x98115606
    int32_t result; // 0x98115606
    return result;
}

// Address range: 0x99ec2826 - 0x99ec2827
int32_t function_99ec2826(int16_t a1) {
    // 0x99ec2826
    int32_t result; // 0x99ec2826
    return result;
}

// Address range: 0x9b59eb7c - 0x9b59eb7d
int32_t function_9b59eb7c(void) {
    // 0x9b59eb7c
    int32_t result; // 0x9b59eb7c
    return result;
}

// Address range: 0x9dd14627 - 0x9dd14628
int32_t function_9dd14627(void) {
    // 0x9dd14627
    int32_t result; // 0x9dd14627
    return result;
}

// Address range: 0xa6ac3c7b - 0xa6ac3c7c
int32_t function_a6ac3c7b(void) {
    // 0xa6ac3c7b
    int32_t result; // 0xa6ac3c7b
    return result;
}

// Address range: 0xa700e3d4 - 0xa700e3d5
int32_t function_a700e3d4(void) {
    // 0xa700e3d4
    int32_t result; // 0xa700e3d4
    return result;
}

// Address range: 0xa9a42bcf - 0xa9a42bd0
int32_t function_a9a42bcf(void) {
    // 0xa9a42bcf
    int32_t result; // 0xa9a42bcf
    return result;
}

// Address range: 0xab3626a2 - 0xab3626a3
int32_t function_ab3626a2(int32_t a1) {
    // 0xab3626a2
    int32_t result; // 0xab3626a2
    return result;
}

// Address range: 0xac770516 - 0xac770517
int32_t function_ac770516(void) {
    // 0xac770516
    int32_t result; // 0xac770516
    return result;
}

// Address range: 0xb1fc5741 - 0xb1fc5742
int32_t function_b1fc5741(void) {
    // 0xb1fc5741
    int32_t result; // 0xb1fc5741
    return result;
}

// Address range: 0xb39003fa - 0xb39003fb
int32_t function_b39003fa(void) {
    // 0xb39003fa
    int32_t result; // 0xb39003fa
    return result;
}

// Address range: 0xb4360ac2 - 0xb4360ac3
int32_t function_b4360ac2(void) {
    // 0xb4360ac2
    int32_t result; // 0xb4360ac2
    return result;
}

// Address range: 0xb5f8a065 - 0xb5f8a066
int32_t function_b5f8a065(void) {
    // 0xb5f8a065
    int32_t result; // 0xb5f8a065
    return result;
}

// Address range: 0xb6fce7ee - 0xb6fce7ef
int32_t function_b6fce7ee(void) {
    // 0xb6fce7ee
    int32_t result; // 0xb6fce7ee
    return result;
}

// Address range: 0xc3024dda - 0xc3024ddb
int32_t function_c3024dda(void) {
    // 0xc3024dda
    int32_t result; // 0xc3024dda
    return result;
}

// Address range: 0xc782bb45 - 0xc782bb46
int32_t function_c782bb45(int16_t a1) {
    // 0xc782bb45
    int32_t result; // 0xc782bb45
    return result;
}

// Address range: 0xc90d0b57 - 0xc90d0b58
int32_t function_c90d0b57(void) {
    // 0xc90d0b57
    int32_t result; // 0xc90d0b57
    return result;
}

// Address range: 0xce235ce3 - 0xce235ce4
int32_t function_ce235ce3(void) {
    // 0xce235ce3
    int32_t result; // 0xce235ce3
    return result;
}

// Address range: 0xd4ac3cfd - 0xd4ac3cfe
int32_t function_d4ac3cfd(void) {
    // 0xd4ac3cfd
    int32_t result; // 0xd4ac3cfd
    return result;
}

// Address range: 0xd4bc725f - 0xd4bc7260
int32_t function_d4bc725f(int16_t a1) {
    // 0xd4bc725f
    int32_t result; // 0xd4bc725f
    return result;
}

// Address range: 0xd4ce28ce - 0xd4ce28cf
int32_t function_d4ce28ce(void) {
    // 0xd4ce28ce
    int32_t result; // 0xd4ce28ce
    return result;
}

// Address range: 0xd4eaf4e8 - 0xd4eaf4e9
int32_t function_d4eaf4e8(int32_t a1) {
    // 0xd4eaf4e8
    int32_t result; // 0xd4eaf4e8
    return result;
}

// Address range: 0xd4eafac3 - 0xd4eafac4
int32_t function_d4eafac3(int32_t a1) {
    // 0xd4eafac3
    int32_t result; // 0xd4eafac3
    return result;
}

// Address range: 0xd6c0a0d0 - 0xd6c0a0d1
int32_t function_d6c0a0d0(int32_t a1) {
    // 0xd6c0a0d0
    int32_t result; // 0xd6c0a0d0
    return result;
}

// Address range: 0xd81bbc05 - 0xd81bbc06
int32_t function_d81bbc05(void) {
    // 0xd81bbc05
    int32_t result; // 0xd81bbc05
    return result;
}

// Address range: 0xd81c0bff - 0xd81c0c00
int32_t function_d81c0bff(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0xd81c0bff
    int32_t result; // 0xd81c0bff
    return result;
}

// Address range: 0xd8458d0c - 0xd8458d0d
int32_t function_d8458d0c(void) {
    // 0xd8458d0c
    int32_t result; // 0xd8458d0c
    return result;
}

// Address range: 0xd933c1ec - 0xd933c1ed
int32_t function_d933c1ec(void) {
    // 0xd933c1ec
    int32_t result; // 0xd933c1ec
    return result;
}

// Address range: 0xdcef8262 - 0xdcef8263
int32_t function_dcef8262(void) {
    // 0xdcef8262
    int32_t result; // 0xdcef8262
    return result;
}

// Address range: 0xdf0d09de - 0xdf0d09df
int32_t function_df0d09de(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0xdf0d09de
    int32_t result; // 0xdf0d09de
    return result;
}

// Address range: 0xe05061f4 - 0xe05061f5
int32_t function_e05061f4(void) {
    // 0xe05061f4
    int32_t result; // 0xe05061f4
    return result;
}

// Address range: 0xe0b4d242 - 0xe0b4d243
int32_t function_e0b4d242(void) {
    // 0xe0b4d242
    int32_t result; // 0xe0b4d242
    return result;
}

// Address range: 0xe99a084a - 0xe99a084b
int32_t function_e99a084a(void) {
    // 0xe99a084a
    int32_t result; // 0xe99a084a
    return result;
}

// Address range: 0xf06e538a - 0xf06e538b
int32_t function_f06e538a(void) {
    // 0xf06e538a
    int32_t result; // 0xf06e538a
    return result;
}

// Address range: 0xf06e7f8a - 0xf06e7f8b
int32_t function_f06e7f8a(void) {
    // 0xf06e7f8a
    int32_t result; // 0xf06e7f8a
    return result;
}

// Address range: 0xf06eaf8a - 0xf06eaf8b
int32_t function_f06eaf8a(void) {
    // 0xf06eaf8a
    int32_t result; // 0xf06eaf8a
    return result;
}

// Address range: 0xf50ace15 - 0xf50ace16
int32_t function_f50ace15(void) {
    // 0xf50ace15
    int32_t result; // 0xf50ace15
    return result;
}

// Address range: 0xf56e738a - 0xf56e738b
int32_t function_f56e738a(void) {
    // 0xf56e738a
    int32_t result; // 0xf56e738a
    return result;
}

// Address range: 0xf5804983 - 0xf5804984
int32_t function_f5804983(void) {
    // 0xf5804983
    int32_t result; // 0xf5804983
    return result;
}

// Address range: 0xf88b5e19 - 0xf88b5e1a
int32_t function_f88b5e19(int32_t a1) {
    // 0xf88b5e19
    int32_t result; // 0xf88b5e19
    return result;
}

// Address range: 0xf98150ec - 0xf98150ed
int32_t function_f98150ec(void) {
    // 0xf98150ec
    int32_t result; // 0xf98150ec
    return result;
}

// Address range: 0xfaf63c48 - 0xfaf63c49
int32_t function_faf63c48(int32_t a1, int32_t a2, int16_t a3) {
    // 0xfaf63c48
    int32_t result; // 0xfaf63c48
    return result;
}

// Address range: 0xfaf648fe - 0xfaf648ff
int32_t function_faf648fe(void) {
    // 0xfaf648fe
    int32_t result; // 0xfaf648fe
    return result;
}

// Address range: 0xfb12c512 - 0xfb12c513
int32_t function_fb12c512(void) {
    // 0xfb12c512
    int32_t result; // 0xfb12c512
    return result;
}

// Address range: 0xfc75ff0d - 0xfc75ff0e
int32_t function_fc75ff0d(void) {
    // 0xfc75ff0d
    int32_t result; // 0xfc75ff0d
    return result;
}

// Address range: 0xfffffaff - 0xfffffb00
int32_t function_fffffaff(void) {
    // 0xfffffaff
    int32_t result; // 0xfffffaff
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// BOOL CloseHandle(_In_ HANDLE hObject);
// struct hostent * gethostbyaddr(const char * addr, _In_ int len, _In_ int type);
// LPSTR lstrcpyA(LPSTR lpString1, _In_ LPCSTR lpString2);
// LSTATUS RegCloseKey(_In_ HKEY hKey);
// LSTATUS RegQueryValueExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, LPDWORD lpReserved, _Out_opt_ LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// DWORD WaitForSingleObject(_In_ HANDLE hHandle, _In_ DWORD dwMilliseconds);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (7.1)
// Detected functions: 419
