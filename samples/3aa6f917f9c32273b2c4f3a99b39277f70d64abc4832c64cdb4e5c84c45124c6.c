//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int80_t;
typedef int64_t int224_t;
typedef int64_t int864_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float80_t;

// ------------------- Function Prototypes --------------------

int32_t Activate(void);
int32_t DllCanUnloadNow(int16_t a1, int32_t a2, int32_t a3);
int32_t DllGetClassObject(int32_t a1);
int32_t entry_point(int32_t a1);
int32_t function_10001000(void);
int32_t function_10001006(int32_t a1);
int32_t function_10001009(int32_t a1);
int32_t function_1000104b(int16_t a1, int32_t a2);
int32_t function_10001231(void);
int32_t function_10001249(void);
int32_t function_10001299(int32_t a1, int32_t a2, int16_t a3);
int32_t function_10001385(int32_t a1);
int32_t function_1000146e(int32_t a1);
int32_t function_10001529(int32_t a1, int32_t a2);
int32_t function_1000156c(void);
int32_t function_10001585(void);
int32_t function_1000158b(void);
int32_t function_10001591(int32_t a1);
int32_t function_100015ef(int32_t a1, int32_t result);
int32_t function_1000183e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
float80_t function_10001c8e(int32_t a1, int32_t a2);
int32_t function_10001ce4(void);
int32_t function_10001cf6(int32_t a1);
int32_t function_10001d09(int32_t a1);
int32_t function_10001d31(void);
int32_t function_10001d3a(void);
int32_t function_10001d4c(void);
int32_t function_10001d81(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t result);
int32_t function_10001dcc(void);
int32_t function_10001e09(int32_t * a1, int32_t a2);
int32_t function_10001e47(void);
int32_t function_10001e54(int32_t a1);
int32_t function_10001e59(int32_t a1, int32_t a2, int32_t a3);
float80_t function_10001ec3(int32_t a1);
int32_t function_10001ec9(void);
int32_t function_10001ecc(int32_t a1);
int32_t function_10001f34(int32_t a1);
int32_t function_10001f39(int32_t a1);
int32_t function_10001f40(void);
int32_t function_10001f67(void);
int32_t function_10001f80(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t result, int32_t a8);
int32_t function_10001fa8(int32_t a1);
int32_t function_10001fd1(int32_t a1);
int32_t function_10001fd3(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_100020cf(int32_t a1);
int32_t function_100020da(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_10002228(void);
int32_t function_10002250(int32_t a1);
int32_t function_10002286(int32_t a1);
int32_t function_100022c6(int32_t a1);
int32_t function_100022de(int32_t a1);
int32_t function_100022ef(void);
int32_t function_100022f2(void);
int32_t function_10002315(void);
int32_t function_1000231a(int32_t a1);
int32_t function_1000240f(int32_t a1);
int32_t function_100024de(int32_t a1, int32_t a2);
int32_t function_10002691(int32_t a1);
int32_t function_1000269d(void);
int32_t function_100026f8(int32_t a1, int32_t a2);
int32_t function_100027e0(int32_t a1);
int32_t function_10002819(int32_t a1);
int32_t function_10002a17(int32_t a1);
int32_t function_10002a3a(void);
int32_t function_10002a3d(void);
int32_t function_10002a43(int32_t a1);
int32_t function_10002ad0(void);
int32_t function_10002b06(void);
int32_t function_10002b0f(void);
int32_t function_10002b40(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, uint32_t a7);
int32_t function_10002b49(int32_t a1);
int32_t function_10002b60(void);
int32_t function_10002b62(void);
int32_t function_10002bd5(void);
int32_t function_10002bdc(void);
int32_t function_10002be6(void);
int32_t function_10002c2c(int32_t a1, int32_t a2);
int32_t function_10002d34(int32_t a1);
int32_t function_10002d66(void);
int32_t function_10002dc8(int32_t a1, int32_t a2);
int32_t function_10002e63(void);
int32_t function_10002e9d(void);
int32_t function_10002f0c(void);
int32_t function_10003035(void);
int32_t function_10003059(void);
int32_t function_10003061(void);
int32_t function_100030a4(void);
int32_t function_100030b1(void);
int32_t function_100030b4(void);
int32_t function_10003119(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_1000311e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17, int32_t a18, int32_t a19);
int32_t function_1000f000(int32_t a1);
int32_t function_1000f06d(int32_t a1);
int32_t function_1000f0d2(void);
int32_t function_1000f0da(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1000f3d3(int32_t a1, int32_t a2);
int32_t function_1000f4d4(void);
int32_t function_1000f510(int32_t a1);
int32_t function_1000f54d(int16_t a1, int32_t a2);
int32_t function_1000f612(int32_t a1);
int32_t function_1000f635(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1000f65f(void);
int32_t function_1000f67f(void);
int32_t function_1000f6b6(int32_t a1, int32_t a2);
int32_t function_1000f6e0(int32_t a1);
int32_t function_1000f6e7(void);
int32_t function_1000f6ef(void);
int32_t function_1000f712(int32_t a1);
int32_t function_1000f745(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1000f896(int32_t a1);
int32_t function_1000f901(int32_t a1, int32_t a2);
int32_t function_1000f920(void);
int32_t function_1000f959(void);
int32_t function_1000f977(void);
int32_t function_1000f9a3(void);
int32_t function_1000f9bc(int32_t a1);
int32_t function_1000f9ef(void);
int32_t function_1000fa03(int32_t a1);
int32_t function_1000fa06(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1000fac2(void);
int32_t function_1000fadb(void);
int32_t function_1000fae7(void);
float80_t function_1000fb3b(void);
int32_t function_1000fb4b(void);
int32_t function_1000fb51(void);
int32_t function_1000fb59(void);
int32_t function_1000fb5f(int32_t a1);
int32_t function_1000fc2a(void);
int32_t function_1000fc58(int32_t a1);
int32_t function_1000fcd6(void);
float80_t function_1000fcee(int32_t a1);
int32_t function_1000fd15(int32_t a1);
int32_t function_1000fd42(int32_t a1);
int32_t function_1000fd56(void);
int32_t function_1000fe22(void);
int32_t function_1000fe5b(void);
int32_t function_1000fe79(void);
int32_t function_1000fe7d(void);
int32_t function_1000fe82(void);
int32_t function_1000fe97(int32_t a1);
int32_t function_1000feae(void);
int32_t function_1000ff64(void);
int32_t function_1000ff81(void);
int32_t function_10010003(int32_t a1);
int32_t function_18fc1b2e(void);
int32_t function_20100313(void);
int32_t function_20102618(void);
int32_t function_21100900(void);
int32_t function_2112081b(void);
int32_t function_26e9350c(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_408e86e0(void);
int32_t function_40fc2dae(void);
int32_t function_430af841(void);
int32_t function_50f83311(void);
int32_t function_538bd497(void);
int32_t function_5d856cf6(void);
int32_t function_5f04685d(void);
int32_t function_5f4c0d41(void);
int32_t function_5f4c1369(void);
int32_t function_6011fd41(int32_t a1);
int32_t function_64838f02(void);
int32_t function_659d7799(void);
int32_t function_6d04b19d(void);
int32_t function_7d986499(int32_t * a1);
int32_t function_81afbfe9(void);
int32_t function_8339657e(void);
int32_t function_83d86165(int32_t a1);
int32_t function_848da803(int32_t a1, int32_t a2, int32_t a3, int16_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int16_t a9);
int32_t function_859a3b22(void);
int32_t function_862bafd7(void);
int32_t function_881eb438(void);
int32_t function_8ae809aa(void);
int32_t function_939881e9(void);
int32_t function_970ba832(void);
int32_t function_996e57db(void);
int32_t function_99a0aee4(void);
int32_t function_a0b6c769(void);
int32_t function_a1101dfb(void);
int32_t function_a8140a05(void);
int32_t function_bfd67d2f(void);
int32_t function_bfd8060b(void);
int32_t function_bfd82e63(void);
int32_t function_c382b151(void);
int32_t function_c4b397e7(void);
int32_t function_c5bf3eed(void);
int32_t function_c83510b6(void);
int32_t function_c8d61b19(void);
int32_t function_c8ef5fdf(void);
int32_t function_c9b23e0d(void);
int32_t function_ccdf35e9(void);
int32_t function_ccdf3b3d(void);
int32_t function_d693b9bf(void);
int32_t function_d7759eab(void);
int32_t function_d888f01c(void);
int32_t function_d923f68f(void);
int32_t function_defb46d3(int16_t a1);
int32_t function_dfeff415(int32_t a1);
int32_t function_e1100804(void);
int32_t function_e3c821de(int32_t a1);
int32_t function_eb9dd052(int16_t a1);
int32_t function_ec4dffe4(void);
int32_t function_ef4d59b8(void);
int32_t function_efed5692(void);
int32_t function_f589cf09(void);
int32_t function_fb8dba02(void);
int32_t function_fbf7bf95(void);
int32_t function_fc95d1e3(void);
int32_t function_fd81bf13(void);
int32_t function_fff819a4(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_fff81cf8(void);
int32_t function_ffffb8a3(void);
int32_t HookProc(int32_t a1);
int32_t Logoff(int32_t a1, int32_t a2);
int32_t Logon(void);
int32_t Start(int32_t a1, int32_t a2);
int32_t unknown_103f106a(int16_t a1);
int32_t unknown_1063218c(void);
int32_t unknown_20007338(void);
int32_t unknown_2000bfe8(void);
int32_t unknown_21101d27(void);
int32_t unknown_2e3c(int32_t a1);
int32_t unknown_5b64bc56(void);
int32_t unknown_6091a230(void);
int32_t unknown_60f2b89b(void);
int32_t unknown_655c934b(int16_t a1);
int32_t unknown_69ddfc9(void);
int32_t unknown_72673651(void);
int32_t unknown_9041f8c9(void);
int32_t unknown_b15a058(void);
int32_t unknown_ce1502f9(void);
int32_t unknown_d5b6d334(void);
int32_t unknown_f028d10b(void);
int32_t unknown_fc350e(void);
int32_t unknown_fffb017(void);

// --------------------- Global Variables ---------------------

char * g1; // 0x1000622c
char g2 = 0; // 0x1000622d
int32_t g3 = 0; // 0x1000622e
int16_t * g4 = NULL; // 0x10006230
char g5 = 1; // 0x1000d0c6
int32_t g6;

// ------------------------ Functions -------------------------

// Address range: 0x10001000 - 0x10001006
int32_t function_10001000(void) {
    // 0x10001000
    return function_18fc1b2e();
}

// Address range: 0x10001006 - 0x10001009
int32_t function_10001006(int32_t a1) {
    // 0x10001006
    int32_t result; // 0x10001006
    return result;
}

// Address range: 0x10001009 - 0x10001049
int32_t function_10001009(int32_t a1) {
    // 0x10001009
    int32_t v1; // 0x10001009
    unsigned char v2 = (char)v1; // 0x1000100a
    bool v3; // 0x10001009
    bool v4 = v2 > 153 | v3;
    int32_t v5; // 0x10001009
    bool v6; // 0x10001009
    if (v6 || (v2 & 14) > 9) {
        v5 = (v4 ? 102 : 6) + v1 & 255 | v1 & -256;
    } else {
        v5 = (v4 ? v1 + 96 : v1) & 255 | v1 & -256;
    }
    int32_t v7; // 0x10001009
    int64_t v8 = (int64_t)*(int32_t *)(v7 + 52); // 0x1000100b
    int64_t v9 = -114 * v8; // 0x1000100b
    int32_t v10; // 0x10001009
    int32_t * v11 = (int32_t *)((a1 & -256 | (int32_t)*(char *)(v10 + 12)) + 48); // 0x10001013
    *v11 = *v11 - 0x8ab7536 + (int32_t)(v9 != -0x7200000000 * v8 / 0x100000000);
    int32_t v12 = v5 & -0x6ca56c58; // 0x1000101b
    *(int32_t *)(((int32_t)v9 | 1) - 4) = 79;
    int32_t v13; // 0x10001009
    __asm_into(v13);
    int32_t v14; // 0x10001009
    int32_t v15 = v14;
    *(char *)v15 = *(char *)&v14 + (char)v15;
    int32_t * v16 = (int32_t *)(v12 + 2 * v10); // 0x10001029
    *v16 = *v16 - 0x948f1af;
    int32_t v17 = v12 | (int32_t)&g1; // 0x10001034
    int32_t v18 = v17; // 0x10001039
    int32_t v19; // 0x10001009
    if (v17 >= 0) {
        // 0x1000103b
        v18 = v17 + v19 & 255 | v17 & -256;
    }
    char * v20 = (char *)v18; // 0x10001044
    *v20 = *v20 + (char)v19;
    return v18 ^ 142;
}

// Address range: 0x1000104b - 0x100010e6
int32_t function_1000104b(int16_t a1, int32_t a2) {
    // 0x1000104b
    int32_t v1; // 0x1000104b
    unsigned char v2 = (char)v1;
    char v3 = v2 / 128; // 0x1000104b
    *(char *)v1 = v3 | 2 * v2;
    int32_t v4; // 0x1000104b
    char * v5 = (char *)(v4 + 104); // 0x1000104d
    char v6 = *v5; // 0x1000104d
    char v7 = v3 != 0; // 0x1000104d
    *v5 = v7 + v2 + v6;
    bool v8 = (v1 & 14) > 9 | (v2 & 15) + v7 + (v6 & 15) > 15; // 0x10001051
    int32_t v9 = v8 ? v1 + 10 : v1; // 0x10001051
    int32_t result = (v9 & 15) + 8 | v1 & -0x10000 | 256 * (int32_t)v8 + v1 & 0xff00; // 0x10001052
    char * v10 = (char *)result; // 0x10001057
    int32_t v11; // 0x1000104b
    char v12 = *v10 + (char)v11; // 0x10001057
    *v10 = v12;
    uint32_t v13; // 0x1000104b
    uint32_t v14 = v11 ^ v13; // 0x10001059
    if (v14 == 0) {
        // 0x1000105e
        *v10 = v12 & (char)v13;
        return result;
    }
    int32_t v15 = *(int32_t *)0x60147f13 & -256; // 0x10001072
    char * v16 = (char *)(v15 | (int32_t)(*(char *)-0x1d8ff000 - 96)); // 0x10001079
    char v17 = v14; // 0x10001079
    *v16 = *v16 + v17;
    unsigned char v18 = *(char *)0x1cc31000; // 0x1000107e
    int32_t v19 = v15 | (int32_t)v18; // 0x1000107e
    char * v20 = (char *)v19; // 0x10001084
    unsigned char v21 = *v20; // 0x10001084
    unsigned char v22 = v21 + v17; // 0x10001084
    char v23 = llvm_ctpop_i8(v22); // 0x10001084
    *v20 = v22;
    int32_t v24; // 0x1000104b
    if ((v23 & 1) != 0) {
        if (((v22 ^ v21) & (v22 ^ v17)) >= 0) {
            unsigned char v25 = v22 < v21 ? -90 : -91; // 0x100010a4
            *(char *)v14 = (char)(v13 / 256);
            return v15 | (int32_t)(v18 - 88 - v25 + (char)(v22 < v21 | v25 > v18) & -127);
        }
        // 0x1000108a
        int32_t v26; // 0x1000104b
        __asm_out((int16_t)v14, v26);
        char * v27 = (char *)(v24 - 50); // 0x1000109c
        unsigned char v28 = *v27; // 0x1000109c
        *v27 = v28 - 28;
        char * v29 = (char *)(v4 & -256 | 28); // 0x1000109f
        *v29 = *v29 + (char)(v14 / 256) + (char)(v28 < 28);
        return v26 ^ 0x1000a05c;
    }
    uint32_t v30 = v19 | 0x358402; // 0x100010d0
    char * v31 = (char *)v30; // 0x100010d5
    unsigned char v32 = *v31; // 0x100010d5
    char v33 = v32 / 128; // 0x100010d5
    *v31 = v33 | 2 * v32;
    int32_t v34; // bp-66, 0x1000104b
    char * v35 = (char *)(2 * v24 + (int32_t)&v34); // 0x100010d7
    unsigned char v36 = *v35; // 0x100010d7
    unsigned char v37 = v36 + (char)v30; // 0x100010d7
    unsigned char v38 = v37 + (char)(v33 != 0); // 0x100010d7
    bool v39 = v33 != 0 ? v38 <= v36 : v37 < v36; // 0x100010d7
    *v35 = v38;
    uint32_t result2 = v30 + 0xca5a5c9 + (int32_t)v39; // 0x100010da
    char * v40 = (char *)v14; // 0x100010df
    char v41 = result2; // 0x100010df
    *v40 = *v40 - v41 + (char)(v39 ? result2 <= v30 : v30 > 0xf35a5a36);
    *(char *)0x20184a84 = v41;
    return result2;
}

// Address range: 0x100010e6 - 0x10001229
int32_t DllCanUnloadNow(int16_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a2;
    v1 = a2;
    int32_t v2 = 1; // 0x100010e6
    int32_t v3; // 0x100010e6
    int32_t v4; // 0x100010e6
    int32_t v5; // 0x100010e6
    int32_t result2; // 0x100010e6
    int32_t v6; // 0x100010e6
    int32_t v7; // 0x100010e6
    int32_t v8; // 0x100010e6
    bool v9; // 0x100010e6
    if (!v9) {
        // 0x100010e8
        uint32_t v10; // 0x100010e6
        int32_t v11 = v10 + 96 & 255 | v10 & -256; // 0x100010ea
        char * v12 = (char *)v11; // 0x100010ec
        int32_t v13; // 0x100010e6
        *v12 = *v12 + (char)v13;
        uint32_t v14; // 0x100010e6
        int32_t v15 = (v14 / 0x20000 | 0x8000 * v14) - 1; // 0x100010f3
        uint32_t v16; // 0x100010e6
        unsigned char v17 = (char)(v16 / 256); // 0x100010f4
        char v18 = (v14 & 0x20000) != 0; // 0x100010f4
        unsigned char v19 = (char)(v10 / 256) + v18; // 0x100010f4
        unsigned char v20 = v17 - v19; // 0x100010f4
        int32_t v21 = v11 + 1; // 0x100010f6
        int32_t v22 = (v14 & 0x20000) != 0 ? v19 != -1 | v20 - v18 > v17 : v19 > v17 ? 163 : 162; // 0x100010f7
        int32_t v23 = v21 - v22; // 0x100010f7
        int32_t v24 = v21 & -256; // 0x100010f7
        char * v25 = (char *)(v23 & 255 | v24); // 0x100010f9
        *v25 = *v25 + (char)v6;
        __asm_out_2(2, (char)v23);
        *(char *)v6 = *(char *)&v6;
        int32_t v26; // 0x100010e6
        char * v27 = (char *)(v26 - 57); // 0x10001101
        char v28 = *v27; // 0x10001101
        unsigned char v29 = (char)v15; // 0x10001101
        *v27 = v28 + v29;
        char * v30 = (char *)((v23 + 231 + (int32_t)(-1 - v28 < v29) & 255 | v24) - 0x5dfff276); // 0x1000110b
        *v30 = *v30 + (char)v6;
        *(char *)(v6 + 0x40850042) = v29;
        int32_t * v31 = (int32_t *)(v6 - 0x64f75df9); // 0x1000111a
        uint32_t v32 = *v31; // 0x1000111a
        uint32_t v33 = v15 & 31; // 0x1000111a
        int32_t v34 = v6; // 0x1000111a
        bool v35 = false; // 0x1000111a
        bool v36 = false; // 0x1000111a
        if (v33 != 0) {
            int32_t v37 = v32 >> v33; // 0x1000111a
            *v31 = v37;
            v34 = v6;
            v35 = v37 == 0;
            v36 = (v32 & 1 << v33 - 1) != 0;
        }
        int32_t v38 = __asm_int1(); // 0x10001120
        __asm_outsb((int16_t)v34, *(char *)&v7);
        int32_t result = &v1; // 0x10001122
        if (v35 || v36) {
            // 0x10001125
            return result;
        }
        // .dec_label_pc_1000112a_crit_edge
        v3 = result;
        v5 = v15;
        v4 = 256 * (int32_t)v20 | v16 & -0xff01;
        v8 = v38;
        v2 = 0;
        result2 = v26 - 1;
    }
    int32_t result3 = v3;
    v1 = 0x1000000 * (v5 / 256 + v1 + v2) / 0x1000000;
    v7 -= *(int32_t *)(v8 - 2);
    int32_t v39; // 0x100010e6
    int32_t * v40 = (int32_t *)(v39 - 119); // 0x10001130
    int32_t v41 = v6 | *v40; // 0x10001130
    *v40 = v41;
    if (v41 != 0) {
        // 0x10001135
        *(int32_t *)(v8 - 6) = -0x39efff60;
        // 0x10001125
        return result2;
    }
    // 0x10001151
    *(int32_t *)v4 = (int32_t)&v1;
    int32_t v42 = v8 - 6; // 0x10001153
    *(int32_t *)v42 = result2;
    int32_t v43 = v7 - 1; // 0x10001154
    v7 = v43;
    bool v44; // 0x100010e6
    if (v5 != 1) {
        // 0x1000119c
        __asm_outsb((int16_t)v6, *(char *)v43);
        int32_t v45 = __asm_bound(*(int64_t *)(v5 + 71)); // 0x100011a1
        if (v5 >= 2) {
            // 0x100011dc
            return v45 & -0x33ce4836 | 0x33ce4800;
        }
        // 0x100011a7
        return result2 + (v44 ? -5 : 3);
    }
    unsigned char v46 = *(char *)-125; // 0x10001157
    char v47 = v46 - 4; // 0x10001157
    *(char *)-125 = v47;
    if (v46 > 3 || v47 == 0) {
        // 0x10001125
        return result3;
    }
    // 0x10001208
    *(int32_t *)result2 = *(int32_t *)v43;
    int32_t v48 = v44 ? -4 : 4; // 0x1000118b
    v7 += v48;
    int32_t v49 = (result3 + 144 & 255 | result3 & -256) - 1; // 0x1000118e
    int32_t * v50 = (int32_t *)v49; // 0x1000118f
    *v50 = *v50 | v49;
    int32_t v51 = v42 ^ v49; // 0x10001191
    *(int32_t *)(v51 - 2) = -0x7cefff60;
    int32_t v52 = v48 - 0x438eeb38 + result2; // 0x10001215
    unsigned char v53 = __readgsbyte(v52); // 0x10001215
    __writegsbyte(v52, (char)v49);
    unsigned char v54 = __readfsbyte(-0x73f9f000); // 0x1000121e
    char * v55 = (char *)(v39 - 54); // 0x10001224
    *v55 = *v55 + (char)(v6 / 256);
    __asm_outsb((int16_t)v6, *(char *)v7);
    *(int32_t *)(v51 - 6) = v49 & -256 | (int32_t)v53;
    return v4 & -256 | (int32_t)v54;
}

// Address range: 0x10001231 - 0x10001238
int32_t function_10001231(void) {
    // 0x10001231
    return function_20100313();
}

// Address range: 0x10001249 - 0x10001299
int32_t function_10001249(void) {
    int32_t v1 = unknown_f028d10b(); // 0x1000124b
    char v2 = v1; // 0x10001255
    unsigned char v3 = v2 + 87; // 0x10001255
    int32_t v4 = v3; // 0x10001255
    int32_t v5 = v1 & -256; // 0x10001255
    int32_t v6; // 0x10001249
    if (((v3 ^ v2) & (v2 ^ -128)) >= 0) {
        char * v7 = (char *)(v5 | v4); // 0x10001259
        int32_t v8; // 0x10001249
        *v7 = *v7 | (char)v8;
        int32_t v9; // 0x10001249
        *(char *)v6 = *(char *)&v9;
        bool v10; // 0x10001249
        *(int32_t *)((v10 ? -86 : -84) + v6) = __asm_insd((int16_t)v8);
        return function_939881e9();
    }
    int32_t v11 = v4 + 168 + (int32_t)(v3 < (char)v6) & 255 | v5; // 0x1000126a
    char * v12 = (char *)(v11 + 0x7a237881); // 0x1000126e
    *v12 = *v12 | 36;
    int32_t result = v11 * v6; // 0x10001279
    *(char *)0x1c08a22f = (char)result;
    *(int32_t *)0xe01a62d = result;
    return result;
}

// Address range: 0x10001299 - 0x10001384
int32_t function_10001299(int32_t a1, int32_t a2, int16_t a3) {
    // 0x10001299
    int32_t v1; // 0x10001299
    int32_t v2; // 0x10001299
    int32_t * v3 = (int32_t *)(v1 + 71 + v2); // 0x10001299
    bool v4; // 0x10001299
    *v3 = *v3 - (v4 ? -0x31194590 : -0x31194591);
    int32_t v5; // 0x10001299
    int32_t v6 = v5 - 1; // 0x100012a2
    int32_t v7; // 0x10001299
    uint64_t v8 = (int64_t)(v2 & -256 | (int32_t)__asm_in((int16_t)v7)) * (int64_t)v6; // 0x100012b3
    int32_t v9 = v8; // 0x100012b3
    uint64_t v10 = v8 / 0x100000000; // 0x100012b3
    *(int32_t *)v6 = v9;
    int32_t v11 = (a1 & 1024) != 0 ? -4 : 4; // 0x100012b5
    int32_t v12 = v6 + v11; // 0x100012b5
    int32_t v13 = v9 | 0x592300a6; // 0x100012b6
    __asm_outsd((int16_t)v10, *(int32_t *)a2);
    unsigned char v14 = (char)v13; // 0x100012be
    char v15 = v14 - 111; // 0x100012be
    uint32_t result = v13 & -256 | (int32_t)v15; // 0x100012be
    float80_t v16; // 0x10001299
    if (v15 < 0 != v14 < 239) {
        // 0x100012c2
        *(char *)v12 = *(char *)0x2dd8367d;
        if (v14 >= 239) {
            // 0x100012cd
            return result;
        }
        int32_t v17 = (a1 & 1024) != 0 ? -1 : 1; // 0x10001341
        int16_t v18; // 0x10001299
        int32_t result2 = unknown_655c934b(v18); // 0x10001342
        int16_t * v19 = (int16_t *)((int32_t)v10 - 0x1016d356); // 0x1000135e
        *v19 = *v19 - (int16_t)(v12 + v17);
        *(int64_t *)(v17 + 0x2113de6) = (int64_t)v16;
        return result2;
    }
    // 0x10001308
    int32_t v20; // 0x10001299
    int32_t v21; // 0x10001299
    uint32_t v22 = v21 ^ v20 & 255; // 0x100012ab
    uint32_t v23 = a2 - *(int32_t *)(v22 - 0x4002098); // 0x1000130d
    uint64_t v24 = (int64_t)v23 * (int64_t)result; // 0x10001313
    int32_t v25 = v24; // 0x10001313
    unsigned char v26 = __readgsbyte(-0x5488e884); // 0x10001315
    int32_t v27 = v25 & -256 | (int32_t)v26; // 0x10001315
    char * v28 = (char *)v27; // 0x1000131d
    *v28 = *v28 | (char)v22;
    char * v29 = (char *)v22; // 0x1000131f
    *v29 = *v29 - (char)(v24 / 0x10000000000);
    uint32_t v30 = *(int32_t *)(v12 + 78); // 0x10001321
    uint32_t v31 = v22 - 1; // 0x10001325
    if (v31 != 0) {
        char * v32 = (char *)(v27 + 0x1225f4bf); // 0x1000136c
        *v32 = (char)(v22 < v30) - (char)(v31 / 256) + *v32;
        *(float80_t *)0x548514a6 = __asm_fbstp(v16);
        *(char *)-40 = *(char *)-40 & (char)v31;
        int32_t v33; // 0x10001299
        __asm_into(v33);
        return 0x10000 * (v25 & 0xff00 | (int32_t)(v26 + 72)) / 0x10000;
    }
    uint64_t v34 = v24 / 0x100000000; // 0x10001313
    *(char *)-180 = *(char *)-180 + (v22 < v30 ? -26 : -27);
    *(int32_t *)v12 = v27;
    *(char *)(v12 + v11) = *(char *)(v23 - 1);
    int32_t v35 = unknown_20007338(); // 0x1000132f
    char v36 = *(char *)((v35 & 255) - 53); // 0x10001334
    int32_t v37 = v35 & -256; // 0x10001334
    int32_t v38 = v37 | (int32_t)(v36 ^ -94); // 0x10001335
    char * v39 = (char *)v38; // 0x10001338
    *v39 = *v39 + (char)v34;
    __asm_out((int16_t)v34, v38);
    return v37 | (int32_t)(v36 ^ -58);
}

// Address range: 0x10001385 - 0x100013b6
int32_t function_10001385(int32_t a1) {
    // 0x10001385
    int32_t v1; // 0x10001385
    uint32_t v2; // 0x10001385
    bool v3; // 0x10001385
    bool v4; // 0x10001385
    if (v3 || v4) {
        // 0x1000139d
        return v1 | v2 | -0x63970f3d;
    }
    // 0x10001387
    int32_t v5; // 0x10001385
    int32_t * v6 = (int32_t *)(v5 + 46); // 0x10001387
    *v6 = *v6 | v1;
    int32_t v7; // 0x10001385
    char * v8 = (char *)(v7 + 0x7f16a427); // 0x1000138a
    *v8 = *v8 - (char)(v2 / 256);
    return v2 & -256 | (int32_t)*(char *)-0x7e5af000;
}

// Address range: 0x100013b6 - 0x1000146e
int32_t DllGetClassObject(int32_t a1) {
    // 0x100013b6
    int32_t v1; // 0x100013b6
    int32_t v2 = v1 + 1; // 0x100013c0
    int32_t v3; // 0x100013b6
    int64_t v4 = (int64_t)*(int32_t *)(v3 + 64); // 0x100013c1
    int64_t v5 = -8 * v4; // 0x100013c1
    int32_t v6; // 0x100013b6
    if (v2 < 0 == (v5 != -0x800000000 * v4 / 0x100000000) == (v2 != 0)) {
        v6 = function_10001385((int32_t)&g6);
    }
    int32_t v7 = v6;
    int32_t v8 = v7; // 0x100013c9
    int32_t v9; // 0x100013b6
    int32_t v10; // 0x100013b6
    if (v2 != 0) {
        int32_t v11 = (int32_t)v5 - 1; // 0x100013c9
        *(int32_t *)(8 * v10 + v3) = v11;
        v8 = (v7 + 77 & 255 | v7 & -256) + 0xb782cbd;
        int32_t v12; // 0x100013b6
        v9 = (1 << ((char)v11 & 31) - 1 & (char)v12 + 1) != 0;
    }
    int32_t v13 = v8;
    int32_t v14 = (v13 + 216 & 255 | v13 & -256) + 1; // 0x100013e4
    int32_t v15 = v14; // 0x100013e5
    if ((v14 & (v13 ^ -0x80000000)) >= 0) {
        int32_t v16 = v14 & -256 | (int32_t)__asm_in((int16_t)v9); // 0x100013f4
        v15 = v16 + *(int32_t *)(v16 - 126);
    }
    int32_t v17 = v15;
    int32_t v18 = (v17 + 247 & 255 | v17 & -256) + 0x1000a06c; // 0x100013fa
    int32_t v19 = v18 >> 31; // 0x100013ff
    char * v20 = (char *)(v3 + 14); // 0x10001402
    unsigned char v21 = *v20; // 0x10001402
    *v20 = (char)v19;
    *(char *)(*(int32_t *)(v10 + 0x3862f9f7) & v3) = *(char *)v10;
    char * v22 = (char *)v18; // 0x1000140c
    *v22 = *v22 + v21;
    char * v23 = (char *)(v18 & -256 | 161); // 0x10001415
    *v23 = *v23 + v21;
    int32_t v24 = __asm_hlt(); // 0x10001433
    int16_t v25 = v19 & 0xff00 | (int32_t)v21; // 0x1000143a
    *(char *)0x11fd09f5 = __asm_insb(v25);
    __asm_int(160);
    *(int32_t *)0x11fd09f5 = __asm_insd(v25);
    return v24 & -256 | (int32_t)(*(char *)0x6d8d1000 ^ 126);
}

// Address range: 0x1000146e - 0x10001528
int32_t function_1000146e(int32_t a1) {
    // 0x1000146e
    int32_t v1; // 0x1000146e
    unsigned char v2 = (char)v1;
    int32_t v3; // 0x1000146e
    char v4 = v3; // 0x1000146f
    unsigned char v5 = v2 + v4; // 0x1000146f
    *(char *)v1 = v5;
    int32_t result; // 0x1000146e
    int32_t * v6 = (int32_t *)(result - 96); // 0x10001472
    int32_t v7; // 0x1000146e
    *v6 = v7 + (int32_t)(v5 < v2) + *v6;
    *(char *)result = *(char *)&result + v4;
    int32_t v8; // bp-32, 0x1000146e
    int32_t v9; // 0x1000146e
    int32_t v10 = v9 | (int32_t)&v8; // 0x10001477
    int32_t v11 = v3 & -256 | 162; // 0x10001480
    int32_t v12 = result;
    bool v13 = (v7 & 15) > 16 | (v12 & 14) > 9; // 0x10001482
    int32_t v14 = 256 * (int32_t)v13 + v12 & 0xff00 | v12 & -0x10000;
    *(int32_t *)v10 = v10 + 4;
    char * v15 = (char *)(v14 | (v13 ? v12 + 6 : v12) & 15); // 0x10001489
    *v15 = *v15 - 94;
    int32_t v16 = v14 | (int32_t)__asm_in_5(100); // 0x1000148d
    int32_t * v17 = (int32_t *)(v16 + 48); // 0x10001492
    *v17 = *v17 | v10;
    uint32_t v18 = __asm_bound(*(int64_t *)v16); // 0x10001495
    char * v19 = (char *)(v11 - 9); // 0x10001497
    *v19 = *v19 - 94;
    int32_t v20 = v18 + 0x1000a070; // 0x1000149a
    result = v20;
    int32_t v21 = v9 - 1; // 0x1000149f
    int32_t v22; // 0x1000146e
    __asm_into(v22);
    if (v21 != 0 && v18 <= 0xefff5f8f) {
        // 0x100014fb
        return v20 & -256 | (int32_t)*(char *)v21;
    }
    unsigned char v23 = *(char *)-0x23e1f000; // 0x100014a3
    int32_t v24 = v20 & -256 | (int32_t)v23; // 0x100014a3
    result = v24;
    *(int32_t *)-0x5753de44 = v24;
    char * v25 = (char *)v11; // 0x100014b0
    *v25 = *v25 + v23;
    int32_t v26 = v21; // 0x100014b0
    int32_t v27; // 0x1000146e
    int32_t v28 = v27 + 4;
    int32_t v29 = result + 94; // 0x100014b2
    int32_t v30 = v7 - 2; // 0x100014b4
    char * v31 = (char *)((v29 & 255 | result & -256) - 126); // 0x100014b5
    *v31 = *v31 | (char)v29;
    int32_t v32 = *(int32_t *)v28; // 0x100014ba
    *(char *)v30 = *(char *)v26;
    int32_t v33 = (v32 & 1024) != 0 ? -1 : 1; // 0x100014bb
    int32_t v34 = __asm_wait(); // 0x100014bc
    result = v34;
    v26 += v33;
    int32_t v35 = v33 + v30; // 0x100014bd
    while ((char)v32 < 0) {
        // 0x100014b2
        v28 += 4;
        v29 = v34 + 94;
        v30 = v35 + ((v32 & 1024) != 0 ? -1 : 1);
        v31 = (char *)((v29 & 255 | v34 & -256) - 126);
        *v31 = *v31 | (char)v29;
        v32 = *(int32_t *)v28;
        *(char *)v30 = *(char *)v26;
        v33 = (v32 & 1024) != 0 ? -1 : 1;
        v34 = __asm_wait();
        result = v34;
        v26 += v33;
        v35 = v33 + v30;
    }
    // 0x100014bf
    __asm_out_3(91, v34);
    int64_t v36 = *(int64_t *)(v34 - 0x7dbed816); // 0x100014c1
    int32_t v37; // 0x1000146e
    char * v38 = (char *)((__asm_bound(v36) & -0xff01 | 256 * v37 + 256 & 0xff00) + 80); // 0x100014ca
    *v38 = (char)((v32 & 1) != 0) - (char)v34 + *v38;
    return result;
}

// Address range: 0x10001529 - 0x1000156c
int32_t function_10001529(int32_t a1, int32_t a2) {
    // 0x10001529
    int32_t result; // 0x10001529
    return result;
}

// Address range: 0x1000156c - 0x1000157f
int32_t function_1000156c(void) {
    // 0x1000156c
    int32_t v1; // 0x1000156c
    *(char *)v1 = -1 - (char)v1;
    int32_t v2; // 0x1000156c
    int32_t result = v2 | 0x5e54ee44; // 0x1000156f
    int32_t v3; // 0x1000156c
    __asm_out((int16_t)v3, result);
    int32_t v4; // 0x1000156c
    int32_t * v5 = (int32_t *)(v4 - 122); // 0x1000157b
    *v5 = *v5 & result;
    return result;
}

// Address range: 0x10001585 - 0x10001586
int32_t function_10001585(void) {
    // 0x10001585
    int32_t result; // 0x10001585
    return result;
}

// Address range: 0x1000158b - 0x1000158c
int32_t function_1000158b(void) {
    // 0x1000158b
    int32_t result; // 0x1000158b
    return result;
}

// Address range: 0x10001591 - 0x100015ef
int32_t function_10001591(int32_t a1) {
    // 0x10001591
    bool v1; // 0x10001591
    bool v2; // 0x10001591
    if (!v1 && !v2) {
        function_1000158b();
    }
    // 0x10001593
    int32_t v3; // 0x10001591
    uint32_t v4 = *(int32_t *)0x1345d995 & -256 | v3 & 255; // 0x100015a6
    int32_t v5 = v4 + 0x182c688b; // 0x100015b0
    int32_t v6; // 0x10001591
    *(char *)v5 = (char)v6;
    int32_t v7 = v5; // 0x100015c5
    if (v4 <= 0xe7d39774 && v5 != 0) {
        v7 = function_10001585();
    }
    int32_t v8 = v7;
    int32_t v9; // 0x10001591
    unsigned char v10 = *(char *)(v9 + 1); // 0x100015c7
    int32_t v11 = ((v8 & 255) * (int32_t)v10 | v8 & -0x10000) + 2; // 0x100015ce
    char v12 = *(char *)0x7aca1000; // 0x100015d3
    int32_t v13; // 0x10001591
    bool v14 = (v12 & 14) > 9 | ((char)(v13 / 256) & 15) > 22; // 0x100015d8
    char v15 = v14 ? v12 + 10 : v12; // 0x100015d8
    int32_t v16; // 0x10001591
    bool v17; // 0x10001591
    *(int32_t *)v16 = *(int32_t *)((v17 ? -2 : 2) + v3);
    *(char *)v13 = *(char *)&v13 + 46;
    *(char *)((v17 ? -4 : 4) + v16) = *(char *)0xa0a897;
    return v11 & -0x10000 | (int32_t)(v15 & 15) | 256 * (int32_t)v14 + v11 & 0xff00;
}

// Address range: 0x100015ef - 0x10001798
int32_t function_100015ef(int32_t a1, int32_t result) {
    // 0x100015ef
    int32_t v1; // 0x100015ef
    int32_t v2; // 0x100015ef
    int32_t v3; // 0x100015ef
    int32_t v4; // 0x100015ef
    int32_t v5; // 0x100015ef
    int32_t v6; // 0x100015ef
    int32_t v7; // 0x100015ef
    int32_t v8; // 0x100015ef
    uint32_t v9; // 0x100015ef
    bool v10; // 0x100015ef
    if (v10) {
        int32_t v11 = (v9 ^ 53) - *(int32_t *)(v7 + 0x3731188c); // 0x1000165c
        int32_t v12 = v6 ^ 0x1000a08c; // 0x10001665
        unsigned char v13 = (char)v12; // 0x1000166a
        char v14 = v13 > 153 ? v13 - 96 : v13;
        char v15 = (v13 & 14) > 9 ? (v13 > 153 ? -102 : -6) + v13 : v14;
        __asm_frstor(*(int864_t *)v11);
        v1 = v12 & -256;
        int16_t v16; // bp-2, 0x100015ef
        v5 = &v16;
        v2 = v11;
        if (v15 >= 0 != v15 != 0) {
            // 0x10001671
            return result;
        }
    } else {
        // 0x100015f1
        int32_t v17; // 0x100015ef
        unsigned char v18 = (char)v17; // 0x100015f1
        unsigned char v19 = *(char *)(v9 + v8) + v18; // 0x100015f1
        char * v20 = (char *)(v7 + 23); // 0x100015f4
        *v20 = *v20 + (char)(v9 / 256) + (char)(v19 < v18);
        int32_t v21; // 0x100015ef
        int32_t v22 = v9 & -256 | (int32_t)*(char *)((v9 & 255) + v21); // 0x100015f7
        if ((*(int32_t *)0x1000a0a4 & 0x1959e993) != 0) {
            // 0x1000161e
            *(char *)v6 = *(char *)&v4;
            char * v23 = (char *)v22; // 0x1000161f
            *v23 = *v23 + v19;
            int32_t * v24 = (int32_t *)(v22 - 0x52df000); // 0x10001622
            *v24 = *v24 / 2 | 0x80000000 * (int32_t)((v6 & 1) != 0);
            int32_t v25 = 0x10000 * v9 / 0x10000; // 0x1000162a
            if ((v6 & 64) != 0) {
                // 0x10001632
                return v25 & 0x10080500 | (int32_t)(*(char *)-0x3b78f000 & 18);
            }
            unsigned char v26 = *(char *)0x457b1000; // 0x1000162b
            *(char *)(v6 + 1) = v26;
            return v25 & -256 | (int32_t)v26;
        }
        char * v27 = (char *)v22; // 0x1000167a
        unsigned char v28 = *v27; // 0x1000167a
        unsigned char v29 = v28 + v19; // 0x1000167a
        *v27 = v29;
        int32_t v30 = -101; // bp-40, 0x10001681
        v1 = v22 - (v29 < v28 ? 0x155c87de : 0x155c87dd) & -0x10000;
        v3 = v17 & -256 | (int32_t)v19;
        v5 = &v30;
    }
    int32_t v31 = v5;
    int32_t v32 = v8 + 0x4d835702; // 0x1000168f
    int32_t * v33 = (int32_t *)v8; // 0x1000168f
    *v33 = v32;
    char v34 = *(char *)-0x2e3b60a1 - 23; // 0x10001695
    int32_t * v35 = (int32_t *)(v8 + 28); // 0x10001697
    *v35 = v4 | *v35;
    if (v2 != -1) {
        // 0x10001659
        return v1 & -256 | (int32_t)v34;
    }
    // 0x1000169d
    int32_t v36; // 0x100015ef
    __asm_into(v36);
    int32_t v37 = __asm_int3(); // 0x100016a2
    if (v34 < 76) {
        // 0x100016a5
        return __asm_bound(*(int64_t *)(v37 + 1));
    }
    char v38 = v3 / 256;
    char v39 = __asm_in((int16_t)v3); // 0x100016b4
    float80_t v40; // 0x100015ef
    *(int64_t *)(v4 + 0x7841727d) = (int64_t)v40;
    char v41 = *(char *)-17; // 0x100016c2
    if (((v38 - v41 ^ v38) & (v41 ^ v38)) < 0) {
        unsigned char v42 = (char)v37; // 0x100016aa
        *v33 = v32;
        *v35 = v4 | *v35;
        int32_t v43 = v42 < 161 ? v37 : v37 + 95; // 0x100016aa
        int32_t v44 = (v43 & 255 | v37 & -0x10000 | 256 * (int32_t)(v42 > 160)) + 0x32d334b4 & -0x6af40000 | (int32_t)v39 & -0x6af3ffbe | 0x9e00; // 0x100015ef
        // 0x10001659
        return v44 & -256 | (int32_t)(*(char *)-0x2e3b60a1 - 23);
    }
    int32_t v45 = *(int32_t *)v31; // 0x100016ca
    int32_t v46 = *(int32_t *)(v31 + 8); // 0x100016ca
    uint32_t v47 = *(int32_t *)(v31 + 16); // 0x100016ca
    uint32_t v48 = *(int32_t *)(v31 + 20); // 0x100016ca
    uint32_t v49 = *(int32_t *)(v31 + 24); // 0x100016ca
    int32_t * v50 = (int32_t *)(v31 + 28); // 0x100016ca
    int32_t v51 = *v50; // 0x100016ca
    v4 = *(int32_t *)(v31 + 4);
    char * v52 = (char *)(v45 + 0x6014b5); // 0x100016cb
    *v52 = *v52 & (char)(v49 / 256);
    char * v53 = (char *)(v49 - 0x33fc9b38); // 0x100016d1
    char v54 = *v53 + (char)v51; // 0x100016d1
    *v53 = v54;
    uint16_t v55 = 256 * (int16_t)v51 / 256 * (int16_t)v47 / 256; // 0x100016d9
    int32_t v56 = v51 & -0x10000 | (int32_t)v55; // 0x100016d9
    char v57; // 0x100015ef
    int32_t v58; // 0x100015ef
    if (v54 >= 0) {
        char v59 = v55 / 256; // 0x100016d9
        char * v60 = (char *)(v47 + 0x6e826616); // 0x100016f8
        *v60 = (char)(v59 != 0 == (v59 != -1)) + (char)v55 + *v60;
        char * v61 = (char *)(v47 + 3); // 0x10001701
        *v61 = *v61 + (char)(v48 / 256);
        *v50 = v46;
        v57 = v48;
        v58 = v56;
    } else {
        int32_t result2 = v56 & -0xff01 | 0xa100; // 0x100016df
        char * v62 = (char *)result2; // 0x100016e1
        char v63 = v48;
        char v64 = *v62 + v63; // 0x100016e1
        *v62 = v64;
        int32_t v65 = v49 - 1; // 0x100016e3
        v57 = v63;
        v58 = result2;
        if (v65 == 0 || v64 == 0) {
            // 0x100016e5
            *(int32_t *)(v31 + 30) = result2;
            *(int32_t *)(v31 + 26) = v65;
            *(int32_t *)(v31 + 22) = v48;
            *(int32_t *)(v31 + 18) = v47;
            *(int32_t *)(v31 + 14) = v31 + 34;
            *(int32_t *)(v31 + 10) = v46;
            *(int32_t *)(v31 + 6) = v4;
            *(int32_t *)(v31 + 2) = v45;
            unsigned char v66 = *v62; // 0x100016e6
            unsigned char v67 = v66 + v63; // 0x100016e6
            *v62 = v67;
            *(char *)(v45 + 0x5fafd6e8) = (char)v65;
            char * v68 = (char *)(v45 + 20); // 0x100016ee
            *v68 = *v68 + (char)(v47 / 256) + (char)(v67 < v66);
            *v62 = *v62 + v63;
            *(int32_t *)v45 = *(int32_t *)v4;
            return result2;
        }
    }
    char * v69 = (char *)(v47 - 12); // 0x1000170e
    *v69 = *v69 - 106;
    *(char *)v45 = *(char *)(v4 - 1);
    char * v70 = (char *)(v58 & -256 | (int32_t)*(char *)v4); // 0x10001714
    *v70 = *v70 + v57;
    return unknown_fffb017();
}

// Address range: 0x100017c1 - 0x100017cd
int32_t Logon(void) {
    // 0x100017c1
    int32_t v1; // 0x100017c1
    int32_t v2; // 0x100017c1
    *(char *)v1 = (char)v2;
    int32_t result; // 0x100017c1
    int32_t v3; // 0x100017c1
    *(char *)result = *(char *)&result + (char)v3;
    int32_t v4 = result;
    int32_t v5; // 0x100017c1
    *(int32_t *)v4 = v4 & v5;
    return result;
}

// Address range: 0x100017cd - 0x10001822
int32_t Logoff(int32_t a1, int32_t a2) {
    // 0x100017cd
    int32_t v1; // 0x100017cd
    int16_t v2 = v1; // 0x100017cd
    __asm_arpl(*(int16_t *)-0x177e12f5, v2);
    int32_t v3; // 0x100017cd
    char * v4 = (char *)(v3 + 19); // 0x100017d3
    int32_t v5; // 0x100017cd
    *v4 = *v4 & (char)v5;
    int16_t v6; // 0x100017cd
    uint32_t v7 = unknown_103f106a(v6); // 0x100017d6
    int32_t v8; // 0x100017cd
    int32_t v9 = v8 + 1; // 0x100017dd
    if (v9 < 0) {
        int32_t result = v7 + 154 & 255 | v7 & -256; // 0x100017e2
        char * v10 = (char *)result; // 0x100017e4
        *v10 = *v10 + (char)(v7 / 256);
        return result;
    }
    // 0x100017f4
    __asm_out(v2, v7);
    float80_t v11; // 0x100017cd
    *(int16_t *)v7 = (int16_t)v11;
    int32_t v12 = v7 + 1 & -256; // 0x10001802
    char * v13 = (char *)(v12 | (int32_t)*(char *)-0x4e54f000); // 0x10001813
    char v14 = (char)((v9 & (v8 ^ -0x80000000)) >= 0 ? v7 : v1); // 0x10001813
    *v13 = *v13 | v14;
    int32_t v15; // 0x100017cd
    *(char *)v15 = *(char *)&v15 & v14;
    return v12 | (int32_t)*(char *)-0x5e44f000;
}

// Address range: 0x10001826 - 0x1000182d
int32_t Activate(void) {
    // 0x10001826
    return function_c83510b6();
}

// Address range: 0x1000183e - 0x10001884
int32_t function_1000183e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x1000183e
    int32_t v1; // 0x1000183e
    char * v2 = (char *)(v1 + 0x5949674); // 0x1000183e
    char v3 = *v2; // 0x1000183e
    int32_t v4; // 0x1000183e
    char v5 = v4; // 0x1000183e
    bool v6; // 0x1000183e
    char v7 = v6; // 0x1000183e
    char v8 = v7 + v5 + v3; // 0x1000183e
    char v9 = v8 + v7; // 0x1000183e
    *v2 = v8;
    if (v8 < 0 != ((v9 ^ v3) & (v9 ^ v5)) < 0) {
        // 0x10001849
        int32_t result; // 0x1000183e
        return result;
    }
    char * v10 = (char *)(a2 + 41 + a5); // 0x10001879
    char v11 = *v10; // 0x1000186d
    int32_t v12 = a6 + 0x50344ce2 & -256 | (int32_t)*(char *)0x23577a8;
    int32_t v13 = (v12 + 136 & 255 | v12 & -256) - (int32_t)&g2; // 0x10001874
    v11 |= (char)(v13 / 256);
    while (v11 >= 0) {
        // 0x10001872
        v12 = v13;
        v13 = (v12 + 136 & 255 | v12 & -256) - (int32_t)&g2;
        v11 |= (char)(v13 / 256);
    }
    // 0x1000187f
    *v10 = v11;
    return v13 | 0x1000a0b0;
}

// Address range: 0x100018e7 - 0x10001a42
int32_t entry_point(int32_t a1) {
    int32_t v1 = a1;
    int32_t v2; // 0x100018e7
    int32_t v3; // 0x100018e7
    int32_t v4; // 0x100018e7
    uint32_t v5; // 0x100018e7
    int32_t v6; // 0x100018e7
    int32_t v7; // 0x100018e7
    int32_t result; // 0x100018e7
    __asm_rdtsc(v2, v3, v4, &v1, v5, v6, v7, result);
    __asm_rdtsc_1();
    if ((int16_t)result == 736) {
        // 0x100018fe
        return result;
    }
    // 0x100018ff
    v1 += 0xd6ec;
    int32_t v8 = __readfsdword(0); // bp-4, 0x1000195c
    __writefsdword(0, (int32_t)&v8);
    int32_t v9 = 0x10000;
    int32_t v10 = v9 - 1; // 0x10001998
    while (v10 != 0) {
        // 0x10001998
        v9 = v10;
        v10 = v9 - 1;
    }
    int32_t v11 = 0x10000 * v6 / 0x10000; // 0x100018ff
    int32_t * v12 = (int32_t *)v10; // 0x100019ba
    *v12 = *v12 ^ v4;
    uint32_t v13 = *(int32_t *)(v9 + 24); // 0x100019bc
    int32_t v14 = v13 + v2; // 0x100019bc
    int32_t v15 = v8 & -256 | (int32_t)*(char *)0x5d631000; // 0x100019c0
    uint32_t v16 = v15 - 1; // 0x100019c5
    v8 = v16;
    int32_t v17 = v14; // bp-32, 0x100019c6
    *(char *)-0x28bdf000 = (char)v16;
    int32_t v18 = *(int32_t *)0x3a40f580; // 0x100019cc
    *(int32_t *)0x3a40f580 = (int32_t)&v17;
    int32_t v19 = v14 + (int32_t)(v13 > -1 - v2) + 1 - v15; // 0x100019d2
    char * v20 = (char *)v16; // 0x100019d4
    unsigned char v21 = *v20; // 0x100019d4
    char v22 = v21 / 128; // 0x100019d4
    *v20 = v22 | 2 * v21;
    int32_t v23 = v11 / 256;
    int32_t v24; // 0x100018e7
    int32_t v25; // 0x100018e7
    bool v26; // 0x100018e7
    int32_t v27; // 0x100018e7
    int32_t v28; // 0x100018e7
    int32_t v29; // 0x100018e7
    int32_t v30; // 0x100018e7
    int32_t v31; // 0x100018e7
    if (v15 >= 0x13c95586) {
        // 0x100019f8
        v24 = v23;
        v30 = v18;
        v28 = v11;
        v25 = v23;
        v31 = v18;
        v29 = v11;
        v26 = true;
        v27 = (int32_t)&g3 - 0x54efff31;
        if (v16 < 0x13c95585) {
            goto lab_0x10001a0d;
        } else {
            goto lab_0x100019ff;
        }
    } else {
        // 0x100019df
        __asm_int3();
        int32_t v32 = (v16 & 0x13c95585 - v15) < 0 ? v11 : v18; // 0x100019e7
        int32_t v33 = v32 - 3; // 0x100019ed
        *(int32_t *)v33 = v4 + 1;
        int32_t v34 = v32 - 167; // 0x100019f1
        *(int32_t *)v34 = -0x27aa7af4;
        uint32_t v35 = v33 + v11; // 0x100019f6
        int32_t v36 = v35 + (int32_t)(v16 < 0x13c95585); // 0x100019f6
        int32_t v37 = v36 / 256;
        v24 = v37;
        v30 = v34;
        v28 = v36;
        v25 = v37;
        v31 = v34;
        v29 = v36;
        v26 = true;
        v27 = (int32_t)&g3 - 0x54efff31;
        if (v16 < 0x13c95585 ? v36 <= v11 : v35 < v11) {
            goto lab_0x10001a0d;
        } else {
            goto lab_0x100019ff;
        }
    }
  lab_0x10001a0d:;
    int32_t v38 = v23 + v5 / 256 + (int32_t)(v22 != 0); // 0x100019d6
    uint32_t v39 = 256 * v38 & 0xff00 | v5 & -0xff01; // 0x100019d6
    char * v40 = (char *)(v39 - 0x31a4fdff); // 0x10001a0e
    unsigned char v41 = *v40; // 0x10001a0e
    char v42 = v26; // 0x10001a0e
    unsigned char v43 = v42 + (char)v25; // 0x10001a0e
    char v44 = v41 - v43; // 0x10001a0e
    bool v45 = v26 ? v43 != -1 | v41 < v44 - v42 : v41 < v43;
    *v40 = v44;
    uint32_t v46 = v27 + (int32_t)v45; // 0x10001a14
    int32_t * v47 = (int32_t *)(v3 - 54); // 0x10001a19
    *v47 = *v47 | v10;
    uint32_t v48 = v46 / 256; // 0x10001a22
    uint32_t v49 = v39 / 256; // 0x10001a22
    int32_t * v50 = (int32_t *)(256 * (v48 + v49) & 0xff00 | v46 & -0xff01); // 0x10001a25
    *v50 = *v50 - (-1 - (char)v48 < (char)v49 ? -0x14d0efff : -0x14d0f000);
    char * v51 = (char *)(v19 + 20); // 0x10001a2e
    char v52 = *v51; // 0x10001a2e
    unsigned char v53 = (char)v38; // 0x10001a2e
    *v51 = v52 + v53;
    int32_t v54 = *(int32_t *)(v31 + 2) & -256; // 0x10001a32
    unsigned char v55 = *(char *)0x5ca91000 - (-1 - v52 < v53 ? 97 : 96); // 0x10001a37
    char * v56 = (char *)(v54 | (int32_t)v55); // 0x10001a39
    unsigned char v57 = *v56; // 0x10001a39
    unsigned char v58 = v57 + (char)v29; // 0x10001a39
    *v56 = v58;
    char v59 = *(char *)(v39 - 0xc2ea83a); // 0x10001a3b
    __asm_outsb((int16_t)v29, *(char *)0x622c11);
    return v54 | (int32_t)(v59 + v55 + (char)(v58 < v57));
  lab_0x100019ff:;
    char * v60 = (char *)v10; // 0x100019ff
    *v60 = *v60 - (char)v24;
    __asm_out((int16_t)v28, -0x54efff30);
    int32_t * v61 = (int32_t *)(v19 - 0x77c237c0); // 0x10001a02
    uint32_t v62 = *v61; // 0x10001a02
    *v61 = v62 - 0x1368f5fb;
    v25 = v24;
    v31 = v30;
    v29 = v28;
    v26 = v62 > 0x1368f5fa;
    v27 = (int32_t)&g3 - 0x54efff30;
    goto lab_0x10001a0d;
}

// Address range: 0x10001a43 - 0x10001a67
int32_t HookProc(int32_t a1) {
    // 0x10001a43
    uint32_t v1; // 0x10001a43
    float80_t v2; // 0x10001a43
    *(float64_t *)(v1 + 0x2d6ec2cc) = (float64_t)v2;
    int32_t v3; // 0x10001a43
    unsigned char v4 = (char)v3; // 0x10001a4a
    bool v5; // 0x10001a43
    bool v6 = v4 > 153 | v5;
    int32_t v7; // 0x10001a43
    bool v8; // 0x10001a43
    if (v8 || (v4 & 14) > 9) {
        v7 = (v6 ? 102 : 6) + v3 & 255 | v3 & -256;
    } else {
        v7 = (v6 ? v3 + 96 : v3) & 255 | v3 & -256;
    }
    char * v9 = (char *)(v7 + 77); // 0x10001a51
    uint32_t v10; // 0x10001a43
    *v9 = (char)v6 + (char)(v10 / 256) + *v9;
    g5 -= (char)(v1 / 256);
    int32_t v11 = __asm_wait(); // 0x10001a5d
    int32_t v12 = v11 & -256; // 0x10001a5e
    char * v13 = (char *)(v11 + 158 & 255 | v12); // 0x10001a60
    *v13 = *v13 + (char)v10;
    return v12 | 189;
}

// Address range: 0x10001aae - 0x10001c8d
int32_t Start(int32_t a1, int32_t a2) {
    int32_t v1 = a2;
    uint32_t v2; // 0x10001aae
    bool v3; // 0x10001aae
    uint32_t v4 = v2 - 0x177c12f5 + (int32_t)v3; // 0x10001aae
    int32_t v5 = v4 + 0x52d14120 + (int32_t)(v3 ? v4 <= v2 : v2 > 0x177c12f4); // 0x10001ab4
    int32_t v6; // 0x10001aae
    unsigned char v7 = *(char *)((v5 + 181 & 255) + v6); // 0x10001abe
    int32_t v8 = __asm_bound(*(int64_t *)((v5 & -256 | (int32_t)v7) - 1)); // 0x10001acb
    char v9 = *(char *)-0xf9fc4c1; // 0x10001acd
    *(char *)-0xf9fc4c1 = (char)((char)v5 > 74) + (char)v6 + v9;
    int32_t v10; // 0x10001aae
    *(int32_t *)(v10 + 0x10080493) = a1;
    int32_t v11 = v8 - 1; // 0x10001ad5
    int32_t * v12 = (int32_t *)(v8 - 0xf9fc4c2); // 0x10001ad7
    *v12 = *v12 - 99;
    int32_t v13; // 0x10001aae
    int32_t v14; // 0x10001aae
    *(char *)v14 = *(char *)&v13;
    bool v15; // 0x10001aae
    v13 += (v15 ? -1 : 1);
    __asm_out_3(97, v11);
    int32_t v16 = v1; // 0x10001ae1
    int32_t * v17 = (int32_t *)(v8 - 97); // 0x10001ae2
    *v17 = 2 * *v17 | (int32_t)((v16 & 1) != 0);
    char * v18 = (char *)v11; // 0x10001ae5
    int32_t v19; // 0x10001aae
    *v18 = *v18 + (char)v19;
    int32_t v20 = *(int32_t *)-0x504018c9; // 0x10001ae9
    int32_t v21 = unknown_2000bfe8() + 1; // 0x10001af4
    v1 = v10 + 1;
    __asm_out_3(97, v21);
    int16_t v22 = v20; // 0x10001b01
    __asm_out(v22, v21);
    int32_t v23 = (v16 & 1024) == 0 ? 1 : -1; // 0x10001b10
    int32_t v24 = v21 & -256 | (int32_t)__asm_in(v22); // 0x10001b04
    int32_t v25 = v20; // 0x10001b04
    int32_t v26; // bp+20111, 0x10001aae
    int32_t v27 = &v26;
    int32_t v28 = -0xf9fc40c;
    int32_t v29 = v24;
    float80_t v30; // 0x10001aae
    *(int64_t *)(v13 + 0x6c8f88d2) = (int64_t)v30;
    int32_t v31 = 0; // 0x10001b0b
    *(char *)*(int32_t *)v27 = *(char *)v13;
    int32_t v32 = v13 + v23; // 0x10001b10
    char * v33 = (char *)(v29 & -0x10000 | v31 | v29 - (v28 & 0xff00) & 0xff00); // 0x10001b11
    char v34 = v25; // 0x10001b11
    *v33 = *v33 + v34;
    int32_t v35 = v27 + 8; // 0x10001b13
    __asm_out((int16_t)v25, *(int32_t *)(v27 + 4));
    int32_t * v36 = (int32_t *)__asm_in_4(91); // 0x10001b24
    *v36 = *v36 + v35;
    int32_t v37 = v28 + 1; // 0x10001b26
    int32_t v38 = unknown_6091a230(); // 0x10001b27
    char * v39 = (char *)v38; // 0x10001b33
    *v39 = *v39 + v34;
    *(int16_t *)(v38 + 0x1034e20) = (int16_t)v30;
    *v39 = *v39 + v34;
    *(char *)0x602069d0 = *(char *)v32;
    int32_t v40 = v32 + v23; // 0x10001b3b
    v13 = v40;
    v25 ^= -90;
    v24 = (int32_t)&v1 & -0xff01 | 0x1a00;
    unsigned char v41 = (char)(v25 / 256); // 0x10001b42
    unsigned char v42 = *(char *)(v23 + 0x602069bf); // 0x10001b42
    char v43 = v41 - v42; // 0x10001b42
    int32_t v44 = v27 + 12; // 0x10001b45
    while (((v43 ^ v41) & (v42 ^ v41)) < 0) {
        int32_t v45 = v38;
        v27 = v44;
        v28 = v37;
        v29 = v24;
        *(int64_t *)(v40 + 0x6c8f88d2) = (int64_t)v30;
        v31 = v42 > v41 ? 255 : 0;
        *(char *)*(int32_t *)v27 = *(char *)v40;
        v32 = v13 + v23;
        v33 = (char *)(v29 & -0x10000 | v31 | v29 - (v28 & 0xff00) & 0xff00);
        v34 = v25;
        *v33 = *v33 + v34;
        v35 = v27 + 8;
        __asm_out((int16_t)v25, *(int32_t *)(v27 + 4));
        v36 = (int32_t *)__asm_in_4(91);
        *v36 = *v36 + v35;
        v37 = v28 + 1;
        v38 = unknown_6091a230();
        v39 = (char *)v38;
        *v39 = *v39 + v34;
        *(int16_t *)(v38 + 0x1034e20) = (int16_t)v30;
        *v39 = *v39 + v34;
        *(char *)0x602069d0 = *(char *)v32;
        v40 = v32 + v23;
        v13 = v40;
        v25 ^= -90;
        v24 = v45 & -0xff01 | 0x1a00;
        v41 = (char)(v25 / 256);
        v42 = *(char *)(v23 + 0x602069bf);
        v43 = v41 - v42;
        v44 = v27 + 12;
    }
    char v46 = llvm_ctpop_i8(v43); // 0x10001b42
    *(int32_t *)v35 = -0x24efff60;
    if ((v46 & 1) != 0) {
        if (v42 > v41) {
            // 0x10001bc5
            return (int32_t)(*(char *)-0x1f6af000 ^ -122) | -0x6ff00000;
        }
        // 0x10001c29
        __asm_out_2(191, -96);
        int32_t * v47 = (int32_t *)v37; // 0x10001c2b
        *v47 = *v47 | 11;
        __asm_out((int16_t)v25, __asm_sti());
        return unknown_21101d27();
    }
    char * v48 = (char *)(v25 + 0x29201008); // 0x10001b51
    unsigned char v49 = *v48; // 0x10001b51
    *v48 = (char)v25;
    int32_t v50 = v25 & -256 | (int32_t)v49; // 0x10001b51
    *(char *)-0x24efff60 = *(char *)-0x24efff60 + v49;
    int32_t v51 = __asm_sti(); // 0x10001b64
    int32_t v52 = v28 - v50; // 0x10001b65
    *(int32_t *)(v27 | 2) = v51;
    *(int32_t *)(v27 - 2) = v52;
    *(int32_t *)(v27 - 6) = v50;
    *(int32_t *)(v27 - 10) = -0x24efe760;
    *(int32_t *)(v27 - 14) = v27 + 6;
    *(int32_t *)(v27 - 18) = v38;
    *(int32_t *)(v27 - 22) = v13;
    *(int32_t *)(v27 - 26) = v24;
    char * v53 = (char *)v51; // 0x10001b6a
    unsigned char v54 = *v53; // 0x10001b6a
    unsigned char v55 = v54 + v49; // 0x10001b6a
    *v53 = v55;
    __asm_out((int16_t)v50, v51);
    unsigned char v56 = (char)v51; // 0x10001b6e
    char v57 = v55 < v54; // 0x10001b6e
    unsigned char v58 = *v53 + v57; // 0x10001b6e
    unsigned char v59 = v56 - v58; // 0x10001b6e
    bool v60 = v55 < v54 ? v58 != -1 | v59 - v57 > v56 : v58 > v56; // 0x10001b6e
    char * v61 = (char *)v52; // 0x10001b70
    *v61 = *v61 + 24 + (char)v60;
    return v51 & -256 | (int32_t)v59;
}

// Address range: 0x10001c8e - 0x10001cd9
float80_t function_10001c8e(int32_t a1, int32_t a2) {
    // 0x10001c8e
    __asm_int(5);
    int32_t v1; // 0x10001c8e
    int32_t v2 = -0x47870805 * v1; // 0x10001c90
    int32_t v3; // 0x10001c8e
    *(char *)v2 = (char)v3;
    int32_t v4; // 0x10001c8e
    char v5 = v4; // 0x10001c97
    int32_t v6; // 0x10001c8e
    *(char *)v6 = *(char *)&v6 + v5;
    __asm_out((int16_t)v4, a1);
    int32_t v7; // 0x10001c8e
    uint32_t v8 = v7 - 1; // 0x10001ca5
    char * v9 = (char *)v8; // 0x10001cab
    *v9 = *v9 & (char)(v8 / 256);
    bool v10; // 0x10001c8e
    char * v11 = (char *)(v2 + 20 + (v10 ? -1 : 1)); // 0x10001cae
    *v11 = *v11 - 6;
    char * v12 = (char *)(v8 & -256 | (int32_t)__asm_in_5(-96)); // 0x10001cb3
    *v12 = *v12 + v5;
    float80_t result; // 0x10001c8e
    return result;
}

// Address range: 0x10001ce4 - 0x10001ced
int32_t function_10001ce4(void) {
    // 0x10001ce4
    return function_f589cf09();
}

// Address range: 0x10001cf6 - 0x10001cf9
int32_t function_10001cf6(int32_t a1) {
    // 0x10001cf6
    int32_t result; // 0x10001cf6
    return result;
}

// Address range: 0x10001d09 - 0x10001d31
int32_t function_10001d09(int32_t a1) {
    // 0x10001d09
    int32_t v1; // 0x10001d09
    bool v2; // 0x10001d09
    int32_t v3 = v1 - (v2 ? 161 : 160); // 0x10001d0a
    int32_t v4 = v3 & 255 | v1 & -256; // 0x10001d0d
    int32_t v5; // 0x10001d09
    if (v5 != 0 != (v5 == -1)) {
        unsigned char v6 = (char)v3; // 0x10001d17
        uint32_t v7; // 0x10001d09
        uint32_t v8; // 0x10001d09
        uint32_t v9; // 0x10001d09
        *(char *)v7 = (char)(v8 < v7) + (char)v7 - (char)(v9 / 256);
        v4 = v1 & -0x10000 | (int32_t)(v6 % 83) | 256 * (int32_t)(v6 / 83);
    }
    // 0x10001d1d
    *(char *)-0x16d399e8 = (char)v4;
    char * v10 = (char *)(2 * v4 + 0x9a635ab); // 0x10001d22
    *v10 = *v10 - 33;
    return v4 & -256 | (int32_t)__asm_in_5(-94);
}

// Address range: 0x10001d31 - 0x10001d3a
int32_t function_10001d31(void) {
    // 0x10001d31
    int32_t v1; // 0x10001d31
    int32_t v2; // 0x10001d31
    return v2 ^ v1 & 255;
}

// Address range: 0x10001d3a - 0x10001d4c
int32_t function_10001d3a(void) {
    // 0x10001d3a
    int32_t v1; // 0x10001d3a
    int32_t v2; // 0x10001d3a
    __asm_outsb((int16_t)v2, (char)v1);
    int32_t v3; // 0x10001d3a
    return v3 & -0x10000 | v2 & 255 | 256 * (int32_t)((uint32_t)(v3 & 14 ^ 4) > 9) + v3 & 0xff00;
}

// Address range: 0x10001d4c - 0x10001d65
int32_t function_10001d4c(void) {
    // 0x10001d4c
    return function_e3c821de(-65);
}

// Address range: 0x10001d81 - 0x10001dcc
int32_t function_10001d81(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t result) {
    int32_t v1 = a1;
    int32_t v2; // 0x10001d81
    if (v2 == 1) {
        // 0x10001d83
        return result;
    }
    // 0x10001dc0
    int32_t v3; // 0x10001d81
    int32_t v4; // 0x10001d81
    __asm_out((int16_t)v4, v3);
    return function_10001e09(&v1, (int32_t)&g6);
}

// Address range: 0x10001dcc - 0x10001e09
int32_t function_10001dcc(void) {
    // 0x10001dcc
    int32_t v1; // 0x10001dcc
    int32_t result = v1 + 161 & 255 | v1 & -256; // 0x10001dcc
    char * v2 = (char *)result; // 0x10001dce
    int32_t v3; // 0x10001dcc
    *v2 = *v2 + (char)v3;
    int32_t v4; // 0x10001dcc
    int32_t * v5 = (int32_t *)(v4 + 112); // 0x10001dd6
    int32_t v6; // 0x10001dcc
    *v5 = v6 + 1 + *v5;
    return result;
}

// Address range: 0x10001e09 - 0x10001e13
int32_t function_10001e09(int32_t * a1, int32_t a2) {
    // 0x10001e09
    int32_t v1; // 0x10001e09
    int32_t v2; // 0x10001e09
    int32_t result = v2 & -256 | (int32_t)(*(char *)((v2 & 255) + v1) - 95); // 0x10001e0f
    char * v3 = (char *)result; // 0x10001e11
    *v3 = *v3 + (char)(int32_t)a1;
    return result;
}

// Address range: 0x10001e47 - 0x10001e4a
int32_t function_10001e47(void) {
    // 0x10001e47
    int32_t result; // 0x10001e47
    return result;
}

// Address range: 0x10001e54 - 0x10001e59
int32_t function_10001e54(int32_t a1) {
    // 0x10001e54
    uint32_t result; // 0x10001e54
    *(char *)result = (char)(result / 256) + (char)result;
    return result;
}

// Address range: 0x10001e59 - 0x10001ec2
int32_t function_10001e59(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10001e59
    int32_t v1; // 0x10001e59
    bool v2; // 0x10001e59
    bool v3; // 0x10001e59
    if (v3 != v2) {
        // 0x10001e5b
        int32_t v4; // 0x10001e59
        return 256 * v1 & 0xff00 | v4 & -0xff01;
    }
    // 0x10001e6e
    int32_t v5; // 0x10001e59
    char * v6 = (char *)(v5 - 0x1f7cad3f + 2 * v1); // 0x10001e6e
    unsigned char v7 = *v6; // 0x10001e6e
    char v8 = v7 - 93; // 0x10001e6e
    *v6 = v8;
    int32_t v9; // 0x10001e59
    int32_t v10 = v9 - 1; // 0x10001e7b
    int32_t v11; // 0x10001e59
    if (v10 != 0 == v8 == 0) {
        int32_t v12 = __asm_wait(); // 0x10001e9a
        __asm_out((int16_t)v11, v12);
        int32_t v13; // bp+12965, 0x10001e59
        char * v14 = (char *)(8 * (v11 ^ v1) - 20 + (int32_t)&v13); // 0x10001ea2
        *v14 = *v14 | (char)v12;
        return 0x230c7987;
    }
    int32_t v15; // 0x10001e59
    if (v7 <= 92) {
        // 0x10001e81
        return (v15 & -256 | (int32_t)*(char *)(a1 + 45)) ^ -0x2a1def00;
    }
    uint32_t v16 = v10 & 31; // 0x10001eb4
    if (v16 != 0) {
        int32_t v17; // 0x10001e59
        int32_t * v18 = (int32_t *)(v17 - 53); // 0x10001eb4
        *v18 = *v18 << v16;
    }
    int32_t v19; // 0x10001e59
    __asm_outsb((int16_t)v11, *(char *)&v19);
    return v15 ^ 114;
}

// Address range: 0x10001ec3 - 0x10001ec9
float80_t function_10001ec3(int32_t a1) {
    // 0x10001ec3
    int32_t v1; // 0x10001ec3
    float80_t v2; // 0x10001ec3
    return (float80_t)*(float32_t *)(v1 + 32) / v2;
}

// Address range: 0x10001ec9 - 0x10001ecc
int32_t function_10001ec9(void) {
    // 0x10001ec9
    int32_t result; // 0x10001ec9
    return result;
}

// Address range: 0x10001ecc - 0x10001f33
int32_t function_10001ecc(int32_t a1) {
    // 0x10001ecc
    int32_t v1; // 0x10001ecc
    int32_t * v2 = (int32_t *)(v1 - 0x4b07480 + 2 * v1); // 0x10001ecc
    int32_t v3; // 0x10001ecc
    bool v4; // 0x10001ecc
    *v2 = (int32_t)v4 - v3 + *v2;
    int32_t result = v1 | 11; // 0x10001ed3
    uint32_t v5; // 0x10001ecc
    uint32_t v6; // 0x10001ecc
    char v7 = (char)(v6 / 256) + (char)(v5 / 256); // 0x10001ed7
    int32_t v8 = v6 - 1; // 0x10001ed9
    if (v8 != 0 == v7 == 0) {
        // 0x10001f18
        return result;
    }
    if (result < -0x3ee09bb5) {
        // 0x10001f19
        *(int32_t *)-0x664de288 = result;
        *(int32_t *)0xf7987ba = result;
        int32_t v9; // 0x10001ecc
        int32_t * v10 = (int32_t *)(v9 - 34); // 0x10001f2b
        uint32_t v11 = *v10; // 0x10001f2b
        uint32_t v12 = v6 & 31; // 0x10001f2b
        if (v12 != 0) {
            *v10 = v11 >> v12 | v11 << 32 - v12;
        }
        // 0x10001f18
        int16_t result2; // 0x10001ecc
        return result2;
    }
    char v13 = *(char *)(v6 - 96 + v8) & v7; // 0x10001ef8
    int32_t v14 = __asm_wait(); // 0x10001f01
    int32_t v15; // 0x10001ecc
    int32_t v16 = &v15; // 0x10001f0a
    int32_t * v17 = (int32_t *)((v14 & -256 | (int32_t)*(char *)0x71bcb8) - 0x779c3ac0); // 0x10001f0b
    *v17 = 2 * *v17;
    char v18 = v16; // 0x10001f0f
    unsigned char v19 = v13 + v18; // 0x10001f0f
    int32_t result3 = v16 & -256 | (int32_t)v19; // 0x10001f0f
    if (((v19 ^ v18) & (v19 ^ v13)) < 0) {
        // 0x10001f14
        return result3 + 1;
    }
    // 0x10001f18
    return result3;
}

// Address range: 0x10001f34 - 0x10001f39
int32_t function_10001f34(int32_t a1) {
    // 0x10001f34
    uint32_t result; // 0x10001f34
    bool v1; // 0x10001f34
    *(char *)result = (char)(result / 256) + (char)result + (char)v1;
    return result;
}

// Address range: 0x10001f39 - 0x10001f3e
int32_t function_10001f39(int32_t a1) {
    // 0x10001f39
    int32_t v1; // 0x10001f39
    __asm_bound(*(int64_t *)&v1);
    int32_t result; // 0x10001f39
    return result;
}

// Address range: 0x10001f40 - 0x10001f4d
int32_t function_10001f40(void) {
    // 0x10001f40
    int32_t v1; // 0x10001f40
    int32_t v2; // 0x10001f40
    __asm_bound(*(int64_t *)(v1 - 0x3388bc89 + v2));
    __asm_iretd();
    return function_bfd67d2f();
}

// Address range: 0x10001f67 - 0x10001f75
int32_t function_10001f67(void) {
    // 0x10001f67
    __asm_int(141);
    int32_t result; // 0x10001f67
    return result;
}

// Address range: 0x10001f80 - 0x10001f93
int32_t function_10001f80(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t result, int32_t a8) {
    // 0x10001f80
    int32_t v1; // 0x10001f80
    int32_t v2; // 0x10001f80
    *(char *)v1 = (char)v2;
    int32_t * v3 = (int32_t *)(*(int32_t *)(result + 0x4d6ae89b) - 0x53239ec4); // 0x10001f88
    uint32_t v4 = *v3; // 0x10001f88
    bool v5; // 0x10001f80
    *v3 = v4 / 0x8000000 | 32 * (int32_t)v5 | 64 * v4;
    return result;
}

// Address range: 0x10001fa8 - 0x10001fd1
int32_t function_10001fa8(int32_t a1) {
    // 0x10001fa8
    int32_t v1; // 0x10001fa8
    int32_t * v2 = (int32_t *)(v1 - 0x1278029); // 0x10001fa8
    int32_t v3; // 0x10001fa8
    *v2 = *v2 | v3;
    *(char *)-0x260bbef5 = *(char *)-0x260bbef5 & (char)v3;
    int32_t v4; // 0x10001fa8
    __asm_in_6((int16_t)v4);
    return function_862bafd7();
}

// Address range: 0x10001fd1 - 0x10001fd2
int32_t function_10001fd1(int32_t a1) {
    // 0x10001fd1
    int32_t result; // 0x10001fd1
    return result;
}

// Address range: 0x10001fd3 - 0x100020cf
int32_t function_10001fd3(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = a2;
    int32_t v2; // 0x10001fd3
    unsigned char v3 = (char)v2; // 0x10001fdb
    int32_t v4; // 0x10001fd3
    *(char *)v4 = v3;
    bool v5; // 0x10001fd3
    int32_t v6 = v5 ? -1 : 1; // 0x10001fdb
    uint32_t v7; // 0x10001fd3
    int32_t v8 = v7 & -256 | 3; // 0x10001fdc
    int32_t v9; // 0x10001fd3
    bool v10 = (v9 + 1 & (v9 ^ -0x80000000)) < 0; // 0x10001fe3
    int32_t v11 = v8; // 0x10001fe3
    int32_t v12; // 0x10001fd3
    int32_t * v13 = &v12; // 0x10001fe3
    v12 = v6 + v4;
    int32_t v14; // 0x10001fd3
    float80_t v15; // 0x10001fd3
    if (v14 == 0) {
        // 0x10001fe5
        *(float80_t *)0x63e215a6 = __asm_fbstp(v15);
        int32_t v16 = 175 * v7 / 256 + v8; // 0x10001feb
        char v17 = v16; // 0x10001fee
        char v18 = *(char *)((v16 & 255 | v7 & -0x10000) + 0x1c2076fe); // 0x10001fee
        v10 = ((v17 - v18 ^ v17) & (v18 ^ v17)) < 0;
        v11 = __asm_wait();
        v13 = &v1;
    }
    // 0x10001ff5
    if (!v10) {
        int32_t v19 = __asm_sti() + 1; // 0x10002017
        int32_t v20 = v19 & 247 | 8; // 0x10002018
        *(char *)v12 = (char)v20;
        bool v21 = (a1 & 15) == 15 | (v20 & 14) > 9; // 0x1000201c
        int32_t v22 = (v21 ? v20 + 6 : v20) & 15; // 0x1000201c
        *(char *)0x17c79d04 = (char)v22;
        return v22 | v19 & -0x10000 | 256 * (int32_t)v21 + v19 & 0xff00;
    }
    float32_t v23 = *(float32_t *)(v14 - 0x10080618); // 0x10001ff5
    int32_t v24; // 0x10001fd3
    int16_t v25 = v24; // 0x10001ffd
    char * v26 = (char *)a1; // 0x10001ffd
    __asm_outsb(v25, *v26);
    int32_t result = v11 - 1; // 0x10002003
    int32_t v27 = v14 - 1; // 0x10002004
    if (v27 < 0) {
        // 0x10002007
        return result;
    }
    unsigned char v28 = (char)v24; // 0x10002025
    int32_t v29 = result & -256 | (v28 < (char)v27 ? 255 : 0); // 0x10002027
    int32_t * v30 = (int32_t *)a1; // 0x10002028
    *v30 = *v30 & v29;
    uint32_t v31 = v27 & -0x172d554; // 0x1000202c
    int32_t v32 = (int32_t)v13 | 2; // 0x10002031
    char * v33 = (char *)(v29 + 0x42721000); // 0x10002032
    *v33 = *v33 | (char)(v31 / 256);
    __asm_out(v25, v31);
    unsigned char v34 = *(char *)0x419dcee6; // 0x10002039
    *(char *)0x419dcee6 = v34 - v3;
    int32_t v35 = v29 + 1; // 0x1000203c
    int32_t v36 = v34 < v3 ? 0x419d0170 : 0x419d0171; // 0x1000203f
    *(char *)v31 = *v26;
    int32_t v37 = v6 + v31; // 0x10002042
    char * v38 = (char *)v36; // 0x10002043
    unsigned char v39 = *v38; // 0x10002043
    char v40 = v39 + v28; // 0x10002043
    *v38 = v40;
    int32_t v41; // 0x10001fd3
    int32_t v42; // 0x10001fd3
    int32_t v43; // 0x10001fd3
    int32_t v44; // 0x10001fd3
    int32_t v45; // 0x10001fd3
    uint32_t v46; // 0x10002076
    int32_t v47; // 0x1000207c
    int32_t result3; // 0x10002097
    int32_t v48; // 0x1000209a
    bool v49; // 0x10001fd3
    if (v40 < v39 || v40 == 0) {
        int32_t v50 = v32 - 4; // 0x10002058
        int32_t * v51 = (int32_t *)(v9 + 50); // 0x10002059
        int32_t v52 = *v51 & 104; // 0x10002059
        *v51 = v52;
        v41 = v36;
        v43 = v35;
        v44 = v37;
        if (v52 == 0) {
            goto lab_0x100020ba;
        } else {
            int32_t * v53 = (int32_t *)v50; // 0x10002058
            int32_t * v54 = (int32_t *)v37; // 0x10002073
            *v54 = *v54 - 93;
            int32_t v55 = *v53; // 0x10002076
            int32_t * v56 = (int32_t *)v32; // 0x10002076
            int32_t v57 = *v56; // 0x10002076
            int32_t * v58 = (int32_t *)(v32 + 4); // 0x10002076
            int32_t * v59 = (int32_t *)(v32 + 12); // 0x10002076
            int32_t v60 = *v59; // 0x10002076
            int32_t * v61 = (int32_t *)(v32 + 16); // 0x10002076
            int32_t v62 = *v61; // 0x10002076
            int32_t * v63 = (int32_t *)(v32 + 20); // 0x10002076
            v46 = *v63;
            int32_t v64 = v60 & -0xff01; // 0x10002077
            int32_t v65 = v60 + 0xee00 & 0xff00 | v64; // 0x10002077
            int32_t v66 = __asm_wait(); // 0x1000207a
            *(int32_t *)(v32 + 24) = v66;
            *v63 = v46;
            *v61 = v62;
            *v59 = v65;
            *(int32_t *)(v32 + 8) = v32 + 28;
            *v56 = v57;
            *v53 = v55;
            v47 = v55 - 1;
            *(int32_t *)(v65 - 0x399d09f1) = v57;
            *(char *)v66 = (char)v62;
            char * v67 = (char *)(v62 + 0x184b8e8e); // 0x10002085
            *v67 = *v67 & (char)(v46 / 256);
            unsigned char v68 = (char)v66; // 0x1000208b
            int32_t v69 = v68 > 153 ? v66 + 96 : v66;
            int16_t v70 = v62; // 0x1000208c
            char v71 = (v68 & 14) > 9 ? (v68 > 153 ? 102 : 6) + v66 : v69; // 0x1000208c
            __asm_out_7(v70, v71);
            int32_t v72 = v64 | 0x8700; // 0x1000208d
            char * v73 = (char *)v62; // 0x1000208f
            *v73 = *v73 + 2;
            __asm_wait();
            *(int32_t *)v47 = __asm_insd(v70);
            result3 = __asm_sldt();
            *(int16_t *)v62 = (int16_t)result3;
            v48 = *(int32_t *)(v72 - 83 + 2 * v62) + (v50 | (int32_t)((v71 ^ -8) < 8));
            v49 = v48 == 0;
            v45 = v62;
            v42 = v72;
            goto lab_0x1000209e;
        }
    } else {
        // 0x10002047
        v49 = false;
        result3 = v36;
        v46 = v35;
        v48 = v32;
        v47 = v37;
        if (v40 < 0 != ((v40 ^ v39) & (v40 ^ v28)) < 0) {
            // 0x10002049
            return unknown_b15a058();
        }
        goto lab_0x1000209e;
    }
  lab_0x100020ba:;
    unsigned char v74 = (char)v43 & 31; // 0x100020ba
    char * v75 = (char *)v43;
    if (v74 != 0) {
        *v75 = *v75 << v74;
    }
    int32_t result2 = v41 | 0x223d3c48; // 0x100020bd
    *(int32_t *)v44 = result2;
    *v75 = *v75 | 73;
    return result2;
  lab_0x1000209e:;
    int32_t v76 = v48;
    *(int16_t *)v42 = (int16_t)((float80_t)v23 - v15);
    if (!v49 && v46 != 1) {
        // 0x10002007
        return result3;
    }
    // 0x100020a2
    *(int32_t *)v76 = v76 + 4;
    int32_t result4 = __asm_int3(); // 0x100020a9
    if (v42 > 1) {
        // 0x10002007
        return result4;
    }
    // 0x100020ab
    *(char *)0x37980aef = (char)v45;
    v41 = *(int32_t *)-0x19b8b4b9;
    v43 = v46 - 2;
    v44 = v47;
    goto lab_0x100020ba;
}

// Address range: 0x100020cf - 0x100020da
int32_t function_100020cf(int32_t a1) {
    // 0x100020cf
    int32_t v1; // 0x100020cf
    bool v2; // 0x100020cf
    if (v1 == 1 || v2) {
        // 0x100020d1
        int32_t result; // 0x100020cf
        return result;
    }
    // 0x100020d6
    return __asm_int3();
}

// Address range: 0x100020da - 0x1000220c
int32_t function_100020da(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x100020da
    int32_t v1; // 0x100020da
    int32_t v2 = v1 - 0x6e21fcb5; // 0x100020db
    int32_t v3; // 0x100020da
    int32_t v4; // 0x100020da
    int32_t v5; // 0x100020da
    int32_t v6; // 0x100020da
    int32_t v7; // 0x100020da
    if (v2 < 0) {
        // 0x100020e2
        int32_t v8; // 0x100020da
        int32_t v9 = v8 & -256 | 139; // 0x100020e2
        int32_t v10; // 0x100020da
        if ((a2 & 2048) == 0) {
            // 0x100020e7
            int32_t v11; // 0x100020da
            int32_t v12 = *(int32_t *)(v10 + 6) | v11; // 0x100020e7
            int32_t v13; // 0x100020da
            int32_t * v14 = (int32_t *)(v13 + 43); // 0x100020eb
            *v14 = *v14 | v12;
            char * v15 = (char *)(4 * v13 + 0x18ca0423 + v12); // 0x100020ee
            *v15 = *v15 | -117;
            char * v16 = (char *)(2 * v9); // 0x100020f5
            *v16 = *v16 & (char)v12;
            int32_t v17 = unknown_5b64bc56(); // 0x100020f8
            char v18 = __asm_in_5(-120); // 0x10002102
            int32_t v19; // 0x100020da
            if (v19 == -1) {
                // 0x1000211d
                return function_d693b9bf();
            }
            int32_t v20 = v17 & -0x6231b200 | (int32_t)v18 | 0x6231b100; // 0x10002102
            int32_t v21 = *(int32_t *)(v20 - 10) | v9; // 0x10002107
            return v20 & -0xff01 | 0x8000 * (int32_t)(v21 < 0) | 1024 * (int32_t)((llvm_ctpop_i8((char)v21) & 1) == 0) | 512;
        }
        // 0x10002138
        __asm_fldenv(*(int224_t *)v9);
        int32_t v22 = v2 & -256 | (int32_t)__asm_in_5(2); // bp-1, 0x10002144
        int32_t * v23 = (int32_t *)(v10 - 123); // 0x10002145
        *v23 = *v23 & (int32_t)&v22;
        v4 = a6;
        v6 = a5;
        v3 = a4;
        int16_t v24; // 0x100020da
        v7 = v24;
        v5 = v22;
    }
    char * v25 = (char *)(v6 - 128); // 0x1000214c
    unsigned char v26 = *v25; // 0x1000214c
    *v25 = v26 / 128 | 2 * v26;
    int32_t v27 = __asm_hlt(); // 0x1000214f
    uint32_t v28 = v27 & -0x1cfa0334; // 0x10002154
    char * v29 = (char *)(v4 + 0x1b7906b9); // 0x1000215a
    unsigned char v30 = *v29; // 0x1000215a
    unsigned char v31 = (char)(v28 / 256); // 0x1000215a
    *v29 = v30 - v31;
    bool v32 = (char)v28 > 153 | v30 < v31;
    int32_t v33; // 0x100020da
    if ((v27 & 12) > 9 || (v30 & 15) - (v31 & 12) > 15) {
        v33 = (v32 ? 154 : 250) + v28 & 254 | v27 & -0x1cfa0400;
    } else {
        v33 = (v32 ? v28 + 160 : v28) & 236 | v27 & -0x1cfa0400;
    }
    char v34 = (char)v6 + 1; // 0x10002166
    if ((llvm_ctpop_i8(v34) & 1) != 0) {
        char * v35 = (char *)v33; // 0x100021be
        *v35 = *v35 + (char)v3;
        __asm_bound(*(int64_t *)(v5 + 2 * v4));
        return v33 ^ 52;
    }
    uint32_t v36 = *(int32_t *)-0xef43fe4; // 0x10002169
    char * v37 = (char *)(v7 + 7); // 0x100021c9
    *v37 = *v37 + (char)(v3 / 256);
    int32_t * v38 = (int32_t *)(v36 - 0x20f11f23); // 0x100021d0
    *v38 = *v38 - v36;
    unsigned char v39 = *(char *)0x114e897d; // 0x100021e5
    unsigned char v40 = v39 + v34; // 0x100021e5
    *(char *)0x114e897d = v40;
    unsigned char v41 = *(char *)0x114e000c | (char)v36; // 0x100021f2
    *(char *)0x114e000c = v41;
    uint16_t v42 = 12 * (int16_t)v41; // 0x100021f7
    char v43 = v42; // 0x100021f9
    char v44 = v42 > 255 ? 72 : 71; // 0x100021f9
    char v45 = v43 - v44; // 0x100021f9
    *(char *)(*(int32_t *)-0xef43fd8 - (v40 < v39 ? 0x1fa402d8 : 0x1fa402d7)) = v45;
    bool v46 = (v45 & 14) > 9 | (v43 & 12 | (char)(v42 > 255)) - (v44 & 15) > 15; // 0x100021fc
    *(char *)-0x6299b1e8 = (v46 ? v45 + 10 : v45) & 15;
    char * v47 = (char *)(v3 - 0xb109567); // 0x10002204
    *v47 = *v47 | (char)(v36 / 256);
    return 256 * ((int32_t)v46 + (int32_t)(v42 / 256)) & 0xff00 | 0x114e00ac;
}

// Address range: 0x10002228 - 0x1000222b
int32_t function_10002228(void) {
    // 0x10002228
    int32_t result; // 0x10002228
    return result;
}

// Address range: 0x10002250 - 0x10002286
int32_t function_10002250(int32_t a1) {
    // 0x10002250
    int32_t result; // 0x10002250
    bool v1; // 0x10002250
    if (!v1) {
        // 0x10002252
        return result;
    }
    // 0x10002263
    int32_t v2; // 0x10002250
    __asm_arpl((int16_t)v2, (int16_t)result);
    __asm_out_3(4, result);
    int32_t v3; // 0x10002250
    bool v4; // 0x10002250
    if (v4) {
        int32_t v5 = result & 255; // 0x1000225c
        int32_t result2 = v5 * v5 | result & -0x10000; // 0x1000225c
        char * v6 = (char *)result2; // 0x1000225e
        *v6 = *v6 + (char)v3;
        return result2;
    }
    int32_t v7 = __asm_in_4(180); // 0x1000226d
    unsigned char v8 = *(char *)v7; // 0x1000226f
    char * v9 = (char *)((v7 & 255) * (int32_t)v8 | v7 & -0x10000); // 0x10002271
    *v9 = *v9 + (char)v3;
    int32_t * v10 = (int32_t *)(v3 + 126); // 0x10002276
    int32_t v11; // 0x10002250
    *v10 = *v10 + v11;
    return function_40fc2dae();
}

// Address range: 0x10002286 - 0x10002289
int32_t function_10002286(int32_t a1) {
    // 0x10002286
    int32_t result; // 0x10002286
    return result;
}

// Address range: 0x100022c6 - 0x100022c9
int32_t function_100022c6(int32_t a1) {
    // 0x100022c6
    int32_t result; // 0x100022c6
    return result;
}

// Address range: 0x100022de - 0x100022ef
int32_t function_100022de(int32_t a1) {
    // 0x100022de
    uint32_t v1; // 0x100022de
    int32_t v2; // 0x100022de
    *(char *)v2 = (char)(v2 ^ v1 / 256);
    int32_t v3; // 0x100022de
    return v2 & 0x4428e300 | (int32_t)*(char *)&v3 | -0x4428e400;
}

// Address range: 0x100022ef - 0x100022f2
int32_t function_100022ef(void) {
    // 0x100022ef
    int32_t result; // 0x100022ef
    return result;
}

// Address range: 0x100022f2 - 0x10002315
int32_t function_100022f2(void) {
    int32_t v1 = __asm_wait(); // 0x100022f4
    __asm_int(232);
    int32_t v2; // 0x100022f2
    int32_t v3; // 0x100022f2
    float80_t v4; // 0x100022f2
    *(int16_t *)v3 = (int16_t)(v4 / (float80_t)(int16_t)v2);
    *(char *)-0x92bae33 = *(char *)-0x92bae33 + 32;
    int32_t v5; // 0x100022f2
    int32_t v6; // 0x100022f2
    char * v7 = (char *)((v1 | v5) & -256 | (int32_t)*(char *)(v6 + 0x332c95c)); // 0x1000230e
    *v7 = (char)v5 + 1 + *v7;
    return function_fff81cf8();
}

// Address range: 0x10002315 - 0x1000231a
int32_t function_10002315(void) {
    // 0x10002315
    return function_6d04b19d();
}

// Address range: 0x1000231a - 0x100023ef
int32_t function_1000231a(int32_t a1) {
    int32_t v1 = __asm_wait(); // 0x1000231a
    __asm_int(192);
    int32_t v2; // 0x1000231a
    int32_t v3; // 0x1000231a
    bool v4; // 0x1000231a
    if (!v4) {
        // 0x10002321
        *(int32_t *)v2 = __asm_insd((int16_t)v3);
        return function_fbf7bf95();
    }
    float64_t v5 = *(float64_t *)(v3 - 125); // 0x10002355
    int32_t v6 = v1 & -256; // 0x10002358
    int16_t v7 = v3; // 0x1000235a
    __asm_out(v7, v1 + 8 & 255 | v6);
    int32_t v8; // 0x1000231a
    unsigned char v9 = *(char *)(v8 - 0x7ef317cf); // 0x10002362
    uint32_t v10; // 0x1000231a
    int32_t v11; // 0x1000231a
    int32_t v12 = v9 < (char)(v11 + v10 / 256) + 1 ? -0x5e5eb96d : -0x5e5eb96e; // 0x1000236b
    int32_t v13 = (v6 | (int32_t)*(char *)0x27ba1000) - v12; // 0x1000236b
    int32_t v14; // 0x1000231a
    *(char *)v2 = *(char *)&v14;
    bool v15; // 0x1000231a
    int32_t v16 = (v15 ? -1 : 1) + v2; // 0x10002373
    char * v17 = (char *)v13; // 0x10002374
    char v18 = v3; // 0x10002374
    *v17 = *v17 + v18;
    v14 = 0x5f70cf7;
    char * v19 = (char *)(v13 & -256 | 161); // 0x1000237d
    *v19 = *v19 + v18;
    int32_t v20 = __asm_wait(); // 0x1000237f
    __asm_outsb(v7, *(char *)0x5f70cf7);
    int32_t v21 = v20 | -0x5254bab5; // 0x10002382
    char * v22 = (char *)v16; // 0x10002389
    unsigned char v23 = *v22 & v18; // 0x10002389
    int32_t v24 = v3 & -256 | (int32_t)v23; // 0x10002389
    char * v25 = (char *)(v21 - 13); // 0x1000238b
    unsigned char v26 = *v25; // 0x1000238b
    *v25 = v26 - v23;
    int32_t result = v21; // 0x1000238e
    int32_t v27 = v24; // 0x1000238e
    if (v26 < v23) {
        unsigned char v28 = (char)v11;
        result = __readgsdword(v14);
        v14 += ((v11 & 1024) != 0 ? -4 : 4);
        unsigned char v29 = v28 & 31; // 0x10002397
        if (v29 != 0) {
            char * v30 = (char *)(v16 + 91); // 0x10002397
            unsigned char v31 = *v30; // 0x10002397
            *v30 = v31 << v29 | (char)((v11 & 1) != 0) << v29 - 1 | (char)((int16_t)v31 >> (int16_t)(9 - v29));
        }
        int32_t v32 = v11 + v8; // 0x10002387
        if (v28 >= 0) {
            // 0x1000239c
            *v22 = *(char *)v14;
            char * v33 = (char *)result; // 0x1000239d
            unsigned char v34 = *v33; // 0x1000239d
            unsigned char v35 = v34 + v23; // 0x1000239d
            *v33 = v35;
            if (v35 < v34 || v35 == 0) {
                // 0x100023a5
                *(char *)(v16 + ((v11 & 1024) != 0 ? -1 : 1)) = __asm_insb((int16_t)v24);
                return result;
            }
            int16_t v36 = *(int16_t *)(v32 - 59 + 4 * v16); // 0x1000239f
            unsigned char v37 = (char)result; // 0x100023aa
            char * v38 = (char *)((result & -0x10000 | (int32_t)(v37 % 92) | 256 * (int32_t)(v37 / 92)) ^ -0x5bc79694); // 0x100023b3
            unsigned char v39 = *v38; // 0x100023b3
            unsigned char v40 = v39 + v23; // 0x100023b3
            *v38 = v40;
            float80_t v41; // 0x1000231a
            float80_t v42 = __asm_fbstp((v41 - (float80_t)v5) / (float80_t)v36); // 0x100023b5
            *(float80_t *)(v24 + 4 * v11) = v42;
            return __asm_sti() - (v40 < v39 ? 0x1000a1b1 : 0x1000a1b0);
        }
        int32_t * v43 = (int32_t *)(v32 + 0x58241ba); // 0x100023e3
        *v43 = v24;
        v27 = *v43 & -256 | 16;
    }
    int32_t * v44 = (int32_t *)(result - 96); // 0x100023eb
    *v44 = *v44 - v27;
    return result;
}

// Address range: 0x1000240f - 0x100024de
int32_t function_1000240f(int32_t a1) {
    // 0x1000240f
    int32_t v1; // 0x1000240f
    uint32_t v2 = v1 & 31; // 0x1000240f
    bool v3; // 0x1000240f
    int32_t v4; // 0x1000240f
    bool v5; // 0x1000240f
    if (v2 != 0) {
        int32_t v6; // 0x1000240f
        int32_t v7 = v6 >> v2; // 0x1000240f
        v5 = v7 == 0;
        v3 = (1 << v2 - 1 & v6) != 0;
        v4 = v7;
    }
    int32_t v8; // 0x1000240f
    int32_t v9; // 0x1000240f
    if (!v5 && !v3) {
        function_1000240f((int32_t)&g6);
        v8 = v9;
    }
    int32_t v10 = __asm_iretd(); // 0x10002420
    int32_t v11 = (v8 & 1024) == 0 ? 4 : -4; // 0x1000242b
    int32_t v12 = *(int32_t *)v4 - 0x5c3e49f5 + (int32_t)((v8 & 1) != 0); // 0x10002431
    int32_t v13; // 0x1000240f
    *(int32_t *)v13 = v12;
    int32_t v14 = v11 + v13; // 0x10002436
    int32_t v15 = *(int32_t *)v14; // 0x10002437
    if (((v12 - v15 ^ v12) & (v15 ^ v12)) >= 0) {
        // 0x1000243a
        int32_t result; // 0x1000240f
        return result;
    }
    int32_t v16 = v14 + v11; // 0x10002437
    int32_t v17 = (int32_t)&v9 | 2; // 0x10002441
    *(int32_t *)v12 = 0x8076018;
    float80_t v18; // 0x1000240f
    *(int16_t *)(v10 - 75) = (int16_t)v18;
    int32_t v19 = 0x10000 * v12 / 0x10000; // 0x1000244d
    int32_t v20; // 0x1000240f
    int32_t v21; // 0x1000240f
    int32_t v22; // 0x1000240f
    int32_t v23; // 0x1000240f
    int32_t v24; // 0x1000240f
    int32_t v25; // 0x1000240f
    if ((0xc378a7e - v19 & v19) >= 0) {
        int32_t v26 = v17 - 3; // 0x10002461
        *(int32_t *)v26 = 59;
        v20 = 59;
        v24 = v26;
        v21 = v16;
        goto lab_0x10002463;
    } else {
        // 0x1000245a
        v25 = v17;
        v23 = v11 + v4 | 0x8076018;
        v22 = v16;
        goto lab_0x10002464;
    }
  lab_0x10002463:
    // 0x10002463
    v25 = v24 + 4;
    v23 = v20;
    v22 = v21;
    goto lab_0x10002464;
  lab_0x10002464:;
    int32_t v27 = v23;
    int32_t v28 = v25;
    *(int32_t *)v22 = *(int32_t *)v27;
    int32_t v29 = (*(int32_t *)v28 & 1024) == 0 ? 4 : -4; // 0x10002465
    int32_t v30 = v29 + v22; // 0x10002465
    int32_t v31 = *(int32_t *)(v28 + 4); // 0x10002466
    while ((char)v31 < 0 == ((v31 & 2048) != 0) != ((v31 & 64) == 0)) {
        // 0x10002469
        v27 += v29;
        v28 += 9;
        *(int32_t *)v30 = *(int32_t *)v27;
        v29 = (*(int32_t *)v28 & 1024) == 0 ? 4 : -4;
        v30 += v29;
        v31 = *(int32_t *)(v28 + 4);
    }
    int32_t v32 = v28 + 8; // 0x10002466
    v20 = *(int32_t *)v32;
    v24 = v32;
    v21 = v30;
    goto lab_0x10002463;
}

// Address range: 0x100024de - 0x10002678
int32_t function_100024de(int32_t a1, int32_t a2) {
    int32_t v1 = __asm_fnstenv(); // 0x100024e0
    int32_t v2; // 0x100024de
    *(int224_t *)(v2 + 60) = (int224_t)v1;
    int32_t v3; // 0x100024de
    *(int32_t *)v3 = v1;
    uint32_t v4 = __asm_bound(*(int64_t *)v1); // 0x100024e8
    int32_t v5; // 0x100024de
    char * v6 = (char *)(v5 + 0x62fc45); // 0x100024ea
    char v7 = *v6; // 0x100024ea
    unsigned char v8 = (char)(v4 / 256); // 0x100024ea
    *v6 = v7 + v8;
    int32_t v9; // 0x100024de
    char * v10 = (char *)(v9 + 0x2cd48bc5); // 0x100024f0
    unsigned char v11 = *v10; // 0x100024f0
    unsigned char v12 = (char)v9; // 0x100024f0
    unsigned char v13 = v11 + v12; // 0x100024f0
    unsigned char v14 = v13 + (char)(-1 - v7 < v8); // 0x100024f0
    *v10 = v14;
    int32_t v15; // 0x100024de
    bool v16; // 0x100024de
    if ((v4 + 1 & (v4 ^ -0x80000000)) < 0) {
        // 0x100024fa
        __asm_bound(*(int64_t *)__asm_wait());
        char * v17 = (char *)(v3 - 51 + (v16 ? -4 : 4)); // 0x10002501
        char v18 = *v17; // 0x10002501
        *v17 = v18 + v12;
        uint32_t v19 = unknown_1063218c(); // 0x10002504
        char v20 = *(char *)&v15; // 0x10002509
        *(char *)v15 = v20 + (char)(-1 - v18 < v12) + (char)(v19 / 256);
        int32_t result = unknown_9041f8c9(); // 0x1000250b
        int32_t * v21 = (int32_t *)(v9 - 0x1964038f); // 0x10002510
        *v21 = *v21 + v9;
        return result;
    }
    // 0x10002519
    int32_t v22; // bp-1, 0x100024de
    int32_t v23 = &v22; // 0x100024e6
    uint32_t v24 = unknown_69ddfc9(); // 0x1000251a
    int32_t v25 = v2 - 1 & -256 | 188; // 0x10002521
    int16_t v26 = v25; // 0x10002523
    __asm_outsb(v26, *(char *)v15);
    __asm_outsd(v26, *(int32_t *)v15);
    bool v27 = v12 > 153 | (-1 - v7 < v8 ? v14 <= v11 : v13 < v11);
    int32_t v28; // 0x100024de
    if ((v12 & 14) > 9 || (v23 & 12) > 16) {
        v28 = (v27 ? 102 : 6) + v9 & 255 | v9 & -256;
    } else {
        v28 = (v27 ? v9 + 96 : v9) & 255 | v9 & -256;
    }
    uint32_t v29 = *(int32_t *)(v23 - 1); // 0x10002528
    int32_t v30 = __asm_bound(*(int64_t *)v28); // 0x10002530
    char * v31 = (char *)(v24 + 0x62fc1d); // 0x10002532
    char v32 = *v31; // 0x10002532
    unsigned char v33 = (char)v30; // 0x10002532
    *v31 = v32 + v33;
    char * v34 = (char *)(v30 - 0x78f837ef); // 0x10002538
    *v34 = *v34 + (char)(v29 / 256) + (char)(-1 - v32 < v33);
    int32_t v35 = v30 | 24; // 0x1000253e
    float80_t v36; // 0x100024de
    int16_t v37 = v36 - (float80_t)*(int32_t *)(v15 + 0x75298d5a); // 0x10002545
    *(int16_t *)v24 = v37;
    int32_t v38 = *(int32_t *)(v35 - 18) | v29; // 0x10002547
    bool v39; // 0x100024de
    bool v40; // 0x100024de
    bool v41; // 0x100024de
    int32_t v42 = 0x4000 * (int32_t)v39 | 1024 * (int32_t)v16 | 512 * (int32_t)v40 | 256 * (int32_t)v41 | 64 * (int32_t)(v38 == 0) | 128 * (int32_t)(v38 < 0) | 4 * (int32_t)((llvm_ctpop_i8((char)v38) & 1) == 0) | 2; // 0x1000254a
    *(int32_t *)-0x1089831d = v42;
    v15 += (v16 ? -1 : 1);
    while (v35 >= 1) {
        // continue -> 0x1000254f
    }
    int32_t v43 = *(int32_t *)-0x10898319; // 0x10002559
    int32_t v44 = v38 + 1 & -0xff01 | 0xa000; // 0x1000255e
    char * v45 = (char *)v44; // 0x10002560
    *v45 = *v45 - 68;
    int32_t * v46 = (int32_t *)(v43 - 103); // 0x10002562
    *v46 = *v46 - 1;
    char * v47 = (char *)(v44 - 56); // 0x1000256b
    *v47 = *v47 + 68;
    int32_t * v48 = (int32_t *)v25; // 0x10002570
    *v48 = *v48 + v44;
    *(int32_t *)-0x10898319 = -0x10898315;
    char * v49 = (char *)v24; // 0x1000258c
    *v49 = *v49 + (char)(v24 / 256);
    int32_t v50 = v44 - 4; // 0x10002598
    *(int32_t *)v50 = v42;
    int32_t v51 = (int32_t)*(char *)-0x3833f000 | 0x335efec8; // 0x1000259e
    if ((llvm_ctpop_i8((char)v51) & 1) != 0) {
        // 0x100025a6
        return __asm_int3();
    }
    char * v52 = (char *)(v44 - 0x68f8b124); // 0x100025d3
    *v52 = *v52 - 68;
    char * v53 = (char *)v51; // 0x100025d9
    *v53 = *v53 | -68;
    int32_t * v54 = (int32_t *)v24; // 0x100025db
    *v54 = *v54 & v50;
    int32_t v55 = v44 - 0x2eeda507; // 0x100025e3
    *(int32_t *)(v51 - 4) = v15;
    int32_t v56 = v55 & -0xff01 | 0xc400; // 0x100025e9
    *(char *)0x7f161000 = (char)v55;
    *(int16_t *)(v44 - 124 + v56) = v37;
    char * v57 = (char *)v56; // 0x100025f9
    *v57 = *v57 + *(char *)(v43 - 107);
    *(char *)0xa02c95 = *(char *)(v44 - 28);
    int32_t result2 = v43 ^ 94; // 0x100025fc
    if (result2 == 0) {
        // 0x1000266c
        return function_a1101dfb();
    }
    // 0x10002602
    return result2;
}

// Address range: 0x10002691 - 0x10002695
int32_t function_10002691(int32_t a1) {
    // 0x10002691
    int32_t result; // 0x10002691
    return result;
}

// Address range: 0x1000269d - 0x100026ed
int32_t function_1000269d(void) {
    // 0x1000269d
    int32_t v1; // 0x1000269d
    int32_t v2 = v1 & 231 | 24; // 0x1000269e
    int32_t v3; // 0x1000269d
    int32_t v4 = v3 + 1; // 0x100026a2
    int32_t v5 = (v2 | v1 & -256) + 1; // 0x100026a3
    int32_t v6; // 0x1000269d
    int16_t v7 = v6; // 0x100026a4
    unsigned char v8 = (char)v5; // 0x100026a4
    __asm_out_7(v7, v8);
    int32_t v9; // 0x1000269d
    float80_t v10; // 0x1000269d
    *(int64_t *)(v9 - 0x7b1daa2c) = (int64_t)v10;
    int32_t v11 = v8 < 175 ? v5 : v2 + 82; // 0x100026ab
    int32_t result3 = v11 & 255 | v5 & -0x10000 | 256 * (int32_t)(v8 > 174); // 0x100026ab
    int32_t v12 = *(int32_t *)-0x805357c; // 0x100026ae
    int32_t v13 = v12 - v4; // 0x100026ae
    *(int32_t *)-0x805357c = v13;
    __asm_out(v7, result3);
    int32_t result; // 0x1000269d
    if (((v13 ^ v12) & (v12 ^ v4)) >= 0) {
        // 0x100026b7
        return result;
    }
    if (v3 != 0) {
        // 0x100026e2
        __asm_int3();
        int32_t result2 = __asm_in_4(90); // 0x100026e8
        int32_t v14; // 0x1000269d
        *(int32_t *)v14 = __asm_insd((int16_t)(result2 >> 31));
        return result2;
    }
    char * v15 = (char *)(result3 - 10); // 0x100026cb
    unsigned char v16 = *v15; // 0x100026cb
    unsigned char v17 = (char)v6; // 0x100026cb
    *v15 = v16 - v17;
    char * v18 = (char *)(result - 0x58f8b120); // 0x100026d3
    *v18 = *v18 + v17 + (char)(v16 < v17);
    char * v19 = (char *)result3; // 0x100026d9
    *v19 = *v19 | v17;
    return result3;
}

// Address range: 0x100026f8 - 0x100027de
int32_t function_100026f8(int32_t a1, int32_t a2) {
    int32_t v1 = a1;
    int32_t v2; // 0x100026f8
    int32_t v3 = (v2 | (int32_t)__asm_in_5(88)) & -256 | (int32_t)__asm_in_5(-22); // 0x100026fe
    int32_t v4; // 0x100026f8
    int32_t v5 = *(int32_t *)(v4 - 0x2baafcc5); // 0x10002700
    int32_t v6; // 0x100026f8
    int32_t * v7 = (int32_t *)(v6 - 91 + 8 * (int32_t)&v1); // 0x1000270f
    *v7 = *v7 | v3;
    char * v8 = (char *)(v5 & -256 | (int32_t)((a1 & 1) != 0) | 2 * v5 & 254); // 0x10002716
    int32_t v9; // 0x100026f8
    char v10 = v9; // 0x10002716
    *v8 = *v8 + v10;
    char v11; // 0x100026f8
    int32_t v12 = v11; // 0x1000271a
    int32_t v13 = (v12 & 1) != 0 ? 767 : 512; // 0x1000271b
    int32_t v14 = 256 * (128 * (int32_t)(v11 < 0) | (int32_t)((v12 & 1) != 0) | 4 * (int32_t)((v12 & 4) != 0) | 16 * (int32_t)((v12 & 16) != 0) | 64 * (int32_t)((v12 & 64) != 0)) | v13 | v3 & -0x10000; // 0x1000271d
    int32_t v15; // 0x100026f8
    char * v16 = (char *)(v15 - 126); // 0x10002725
    *v16 = *v16 & v10 + 1;
    int32_t v17 = v14 + 1; // 0x1000272b
    int32_t v18; // 0x100026f8
    char * v19 = (char *)(v18 + 0x691000); // 0x1000272c
    *v19 = *v19 & 4;
    char * v20 = (char *)(v14 - 0x5fd3ab20); // 0x10002733
    char v21 = v18; // 0x10002733
    *v20 = *v20 | v21;
    char * v22 = (char *)v17; // 0x10002739
    *v22 = *v22 + v21;
    int32_t v23; // 0x100026f8
    *(char *)(v23 + 1) = *(char *)&v15;
    v15 += ((v12 & 1024) == 0 ? 1 : -1);
    __asm_out((int16_t)v18, v17);
    int32_t * v24 = (int32_t *)(v14 + 65); // 0x10002742
    *v24 = *v24 & 0x6dd1424a;
    int32_t result = v17 ^ 160; // 0x10002752
    char * v25 = (char *)result; // 0x10002754
    *v25 = *v25 + v21;
    return result;
}

// Address range: 0x100027e0 - 0x10002819
int32_t function_100027e0(int32_t a1) {
    // 0x100027e0
    uint32_t v1; // 0x100027e0
    int16_t v2 = (int16_t)v1 & -256 | 95; // 0x100027e2
    int32_t v3; // 0x100027e0
    int32_t v4 = __asm_bound(*(int64_t *)(v3 & -256 | (int32_t)__asm_in(v2))); // 0x100027e3
    int32_t v5; // 0x100027e0
    char * v6 = (char *)(v5 - 9); // 0x100027e5
    bool v7; // 0x100027e0
    *v6 = (char)v4 + (char)v7 + *v6;
    int32_t v8; // 0x100027e0
    char * v9 = (char *)(v8 + 0xa0b895); // 0x100027ed
    char v10 = *v9; // 0x100027ed
    uint32_t v11; // 0x100027e0
    unsigned char v12 = (char)(v11 / 256); // 0x100027ed
    *v9 = v10 + v12;
    int32_t v13; // 0x100027e0
    char * v14 = (char *)(v13 + 0x6c9335e0); // 0x100027f3
    unsigned char v15 = *v14; // 0x100027f3
    unsigned char v16 = v15 + 95 + (char)(-1 - v10 < v12); // 0x100027f3
    bool v17 = -1 - v10 < v12 ? v16 <= v15 : v15 > 160; // 0x100027f3
    *v14 = v16;
    int32_t v18; // 0x100027e0
    char * v19 = (char *)(v18 - 0xc29f000); // 0x100027f9
    *v19 = *v19 - (char)(v1 / 256) + (char)v17;
    int32_t v20 = __asm_bound(*(int64_t *)(v4 & 0xb60c62 | 0x1000a098)); // 0x10002806
    int32_t v21; // 0x100027e0
    char v22 = *(char *)&v21; // 0x10002808
    *(char *)v21 = v22 + v12;
    char v23 = __asm_in(v2); // 0x1000280d
    int64_t v24 = *(int64_t *)(256 * (int32_t)((char)v20 / 17) | v20 & -0x10000 | (int32_t)v23); // 0x1000280e
    int32_t result = __asm_bound(v24); // 0x1000280e
    char v25 = *(char *)0x75d3c891; // 0x10002810
    *(char *)0x75d3c891 = v25 + (char)(-1 - v22 < v12) + (char)v21;
    return result;
}

// Address range: 0x10002819 - 0x10002996
int32_t function_10002819(int32_t a1) {
    // 0x10002819
    __asm_in_5(64);
    *(int32_t *)0x40df0304 = 0x40df7c23;
    int32_t v1; // 0x10002819
    int32_t v2 = v1 + -1 - *(int32_t *)0x40df7c2f; // 0x1000282d
    int32_t v3 = *(int32_t *)0x14cf1000; // 0x10002830
    int32_t v4 = v3 + 84; // 0x10002835
    int32_t v5 = v4 & 255 | v3 & -256; // 0x10002835
    int32_t v6; // 0x10002819
    int32_t v7 = v6 & -0xff01; // 0x10002837
    char * v8 = (char *)(a1 - 34); // 0x10002839
    unsigned char v9 = *v8; // 0x10002839
    unsigned char v10 = v9 + (char)v4; // 0x10002839
    unsigned char v11 = v10 + (char)((char)v3 > 171); // 0x10002839
    bool v12 = (char)v3 > 171 ? v11 <= v9 : v10 < v9; // 0x10002839
    *v8 = v11;
    int16_t v13 = v7;
    __asm_out_7(v13, 35);
    unsigned char v14 = *(char *)0x48368b56; // 0x1000283e
    unsigned char v15 = v12 ? 125 : 124; // 0x1000283e
    *(char *)0x48368b56 = v14 - v15;
    *(int32_t *)0x40df0304 = 0x40df7c22;
    int32_t v16; // 0x10002819
    char * v17 = (char *)(v16 - 41); // 0x10002849
    unsigned char v18 = *v17 + 34 + (char)(v12 | v14 < v15); // 0x10002849
    *v17 = v18;
    unsigned char v19 = *(char *)0x55513805; // 0x1000284c
    uint32_t v20; // 0x10002819
    *(char *)0x55513805 = (char)(v20 / 256);
    int32_t v21 = 256 * (int32_t)v19 | v20 & -0xff01; // 0x1000284c
    uint32_t v22 = __asm_sti(); // 0x10002852
    uint32_t v23 = *(int32_t *)0x40df0304; // 0x10002859
    if (v18 >= 0) {
        char * v24 = (char *)v22; // 0x1000285c
        unsigned char v25 = *v24; // 0x1000285c
        char v26 = v25 / 128; // 0x1000285c
        *v24 = v26 | 2 * v25;
        char * v27 = (char *)(v5 + 0x773ad6b4); // 0x1000285e
        unsigned char v28 = *v27; // 0x1000285e
        char v29 = v6; // 0x1000285e
        unsigned char v30 = v28 + v29; // 0x1000285e
        unsigned char v31 = v30 + (char)(v26 != 0); // 0x1000285e
        bool v32 = v26 != 0 ? v31 <= v28 : v30 < v28; // 0x1000285e
        *v27 = v31;
        __asm_out(v13, v22);
        char * v33 = (char *)(a1 + 21 + 8 * v5); // 0x10002869
        *v33 = (char)v22 - 2 + *v33 + (char)v32;
        int32_t * v34 = (int32_t *)v21; // 0x1000286f
        *v34 = *v34 - 0x4fe204fe;
        uint32_t result = *(int32_t *)-0x3378f000; // 0x10002875
        char * v35 = (char *)(v2 - 0x4b6aa386 + result); // 0x1000287a
        char v36 = *v35; // 0x1000287a
        char v37 = v36 + v19; // 0x1000287a
        *v35 = v37;
        unsigned char v38 = (char)v20 & 31; // 0x10002881
        if (v38 == 0) {
            if (((v37 ^ v36) & (v37 ^ v19)) >= 0) {
                // 0x10002887
                return result;
            }
        } else {
            char * v39 = (char *)v21; // 0x10002881
            *v39 = *v39 >> v38;
            if (v38 != 1 != ((v37 ^ v36) & (v37 ^ v19)) < 0) {
                // 0x10002887
                return result;
            }
        }
        // 0x100028b2
        *(char *)a1 = __asm_insb(v13);
        char * v40 = (char *)result; // 0x100028b5
        unsigned char v41 = *v40; // 0x100028b5
        unsigned char v42 = v41 + v29; // 0x100028b5
        *v40 = v42;
        int32_t v43 = v42 < v41 ? 158 : 159; // 0x100028bf
        char * v44 = (char *)(v5 - 21); // 0x100028c8
        *v44 = *v44 + (char)v23;
        char * v45 = (char *)v23; // 0x100028cb
        *v45 = *v45 + 1;
        uint32_t v46 = *(int32_t *)(a1 + 0x5f5c5e56); // 0x100028cd
        return (0x100000000 * (int64_t)v7 | (int64_t)((251 * result / 256 + result + v43 & 255 | result & -0x10000) ^ 0x38785e3b)) / (int64_t)v46;
    }
    int16_t v47 = *(int16_t *)(v16 + (int32_t)&g4); // 0x10002853
    int32_t v48 = *(int32_t *)0x40df0308; // 0x1000288d
    char * v49 = (char *)(v48 + 20); // 0x1000288e
    char v50 = *v49; // 0x1000288e
    *v49 = v50 + (char)(v23 / 256) + (char)(v22 < *(int32_t *)a1);
    float80_t v51; // 0x10002819
    float80_t v52 = (float80_t)v47 - v51 - (float80_t)*(float64_t *)(v21 - 0x7e5af000); // 0x10002891
    uint16_t v53 = 256 * (int16_t)v22 / 256 * (int16_t)*(char *)v48; // 0x10002897
    char v54 = v53 / 256; // 0x10002897
    int32_t v55 = v22 & -0x10000 | (int32_t)v53; // 0x10002897
    *(int32_t *)0x40df0308 = v55;
    *(int32_t *)0x40df0304 = v21;
    *(int32_t *)0x40df0300 = v7;
    *(int32_t *)0x40df02fc = v23;
    *(int32_t *)0x40df02f8 = 0x40df030c;
    *(int32_t *)0x40df02f4 = v5;
    *(int32_t *)0x40df02f0 = v2;
    *(int32_t *)0x40df02ec = v48;
    int32_t v56 = v55 + 1; // 0x1000289a
    char * v57 = (char *)(v21 + 0x3b9f819d); // 0x1000289d
    unsigned char v58 = *v57; // 0x1000289d
    unsigned char v59 = v58 + (char)v56; // 0x1000289d
    unsigned char v60 = v59 + (char)(v54 != 0 == (v54 != -1)); // 0x1000289d
    *v57 = v60;
    if (v60 == 0 || (v54 != 0 == (v54 != -1) ? v60 <= v58 : v59 < v58)) {
        // 0x100028a5
        *(int16_t *)(2 * v2 - 94 + v55) = (int16_t)v52;
        char * v61 = (char *)v56; // 0x100028a9
        *v61 = *v61 + (char)v6;
        return *(int32_t *)v2;
    }
    // 0x100028e5
    *(int64_t *)(v2 + 0x6153c506) = (int64_t)v52;
    int32_t v62 = __asm_sti(); // 0x100028f2
    int32_t * v63 = (int32_t *)(v5 - 0x762d529b); // 0x100028f3
    int32_t v64 = *v63; // 0x100028f3
    *v63 = -v64;
    int32_t v65 = v5 - 1; // 0x100028f9
    int32_t v66 = v21 - 1; // 0x100028fa
    int16_t v67 = v13; // 0x100028fa
    int32_t v68 = v62; // 0x100028fa
    int32_t v69 = v66; // 0x100028fa
    int32_t v70 = 0x40df02ec; // 0x100028fa
    if (v65 == 0 || v66 == 0) {
        int32_t v71; // 0x10002819
        int32_t v72; // 0x10002819
        int32_t v73; // 0x10002819
        int32_t v74; // 0x10002819
        if ((v3 & -v5) < 0) {
            uint32_t v75 = *(int32_t *)0x40df02ec; // 0x1000295c
            char * v76 = (char *)(v21 - 101); // 0x1000295f
            *v76 = *v76 + (char)(v64 != 0) + (char)(v75 / 256);
            int32_t * v77 = (int32_t *)(v75 + 0x11000a1); // 0x10002962
            int32_t v78 = *v77; // 0x10002962
            *v77 = 2 * v78;
            v67 = v13;
            v71 = 0x2000000 * (int32_t)(v78 < 0);
            v72 = v75;
            v69 = v21 - 2;
            v73 = v7;
            v74 = 0x40df02ec;
        } else {
            char v79 = *(char *)(v7 - 22); // 0x100028fe
            uint32_t v80 = v62 >> 31; // 0x10002902
            unknown_d5b6d334();
            char v81 = *(char *)(__asm_int1() + 12); // 0x10002911
            int32_t v82 = 256 * (int32_t)(v81 + (char)(v80 / 256)) | v80 & -0xff01; // 0x10002911
            __asm_int3();
            uint32_t v83 = *(int32_t *)0x24f1000; // 0x1000291c
            *(char *)-0x74170ab7 = (char)v83;
            int32_t v84 = *(int32_t *)(v82 + 0x78e04f88); // 0x10002926
            int32_t v85 = ((256 * (int32_t)((char)(v62 / 256) - v79) | v62 & -0xff01) ^ 0x1000a1c8) - v84; // 0x10002926
            int32_t v86 = v83 - 0x41dfeff8; // 0x10002932
            *(int32_t *)0x40df02e8 = 0x40df02ec;
            *(int32_t *)0x40df02e4 = v48;
            if (v83 <= 0x41dfeff7) {
                int32_t v87 = v48 + 1; // 0x1000293a
                *(int32_t *)0x40df02e4 = v86;
                *(int32_t *)0x40df02e0 = v85;
                *(int32_t *)0x40df02dc = v82;
                *(int32_t *)0x40df02d8 = v87;
                *(int32_t *)0x40df02d4 = 0x40df02e8;
                *(int32_t *)0x40df02d0 = v65;
                *(int32_t *)0x40df02cc = 0x25835283;
                *(int32_t *)0x40df02c8 = v48;
                char * v88 = (char *)(v5 + 0xa1d0d0); // 0x10002940
                unsigned char v89 = *v88; // 0x10002940
                unsigned char v90 = v89 + (char)v87; // 0x10002940
                *v88 = v90;
                char * v91 = (char *)v85; // 0x10002946
                *v91 = *v91 + (char)v85 + (char)(v90 < v89);
                return v86 ^ -0x33787378;
            }
            // 0x100028fe
            v67 = v82;
            v71 = 0x2000000;
            v72 = v86;
            v69 = v85;
            v73 = v82;
            v74 = 0x40df02e4;
        }
        // 0x10002968
        v70 = v74;
        int32_t * v92 = (int32_t *)v73; // 0x10002968
        uint32_t v93 = *v92; // 0x10002968
        *v92 = v93 / 128 | v71 | 0x4000000 * v93;
        v68 = v72 + 1;
        *(int32_t *)v70 = v68;
    }
    int32_t v94 = v70;
    *(int32_t *)(v5 + 0x7dbed7d7) = v69;
    *(int32_t *)(v94 - 4) = v94;
    __asm_out(v67, v68 & -256 | (int32_t)*(char *)0x51528060);
    int32_t * v95 = (int32_t *)(*(int32_t *)-0x1499f000 - 17); // 0x10002982
    *v95 = *v95 ^ 0xa1d835;
    char v96 = *(char *)0x44d5a875; // 0x10002989
    *(char *)0x44d5a875 = v96 + (char)(v69 / 256);
    return function_ef4d59b8();
}

// Address range: 0x10002a17 - 0x10002a1e
int32_t function_10002a17(int32_t a1) {
    // 0x10002a17
    int32_t v1; // 0x10002a17
    int32_t v2; // 0x10002a17
    return v2 & -256 | (int32_t)*(char *)(v1 - 0x378f9b09);
}

// Address range: 0x10002a3a - 0x10002a3d
int32_t function_10002a3a(void) {
    // 0x10002a3a
    int32_t result; // 0x10002a3a
    return result;
}

// Address range: 0x10002a3d - 0x10002a43
int32_t function_10002a3d(void) {
    // 0x10002a3d
    int32_t v1; // 0x10002a3d
    return v1 | -0x17166c02;
}

// Address range: 0x10002a43 - 0x10002acf
int32_t function_10002a43(int32_t a1) {
    int32_t v1 = a1;
    int32_t v2; // 0x10002a43
    *(int32_t *)(v2 - 0x3bad3520) = (int32_t)&v1;
    int32_t v3; // 0x10002a43
    int32_t v4 = v3 - 1; // 0x10002a49
    int32_t result; // 0x10002a43
    bool v5; // 0x10002a43
    bool v6; // 0x10002a43
    if (v4 == 0 || v5) {
        // 0x10002a4b
        *(char *)0xb6acc2 = (char)result;
        int32_t v7; // 0x10002a43
        char * v8 = (char *)(v7 + 0x2ff08b15); // 0x10002a50
        *v8 = (char)v6 + (char)v4 + *v8;
        return result;
    }
    // 0x10002a5b
    int32_t v9; // 0x10002a43
    char * v10 = (char *)(8 * result + v9); // 0x10002a5b
    *v10 = (char)v6 + (char)result + *v10;
    return __asm_wait();
}

// Address range: 0x10002ad0 - 0x10002aec
int32_t function_10002ad0(void) {
    // 0x10002ad0
    int32_t v1; // 0x10002ad0
    bool v2; // 0x10002ad0
    bool v3; // 0x10002ad0
    if (v2 || !v3) {
        // 0x10002ad3
        int32_t v4; // 0x10002ad0
        uint32_t v5; // 0x10002ad0
        uint64_t v6 = (int64_t)*(int32_t *)(v4 - 40) * (int64_t)v5; // 0x10002ad3
        int32_t v7 = v6 / 0x100000000; // 0x10002ad3
        char * v8 = (char *)(v1 + 70); // 0x10002adb
        *v8 = *v8 + (char)(v6 / 0x10000000000) + (char)(v7 != 0);
        int32_t result = __asm_in_4(221); // 0x10002ade
        int32_t * v9 = (int32_t *)(v7 - 60); // 0x10002ae0
        int32_t v10; // 0x10002ad0
        *v9 = *v9 ^ v10;
        return result;
    }
    uint32_t v11 = v1 & 31; // 0x10002ae7
    if (v11 != 0) {
        int32_t v12; // 0x10002ad0
        int32_t * v13 = (int32_t *)(v12 + 90); // 0x10002ae7
        uint32_t v14 = *v13; // 0x10002ae7
        *v13 = v14 << v11 | (int32_t)((int64_t)v14 >> (int64_t)(33 - v11));
    }
    return function_10002b49((int32_t)&g6);
}

// Address range: 0x10002b06 - 0x10002b0d
int32_t function_10002b06(void) {
    // 0x10002b06
    return function_99a0aee4();
}

// Address range: 0x10002b0f - 0x10002b18
int32_t function_10002b0f(void) {
    // 0x10002b0f
    bool v1; // 0x10002b0f
    bool v2; // 0x10002b0f
    bool v3; // 0x10002b0f
    if (v2 == v1 == !v3) {
        function_10002b62();
    }
    // 0x10002b11
    return function_20102618();
}

// Address range: 0x10002b40 - 0x10002b47
int32_t function_10002b40(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, uint32_t a7) {
    unsigned char v1 = *(char *)a1; // 0x10002b43
    char * v2 = (char *)a7; // 0x10002b44
    *v2 = *v2 + (char)(a7 / 256) + (char)(*(char *)a2 < v1);
    return __asm_int3();
}

// Address range: 0x10002b49 - 0x10002b57
int32_t function_10002b49(int32_t a1) {
    // 0x10002b49
    uint32_t v1; // 0x10002b49
    char * v2 = (char *)(v1 ^ 95); // 0x10002b53
    *v2 = *v2 + (char)(v1 / 256);
    return __asm_int3();
}

// Address range: 0x10002b60 - 0x10002b62
int32_t function_10002b60(void) {
    // 0x10002b60
    uint32_t result; // 0x10002b60
    *(int32_t *)result = result / 2 | 0x80000000 * result;
    return result;
}

// Address range: 0x10002b62 - 0x10002baf
int32_t function_10002b62(void) {
    // 0x10002b62
    int32_t v1; // 0x10002b62
    unsigned char v2 = (char)v1; // 0x10002b62
    char v3 = v2 < 216 ? v2 : v2 + 40; // 0x10002b62
    bool v4; // 0x10002b62
    while (v3 < 0 == v4) {
        // continue -> 0x10002b64
    }
    int32_t v5 = __asm_sti(); // 0x10002b72
    int32_t v6; // 0x10002b62
    int32_t * v7 = (int32_t *)(v6 - 39); // 0x10002b73
    *v7 = *v7 + (v3 == -42 ? -54 : -53);
    unsigned char v8 = (char)v5 + 107; // 0x10002b7e
    int32_t v9 = v5 & -256 | (int32_t)v8; // 0x10002b80
    if (v8 == 0) {
        v9 = function_10002b60();
    }
    int32_t v10 = v9;
    int32_t v11; // 0x10002b62
    int32_t v12 = __asm_in_6((int16_t)v11); // 0x10002b88
    int32_t v13; // 0x10002b62
    int32_t v14 = v12 & -256 & *(int32_t *)(4 * v13 + 0xc71c284 + v12); // 0x10002b94
    int32_t v15; // 0x10002b62
    int32_t * v16 = (int32_t *)(v15 - 43); // 0x10002b9b
    *v16 = *v16 & v14;
    __asm_out_3(36, v14);
    *(int32_t *)(v10 + 4) = v10 + 8;
    int32_t result = v14; // 0x10002bab
    int32_t v17; // 0x10002b62
    int32_t v18; // 0x10002b62
    if ((v18 & -0x2801) != 1 == v17 == 5) {
        result = function_10002b40((int32_t)&g6, (int32_t)&g6, (int32_t)&g6, (int32_t)&g6, (int32_t)&g6, (int32_t)&g6, (int32_t)&g6);
    }
    // 0x10002bad
    return result;
}

// Address range: 0x10002bd5 - 0x10002bd6
int32_t function_10002bd5(void) {
    // 0x10002bd5
    int32_t result; // 0x10002bd5
    return result;
}

// Address range: 0x10002bdc - 0x10002be6
int32_t function_10002bdc(void) {
    // 0x10002bdc
    int32_t v1; // 0x10002bdc
    int32_t v2; // 0x10002bdc
    *(char *)v2 = (char)v2 + (char)v1;
    return unknown_fc350e();
}

// Address range: 0x10002be6 - 0x10002c2c
int32_t function_10002be6(void) {
    // 0x10002be6
    int32_t v1; // 0x10002be6
    int32_t v2 = v1 + 1; // 0x10002be6
    *(char *)0x68f32759 = *(char *)0x68f32759 - 3;
    uint32_t result; // 0x10002be6
    int32_t v3; // 0x10002be6
    char * v4 = (char *)(v3 + 112 + 8 * result); // 0x10002bef
    uint32_t v5; // 0x10002be6
    *v4 = *v4 | (char)v5;
    char * v6 = (char *)(v1 + 7); // 0x10002bf3
    *v6 = *v6 & (char)(v5 / 256);
    int32_t v7 = *(int32_t *)-0x5ef5f000; // 0x10002bfd
    int32_t v8 = v7 & 0xff00 & 256 * v7 | v7 & -0xff01; // 0x10002c04
    unsigned char v9 = *(char *)v8 | (char)v2; // 0x10002c09
    int32_t v10 = v2 & -256 | (int32_t)v9; // 0x10002c09
    int32_t v11 = v8 - 1; // 0x10002c0c
    if (v11 == 0) {
        // 0x10002c0f
        __asm_out((int16_t)v10, -0x8054d7c);
        int32_t v12; // 0x10002be6
        char * v13 = (char *)((v12 & -256 | 143) + 0xd150fff); // 0x10002c18
        *v13 = *v13 ^ (char)(result / 256);
        return result;
    }
    int32_t result2 = v11 | 161; // 0x10002c1f
    char * v14 = (char *)result2; // 0x10002c21
    *v14 = *v14 + v9;
    float80_t v15; // 0x10002be6
    *(int64_t *)(v10 + 96) = (int64_t)v15;
    return result2;
}

// Address range: 0x10002c2c - 0x10002d33
int32_t function_10002c2c(int32_t a1, int32_t a2) {
    // 0x10002c2c
    int32_t v1; // 0x10002c2c
    int32_t v2; // 0x10002c2c
    __asm_arpl(*(int16_t *)(v2 + 25), (int16_t)v1);
    int32_t v3 = v2 | -0x8051844; // 0x10002c2f
    uint32_t v4; // 0x10002c2c
    __asm_out((int16_t)v4, v3);
    uint32_t v5; // 0x10002c2c
    uint32_t v6 = v4 >> (v5 & 31);
    char v7 = __asm_in_5(-81); // 0x10002c37
    *(char *)-0x79bdda88 = v7;
    int32_t v8 = (v3 | (int32_t)v7) & -0x10000 | (int32_t)v7 | 0x8695; // 0x10002c40
    unsigned char v9 = *(char *)-0x33c7f000; // 0x10002c49
    int32_t v10 = v6 & -0xff01; // 0x10002c4e
    char * v11 = (char *)(v8 - 0x2011137f); // 0x10002c50
    char v12 = *v11; // 0x10002c50
    char v13 = v5; // 0x10002c50
    int32_t v14; // 0x10002c2c
    char v15 = *(char *)(v14 - 17) > (char)(v6 / 256); // 0x10002c50
    char v16 = v15 + v13 + v12; // 0x10002c50
    char v17 = v16 + v15; // 0x10002c50
    *v11 = v16;
    int32_t v18; // bp-4, 0x10002c2c
    int32_t v19; // bp-8, 0x10002c2c
    int32_t v20; // 0x10002c2c
    if (v16 < 0 == ((v17 ^ v12) & (v17 ^ v13)) < 0) {
        int32_t v21 = __asm_hlt(); // 0x10002c5d
        *(char *)v8 = *(char *)0x28defbd2;
        bool v22; // 0x10002c2c
        int32_t v23 = v22 ? -1 : 1; // 0x10002c5f
        int32_t v24 = v8 + v23; // 0x10002c5f
        char * v25 = (char *)v21; // 0x10002c60
        *v25 = *v25 + (char)v6;
        char * v26 = (char *)(v10 - 103); // 0x10002c68
        *v26 = *v26 + (char)v20;
        *(int32_t *)v24 = __asm_insd((int16_t)v10);
        int32_t v27 = *(int32_t *)(v23 + 0x28defbd2); // 0x10002c75
        v19 = &v18;
        int32_t v28; // 0x10002c2c
        __asm_into(v28);
        int32_t v29 = (v27 + 106 & 255 | v27 & -256) - 1 & -0x7dbefff5 | 0x7dbedff4; // 0x10002c83
        int32_t * v30 = (int32_t *)(v29 + 0x51000a1); // 0x10002c8a
        *v30 = v29 + *v30;
        int32_t * v31 = (int32_t *)(v24 - 93); // 0x10002c90
        *v31 = 8 * *v31;
        __asm_bound(*(int64_t *)(v24 + 120));
        return v29 & 0x1000812c;
    }
    int32_t v32 = v14 & -256 | (int32_t)v9; // 0x10002c49
    int32_t v33; // 0x10002c2c
    char * v34 = (char *)(v33 - 65); // 0x10002cac
    char v35 = *v34 & (char)v20; // 0x10002cac
    *v34 = v35;
    if (v35 >= 0 != v35 != 0) {
        // 0x10002cb1
        *(int32_t *)(v5 - 0x41201114) = v18;
        *(char *)v8 = __asm_insb((int16_t)v10);
        char v36 = *(char *)(4 * v5 + 16 + v32); // 0x10002cc1
        return (v14 & 0xff00 & 256 * v5 | v14 & -0x10000 | (int32_t)(v36 | v9)) ^ 0x7dbedd64;
    }
    // 0x10002d02
    float80_t v37; // 0x10002c2c
    *(float80_t *)(v10 + 4 * v5) = __asm_fbstp(v37);
    v19 = 0x28defbd2;
    uint32_t v38 = (int32_t)&v19; // 0x10002d08
    uint32_t v39 = v33 + v38; // 0x10002d0a
    int32_t v40 = __asm_bound(*(int64_t *)v32); // 0x10002d0c
    int32_t v41 = ((v40 & 14) > 9 ? v40 + 6 : v40) & 15; // 0x10002d12
    int32_t * v42 = (int32_t *)(v39 - 0xc858864); // 0x10002d19
    *v42 = -*v42;
    __asm_out_3(194, v41 | v40 & -0x10000 | 256 * (int32_t)((v40 & 14) > 9) + v40 & 0xff00);
    *(int32_t *)(v5 - 0x40a05135) = v6 + v5 / 256 + (int32_t)(v39 < v38) & 255 | v6 & -0x10000;
    return v40 & -0x7dbf0000 | v41 | 0x7dbe0020;
}

// Address range: 0x10002d34 - 0x10002d3b
int32_t function_10002d34(int32_t a1) {
    // 0x10002d34
    int32_t v1; // 0x10002d34
    int32_t result; // 0x10002d34
    __asm_out((int16_t)v1, result);
    return result;
}

// Address range: 0x10002d66 - 0x10002d6f
int32_t function_10002d66(void) {
    // 0x10002d66
    int32_t result; // 0x10002d66
    return result;
}

// Address range: 0x10002dc8 - 0x10002e63
int32_t function_10002dc8(int32_t a1, int32_t a2) {
    // 0x10002dc8
    int32_t v1; // 0x10002dc8
    char * v2 = (char *)(v1 + 0x2b1000a0); // 0x10002dc8
    unsigned char v3 = *v2; // 0x10002dc8
    uint32_t v4; // 0x10002dc8
    unsigned char v5 = v3 + (char)v4; // 0x10002dc8
    bool v6; // 0x10002dc8
    char v7 = v5 + (char)v6; // 0x10002dc8
    *v2 = v7;
    char v8; // 0x10002dc8
    int32_t v9; // 0x10002dc8
    int32_t v10; // 0x10002dc8
    int32_t v11; // 0x10002dc8
    int32_t v12; // 0x10002dc8
    if (v7 == 0 || (v6 ? v7 <= v3 : v5 < v3) ? v7 < 0 : v11 < 0) {
        // 0x10002dc8
        v8 = v12;
    } else {
        unsigned char v13 = *(char *)0x75781000; // 0x10002dd9
        int32_t v14 = v1 & -256 | (int32_t)v13; // 0x10002dd9
        int32_t v15; // 0x10002dc8
        *(char *)v15 = v13;
        char * v16 = (char *)v14; // 0x10002de9
        char v17 = v12;
        *v16 = *v16 + v17;
        uint32_t v18 = v14 + 1; // 0x10002deb
        char * v19 = (char *)v18; // 0x10002ded
        unsigned char v20 = *v19; // 0x10002ded
        char v21 = v20 / 128; // 0x10002ded
        *v19 = v21 | 2 * v20;
        char * v22 = (char *)(v12 + 106); // 0x10002def
        *v22 = *v22 + v17 + (char)(v21 != 0);
        int32_t v23 = v18 & -256 | (int32_t)(v13 + 9); // 0x10002df2
        char * v24 = (char *)v23; // 0x10002df4
        unsigned char v25 = *v24; // 0x10002df4
        unsigned char v26 = v25 + (char)(v18 / 256); // 0x10002df4
        *v24 = v26;
        char * v27 = (char *)(v23 + 69); // 0x10002dfb
        unsigned char v28 = *v27 + (char)(v4 / 256) + (char)(v26 < v25); // 0x10002dfb
        *v27 = v28;
        v8 = v17;
        v9 = a1;
        v10 = 0xa11897;
        if (v28 >= 0) {
            int32_t * v29 = (int32_t *)(v14 - 95); // 0x10002e02
            *v29 = *v29 / 2 | 0x80000000 * (int32_t)((a2 & 1) != 0);
            *v19 = *v19 + v17;
            return __asm_int1();
        }
    }
    int32_t v30 = v9;
    bool v31; // 0x10002dc8
    int32_t v32 = *(int32_t *)(v10 + (v31 ? 0x55d10fff : 0x55d11001)); // 0x10002e23
    __asm_bound(*(int64_t *)(v32 + 0x7f131000 + 4 * v32));
    int32_t v33 = *(int32_t *)-0x465cf000; // 0x10002e32
    *(char *)0x54efc57b = (char)v33;
    char * v34 = (char *)v33; // 0x10002e41
    unsigned char v35 = *v34; // 0x10002e41
    unsigned char v36 = v35 + v8; // 0x10002e41
    *v34 = v36;
    char v37 = *(char *)-0x286b33ff; // 0x10002e4f
    *(char *)-0x286b33ff = v37 - 33 + (char)(v36 < v35);
    int32_t * v38 = (int32_t *)(v33 + 40); // 0x10002e53
    *v38 = *v38 ^ v30;
    *(char *)(v32 + 2 * v30) = (char)v30;
    return unknown_2e3c(v33);
}

// Address range: 0x10002e63 - 0x10002e6c
int32_t function_10002e63(void) {
    // 0x10002e63
    int32_t v1; // 0x10002e63
    char * v2 = (char *)(v1 + 24); // 0x10002e66
    uint32_t v3; // 0x10002e63
    bool v4; // 0x10002e63
    *v2 = *v2 + (char)(v3 / 256) + (char)v4;
    int32_t result; // 0x10002e63
    return result;
}

// Address range: 0x10002e9d - 0x10002e9e
int32_t function_10002e9d(void) {
    // 0x10002e9d
    int32_t result; // 0x10002e9d
    return result;
}

// Address range: 0x10002f0c - 0x10002f14
int32_t function_10002f0c(void) {
    // 0x10002f0c
    int32_t v1; // 0x10002f0c
    char * v2 = (char *)(v1 + 127 + 4 * v1); // 0x10002f0c
    bool v3; // 0x10002f0c
    *v2 = *v2 - (v3 ? -122 : -123);
    int32_t result; // 0x10002f0c
    return result;
}

// Address range: 0x10003035 - 0x1000303d
int32_t function_10003035(void) {
    // 0x10003035
    return function_996e57db();
}

// Address range: 0x10003059 - 0x1000305a
int32_t function_10003059(void) {
    // 0x10003059
    int32_t result; // 0x10003059
    return result;
}

// Address range: 0x10003061 - 0x10003062
int32_t function_10003061(void) {
    // 0x10003061
    int32_t result; // 0x10003061
    return result;
}

// Address range: 0x100030a4 - 0x100030a5
int32_t function_100030a4(void) {
    // 0x100030a4
    int32_t result; // 0x100030a4
    return result;
}

// Address range: 0x100030b1 - 0x100030b4
int32_t function_100030b1(void) {
    // 0x100030b1
    int32_t result; // 0x100030b1
    return result;
}

// Address range: 0x100030b4 - 0x10003119
int32_t function_100030b4(void) {
    // 0x100030b4
    int32_t v1; // 0x100030b4
    bool v2; // 0x100030b4
    bool v3; // 0x100030b4
    if (v2 || v3) {
        v1 = function_10003061();
    }
    int32_t v4 = v1 + 190; // 0x100030b6
    int32_t v5; // 0x100030b4
    int64_t v6 = *(int64_t *)&v5; // 0x100030b8
    __asm_bound(v6);
    int32_t v7; // 0x100030b4
    char * v8 = (char *)(v7 + 0x87ce76a); // 0x100030bc
    *v8 = *v8 ^ (char)v6;
    *(char *)0x594c550b = (char)v4;
    int32_t v9 = -119 * *(int32_t *)((v4 & 255 | v1 & -256) + 103) + 1; // 0x100030d2
    v5 = v9;
    uint32_t v10; // 0x100030b4
    char v11 = *(char *)(v10 - 23) ^ (char)(v10 / 256); // 0x100030d3
    if (v11 >= 0) {
        function_10003059();
    }
    // 0x100030d8
    int32_t v12; // 0x100030b4
    uint32_t v13 = v12 - 0x18d887b9; // 0x100030c7
    __asm_outsb((int16_t)v12, *(char *)v13);
    int32_t v14; // 0x100030b4
    int32_t * v15 = (int32_t *)(v14 - 12 + v9); // 0x100030da
    int32_t v16; // bp-36, 0x100030b4
    *v15 = *v15 - (int32_t)&v16;
    int32_t v17 = v13 & 27 | 228; // 0x100030e6
    int32_t v18 = v17 | v13 & -256; // 0x100030e6
    char v19 = *(char *)(v14 + 0x175f4258); // 0x100030e8
    char * v20 = (char *)((256 * (int32_t)(v19 | v11) | v10 & -0xff01) + 0x4d8f64c9); // 0x100030ee
    *v20 = *v20 - 38;
    char v21 = v13 / 256; // 0x100030f6
    *(char *)v12 = v21;
    int32_t * v22 = (int32_t *)v18; // 0x100030f8
    uint32_t v23 = *v22; // 0x100030f8
    uint32_t v24 = v5 - 1 + v23; // 0x100030f8
    *v22 = v24;
    *(char *)v12 = *(char *)&v12 + v21 + (char)(v24 < v23);
    __asm_out_7(0x35e0, (char)v17);
    __asm_out(0x35e0, v18);
    *(int32_t *)v7 = __asm_insd(0x35e0);
    return v13 & 0x324a8000 | -0x3b4af11a;
}

// Address range: 0x10003119 - 0x1000311e
int32_t function_10003119(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x10003119
    return function_100030a4();
}

// Address range: 0x1000311e - 0x1000ba00
int32_t function_1000311e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17, int32_t a18, int32_t a19) {
    // 0x1000311e
    int32_t v1; // 0x1000311e
    int32_t v2 = v1 & 228 | 27; // 0x1000311e
    int32_t v3; // 0x1000311e
    int32_t v4 = v3 & -256 | 250; // 0x10003127
    __asm_out_3(237, ((char)v2 > 153 ? 102 : 6) + v2 & 229 | v1 & -256);
    char * v5 = (char *)(v4 - 24); // 0x10003133
    *v5 = *v5 / 2;
    uint32_t v6; // 0x1000311e
    int64_t v7 = v6; // 0x10003137
    int64_t v8 = 8 * v7; // 0x10003137
    int32_t v9 = v8; // 0x10003137
    uint32_t v10 = v6 + v9; // 0x1000313a
    bool v11 = v8 != 0x800000000 * v7 / 0x100000000 ? v10 + (int32_t)(v8 != 0x800000000 * v7 / 0x100000000) <= v6 : v10 < v6; // 0x1000313a
    uint32_t v12 = v9 - 0x5fa7e687 + (int32_t)v11; // 0x1000313c
    char * v13 = (char *)v12; // 0x10003141
    int32_t v14; // 0x1000311e
    char v15 = v14; // 0x10003141
    *v13 = *v13 + v15;
    int32_t v16 = v14 + 13; // 0x10003145
    int32_t result = v12 & -256 | v16 & 255; // 0x10003145
    char * v17 = (char *)result; // 0x10003147
    unsigned char v18 = *v17 + v15; // 0x10003147
    *v17 = v18;
    if (v18 >= 1) {
        // 0x1000314b
        __asm_out_7((int16_t)v14 & 255 | -0x3e00, (char)v16);
        *v17 = *v17 + v15;
        return result;
    }
    char * v19 = (char *)(v4 - 127); // 0x10003165
    *v19 = *v19 & v15;
    char * v20 = (char *)(v4 + 0x437b0fff); // 0x1000316a
    char v21 = *v20 - (char)(v12 / 256); // 0x1000316a
    *v20 = v21;
    if (v21 != 0) {
        // 0x10003172
        return __asm_sti() - 1;
    }
    // 0x1000317e
    __asm_out_3(31, result);
    char * v22; // 0x1000311e
    int32_t v23 = (int32_t)v22; // 0x10003180
    int16_t * v24; // 0x1000311e
    int32_t v25 = (int32_t)v24; // 0x10003180
    char * v26; // 0x1000311e
    int32_t v27 = (int32_t)v26; // 0x10003180
    int32_t * v28 = (int32_t *)(v27 - 96); // 0x10003182
    int32_t v29; // 0x1000311e
    *v28 = *v28 / 2 | 0x80000000 * (int32_t)((v29 & 1) != 0);
    int32_t * v30 = (int32_t *)(v27 + 82); // 0x10003187
    uint32_t v31 = *v30; // 0x10003187
    uint32_t v32 = v31 + v23; // 0x10003187
    *v30 = v32;
    int16_t v33; // 0x1000311e
    int32_t v34 = v33; // 0x1000318b
    char v35; // 0x1000311e
    int32_t v36 = (int32_t)v35 + 1; // 0x1000318c
    uint16_t v37; // 0x1000311e
    char * v38 = (char *)(int32_t)v37; // bp+796, 0x1000318d
    int32_t v39 = (int32_t)&v38; // 0x1000318d
    char * v40 = (char *)(v25 - 0x41223773); // 0x10003191
    unsigned char v41 = *v40; // 0x10003191
    char v42 = v25; // 0x10003191
    char v43 = v32 < v31; // 0x10003191
    unsigned char v44 = v41 + v42; // 0x10003191
    char v45 = v44 + v43; // 0x10003191
    char v46 = v45 + v43; // 0x10003191
    *v40 = v45;
    int32_t result2; // 0x1000311e
    if (v45 < 0 == ((v46 ^ v41) & (v46 ^ v42)) < 0) {
        bool v47 = v32 < v31 ? v45 <= v41 : v44 < v41; // 0x1000311e
        int32_t v48; // bp+19408, 0x1000311e
        int32_t v49 = &v48;
        int32_t v50 = v36;
        uint32_t v51 = v27;
        int32_t * v52 = (int32_t *)v49; // 0x100031ed
        int32_t v53 = *v52; // 0x100031ed
        char * v54 = (char *)(v53 + 116); // 0x100031ee
        unsigned char v55 = *v54; // 0x100031ee
        unsigned char v56 = v55 + (char)(v34 / 256); // 0x100031ee
        unsigned char v57 = v56 + (char)v47; // 0x100031ee
        bool v58 = v47 ? v57 <= v55 : v56 < v55; // 0x100031ee
        *v54 = v57;
        *(char *)-0x2a5b7277 = (char)v51;
        int32_t v59 = 2 * v51 + 0x6230e010; // 0x100031fd
        char v60 = v51 / 256; // 0x100031fd
        __writefsbyte(v59, __readfsbyte(v59) - v60 + (char)v58);
        char * v61 = (char *)v51; // 0x10003206
        char v62 = v50;
        *v61 = *v61 + v62;
        int16_t v63 = v50;
        int32_t v64 = __asm_insd(v63); // 0x10003208
        int32_t * v65 = (int32_t *)v53;
        *v65 = v64;
        int32_t v66 = v50 & 255 ^ v51; // 0x10003209
        char * v67 = (char *)v66;
        unsigned char v68 = *v67; // 0x1000320b
        unsigned char v69 = v68 + v62; // 0x1000320b
        *v67 = v69;
        *v52 = v39;
        int32_t v70 = v49 + 0x4900; // 0x1000320d
        char * v71 = (char *)(v53 + 0x63efdbae); // 0x10003211
        unsigned char v72 = *v71; // 0x10003211
        unsigned char v73 = v72 + v62; // 0x10003211
        unsigned char v74 = v73 + (char)(v69 < v68); // 0x10003211
        *v71 = v74;
        *(int32_t *)0x6057c685 = v66;
        char v75 = *(char *)v24; // 0x1000321a
        char v76 = v69 < v68 ? v74 <= v72 : v73 < v72; // 0x1000321a
        char v77 = v75 + v60 + v76; // 0x1000321a
        char v78 = v77 + v76; // 0x1000321a
        *(char *)v24 = v77;
        __asm_arpl(*(int16_t *)0x743a46dc, (int16_t)v66);
        while (((v78 ^ v75) & (v78 ^ v60)) >= 0) {
            // 0x10003224
            float80_t v79; // 0x1000311e
            float80_t v80 = v79 / (float80_t)*(int16_t *)-0x73820483; // 0x100031fb
            __asm_out(v63, v66);
            if (v77 >= 0) {
                // 0x10003299
                *v67 = *v67 | v62;
                return *(int32_t *)0x60202b;
            }
            int32_t v81 = v50 + 1; // 0x10003229
            unsigned char v82 = *v67; // 0x10003243
            unsigned char v83 = v82 + (char)v81; // 0x10003243
            *v67 = v83;
            *(int32_t *)0xd0c07c = v66;
            *(char *)v34 = *(char *)&v33 + (char)(v25 / 256) + (char)(v83 < v82);
            *(char *)v24 = *(char *)v24 + 2;
            __asm_outsb((int16_t)v81, *(char *)-0x73820483);
            int32_t v84 = *(int32_t *)(v25 - 0x10ff46f1); // 0x10003255
            int32_t v85 = (v66 + 1 & 255 | v51 & -256) + (int32_t)((char)v66 < 255) + v84; // 0x10003255
            uint32_t v86 = *(int32_t *)(*(int32_t *)v70 - 17); // 0x10003262
            v47 = v86 > 0x8c7dfb7d;
            v79 = (float80_t)*(int16_t *)(v49 + 0x7fb08ca1) / v80;
            int32_t v87 = v49; // 0x10003265
            result2 = v85;
            if (((v86 ^ -0x80000000) & 0xc7dfb7d - v86) >= 0) {
                // 0x10003267
                return result2;
            }
            v49 += 0x4904;
            v50 = v81;
            v51 = v85;
            v52 = (int32_t *)v49;
            v53 = *v52;
            v54 = (char *)(v53 + 116);
            v55 = *v54;
            v56 = v55 + (char)(v34 / 256);
            v57 = v56 + (char)v47;
            v58 = v47 ? v57 <= v55 : v56 < v55;
            *v54 = v57;
            *(char *)-0x2a5b7277 = (char)v51;
            v59 = 2 * v51 + 0x6230e010;
            v60 = v51 / 256;
            __writefsbyte(v59, __readfsbyte(v59) - v60 + (char)v58);
            v61 = (char *)v51;
            v62 = v50;
            *v61 = *v61 + v62;
            v63 = v50;
            v64 = __asm_insd(v63);
            v65 = (int32_t *)v53;
            *v65 = v64;
            v66 = v50 & 255 ^ v51;
            v67 = (char *)v66;
            v68 = *v67;
            v69 = v68 + v62;
            *v67 = v69;
            *v52 = v87;
            v70 = v49 + 0x4900;
            v71 = (char *)(v53 + 0x63efdbae);
            v72 = *v71;
            v73 = v72 + v62;
            v74 = v73 + (char)(v69 < v68);
            *v71 = v74;
            *(int32_t *)0x6057c685 = v66;
            v75 = *(char *)v24;
            v76 = v69 < v68 ? v74 <= v72 : v73 < v72;
            v77 = v75 + v60 + v76;
            v78 = v77 + v76;
            *(char *)v24 = v77;
            __asm_arpl(*(int16_t *)0x743a46dc, (int16_t)v66);
        }
        unsigned char v88 = (char)v66; // 0x100032a1
        unsigned char v89 = v88 + 111; // 0x100032a1
        int32_t v90 = v51 & -256; // 0x100032a1
        if (v88 > 144 || v89 == 0) {
            int32_t result3 = v90 | (int32_t)v89; // 0x100032a1
            char * v91 = (char *)result3; // 0x100032a7
            *v91 = *v91 + v62;
            return result3;
        }
        char v92 = __asm_in(v63); // 0x100032aa
        uint32_t v93 = v90 | (int32_t)v92; // 0x100032aa
        *v65 = v93;
        int32_t * v94 = (int32_t *)v70; // 0x100032ad
        char v95 = v92 ^ -90; // 0x100032ae
        int32_t v96 = v95; // 0x100032ae
        int32_t v97 = v93 & -256 | v96; // 0x100032ae
        *v94 = v50;
        *(int32_t *)(v49 + 0x48fc) = v25;
        *(int32_t *)(v49 + 76) = v25;
        int32_t v98 = v97; // 0x100032b7
        if (v95 < 0) {
            char v99 = *(char *)(v25 - 0x33fcf000); // 0x100032b9
            *(char *)*v94 = __asm_insb(v63);
            bool v100 = (v96 & 14) > 9 | (v99 & 15) - ((char)(v93 / 256) & 15) > 15; // 0x100032c0
            int32_t v101 = v100 ? v96 + 10 : v96; // 0x100032c0
            v98 = v101 & 15 | v93 & -0x10000 | 256 * (int32_t)v100 + v97 & 0xff00;
            __asm_out(v63, v98);
            *(int32_t *)(v49 - 0x21fb09c8) = v49;
        }
        int32_t v102 = v98;
        *(int32_t *)v24 = *(int32_t *)v24 - 0x73820483;
        char * v103 = (char *)v102; // 0x100032cd
        *v103 = *v103 + v62;
        return v102 & -256 | (int32_t)*(char *)((v102 & 255) + v34);
    }
    unsigned char v104 = *v26; // 0x100031a3
    char v105 = v36; // 0x100031a3
    char v106 = v104 + v105; // 0x100031a3
    int32_t v107 = v34; // bp+19400, 0x100031a6
    bool v108 = v106 < v104; // 0x100031a7
    bool v109 = v106 < 0; // 0x100031a7
    bool v110 = ((v106 ^ v104) & (v106 ^ v105)) < 0; // 0x100031a7
    int32_t v111 = v27; // 0x100031a7
    int32_t v112 = v25; // 0x100031a7
    int32_t v113 = v36; // 0x100031a7
    int32_t v114 = v34; // 0x100031a7
    int32_t v115 = &v107; // 0x100031a7
    int32_t v116 = v39; // 0x100031a7
    int32_t v117 = v23; // 0x100031a7
    int32_t v118; // 0x1000311e
    int32_t v119; // 0x1000311e
    int32_t v120; // 0x1000311e
    int32_t v121; // 0x1000311e
    int32_t v122; // 0x1000311e
    int32_t v123; // 0x1000311e
    int32_t v124; // 0x1000311e
    int32_t v125; // 0x1000311e
    int32_t v126; // 0x1000311e
    int32_t v127; // 0x1000311e
    int16_t v128; // 0x1000311e
    int16_t v129; // 0x1000311e
    int16_t v130; // 0x1000311e
    int32_t v131; // 0x1000311e
    int32_t v132; // 0x1000311e
    int32_t v133; // 0x1000311e
    int32_t v134; // 0x1000311e
    int32_t v135; // 0x1000b758
    int32_t v136; // 0x1000b758
    int32_t v137; // 0x1000b758
    int32_t v138; // 0x1000b758
    uint32_t v139; // 0x1000b758
    int32_t * v140; // 0x1000311e
    int32_t v141; // 0x1000b758
    int32_t v142; // 0x1000b768
    char * v143; // 0x1000b855
    bool v144; // 0x1000311e
    while (true) {
        int32_t v145 = v117;
        int32_t v146; // 0x1000311e
        int32_t v147 = v146;
        int32_t v148 = v116;
        v133 = v115;
        v122 = v114;
        int32_t v149 = v113;
        int32_t v150 = v112;
        int32_t v151 = v111;
        int16_t v152; // 0x1000311e
        v128 = v152;
        int32_t v153 = v133 - 4; // 0x1000b744
        int32_t * v154 = (int32_t *)v153; // 0x1000b744
        *v154 = v122;
        bool v155; // 0x1000311e
        bool v156; // 0x1000311e
        int32_t v157; // 0x1000311e
        int32_t v158; // 0x1000311e
        int16_t v159; // 0x1000311e
        int32_t v160; // 0x1000311e
        if (v109 == v110) {
            int32_t v161 = v151 + 0x7628140a; // 0x1000b748
            __asm_int(125);
            unsigned char v162 = (char)v161; // 0x1000b751
            unsigned char v163 = *(char *)((v150 & -256 | 1) + v161) + v162; // 0x1000b751
            *v154 = v122;
            char v164 = llvm_ctpop_i8(v163 - 15 + (char)(v163 < v162)); // 0x1000b756
            v135 = v133 + 24;
            v136 = *(int32_t *)v133;
            v137 = *(int32_t *)(v133 + 4);
            v138 = *(int32_t *)(v133 + 16);
            v139 = *(int32_t *)(v133 + 20);
            v140 = (int32_t *)v135;
            v141 = *v140;
            if ((v164 & 1) == 0) {
                // break -> 0x1000b7ac
                break;
            }
            int32_t v165 = v137 + 1; // 0x1000b75b
            __asm_out((int16_t)v138, v141);
            int32_t v166 = __asm_bound(*(int64_t *)v141); // 0x1000b75e
            int32_t v167 = v138 + 1; // 0x1000b760
            int16_t v168 = *(int16_t *)(v133 + 28); // 0x1000b761
            int32_t v169 = v141 & -256; // 0x1000b762
            int32_t v170 = v169 | 253; // 0x1000b762
            *(int32_t *)(v133 + 26) = v170;
            *(int32_t *)(v133 + 22) = v139;
            *(int32_t *)(v133 + 18) = v167;
            *(int32_t *)(v133 + 14) = v166;
            *(int32_t *)(v133 + 10) = v133 + 30;
            *(int32_t *)(v133 + 6) = v165;
            *(int32_t *)(v133 + 2) = v136;
            *(int32_t *)(v133 - 2) = v122;
            v142 = v165 - *(int32_t *)(v136 + 120);
            int32_t v171 = v133 - 1;
            int32_t v172 = v133 - 5;
            *(int32_t *)v172 = v170;
            unsigned char v173 = *(char *)0x77638040; // 0x1000b76d
            if ((v171 & 1 - v133) < 0) {
                // 0x1000b855
                v143 = (char *)(v139 - 125);
                char v174 = *v143 & v173; // 0x1000b855
                *v143 = v174;
                if (v174 >= 0 != v174 != 0) {
                    int32_t result4 = __asm_int1(); // 0x1000b85d
                    *(int32_t *)v122 = __asm_insd((int16_t)v167);
                    *(int32_t *)v171 = 84;
                    return result4;
                }
            }
            int32_t v175 = v166 ^ v165; // 0x1000b766
            int32_t v176 = v169 | (int32_t)v173; // 0x1000b76d
            if (v171 >= 0 == (v171 != 0)) {
                int32_t v177 = v139 + 1; // 0x1000b765
                v131 = v136;
                v120 = v142;
                v134 = v172;
                v123 = v175;
                v126 = v167;
                v124 = v177;
                v118 = v176;
                v129 = v168;
                v132 = v136;
                v121 = v142;
                v127 = v167;
                v130 = v168;
                v144 = v171 == 0;
                v119 = v176;
                v125 = v177;
                if (v171 >= 0) {
                    goto lab_0x1000b819;
                } else {
                    goto lab_0x1000b7c6;
                }
            }
            unsigned char v178 = *(char *)(v122 + 62); // 0x1000b777
            char v179 = llvm_ctpop_i8(v178 - 84); // 0x1000b777
            int32_t v180 = v133 - 7; // 0x1000b77b
            *(int16_t *)v180 = v33;
            v156 = v178 < 84;
            v155 = (v178 & 15) > 19;
            v159 = v168;
            v157 = v176;
            v112 = v139 + 2;
            v158 = v167;
            v114 = v175;
            v160 = v180;
            v116 = v142;
            v117 = v122;
            if ((v179 & 1) != 0) {
                // 0x1000b77e
                *(char *)(v122 - 1) = __asm_insb((int16_t)*(int32_t *)v180);
                __asm_sti();
                int16_t v181 = (int16_t)*(int32_t *)(v133 + 17); // 0x1000b7a0
                __asm_outsb(v181, *(char *)*(int32_t *)(v133 + 1));
                int32_t * v182 = (int32_t *)(*(int32_t *)(v133 + 13) + 0x335063e6); // 0x1000b7a1
                *v182 = *v182 & *(int32_t *)(v133 + 5);
                int32_t result5 = __asm_iretd(); // 0x1000b7a7
                *(char *)*(int32_t *)(v133 - 3) = __asm_insb(v181);
                return result5;
            }
        } else {
            int32_t v183 = *(int32_t *)v149; // 0x1000b6fb
            int32_t v184 = v108; // 0x1000b6fb
            int32_t v185 = v148 + v184 + v183; // 0x1000b6fb
            *(int32_t *)0x1114187f = v151;
            char * v186 = (char *)v150; // 0x1000b6b4
            char v187 = v150;
            int32_t v188 = v153;
            uint32_t v189 = v122;
            int32_t v190 = v151;
            bool v191 = (v148 & 15) + v184 + (v183 & 15) > 15;
            unsigned char v192 = *(char *)v145 ^ (char)(v189 / 256); // 0x1000b6b2
            *v186 = *v186 - (char)v189;
            int32_t v193 = v145 + 1; // 0x1000b6b8
            int32_t v194 = v188 - 5; // 0x1000b6ba
            *(int32_t *)v194 = v185;
            int64_t v195 = (int64_t)*(int32_t *)(v147 + 49); // 0x1000b6be
            int64_t v196 = 0x3e88c462 * v195; // 0x1000b6be
            while (v196 == 0x3e88c46200000000 * v195 / 0x100000000) {
                bool v197 = v191 | (v190 & 14) > 9; // 0x1000b6b1
                int32_t v198 = 256 * (int32_t)v192 | v189 & -0xff01; // 0x1000b6b2
                int32_t v199 = 2 * v190;
                int32_t v200 = v197 ? v199 + 12 : v199; // 0x1000b6b1
                int32_t v201 = (v200 & 30) + 10 | v190 & -0x10000 | 256 * (int32_t)v197 + v190 & 0xff00; // 0x1000b6bb
                int32_t v202 = v196; // 0x1000b6be
                char * v203 = (char *)(v201 + 114); // 0x1000b6c7
                *v203 = *v203 & 113;
                char * v204 = (char *)v201; // 0x1000b6cb
                *v204 = *v204 - v187;
                int32_t v205 = v201 | 1; // 0x1000b6ce
                char * v206 = (char *)(2 * v202 + v150); // 0x1000b6cf
                char v207 = *v206 & 59; // 0x1000b6cf
                *v206 = v207;
                if (v207 != 0) {
                    int32_t result6 = (v205 + 0x7021dd39 & -256 | (int32_t)*(char *)0x1114256b) - 0x6cb67105; // 0x1000b6e4
                    *(int32_t *)(v188 - 9) = v185;
                    int32_t * v208 = (int32_t *)result6; // 0x1000b6ea
                    *v208 = *v208 ^ v198;
                    return result6;
                }
                v188 = v194;
                v189 = v198;
                v190 = v205;
                v191 = false;
                v192 = *(char *)v193 ^ (char)(v189 / 256);
                *v186 = *v186 - (char)v189;
                v193++;
                v194 = v188 - 5;
                *(int32_t *)v194 = v185;
                v195 = (int64_t)*(int32_t *)(v202 + 49);
                v196 = 0x3e88c462 * v195;
            }
            char * v209 = (char *)(v150 + 50); // 0x1000b708
            *v209 = *v209 & v192;
            *(int32_t *)v193 = __asm_insd((int16_t)v149);
            __asm_fbld(*(float80_t *)(2 * v193 + v149));
            int32_t * v210 = (int32_t *)(v188 - 1); // 0x1000b712
            int32_t v211 = *v210; // 0x1000b712
            int32_t * v212 = (int32_t *)(v211 + 54); // 0x1000b718
            *v212 = *v212 & v193;
            *v210 = v185;
            v156 = false;
            v155 = false;
            v159 = v128;
            v157 = v185 ^ 0x75777d38;
            v112 = v150;
            v158 = v149;
            v114 = v211;
            v160 = v188 + 1;
            v116 = v185;
            v117 = v193 + ((v29 & 1024) == 0 ? 4 : -4);
        }
        int32_t v213 = v160;
        v113 = v158;
        int32_t v214 = v157;
        int32_t * v215 = (int32_t *)v213; // 0x1000b730
        unsigned char v216 = (char)v214; // 0x1000b731
        bool v217 = v156 | v216 > 153;
        int32_t v218; // 0x1000311e
        if (v155 || (v216 & 14) > 9) {
            v218 = (v217 ? 102 : 6) + v214 & 255 | v214 & -256;
        } else {
            v218 = (v217 ? v214 + 96 : v214) & 255 | v214 & -256;
        }
        char v219 = (char)v218 ^ 58; // 0x1000b732
        int32_t v220 = v218 & -256 | (int32_t)v219; // 0x1000b732
        int32_t v221 = v220; // 0x1000b734
        v115 = v213 + 4;
        if (v219 < 0) {
            // 0x1000b736
            *v215 = v113;
            v221 = v220 & 0x356121bf;
            v115 = v213;
        }
        // 0x1000b73c
        v111 = v221;
        __asm_out_3(49, v111);
        int32_t v222 = v111 + 0x773b9da8; // 0x1000b73f
        v108 = v111 < 0x88c46258;
        v109 = v222 < 0;
        v110 = ((v222 ^ v111) & (v111 ^ -0x80000000)) < 0;
        v152 = v159;
        v146 = *v215;
    }
    // 0x1000b7ac
    *v140 = 0x3e7c6d6c;
    char v223 = (char)v141 | -41; // 0x1000b7b6
    char v224; // 0x1000311e
    bool v225; // 0x1000311e
    if ((v139 & 15) > 16 || (v223 & 14) > 9) {
        v225 = true;
        v224 = v223 - 102;
    } else {
        v225 = false;
        v224 = v223 - 96;
    }
    int32_t v226 = v136 - v137; // 0x1000b7ae
    int32_t v227 = v139 - 1; // 0x1000b7b5
    int32_t v228 = v141 & -256 | (int32_t)v224;
    bool v229 = true; // 0x1000b7bd
    bool v230 = v225; // 0x1000b7bd
    int32_t v231 = v228; // 0x1000b7bd
    int32_t v232 = v226; // 0x1000b7bd
    int32_t * v233; // 0x1000311e
    int32_t v234; // 0x1000311e
    int32_t v235; // 0x1000311e
    int32_t v236; // 0x1000311e
    int32_t v237; // 0x1000311e
    int32_t v238; // 0x1000311e
    int16_t v239; // 0x1000311e
    int32_t v240; // 0x1000311e
    int32_t v241; // 0x1000311e
    if (v227 == 0) {
        goto lab_0x1000b821;
    } else {
        // 0x1000b7bf
        v233 = v140;
        v239 = v128;
        v234 = v228;
        v237 = v227;
        v238 = v138;
        v236 = 0x3e7c6d6c;
        v241 = v135;
        v235 = v137;
        v240 = v226;
        if (v224 < 0 == (v139 & -v139) < 0) {
            // 0x1000b7c4
            int32_t v242; // 0x1000311e
            __asm_into(v242);
            v131 = v226;
            v120 = v137;
            v134 = v135;
            v123 = *(int32_t *)(v133 + 12);
            v126 = v138;
            v124 = v227;
            v118 = v228 | 163;
            v129 = v128;
            goto lab_0x1000b7c6;
        } else {
            goto lab_0x1000b8f1;
        }
    }
  lab_0x1000b821:;
    int32_t v243 = v231;
    unsigned char v244 = (char)v243; // 0x1000b821
    bool v245 = v229 | v244 > 153;
    int32_t result7; // 0x1000311e
    if (v230 || (v244 & 14) > 9) {
        result7 = (v245 ? 154 : 250) + v243 & 255 | v243 & -256;
    } else {
        result7 = (v245 ? v243 + 160 : v243) & 255 | v243 & -256;
    }
    *(int32_t *)v122 = *(int32_t *)v232;
    return result7;
  lab_0x1000b8f1:;
    int32_t v246 = v241;
    int32_t v247 = v236;
    char v248 = __asm_in_5(110); // 0x1000b86e
    uint32_t v249 = v234 & -256 | (int32_t)v248; // 0x1000b86e
    *v233 = v249;
    *(int32_t *)(v246 - 4) = v237;
    *(int32_t *)(v246 - 8) = v238;
    *(int32_t *)(v246 - 12) = v247;
    *(int32_t *)(v246 - 16) = v246 + 4;
    *(int32_t *)(v246 - 20) = v235;
    *(int32_t *)(v246 - 24) = v240;
    *(int32_t *)(v246 - 28) = v122;
    *(int16_t *)(v246 - 30) = v239;
    int32_t result8 = v249 ^ 76; // 0x1000b8ee
    *(int32_t *)v122 = __asm_insd((int16_t)v238);
    if ((v247 + 1 & (v247 ^ -0x80000000)) >= 0) {
        char * v250 = (char *)result8; // 0x1000b8f4
        *v250 = (char)(v249 / 256) + (char)((v248 ^ -128) > -1) + *v250;
        return result8;
    }
    // 0x1000b954
    *(int32_t *)(v246 - 34) = v235;
    result2 = result8;
    int32_t v251 = v240; // 0x1000b955
    int32_t v252 = v235; // 0x1000b955
    int32_t v253 = result8; // 0x1000b955
    if ((v248 ^ -128) <= 255) {
        // 0x10003267
        return result2;
    }
    goto lab_0x1000b96e;
  lab_0x1000b7c6:;
    int32_t v376 = v126;
    int32_t v377 = v134;
    unsigned char v378 = (char)v118 & -48; // 0x1000b7c6
    int32_t v379 = v118 & -256 | (int32_t)v378; // 0x1000b7c6
    int32_t v380 = v377 - 32; // 0x1000b7c8
    *(int32_t *)(v377 - 4) = v379;
    *(int32_t *)(v377 - 8) = v124;
    *(int32_t *)(v377 - 12) = v376;
    *(int32_t *)(v377 - 16) = v123;
    *(int32_t *)(v377 - 20) = v377;
    *(int32_t *)(v377 - 24) = v120;
    *(int32_t *)(v377 - 28) = v131;
    *(int32_t *)v380 = v122;
    if (v378 != 0) {
        int32_t v381 = v124 + 1; // 0x1000b811
        v132 = v131;
        v121 = v120;
        v127 = v376;
        v130 = v129;
        v144 = v381 == 0;
        v119 = v379;
        v125 = v381;
        goto lab_0x1000b819;
    } else {
        int32_t result11 = v379 ^ 0x73e530ef; // 0x1000b7cc
        __asm_arpl(*(int16_t *)(result11 + 97), (int16_t)v131);
        if (result11 < 0) {
            char v382 = *(char *)(result11 + 0x21100804); // 0x1000b7d6
            int32_t v383 = __asm_bound(*(int64_t *)(2 * v123 + 12 + result11)); // 0x1000b7de
            *(int32_t *)0x244c79ce = result11;
            char * v384 = (char *)(result11 + 100); // 0x1000b7e7
            char v385 = *v384; // 0x1000b7e7
            char v386 = 2 * v385; // 0x1000b7e7
            *v384 = v386;
            if (v386 == 0) {
                // 0x10003267
                return result11;
            }
            int32_t v387 = v380 + v123; // 0x1000b7dc
            int32_t v388 = __asm_insd((int16_t)(256 * (int32_t)(v382 ^ (char)(v376 / 256)) | v376 & 255)); // 0x1000b831
            *(int32_t *)v383 = v388;
            *(int32_t *)(v387 - 4) = 109;
            char * v389 = (char *)result11; // 0x1000b834
            *v389 = (char)(v385 < 0) + (char)(result11 / 256) + *v389;
            char * v390 = (char *)(v383 + 93); // 0x1000b837
            unsigned char v391 = *v390; // 0x1000b837
            *v390 = v391 + 66;
            if (v391 <= 189) {
              lab_0x10003267:
                // 0x10003267
                return result11;
            }
            // 0x1000b83d
            *(int32_t *)(v387 - 8) = v120;
            return result11;
        }
        int32_t * v392 = (int32_t *)v120;
        v233 = v392;
        v239 = v129;
        v234 = result11;
        v237 = v124;
        v238 = v376;
        v236 = v123;
        v241 = v120;
        v235 = *v392;
        v240 = v131;
        goto lab_0x1000b8f1;
    }
  lab_0x1000b96e:;
    int32_t v254 = v253;
    bool v255 = v251 < v252; // 0x1000b970
    int32_t result9 = v254; // 0x1000b970
    if (v251 == v252) {
        // 0x1000b972
        v255 = (char)v254 > 247;
        result9 = v254 + 8 & 255 | v254 & -256;
    }
    goto lab_0x1000b974;
  lab_0x1000b974:;
    char * v256 = (char *)result9; // 0x1000b974
    *v256 = *v256 + (char)v255 + (char)(result9 / 256);
    return result9;
  lab_0x1000b819:
    // 0x1000b819
    v232 = v132;
    int32_t v257 = 82 * *(int32_t *)(v232 + 100); // 0x1000b812
    __asm_out_7((int16_t)v127, (char)v119);
    v231 = *(int32_t *)v257;
    int32_t v258 = v257 + 4; // 0x1000b818
    int32_t * v259 = (int32_t *)v258;
    v233 = v259;
    v239 = v130;
    v234 = v231;
    v237 = v125;
    v238 = v127;
    v236 = *v259;
    v241 = v258;
    v235 = v121;
    v240 = v232;
    if (!v144) {
        goto lab_0x1000b8f1;
    } else {
        // 0x1000b81c
        __asm_arpl(*(int16_t *)(v232 + 17), (int16_t)v232);
        v229 = false;
        v230 = false;
        goto lab_0x1000b821;
    }
    char v260; // 0x1000311e
    char v261 = v260;
    int32_t v262; // 0x1000b8a3
    unsigned char v263 = *(char *)(v262 + 97); // 0x1000b8af
    uint16_t v264 = ((int16_t)v262 & 255) * (int16_t)v263; // 0x1000b8af
    int32_t v265; // 0x1000311e
    int32_t v266; // 0x1000311e
    int32_t v267; // 0x1000311e
    int32_t v268; // 0x1000311e
    int32_t v269; // 0x1000311e
    int32_t v270; // 0x1000311e
    int32_t * v271; // 0x1000311e
    int32_t v272; // 0x1000b859
    int16_t v273; // 0x1000311e
    if (v261 < 0 == v264 > 255) {
        int32_t v274 = __asm_in_4(115); // 0x1000b90f
        v255 = v261 < 0;
        result9 = v274;
        if (v261 == 0) {
            goto lab_0x1000b974;
        } else {
            // 0x1000b913
            char v275; // 0x1000311e
            char v276 = v275;
            v266 = v274;
            int32_t v277; // 0x1000b765
            v269 = v277;
            v268 = v272;
            v267 = v142;
            v270 = v136;
            if ((v276 & 1) == 0) {
                goto lab_0x1000b938;
            } else {
                unsigned char v278 = (char)v274; // 0x1000b915
                char v279 = *v143; // 0x1000b915
                unsigned char v280 = v279 + v278; // 0x1000b915
                unsigned char v281 = v280 + (char)(v261 < 0); // 0x1000b915
                bool v282 = v261 < 0 ? v281 <= v278 : v280 < v278; // 0x1000b915
                int32_t v283 = v274 & -256 | (int32_t)v281; // 0x1000b915
                *v271 = v277;
                result2 = v283;
                v265 = v283;
                if (v282) {
                    goto lab_0x1000b92d;
                } else {
                    goto lab_0x10003267;
                }
            }
        }
    } else {
        int32_t v284 = v264; // 0x1000b8af
        int32_t v285 = v262 & -0x10000; // 0x1000b8af
        if (v261 != 0) {
            // 0x1000b90a
            char v286; // 0x1000b8aa
            char v287; // 0x1000b8aa
            bool v288 = (v286 & 15) - (v287 & 15) > 15 | (v284 & 14) > 9; // 0x1000b90c
            int32_t v289 = v288 ? v284 + 10 : v284; // 0x1000b90c
            return v289 & 15 | v285 | 256 * (int32_t)v288 + v284 & 0xff00;
        }
        // 0x1000b8b8
        *v271 = 109;
        int32_t v290 = (v285 | v284) + 1; // 0x1000b8ba
        int32_t * v291; // 0x1000311e
        *v291 = v272;
        if (v139 == 0 || v290 == 0) {
            int32_t v292 = v264 > 255; // 0x1000b8b6
            int32_t * v293 = (int32_t *)(v133 - 9); // 0x1000b8bf
            *v293 = 84;
            int32_t result10 = __asm_in_6(v273); // 0x1000b8c3
            char * v294 = (char *)(v139 - 126); // 0x1000b8c5
            char v295 = *v294; // 0x1000b8c5
            char v296 = v295 & (char)result10; // 0x1000b8c5
            *v294 = v296;
            *(int32_t *)(v133 - 13) = v292;
            if (v296 < 0) {
                // 0x1000b948
                *(int32_t *)(v133 - 17) = v292;
                *(int32_t *)(v133 - 21) = v272;
                return result10;
            }
            uint32_t v297 = v122 + 1; // 0x1000b8c4
            if (v297 > result10) {
                // 0x1000b8d3
                result2 = result10;
                if (v297 > result10) {
                    int32_t v298 = *v291; // 0x1000b8d8
                    int32_t v299 = *(int32_t *)(v133 + 11); // 0x1000b8d8
                    int32_t v300 = *(int32_t *)(v133 + 19); // 0x1000b8d8
                    char v301 = *(char *)v298; // 0x1000b8d9
                    __asm_outsb((int16_t)v299, v301);
                    result2 = v300;
                    if (result10 + v292 == (int32_t)(v297 < result10)) {
                        // 0x1000b8dc
                        return unknown_72673651();
                    }
                    goto lab_0x10003267;
                } else {
                    goto lab_0x10003267;
                }
            } else {
                int32_t v302 = *v293; // 0x1000b934
                char v303 = __asm_insb(v273); // 0x1000b935
                char * v304; // 0x1000311e
                *v304 = v303;
                v266 = (result10 & 78) + 209 & 223 | result10 & -256;
                v269 = v302;
                v268 = result10 ^ v272;
                v267 = v292;
                v270 = v292;
                goto lab_0x1000b938;
            }
        } else {
            char * v305 = (char *)v272; // 0x1000b929
            char v306 = *v305; // 0x1000b929
            char v307 = v306 ^ (char)(v139 / 256); // 0x1000b929
            *v305 = v307;
            result2 = v290;
            v265 = v290;
            if (v307 < 0) {
                goto lab_0x10003267;
            } else {
                goto lab_0x1000b92d;
            }
        }
    }
    char v308; // 0x1000311e
    char v309 = v308;
    int32_t v310; // 0x1000311e
    int32_t v311 = v310;
    *(int32_t *)v122 = v311;
    int16_t v312; // 0x1000b8a3
    int32_t v313 = v311 & -256 | (int32_t)__asm_in(v312); // 0x1000b903
    result2 = v313;
    if (v309 != 0) {
        // 0x1000b952
        *v271 = v142;
        result2 = v313;
        v251 = v136;
        v252 = v142;
        v253 = v313;
        unsigned char v314; // 0x1000b901
        if (v314 > 153) {
            goto lab_0x1000b96e;
        } else {
            goto lab_0x10003267;
        }
    } else {
        goto lab_0x10003267;
    }
  lab_0x1000b938:;
    int32_t v315 = v267;
    int32_t v316 = v269;
    uint32_t v317 = v266;
    uint32_t v318 = *(int32_t *)(v315 + 89); // 0x1000b938
    int64_t v319 = *(int64_t *)v316; // 0x1000b93b
    int32_t v320 = __asm_bound(v319); // 0x1000b93b
    if (v317 <= v318) {
        // 0x1000b942
        return v317 & -256 | (int32_t)__asm_in_5(-55);
    }
    int32_t v321 = v270;
    int32_t v322 = v268;
    *(char *)(v317 + 0x43211008 + v322) = (char)v316;
    int32_t v323 = *(int32_t *)(v317 - 0x3a9dcfe8); // 0x1000b982
    uint32_t v324 = v317 - 0x6cb6dbee; // 0x1000b988
    unsigned char v325 = *(char *)0x2018040; // 0x1000b98d
    int32_t v326 = v324 & -256; // 0x1000b98d
    unsigned char v327 = v325 + 8; // 0x1000b992
    int32_t v328 = v326 | (int32_t)v327; // 0x1000b992
    char * v329 = (char *)v328; // 0x1000b994
    char v330 = *v329; // 0x1000b994
    *v329 = v330 + (char)(v324 / 256) + (char)(v325 > 247);
    char * v331 = (char *)(v323 + 1 + v328); // 0x1000b997
    char v332 = *v331; // 0x1000b997
    *v331 = v332 + 16;
    int32_t * v333 = (int32_t *)(v322 - 122); // 0x1000b99b
    int32_t v334 = *v333; // 0x1000b99b
    *v333 = v334 & v328;
    unsigned char v335 = v327 | 24; // 0x1000b99e
    int32_t v336 = v326 | (int32_t)v335; // 0x1000b99e
    int32_t v337 = v320 - 60; // 0x1000b9a0
    int32_t * v338 = (int32_t *)v337; // 0x1000b9a0
    int32_t v339 = *v338; // 0x1000b9a0
    *v338 = v339 ^ v315 + 4;
    char v340 = v320; // 0x1000b9a3
    *(char *)v336 = v340;
    char * v341 = (char *)(v323 - 125); // 0x1000b9a5
    char v342 = *v341; // 0x1000b9a5
    *v341 = v342 & v335;
    uint32_t v343 = v336 + 0x5028140a; // 0x1000b9a8
    unsigned char v344 = *(char *)0x2018040; // 0x1000b9ad
    int32_t v345 = v343 & -256; // 0x1000b9ad
    unsigned char v346 = v344 + 8; // 0x1000b9b2
    int32_t v347 = v345 | (int32_t)v346; // 0x1000b9b2
    char * v348 = (char *)v347; // 0x1000b9b4
    char v349 = *v348; // 0x1000b9b4
    *v348 = v349 + (char)(v343 / 256) + (char)(v344 > 247);
    char * v350 = (char *)(v323 + 2 + v347); // 0x1000b9b7
    char v351 = *v350; // 0x1000b9b7
    *v350 = v351 + 16;
    int32_t v352 = *v333; // 0x1000b9bb
    *v333 = v352 & v347;
    unsigned char v353 = v346 | 24; // 0x1000b9be
    int32_t v354 = *(int32_t *)(v321 - 58); // 0x1000b9c0
    *(char *)(v345 | (int32_t)v353) = v340;
    char * v355 = (char *)(v323 - 124); // 0x1000b9c5
    char v356 = *v355; // 0x1000b9c5
    *v355 = v356 & v353;
    *(int32_t *)v315 = v345 | (int32_t)(v353 + 40);
    int32_t * v357 = (int32_t *)__asm_hlt(); // 0x1000b9d9
    int32_t v358 = *v357; // 0x1000b9d9
    int32_t v359 = v358 & v320; // 0x1000b9d9
    *v357 = v359;
    uint32_t v360 = *(int32_t *)(v322 - 69); // 0x1000b9db
    result2 = v360;
    if (v359 >= 0 != v359 != 0) {
        char * v361 = (char *)v337; // 0x1000b9e0
        char v362 = *v361; // 0x1000b9e0
        unsigned char v363 = (char)(v360 / 256); // 0x1000b9e0
        *v361 = v362 ^ v363;
        *(char *)v360 = v340;
        char v364 = *(char *)-0x596c7273; // 0x1000b9e5
        *(char *)-0x596c7273 = v364 & (char)v360;
        int32_t v365 = *(int32_t *)v320; // 0x1000b9e8
        int32_t v366 = v360 & -256; // 0x1000b9ea
        *(int32_t *)(v315 - 5) = v360 + 40 & 255 | v366;
        unsigned char v367 = *(char *)0x201c640; // 0x1000b9ed
        int32_t v368 = v366 | (int32_t)(v367 + 8); // 0x1000b9f2
        char * v369 = (char *)v368; // 0x1000b9f4
        char v370 = *v369; // 0x1000b9f4
        *v369 = v370 + v363 + (char)(v367 > 247);
        int32_t v371 = v365 + 1; // 0x1000b9f6
        uint32_t v372 = v360 + 2048;
        char * v373 = (char *)v371; // 0x1000b9fa
        char v374 = *v373; // 0x1000b9fa
        *v373 = (char)(v363 > 247) + (char)(v372 / 256) + v374;
        *(char *)(2 * v322 + 2 + v354) = (char)v371;
        return v368 & -0xff01 | v372 & 0xff00;
    }
    goto lab_0x10003267;
  lab_0x1000b92d:;
    int32_t v375 = v265;
    __asm_out(v273, v375);
    result2 = v375;
    goto lab_0x10003267;
}

// Address range: 0x1000f000 - 0x1000f06d
int32_t function_1000f000(int32_t a1) {
    // 0x1000f000
    int32_t v1; // 0x1000f000
    *(int32_t *)(v1 + 184) = a1 + 88;
    return 0;
}

// Address range: 0x1000f06d - 0x1000f0d2
int32_t function_1000f06d(int32_t a1) {
    // 0x1000f06d
    __writefsdword(0, a1);
    int32_t v1; // 0x1000f06d
    int32_t v2; // 0x1000f06d
    int32_t v3; // 0x1000f06d
    int32_t v4; // 0x1000f06d
    return function_1000f0da(v4, v3, v1, v2);
}

// Address range: 0x1000f0d2 - 0x1000f0da
int32_t function_1000f0d2(void) {
    // 0x1000f0d2
    int32_t v1; // 0x1000f0d2
    return v1 + 0x3010431;
}

// Address range: 0x1000f0da - 0x1000f3d3
int32_t function_1000f0da(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = a1 - 27 + (int32_t)*(int16_t *)(a1 - 21); // 0x1000f13c
    uint16_t v2 = *(int16_t *)(a1 - 19); // 0x1000f169
    int32_t v3 = *(int32_t *)(a1 - 25); // 0x1000f1c6
    int32_t v4 = 0; // 0x1000f1c6
    int32_t * v5 = (int32_t *)(4 * v4 + v1); // 0x1000f1c7
    *v5 = *v5 ^ v3;
    uint32_t v6 = v3 / 2; // 0x1000f1d6
    v4++;
    v3 = v6 & 0x7fffff00 | 0x80000000 * v3 | v6 & 255;
    while (v4 < (int32_t)(v2 / 4)) {
        // 0x1000f1c7
        v5 = (int32_t *)(4 * v4 + v1);
        *v5 = *v5 ^ v3;
        v6 = v3 / 2;
        v4++;
        v3 = v6 & 0x7fffff00 | 0x80000000 * v3 | v6 & 255;
    }
    uint16_t v7 = v2 % 4;
    int32_t v8; // 0x1000f0da
    int32_t v9; // 0x1000f0da
    switch (v7) {
        case 1: {
            char * v10 = (char *)(4 * v4 + v1); // 0x1000f39c
            *v10 = *v10 ^ (char)v6;
        }
        case 0: {
          lab_0x1000f2c1:
            // 0x1000f2c1
            v8 = v9;
            // break -> 0x1000f2c1
            break;
        }
        default: {
            int32_t v11 = 4 * v4 + v1;
            int16_t * v12 = (int16_t *)v11;
            *v12 = *v12 ^ (int16_t)v3;
            if (v7 != 2) {
                char * v13 = (char *)(v11 + 2); // 0x1000f2b1
                *v13 = *v13 ^ (char)(v3 / 2);
            }
            // branch (via goto) -> 0x1000f2c1
            goto lab_0x1000f2c1;
        }
    }
    while (true) {
        int32_t v14 = v8;
        int32_t v15; // 0x1000f0da
        if (*(int16_t *)v14 == 0x5a4d) {
            int32_t v16 = v14 + 60; // 0x1000f31c
            int32_t v17 = v16 & -0x10000 | (int32_t)*(int16_t *)v16; // 0x1000f32c
            v15 = v17;
            if (*(int16_t *)v17 == 0x4550) {
                // break -> 0x1000f352
                break;
            }
        } else {
            // 0x1000f2d8
            v15 = v14 - 0x1000 & -0x10000;
        }
        // 0x1000f2c1
        v8 = v15;
    }
    // 0x1000f352
    return *(int32_t *)((int32_t)&v9 + 4);
}

// Address range: 0x1000f3d3 - 0x1000f4b3
int32_t function_1000f3d3(int32_t a1, int32_t a2) {
    // 0x1000f3d3
    int32_t v1; // 0x1000f3d3
    char * v2 = (char *)(v1 + 0x17175f41); // 0x1000f3d9
    *v2 = *v2 - 53;
    int32_t v3; // 0x1000f3d3
    *(int32_t *)(v3 - 101 + 2 * v3) = a1;
    *(int16_t *)0x5dca1161 = -0x4ab7;
    int32_t v4; // 0x1000f3d3
    int32_t v5; // 0x1000f3d3
    uint32_t v6 = *(int32_t *)((v5 & 0x3e421400) - 3) + 1 + *(int32_t *)(v4 - 0x16e78834); // 0x1000f46a
    char * v7 = (char *)(v6 + 0x50a406e7); // 0x1000f480
    char v8 = v6 / 256; // 0x1000f480
    *v7 = *v7 & v8;
    *(char *)v4 = *(char *)&v4 + v8;
    __asm_int(208);
    int32_t v9; // 0x1000f3d3
    *(int32_t *)v1 = v1 & v9 | v4 & 0xff00 | 224;
    *(int32_t *)(v9 - 1) = (v6 + 21 & 255 | v6 & -256) + 0x7ac50931;
    return function_1000f510((int32_t)&g6);
}

// Address range: 0x1000f4d4 - 0x1000f50b
int32_t function_1000f4d4(void) {
    // 0x1000f4d4
    int32_t v1; // 0x1000f4d4
    int32_t v2; // 0x1000f4d4
    *(int32_t *)v1 = v1 - v2;
    int32_t v3; // 0x1000f4d4
    int32_t v4 = v2 & -256 | (int32_t)(*(char *)&v3 ^ (char)v2); // 0x1000f4d9
    int32_t v5; // 0x1000f4d4
    int32_t v6 = v5 + 180 & 255 | v5 & -256; // 0x1000f4db
    int32_t v7 = *(int32_t *)(v6 - 128) * v6; // 0x1000f4de
    int32_t * v8 = (int32_t *)v7; // 0x1000f4e8
    *v8 = v4 & *v8;
    *(int32_t *)0x418dfc91 = v7;
    int32_t v9; // 0x1000f4d4
    int32_t * v10 = (int32_t *)(v9 - 38); // 0x1000f4f0
    *v10 = *v10 - 72;
    int32_t v11 = __asm_in_4(194); // 0x1000f4f5
    *(int32_t *)-0x74ee6cb4 = -128;
    char * v12 = (char *)(v4 + 1 + 2 * v11); // 0x1000f4fa
    *v12 = *v12 | -53;
    return function_8339657e();
}

// Address range: 0x1000f510 - 0x1000f54c
int32_t function_1000f510(int32_t a1) {
    int32_t v1 = __asm_sti(); // 0x1000f510
    int32_t v2; // 0x1000f510
    bool v3; // 0x1000f510
    if (!v3) {
        // 0x1000f513
        int32_t v4; // 0x1000f510
        char * v5 = (char *)(v4 + 0x368d8150); // 0x1000f513
        *v5 = *v5 | (char)v2;
        int32_t v6; // 0x1000f510
        unsigned char v7 = *(char *)&v6; // 0x1000f519
        *(char *)v6 = 128 * v7 | v7 / 4;
        int32_t v8; // 0x1000f510
        *(int32_t *)v8 = __asm_insd((int16_t)v6);
        __asm_out_2(65, 36);
        return 0x2b047825;
    }
    unsigned char v9 = (char)v1; // 0x1000f52b
    bool v10; // 0x1000f510
    bool v11 = v10 | v9 > 153;
    int32_t v12; // 0x1000f510
    int32_t v13; // 0x1000f510
    char v14; // 0x1000f510
    char v15; // 0x1000f510
    bool v16; // 0x1000f510
    if (v16 || (v9 & 14) > 9) {
        char v17 = (v11 ? 102 : 6) + v9; // 0x1000f52b
        char v18 = llvm_ctpop_i8(v17); // 0x1000f52b
        v14 = v17;
        v13 = v1 & -256 | (int32_t)v17;
        v12 = 16;
        v15 = v18;
    } else {
        char v19 = v11 ? v9 + 96 : v9; // 0x1000f52b
        char v20 = llvm_ctpop_i8(v19); // 0x1000f52b
        v14 = v19;
        v13 = v1 & -256 | (int32_t)v19;
        v12 = 0;
        v15 = v20;
    }
    char v21 = v14;
    int32_t * v22 = (int32_t *)((v13 & -0xff01 | 256 * (v12 | (int32_t)v11 | 64 * (int32_t)(v21 == 0) | 128 * (int32_t)(v21 < 0) | 4 * (int32_t)((v15 & 1) == 0)) | 512) + 0xc2abc0d); // 0x1000f52d
    *v22 = *v22 & 0x715efc82;
    int32_t v23; // 0x1000f510
    int32_t * v24 = (int32_t *)(v23 + 50); // 0x1000f538
    *v24 = *v24 | v2;
    return __asm_wait() & -256 | (int32_t)*(char *)-0x1e6a3a5f;
}

// Address range: 0x1000f54d - 0x1000f612
int32_t function_1000f54d(int16_t a1, int32_t a2) {
    // 0x1000f54d
    int32_t v1; // 0x1000f54d
    int32_t v2; // 0x1000f54d
    char * v3 = (char *)(4 * v2 + v1); // 0x1000f54d
    bool v4; // 0x1000f54d
    *v3 = (char)v4 + (char)v2 + *v3;
    int32_t v5; // 0x1000f54d
    uint16_t v6 = (int16_t)*(char *)&v5 | -0x4d00; // 0x1000f557
    bool v7; // 0x1000f54d
    int32_t v8 = v7 ? 0x3fffffff : 1; // 0x1000f557
    int32_t v9; // 0x1000f54d
    int32_t v10; // 0x1000f54d
    *(int32_t *)v9 = __asm_insd((int16_t)v10);
    uint16_t v11 = (int16_t)*(char *)0x4ebc0b92; // 0x1000f55e
    *(int32_t *)0x3f36625a = (int32_t)(256 * (v6 % v11) | v6 / v11 & 255) | -0x78cd0000;
    int32_t v12; // 0x1000f54d
    int32_t * v13 = (int32_t *)(v12 + 33); // 0x1000f56f
    *v13 = *v13 + v9;
    int32_t v14; // 0x1000f54d
    int32_t * v15 = (int32_t *)((int32_t)&v14 + 14 + 4 * (v5 + v8)); // 0x1000f572
    int32_t v16 = *v15 & 0x3815ab3; // 0x1000f572
    char v17 = llvm_ctpop_i8((char)v16); // 0x1000f572
    *v15 = v16;
    if ((v17 & 1) == 0) {
        // 0x1000f5fa
        return function_83d86165(v12);
    }
    // 0x1000f57c
    return 0x4ebc0c5c;
}

// Address range: 0x1000f612 - 0x1000f61e
int32_t function_1000f612(int32_t a1) {
    // 0x1000f612
    int32_t v1; // 0x1000f612
    int32_t v2; // 0x1000f612
    *(int32_t *)v1 = __asm_insd((int16_t)v2);
    int32_t * v3 = (int32_t *)((v2 & -256 | 73) + 0x8f7f47b); // 0x1000f615
    int32_t v4; // 0x1000f612
    *v3 = *v3 + v4;
    int32_t result; // 0x1000f612
    return result;
}

// Address range: 0x1000f635 - 0x1000f65f
int32_t function_1000f635(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1000f635
    int32_t v1; // 0x1000f635
    int32_t * v2 = (int32_t *)(v1 + 0x341732c5); // 0x1000f635
    int32_t v3; // 0x1000f635
    bool v4; // 0x1000f635
    *v2 = (int32_t)v4 - v3 + *v2;
    int32_t v5; // 0x1000f635
    char * v6 = (char *)(v5 - 113); // 0x1000f63b
    *v6 = *v6 | (char)v5;
    *(int32_t *)(v1 - 46) = a1;
    return (int32_t)(*(char *)(v1 + 0x617f1fb) ^ 52) | 0x16405441;
}

// Address range: 0x1000f65f - 0x1000f67f
int32_t function_1000f65f(void) {
    // 0x1000f65f
    int32_t v1; // 0x1000f65f
    bool v2; // 0x1000f65f
    int32_t v3 = (v2 ? -4 : 4) + v1; // 0x1000f65f
    uint32_t v4 = unknown_60f2b89b(); // 0x1000f662
    char v5 = v4 / 256; // 0x1000f667
    int32_t v6; // 0x1000f65f
    *(char *)v6 = v5;
    char * v7 = (char *)v3; // 0x1000f669
    bool v8; // 0x1000f65f
    *v7 = (char)v8 - v5 + *v7;
    int32_t v9 = v2 ? -1 : 1; // 0x1000f66c
    int32_t v10 = v4 + 0x47cf6214; // 0x1000f66d
    *(char *)0x5010431 = (char)v10;
    int32_t v11; // 0x1000f65f
    *(char *)(v3 + v9) = *(char *)(v9 + v11);
    int32_t v12; // 0x1000f65f
    return v10 & -256 | (int32_t)*(char *)((v10 & 255) + v12);
}

// Address range: 0x1000f67f - 0x1000f6b6
int32_t function_1000f67f(void) {
    // 0x1000f67f
    int32_t v1; // 0x1000f67f
    int64_t v2 = *(int64_t *)&v1; // 0x1000f67f
    int64_t v3; // 0x1000f67f
    __asm_pcmpeqw(v3, v2);
    int32_t v4; // 0x1000f67f
    *(int32_t *)v4 = (int32_t)v2;
    bool v5; // 0x1000f67f
    int32_t v6 = (v5 ? -4 : 4) + v4; // 0x1000f682
    int32_t v7 = v1 & -256 | (int32_t)*(char *)0x33895ddb; // 0x1000f684
    int32_t v8; // 0x1000f67f
    *(int32_t *)(v8 - 0x7efdf73b) = 0x10000 * v7 / 0x10000;
    uint32_t v9; // 0x1000f67f
    char * v10 = (char *)(v9 - 0x35d5cae8); // 0x1000f698
    *v10 = *v10 + 73;
    char * v11 = (char *)(v6 + 92); // 0x1000f6ae
    *v11 = *v11 + (char)(v9 / 256);
    int16_t v12; // bp-2, 0x1000f67f
    int32_t v13; // 0x1000f67f
    int32_t v14; // 0x1000f67f
    int32_t v15; // 0x1000f67f
    return function_848da803(v6, v13, v14, &v12, v15, v9, v8, v7, v12);
}

// Address range: 0x1000f6b6 - 0x1000f6e0
int32_t function_1000f6b6(int32_t a1, int32_t a2) {
    int32_t v1 = a1;
    int32_t v2 = __asm_iretd(); // 0x1000f6b8
    int32_t v3; // 0x1000f6b6
    char * v4 = (char *)(v3 + 16); // 0x1000f6c4
    unsigned char v5 = *v4; // 0x1000f6c4
    unsigned char v6 = v5 + *(char *)0x70995413; // 0x1000f6c4
    bool v7; // 0x1000f6b6
    unsigned char v8 = v6 + (char)v7; // 0x1000f6c4
    *v4 = v8;
    float80_t v9; // 0x1000f6b6
    *(int64_t *)(v3 - 87) = (int64_t)v9;
    int32_t v10 = v1; // 0x1000f6ca
    int32_t v11; // 0x1000f6b6
    int32_t * v12 = (int32_t *)(v11 - 0x177439a1); // 0x1000f6cd
    *v12 = *v12 + -1 - v3 + (int32_t)(v7 ? v8 <= v5 : v6 < v5);
    v1 = v3 + 1;
    int32_t * v13 = (int32_t *)(v10 + 38); // 0x1000f6d7
    *v13 = *v13 + (int32_t)&v1;
    bool v14; // 0x1000f6b6
    char * v15 = (char *)((v14 ? -4 : 4) + v11); // 0x1000f6da
    *v15 = *v15 ^ 30;
    return v2 & -256 | 231;
}

// Address range: 0x1000f6e0 - 0x1000f6ef
int32_t function_1000f6e0(int32_t a1) {
    // 0x1000f6e0
    int32_t v1; // 0x1000f6e0
    int32_t result; // 0x1000f6e0
    __asm_out((int16_t)v1, result);
    return result;
}

// Address range: 0x1000f6e7 - 0x1000f6e8
int32_t function_1000f6e7(void) {
    // 0x1000f6e7
    int32_t result; // 0x1000f6e7
    return result;
}

// Address range: 0x1000f6ef - 0x1000f6f4
int32_t function_1000f6ef(void) {
    // 0x1000f6ef
    return function_c382b151();
}

// Address range: 0x1000f712 - 0x1000f745
int32_t function_1000f712(int32_t a1) {
    // 0x1000f712
    int32_t v1; // 0x1000f712
    char * v2 = (char *)(v1 - 0x28454ab4); // 0x1000f712
    int32_t v3; // 0x1000f712
    *v2 = *v2 | (char)v3;
    int32_t v4; // 0x1000f712
    char * v5 = (char *)(v4 + 0x4cb4d49); // 0x1000f718
    int32_t v6; // 0x1000f712
    *v5 = *v5 - (char)v6;
    int32_t v7 = v6 & -0x10000 | 0x1b00; // 0x1000f71e
    int32_t v8; // 0x1000f712
    *(char *)v7 = (char)v8;
    char v9 = *(char *)&v4; // 0x1000f72f
    int32_t v10 = *(int32_t *)0x73770431 & (v7 - 0x55cf9a7d & -0x8000 | 177); // 0x1000f733
    *(int32_t *)0x73770431 = v10;
    uint32_t v11; // 0x1000f712
    unsigned char v12 = *(char *)((256 * (int32_t)(v9 + (char)(v11 / 256)) | v11 & -0xff01) + (v4 & 255)); // 0x1000f73a
    int32_t v13 = v4 & -256 | (int32_t)v12; // 0x1000f73b
    if (v10 != 0) {
        v13 = function_1000f6e7();
    }
    // 0x1000f73d
    return v13 + 0x580f5ca;
}

// Address range: 0x1000f745 - 0x1000f895
int32_t function_1000f745(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1000f745
    int32_t v1; // 0x1000f745
    int32_t v2 = v1 & -256 | 171; // 0x1000f746
    int32_t * v3 = (int32_t *)v2; // 0x1000f749
    *v3 = *v3 | 0x419bd662;
    *(int32_t *)0x7c8e1de0 = v2;
    int32_t v4 = __asm_hlt(); // 0x1000f755
    int32_t v5; // 0x1000f745
    char * v6 = (char *)(v5 + 19); // 0x1000f756
    *v6 = 2 * *v6;
    int16_t v7; // bp-2, 0x1000f745
    int32_t v8; // 0x1000f745
    int32_t * v9 = (int32_t *)(8 * v8 + (int32_t)&v7); // 0x1000f75a
    int32_t v10 = *v9 | v4; // 0x1000f75a
    char v11 = llvm_ctpop_i8((char)v10); // 0x1000f75a
    *v9 = v10;
    *(char *)v8 = (char)v4;
    bool v12; // 0x1000f745
    int32_t v13 = v12 ? -1 : 1; // 0x1000f75d
    int32_t v14 = v13 + v8; // 0x1000f75d
    int32_t v15 = v4 & -0xff01 | 0x4000 * (int32_t)(v10 == 0) | 0x8000 * (int32_t)(v10 < 0) | 1024 * (int32_t)((v11 & 1) == 0) | 512; // 0x1000f75e
    *(int32_t *)v14 = v15;
    uint32_t v16; // 0x1000f745
    uint32_t v17 = v16 & 31; // 0x1000f760
    if (v17 != 0) {
        int32_t * v18 = (int32_t *)(v15 + 0x10a7922b); // 0x1000f760
        uint32_t v19 = *v18; // 0x1000f760
        *v18 = v19 >> v17 | (int32_t)((int64_t)v19 << (int64_t)(33 - v17));
    }
    int32_t result = v5 + 1; // 0x1000f759
    int32_t v20 = v12 ? -4 : 4; // 0x1000f75f
    int32_t v21 = v14 + v20; // 0x1000f75f
    int32_t v22 = v15; // bp-6, 0x1000f766
    int32_t v23; // 0x1000f745
    *(char *)(v23 + 0x44498045) = (char)(v16 / 256);
    int32_t v24 = v15 - 0x55a21415; // 0x1000f76d
    int32_t v25; // 0x1000f745
    int32_t * v26 = (int32_t *)(4 * v25 - 120 + (int32_t)&v22); // 0x1000f772
    *v26 = *v26 ^ 0x246ba440;
    char * v27 = (char *)(2 * v24 + v16); // 0x1000f77a
    *v27 = *v27 | -53;
    *(int32_t *)0x64435cd9 = v24 | 62;
    char * v28 = (char *)(v5 - 0x325c478b); // 0x1000f785
    *v28 = *v28 | (char)result;
    int32_t v29 = v21 - 1; // 0x1000f790
    int32_t v30; // 0x1000f745
    int32_t v31 = v30 + 1; // 0x1000f793
    if (v31 < 0) {
        // 0x1000f796
        if (v31 != 0) {
            // 0x1000f798
            return result;
        }
        char * v32 = (char *)(v25 - 0x351e58f0); // 0x1000f7a1
        *v32 = *v32 & 7;
        char * v33 = (char *)(v21 - 0x176ca7c0); // 0x1000f7aa
        char v34 = v16; // 0x1000f7aa
        *v33 = *v33 - v34;
        *(char *)(4 * result - 0x7c379d79) = v34;
        int32_t result2 = __asm_hlt() - 0x4056324f; // 0x1000f7bb
        *(int32_t *)v29 = result2;
        return result2;
    }
    int32_t v35 = v23 & -256 | 89; // 0x1000f791
    float80_t v36; // 0x1000f745
    *(int64_t *)result = (int64_t)v36;
    __asm_wait();
    uint32_t v37 = __asm_hlt(); // 0x1000f813
    int32_t v38 = v16 & -0xff01; // 0x1000f814
    int32_t v39 = v38 | v31; // 0x1000f817
    unsigned char v40 = *(char *)0x6585804b; // 0x1000f81b
    *(int32_t *)-0x7eedfbb8 = v37 & -256 | (int32_t)v40;
    int32_t v41 = *(int32_t *)v39; // 0x1000f821
    unsigned char v42 = -18 * (char)(v37 / 256) + v40; // 0x1000f822
    int32_t v43 = v29 + v20; // 0x1000f824
    int16_t v44 = v35; // 0x1000f825
    __asm_out(v44, v37 & -0x10000 | (int32_t)v42);
    *(char *)v43 = v42;
    unsigned char v45 = (char)v41; // 0x1000f828
    int32_t result3 = v41 & -0x10000 | (int32_t)(v45 % 119) | 256 * (int32_t)(v45 / 119); // 0x1000f828
    if (v38 < (int32_t)*(char *)v38) {
        // 0x1000f798
        return result3;
    }
    if (v38 == 1) {
        int32_t result4 = __asm_int1(); // 0x1000f887
        char * v46 = (char *)v35; // 0x1000f88f
        *v46 = *v46 | (char)result4;
        return result4;
    }
    char * v47 = (char *)(v39 + 11); // 0x1000f865
    unsigned char v48 = *v47; // 0x1000f865
    *v47 = v48 + 89;
    *(char *)(v43 + v13) = __asm_insb(v44);
    int32_t * v49 = (int32_t *)(*(int32_t *)(v39 + 4) - 0x76df4e4); // 0x1000f86a
    *v49 = v35 + (int32_t)(v48 > 166) + *v49;
    int32_t result5 = *(int32_t *)v35 | v39 + 8; // 0x1000f870
    if ((*(char *)(v35 + 0x5d8e9951) || (char)((v5 + 2) / 256)) < 1) {
        // 0x1000f7fd
        *(int32_t *)((result3 | 0xea94c6d) - 4) = -85;
        return result5;
    }
    // 0x1000f87a
    *(char *)result5 = -1;
    return result5;
}

// Address range: 0x1000f896 - 0x1000f901
int32_t function_1000f896(int32_t a1) {
    // 0x1000f896
    int32_t v1; // bp-4, 0x1000f896
    int32_t v2; // 0x1000f896
    int32_t v3; // 0x1000f896
    int32_t v4; // 0x1000f896
    int32_t result; // 0x1000f896
    bool v5; // 0x1000f896
    bool v6; // 0x1000f896
    if (v6 != v5) {
        // 0x1000f8da
        v1 = -0x7708fcb7;
        bool v7; // 0x1000f896
        int32_t v8 = (v7 ? -4 : 4) + v2; // 0x1000f8df
        uint32_t v9 = v4 & 31; // 0x1000f8e0
        if (v9 != 0) {
            int32_t * v10 = (int32_t *)(4 * v3 - 0x6edcbe5a + v8); // 0x1000f8e0
            *v10 = *v10 << v9;
        }
        char * v11 = (char *)(v8 - 0x11fc8e0f); // 0x1000f8f1
        *v11 = *v11 + (char)v4;
        __asm_int(114);
        __asm_int(168);
        return result;
    }
    // 0x1000f898
    int32_t v12; // 0x1000f896
    int32_t v13 = result | v12; // 0x1000f898
    int32_t v14 = v13 + 106; // 0x1000f89a
    int32_t v15 = v13 & -256; // 0x1000f89a
    int32_t v16 = v14 & 255 | v15; // 0x1000f89a
    int32_t * v17 = (int32_t *)(v3 + 63); // 0x1000f89c
    uint32_t v18 = *v17; // 0x1000f89c
    uint32_t v19 = v18 + v4; // 0x1000f89c
    *v17 = v19;
    int32_t * v20 = (int32_t *)v16; // 0x1000f89f
    *v20 = *v20 - v16 + (int32_t)(v19 < v18);
    *(char *)v16 = (char)v12;
    v1 = v16;
    __asm_out_3(178, v16);
    char * v21 = (char *)(v4 + 0x548163e0); // 0x1000f8ae
    unsigned char v22 = *v21; // 0x1000f8ae
    *v21 = v22 - 107;
    int32_t v23 = v12 & -256 | 121; // 0x1000f8b5
    char * v24 = (char *)(v23 + 0x4cb906e); // 0x1000f8b7
    *v24 = *v24 + (char)v14 + (char)(v22 > 106);
    char * v25 = (char *)(v16 + 63); // 0x1000f8be
    *v25 = *v25 | 13;
    *(int32_t *)v2 = __asm_insd((int16_t)v23);
    int32_t result2 = v15 | (int32_t)*(char *)-0x16e45d3f; // 0x1000f8c3
    int32_t * v26 = (int32_t *)(8 * v2 - 1 + result2); // 0x1000f8c8
    *v26 = *v26 + (int32_t)&v1;
    int32_t v27; // 0x1000f896
    int32_t * v28 = (int32_t *)(v4 + v27); // 0x1000f8d4
    *v28 = *v28 ^ result2;
    return result2;
}

// Address range: 0x1000f901 - 0x1000f920
int32_t function_1000f901(int32_t a1, int32_t a2) {
    // 0x1000f901
    int32_t v1; // 0x1000f901
    int32_t * v2 = (int32_t *)(v1 - 0x3b6ce393); // 0x1000f907
    uint32_t v3 = *v2; // 0x1000f907
    int32_t v4 = v3 / 0x80000000; // 0x1000f907
    *v2 = v4 | 2 * v3;
    int32_t v5; // 0x1000f901
    int32_t v6 = v5 - 0x4c69b2b4 + (int32_t)(v4 != 0); // 0x1000f90d
    int32_t v7; // 0x1000f901
    __asm_arpl(*(int16_t *)(v6 + v7), (int16_t)v6);
    return v1 + 216 + (int32_t)((v6 ^ -4) < 0x31f54bb4) & 255 | v1 & -256;
}

// Address range: 0x1000f920 - 0x1000f949
int32_t function_1000f920(void) {
    // 0x1000f920
    int32_t v1; // 0x1000f920
    int32_t v2; // 0x1000f920
    *(char *)v1 = __asm_insb((int16_t)v2);
    __asm_hlt();
    int32_t v3; // 0x1000f920
    int32_t * v4 = (int32_t *)(5 * v3); // 0x1000f935
    *v4 = *v4 ^ v3;
    int32_t v5; // 0x1000f920
    char * v6 = (char *)(v5 + 0x41cad8c7); // 0x1000f938
    *v6 = *v6 - 127;
    return v3 + 144 & 255 | v3 & -256;
}

// Address range: 0x1000f959 - 0x1000f977
int32_t function_1000f959(void) {
    // 0x1000f959
    return -0x3be54578;
}

// Address range: 0x1000f977 - 0x1000f9a2
int32_t function_1000f977(void) {
    // 0x1000f977
    uint32_t v1; // 0x1000f977
    bool v2; // 0x1000f977
    *(char *)v1 = (char)v2;
    uint32_t v3; // 0x1000f977
    uint32_t v4; // 0x1000f977
    uint32_t v5 = v1 - 0x41d1e748 + (int32_t)((114 * v4 / 256 + v4 & 255 | v4 & -0x10000) < v3); // 0x1000f983
    if (v5 < 2) {
        // 0x1000f98b
        int32_t v6; // 0x1000f977
        *(char *)v6 = (char)v6;
    }
    // 0x1000f98e
    if ((114 * v4 / 256 + v4 & 255 || v4 & -0x10000) < v3 ? v5 <= v1 : v1 > 0x41d1e747) {
        // 0x1000f9a2
        bool v7; // 0x1000f977
        return (v7 ? -4 : 4) + v3;
    }
    // 0x1000f990
    return function_408e86e0();
}

// Address range: 0x1000f9a3 - 0x1000f9b6
int32_t function_1000f9a3(void) {
    // 0x1000f9a3
    int32_t v1; // 0x1000f9a3
    unsigned char v2 = (char)v1; // 0x1000f9a3
    bool v3; // 0x1000f9a3
    __readgsdword((v1 & -256 | (int32_t)(16 * v2 | v2 / 32 | 8 * (char)v3)) + 0x5d4c15c5);
    int32_t result; // 0x1000f9a3
    return result;
}

// Address range: 0x1000f9bc - 0x1000f9bf
int32_t function_1000f9bc(int32_t a1) {
    // 0x1000f9bc
    int32_t result; // 0x1000f9bc
    return result;
}

// Address range: 0x1000f9ef - 0x1000f9f4
int32_t function_1000f9ef(void) {
    // 0x1000f9ef
    return function_430af841();
}

// Address range: 0x1000fa03 - 0x1000fa06
int32_t function_1000fa03(int32_t a1) {
    // 0x1000fa03
    int32_t result; // 0x1000fa03
    return result;
}

// Address range: 0x1000fa06 - 0x1000fabc
int32_t function_1000fa06(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1000fa06
    int32_t v1; // 0x1000fa06
    int32_t v2 = v1 - 1; // 0x1000fa07
    bool v3; // 0x1000fa06
    if (v2 == 0 || v3) {
        // 0x1000fa0a
        int32_t v4; // 0x1000fa06
        int32_t v5; // 0x1000fa06
        unsigned char v6 = *(char *)((v5 & 255) + v4); // 0x1000fa06
        int32_t v7 = v5 & -256; // 0x1000fa06
        int32_t v8; // 0x1000fa06
        *(char *)(v7 | (int32_t)v6) = (char)v8;
        int32_t * v9 = (int32_t *)((v7 | (int32_t)(v6 - 97)) - 0x705db877); // 0x1000fa0e
        *v9 = *v9 + (v6 > 96 ? -0x718fd1fe : -0x718fd1ff);
        int32_t v10 = *(int32_t *)0xc414061; // 0x1000fa1a
        int32_t v11; // 0x1000fa06
        *(int32_t *)(v11 - 4) = v2;
        return v10 & -256 | (int32_t)*(char *)((v10 & 255) + (v4 & -256 | 80));
    }
    // 0x1000fa32
    int32_t v12; // 0x1000fa06
    int32_t * v13 = (int32_t *)(2 * v12 + 0x17ffbcd + v1); // 0x1000fa32
    bool v14; // 0x1000fa06
    *v13 = *v13 + (v14 ? -0x4140095a : -0x4140095b);
    int32_t result = __asm_iretd(); // 0x1000fa4c
    int32_t v15; // 0x1000fa06
    int32_t * v16 = (int32_t *)(v15 - 0x2b1c6db1); // 0x1000fa4d
    uint32_t v17 = *v16; // 0x1000fa4d
    *v16 = v17 / 2 | 0x80000000 * v17;
    return result;
}

// Address range: 0x1000fac2 - 0x1000fac6
int32_t function_1000fac2(void) {
    // 0x1000fac2
    int32_t result; // 0x1000fac2
    char * v1 = (char *)(result + 16); // 0x1000fac2
    int32_t v2; // 0x1000fac2
    *v1 = *v1 & (char)v2;
    return result;
}

// Address range: 0x1000fadb - 0x1000fae7
int32_t function_1000fadb(void) {
    // 0x1000fadb
    return function_c8ef5fdf();
}

// Address range: 0x1000fae7 - 0x1000fb3a
int32_t function_1000fae7(void) {
    // 0x1000fae7
    int32_t v1; // 0x1000fae7
    int32_t v2; // 0x1000fae7
    int32_t * v3 = (int32_t *)(8 * v1 - 93 + v2); // 0x1000fae7
    int32_t v4; // 0x1000fae7
    *v3 = *v3 + v4;
    __asm_iretd();
    int32_t v5; // 0x1000fae7
    if (v5 == 1) {
        // 0x1000faf4
        abort();
        // UNREACHABLE
    }
    // 0x1000fb25
    int32_t v6; // 0x1000fae7
    char v7 = v6; // 0x1000fb29
    *(char *)(20 - v1) = v7;
    if (v4 == 1 || v5 == 2) {
        // 0x1000fb37
        return *(int32_t *)(v5 - 233);
    }
    int32_t v8 = v1 + 1; // 0x1000fae7
    int32_t v9; // 0x1000fae7
    int32_t v10 = v9 - 5; // 0x1000fb1d
    int32_t v11; // 0x1000fae7
    *(int32_t *)v10 = v11;
    int32_t v12 = v9 - 0x409e; // 0x1000fb1d
    float80_t v13; // 0x1000fae7
    *(int64_t *)(v5 - 110) = (int64_t)v13;
    __asm_in_6((int16_t)v6);
    *(char *)(v8 + 22) = v7;
    v8 = -1 - v8;
    v11 = v10;
    while (v12 != 1) {
        // 0x1000fb1c
        v10 = v12 - 5;
        *(int32_t *)v10 = v11;
        v12 -= 0x409e;
        *(int64_t *)(v5 - 110) = (int64_t)v13;
        __asm_in_6((int16_t)v6);
        *(char *)(v8 + 22) = v7;
        v8 = -1 - v8;
        v11 = v10;
    }
    // 0x1000fb37
    return *(int32_t *)(v5 - 233);
}

// Address range: 0x1000fb3b - 0x1000fb4a
float80_t function_1000fb3b(void) {
    // 0x1000fb3b
    int32_t v1; // 0x1000fb3b
    int32_t v2 = *(int32_t *)(v1 - 0x2086b4db); // 0x1000fb3d
    int32_t v3; // 0x1000fb3b
    float80_t v4; // 0x1000fb3b
    return (v4 + (float80_t)v2) * (float80_t)(float32_t)v3;
}

// Address range: 0x1000fb4b - 0x1000fb4d
int32_t function_1000fb4b(void) {
    // 0x1000fb4b
    int32_t result; // 0x1000fb4b
    return result;
}

// Address range: 0x1000fb51 - 0x1000fb59
int32_t function_1000fb51(void) {
    // 0x1000fb51
    return function_c9b23e0d();
}

// Address range: 0x1000fb59 - 0x1000fb5a
int32_t function_1000fb59(void) {
    // 0x1000fb59
    int32_t result; // 0x1000fb59
    return result;
}

// Address range: 0x1000fb5f - 0x1000fc29
int32_t function_1000fb5f(int32_t a1) {
    // 0x1000fb5f
    uint32_t v1; // 0x1000fb5f
    char v2 = *(char *)(v1 + 0x2f9d2be1); // 0x1000fb5f
    uint32_t v3; // 0x1000fb5f
    int32_t v4; // 0x1000fb5f
    __asm_out((int16_t)(256 * (int32_t)(v2 & (char)(v3 / 256)) | v3 & 255), v4);
    int32_t v5; // 0x1000fb5f
    bool v6; // 0x1000fb5f
    int32_t v7 = (v6 ? -4 : 4) + v5; // 0x1000fb66
    int32_t v8; // 0x1000fb5f
    int32_t * v9 = (int32_t *)(v8 - 0x13a1f6f); // 0x1000fb69
    int32_t v10; // 0x1000fb5f
    *v9 = *v9 | v10;
    int32_t v11 = v7 + 1; // 0x1000fb71
    int32_t v12; // 0x1000fb5f
    int32_t v13; // 0x1000fb5f
    if (v13 != 1 && v11 != 0) {
        v12 = function_1000fb59();
    }
    // 0x1000fb75
    int32_t v14; // 0x1000fb5f
    float80_t v15 = *(float80_t *)&v14; // 0x1000fb80
    __asm_fbld(v15);
    int32_t v16 = __asm_wait(); // 0x1000fb86
    unsigned char v17 = *(char *)((v16 & 255) + (int32_t)(int80_t)v15); // 0x1000fb89
    int32_t result = v16 & -0x10000 | (int32_t)v17 | 0x6400; // 0x1000fb89
    if (v12 != -1) {
        // 0x1000fb7b
        return result;
    }
    int32_t v18 = *(int32_t *)-0x67f466e | v10; // 0x1000fb8c
    *(int32_t *)(v18 - 4) = result;
    *(int32_t *)(v18 - 8) = 0;
    *(int32_t *)(v18 - 12) = 0x79be2bcc;
    *(int32_t *)(v18 - 16) = v14;
    *(int32_t *)(v18 - 20) = v18;
    int32_t v19; // 0x1000fb5f
    *(int32_t *)(v18 - 28) = v19;
    *(int32_t *)(v18 - 32) = v11;
    __asm_out(0x2bcc, result);
    *(int32_t *)(v18 - 36) = v1 / 2 | 0x80000000 * v1;
    *(int32_t *)0x7188280 = v11;
    char * v20 = (char *)v14; // 0x1000fbbb
    *v20 = *v20 ^ -54;
    int32_t v21 = v7 + 0x502086bd; // 0x1000fbbf
    int32_t v22; // 0x1000fb5f
    int32_t v23; // 0x1000fb5f
    int32_t v24; // 0x1000fb5f
    int32_t v25; // 0x1000fb5f
    int32_t v26; // 0x1000fb5f
    if (v21 == 0) {
        // 0x1000fbc8
        v26 = 64;
        v22 = 16 * (int32_t)((v11 & 15) > 19);
        v25 = 4;
        v24 = 0x7300;
        v23 = 0;
    } else {
        // 0x1000fbef
        *(int32_t *)(result - 0x50104b3) = v14;
        __asm_wait();
        int32_t v27 = v14;
        *(int32_t *)v27 = v27 | -0x4140c267;
        unsigned char v28 = *(char *)&v19; // 0x1000fc06
        unsigned char v29 = v28 / 2; // 0x1000fc06
        char v30 = llvm_ctpop_i8(v29); // 0x1000fc06
        *(char *)v19 = v29;
        v26 = 64 * (int32_t)(v28 < 2);
        v22 = 0;
        v25 = 4 * (int32_t)((v30 & 1) == 0);
        v24 = *(int32_t *)-0x2aefbce0;
        v23 = (v28 & 1) != 0;
    }
    int32_t v31 = v21 >> 31; // 0x1000fbc4
    __asm_out((int16_t)v31, v24);
    int32_t v32 = 256 * (v22 | v26 | v25 | v23) | __asm_sti() & -0xff01 | 512; // 0x1000fc0d
    *(int32_t *)(v32 - 0x7289347f) = v31;
    *(int32_t *)-1 = v32 + 1;
    *(int64_t *)-110 = (int64_t)1.0;
    return v32 + 0x53f8bc5d;
}

// Address range: 0x1000fc2a - 0x1000fc58
int32_t function_1000fc2a(void) {
    int32_t v1 = __asm_hlt(); // 0x1000fc32
    *(char *)0x395d46f7 = -38;
    char * v2 = (char *)(v1 + 16); // 0x1000fc42
    int32_t v3; // 0x1000fc2a
    *v2 = *v2 & (char)v3;
    int32_t result = __asm_wait(); // 0x1000fc46
    unsigned char v4 = *(char *)0x395d46f7 & 31; // 0x1000fc4d
    if (v4 != 0) {
        int32_t v5; // 0x1000fc2a
        char * v6 = (char *)(v5 + 1 + 4 * result); // 0x1000fc4d
        unsigned char v7 = *v6; // 0x1000fc4d
        *v6 = v7 >> v4 | v7 << 8 - v4;
    }
    int32_t v8; // 0x1000fc2a
    int32_t * v9 = (int32_t *)(8 * v8 - 0x14082136); // 0x1000fc50
    *v9 = -*v9;
    int32_t v10; // 0x1000fc2a
    __asm_into(v10);
    return result;
}

// Address range: 0x1000fc58 - 0x1000fcae
int32_t function_1000fc58(int32_t a1) {
    // 0x1000fc58
    int32_t v1; // 0x1000fc58
    __asm_out_3(125, v1);
    bool v2; // 0x1000fc58
    bool v3; // 0x1000fc58
    bool v4; // 0x1000fc58
    if (v3 == v2 != !v4) {
        // 0x1000fc5c
        return __asm_sti();
    }
    unsigned char v5 = (char)v1; // 0x1000fc9d
    int32_t v6; // 0x1000fc58
    float80_t v7; // 0x1000fc58
    *(int16_t *)(v6 - 33) = (int16_t)v7;
    int32_t v8; // 0x1000fc58
    uint32_t v9 = (v1 & -0x10000 | (int32_t)(v5 % 95) | 256 * (int32_t)(v5 / 95)) + v8; // 0x1000fca2
    int32_t result = v9 & -235; // 0x1000fca4
    *(char *)v6 = (char)result;
    int32_t v10; // 0x1000fc58
    *(char *)v10 = (char)(v9 / 256);
    return result;
}

// Address range: 0x1000fcd6 - 0x1000fcee
int32_t function_1000fcd6(void) {
    // 0x1000fcd6
    uint32_t v1; // 0x1000fcd6
    int32_t * v2 = (int32_t *)(v1 - 0x63af6e8); // 0x1000fcd6
    int32_t v3; // 0x1000fcd6
    *v2 = *v2 + v3;
    int32_t v4; // 0x1000fcd6
    char * v5 = (char *)(v4 + 0x79d1875); // 0x1000fcde
    *v5 = *v5 | (char)(v1 / 256);
    int32_t v6; // 0x1000fcd6
    int32_t v7; // 0x1000fcd6
    *(char *)v6 = *(char *)(2 * v7);
    int32_t v8 = v3 + 1; // 0x1000fce9
    int32_t v9; // 0x1000fcd6
    return v8 & -256 | (int32_t)*(char *)((v8 & 255) + v9);
}

// Address range: 0x1000fcee - 0x1000fd11
float80_t function_1000fcee(int32_t a1) {
    // 0x1000fcee
    uint32_t v1; // 0x1000fcee
    uint32_t v2; // 0x1000fcee
    int64_t v3 = 0x100000000 * (int64_t)v1 | (int64_t)v2; // 0x1000fcf0
    uint32_t v4; // 0x1000fcee
    int64_t v5 = v4; // 0x1000fcf0
    int32_t v6 = v3 / v5; // 0x1000fcf0
    int32_t v7; // 0x1000fcee
    int32_t * v8 = (int32_t *)(v7 + v6); // 0x1000fcf3
    *v8 = *v8 ^ v6;
    char * v9 = (char *)(a1 - 0x1efa4141); // 0x1000fcfb
    uint32_t v10; // 0x1000fcee
    *v9 = *v9 ^ (char)(v10 / 256);
    __asm_out((int16_t)(v3 % v5), *(int32_t *)-0x50d33157);
    float80_t v11; // 0x1000fcee
    return v11 + (float80_t)*(int16_t *)(v10 - 0x4ce0cf83);
}

// Address range: 0x1000fd15 - 0x1000fd36
int32_t function_1000fd15(int32_t a1) {
    // 0x1000fd15
    bool v1; // 0x1000fd15
    bool v2; // 0x1000fd15
    if (v1 || v2) {
        // 0x1000fd26
        int32_t v3; // 0x1000fd15
        int32_t v4; // 0x1000fd15
        *(int32_t *)v3 = v4 ^ v3;
        __asm_wait();
        int16_t v5; // 0x1000fd15
        return function_defb46d3(v5);
    }
    // 0x1000fd17
    int32_t v6; // 0x1000fd15
    *(int32_t *)-0x40411836 = *(int32_t *)-0x40411836 | v6;
    int32_t result; // 0x1000fd15
    return result;
}

// Address range: 0x1000fd42 - 0x1000fd43
int32_t function_1000fd42(int32_t a1) {
    // 0x1000fd42
    int32_t result; // 0x1000fd42
    return result;
}

// Address range: 0x1000fd56 - 0x1000fe22
int32_t function_1000fd56(void) {
    // 0x1000fd56
    uint32_t v1; // 0x1000fd56
    int16_t v2 = v1; // 0x1000fd57
    int32_t v3; // 0x1000fd56
    __asm_outsb(v2, (char)v3);
    __asm_iretd();
    char v4; // 0x1000fd56
    int32_t v5 = v4; // 0x1000fd5c
    int32_t v6; // 0x1000fd56
    int32_t result; // 0x1000fd56
    int32_t v7; // 0x1000fd56
    if (v6 != 1) {
        // 0x1000fdc3
        __asm_out(v2, v5);
        *(int32_t *)-0x5776156d = -0x57761569;
        __asm_sti();
        __asm_into(v7);
        char * v8 = (char *)(v1 - 55); // 0x1000fdd5
        *v8 = *v8 + (char)(v1 / 256);
        return result;
    }
    // 0x1000fd61
    __asm_out_3(229, v5);
    char * v9 = (char *)(v5 - 120); // 0x1000fd65
    char v10 = *v9; // 0x1000fd65
    unsigned char v11 = (char)v1; // 0x1000fd65
    char v12 = v10 + v11; // 0x1000fd65
    char v13 = llvm_ctpop_i8(v12); // 0x1000fd65
    *v9 = v12;
    __asm_out(v2, v5);
    __asm_out(v2, __asm_sti() & -0xff01 | 256 * (64 * (int32_t)(v12 == 0) | (int32_t)(-1 - v10 < v11) | 128 * (int32_t)(v12 < 0) | 16 * (int32_t)((v10 & 15) + (v11 & 15) > 15) | 4 * (int32_t)((v13 & 1) == 0)) | 512);
    __asm_into(v7);
    int32_t * v14 = (int32_t *)(result - 0x4aaf4cbc); // 0x1000fd76
    *v14 = *v14 | v1;
    int32_t v15 = *(int32_t *)(v5 + 66); // 0x1000fd7c
    int32_t * v16 = (int32_t *)(v5 + 86); // 0x1000fd7c
    int32_t v17 = *v16; // 0x1000fd7c
    int32_t v18 = v17 + 1; // 0x1000fd7d
    *v16 = *(int32_t *)(v5 + 82) + 1;
    unsigned char v19 = (char)v18; // 0x1000fd89
    int32_t v20; // 0x1000fd56
    if ((v19 & 14) > 9) {
        v20 = (v19 > 153 ? 102 : 6) + v18 & 255 | v18 & -256;
    } else {
        v20 = (v19 > 153 ? v17 + 97 : v18) & 255 | v18 & -256;
    }
    int32_t v21 = *(int32_t *)(v15 - 0x8c414c4); // 0x1000fd8a
    __asm_into(v7);
    __asm_int(114);
    int32_t result2 = v21 + v20 & 0x3d948d00 | (int32_t)*(char *)0x6585804b; // 0x1000fe1b
    *(int32_t *)v15 = result2;
    return result2;
}

// Address range: 0x1000fe22 - 0x1000fe5b
int32_t function_1000fe22(void) {
    // 0x1000fe22
    int32_t v1; // 0x1000fe22
    bool v2; // 0x1000fe22
    int32_t v3 = v1 + (int32_t)v2 - *(int32_t *)(v1 - 0x843bb3b); // 0x1000fe22
    __asm_sti();
    int32_t v4; // 0x1000fe22
    __asm_into(v4);
    int32_t v5; // 0x1000fe22
    if ((__asm_sti() || v5) >= -1) {
        function_1000fe22();
    }
    // 0x1000fe43
    int32_t v6; // 0x1000fe22
    *(int32_t *)((v3 | v6) - 1) = v3;
    *(int32_t *)(v5 + 1) = *(int32_t *)-0x20033379;
    unsigned char v7 = (char)v3; // 0x1000fe48
    int32_t v8 = v7 < 222 ? v3 : v3 + 34; // 0x1000fe48
    return (v8 & 255 | v3 & -0x10000 | 256 * (int32_t)(v7 > 221)) * v3;
}

// Address range: 0x1000fe5b - 0x1000fe75
int32_t function_1000fe5b(void) {
    // 0x1000fe5b
    int32_t v1; // 0x1000fe5b
    float80_t v2; // 0x1000fe5b
    *(int64_t *)(v1 - 85) = (int64_t)v2;
    int32_t v3; // 0x1000fe5b
    int32_t v4; // 0x1000fe5b
    char v5; // 0x1000fe5b
    char v6 = v5 | (char)(*(int32_t *)(v4 + 0x501043b8) | v3); // 0x1000fe69
    char v7 = llvm_ctpop_i8(v6); // 0x1000fe69
    int32_t v8 = __asm_sti(); // 0x1000fe6c
    int32_t v9 = (v8 & 14) > 9 ? v8 + 6 : v8; // 0x1000fe6f
    return v8 & -0x10000 | v9 & 15 | 256 * (int32_t)((v8 & 14) > 9) | 0x4000 * (int32_t)(v6 == 0) | 0x8000 * (int32_t)(v6 < 0) | 1024 * (int32_t)((v7 & 1) == 0) | 512;
}

// Address range: 0x1000fe79 - 0x1000fe7a
int32_t function_1000fe79(void) {
    // 0x1000fe79
    int32_t result; // 0x1000fe79
    return result;
}

// Address range: 0x1000fe7d - 0x1000fe7e
int32_t function_1000fe7d(void) {
    // 0x1000fe7d
    int32_t result; // 0x1000fe7d
    return result;
}

// Address range: 0x1000fe82 - 0x1000fe83
int32_t function_1000fe82(void) {
    // 0x1000fe82
    int32_t result; // 0x1000fe82
    return result;
}

// Address range: 0x1000fe97 - 0x1000fe9e
int32_t function_1000fe97(int32_t a1) {
    // 0x1000fe97
    int32_t result; // 0x1000fe97
    bool v1; // 0x1000fe97
    bool v2; // 0x1000fe97
    if (v2 == v1) {
        result = function_1000fe82();
    }
    // 0x1000fe9b
    return result;
}

// Address range: 0x1000feae - 0x1000ff63
int32_t function_1000feae(void) {
    // 0x1000feae
    int32_t v1; // 0x1000feae
    int32_t v2; // 0x1000feae
    int32_t v3 = v2 & -256 | (int32_t)__asm_in((int16_t)v1); // 0x1000feae
    int32_t * v4 = (int32_t *)(v3 + 102); // 0x1000feaf
    int32_t v5; // 0x1000feae
    *v4 = *v4 + v5;
    int32_t v6; // 0x1000feae
    int32_t * v7 = (int32_t *)(v5 + 0x97ffbce + v6); // 0x1000feb2
    *v7 = *v7 | 9;
    *(int32_t *)-0x4eba7a43 = *(int32_t *)-0x4eba7a43 | v5;
    int32_t v8; // 0x1000feae
    *(int32_t *)v8 = v3;
    bool v9; // 0x1000feae
    int32_t v10 = (v9 ? -4 : 4) + v8; // 0x1000fec0
    uint32_t v11; // 0x1000feae
    int32_t v12 = *(int32_t *)(v10 + 4 * v11) + v1; // 0x1000fec1
    int16_t v13 = v12; // 0x1000fec4
    __asm_out(v13, v3);
    int32_t v14; // 0x1000feae
    char v15 = *(char *)&v14 & (char)(v14 / 256); // 0x1000fecb
    *(char *)v14 = v15;
    __asm_out(v13, v3);
    int32_t v16 = __asm_sti(); // 0x1000fecf
    if (v5 != 1 == v15 == 0) {
        v16 = function_1000fe79();
    }
    int32_t * v17 = (int32_t *)(v10 - 47); // 0x1000fed1
    uint32_t v18 = *v17; // 0x1000fed1
    int32_t v19 = v18 - 70; // 0x1000fed1
    *v17 = v19;
    if (v5 != 2 == v19 == 0) {
        uint32_t v20 = v14; // 0x1000ff33
        v14 = v16;
        unsigned char v21 = (char)(v20 - (v18 > 69 ? 50 : 49)) - 83; // 0x1000ff36
        int32_t v22 = v5 - 3; // 0x1000ff38
        if (v22 == 0 || v21 == 0) {
            unsigned char v23 = v21 | 65;
            int32_t v24 = v20 & -256 | (int32_t)v23; // 0x1000ff3d
            *(char *)(4 * v24 + 0x4309fc20 + v6) = v23;
            char * v25 = (char *)v22; // 0x1000ff46
            char v26 = *v25; // 0x1000ff46
            unsigned char v27 = (char)(v14 / 256); // 0x1000ff46
            char v28 = v26 + v27; // 0x1000ff46
            char v29 = llvm_ctpop_i8(v28); // 0x1000ff46
            *v25 = v28;
            int32_t v30 = v24 & -0xff01 | 256 * (64 * (int32_t)(v28 == 0) | (int32_t)(-1 - v26 < v27) | 128 * (int32_t)(v28 < 0) | 16 * (int32_t)((v27 & 15) + (v26 & 15) > 15) | 4 * (int32_t)((v29 & 1) == 0)) | 512; // 0x1000ff48
            int32_t * v31 = (int32_t *)v30; // 0x1000ff49
            *v31 = *v31 & v22;
            return v30 & -256 | (int32_t)*(char *)-0x21fbef23;
        }
        unsigned char v32 = *(char *)-0x7dfefbcf + v21; // 0x1000ff52
        char * v33 = (char *)(v12 - 0x587d6980); // 0x1000ff58
        *v33 = *v33 - v32 + (char)(v32 < v21);
        return v20 & -0x10000 | (int32_t)(v32 + -28 * (char)(v20 / 256));
    }
    int32_t v34 = v16; // 0x1000feda
    if (v19 < 0 == ((v19 ^ v18) & v18 + 0x7fffffba) < 0 == (v19 != 0)) {
        v34 = function_1000fe7d();
    }
    // 0x1000fedc
    *(int32_t *)-0x577f156d = v14;
    uint32_t v35 = *(int32_t *)(v14 + 0x31637d63) + (int32_t)(v18 > 69); // 0x1000fede
    bool v36 = v18 > 69 ? v35 != -1 | v11 < v11 + (int32_t)(v18 > 69) - v35 : v11 < v35; // 0x1000fede
    int32_t v37 = *(int32_t *)-0x577f156b; // 0x1000fee4
    char * v38 = (char *)(v34 - 112); // 0x1000fee5
    *v38 = *v38 + (char)v37 + (char)v36;
    uint32_t v39 = v5 - 1; // 0x1000fee8
    char * v40 = (char *)v34; // 0x1000fee9
    *v40 = *v40 | (char)(v39 / 256);
    int32_t v41 = unknown_ce1502f9(); // 0x1000feeb
    char * v42 = (char *)(v37 + 0x41405831); // 0x1000fef9
    unsigned char v43 = *v42; // 0x1000fef9
    *v42 = v43 - 98;
    uint32_t v44 = (v41 & -256 | (int32_t)(*(char *)&v6 | (char)v41)) + 0x1dc7fb00; // 0x1000ff00
    int32_t v45 = v44 & -256; // 0x1000ff01
    char * v46 = (char *)v39; // 0x1000ff06
    unsigned char v47 = *v46; // 0x1000ff06
    unsigned char v48 = (char)(v44 / 256); // 0x1000ff06
    unsigned char v49 = v47 + v48; // 0x1000ff06
    unsigned char v50 = v49 + (char)(v43 > 97); // 0x1000ff06
    bool v51 = v43 > 97 ? v50 <= v47 : v49 < v47; // 0x1000ff06
    *v46 = v50;
    *(char *)(v10 + 29) = (char)v39;
    unsigned char v52 = *(char *)0x50090120 - 60 + (char)v51; // 0x1000ff0d
    char * v53 = (char *)(v14 + 0x1861620a); // 0x1000ff0f
    *v53 = *v53 & 5;
    int32_t * v54 = (int32_t *)(v37 + 32); // 0x1000ff16
    *v54 = v14 ^ *v54;
    char * v55 = (char *)(v45 | (int32_t)v52); // 0x1000ff19
    *v55 = *v55 - 45;
    uint32_t v56 = *(int32_t *)-0x577f1567 + 1; // 0x1000ff1d
    unsigned char v57 = v52 | 112; // 0x1000ff1e
    int32_t v58 = v45 | (int32_t)v57; // 0x1000ff1e
    unsigned char v59 = *(char *)v58 + v48; // 0x1000ff20
    char * v60 = (char *)(v37 + 73); // 0x1000ff22
    *v60 = (char)(v56 / 256);
    char * v61 = (char *)(v14 + 36); // 0x1000ff25
    *v61 = v57 + (char)(v59 < v48) + *v61;
    *(char *)(256 * (int32_t)*v60 | v56 & -0xff01) = v59;
    return 256 * (int32_t)v59 | v58 & -0xff01;
}

// Address range: 0x1000ff64 - 0x1000ff80
int32_t function_1000ff64(void) {
    // 0x1000ff64
    int32_t v1; // 0x1000ff64
    uint32_t v2 = v1 & 31; // 0x1000ff67
    if (v2 != 0) {
        uint32_t v3; // 0x1000ff64
        *(int32_t *)v3 = v3 >> 32 - v2 | v3 << v2;
    }
    int32_t v4; // 0x1000ff64
    *(char *)v4 = (char)v4;
    int32_t v5; // 0x1000ff64
    int32_t result = v5 & -256 | 85; // 0x1000ff74
    char * v6 = (char *)(result - 0x426b096e); // 0x1000ff76
    unsigned char v7 = *v6; // 0x1000ff76
    *v6 = v7 / 32 | 16 * v7;
    return result;
}

// Address range: 0x1000ff81 - 0x1000ffd0
int32_t function_1000ff81(void) {
    // 0x1000ff81
    int32_t v1; // 0x1000ff81
    int32_t v2 = &v1; // 0x1000ff87
    uint16_t v3 = (int16_t)v2; // 0x1000ff89
    int32_t v4; // 0x1000ff81
    uint16_t v5 = (int16_t)v4 & 255; // 0x1000ff89
    int32_t v6; // 0x1000ff81
    uint32_t v7; // 0x1000ff81
    *(int32_t *)v6 = __asm_insd((int16_t)v7);
    int32_t v8; // 0x1000ff81
    int32_t v9 = v8 & -0x10000 | v8 + 249 & 255 | 0xb200; // 0x1000ff8f
    uint32_t v10 = *(int32_t *)(v9 + 4 * v7); // 0x1000ff92
    int32_t v11 = v7 < v10 ? -0x4a908252 : -0x4a908251; // 0x1000ff95
    int32_t v12 = (v2 & -0x10000 | (int32_t)(v3 / v5 & 255) | (int32_t)(256 * (v3 % v5))) - 0x6c4b45c4 + v11; // 0x1000ff9f
    int32_t v13 = v7 - v10; // 0x1000ff9f
    while (true) {
        // 0x1000ffa4
        int32_t v14; // 0x1000ff81
        int32_t v15 = v14;
        __asm_out_7((int16_t)v13, (char)v12);
        int32_t v16; // 0x1000ff81
        int32_t v17 = v16 - 2; // 0x1000ffa5
        int32_t v18; // 0x1000ff81
        int32_t v19 = v18 + 1; // 0x1000ffa6
        char * v20 = (char *)v12; // 0x1000ffa7
        *v20 = *v20 - 78;
        int32_t * v21 = (int32_t *)v12; // 0x1000ffa9
        *v21 = *v21 - 1;
        int32_t v22 = *(int32_t *)(v12 & -140); // 0x1000ffad
        *(int32_t *)-0x7daffb0f = *(int32_t *)-0x7daffb0f + v13;
        char * v23 = (char *)(v17 + v13); // 0x1000ffb9
        *v23 = *v23 | -78;
        uint32_t v24 = *(int32_t *)(v9 - 0x26719330); // 0x1000ffbc
        int32_t v25 = v24 + v15; // 0x1000ffbc
        char v26 = llvm_ctpop_i8((char)v25); // 0x1000ffbc
        char * v27 = (char *)(v13 - 66); // 0x1000ffc3
        unsigned char v28 = *v27; // 0x1000ffc3
        *v27 = v28 - 62;
        v13 -= 61;
        v18 = v19;
        v12 = v22 & -0xff01 | 256 * (64 * (int32_t)(v25 == 0) | (int32_t)(v24 > -1 - v15) | 128 * (int32_t)(v25 < 0) | 16 * (int32_t)((v24 & 15) + (v15 & 15) > 15) | 4 * (int32_t)((v26 & 1) == 0)) | 512;
        v14 = v25;
        v16 = v17 + (int32_t)(v28 > 61) + *(int32_t *)v19;
    }
}

// Address range: 0x10010003 - 0x10010006
int32_t function_10010003(int32_t a1) {
    // 0x10010003
    int32_t result; // 0x10010003
    return result;
}

// Address range: 0x18fc1b2e - 0x18fc1b2f
int32_t function_18fc1b2e(void) {
    // 0x18fc1b2e
    int32_t result; // 0x18fc1b2e
    return result;
}

// Address range: 0x20100313 - 0x20100314
int32_t function_20100313(void) {
    // 0x20100313
    int32_t result; // 0x20100313
    return result;
}

// Address range: 0x20102618 - 0x20102619
int32_t function_20102618(void) {
    // 0x20102618
    int32_t result; // 0x20102618
    return result;
}

// Address range: 0x21100900 - 0x21100901
int32_t function_21100900(void) {
    // 0x21100900
    int32_t result; // 0x21100900
    return result;
}

// Address range: 0x2112081b - 0x2112081c
int32_t function_2112081b(void) {
    // 0x2112081b
    int32_t result; // 0x2112081b
    return result;
}

// Address range: 0x26e9350c - 0x26e9350d
int32_t function_26e9350c(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x26e9350c
    int32_t result; // 0x26e9350c
    return result;
}

// Address range: 0x408e86e0 - 0x408e86e1
int32_t function_408e86e0(void) {
    // 0x408e86e0
    int32_t result; // 0x408e86e0
    return result;
}

// Address range: 0x40fc2dae - 0x40fc2daf
int32_t function_40fc2dae(void) {
    // 0x40fc2dae
    int32_t result; // 0x40fc2dae
    return result;
}

// Address range: 0x430af841 - 0x430af842
int32_t function_430af841(void) {
    // 0x430af841
    int32_t result; // 0x430af841
    return result;
}

// Address range: 0x50f83311 - 0x50f83312
int32_t function_50f83311(void) {
    // 0x50f83311
    int32_t result; // 0x50f83311
    return result;
}

// Address range: 0x538bd497 - 0x538bd498
int32_t function_538bd497(void) {
    // 0x538bd497
    int32_t result; // 0x538bd497
    return result;
}

// Address range: 0x5d856cf6 - 0x5d856cf7
int32_t function_5d856cf6(void) {
    // 0x5d856cf6
    int32_t result; // 0x5d856cf6
    return result;
}

// Address range: 0x5f04685d - 0x5f04685e
int32_t function_5f04685d(void) {
    // 0x5f04685d
    int32_t result; // 0x5f04685d
    return result;
}

// Address range: 0x5f4c0d41 - 0x5f4c0d42
int32_t function_5f4c0d41(void) {
    // 0x5f4c0d41
    int32_t result; // 0x5f4c0d41
    return result;
}

// Address range: 0x5f4c1369 - 0x5f4c136a
int32_t function_5f4c1369(void) {
    // 0x5f4c1369
    int32_t result; // 0x5f4c1369
    return result;
}

// Address range: 0x6011fd41 - 0x6011fd42
int32_t function_6011fd41(int32_t a1) {
    // 0x6011fd41
    int32_t result; // 0x6011fd41
    return result;
}

// Address range: 0x64838f02 - 0x64838f03
int32_t function_64838f02(void) {
    // 0x64838f02
    int32_t result; // 0x64838f02
    return result;
}

// Address range: 0x659d7799 - 0x659d779a
int32_t function_659d7799(void) {
    // 0x659d7799
    int32_t result; // 0x659d7799
    return result;
}

// Address range: 0x6d04b19d - 0x6d04b19e
int32_t function_6d04b19d(void) {
    // 0x6d04b19d
    int32_t result; // 0x6d04b19d
    return result;
}

// Address range: 0x7d986499 - 0x7d98649a
int32_t function_7d986499(int32_t * a1) {
    // 0x7d986499
    int32_t result; // 0x7d986499
    return result;
}

// Address range: 0x81afbfe9 - 0x81afbfea
int32_t function_81afbfe9(void) {
    // 0x81afbfe9
    int32_t result; // 0x81afbfe9
    return result;
}

// Address range: 0x8339657e - 0x8339657f
int32_t function_8339657e(void) {
    // 0x8339657e
    int32_t result; // 0x8339657e
    return result;
}

// Address range: 0x83d86165 - 0x83d86166
int32_t function_83d86165(int32_t a1) {
    // 0x83d86165
    int32_t result; // 0x83d86165
    return result;
}

// Address range: 0x848da803 - 0x848da804
int32_t function_848da803(int32_t a1, int32_t a2, int32_t a3, int16_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int16_t a9) {
    // 0x848da803
    int32_t result; // 0x848da803
    return result;
}

// Address range: 0x859a3b22 - 0x859a3b23
int32_t function_859a3b22(void) {
    // 0x859a3b22
    int32_t result; // 0x859a3b22
    return result;
}

// Address range: 0x862bafd7 - 0x862bafd8
int32_t function_862bafd7(void) {
    // 0x862bafd7
    int32_t result; // 0x862bafd7
    return result;
}

// Address range: 0x881eb438 - 0x881eb439
int32_t function_881eb438(void) {
    // 0x881eb438
    int32_t result; // 0x881eb438
    return result;
}

// Address range: 0x8ae809aa - 0x8ae809ab
int32_t function_8ae809aa(void) {
    // 0x8ae809aa
    int32_t result; // 0x8ae809aa
    return result;
}

// Address range: 0x939881e9 - 0x939881ea
int32_t function_939881e9(void) {
    // 0x939881e9
    int32_t result; // 0x939881e9
    return result;
}

// Address range: 0x970ba832 - 0x970ba833
int32_t function_970ba832(void) {
    // 0x970ba832
    int32_t result; // 0x970ba832
    return result;
}

// Address range: 0x996e57db - 0x996e57dc
int32_t function_996e57db(void) {
    // 0x996e57db
    int32_t result; // 0x996e57db
    return result;
}

// Address range: 0x99a0aee4 - 0x99a0aee5
int32_t function_99a0aee4(void) {
    // 0x99a0aee4
    int32_t result; // 0x99a0aee4
    return result;
}

// Address range: 0xa0b6c769 - 0xa0b6c76a
int32_t function_a0b6c769(void) {
    // 0xa0b6c769
    int32_t result; // 0xa0b6c769
    return result;
}

// Address range: 0xa1101dfb - 0xa1101dfc
int32_t function_a1101dfb(void) {
    // 0xa1101dfb
    int32_t result; // 0xa1101dfb
    return result;
}

// Address range: 0xa8140a05 - 0xa8140a06
int32_t function_a8140a05(void) {
    // 0xa8140a05
    int32_t result; // 0xa8140a05
    return result;
}

// Address range: 0xbfd67d2f - 0xbfd67d30
int32_t function_bfd67d2f(void) {
    // 0xbfd67d2f
    int32_t result; // 0xbfd67d2f
    return result;
}

// Address range: 0xbfd8060b - 0xbfd8060c
int32_t function_bfd8060b(void) {
    // 0xbfd8060b
    int32_t result; // 0xbfd8060b
    return result;
}

// Address range: 0xbfd82e63 - 0xbfd82e64
int32_t function_bfd82e63(void) {
    // 0xbfd82e63
    int32_t result; // 0xbfd82e63
    return result;
}

// Address range: 0xc382b151 - 0xc382b152
int32_t function_c382b151(void) {
    // 0xc382b151
    int32_t result; // 0xc382b151
    return result;
}

// Address range: 0xc4b397e7 - 0xc4b397e8
int32_t function_c4b397e7(void) {
    // 0xc4b397e7
    int32_t result; // 0xc4b397e7
    return result;
}

// Address range: 0xc5bf3eed - 0xc5bf3eee
int32_t function_c5bf3eed(void) {
    // 0xc5bf3eed
    int32_t result; // 0xc5bf3eed
    return result;
}

// Address range: 0xc83510b6 - 0xc83510b7
int32_t function_c83510b6(void) {
    // 0xc83510b6
    int32_t result; // 0xc83510b6
    return result;
}

// Address range: 0xc8d61b19 - 0xc8d61b1a
int32_t function_c8d61b19(void) {
    // 0xc8d61b19
    int32_t result; // 0xc8d61b19
    return result;
}

// Address range: 0xc8ef5fdf - 0xc8ef5fe0
int32_t function_c8ef5fdf(void) {
    // 0xc8ef5fdf
    int32_t result; // 0xc8ef5fdf
    return result;
}

// Address range: 0xc9b23e0d - 0xc9b23e0e
int32_t function_c9b23e0d(void) {
    // 0xc9b23e0d
    int32_t result; // 0xc9b23e0d
    return result;
}

// Address range: 0xccdf35e9 - 0xccdf35ea
int32_t function_ccdf35e9(void) {
    // 0xccdf35e9
    int32_t result; // 0xccdf35e9
    return result;
}

// Address range: 0xccdf3b3d - 0xccdf3b3e
int32_t function_ccdf3b3d(void) {
    // 0xccdf3b3d
    int32_t result; // 0xccdf3b3d
    return result;
}

// Address range: 0xd693b9bf - 0xd693b9c0
int32_t function_d693b9bf(void) {
    // 0xd693b9bf
    int32_t result; // 0xd693b9bf
    return result;
}

// Address range: 0xd7759eab - 0xd7759eac
int32_t function_d7759eab(void) {
    // 0xd7759eab
    int32_t result; // 0xd7759eab
    return result;
}

// Address range: 0xd888f01c - 0xd888f01d
int32_t function_d888f01c(void) {
    // 0xd888f01c
    int32_t result; // 0xd888f01c
    return result;
}

// Address range: 0xd923f68f - 0xd923f690
int32_t function_d923f68f(void) {
    // 0xd923f68f
    int32_t result; // 0xd923f68f
    return result;
}

// Address range: 0xdefb46d3 - 0xdefb46d4
int32_t function_defb46d3(int16_t a1) {
    // 0xdefb46d3
    int32_t result; // 0xdefb46d3
    return result;
}

// Address range: 0xdfeff415 - 0xdfeff416
int32_t function_dfeff415(int32_t a1) {
    // 0xdfeff415
    int32_t result; // 0xdfeff415
    return result;
}

// Address range: 0xe1100804 - 0xe1100805
int32_t function_e1100804(void) {
    // 0xe1100804
    int32_t result; // 0xe1100804
    return result;
}

// Address range: 0xe3c821de - 0xe3c821df
int32_t function_e3c821de(int32_t a1) {
    // 0xe3c821de
    int32_t result; // 0xe3c821de
    return result;
}

// Address range: 0xeb9dd052 - 0xeb9dd053
int32_t function_eb9dd052(int16_t a1) {
    // 0xeb9dd052
    int32_t result; // 0xeb9dd052
    return result;
}

// Address range: 0xec4dffe4 - 0xec4dffe5
int32_t function_ec4dffe4(void) {
    // 0xec4dffe4
    int32_t result; // 0xec4dffe4
    return result;
}

// Address range: 0xef4d59b8 - 0xef4d59b9
int32_t function_ef4d59b8(void) {
    // 0xef4d59b8
    int32_t result; // 0xef4d59b8
    return result;
}

// Address range: 0xefed5692 - 0xefed5693
int32_t function_efed5692(void) {
    // 0xefed5692
    int32_t result; // 0xefed5692
    return result;
}

// Address range: 0xf589cf09 - 0xf589cf0a
int32_t function_f589cf09(void) {
    // 0xf589cf09
    int32_t result; // 0xf589cf09
    return result;
}

// Address range: 0xfb8dba02 - 0xfb8dba03
int32_t function_fb8dba02(void) {
    // 0xfb8dba02
    int32_t result; // 0xfb8dba02
    return result;
}

// Address range: 0xfbf7bf95 - 0xfbf7bf96
int32_t function_fbf7bf95(void) {
    // 0xfbf7bf95
    int32_t result; // 0xfbf7bf95
    return result;
}

// Address range: 0xfc95d1e3 - 0xfc95d1e4
int32_t function_fc95d1e3(void) {
    // 0xfc95d1e3
    int32_t result; // 0xfc95d1e3
    return result;
}

// Address range: 0xfd81bf13 - 0xfd81bf14
int32_t function_fd81bf13(void) {
    // 0xfd81bf13
    int32_t result; // 0xfd81bf13
    return result;
}

// Address range: 0xfff819a4 - 0xfff819a5
int32_t function_fff819a4(int32_t a1, int32_t a2, int32_t * a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0xfff819a4
    int32_t result; // 0xfff819a4
    return result;
}

// Address range: 0xfff81cf8 - 0xfff81cf9
int32_t function_fff81cf8(void) {
    // 0xfff81cf8
    int32_t result; // 0xfff81cf8
    return result;
}

// Address range: 0xffffb8a3 - 0xffffb8a4
int32_t function_ffffb8a3(void) {
    // 0xffffb8a3
    int32_t result; // 0xffffb8a3
    return result;
}

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (7.1)
// Detected functions: 215
